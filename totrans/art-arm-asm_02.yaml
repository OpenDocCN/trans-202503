- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 1 HELLO, WORLD OF ASSEMBLY LANGUAGE
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 汇编语言的世界，你好
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This “quick-start” chapter gets you writing basic assembly language programs
    as rapidly as possible, giving you the skills you need to learn new assembly language
    features in the following chapters. You’ll learn the foundations of 64-bit ARM
    architecture and the basic syntax of the GNU assembler (Gas) program, a compiler
    for assembly language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个“快速入门”章节，旨在让您尽可能快速地开始编写基本的汇编语言程序，为您学习后续章节中的新汇编语言特性提供必要的技能。您将学习64位ARM架构的基础知识以及GNU汇编器（Gas）程序的基本语法，Gas是一个汇编语言编译器。
- en: You’ll also learn to set aside memory for variables, control the CPU by using
    machine instructions, and link a Gas program with C/C++ code so that you can call
    routines in the C standard library (C stdlib). Gas running under Linux and macOS
    is by far the most common assembler for writing real-world ARM assembly language
    programs. Vendors (especially Apple) have produced variants of Gas with slightly
    different syntax; for instance, under macOS, Gas is known as the *Clang* or *Mach-O*
    assembler. To make the source code in this book portable between macOS and Linux,
    this chapter also introduces a header file, *aoaa.inc*, that eliminates the differences
    between Gas and the Clang assembler.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将学习为变量分配内存、通过使用机器指令控制CPU，并将Gas程序与C/C++代码链接，以便调用C标准库（C stdlib）中的例程。Linux和macOS下运行的Gas汇编器是编写实际ARM汇编语言程序最常用的汇编器。供应商（特别是苹果公司）生产了Gas的变体，具有略微不同的语法；例如，在macOS下，Gas被称为*Clang*或*Mach-O*汇编器。为了使本书中的源代码能够在macOS和Linux之间可移植，本章还介绍了一个头文件*aoaa.inc*，它消除了Gas和Clang汇编器之间的差异。
- en: 1.1 What You’ll Need
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1 您需要的工具
- en: To learn assembly language programming with Gas, you’ll need a version of the
    assembler for your platform, plus a text editor for creating and modifying Gas
    source files, a linker, various library files, and a C++ compiler. You’ll learn
    to set up the Gas assembler and text editor in this section, and the other tools
    later in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Gas学习汇编语言编程，您需要为您的平台准备一个汇编器版本，以及一个文本编辑器，用于创建和修改Gas源文件，还有一个链接器、各种库文件和一个C++编译器。您将在本节中学习如何设置Gas汇编器和文本编辑器，其他工具将在本章后续部分介绍。
- en: 1.1.1 Setting Up Gas
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1 设置Gas
- en: The GNU Compiler Collection (GCC) emits Gas source code as its output (which
    Gas then converts to object code). Therefore, if you have the compiler suite running
    on your system, you also have Gas. Apple macOS uses a compiler based on the LLVM
    compiler suite rather than GCC, so if you have a macOS, you’ll need to install
    its Xcode integrated development environment (IDE) to gain access to the assembler
    (see [Appendix C](appendix-C.xhtml)). Otherwise, if you don’t have the GCC compiler,
    install it with the instructions in your operating system (OS) documentation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: GNU编译器集合（GCC）将Gas源代码作为其输出（然后Gas将其转换为目标代码）。因此，如果您的系统上已经安装了编译器套件，那么您也就拥有了Gas。苹果macOS使用基于LLVM编译器套件的编译器，而不是GCC，因此如果您使用macOS，您需要安装其Xcode集成开发环境（IDE）以访问汇编器（见[附录C](appendix-C.xhtml)）。如果没有GCC编译器，请根据您的操作系统（OS）文档中的说明安装它。
- en: NOTE
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The GNU assembler and the Clang assembler’s executable name is actually* as
    *(assembler). The examples in this book rarely invoke the assembler directly,
    so you won’t use the* as *program often. Therefore, this book refers to the assembler
    by using the name* Gas *rather than* as *(or Clang assembler).*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*GNU汇编器和Clang汇编器的可执行文件名实际上是*as*（汇编器）。本书中的示例很少直接调用汇编器，因此您不会经常使用*as*程序。因此，本书使用*Gas*而不是*as*（或Clang汇编器）来指代汇编器。*'
- en: 1.1.2 Setting Up a Text Editor
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2 设置文本编辑器
- en: To write ARM assembly language programs, you will need some sort of programmer’s
    text editor to create assembly language source files. The choice of editor is
    dictated by personal tastes and editor availability for your OS or development
    suite.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写ARM汇编语言程序，您需要某种程序员文本编辑器来创建汇编语言源文件。编辑器的选择取决于个人喜好以及操作系统或开发套件中可用的编辑器。
- en: The standard suffix for assembly language source files is *.s*, since GCC emits
    this suffix when it converts a C/C++ file into assembly language during compilation.
    For handwritten assembly language source files, the *.S* suffix is a better choice,
    since it tells the assembler to route the source file through the C preprocessor
    (CPP) before assembly. Since this allows the use of CPP macros (#define statements),
    conditional compilation, and other facilities, all example files in this book
    use *.S*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言源文件的标准后缀是 *.s*，因为在编译时，GCC 会在将 C/C++ 文件转换为汇编语言时发出这个后缀。对于手写的汇编语言源文件，*.S* 后缀是更好的选择，因为它告诉汇编器在汇编之前通过
    C 预处理器（CPP）处理源文件。由于这样可以使用 CPP 宏（#define 语句）、条件编译和其他功能，因此本书中的所有示例文件都使用 *.S*。
- en: GCC always produces assembly language output files, which are then processed
    by Gas. GCC automatically invokes the assembler and then deletes the assembly
    source file after the assembly is complete.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 总是生成汇编语言输出文件，然后由 Gas 处理。GCC 会自动调用汇编器，并在汇编完成后删除汇编源文件。
- en: 1.1.3 Understanding C/C++ Examples
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3 理解 C/C++ 示例
- en: Today’s software engineers drop into assembly language only when their C/C++,
    C#, Java, Swift, or Python code is running too slowly and they need to improve
    the performance of certain modules or functions. The examples in this book use
    C/C++ because you’ll typically interface assembly language with C/C++ or other
    high-level language (HLL) code in the real world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现代软件工程师只有在 C/C++、C#、Java、Swift 或 Python 代码运行得过慢，需要提升某些模块或函数的性能时，才会进入汇编语言。书中的示例使用
    C/C++，因为在实际应用中，你通常会将汇编语言与 C/C++ 或其他高级语言（HLL）代码进行接口对接。
- en: The C/C++ standard library is another good reason to use this language. To make
    the C stdlib immediately accessible to Gas programs, I present examples with a
    short C++ main function that calls a single external function written in assembly
    language using Gas. Compiling the C++ main program along with the Gas source file
    produces a single executable file that you can run and test.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 标准库是使用该语言的另一个重要原因。为了让 C 标准库能够立即在 Gas 程序中使用，我提供了一个示例，其中包含一个简短的 C++ 主函数，该函数调用一个用汇编语言编写的外部函数（使用
    Gas）。将 C++ 主程序与 Gas 源文件一起编译，生成一个单独的可执行文件，你可以运行并进行测试。
- en: This book spoon-feeds you the C++ you’ll need to run the example HLL programs,
    so you’ll be able to follow even if you’re not fluent in the language. However,
    you’ll have an easier time if you have a little prior familiarity with C/C++.
    At minimum, this book assumes that you have some experience in a language such
    as Pascal (or Delphi), Java, Swift, Rust, BASIC, Python, or any other imperative
    or object-oriented programming language.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书会手把手地教你运行示例高级语言程序所需的 C++，即使你不精通该语言，也能跟得上。不过，如果你对 C/C++ 有一点基础，会更加容易理解。本书至少假设你有使用
    Pascal（或 Delphi）、Java、Swift、Rust、BASIC、Python 或其他任何命令式或面向对象的编程语言的经验。
- en: 1.2 The Anatomy of an Assembly Language Program
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2 汇编语言程序的结构
- en: A typical (stand-alone) Gas program takes the form shown in Listing 1-1.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的（独立的）Gas 程序呈现出示例 1-1 所示的形式。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assembly language programs are broken into *sections*. Some sections contain
    data, some contain constants, some contain machine instruction (executable statements),
    and so on. Listing 1-1 contains a single code section, called *text* in macOS
    and Linux. The .text statement ❶ tells the assembler that the following statements
    are associated with the code section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言程序被分为*段*。有些段包含数据，有些包含常量，有些包含机器指令（可执行语句），依此类推。示例 1-1 包含一个单独的代码段，在 macOS 和
    Linux 中称为*text*。`.text` 语句 ❶ 告诉汇编器，接下来的语句属于代码段。
- en: 'In assembly language source files, symbols are usually local or private to
    a source file. When creating an executable source file, you must pass one or more
    symbols to the system linker—at least the name of the main program. You can accomplish
    this by using the .global statement, specifying the global name as an operand:
    _main in the macOS case, main in the Linux case. Leaving out this statement gives
    you an error when you try to compile the source file.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言源文件中，符号通常是局部的或私有的，仅限于某个源文件。在创建可执行源文件时，你必须将一个或多个符号传递给系统链接器——至少是主程序的名称。你可以通过使用
    `.global` 语句来实现，并将全局名称作为操作数指定：在 macOS 中为 _main，在 Linux 中为 main。如果省略这个语句，在尝试编译源文件时会出现错误。
- en: The ARM instruction set requires all machine instructions to begin on a 32-bit
    (4-byte) boundary in memory. Therefore, before the first machine instruction in
    a .text section, tell the assembler to align the addresses on a 4-byte boundary.
    The .align statement ❷ raises 2 to the power specified by its operand and aligns
    the next instruction on that boundary. Since 2² is equal to 4, this statement
    aligns the next instruction on a 4-byte boundary.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 指令集要求所有机器指令在内存中以 32 位（4 字节）边界开始。因此，在 .text 区段中的第一条机器指令之前，您需要告诉汇编器将地址对齐到
    4 字节边界。 .align 语句 ❷ 将其操作数指定的指数作为 2 的幂来对齐下一条指令。由于 2² 等于 4，因此此语句将下一条指令对齐到 4 字节边界。
- en: 'A procedure, or function, in ARM assembly simply consists of the name of that
    function (_main or main in this case) followed by a colon. The machine instructions
    follow. The main program in this example consists of a single machine instruction:
    ret (return). This instruction immediately returns control to whatever called
    the main program—that is, the OS.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ARM 汇编中，一个过程或函数仅由该函数的名称（此例中为_main 或 main）后跟冒号组成。接下来是机器指令。此示例中的主程序由一条机器指令组成：ret（返回）。该指令立即将控制权返回给调用主程序的地方——即操作系统。
- en: Identifiers in Gas are similar to identifiers in most HLLs. Gas identifiers
    may begin with a dollar sign ($), an underscore (_), or an alphabetic character
    and may be followed by zero or more alphanumeric, dollar sign, or underscore characters.
    Symbols are case sensitive.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 中的标识符类似于大多数高级语言中的标识符。Gas 标识符可以以美元符号（$）、下划线（_）或字母字符开头，并且可以后跟零个或多个字母数字、美元符号或下划线字符。符号区分大小写。
- en: While the program in Listing 1-1 doesn’t really *do* anything, you can use it
    to learn how to use the assembler, linker, and other tools necessary for writing
    ARM assembly language programs, as we’ll do in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然清单 1-1 中的程序实际上什么也不做，但您可以通过它学习如何使用汇编器、链接器以及编写 ARM 汇编语言程序所需的其他工具，正如我们将在下一节中所做的那样。
- en: 1.3 Running Your First Assembly Language Program
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3 运行您的第一个汇编语言程序
- en: 'Once you have an assembly source file, you can compile and run that program.
    In theory, you could run the assembler (as) and then the linker (ld, supplying
    appropriate library files needed by the OS). Here’s how that would look for macOS
    (where the $ appearing at the beginning of each line is the OS’s shell prompt):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了汇编源文件，就可以编译并运行该程序。理论上，您可以先运行汇编器（as），然后再运行链接器（ld，提供操作系统所需的适当库文件）。以下是在 macOS
    上的操作示例（每行开头的 $ 是操作系统的 shell 提示符）：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, the command lines differ depending on your OS, and producing an executable
    in this way takes a lot of typing. An easier way to compile the program and produce
    an executable is to use the GCC compiler (g++) by running this command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，命令行在不同的操作系统中有所不同，而且以这种方式生成可执行文件需要大量的输入。更简单的编译程序并生成可执行文件的方法是使用 GCC 编译器（g++），通过运行以下命令：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command line even works on macOS, which uses the Clang compiler rather
    than GCC; macOS has an alias for Clang named g++. On macOS, you could also use
    the clang -o Listing1-1 Listing1-1.S command line. This book, however, will stick
    to the g++ command line, as that works on macOS and Linux.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令行甚至可以在 macOS 上运行，macOS 使用 Clang 编译器而不是 GCC；macOS 为 Clang 创建了一个名为 g++ 的别名。在
    macOS 上，您也可以使用 clang -o Listing1-1 Listing1-1.S 命令行。不过，本书将坚持使用 g++ 命令行，因为它在 macOS
    和 Linux 上都有效。
- en: The g++ command is smart enough to note that this is an assembly language source
    file and run Gas on it to produce an object file. GCC will then run the linker
    (ld) and supply all the default libraries the OS requires.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: g++ 命令足够智能，能够识别这是一个汇编语言源文件，并运行 Gas 来生成目标文件。GCC 接着会运行链接器（ld），并提供操作系统所需的所有默认库。
- en: 'You can run the resulting executable file from the command line as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式从命令行运行生成的可执行文件：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This program immediately returns without any output, since that’s all Listing
    1-1 does; it’s simply intended to demonstrate how to compile and run ARM assembly
    language programs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序立即返回且没有任何输出，因为清单 1-1 只做这件事；它仅仅是用来演示如何编译和运行 ARM 汇编语言程序的。
- en: 'In addition to reducing the amount of typing required, using g++ to assemble
    your assembly language source files provides another advantage: it’s the easiest
    way to run the CPP, which many of the example files in this book require. You
    can invoke the CPP (by itself) on an assembly source file by using a command like
    the following, to see the modifications the CPP makes to your assembly source
    files:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减少所需输入的字符数外，使用g++来汇编你的汇编语言源文件还提供了另一个好处：它是运行CPP的最简单方式，而本书中的许多示例文件都需要这个CPP。你可以像下面这样单独调用CPP来处理汇编源文件，以查看CPP对你的汇编源文件所做的修改：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can even pipe the output from the CPP to Gas, using the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用以下命令将CPP的输出通过管道传递给Gas：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, at that point, you may as well have typed
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在那时，你完全可以输入
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: as it’s shorter and easier to input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它更短且更易于输入。
- en: 1.4 Running Your First Gas/C++ Hybrid Program
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4 运行你的第一个Gas/C++混合程序
- en: This book commonly combines an assembly language module containing one or more
    functions written in assembly language with a C/C++ main program that calls those
    functions. Because the compilation and execution process is slightly different
    from a stand-alone Gas program, this section demonstrates how to create, compile,
    and run a hybrid assembly/C++ program. Listing 1-2 provides the main C++ program
    that calls the assembly language module.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书通常将包含一个或多个用汇编语言编写的函数的汇编语言模块与一个调用这些函数的C/C++主程序相结合。由于编译和执行过程与独立的Gas程序略有不同，本节将演示如何创建、编译和运行一个混合汇编/C++程序。列表1-2提供了调用汇编语言模块的主要C++程序。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 1-3, a slight modification of the stand-alone Gas program, contains
    the asmMain() function that the C++ program calls. The main difference between
    Listing 1-3 and Listing 1-1 is that the function’s name changes from _main to
    _asmMain. The C++ compiler and linker would get confused if we continued to use
    the name _main, as that’s also the name of the C++ main function.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-3是一个稍微修改过的独立Gas程序，其中包含C++程序调用的asmMain()函数。列表1-3和列表1-1之间的主要区别是函数名从_main更改为_asmMain。如果我们继续使用_main这个名字，C++编译器和链接器会感到困惑，因为_main也是C++主函数的名称。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, to compile and run these source files, run the following commands:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了编译和运行这些源文件，请运行以下命令：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Granted, this assembly language example doesn’t accomplish much other than demonstrate
    how to compile and run some assembly code. To write real assembly code, you’re
    going to need a lot of support code. The next section describes the *aoaa.inc*
    header file that provides some of this support.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这个汇编语言示例除了演示如何编译和运行一些汇编代码外，并没有做太多其他事情。要编写真正的汇编代码，你需要大量的支持代码。下一节将介绍提供部分支持的*aoaa.inc*头文件。
- en: 1.5 The aoaa.inc Include File
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5 aoaa.inc包含文件
- en: The example code in this book was written to be as portable between macOS and
    Linux assemblers as possible, a difficult task requiring considerable advanced
    behind-the-scenes trickery. Many of those tricks are a bit too advanced to easily
    explain to beginning ARM programmers, so I’ve incorporated all this magic code
    in a special header file, *aoaa.inc*, that I use in most of the example programs
    from this point forward.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例代码旨在尽可能使macOS和Linux汇编器之间的代码具有可移植性，这是一项艰巨的任务，需要相当多的幕后高级技巧。许多这些技巧对于初学者ARM程序员来说有些过于高级，因此我将所有这些魔法代码包含在一个特殊的头文件*aoaa.inc*中，从此以后我会在大部分示例程序中使用它。
- en: 'This human-readable include file is little more than a typical advanced C/C++
    header file; it just contains a bunch of macros (for example, C/C++ #define statements)
    that help smooth out some of the differences between the macOS and Linux versions
    of the assembler. By the time you get to the end of this book (especially by the
    time you read [Chapter 13](chapter13.xhtml)), most of the material in the header
    file will make perfect sense. For now, I won’t distract you with advanced macros
    and conditional assembly information.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个人类可读的包含文件几乎和典型的高级C/C++头文件一样；它仅包含一些宏（例如C/C++的#define语句），帮助平滑处理macOS和Linux版本的汇编器之间的差异。当你读到本书的最后（特别是当你阅读[第13章](chapter13.xhtml)时），头文件中的大部分内容将变得完全清晰。现在，我不会用高级宏和条件汇编的信息来分散你的注意力。
- en: You can find *aoaa.inc* along with all the other example code at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*.
    If you’re curious about this file’s content and don’t want to wait for [Chapter
    13](chapter13.xhtml), load it into a text editor and take a look.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在* [https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)
    *找到*aoaa.inc*及所有其他示例代码。如果你对这个文件的内容感兴趣，并且不想等到[第13章](chapter13.xhtml)，可以将其加载到文本编辑器中查看。
- en: 'To include this file in an assembly, use the following CPP statement in your
    assembly language source files:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要在汇编中包含此文件，请在你的汇编语言源文件中使用以下 CPP 语句：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just as in C/C++, this statement will automatically insert the content of this
    file into the current source file during assembly (at the point of the #include
    statement).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '就像在 C/C++ 中一样，这条语句将在汇编时自动将该文件的内容插入到当前源文件中（在 #include 语句处）。'
- en: 'Gas has its own include statement, used as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 有自己的 include 语句，使用方法如下：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, don’t use this statement to include *aoaa.inc* in your source files.
    The Gas .include directive executes after the CPP runs, but *aoaa.inc* contains
    CPP macros, conditional compilation statements, and other code that must be processed
    by the CPP. If you use the .include directive rather than #include, the CPP will
    never see the contents of the *aoaa.inc* file, and Gas will generate errors when
    it processes the file.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，不要使用这个语句在源文件中包含 *aoaa.inc*。Gas 的 .include 指令在 CPP 运行之后执行，但 *aoaa.inc* 包含
    CPP 宏、条件编译语句和其他必须由 CPP 处理的代码。如果你使用 .include 指令而不是 #include，CPP 将无法看到 *aoaa.inc*
    文件的内容，而 Gas 在处理该文件时会产生错误。'
- en: 'The *aoaa.inc* file must be present in the same directory as your assembly
    source file during the assembly process (or you must supply an appropriate path
    to the file in the #include "aoaa.inc" statement). If the header file isn’t in
    the current directory, Gas will complain that it can’t find the file and terminate
    the assembly. Also remember to use the *.S* suffix with your assembly source files
    when using #include "aoaa.inc", or GCC won’t run the CPP on those files.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '在汇编过程中，*aoaa.inc* 文件必须与汇编源文件位于同一目录（或者你必须在 #include "aoaa.inc" 语句中提供文件的适当路径）。如果头文件不在当前目录，Gas
    会提示找不到文件并终止汇编。还要记得在使用 #include "aoaa.inc" 时，使用 *.S* 后缀命名你的汇编源文件，否则 GCC 不会对这些文件运行
    CPP。'
- en: '### 1.6 The ARM64 CPU Architecture'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '### 1.6 ARM64 CPU 架构'
- en: Thus far, you’ve seen a pair of Gas programs that compile and run. However,
    the statements appearing in those programs do nothing more at this point than
    return control to the OS. Before you learn some real assembly language, you’ll
    need to understand the basic structure of the ARM CPU family so you can follow
    the machine instructions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了成对的 Gas 程序，它们能够编译并运行。然而，这些程序中出现的语句目前仅仅是在将控制权返回给操作系统。在你学习一些真正的汇编语言之前，你需要了解
    ARM CPU 家族的基本结构，这样你才能理解机器指令。
- en: 'The ARM CPU family is generally classified as a Von Neumann architecture machine.
    Von Neumann computer systems contain three main building blocks: the *central
    processing unit (CPU)*, *memory*, and *input/output (I/0) devices*. These three
    components are interconnected via the *system bus* (consisting of the address,
    data, and control buses). [Figure 1-1](chapter1.xhtml#fig1-1) shows this relationship.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU 家族通常被归类为冯·诺依曼架构机器。冯·诺依曼计算机系统包含三个主要组成部分：*中央处理单元（CPU）*、*内存*和*输入/输出（I/O）设备*。这三个组件通过*系统总线*（由地址、数据和控制总线组成）相互连接。[图
    1-1](chapter1.xhtml#fig1-1)展示了这种关系。
- en: '![](../images/Figure1-1.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-1.jpg)'
- en: 'Figure 1-1: A Von Neumann computer system block diagram'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：冯·诺依曼计算机系统框图
- en: The CPU communicates with memory and I/O devices by placing a numeric value
    on the address bus to select one of the memory or I/O device port locations, each
    of which has a unique binary numeric *address*. Then the CPU, memory, and I/O
    devices pass data among themselves by placing the data on the data bus. The control
    bus contains signals that determine the direction of the data transfer (to/from
    memory and to/from an I/O device).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 通过在地址总线上放置一个数字值来选择内存或 I/O 设备端口位置，从而与内存和 I/O 设备通信，每个位置都有一个唯一的二进制数字*地址*。然后，CPU、内存和
    I/O 设备通过将数据放置在数据总线上相互传递数据。控制总线包含决定数据传输方向（到/从内存和到/从 I/O 设备）的信号。
- en: 1.6.1 ARM CPU Registers
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.1 ARM CPU 寄存器
- en: 'There are two categories of ARM CPU registers: *general-purpose registers*
    and *special-purpose kernel-mode registers*. The special-purpose registers are
    intended for writing OSes, debuggers, and other system-level tools. Such software
    construction is well beyond the scope of this text.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU寄存器分为两类：*通用寄存器*和*特殊用途内核模式寄存器*。特殊用途寄存器是为编写操作系统、调试器及其他系统级工具而设计的。这类软件的构建远远超出了本文的范围。
- en: The ARM64 supports 32 general-purpose 64-bit registers (named X0 through X31)
    and 32 general-purpose 32-bit registers (named W0 through W31). This doesn’t imply
    there are 64 registers total; instead, the 32-bit registers overlay the low-order
    (LO) 32 bits of each of the 64-bit registers. ([Chapter 2](chapter2.xhtml) discusses
    LO components in more depth.) Modifying one of the 32-bit registers also modifies
    the corresponding 64-bit register, and vice versa, as outlined in [Figure 1-2](chapter1.xhtml#fig1-2).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ARM64支持32个通用64位寄存器（命名为X0至X31）和32个通用32位寄存器（命名为W0至W31）。这并不意味着总共有64个寄存器；相反，32位寄存器覆盖了每个64位寄存器的低32位部分。([第2章](chapter2.xhtml)将更深入地讨论低位（LO）部分。)
    修改其中一个32位寄存器也会修改对应的64位寄存器，反之亦然，具体请参见[图1-2](chapter1.xhtml#fig1-2)。
- en: '![](../images/Figure1-2.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-2.jpg)'
- en: 'Figure 1-2: The 32- and 64-bit registers on the ARM'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2：ARM上的32位和64位寄存器
- en: Those new to assembly language are often surprised that all calculations on
    the ARM64 involve a register. For example, to add two variables together, storing
    the sum into a third variable, you must load one of the variables into a register,
    add the second operand to the value in the register, and then store the register
    away in the destination variable. Registers are a middleman in nearly every calculation,
    so they’re important in ARM64 assembly language programs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚接触汇编语言的人来说，通常会惊讶于在ARM64上所有的计算都涉及一个寄存器。例如，要将两个变量相加，并将和存储到第三个变量中，你必须将其中一个变量加载到寄存器中，将第二个操作数加到寄存器中的值，然后将寄存器的值存储到目标变量中。寄存器几乎参与了每一个计算过程，因此它们在ARM64汇编语言程序中非常重要。
- en: 'Although these registers are known as *general-purpose* registers, a few of
    them have special purposes:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些寄存器被称为*通用寄存器*，但其中有一些具有特殊用途：
- en: X31, usually referred to as *SP* in code, is called the *stack pointer*, since
    it’s used to maintain a *hardware stack* on the ARM (another non-RISC, or reduced
    instruction set computer, feature), always as a 64-bit register. Because it’s
    used as the stack pointer, SP cannot be used for other purposes in most code.
    This register is accessible only by a few instructions.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X31，在代码中通常称为*SP*，是*栈指针*，因为它用于在ARM上维护*硬件栈*（另一个非RISC或精简指令集计算机的特性），始终作为64位寄存器使用。由于它被用作栈指针，因此在大多数代码中，SP不能用于其他用途。此寄存器只能通过少数指令访问。
- en: The XZR/WZR register (also treated as X31/W31 by the hardware) is called the
    *zero* register. It always returns 0 when read and is a convenient way to obtain
    the constant 0 in a program.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XZR/WZR寄存器（硬件上也称为X31/W31）被称为*零寄存器*。它在读取时总是返回0，是程序中获取常量0的便捷方式。
- en: Register X30 is the *link register*, referred to by the name *LR* rather than
    X30\. The ARM CPU uses this register to hold *return addresses* when the code
    makes a function call. ([Chapter 5](chapter5.xhtml) discusses the LR in greater
    detail.) This register is also always accessed in 64-bit mode. While you could
    theoretically use X30/W30 as a general-purpose register, you should avoid doing
    so, because function calls will wipe out the value in this register.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器X30是*链接寄存器*，通常用*LR*而不是X30来表示。ARM CPU使用这个寄存器保存*返回地址*，当代码执行函数调用时。([第5章](chapter5.xhtml)将更详细地讨论LR。)
    此寄存器始终在64位模式下访问。虽然理论上你可以将X30/W30作为通用寄存器使用，但应该避免这样做，因为函数调用会清除此寄存器中的值。
- en: Although this special purpose isn’t enforced by the hardware, most software
    uses X29 as a 64-bit *frame pointer (FP)*. Software generally uses this register
    to provide access to function parameters and local variables. Technically, you
    could use any of the general-purpose registers for this purpose, but using X29/FP
    is conventional.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这个特殊用途不是硬件强制要求的，但大多数软件将X29用作64位的*帧指针（FP）*。软件通常使用这个寄存器来访问函数参数和局部变量。从技术上讲，你可以使用任何通用寄存器来实现这一目的，但使用X29/FP是惯例。
- en: Apple reserves X18 for its own internal purposes. Programs written for macOS,
    iOS, iPadOS, and so on must not use this register. Since 29 other registers are
    available, the examples in this book don’t use X18, even for Linux examples.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple为其内部用途保留了X18寄存器。为macOS、iOS、iPadOS等编写的程序不得使用此寄存器。由于还有29个其他寄存器可用，本书中的示例不使用X18，即使是Linux示例也是如此。
- en: 'In addition to the 32 general-purpose registers, the ARM64 CPUs have two additional
    special-purpose registers accessible to user programs: the 32-bit *processor state
    (PSTATE)* register and the 64-bit *program counter (PC)* register. The PC register
    always contains the address of the machine instruction being executed. Because
    instructions are always 32 bits long, the CPU will increment this register by
    4 whenever it finishes the execution of one instruction and moves on to the next
    (more on this activity in [Chapter 2](chapter2.xhtml)).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了32个通用寄存器，ARM64 CPU还拥有两个额外的特殊用途寄存器，用户程序可以访问：32位的*处理器状态（PSTATE）*寄存器和64位的*程序计数器（PC）*寄存器。PC寄存器始终包含正在执行的机器指令的地址。由于指令始终是32位长，CPU在每次执行完一条指令并进入下一条指令时，会将该寄存器的值增加4（有关此活动的更多内容，请参见[第2章](chapter2.xhtml)）。
- en: NOTE
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*32-bit ARM CPUs refer to the PSTATE register as the* CPSR *or* PSR*. You may
    see references to those names in various documents.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*32位ARM CPU将PSTATE寄存器称为* CPSR *或* PSR*。你可能会在各种文档中看到这些名称的引用。*'
- en: The PSTATE register is 32 bits wide (of which only 16 bits are used at the time
    of this writing) and is really just a collection of individual Boolean flags.
    Its layout appears in [Figure 1-3](chapter1.xhtml#fig1-3).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PSTATE寄存器宽度为32位（其中只有16位在写作时被使用），实际上它只是由一组单独的布尔标志组成。其布局如[图1-3](chapter1.xhtml#fig1-3)所示。
- en: '![](../images/Figure1-3.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-3.jpg)'
- en: 'Figure 1-3: The PSTATE register layout'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：PSTATE寄存器布局
- en: 'Most user applications use only the N, Z, C, and V bits in the PSTATE register.
    These bits, also known as the *condition codes*, have the following meanings:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户应用程序仅使用PSTATE寄存器中的N、Z、C和V位。这些位也称为*条件码*，它们具有以下含义：
- en: '**N**    Negative (sign) flag, set when an instruction produces a negative
    result'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**N**    负数（符号）标志，当指令产生负结果时设置'
- en: '**Z**    Zero flag, set when an instruction produces a zero result'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Z**    零标志，当指令产生零结果时设置'
- en: '**C**    Carry flag, set when an unsigned arithmetic overflow occurs'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**C**    进位标志，发生无符号算术溢出时设置'
- en: '**V**    Overflow flag, set when a signed arithmetic overflow occurs'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**V**    溢出标志，发生带符号算术溢出时设置'
- en: Most of the remaining flags are inaccessible or of little use in user programs.
    UAO and PAN control CPU access features, allowing user programs to access kernel
    memory. SS is the single-step control bit for debugging. IL is the illegal instruction
    flag, set when the CPU executes an illegal instruction. D, A, I, and F are interrupt
    flags. cEL selects an exception level, usually 00 for user mode. SPS selects a
    stack pointer to use (kernel versus user mode).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其余大多数标志对用户程序不可访问或几乎没有用处。UAO和PAN控制CPU的访问特性，允许用户程序访问内核内存。SS是调试时的单步控制位。IL是非法指令标志，当CPU执行非法指令时设置。D、A、I和F是中断标志。cEL选择异常级别，通常用户模式为00。SPS选择要使用的堆栈指针（内核与用户模式）。
- en: In addition to the 32 general-purpose registers, the ARM64 provides 32 floating-point
    and vector registers to handle nonintegral arithmetic. [Chapters 6](chapter6.xhtml)
    and [11](chapter11.xhtml) discuss these registers in greater detail when covering
    floating-point arithmetic and single-instruction/multiple data (SIMD) operations.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了32个通用寄存器，ARM64还提供了32个浮点寄存器和向量寄存器，用于处理非整数算术运算。[第6章](chapter6.xhtml)和[第11章](chapter11.xhtml)在讨论浮点运算和单指令/多数据（SIMD）操作时，会更详细地讨论这些寄存器。
- en: 1.6.2 The Memory Subsystem
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.6.2 内存子系统
- en: A typical ARM64 processor running a modern 64-bit OS can access a maximum of
    2^(48) memory locations, or just over 256TB—probably far more than any of your
    programs will ever need. Since the ARM64 supports byte-addressable memory, the
    basic memory unit is a byte, which is sufficient to hold a single character or
    a very small integer value (discussed further in [Chapter 2](chapter2.xhtml)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一台运行现代64位操作系统的典型ARM64处理器可以访问最多2^(48)个内存位置，约为256TB——这可能远远超过你的任何程序所需的内存。由于ARM64支持字节寻址内存，基本的内存单元是字节，足以容纳一个字符或一个非常小的整数值（在[第2章](chapter2.xhtml)中有进一步讨论）。
- en: Because 2^(48) is a frightfully large number, the following discussion uses
    the 4GB address space of 32-bit ARM processors. Scaled up, the same discussion
    applies to 64-bit ARM processors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 2^(48) 是一个非常大的数字，以下讨论使用的是 32 位 ARM 处理器的 4GB 地址空间。将其扩展后，相同的讨论适用于 64 位 ARM
    处理器。
- en: NOTE
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*While the ARM64 supports 64 address bits in software, the hardware supports
    only 48 to 52 address bits for virtual memory operations. Most OSes limit this
    to 48 bits.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然 ARM64 在软件中支持 64 位地址，但硬件仅支持 48 到 52 位地址用于虚拟内存操作。大多数操作系统将其限制为 48 位。*'
- en: 'Think of memory as a linear array of bytes. The address of the first byte is
    0, and the address of the last byte is 2^(32) – 1\. For an ARM processor, the
    following pseudo-Pascal array declaration is a good approximation of memory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存视为一个线性字节数组。第一个字节的地址是 0，最后一个字节的地址是 2^(32) – 1。对于 ARM 处理器，以下伪 Pascal 数组声明是内存的一个很好的近似：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'C/C++ and Java users might prefer the following syntax:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++ 和 Java 用户可能更喜欢以下语法：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To execute the equivalent of the Pascal statement Memory [125] := 0;, the CPU
    places the value 0 on the data bus, places the address 125 on the address bus,
    and asserts the write line (which generally involves setting that line to 0),
    as shown in [Figure 1-4](chapter1.xhtml#fig1-4).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行等同于 Pascal 语句 Memory [125] := 0; 的操作，CPU 将值 0 放到数据总线中，将地址 125 放到地址总线中，并且触发写入线（通常是将该线设置为
    0），如 [图 1-4](chapter1.xhtml#fig1-4) 所示。
- en: '![](../images/Figure1-4.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-4.jpg)'
- en: 'Figure 1-4: The memory write operation'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-4：内存写操作
- en: To execute the equivalent of CPU := Memory [125];, the CPU places the address
    125 on the address bus, asserts the read line (because the CPU is reading data
    from memory), and reads the resulting data from the data bus (see [Figure 1-5](chapter1.xhtml#fig1-5)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行等同于 CPU := Memory [125]; 的操作，CPU 将地址 125 放到地址总线中，触发读取线（因为 CPU 正在从内存读取数据），然后从数据总线中读取相应的数据（见
    [图 1-5](chapter1.xhtml#fig1-5)）。
- en: '![](../images/Figure1-5.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-5.jpg)'
- en: 'Figure 1-5: The memory read operation'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5：内存读取操作
- en: This discussion applies only when accessing a single byte in memory. To store
    values larger than a single byte, like *half words* (2 bytes) and *words* (4 bytes),
    the ARM uses a sequence of consecutive memory locations, as shown in [Figure 1-6](chapter1.xhtml#fig1-6).
    The memory address is the address of each object’s first byte (that is, the lowest
    address).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论仅适用于访问内存中的单个字节。要存储大于单字节的值，如*半字*（2 字节）和*字*（4 字节），ARM 使用一系列连续的内存位置，如 [图 1-6](chapter1.xhtml#fig1-6)
    所示。内存地址是每个对象的第一个字节的地址（即最低地址）。
- en: '![](../images/Figure1-6.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-6.jpg)'
- en: 'Figure 1-6: Byte, half-word, and word storage in memory'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-6：内存中的字节、半字和字存储
- en: The ARM64 generally supports *unaligned memory access*, meaning the CPU can
    read or write an object of any size—byte, half word, word, or double word (dword)—at
    any address in memory. Certain instructions, however, require that memory access
    be aligned on the natural size of the transfer. Generally, this means that 16-,
    32-, and 64-bit memory accesses must take place on addresses that are a multiple
    of 2, 4, or 8; otherwise, the CPU may raise an exception. Regardless of exceptions,
    the CPU can usually access memory locations aligned on a natural boundary faster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ARM64 通常支持*非对齐内存访问*，意味着 CPU 可以在内存的任何地址读取或写入任意大小的对象——字节、半字、字或双字（dword）。然而，某些指令要求内存访问在传输的自然大小上对齐。通常，这意味着
    16 位、32 位和 64 位内存访问必须在 2、4 或 8 的倍数地址上进行；否则，CPU 可能会引发异常。无论是否发生异常，CPU 通常能更快地访问在自然边界上对齐的内存位置。
- en: Modern ARM processors don’t connect directly to memory. Instead, a special memory
    buffer on the CPU known as the *cache* (pronounced “cash”) acts as a high-speed
    intermediary between the CPU and main memory. You’ll learn to set the alignment
    of memory objects and the effects of the cache on data alignment in [Chapter 3](chapter3.xhtml).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 ARM 处理器不会直接连接到内存。相反，CPU 上有一个特殊的内存缓冲区，称为*缓存*（发音为“cash”），它充当 CPU 和主内存之间的高速中介。你将在[第
    3 章](chapter3.xhtml)中学习如何设置内存对象的对齐方式以及缓存对数据对齐的影响。
- en: 1.7 Declaring Memory Variables in Gas
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.7 在 Gas 中声明内存变量
- en: Referencing memory by using numeric addresses in assembly language is possible,
    but painful and error-prone. Rather than having your program state, “Give me the
    32-bit value held in memory location 192 and the 16-bit value held in memory location
    188,” it’s much nicer to state, “Give me the contents of elementCount and portNumber.”
    Using variable names, rather than memory addresses, makes your program much easier
    to write, read, and maintain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: To create (writable) data variables, you have to put them in a data section
    of the Gas source file, defined using the .data directive. The .data directive
    tells Gas that all following statements (up to the next .text or other section-defining
    directive) will define data declarations to be grouped into a read/write section
    of memory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Within a .data section, Gas allows you to declare variable objects by using
    a set of data declaration directives. The basic form of a data declaration directive
    is
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where label is a legal Gas identifier and directive is one of the directives
    in the following list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: .byte    Byte (8-bit) values. One or more comma-separated 8-bit expressions
    appear in the operand field (values).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: .hword**,** .short**,** .2byte    Half-word (16-bit) values. One or more comma-separated
    16-bit expressions appear in the operand field.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: .word**,** .4byte    Word (32-bit) values. One or more comma-separated 32-bit
    expressions appear in the operand field.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: .quad**,** .8byte    Dword (64-bit) values. One or more comma-separated 64-bit
    expressions appear in the operand field. .quad is an unfortunate misnomer for
    ARM64, since a 64-bit value is actually a double word, not a quad word (on the
    ARM, a quad word is 128 bits). The term predates the ARM assembler, coming from
    “quad word” in the x86 and 68000 assembly language days. To avoid confusion, this
    book uses the .dword directive in place of .quad.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: .dword    The .dword macro appearing in the *aoaa.inc* include file is a synonym
    for the .quad directive that emits 8 bytes (64 bits) for each operand. Using .dword
    is preferable to .quad. You must include the *aoaa.inc* file in order to use this
    directive.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: .octa    Octaword (oword, 128-bit/16-byte) values. One or more comma-separated
    128-bit expressions appear in the operand field. .octa is an unfortunate misnomer
    for ARM64, since a 128-bit value is actually a quad word, not an “octa” word (on
    the ARM, an octaword is 256 bits). To avoid confusion, this book avoids the .octa
    directive and uses .qword instead.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: .qword    This is a macro appearing the *aoaa.inc* include file. It is a synonym
    for the .octa directive and emits 16 bytes for each operand. You must include
    the *aoaa.inc* file in order to use this directive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: .ascii    String values. A single string constant (surrounded by quotation marks)
    appears in the operand field. Note that Gas does not terminate this string with
    a 0 byte.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: .asciz    Zero-terminated string values. A single string constant (surrounded
    by quotation marks) appears in the operand field. Gas will emit a 0 after the
    last character in the string operand.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: .float    Single-precision floating-point values. One or more comma-separated
    32-bit single-precision floating-point expressions appear in the operand field.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: .double    Double-precision floating-point values. One or more comma-separated
    64-bit double-precision floating-point expressions appear in the operand field.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Gas provides additional synonyms for some of the directives in this list; see
    the link to the Gas documentation in section 1.12, “For More Information,” on
    [page 43](chapter1.xhtml#pg_43).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of valid Gas data declarations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Whenever you declare a variable in this manner, Gas will associate the current
    location in the output object-code file with the label at the beginning of the
    line. It will then emit the appropriate-sized data value into memory at that location,
    adjusting the assembler’s *location counter* (which tracks the current location)
    by the size of each operand it emits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The label field in these data declaration directives is optional. If you do
    not include the label, Gas simply emits the data in the operand field, starting
    at the current location counter and incrementing the location counter afterward.
    This is useful, for example, when you want to insert a control character or special
    Unicode character into a string:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Gas allows C-style escape sequences within quoted strings. Although Gas doesn’t
    support the full set of escape characters, it does support the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: \b        Backspace character (0x08)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: \n        Newline character/line feed (0x0A)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: \r        Carriage return (0x0D)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: \t         Tab (0x09)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: \f        Form feed character (0x0C)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: \\         Backslash character
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: \nnn    Where nnn is a three-digit octal value; emit the value to the code stream
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: \xhh    Where hh is a two-digit hexadecimal value; emit the value to the code
    stream
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Gas does not support \a, \e, \f, \v, \', \", \?, \uhhhh, or \Uhhhh escape sequences.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '#### 1.7.1 Associating Memory Addresses with Variables'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'With an assembler like Gas, you don’t have to worry about numeric memory addresses.
    Once you declare a variable in Gas, the assembler associates that variable with
    a unique set of memory addresses. For example, say you have the following declaration
    section:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Gas will find an unused 8-bit byte in memory and associate it with the i8 variable;
    it will likewise associate a pair of consecutive unused bytes with i16, 4 consecutive
    unused bytes with i32, and 8 consecutive unused bytes with i64. You’ll always
    refer to these variables by their names and generally don’t have to concern yourself
    with their numeric addresses. Still, be aware that Gas is doing this for you.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: When Gas is processing declarations in a .data section, it assigns consecutive
    memory locations to each variable. Assuming i8 (in the previous declarations)
    as a memory address of 101, Gas will assign the addresses appearing in [Table
    1-1](chapter1.xhtml#tab1-1) to i8, i16, i32, and i64.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-1: Variable Address Assignments'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Memory address |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| i8 | 101 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| i16 | 102 (address of i8 plus 1) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '| i32 | 104 (address of i16 plus 2) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| i64 | 108 (address of i32 plus 4) |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: Technically, Gas assigns offsets into the .data section to variables. Linux/macOS
    converts these offsets to physical memory addresses when it loads the program
    into memory at runtime.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have multiple operands in a data declaration statement, Gas will
    emit the values to sequential memory locations in the order in which they appear
    in the operand field. The label associated with the data declaration (if one is
    present) is associated with the address of the first (leftmost) operand’s value.
    See [Chapter 4](chapter4.xhtml) for more details.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 1.7.2 Aligning Variables
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted already, your programs may run faster if your variables are aligned
    on a *natural boundary* (alignment to the size of the object). Alignment is accomplished
    with the .align directive, which you saw in Listing 1-1.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Byte variables don’t require any alignment. Use the .align 1 directive to put
    half words at an even address (2-byte boundary); remember, Gas will align the
    next statement on a boundary that is equal to 2*^n*, where *n* is the .align statement’s
    operand. For words, use the .align 2 directive. For double words (.dword), use
    the .align 3 directive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s return to the declaration given earlier:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Sticking .align directives in front of every declaration (except i8) will start
    to clutter up your code and make it harder to read:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If your variables don’t have to be declared in a particular order, you can
    clean this up by declaring the largest variables first and the remaining variables
    sorted by decreasing size. If you do this, you have to align only the first variable
    in your declaration list:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because the i64 declaration appears immediately after the .align 3 statement
    in this code, the i64 address will be aligned on an 8-byte boundary. As i32 immediately
    follows i64 in memory, it will also be aligned on an 8-byte boundary (which, of
    course, is also a 4-byte boundary). This is because i64 is aligned on an 8-byte
    boundary and consumes 8 bytes; therefore, the address following i64 (the address
    of i32) will also be 8-byte aligned.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, because i16 immediately follows i32 in memory, it will be aligned
    on a 4-byte boundary (which is also an even address). The alignment of i8 doesn’t
    matter, but it happens to be at an even address, as it follows i16, which was
    aligned on a 4-byte boundary and consumes 2 bytes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Gas also provides a* .balign *directive whose operand must be a power of 2
    (1, 2, 4, 8, 16, ...) to specify the alignment value directly, rather than as
    a power of 2\. While this book uses* .align *because it’s the original directive,
    feel free to use* .balign *if you prefer.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gas 还提供了一个* .balign *指令，它的操作数必须是 2 的幂（1、2、4、8、16，...），用于直接指定对齐值，而不是作为 2 的幂。虽然本书使用*
    .align *指令，因为它是原始指令，但如果你更喜欢的话，也可以使用* .balign*。'
- en: Strings are sequences of bytes, so their alignment usually doesn’t matter. However,
    it is possible to write very high-performance string functions in assembly language
    that process strings eight or more characters at a time. If you have access to
    such library code, it might run faster if your strings are aligned on an 8-byte
    boundary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字节的序列，因此它们的对齐通常无关紧要。然而，确实可以编写高性能的字符串函数，这些函数一次处理八个或更多字符。如果你有访问这样的库代码的权限，如果你的字符串按
    8 字节边界对齐，它可能会运行得更快。
- en: Of course, floats and doubles should be aligned on 4-byte and 8-byte boundaries
    for the highest performance. In fact, as you’ll see in [Chapter 11](chapter11.xhtml),
    16-byte alignment is also sometimes better.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，浮点数和双精度数应该在 4 字节和 8 字节边界上对齐，以获得最佳性能。实际上，正如你将在 [第11章](chapter11.xhtml) 中看到的，有时
    16 字节对齐也更好。
- en: 1.7.3 Declaring Named Constants in Gas
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.3 在 Gas 中声明命名常量
- en: Gas allows you to declare manifest constants by using the .equ directive. A
    *manifest constant* is a symbolic name (identifier) that Gas associates with a
    value. Everywhere the symbol appears in the program, Gas will directly substitute
    its value.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 允许你使用 .equ 指令声明显式常量。一个 *显式常量* 是一个符号名称（标识符），Gas 将其与一个值关联。在程序中每次出现该符号时，Gas
    会直接替换它的值。
- en: 'A manifest constant declaration takes the following form:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显式常量声明的格式如下：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, label is a legal Gas identifier, and expression is a constant arithmetic
    expression (typically a single literal constant value). The following example
    defines the symbol dataSize to be equal to 256:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，label 是一个合法的 Gas 标识符，expression 是一个常量算术表达式（通常是一个单一的字面常量值）。以下示例将符号 dataSize
    定义为 256：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Constant declarations, or *equates* in Gas terminology, may appear anywhere
    in your Gas source file prior to their first use: in a .data section, in a .text
    section, or even outside any sections.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明，或者在 Gas 术语中称为 *equates*，可以出现在 Gas 源文件中的任何位置，位于第一次使用之前：可以在 .data 部分、.text
    部分，甚至可以在任何部分之外。
- en: 'Once you define a constant symbol with .equ, it cannot be further modified
    in the source file during assembly. If you need to reassign the value associated
    with a label during assembly (see [Chapter 13](chapter13.xhtml) for reasons you’d
    want to do this), use the .set directive:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用 .equ 定义了一个常量符号，它就不能在汇编过程中进一步修改。如果你需要在汇编过程中重新分配与标签关联的值（参见 [第13章](chapter13.xhtml)
    了解你为什么需要这样做），可以使用 .set 指令：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Equates can specify textual arguments as well as numeric constants.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 等式可以指定文本参数以及数字常量。
- en: 'Because Gas will run your source files through the CPP if the filename suffix
    is *.S*, you can also use the CPP #define macro definition to create named constants.
    Although the .equ directive is probably the better choice, the C macro form offers
    a few advantages, like allowing arbitrary textual substitution, not just numeric
    expression substitution. For more on this, see [Chapter 13](chapter13.xhtml).'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '由于如果文件名后缀是 *.S*，Gas 会通过 CPP 运行你的源文件，你也可以使用 CPP 的 #define 宏定义来创建命名常量。尽管 .equ
    指令可能是更好的选择，但 C 宏形式有一些优势，比如允许任意文本替代，而不仅仅是数字表达式替代。有关更多信息，请参见 [第13章](chapter13.xhtml)。'
- en: 1.7.4 Creating Register Aliases in Gas and Substituting Text
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.7.4 在 Gas 中创建寄存器别名并进行文本替换
- en: 'As you begin to write more complex ARM assembly language programs, you’ll discover
    that the 32 general-purpose register names (X0 to X30 and SP) obscure the meaning
    of their values in the program. It’s been decades since BASIC supported only variable
    names like A0, A1, B2, and Z3\. To avoid returning to those days by using meaningless
    two-character names, Gas provides a way to create more meaningful aliases of register
    names in your programs: the .req directive.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始编写更复杂的 ARM 汇编语言程序时，你会发现那 32 个通用寄存器名（X0 到 X30 和 SP）使得它们在程序中的值难以理解。从 BASIC
    只支持像 A0、A1、B2 和 Z3 这样的变量名已经过去几十年了。为了避免通过使用无意义的两字符名称回到那些日子，Gas 提供了一种在程序中创建寄存器名称的更有意义的别名的方法：.req
    指令。
- en: The syntax of the .req directive is
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: .req 指令的语法是：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: where symbolicName is any valid Gas identifier and register is one of the 32-
    or 64-bit register names. After this statement in the source file, if you use
    symbolicName in place of register, Gas will automatically substitute that register
    for the name.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Sadly, the .req directive works only for creating register aliases; you can’t
    use it as a general-purpose text-substitution facility. However, if you name your
    assembly language source files with *.S*, Gas/GCC will first run your source file
    through the CPP. This allows you to embed C/C++ #define statements in your assembly
    source file, and the CPP will happily expand any symbols you define in such statements
    throughout your source file. The following example demonstrates using #define:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Typically, you’ll use .req for register aliases and #define for any other textual
    substitutions in the source file, though my personal preference is to use the
    #define statement for both purposes in this book. Since #define also accepts parameters,
    it’s flexible. Gas also supports textual substitution via *macros*; see [Chapter
    13](chapter13.xhtml) for more on this.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 Basic ARM Assembly Language Instructions
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus far, the programming examples in this chapter have consisted of functions
    that use only the ret instruction. This section describes a few more instructions
    to get you started writing more meaningful assembly language programs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '#### 1.8.1 ldr, str, adr, and adrp'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: One solidly RISC feature of ARM is its use of *load/store architecture*. All
    computational activity takes place in the ARM’s registers; the only instructions
    that access main memory are those that load a value from memory or store a value
    into memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Although the ARM64 has many general-purpose registers for holding variable values
    (and thus can avoid using memory), most applications use more variable data than
    can fit in all the registers. This is especially true for larger objects like
    arrays, structs, and strings. Furthermore, programming conventions—known as the
    *application binary interface (ABI)*, discussed later in this chapter—often reserve
    many of ARM’s registers so they cannot be used to hold application variables for
    any length of time. So variables must be placed in main memory and accessed via
    these ldr (load) and str (store) instructions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: This is the generic syntax for the load and store instructions
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: where size is either absent or one of the character sequences b, h, sb, sh,
    or sw; reg is one of the ARM’s 32- or 64-bit registers; and mem is a memory addressing
    mode that specifies where to fetch the data from in memory. The ldr instruction
    loads the register specified by reg from the memory location specified by mem.
    The str instruction stores the value held in the register operand into the memory
    location.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](chapter2.xhtml) discusses the size operand in greater depth, but
    this chapter largely ignores the size suffixes on the ldr and str instructions.
    Without a size prefix, the reg operand determines the operation’s size. If reg
    is X*n*, the instruction transfers 64 bits; if it’s W*n*, then the instruction
    transfers 32 bits.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The mem operand is either the name of a variable in your program, typically
    in the .data section (Linux only), or a register name surrounded by square brackets
    ([]). In this latter case, the register holds the numeric memory address of the
    memory location to access. See [Chapter 3](chapter3.xhtml) for more on mem.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Because macOS requires that your applications be written in a position-independent
    fashion (as we just discussed in “Linux vs. macOS: Position-Independent Executables”),
    you will not be able to use an ldr instruction of this form:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To access the i64 variable, you must first load its address into a 64-bit register,
    then access that data by using the *register-indirect addressing mode*, or X*n*.
    To do so, place the address of the variable you want to access in the register
    by using the adr and adrp instructions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, reg64 is the name of a 64-bit general-purpose register, and mem is a memory
    addressing mode, like the name of a global variable. The adr instruction loads
    reg with the address of the memory variable, which must be ±1MB from the adr instruction
    if the operand is just the name of a variable (like i64 from the previous example).
    The adrp instruction loads the 64-bit destination register with the page (4,096-byte
    boundary) containing the memory object. That value will have the LO 12 bits containing
    all 0s.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of macOS’s PIE requirements, it doesn’t take kindly to instructions
    such as the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: On the Mac, you must use the register-indirect addressing mode to access a global
    variable. Unfortunately
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'fails for the same reason: you’re not allowed to specify the name of a global
    variable.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, to get the address of a global variable into a register under
    macOS, we’ll use the following statement:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The lea (load effective address) macro, included in *aoaa.inc*, will expand
    into two instructions (different ones depending on your OS). These instructions
    will load the address of the second operand (mem) into the 64-bit register specified
    by the first operand (reg). You can use lea in any projects where you’ve included
    *aoaa.inc* at the beginning of your source file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: As noted, the *aoaa.inc* macros make the code in this book portable between
    OSes. However, you can choose to go with the appropriate OS-specific code, which
    can sometimes be more efficient, once you master basic ARM assembly language programming.
    See [Chapter 7](chapter7.xhtml) for more details on lea.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude this discussion of taking the address of a variable, let’s recap
    how to load and store values by using ldr and str:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When loading X0 with a variable’s value, you can first load X0 with the address
    of the variable and then load X0 indirectly from the location held in X0\. This
    winds up using only a single register. However, when storing data to memory, you
    need a second register to hold the address (X1 in this example).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are referencing a particular variable several times within a small section
    of code, it’s more efficient to load its address into a register just once and
    reuse that register value multiple times, rather than constantly reloading the
    address:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Of course, this means you can’t use the register for any other purpose while
    it holds i64’s address. Fortunately, for just this reason, the ARM64 has lots
    of registers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.2 mov
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Beyond the ldr and str instructions, the mov instruction handles two additional
    data movement operations: moving data between a pair of registers and copying
    a constant into a register. The generic syntax for mov is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first mov instruction copies the data in the source register (regsrc) into
    the destination register (regdest). This instruction is equivalent to the C/C++
    statement regdest = regsrc;. The source and destination registers can be any of
    the general-purpose registers but must be the same size (32 or 64 bits).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The second mov instruction moves a small integer constant into the destination
    register. Constants encoded as part of the instruction are known as *immediate
    constants* and are generally preceded by a # character (though Gas often allows
    you to drop the # when specifying literal numeric constants). [Chapter 2](chapter2.xhtml)
    discusses limitations on constants, but for now, assume any constant less than
    ±2,047 will work.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two examples of the mov instruction:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are many additional variants of mov, covered in depth in later chapters.
    For example, if you encounter a constant you cannot load into a register with
    a single mov instruction, other variants of mov let you load any arbitrary 32-
    or 64-bit constant by using two to three instructions. In the meantime, this variant
    of the ldr instruction will load any constant into a register:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The assembler will simply store veryLargeConstant in a memory location somewhere
    and then load the contents of that memory location to the specified register.
    Use this handy pseudo-instruction when you need to load a large constant into
    a register with a single instruction.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '#### 1.8.3 add and sub'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'The add and sub instructions handle simple arithmetic on the ARM CPU. These
    instructions take many forms covered more thoroughly in the next couple of chapters.
    Their basic forms are the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, regdest, reglsrc, and regrsrc are 32- or 64-bit registers (which must
    all be the same size for a given instruction), and const is an immediate constant
    in the range 0 to 4,095\. You’ll learn to specify larger constants later, but
    these forms are sufficient for the example programs in the next few chapters.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Some assemblers allow a range of –4,095 to +4,095 and swap the* add *and*
    sub *instructions if the immediate constant is negative.*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'The instructions with the s suffix affect the condition code flags. They set
    the flags according to the conditions specified in the following list:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '**N**    Set if the arithmetic operation produces a negative result (high-order,
    or HO, bit is set); clear if it produces a nonnegative result (HO bit is clear).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Z**    Set if the arithmetic operation produces a 0 result; clear if it produces
    a nonzero result.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**C**    Set if the addition operation produces an unsigned overflow (carry
    out of the HO bit). Clear if a subtraction operation produces a borrow (unsigned
    underflow), and set otherwise.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**V**    Set if the arithmetic operation produces a signed overflow (carry
    out of the next-to-HO bit).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instructions negate their source operands, because they subtract
    the source register from 0 (remember that WZR and XZR are the zero registers and
    return 0 when read):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Gas provides synonyms for these instructions:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These forms are a little easier to read.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 1.8.4 bl, blr, and ret
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Calling procedures and functions is handled by the bl (branch and link) and
    blr (branch and link through register) instructions. Here’s their syntax
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: where label is a statement label preceding code in the .text section, and Xn
    represents one of the 64-bit registers. These two instructions copy the address
    of the next instruction (following the bl or blr instruction) into the link register
    (LR/X30), then transfer control either to the target label or to the address specified
    by the contents of X*n*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The bl instruction does have a minor limitation: it can transfer control only
    to a statement label within ±128MB of the current instruction. This is generally
    far more than enough for any function you’ll write. In theory, if the OS loads
    code into another section (besides .text), it could be placed sufficiently far
    away that it would exceed this range. The OS linker will probably complain if
    this occurs. This book generally places all code within the .text section, as
    it would be rare for such programs to exceed this limitation.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'The blr instruction copies the full 64-bit address from X*n* into the PC (after
    copying the address of the next instruction into LR). Therefore, blr does not
    have the range limitation of the bl instruction. If you ever do encounter the
    range limitation when using bl, overcome it by using the following sequence:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will load the address of farAwayProcedure into X0 (no matter where it appears
    in memory), then transfer control to that procedure via blr.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The ret instruction has appeared in several examples up to this point. It copies
    the contents of the LR (X30) register into the PC. Assuming that LR was loaded
    with a value as a result of executing the bl or blr instruction, this returns
    control to the instruction following the bl/blr.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The bl, blr, and ret instructions have one issue: the ARM architecture tracks
    only a single subroutine call with the LR register. Consider the following code
    fragment:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When the OS calls the main program, it loads the LR register with the return
    address back to the OS. Normally, when the main program completes execution, its
    ret instruction transfers control to this location. However, that’s not the case
    in this example: when the main program begins execution, it immediately calls
    someFunc with the bl instruction. This instruction copies its return address (the
    address of the main program’s ret instruction) into the LR register, wiping out
    the OS’s return address currently residing there. When someFunc executes the return
    instruction, it returns control back to the main program.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Upon return from someFunc, the main program executes the ret instruction. However,
    the LR register now contains the return address of the someFunc call, which is
    the address of the ret instruction in the main program, so control transfers there,
    re-executing ret. The LR register’s value hasn’t changed; it still points at that
    ret instruction, meaning this code enters an infinite loop continuously executing
    the return and transferring control back to the return (where LR continues to
    point).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](chapter3.xhtml) discusses the high-level solution to this problem.
    For the time being, we must save the LR register value in the main program before
    calling someFunc. One quick-and-dirty way to do this is to copy it into another
    (unused by main) register and restore LR before the final return:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code saves the return address (in LR) in the X1 register and restores it
    after returning from someFunc (the call to someFunc overwrote the value in LR).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: In general, saving the return address in the X1 register is a bad idea, because
    the ARM’s designers reserve X1 for passing parameters. (Using X1 worked in this
    example because someFunc doesn’t have any parameters, as it just returns to its
    caller.) The next section covers in greater depth which registers are reserved
    for various purposes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 1.9 The ARM64 Application Binary Interface
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A CPU’s *application binary interface (ABI)* describes how programs should use
    registers, pass parameters between functions, represent data, and many other conventions.
    Its primary purpose is to provide interoperability among programming languages
    and systems. The ARM64’s ABI, for example, describes the conventions that allow
    C/C++ programs to call functions written in Swift, Pascal, and other languages.
    Since the GCC (and Clang) compilers follow these rules, you must also follow them
    to pass information between your assembly language code and code written in an
    HLL such as C/C++.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: An ABI is a *convention*, not an absolute rule. It is a contract between the
    code being called and the code making the call. When writing your own assembly
    language functions to be called by your own assembly language code, you are under
    no obligation to use the ABI and can use whatever inter-code communication scheme
    you like. However, if you call C/C++ code from your assembly functions, or if
    your assembly code is being called from C/C++, you must follow the ARM64 ABI.
    Since this book uses a considerable mixture of C/C++ and assembly code, understanding
    the ARM64 ABI is critical for our purposes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.1 Register Usage
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM64 ABI reserves some of its 32 general-purpose registers for specific
    uses and defines whether registers are *volatile* (meaning you don’t have to preserve
    their values) or *nonvolatile* (meaning that you must preserve their values within
    a function). [Table 1-2](chapter1.xhtml#tab1-2) describes the special purposes
    and volatility of the 32 ARM registers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-2: ARM64 ABI Register Conventions'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '| Register | Volatile | Special meaning |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '| X0/W0 | Yes | Pass parameter 1 here, return function results here. Registers
    X0 through X7 can also be used as a scratchpad/temporary/ local variable if not
    used as a parameter. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '| X1/W1 | Yes | Pass parameter 2 here, return function results here. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '| X2/W2 | Yes | Pass parameter 3 here, return function results here. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '| X3/W3 | Yes | Pass parameter 4 here, return function results here. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '| X4/W4 | Yes | Pass parameter 5 here, return function results here. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: '| X5/W5 | Yes | Pass parameter 6 here, return function results here. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
- en: '| X6/W6 | Yes | Pass parameter 7 here, return function results here. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| X7/W7 | Yes | Pass parameter 8 here, return function results here. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| X8/W8 | Yes | Pointer to large function return results (for example, a large
    C structure returned by value). |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| X9/W9 X10/W10'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: X11/W11
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: X12/W12
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: X13/W13
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: X14/W14
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: X15/W15 | Yes Yes
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Yes | Can be used as a scratchpad/temporary/local variable. |
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '| X16/W16/IP0 | Yes, but ... | You can use this register as a temporary variable,
    but its value may change across the execution of a control-transfer instruction;
    the system linker/loader may use this register to create a veneer, also known
    as a trampoline (more on this in [Chapter 7](chapter7.xhtml)). |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| X17/W17/IP1 | Yes, but ... | You can use this register as a temporary variable,
    but its value may change across the execution of a control-transfer instruction;
    the system linker/loader may use this register to create a veneer, also known
    as a trampoline (more on this in [Chapter 7](chapter7.xhtml)). |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| X18/W18/Plat | No access | This register is reserved for use by the OS, and
    application programs must not modify its value. Under macOS, you definitely must
    not modify this register; under Linux, you may get away with using this register
    if you preserve its value, but the safe choice is to avoid using this register.
    |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| X19/W19 X20/W20'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: X21/W21
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: X22/W22
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: X23/W23
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: X24/W24
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: X25/W25
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: X26/W26
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: X27/W27
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: X28/W28 | No No
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: No | A function using this register must save and restore the register’s value
    so that it contains its original value when the function returns. |
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '| X29/W29/FP | N/A | Reserved for use as the system frame pointer. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| X30/W30/LR | N/A | Reserved for holding function return addresses. |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| SP /X31/W31 | N/A | Reserved for use as the system stack pointer. |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: Conveniently, when using volatile registers in a function, you don’t have to
    preserve (save and restore) their values within the function. However, this means
    that you also cannot expect them to maintain their values across any functions
    you call via bl or blr. Nonvolatile registers will maintain their values across
    function calls you make, but you must explicitly preserve their values if you
    modify them within your functions.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.2 Parameter Passing and Function Result Conventions
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Chapter 5](chapter5.xhtml) provides a complete discussion of parameter passing
    and function results in assembly language. However, when calling functions written
    in a different languages (particularly HLLs), you must adhere to the conventions
    that language uses. Most HLLs use the ARM ABI as the convention for passing parameters.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: The ARM ABI uses registers X0 through X7 to pass up to eight integer parameters
    to a function. These parameters can be 8-, 16-, 32-, or 64-bit entities. You pass
    the first parameter in X0, the second in X1, and so on. To pass fewer than eight
    parameters, simply ignore the additional registers in this set. [Chapter 5](chapter5.xhtml)
    discusses how to pass more than eight parameters and how to pass data types larger
    than 64 bits, including arrays and structs. [Chapter 6](chapter6.xhtml) covers
    how to pass floating-point values to a function.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: You can also return function results in these registers. Most functions return
    integer results in X0\. If you’re returning a large object by value, like a structure,
    array, or string, you typically use X8 to return a pointer to that data object.
    [Chapter 6](chapter6.xhtml) discusses returning floating-point function results.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Registers X0 through X7 are volatile, meaning you can’t expect a called function
    to preserve the original register values on return. This is true even if you don’t
    use all eight registers to pass parameter values. If you want to preserve a value
    across function calls, use a nonvolatile register.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 Calling C Library Functions
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the coding examples in this book so far have immediately returned to the
    OS, apparently without accomplishing anything. While it is theoretically possible
    for a pure assembly language program to produce its own output, it takes a lot
    of work and is largely beyond the scope of this book. Instead, this book calls
    prewritten C/C++ library code to do the I/O. This section discusses how this is
    done.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Most other books on assembly language that use libraries in this way call the
    OS by using available *application programming interfaces (APIs)*. This is a reasonable
    approach, but such code is tied to the particular OS for which the calls are made
    (see [Chapter 16](chapter16.xhtml) for examples). This book instead relies on
    library functions written in the C stdlib, since it’s available on many OSes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'In most introductory programming books, the first programming example provided
    is the venerable “Hello, world!” program. Here’s that program written in C:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Except for an actual printf() statement, the assembly language source files
    given thus far have fulfilled the purpose of the “Hello, world!” example: learning
    how to edit, compile, and run a simple program.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Most of this book uses the C printf() function to handle program output to the
    console. This function requires one or more arguments—that is, a *variable-length*
    parameter list. The first argument is the address of a *format string*. If that
    string requires it, additional parameters provide data to convert to string form.
    For the “Hello, world!” program, the format string ("Hello, world!\n") is the
    only argument.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'The C stdlib—and all C functions, for that matter—adheres to the ARM ABI. Therefore,
    printf() expects its first argument, the format string, in the X0 register. Instead
    of trying to pass a string (with 14 characters, including the newline) in a 64-bit
    register, we pass the address of that string in memory. If we put the string "Hello,
    world!\n" in the .text section along with the program (out of the way, so the
    CPU doesn’t try to execute it as code), then we can compute the address of that
    string by using the lea macro:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once we have this string address in X0, calling printf() prints that string
    to the standard output device:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To run, this program must be linked against the C stdlib and a small C/C++ program
    like the one in Listing 1-2\. Rather than grabbing that program, I’ll create a
    slightly better version in Listing 1-4 to use with almost every example program
    in the rest of this book.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This program contains a few additional features over Listing 1-2\. First, the
    name of the assembly language function has changed to asmMain() ❶, the assembly
    language main program. This code also requires a second assembly function, getTitle()
    ❷. This function, provided by the assembly language source code, returns a pointer
    to a zero-terminated string containing the program’s title. The program displays
    this title before and after calling asmMain().
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The readLine() function appears in the C program that reads a line of text from
    the user and stores that text into a buffer specified by the caller ❸. You can
    call this function from the example assembly code, sparing you from having to
    write the function in assembly (it’s grunt work better done in C). You’ll see
    examples of this function call in later chapters.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: This file (appearing as *Listing1-4.cpp* or *c.cpp* in the online code) requires
    the assembly code to provide a getTitle() function that returns the address of
    a string so the C program can display the name. This string is embedded in the
    assembly language source file, since most of the programs in this book use only
    one version of *c.cpp*. The getTitle() function is the same in every program
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'where title is a zero-terminated string appearing elsewhere in your program
    (usually in the .data section). That declaration will usually take this form:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The getTitle function returns the address of this string to the *c.cpp* program.
    The string following the .asciz directive will typically be the name of the assembly
    language source file (I used *Listing1-5* in this example).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.1 Assembling Programs Under Multiple OSes
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We could easily bang out a “Hello, world!” program for Linux or macOS at this
    point, but the programs would be slightly different for each OS. So that we don’t
    need to use a different include file for each OS, I’ve modified *aoaa.inc* to
    look for a couple of symbol definitions: isMacOS and isLinux. Both symbols must
    be defined with the CPP #define declaration, and one must be true (1) while the
    other is false (0). The *aoaa.inc* file uses these symbols to adjust the definitions
    present in the file for the appropriate OS.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'In theory, we could use code like the following to define these symbols:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, this would force every example program to have two versions, one for
    macOS (the example just given) and one for Linux, containing the following statements:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'GCC has a preferable command line option that lets you define a preprocessor
    symbol and give it a value:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This way, the following commands will automatically define the symbol prior
    to assembling the *source.S* file:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We can specify the OS from the command line in this way so that the source files
    (*source.S* and *aoaa.inc*) don’t require any changes under either macOS or Linux.
    To avoid any extra typing required to assemble the program, we’ll use a command
    line program known as a *shell script*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: While writing a shell script for this purpose, I also further automated the
    build process. The script, named *build*, accepts the base name of an example
    file without a suffix and automatically deletes any existing object or executable
    files with that base name (a *clean* operation, in Unix terminology). It then
    determines which OS *build* is running on and then automatically generates the
    appropriate GCC command line to build the example.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to build a file named *example.S*, you’d execute the following
    command:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Under Linux, this would generate the following command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Under macOS, it would generate the following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The *build* script also supports a couple of command line options: -c and -pie.
    The -c (compile-only) option generates the following command line, which only
    assembles the assembly file to an object file; it does not compile *c.cpp*, nor
    does it produce an executable:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This executes the following command as appropriate:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: or
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The -pie option applies only to Linux. It issues the appropriate commands to
    tell Linux to produce a position-independent executable file (by default, Linux
    produces a non-position-independent executable). Because macOS’s assembler always
    produces PIE code, this option is ignored under macOS.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'For the curious, I’ve provided the text for this shell script in the file *build*
    without further comment, as writing shell scripts is beyond the scope of this
    book:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Check out a book on GNU’s bash shell interpreter if you want to learn how this
    works (see section 1.12, “For More Information,” on [page 43](chapter1.xhtml#pg_43)).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'The *build* shell script is available in electronic form at *[https://<wbr>artofarm<wbr>.randallhyde<wbr>.com](https://artofarm.randallhyde.com)*.
    Execute the following command to make this file executable from the bash command
    line on your Linux or macOS system:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This makes the *build* script executable. See [Appendix D](appendix-D.xhtml)
    for more information about the chmod command.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 1.10.2 Writing a “Hello, World!” Program
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You finally have the pieces in place to write a complete “Hello, world!” program,
    as shown in Listing 1-5.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The title string ❶ holds the program’s title ("Listing 1-5" in this example).
    The hwStr variable holds the Hello, world! string that the main program will pass
    to the printf() function. The getTitle() function ❷ returns the address of the
    title string to the *c.cpp* program. As per the ARM ABI, this function returns
    the function result in the X0 register.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Upon entry into the asmMain() function (the assembly language main program),
    the code must preserve the contents of the LR register because the call to printf()
    will overwrite its value. This code saves the LR register (which holds the return
    address to the *c.cpp* main function) in the saveLR global variable in the .data
    section ❶.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Saving the LR register value in this fashion is not good practice. In [Chapter
    3](chapter3.xhtml) you’ll learn about the ARM stack and discover a much better
    place to save return addresses held in LR.*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The code that actually prints Hello, world! ❸ loads X0 with the printf() format
    string as per the ARM ABI, then calls printf() by using the bl instruction. Before
    returning to *c.cpp*, the assembly code must reload LR with the returned address
    held in saveLR ❹.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the commands to build and run the program in Listing 1-5, along with
    the program’s output:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You now have a functioning “Hello, world!” program in assembly language.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 Moving On
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter equipped you with the prerequisites to start learning new assembly
    language features in the chapters that follow. You learned the basic syntax of
    a Gas program and the basic 64-bit ARM architecture, and how to use the *aoaa.inc*
    header file to make source files portable between macOS and Linux. You also learned
    how to declare some simple global variables, use a few machine instructions, and
    assemble a Gas program with C/C++ code so you can call routines in the C stdlib
    (using the *build* script file). Finally, you ran that program from the command
    line.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter introduces you to *data representation*, one of the main reasons
    for learning assembly language in the first place.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 1.12 For More Information
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the bash shell interpreter, visit the reference manual
    at *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/software<wbr>/bash<wbr>/manual<wbr>/bash<wbr>.html](https://www.gnu.org/software/bash/manual/bash.html)*.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about the GNU assembler, visit the reference manual at
    *[https://<wbr>ftp<wbr>.gnu<wbr>.org<wbr>/old<wbr>-gnu<wbr>/Manuals<wbr>/gas<wbr>-2<wbr>.9<wbr>.1<wbr>/html<wbr>_chapter<wbr>/as<wbr>_toc<wbr>.html](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html)*.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find an online guide to 64-bit ARM assembly language at *[https://<wbr>modexp<wbr>.wordpress<wbr>.com<wbr>/2018<wbr>/10<wbr>/30<wbr>/arm64<wbr>-assembly<wbr>/](https://modexp.wordpress.com/2018/10/30/arm64-assembly/)*.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re interested in programming ARM assembly language on Apple platforms,
    see *[https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/xcode<wbr>/writing<wbr>-arm64<wbr>-code<wbr>-for<wbr>-apple<wbr>-platforms](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)*.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARM developer portal at *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*
    provides generic information about ARM CPUs and ARM assembly language programming.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
