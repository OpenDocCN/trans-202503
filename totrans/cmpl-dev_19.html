<html><head></head><body>
<section epub:type="backmatter" aria-labelledby="appendix-A">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="appA">&#13;
<span class="CN" id="appendix-A"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_259" aria-label=" Page 259. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">A</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TYPESCRIPT COMPILER OPTIONS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">Pass any of these options to the <i>tsconfig.json</i> file’s <samp class="SANS_TheSansMonoCd_W5Regular_11">compilerOptions</samp> field to configure TSC’s transpilation of TypeScript code to JavaScript. For more information about this process, see <span class="chapterintro_Xref"><a href="chapter3.xhtml">Chapter 3</a></span>.</p>&#13;
<p class="TX">Here we look at the most common options. You can find more information and the complete list in the official documentation at <a href="https://www.typescriptlang.org/tsconfig"><i>https://<wbr/>www<wbr/>.typescriptlang<wbr/>.org<wbr/>/tsconfig</i></a>.</p>&#13;
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">allowJs  </samp>A Boolean that specifies whether the project can import JavaScript files.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">baseUrl  </samp>A string that defines the root directory to use for resolving module paths. For example, if you set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">"./"</samp>, TypeScript will resolve file imports from the root directory.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">esModuleInterop  </samp>A Boolean that specifies whether TypeScript should import CommonJS, AMD, or UMD modules seamlessly or treat them differently from ES.Next modules. In general, this is necessary if you use third-party libraries without ES.Next module support.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_260" aria-label=" Page 260. "/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">forceConsistentCasingInFileNames  </samp>A Boolean that specifies whether file imports are case sensitive. This can be important when some developers are working on case-sensitive filesystems and others are not, to ensure file-loading behaviors are consistent for everyone.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">incremental  </samp>A string that defines whether the TypeScript compiler should save the last compilation’s project graph, use incremental type checks, and perform incremental updates on consecutive runs. This can make transpiling faster.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">isolatedModules  </samp>A Boolean that specifies whether TypeScript should issue warnings for code not compatible with third-party transpilers (such as Babel). The most common cause for those warnings is that the code uses files that are not modules; for example, they don’t have any <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp> statements. This value doesn’t change the behavior of the actual JavaScript; it only warns about code that can’t be correctly transpiled.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">jsx  </samp>A string that specifies how TypeScript handles JSX. It applies only to <i>.tsx</i> files and how the TypeScript compiler emits them; for example, the default value <samp class="SANS_TheSansMonoCd_W5Regular_11">react</samp> transforms and emits the code by using <samp class="SANS_TheSansMonoCd_W5Regular_11">React .createElement</samp>, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">preserver</samp> does not transform the code in your component and emits it untouched.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">lib  </samp>An array that adds missing features through polyfills. In general, <i>polyfills</i> are snippets of code that add support for features and functions the target environment does not support natively. We need to emulate modern JavaScript features when we target less-compliant systems, such as older browsers or node versions. The compiler adds the polyfills defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">lib</samp> array to the generated code.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">module  </samp>A string that sets the module syntax for the transpiled code. For example, if you set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">commonjs</samp>, TSC will transpile this project to use the legacy CommonJS module syntax with <samp class="SANS_TheSansMonoCd_W5Regular_11">require</samp> for importing and <samp class="SANS_TheSansMonoCd_W5Regular_11">module.exports</samp> for exporting the code, whereas with <samp class="SANS_TheSansMonoCd_W5Regular_11">ES2015</samp> the transpiled code will use the <samp class="SANS_TheSansMonoCd_W5Regular_11">import</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">export</samp> keywords. This is independent of the <samp class="SANS_TheSansMonoCd_W5Regular_11">target</samp> property, which defines all available language features except the module syntax.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">moduleResolution  </samp>A string that specifies the module resolution strategy. This strategy also defines how TSC locates definition files for modules at compile time. Changing the approach can resolve fringe problems with the importing and exporting of modules.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">noEmit  </samp>A Boolean that defines whether TSC should produce files or only check the types in the project. Set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> if you want third-party tools such as webpack, Babel.js, or Parcel to transpile the code instead of TSC.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">resolveJsonModule  </samp>A Boolean that specifies whether TypeScript imports JSON files. It generates type definitions based on the JSON inside the file and validates the types on import. We need to manually enable JSON imports as TypeScript can’t import them by default.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_261" aria-label=" Page 261. "/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">skipLibCheck  </samp>A Boolean that defines whether the TypeScript compiler performs type checks on all type declaration files. Setting it to <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> decreases compilation time and is your escape hatch for working with untyped third-party dependencies.</p>&#13;
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">target  </samp>A string that specifies the language features to which the TypeScript code should be transpiled. For example, if you set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">es6</samp>, or the equivalent <samp class="SANS_TheSansMonoCd_W5Regular_11">ES2015</samp>, TSC will transpile this project to ES2015-compatible JavaScript, which, for example, uses <samp class="SANS_TheSansMonoCd_W5Regular_11">let</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>.</p>&#13;
</section>&#13;
</body></html>