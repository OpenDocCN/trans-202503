["```\n#include <stdio.h>\n#include <assert.h>\n\nint main() {\n  FILE* tmp = tmpfile();\n  fputs(\"Effective C\\n\", tmp);\n  rewind(tmp);\n  for (int c; (c = fgetc(tmp)) != EOF; putchar(c)) {}\n  printf(\"%s\", \"End-of-file indicator \");\n  puts(feof(tmp) ? \"set\" : \"clear\");\n  printf(\"%s\", \"Error indicator \");\n  puts(ferror(tmp) ? \"set\" : \"clear\");\n  clearerr(tmp); // clear both indicators\n  printf(\"%s\", \"End-of-file indicator \");\n  puts(feof(tmp) ? \"set\" : \"clear\");\n}\n```", "```\nEffective C\nEnd-of-file indicator set\nError indicator clear\nEnd-of-file indicator clear\n```", "```\nextern FILE * stdin;  // standard input stream\nextern FILE * stdout; // standard output stream\nextern FILE * stderr; // standard error stream\n```", "```\n$ **echo fred**\nfred\n$ **echo fred > tempfile**\n$ **cat tempfile**\nfred\n```", "```\n$ **echo \"one two three four five six seven\" > tempfile**\n$ **wc < tempfile**\n1 7 34\n```", "```\n$ **echo \"Hello Robert\" | sed \"s/Hello/Hi/\" | sed \"s/Robert/robot/\"**\nHi robot\n```", "```\nFILE *fopen(\n  const char * restrict filename,\n  const char * restrict mode\n);\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n  FILE my_stdout = *stdout;\n  if (fputs(\"Hello, World!\\n\", &my_stdout) == EOF) {\n    return EXIT_FAILURE;\n  }\n  return EXIT_SUCCESS;\n}\n```", "```\nint open(const char *path, int oflag, ...);\n```", "```\n#include <err.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n  int fd;\n  int flags = O_WRONLY | O_CREAT | O_TRUNC;\n❶ mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;\n  const char *pathname = \"/tmp/file\";\n  if ((fd = open(pathname, flags, mode) ❷) == -1) {\n    err(EXIT_FAILURE, \"Can't open %s\", pathname);\n  }\n  // `--snip--`\n}\n```", "```\nint fclose(FILE *stream);\n```", "```\nif (fclose(fp) == EOF) {\n  err(EXIT_FAILURE, \"Failed to close file\\n\");\n}\n```", "```\nint close(int fd);\n```", "```\nint fputc(int c, FILE *stream);\n```", "```\nint putc(int c, FILE *stream);\n```", "```\nint fputs(const char * restrict s, FILE * restrict stream);\n```", "```\nfputs(\"I \", stdout);\nfputs(\"am \", stdout);\nfputs(\"Groot\\n\", stdout);\n```", "```\nint puts(const char *s);\n```", "```\nputs(\"This is a message.\");\n```", "```\nint fgetc(FILE *stream);\n```", "```\nchar *fgets(char * restrict s, int n, FILE * restrict stream);\n```", "```\nint fflush(FILE *stream);\n```", "```\n#include <err.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nlong int get_file_size(FILE *fp) {\n  if (fseek(fp, 0, SEEK_END) != 0) {\n    err(EXIT_FAILURE, \"Seek to end-of-file failed\");\n  }\n  long int fpi = ftell(fp);\n  if (fpi == -1L) {\n    err(EXIT_FAILURE, \"ftell failed\");\n  }\n  return fpi;\n}\n\nint main() {\n  FILE *fp = fopen(\"fred.txt\", \"rb\");\n  if (fp  == nullptr) {\n    err(EXIT_FAILURE, \"Cannot open fred.txt file\");\n  }\n  printf(\"file size: %ld\\n\", get_file_size(fp));\n  if (fclose(fp) == EOF) {\n    err(EXIT_FAILURE, \"Failed to close file\");\n  }\n  return EXIT_SUCCESS;\n}\n```", "```\n#include <err.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n  FILE *fp = fopen(\"fred.txt\", \"w+\");\n  if (fp == nullptr) {\n    err(EXIT_FAILURE, \"Cannot open fred.txt file\");\n  }\n  fpos_t pos;\n  if (fgetpos(fp, &pos) != 0) {\n    err(EXIT_FAILURE, \"get position\");\n  }\n  if (fputs(\"abcdefghijklmnopqrstuvwxyz\", fp) == EOF) {\n      fputs(\"Cannot write to fred.txt file\\n\", stderr);\n  }\n  if (fsetpos(fp, &pos) != 0) {\n    err(EXIT_FAILURE, \"set position\");\n  }\n  long int fpi = ftell(fp);\n  if (fpi == -1L) {\n    err(EXIT_FAILURE, \"ftell\");\n  }\n  printf(\"file position = %ld\\n\", fpi);\n  if (fputs(\"0123456789\", fp) == EOF) {\n    fputs(\"Cannot write to fred.txt file\\n\", stderr);\n  }\n  if (fclose(fp) == EOF) {\n    err(EXIT_FAILURE, \"Failed to close file\\n\");\n  }\n  return EXIT_SUCCESS;\n}\n```", "```\n0123456789klmnopqrstuvwxyz\n```", "```\nvoid rewind(FILE *stream);\n```", "```\nfseek(stream, 0L, SEEK_SET);\nclearerr(stream);\n```", "```\nint remove(const char *filename);\nint rename(const char *old, const char *new);\n```", "```\nint unlink(const char *path);\nint rmdir(const char *path);\n```", "```\nint fscanf(FILE * restrict stream, const char * restrict format, ...);\n```", "```\n1 HUP Hangup\n2 INT Interrupt\n3 QUIT Quit\n4 ILL Illegal instruction\n5 TRAP Trace trap\n6 ABRT Abort\n7 EMT EMT trap\n8 FPE Floating-point exception\n```", "```\n#include <err.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define TO_STR_HELPER(x) #x\n#define TO_STR(x) TO_STR_HELPER(x)\n\n#define DESC_MAX_LEN 99\n\nint main() {\n  int status = EXIT_SUCCESS;\n  FILE *in;\n\n  struct sigrecord {\n    int signum;\n    char signame[10];\n    char sigdesc[DESC_MAX_LEN + 1];\n❶} rec;\n\n if ((in = fopen(\"signals.txt\", \"r\")) == nullptr) {\n    err(EXIT_FAILURE, \"Cannot open signals.txt file\");\n  }\n\n❷ while (true) {\n  ❸ int n = fscanf(in, \"%d%9s%*[\\t]%\" TO_STR(DESC_MAX_LEN) \"[^\\n]\",\n      &rec.signum, rec.signame, rec.sigdesc\n    );\n    if (n == 3) {\n      printf(\n        \"Signal\\n  number = %d\\n  name = %s\\n  description = %s\\n\\n\",\n        rec.signum, rec.signame, rec.sigdesc\n      );\n    }\n    else if (ferror(in)) {\n      perror(\"Error indicated\");\n      status = EXIT_FAILURE;\n      break;\n    }\n    else if (n == EOF) {\n      // normal end-of-file\n      break;\n    }\n    else if (feof(in)) {\n      fputs(\"Premature end-of-file detected\\n\", stderr);\n      status = EXIT_FAILURE;\n      break;\n    }\n    else {\n      fputs(\"Failed to match signum, signame, or sigdesc\\n\\n\", stderr);\n      int c;\n      while ((c = getc(in)) != '\\n' && c != EOF);\n      status = EXIT_FAILURE;\n    }\n  }\n\n❹ if (fclose(in) == EOF) {\n    err(EXIT_FAILURE, \"Failed to close file\\n\");\n  }\n\n  return status;\n}\n```", "```\nfputs(\"Failed to match signum, signame, or sigdesc\\n\\n\", stderr);\nint c;\nwhile ((c = getc(in)) != '\\n' && c != EOF);\nstatus = EXIT_FAILURE;\n```", "```\nsize_t fwrite(const void * restrict ptr, size_t size, size_t nmemb,\n  FILE * restrict stream);\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct sigrecord {\n  int signum;\n  char signame[10];\n  char sigdesc[100];\n} rec;\n\nint main() {\n  int status = EXIT_SUCCESS;\n  FILE *fp;\n\n❶ if ((fp = fopen(\"signals.bin\", \"wb\")) == nullptr) {\n    fputs(\"Cannot open signals.bin file\\n\", stderr);\n    return EXIT_FAILURE;\n  }\n\n❷ rec sigrec30 = {30, \"USR1\", \"user-defined signal 1\"};\n  rec sigrec31 = {\n    .signum = 31, .signame = \"USR2\", .sigdesc = \"user-defined signal 2\"\n  };\n\n  size_t size = sizeof(rec);\n\n❸ if (fwrite(&sigrec30, size, 1, fp) != 1) {\n    fputs(\"Cannot write sigrec30 to signals.bin file\\n\", stderr);\n    status = EXIT_FAILURE;\n    goto close_files;\n  }\n\n  if (fwrite(&sigrec31, size, 1, fp) != 1) {\n    fputs(\"Cannot write sigrec31 to signals.bin file\\n\", stderr);\n    status = EXIT_FAILURE;\n  }\n\nclose_files:\n  if (fclose(fp) == EOF) {\n    fputs(\"Failed to close file\\n\", stderr);\n    status = EXIT_FAILURE;\n  }\n\n  return status;\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct rec {\n  int signum;\n  char signame[10];\n  char sigdesc[100];\n} rec;\n\nint main() {\n  int status = EXIT_SUCCESS;\n  FILE *fp;\n  rec sigrec;\n\n❶ if ((fp = fopen(\"signals.bin\", \"rb\")) == nullptr) {\n    fputs(\"Cannot open signals.bin file\\n\", stderr);\n    return EXIT_FAILURE;\n  }\n\n  // read the second signal\n❷ if (fseek(fp, sizeof(rec), SEEK_SET)  != 0) {\n    fputs(\"fseek in signals.bin file failed\\n\", stderr);\n    status = EXIT_FAILURE;\n    goto close_files;\n  }\n\n❸ if (fread(&sigrec, sizeof(rec), 1, fp) != 1) {\n    fputs(\"Cannot read from signals.bin file\\n\", stderr);\n    status = EXIT_FAILURE;\n    goto close_files;\n  }\n\n  printf(\n    \"Signal\\n  number = %d\\n  name = %s\\n  description = %s\\n\\n\",\n    sigrec.signum, sigrec.signame, sigrec.sigdesc\n  );\n\nclose_files:\n  if (fclose(fp) == EOF) {\n    fputs(\"Failed to close file\\n\", stderr);\n    status = EXIT_FAILURE;\n  }\n\n  return status;\n}\n```", "```\n#include <stdbit.h>\n#include <stdio.h>\n\nint main (int argc, char* argv[]) {\n  if (__STDC_ENDIAN_NATIVE__ == __STDC_ENDIAN_LITTLE__) {\n    puts(\"little endian\");\n  }\n  else if (__STDC_ENDIAN_NATIVE__ == __STDC_ENDIAN_BIG__) {\n    puts(\"big endian\");\n  }\n  else {\n    puts(\"other byte ordering\");\n  }\n  return 0;\n}\n```"]