- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Caddy: A Contemporary Web Server'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 9 focused on the web service building blocks available to you in Go’s
    standard library. You learned how to create a simple web server with relatively
    little code by using handlers, middleware, and multiplexers. Although you can
    build a capable web server with those tools alone, writing your own server from
    scratch may not always be the quickest approach. Adding support for logging, metrics,
    authentication, access control, and encryption, to name a few features, can be
    daunting and hard to get right. Instead, you may find it more convenient to use
    an existing, comprehensive web server to host your web services.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to the Caddy web server and show you how to
    focus your time on writing web services while relying on Caddy to serve your application.
    You’ll get Caddy up and running and then take a dive into its real-time configuration
    API. Next, you’ll learn how to extend Caddy’s functionality by using custom modules
    and configuration adapters. You’ll then use Caddy to serve your application’s
    static files and proxy requests to your web services. Finally, you’ll learn about
    Caddy’s automatic TLS support by using free certificates from Let’s Encrypt and
    automated key management.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading this chapter, you should feel comfortable choosing the best solution
    for your web applications: either a simple `net/http`-based web server or a comprehensive
    solution like Caddy.'
  prefs: []
  type: TYPE_NORMAL
- en: What Is Caddy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Caddy* is a contemporary web server that focuses on security, performance,
    and ease of use. Among its hallmark features, it offers automatic TLS certificate
    management, allowing you to easily implement HTTPS. Caddy also takes advantage
    of Go’s concurrency primitives to serve a considerable amount of all web traffic.
    It’s one of the few open source projects with enterprise-grade support.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s Encrypt Integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Let’s Encrypt* is a nonprofit certificate authority that supplies digital
    certificates free of charge for the public to facilitate HTTPS communication.
    Let’s Encrypt certificates run on more than half of all websites on the internet,
    and they’re trusted by all popular web browsers. You can retrieve certificates
    for your website by using Let’s Encrypt’s automated issuance and renewal protocol,
    known as *Automated Certificate Management Environment (ACME)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, getting a certificate requires three steps: a certificate request,
    domain validation, and certificate issuance. First, you request a certificate
    for your domain from Let’s Encrypt. Let’s Encrypt then confirms your domain to
    make sure you administer it. Once Let’s Encrypt has ensured that you’re the domain’s
    rightful owner, it issues you a certificate, which your web server can use for
    HTTPS support. Each certificate is good for 90 days, though you should renew it
    every 60 days to prevent service interruption.'
  prefs: []
  type: TYPE_NORMAL
- en: Caddy has inherent support for the ACME protocol and will automatically request,
    validate, and install Let’s Encrypt certificates if Caddy can properly derive
    the domain names it hosts. We’ll discuss how best to do this in “Adding Automatic
    HTTPS” on page 237. Caddy also handles automatic renewals, eliminating the need
    for you to keep track of certificate expiration dates.
  prefs: []
  type: TYPE_NORMAL
- en: How Does Caddy Fit into the Equation?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caddy works just like other popular web servers, such as NGINX and Apache. It’s
    best positioned on the edge of your network, between web clients and your web
    services, as shown in [Figure 10-1](#figure10-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f10001](image_fi/500884c10/f10001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: Caddy reverse-proxying client requests to web services'
  prefs: []
  type: TYPE_NORMAL
- en: Caddy can serve static files and forward requests between clients and backend
    services, a process known as *reverse proxying*. In this example, you can see
    Caddy serving a WordPress blog through PHP’s FastCGI Process Manager (PHP-FPM),
    static files, and a Go-based web service. We’ll replicate a similar setup later
    in the chapter, sans WordPress blog.
  prefs: []
  type: TYPE_NORMAL
- en: Caddy helps abstract web services from clients in much the same way we use abstraction
    in our code. If you use Caddy’s automatic TLS, static file server, data compression,
    access control, and logging features, you won’t have to add that functionality
    to each web service. In addition, using Caddy has the benefit of allowing you
    to abstract your network topography from clients. As the services increase in
    popularity and the capacity on web services starts to negatively affect clients,
    you can add web services to Caddy and instruct Caddy to balance the load among
    them all, without interruption to your clients.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Caddy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll use version 2 of Caddy. You have a few options for installation,
    described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Caddy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install Caddy by using a static binary, built by the Caddy team. This
    binary is available through the download link at [https://caddyserver.com/](https://caddyserver.com/)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Caddy is also available as a Docker image; a DigitalOcean droplet; an Advanced
    Package Tool (APT) source for Debian derivatives; and in the Fedora Copr build
    system for use in Fedora, CentOS, or Red Hat Enterprise Linux. You can find details
    in the Install documentation at [https://caddyserver.com/docs/download](https://caddyserver.com/docs/download).
  prefs: []
  type: TYPE_NORMAL
- en: Building Caddy from Source Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not find a suitable static binary for your operating system and architecture,
    or if you wish to customize Caddy, you can also compile Caddy from source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caddy relies heavily on Go’s support for modules. Therefore, you need to use
    at least Go 1.14 before running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Clone the Caddy Git repository and change to the *caddy/cmd/caddy* subdirectory,
    where you’ll find the `main` package. Run `go build` to create a binary named
    *caddy* in the current directory for your operating system and architecture. To
    simplify commands, the rest of this chapter assumes that the *caddy* binary is
    in your `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: While you’re in this subdirectory, make note of the *main.go* file. You’ll revisit
    it later in this chapter when you learn how to customize Caddy by adding modules.
  prefs: []
  type: TYPE_NORMAL
- en: Running and Configuring Caddy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For configuration purposes, Caddy exposes an administration endpoint on TCP
    port 2019, over which you can interact with Caddy’s configuration in real time.
    You can configure Caddy by posting JSON to this endpoint, and you can read the
    configuration with a `GET` request. Caddy’s full JSON API documentation is available
    at [https://caddyserver.com/docs/json/](https://caddyserver.com/docs/json/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can configure Caddy, you need to start it. Running this command
    starts Caddy as a background process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see log entries showing that the admin endpoint started and Caddy is
    using the initial configuration. You’ll also see log entries printed to standard
    output as you interact with the admin endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Caddy’s configuration is empty by default. Let’s send meaningful configuration
    data to Caddy. [Listing 10-1](#listing10-1) uses the `curl` command to post JSON
    to the `load` resource on Caddy’s admin endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: Posting configuration to Caddy’s admin endpoint'
  prefs: []
  type: TYPE_NORMAL
- en: You send a `POST` request containing JSON in the request body 1 to the `load`
    resource of the Caddy instance listening on port 2019\. The top-level `apps` namespace
    lists the applications Caddy will load at runtime. In this case, you’re telling
    Caddy to load the `http` application. The `http` application configuration consists
    of one or more servers. This example sets up a single server named `hello` listening
    on localhost port 2020\. Feel free to name your server whatever you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `listen` value is an array of addresses, you can configure this server
    to listen to more than one socket address. Caddy passes these address values to
    `net.Listen`, just as you did in Chapter 3. You also have the option of specifying
    a port range, such as *localhost:2020-2025*. Caddy will recognize that you used
    a range and properly extrapolate the range into separate socket addresses. Caddy
    allows you to restrict listeners to specific network types by prefixing the socket
    address. For example, *udp/localhost:2020* tells the server to bind to UDP port
    2020 on localhost. The forward slash is not part of the address but rather a separator.
    If you want the server to bind to a Unix socket */tmp/caddy.sock*, specify the
    address *unix//tmp/caddy.sock*.
  prefs: []
  type: TYPE_NORMAL
- en: The `hello` server’s `routes` value 2 is an array of routes, like the multiplexer
    from the preceding chapter, which dictates how the server will handle incoming
    requests. If a route matches the request, Caddy passes the request onto each handler
    in the `handle` array. Since `handle` is an array, you can specify more than one
    handler per route. Caddy will pass the request to each successive handler in the
    same way you chained middleware together in the preceding chapter. In this example,
    you specify a single route to match all requests and add a single handler to this
    route. You’re using the built-in `static_response` handler 3, which will write
    the value of the `body` (`Hello, world!` in this example) in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provided there are no errors in the configuration, Caddy will at once start
    using the new configuration. Let’s confirm Caddy is now listening on both the
    administrative port 2019 and your `hello` server port 2020:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks good. This command won’t work on Windows. Instead, you can see similar
    output by running the `netstat -b` command in an Administrator command prompt.
    Now, you can ask Caddy for its configuration by sending a `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Caddy returns its JSON-formatted configuration in the response body. Note that
    you need to write the trailing slash on the `/config/` resource, because `/config/`
    is the resource prefix under which Caddy exposes its configuration. You are asking
    Caddy for all resources found under the /`config/` prefix. If you accidentally
    omit the trailing slash, Caddy thinks you’re asking for an absolute resource named
    `/config`, which doesn’t exist in Caddy’s admin API on port 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caddy supports *configuration traversal*. Configuration traversal lets you
    request a subset of the configuration by treating each JSON key in the configuration
    data as a resource address. For example, you can request the `listen` value for
    the `hello` server from our example configuration by issuing a `GET` request,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Caddy returns a JSON array containing *localhost:2020*, just as you’d expect.
    Let’s send a `GET` request to this socket address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You see the `Hello, world!` string returned from the `static_response` handler.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Caddy’s Configuration in Real Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the other HTTP verbs you learned in Chapter 8 to modify your server’s
    configuration. Any changes you make will take immediate effect, so long as Caddy
    can parse the JSON you send. If Caddy fails to parse the JSON, or if a fundamental
    error exists in the new configuration, Caddy will log an error with an explanation
    of what went wrong and continue to use its existing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to make your `hello` server listen on port 2021 as well.
    You can append another `listen` value by using a `POST` request and immediately
    check that the change took effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that Caddy is now listening on port 2021 1 in addition to ports
    2019 and 2020\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to replace the listening addresses and use a range instead.
    For that, you can send a `PATCH` request with the new `listen` array value you
    want Caddy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the admin port 2019, Caddy is now listening on ports 2020 1 through
    2025 2.
  prefs: []
  type: TYPE_NORMAL
- en: Although you may not find yourself changing Caddy’s configuration on the fly
    very often, it’s a handy feature for development, because it lets you quickly
    spin up a new server to add functionality. Let’s add a new server to Caddy while
    it’s running. You’ll name this new server `test` and configure it to listen on
    port 2030\. [Listing 10-2](#listing10-2) adds the new `test` server to Caddy in
    real time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: Adding a new server to Caddy in real time'
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the new server, `test`, is part of the resource you `POST` to.
    You can think of `test` as the key and the JSON in the request body as the value,
    if you defined this server in the original configuration from [Listing 10-1](#listing10-1).
    At this point, Caddy has two servers: `hello` listening on ports 2020 to 2025
    and `test` listening on port 2030\. To confirm Caddy is serving `test`, you can
    check the new endpoint on port 2030:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `static_response` handler properly responds with the expected message.
    If you want to remove the `test` server, it’s as simple as issuing a `DELETE`
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here again, you specify the `test` server in the resource. Caddy is no longer
    listening on localhost port 2030, and the test server no longer exists. You were
    able to stand up a new server to handle entirely different requests without interrupting
    the functionality of your `hello` server. Changing the configuration in real time
    opens possibilities. Do you want a server or route to be accessible only certain
    times of the day? No problem. Do you want to temporarily redirect traffic without
    having to bounce your entire web server, interrupting existing web traffic? Sure,
    go ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the Configuration in a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We typically provide Caddy with its configuration as part of the startup process.
    Write the JSON configuration from [Listing 10-1](#listing10-1) to a file named
    *caddy.json*. Then start Caddy by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Caddy starts in the background, as in [Listing 10-1](#listing10-1)—but this
    time, it populates its configuration from the *caddy.json* file during initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Caddy with Modules and Adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caddy uses a modular architecture to organize its functionality. This modular
    approach allows you to extend Caddy’s capabilities by writing your own modules
    and configuration adapters. In this section, we’ll walk through the process of
    writing a configuration adapter that will allow you to store your Caddy configuration
    in a Tom’s Obvious, Minimal Language (TOML) file. We’ll also replicate the `restrict_prefix`
    middleware from the preceding chapter in a proper Caddy module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Configuration Adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although JSON is a perfectly good format for configuration files, it isn’t as
    well suited for human consumption as other formats. JSON lacks support for comments
    and multiline strings, two characteristics that make configuration files easier
    for people to read. Caddy supports the use of *configuration adapters* that adapt
    one format, such as TOML, to Caddy’s native JSON format. TOML is a configuration
    file format that is easy for humans to read. It supports both comments and multiline
    strings. You can find more details at [https://github.com/toml-lang/toml/tree/v0.5.0/](https://github.com/toml-lang/toml/tree/v0.5.0/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Caddy version 1 supported a custom configuration file format named *Caddyfile*,
    which was also the name of the configuration file by convention. If you want to
    use Caddyfile with Caddy v2, you must rely on a configuration adapter so Caddy
    can ingest it. Caddy is smart enough to know it needs to use the `caddyfile` adapter
    when you specify a filename that starts with *Caddyfile*. But to specify an adapter
    from the command line, you explicitly tell Caddy which adapter to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `adapter` flag tells Caddy which adapter it should use. Caddy will invoke
    the adapter to adapt the configuration file to JSON and then parse the JSON returned
    by the adapter as if you had presented the configuration in JSON format in the
    first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'But Caddy doesn’t ship with an official configuration adapter for TOML, so
    let’s take a crack at writing one. You need to first create a Go module for your
    TOML configuration adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You should use a fully qualified module name 1 different from the one used here.
    I created this module on GitHub under my *awoodbeck* account. The fully qualified
    name for your module will differ depending on where, and under what account, it’s
    hosted.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve created a module, you can write the code. Create a file in the
    current directory named *toml.go* and add the code in [Listing 10-3](#listing10-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: Creating a TOML configuration adapter and registering it with
    Caddy'
  prefs: []
  type: TYPE_NORMAL
- en: You use Thomas Pelletier’s *go-toml* library to parse the configuration file
    contents 3. This saves a considerable amount of code. You then convert the parsed
    TOML into a map 4 and marshal the map to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: The last bit of accounting is to register your configuration adapter with Caddy.
    For this, you include a call to `caddyconfig.RegisterAdapter` in the `init` function
    and pass it the adapter’s type 1 and an `Adapter` object 2 implementing the `caddyconfig.Adapter`
    interface. When you import this module from Caddy’s *main.go* file, the configuration
    adapter registers itself with Caddy, adding support for parsing the TOML configuration
    file. You’ll look at a concrete example of importing this module from Caddy in
    “Injecting Your Module into Caddy” on page 231.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve created the *toml.go* file, tidy up the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command adds the Caddy dependency to the *go.mod* file. All that’s left
    to do is to publish your module to GitHub, as in this example, or another suitable
    version-control system supported by `go get`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Restrict Prefix Middleware Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chapter 9 introduced the concept of middleware, a design pattern that allows
    your code to manipulate a request and a response and to perform ancillary tasks
    when the server receives a request, such as logging request details. Let’s explore
    how to use middleware with Caddy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, middleware is a function that accepts an `http.Handler` and returns
    an `http.Handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An `http.Handler` describes an object with a `ServeHTTP` method that accepts
    an `http.RequestWriter` and an `http.Request`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The handler reads from the request and writes to the response. Assuming `myHandler`
    is an object that implements the `http.Handler` interface, and `middleware1`,
    `middleware2`, and `middleware3` all accept an `http.Handler` and return an `http.Handler`,
    you can apply the middleware functions to `myHandler` in [Listing 10-4](#listing10-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: Multiple middleware functions wrapping a handler'
  prefs: []
  type: TYPE_NORMAL
- en: You can replace any of the middleware functions with the `RestrictPrefix` middleware
    you wrote in the preceding chapter, since it’s a function that accepts an `http.Handler`
    and returns an `http.Handler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately for us, Caddy’s middleware does not use this design pattern,
    so it cannot use `RestrictPrefix`. Caddy includes interfaces for both handlers
    and middleware, unlike `net/http`, which describes only handlers. Caddy’s equivalent
    of the `http.Handler` interface is `caddyhttp.Handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between `caddyhttp.Handler` and `http.Handler` is that the
    former’s `ServeHTTP` method returns an `error` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caddy middleware is a special type of handler that implements the `caddyhttp.MiddlewareHandler`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `caddyhttp.Handler`, Caddy’s middleware accepts both an `http.ResponseWriter`
    and an `http.Request`, and it returns an `error` interface. But it accepts an
    additional argument: the `caddyhttp.Handler`, downstream from the middleware in
    the same way that `myHandler` is downstream from `middleware3` in [Listing 10-4](#listing10-4).
    Instead of accepting an `http.Handler` and returning an `http.Handler`, Caddy
    expects its middleware to act as handlers, with access to the `caddyhttp.Handler`
    that should receive the request and response after the middleware is done with
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new Caddy module that replicates the functionality of your `RestrictPrefix`
    middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As before, your fully qualified module name will differ from mine. Create a
    new file named *restrict_prefix.go* and add the code from [Listing 10-5](#listing10-5)
    to the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: Defining and registering a new Caddy module'
  prefs: []
  type: TYPE_NORMAL
- en: The `RestrictPrefix` middleware implementation from the preceding chapter expected
    the prefix of a URL path as a string. Here, you’re storing the prefix in the `RestrictPrefix`
    struct 2 and assigning it a struct tag to use the `json.Unmarshal` behavior of
    matching incoming keys to struct tags. The struct tag tells `json.Unmarshal` which
    JSON key corresponds to this field. In this example, you’re telling `json.Unmarshal`
    that it should take the value associated with the `prefix` key in the JSON configuration
    and assign it to the struct’s `Prefix` field. The `RestrictPrefix` struct also
    has a `logger` field 3 so you can log events, as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Your module needs to register itself with Caddy upon initialization 1. The `caddy.RegisterModule`
    function accepts any object that implements the `caddy.Module` interface. For
    that, you add the `CaddyModule` method 4 to return information to Caddy about
    your module. Caddy requires an ID 5 for each module. Since you’re creating an
    HTTP middleware handler, you’ll use the ID `http.handler.restrict_prefix`, where
    `restrict_prefix` is the unique name of your module. Caddy also expects a function
    6 that can create a new instance of your module.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can register your module with Caddy, let’s add more functionality
    so you can retrieve the logger from Caddy and validate your module’s settings.
    [Listing 10-6](#listing10-6) picks up where we left off.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: Implementing various Caddy interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: You add the `Provision` method 1 to your struct. Caddy will recognize that your
    module implements the `caddy.Provisioner` interface and call this method. You
    can then retrieve the logger from the given `caddy.Context`2. Likewise, Caddy
    will call your module’s `Validate` method 3 since it implements the `caddy.Validator`
    interface. You can use this method to make sure all required settings have been
    unmarshaled from the configuration into your module. If anything goes wrong, you
    can return an error and Caddy will complain on your behalf. In this example, you’re
    using this method to set the default prefix if one was not provided in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: You’re almost done. The last piece of the puzzle is the middleware implementation
    itself. [Listing 10-7](#listing10-7) rounds out your module’s implementation by
    adding support for the `caddyhttp.MiddlewareHandler` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-7: Implementing the `MiddlewareHandler` interface'
  prefs: []
  type: TYPE_NORMAL
- en: The logic is almost identical to the middleware from the preceding chapter.
    You loop through the URL path components, checking each one for the prefix 1.
    If you find a match, you respond with a 404 Not Found status 2 and log the occurrence
    for debugging purposes 3. If everything checks out, you pass control onto the
    next handler in the chain 4.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good practice to guard against interface changes by explicitly making
    sure your module implements the expected interfaces 5. If one of these interfaces
    happens to change in the future (for example, if you add a new method), these
    interface guards will cause compilation to fail, giving you an early warning that
    you need to adapt your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final steps are to tidy up your module’s dependencies and publish it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Publish your module to GitHub or a similar version-control system supported
    by `go get`.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Your Module into Caddy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The module and adapter you wrote are both self-registering. All you need to
    do to include their functionality in Caddy is to import them at build time. To
    do that, you need to compile Caddy from source. Start by making a directory for
    your build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Building Caddy from source code requires a small amount of boilerplate code,
    to which you’ll include your modules. Your modules register themselves with Caddy
    as a side effect of the import. Create a new file named *main.go* and add the
    code from [Listing 10-8](#listing10-8) into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-8: Injecting custom modules into Caddy'
  prefs: []
  type: TYPE_NORMAL
- en: First, you import the Caddy command module 1 into your build. This has the `Main`
    function that starts the caddy server. Then, you import the standard modules 2
    that you’ll find in Caddy’s binary distribution. Finally, you include your restrict
    prefix module 3 and your TOML configuration adapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that’s left to do now is initialize the `caddy` module and build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should have a binary named `caddy` in the current directory.
    You can verify that it has your custom imports by looking for them in the `caddy`
    binary’s list of modules. The following command is specific to Linux and macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For my Windows friends, run this command instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `caddy` binary you built can read its configuration from TOML files and
    deny clients access to resources whose path includes a given prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse-Proxying Requests to a Backend Web Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have all the building blocks to create something meaningful in Caddy.
    Let’s put everything you’ve learned together by configuring Caddy to reverse-proxy
    requests to a backend web service and serve up static files on behalf of the backend
    web service. You’ll create two endpoints in Caddy. The first endpoint will serve
    up only static content from Caddy’s file server, showing Caddy’s static file-serving
    abilities. The second endpoint will reverse-proxy requests to a backend web service.
    This backend service will send the client HTML that will prompt the client to
    retrieve static files from Caddy, which will show how your web services can lean
    on Caddy to serve static content on their behalf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start building, you need to set up the proper directory structure.
    If you’re following along, you’re currently in the *caddy* directory, which has
    a `caddy` binary built from the code in [Listing 10-8](#listing10-8). Create two
    subdirectories, *files* and *backend*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can retrieve the contents of the *files* subdirectory from [https://github.com/awoodbeck/gnp/tree/master/ch10/files/](https://github.com/awoodbeck/gnp/tree/master/ch10/files/).
    The *backend* subdirectory will store a simple backend service created in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Simple Backend Web Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need a backend web service for Caddy to reverse-proxy requests to, as illustrated
    in [Figure 10-1](#figure10-1). This service will respond to all requests with
    an HTML document that includes the static files Caddy serves on the service’s
    behalf.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-9](#listing10-9) is the initial code for the backend web service.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-9: Creating a backend service (*backend/main.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: This bit of code should be familiar since it’s a simplified version of what
    you wrote in the preceding chapter. You’re setting up a web service that listens
    on port 8080 of localhost 1. Caddy will direct requests to this socket address.
    [Listing 10-10](#listing10-10) implements the `run` function 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-10: The main logic of the backend service (*backend/main.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: The web service receives all requests from Caddy, no matter which client originated
    the request. Likewise, it sends all responses back to Caddy, which then routes
    the response to the right client. Conveniently, Caddy adds an `X-Forwarded-For`
    header 1 to each request with the originating client’s IP address. Although you
    don’t do anything other than log this information, your backend service could
    use this IP address to differentiate between client requests. The service could
    deny requests based on client IP address, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The handler writes a slice of bytes 2 to the response that has HTML defined
    in [Listing 10-11](#listing10-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-11: The index HTML served by the backend service (*backend/main.go*)'
  prefs: []
  type: TYPE_NORMAL
- en: The `/style.css`1 and `/hiking.svg`2 resources do not include a full URL (such
    as [http://localhost:2020/style.css](http://localhost:2020/style.css)) because
    the backend web service does not know anything about Caddy or how clients access
    Caddy. When you exclude the scheme, hostname, and port number in the resource
    address, the client’s web browser should encounter `/style.css` in the HTML and
    prepend the scheme, hostname, and port number it used for the initial request
    before sending the request to Caddy. For that all to work, you need to configure
    Caddy in the next section to send some requests to the backend web service and
    serve static files for the rest of the requests.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Caddy’s Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, Caddy uses JSON as its native configuration
    format. You could certainly write your configuration in JSON, but you’ve already
    written a perfectly good configuration adapter that allows you to use TOML, so
    you’ll implement that instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to configure Caddy to reverse-proxy requests to your backend web service
    and serve static files from the *files* subdirectory. You’ll need two routes:
    one to the backend web service and one for static files. Let’s start by defining
    your server configuration in a file named *caddy.toml* ([Listing 10-12](#listing10-12)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-12: Caddy test server configuration (*caddy.toml*)'
  prefs: []
  type: TYPE_NORMAL
- en: Your TOML adapter directly converts TOML to JSON. Therefore, you need to make
    sure you’re using the same namespaces Caddy expects. The namespace for your server
    is `apps.http.servers.test_server`1. (For simplicity, you’ll refer to this namespace
    simply as `test_server` from here on out.) It listens for incoming connections
    on port 2020 of localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Reverse-Proxy to Your Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Caddy includes a powerful reverse-proxy handler that makes quick work of sending
    incoming requests to your backend web service. Just as in the server implementation
    in the preceding chapter, Caddy matches an incoming request to a route and then
    passes the request onto the associated handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-13](#listing10-13) adds a route and a reverse-proxy handler to
    the *caddy.toml* file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-13: Adding a reverse proxy to the backend service (*caddy.toml*)'
  prefs: []
  type: TYPE_NORMAL
- en: The `test_server` configuration includes a `routes` array 1, and each route
    in the array has zero or more matchers 2. A *matcher* is a special module that
    allows you to specify matching criteria for incoming requests, like the `http.ServeMux.Handle`
    method’s pattern matching discussed in the preceding chapter. Caddy includes matcher
    modules that allow you to consider each part of a request.
  prefs: []
  type: TYPE_NORMAL
- en: For this route, you add a single matcher that matches any request for the absolute
    path */backend* or any path starting with */backend/*3. The *** character is a
    wildcard that tells Caddy you want to match on the */backend/* prefix. For example,
    a request for the resource */backend/this/is/a/test* will also match.
  prefs: []
  type: TYPE_NORMAL
- en: The route may have one or more handlers 4. Here, you tell Caddy you want to
    send all matching requests to the reverse-proxy handler. The reverse-proxy handler
    needs to know where to send the requests. You specify an upstream entry 5 with
    its dial property set to the backend server’s socket address 6.
  prefs: []
  type: TYPE_NORMAL
- en: Serving Static Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You relied on the `http.FileServer` to serve static files for you in the preceding
    chapter. Caddy exposes similar functionality with its `file_server` handler. [Listing
    10-14](#listing10-14) adds a second route to your *caddy.toml* file for serving
    static files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-14: Adding a default route to serve static files (*caddy.toml*)'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the route you added in [Listing 10-13](#listing10-13), this route 1 does
    not include any matchers. As such, Caddy would send every request to this route’s
    handler if the request didn’t match previous routes. In other words, this route
    is your default route, and so its position in the file matters. If you moved this
    route before the reverse-proxy route, all requests would match it, and no requests
    would ever make their way to the reverse proxy. Whenever you specify a route with
    no matches, make sure you put it at the end of your routes array, as you do here.
  prefs: []
  type: TYPE_NORMAL
- en: As with the file server in the preceding chapter, you want to protect against
    accidentally serving sensitive files prefixed with a period. Therefore, you include
    your `restrict_prefix` middleware 2 in the array of handlers before the `file_server`
    handler 3. You add more configuration options to serve files found in the *files*
    subdirectory 4 and return the *index.html* file 5 if the request didn’t specify
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Your Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everything is in place. Start Caddy and verify that your configuration works
    as expected. Since some of the static files are images, I recommend you use a
    web browser to interact with Caddy while it runs on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Caddy by using the *caddy.toml* file and the *toml* adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, the command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the backend web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Open your web browser and visit [http://localhost:2020/](http://localhost:2020/).
    Caddy will send your request to the file server handler, which in turn will respond
    with the *index.html* file, since you didn’t indicate a specific file in the request.
    Your browser then asks Caddy for the *style.css* and *sage.svg* files to finish
    rendering the page. If everything succeeds, you should now be looking at a sage
    gopher.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s test the reverse proxy to the backend web service. Visit [http://localhost:2020/backend](http://localhost:2020/backend).
    This request matches the reverse-proxy route’s matcher, so the reverse-proxy handler
    should handle it, sending the request onto the backend service. The backend web
    service responds with HTML that instructs your browser to retrieve the *style.css*
    and *hiking.svg* files from Caddy, where the file server handler happily serves
    them up. You should now be looking at a hiking gopher rendered using HTML from
    the backend web service and static files from Caddy.
  prefs: []
  type: TYPE_NORMAL
- en: If you copied the *files* subdirectory from this book’s source code repository,
    it should contain *./files/.secret* and *./files/.dir/secret* files. Your middleware
    should block access to both files. In other words, both [http://localhost:2020/files/.secret](http://localhost:2020/files/.secret)
    and [http://localhost:2020/files/.dir/secret](http://localhost:2020/files/.dir/secret)
    will return a 404 Not Found status if you try to request them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Automatic HTTPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s add Caddy’s key feature to your web server: automatic HTTPS.'
  prefs: []
  type: TYPE_NORMAL
- en: I once used Caddy to stand up a website with full HTTPS support, using certificates
    trusted by all contemporary web browsers, in a matter of minutes. The server has
    been rock-solid ever since, happily rotating Let’s Encrypt keys every few months
    with no intervention on my part. This isn’t to say I couldn’t replicate this functionality
    in my own Go-based web server; my time was simply best spent building services
    and leaving the web serving to Caddy. If Caddy lacked any functionality, I could
    add it as a module.
  prefs: []
  type: TYPE_NORMAL
- en: Caddy automatically enables TLS when it can determine what domain names you’ve
    configured it to serve. The *caddy.toml* configuration created in this chapter
    didn’t give Caddy enough information to determine which domain it was serving.
    Therefore, Caddy didn’t enable HTTPS for you. You told Caddy to bind to localhost,
    but that tells Caddy only what it’s listening to, not what domains it’s serving.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common way to enable automatic HTTPS is by adding a host matcher to
    one of Caddy’s routes. Here’s an example matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This host matcher supplies enough information for Caddy to determine that it
    is serving the *example.com* domain. If Caddy doesn’t already have a valid certificate
    for *example.com* to enable HTTPS, it will go through the process of validating
    the domain with Let’s Encrypt and retrieving a certificate. Caddy will manage
    your certificate, automatically renewing it, as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Caddy’s `file-server` subcommand tells Caddy you want it to exclusively serve
    files over HTTP. The `file-server`’s `--domain` flag is enough information for
    Caddy to invoke its automatic HTTPS and allow you to serve files over HTTPS as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Caddy’s `reverse-proxy` subcommand allows you to put Caddy into a reverse-proxy-only
    mode, where it will send all incoming requests onto the socket address specified
    by the `--to` flag. Caddy will retrieve a TLS certificate and enable automatic
    HTTPS if you specify a hostname with the `--from` flag.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to read more about Caddy’s automatic HTTPS in production environments
    at [https://caddyserver.com/docs/automatic-https](https://caddyserver.com/docs/automatic-https).
  prefs: []
  type: TYPE_NORMAL
- en: What You’ve Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caddy is a contemporary web server written in Go that offers security, performance,
    and extensibility through modules and configuration adapters. Caddy can automatically
    use HTTPS through its integration with Let’s Encrypt, a nonprofit certificate
    authority that supplies free digital certificates. Together, Caddy and Let’s Encrypt
    allow you to stand up a web server with seamless HTTPS support.
  prefs: []
  type: TYPE_NORMAL
- en: Caddy uses JSON as its native configuration format, and it exposes an API on
    localhost port 2019 that allows you to post JSON to change its configuration.
    The configuration changes take immediate effect. But since JSON isn’t an ideal
    configuration format, Caddy makes use of configuration adapters. Configuration
    adapters translate configuration files from more configuration-friendly formats,
    like TOML, to JSON. If you don’t want to use JSON for your Caddy configuration
    or if you don’t find a configuration adapter that meets your needs, you can also
    write your own, as you did in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can also extend Caddy’s functionality with the use of modules. This chapter
    shows how to write a middleware module, compile it into Caddy, configure the module,
    and put it to effective use.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter showed you how to integrate Caddy into your network architecture.
    You’ll often make Caddy the first server in your network, using it to receive
    client requests before sending the requests onto their final destinations. In
    this chapter, you configured an instance of Caddy to reverse-proxy client requests
    to your backend web service and serve static files on behalf of the backend web
    service. As a result, you kept your backend web service as simple as possible
    and saved it from having to manage its static content. Your backend web service
    can use Caddy for HTTPS support, caching, and file serving.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have some experience with Caddy, you should be able to determine
    whether your web services would do better when served by a comprehensive web server
    solution or a comparatively minimal `net/http` web server implementation. If you
    expect to make your web service available to the public, using a proven web server
    like Caddy at the edge of your application will free up time you can better spend
    on your backend web service.
  prefs: []
  type: TYPE_NORMAL
