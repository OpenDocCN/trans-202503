- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to the Integrated Development Environment
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we’ve used individual tools such as GCC, `make`, and a text editor to
    build our program. This has allowed you to see what each tool does and learn about
    the details of software development. Now you’ll learn about using an integrated
    development environment (IDE). The IDE is a program designed to take all those
    tools (and some others) and hide them behind one integrated interface.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this approach is that you can use one GUI-based tool to
    do everything. The major disadvantage is that it works well only if you behave
    the way the IDE expects you to behave. Also, it hides a great deal from you. For
    example, to get a linker map, you have to go through several layers of GUI and
    enter the map option in an obscure customization box.
  prefs: []
  type: TYPE_NORMAL
- en: The IDE we’ll use in this book is the System Workbench for STM32 IDE. From its
    name, you can tell it was created for the STM32 microprocessors. An enhancement
    to a very popular IDE called Eclipse, it includes an editor, debugger, and compiler.
    It is especially powerful when it comes to debugging, because remotely debugging
    on a microcontroller involves a lot of tools, and the IDE makes them work together
    seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To practice using the IDE, you’ll write the same “Hello World” program you
    wrote in Chapter 1, only this time you will wrap every step of the process in
    a unified GUI. In one respect, the IDE makes things simpler by hiding the compiler
    and other tools from you. In other ways, it makes things more complex, because
    accessing those tools to tune them is more difficult. For example, if I want to
    add the flag `-Wextra` to the compiler command line without an IDE, all I do is
    edit the makefile. When using an IDE, I have to find the magic box in which I
    can enter this value (spoiler: it’s Project▶Properties and then C/C++ Build▶Settings▶Tool
    Settings▶GCC Compiler▶All Options).'
  prefs: []
  type: TYPE_NORMAL
- en: Using System Workbench for STM32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve used a text editor, a compiler called GCC,and a program called
    `make` to run the compiler. As we get into more complex programs, we’ll need a
    debugger as well.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32 Workbench bundles all these tools into one integrated development
    environment that is built on the Eclipse IDE. In fact, it *is* Eclipse, with lots
    of special STM32 stuff added, and I’ll refer to it as such in the following discussion.
    We’ll get deeper into the STM32 side of things in Chapter 3. For now, let’s explore
    the IDE by writing a “Hello World” program.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you followed the advice at the beginning of Chapter 1, you’ve already downloaded
    System Workbench for STM32\. Install it using the instructions from the website.
    The standard installation creates a desktop icon and a startup menu item, so you
    should be able to start the IDE in the same way as any other program.
  prefs: []
  type: TYPE_NORMAL
- en: When first started, Eclipse asks for the location of your workspace. Enter the
    directory that will contain all the projects for this book. Next, Eclipse should
    display the Welcome screen. Dismiss the screen by clicking the close icon (the
    little X next to the tab).
  prefs: []
  type: TYPE_NORMAL
- en: A window should pop up indicating that the system is downloading additional
    tools for the ARM processor. When the system finishes, you should get a C/C++
    view of an empty project, as shown [Figure 2-1](#figure2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02001](image_fi/501621c02/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: An empty project screen'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse is the frontend for a *lot* of tools. Displaying them in an organized
    manner is quite a challenge. To cope with this, Eclipse uses the concept of views.
    A *view* is a window layout that is designed for a particular task. For example,
    a Java programmer might have a different view than that of a C programmer. Likewise,
    debugging requires a different view than coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default view in this version of Eclipse is that of a C/C++ project. (You
    can change the view at any time by using the Window▶View menu.) On the left of
    the view is the Project Explorer (currently empty), which allows you to view your
    projects and their details. In the upper middle, you have a text editor. On the
    right is a window with three tabs: Outline, Build Targets, and Task List. We’ll
    go into them when we get to more complex projects.'
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom is a small, wide window with the tabs Problems, Tasks, Console,
    Properties, and Call Graph. The Problems window contains a list of the errors
    and warnings generated by the code in your current project. The Console window
    contains the output of the build process. The other tabs we’ll worry about when
    we start generating more complex programs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Hello World
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will now create another “Hello World” project. You must take certain steps
    whenever you create a native C project (*native* means the program runs on the
    machine on which it was compiled; if you compile it on one machine and run it
    on another, that’s called *cross-compilation*), and this chapter goes through
    them in detail. You will be going through these steps a lot; so that you don’t
    have to remember them all, refer to the checklist in the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project by selecting **File**▶**New**▶**C Project** from the menu
    bar. This brings up the C Project dialog.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen the name *02.hello-ide* for our project, as it’s unique and descriptive.
    Project names can contain any character except spaces and special characters such
    as a forward slash (/), backslash (\), colon (:), and other characters that have
    special meaning for your filesystem. Letters, digits, dashes, dots, and underscores
    are okay.
  prefs: []
  type: TYPE_NORMAL
- en: For the project type, select **Hello World ANSI C Project**. For toolchains,
    select the toolchain for your operating system, as shown in [Figure 2-2](#figure2-2).
    Click **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02002](image_fi/501621c02/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: The project creation dialog'
  prefs: []
  type: TYPE_NORMAL
- en: We now see the Basic Settings dialog. Leave these settings alone and click **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: The next dialog is Select Configurations (see [Figure 2-3](#figure2-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02003](image_fi/501621c02/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: The Select Configurations dialog'
  prefs: []
  type: TYPE_NORMAL
- en: You have a lot of different options for building your project. Eclipse groups
    these into project configurations. The two defined by default are Release and
    Debug. Release produces highly optimized code that is difficult if not impossible
    to debug. Debug produces unoptimized, easy-to-debug code and generates debug symbols.
    Since you are learning, we’ll stick with the Debug configuration. Deselect the
    **Release** configuration, leaving only **Debug** selected, and click **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: The IDE creates our project and generates a number of files. One of these is
    our source code, already filled in with its version of a “Hello World” program
    (see [Figure 2-4](#figure2-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02004](image_fi/501621c02/f02004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: The result of creating our “Hello World” project'
  prefs: []
  type: TYPE_NORMAL
- en: If you enter any code yourself, note that the Eclipse editor uses a tab size
    of 4 by default, which means that when you use a tab to indent a line in source
    code, the tab will have a width of four spaces. Practically every other editor
    and tool uses eight spaces. You can fix this with one of the configuration items
    in Window▶Preferences. (Telling you how to further customize Eclipse would take
    a whole book, and this is not that book.)
  prefs: []
  type: TYPE_NORMAL
- en: At this point we would be done—if we were writing in Java. Eclipse was designed
    for Java. C is an add-on that *almost* completely works. We have to do one more
    fix-up.
  prefs: []
  type: TYPE_NORMAL
- en: First, compile the project by choosing **Project**▶**Build Project**. Then select
    **Run**▶**Run Configurations**, which should bring up the Run Configurations dialog.
    Next, click **C/C++ Application** on the left side, and then click the small icon
    on the left of the icon row to create a new configuration. Finally, under C/C++
    Application, click **Browse**, as shown in [Figure 2-5](#figure2-5).
  prefs: []
  type: TYPE_NORMAL
- en: Use the file browser to find your executable in the *Debug* directory. The IDE
    has created a project directory for you in your workspace (the location of which
    is system-dependent) that has the same name as your project. All the files for
    your project are in this directory. Within the project directory, a *Debug* directory
    contains all the files built as part of the Debug build (the only type of build
    we are doing). Within that directory, you’ll find *02.hello-ide* on macOS and
    Linux or *02.hello-ide.exe* on Windows. Select this file, as shown [Figure 2-6](#figure2-6),
    and then click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02005](image_fi/501621c02/f02005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: The Run Configurations dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '![f02006](image_fi/501621c02/f02006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: The Application Selection dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Next, click **Apply** and **Close** to finish the run configuration. This setup
    tells the IDE where your program is actually located. (Since it decided where
    to put it, you’d think it would know where it went, but for some reason it doesn’t.)
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s actually run the program. Select **Run**▶**Run**. The results should
    appear in the Console window, as shown in [Figure 2-7](#figure2-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02007](image_fi/501621c02/f02007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-7: The results of our program'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now for a quick introduction to the *debugger*, which watches our program execute
    and lets us see what’s going on inside it. First, let’s generate a little more
    code to debug by duplicating line 15 (`puts("!!!Hello World!!!");`) and then save
    the project by choosing **File**▶**Save All**.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to choose File▶Save All after each edit. If you were to run
    the program now, before saving all files, the compiler would see the old, unsaved
    file on disk and compile it. The resulting program would print `!!!Hello World!!!`
    only once instead of twice, which could get very confusing. The code we have in
    front of us is correct; the code we are running is not. Until you choose File▶Save
    All, the files are not the same. (End of soapbox mode.)
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s start the debugger with **Run**▶**Debug** (see [Figure 2-8](#figure2-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02008](image_fi/501621c02/f02008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-8: Starting the debugger'
  prefs: []
  type: TYPE_NORMAL
- en: The IDE is about to switch into debugging mode, which changes the perspective
    from development to debugging. This means a whole new window arrangement. The
    system warns you that this is about to happen, as shown in [Figure 2-9](#figure2-9).
    (Remember that you can always switch perspectives with the command Window▶Perspective▶C/C++
    or Window▶Perspective▶Debug.)
  prefs: []
  type: TYPE_NORMAL
- en: '![f02009](image_fi/501621c02/f02009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9: The debug perspective warning'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Yes** in the warning. The debug perspective should open, as shown in
    [Figure 2-10](#figure2-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02010](image_fi/501621c02/f02010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-10: The debug perspective'
  prefs: []
  type: TYPE_NORMAL
- en: In the upper left is the Stack Tracewindow, which shows the program being executed
    and how far into it you are. This information will become more useful when we
    discuss stack usage in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to that is the Variables/Breakpoints/Registers/I/O Registers/Modules window,
    which contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables **Information about the program’s variables. (More on this starting
    with Chapter 4.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Breakpoints **A *breakpoint* is a location in your program at which the program
    stops and lets the debugger examine it. You can set a breakpoint by double-clicking
    the line number of an executable line in your program. We’ll start using them
    in Chapter 3.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Registers **Information about the current state of the processor’s registers.
    (Discussed in Chapter 10.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Modules **The dynamically linked modules. Since this feature is not available
    to embedded programmers, we won’t be discussing it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the middle of the screen, the Source window displays our program. The highlighted
    line of code indicates that the debugger has run the program up to this line and
    stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Next to the Source window is the Outline panel. This is like a table of contents
    indicating which files go into our program. I’ve included the files *stdio.h*
    and *stdlib.h* so that they show up here.
  prefs: []
  type: TYPE_NORMAL
- en: Across the bottom is the Console/Tasks/Problems/Executables/Memory window. The
    Console window displays the output from the program. All the other tabs contain
    information we’re not interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll *step through* the program, meaning we will execute one statement
    at a time using the debugger. Click the Step Over icon at the top of the screen
    (see [Figure 2-11](#figure2-11)) or press F6 to step over the current line.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02011](image_fi/501621c02/f02011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11: Step Over (F6)'
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted line in the Source window advances one line, and `!!!Hello World!!!`
    appears in the Console window (see [Figure 2-12](#figure2-12)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02012](image_fi/501621c02/f02012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12: Single-step results'
  prefs: []
  type: TYPE_NORMAL
- en: If you keep stepping, you’ll see the second `puts` executed, followed by the
    `return`statement. After that, the program goes into the system library to do
    cleanup work. Since we don’t have the source code for this library, the debugger
    can display no information about it.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other significant icons on the toolbar (see [Figure 2-13](#figure2-13)).
    The Resume icon (or F8 key) runs the program until it finishes or hits a breakpoint.
    The Debug icon restarts debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02013](image_fi/501621c02/f02013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13: Debugging commands'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make use of the debugger a lot in coming chapters. It will provide a very
    useful way of getting information out of our running program and seeing what’s
    going on. To return to the original C/C++ perspective, select **Window**▶ **Perspective**▶**Open
    Perspective**▶**C++**.
  prefs: []
  type: TYPE_NORMAL
- en: What the IDE Did for Us
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IDE generated the C source file, including the `puts` functions, to print
    “Hello World.” It also generated a file called *Debug/makefile*, which is used
    as input to the `make` program. [Listing 2-1](#listing2-1) contains an excerpt
    from this file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: An excerpt from *Debug/makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: This makefile is located in the *Debug* directory. The IDE supports multiple
    build configurations and generates a makefile in a different directory for each
    of them. (For this project, we created only a Debug configuration. Other projects
    may also use a Release configuration.)
  prefs: []
  type: TYPE_NORMAL
- en: The makefile is more complex than the one we generated ourselves in Chapter
    1 because the IDE uses lots and lots of advanced `make` syntax. The IDE also generated
    the files *sources.mk* 1 and *objects.mk* 2, which are included in the makefile.
    What we can see from these files is that computer-generated stuff is designed
    to be very flexible at the cost of making the thing nearly impossible to read.
  prefs: []
  type: TYPE_NORMAL
- en: As it stands now, the IDE does not generate or download a lot of data. But when
    we start to do embedded programming, this will change dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Book’s Programming Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The programming examples used in this book can be downloaded at [https://nostarch.com/bare-metal-c.](https://nostarch.com/bare-metal-c.)
    To use the downloaded programming examples, you’ll need to import them. (You can’t
    just stick the files in your workspace; that would be too easy.) To perform an
    import, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File**▶**Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Import dialog, select **General**▶**Existing Projects into Workspace**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the radio button **Select Archive File** and then click **Browse** after
    the blank space to select the file containing the project (the one you downloaded
    from the website).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IDE is a mixed blessing. On the one hand, you don’t have to worry about
    all the tools that it takes to create a program. You didn’t have to create the
    makefile, manually perform the build, or run the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: But this hands-off approach comes with a price. To add a compile-time flag to
    your program from Chapter 1, you just add the flag to the makefile. With the IDE,
    you can’t do this, because the IDE generates the makefile on its own. You have
    to find the right configuration item to do it in the IDE, and, as we will discover,
    the IDE has a lot of options.
  prefs: []
  type: TYPE_NORMAL
- en: In this book I try to keep things as simple as possible through the use of checklists
    (like the one in the appendix) and standard procedures. Eclipse tries to take
    care of everything, but you will occasionally need to tweak things under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find out what happens when you put `\t` in a string to be printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Chapter 1, we used `printf` to print the message. In this chapter, Eclipse
    uses `puts`. Look up the documentation of these functions to see how they are
    different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is an IDE?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the files generated by our IDE, and what do they contain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you get help with using C and Eclipse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
