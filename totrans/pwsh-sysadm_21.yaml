- en: '18'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING AND CONFIGURING A SQL SERVER
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, you’ve created a module that can create a VM, attach a VHD to it, install
    Windows, and create (and populate) an Active Directory forest. Let’s add one more
    thing to that list: deploying a SQL server. With a VM provisioned, an OS installed,
    and a domain controller set up, you’ve done most of the hard work! Now you just
    need to leverage your existing functions and, with a few tweaks, you’ll be able
    to install a SQL server.'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this chapter, I’m assuming that you’ve been following along in [Part
    III](part3.xhtml#part3) and have created at least one VM called LABDC that’s running
    on your Hyper-V host. This VM will be a domain controller, and since you’ll again
    be connecting to multiple VMs via PowerShell Direct, you’ll need the domain credential
    saved to the Hyper-V host (check out [Chapter 17](ch17.xhtml#ch17) to see how
    we did this).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use a script called *ManuallyCreatingASqlServer.ps1* (found in this chapter’s
    resources) to explain how to properly automate the deploying of a SQL server.
    This script contains all the rough steps covered in this chapter and will be a
    great resource to reference as you progress through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As always, please run the Prerequisites test script included with this chapter
    to ensure you meet all the expected prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Virtual Machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you think *SQL Server*, you probably think about things like databases,
    jobs, and tables. But before you can even get there, a ton of background work
    has to be done: for starters, every SQL database must exist on a server, every
    server needs an operating system, and every operating system needs a physical
    or virtual machine to be installed on. Luckily, you’ve spent the past few chapters
    setting up the exact environment you need to create a SQL server.'
  prefs: []
  type: TYPE_NORMAL
- en: A good automator starts every project by breaking down all the required dependencies.
    They automate around those dependencies, and then on top of them. This process
    results in a modular, decoupled architecture that has the flexibility to be changed
    at any time with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: What you’re ultimately looking for is a single function that uses a standard
    configuration to bring up any number of SQL servers. But to get there, you have
    to think about this project in layers. The first layer is the virtual machine.
    Let’s handle that first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you already have a function in your PowerLab module that’ll build a VM,
    you’ll use that. Because all lab environments you build are going to be the same,
    and because you defined many of the parameters needed to provision a new VM as
    default parameter values in the `New-PowerLabVM` function, the only value you
    need to pass to this function is the VM name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Installing the Operating System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like that, you have a VM ready to go. That was easy. Let’s do it again.
    Use the command you wrote in [Chapter 16](ch16.xhtml#ch16) to install Windows
    on your VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Oops! You used the existing `Install-PowerLabOperatingSystem` function in the
    PowerLab module to install the operating system on the soon-to-be SQL server,
    but it failed because it was referencing a file called *SQLSRV.xml* in the module
    folder. When you built this function, you assumed there would be an *.xml* file
    in the module folder. Problems like path discrepancies and files that don’t exist
    are common when building large automation projects like this. You’ll have many
    dependencies that you must address. The only way to flush out all these bugs is
    to execute the code as many times as possible in as many scenarios as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Windows Unattended Answer File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Install-PowerLabOperatingSystem` function was assuming there would always
    be a file called *.xml* in the PowerLab module folder. This means that before
    you deploy a new server, you have to first ensure that you have this file in the
    right place. Luckily, now that you created the LABDC unattended answer file, this
    should be easy. The first thing you have to do is copy the already-existing *LABDC.xml*
    file and call it *SQLSRV.xml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve made a copy, you have to make a few tweaks: the name of the host
    and the IP address. Since you haven’t deployed a DHCP server, you’ll use static
    IP addresses and have to change them (otherwise you’d have to change just the
    server name).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open *C:\Program Files\WindowsPowerShell\Modules\SQLSRV.xml* and look for the
    spot that defines the hostname. Once you find it, change the `ComputerName` value.
    It should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, look for the `UnicastIPAddress` node. It will look like the following
    code. Note I’m using a 10.0.0.0/24 network and have chosen to make my SQL server
    have the IP address of 10.0.0.101:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Save the *SQLSRV.xml* file and try running the `Install-PowerLabOperatingSystem`
    command again. At this time, your command should run successfully and should deploy
    Windows Server 2016 to your SQLSRV VM.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SQL Server to a Domain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You just installed the operating system, so now you need to start up the VM.
    This is easy enough using the `Start-VM` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you have to wait for the VM to come online—this could take a while. How
    long? That depends; there are a lot of variables. One thing you can do is use
    a `while` loop to continually check whether you can connect to the VM.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk though how to do this. In [Listing 18-1](ch18.xhtml#ch18list1), you’re
    grabbing the locally saved credential for the VM. Once you have that, you can
    create a `while` loop that keeps executing the `Invoke-Command` until something
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you’re using the `Ignore` value for the `ErrorAction` parameter.
    You have to do this because without it, when `Invoke-Command` can’t connect to
    a computer, it will return a nonterminating error message. To avoid having your
    console flood with expected errors (since you know that it might not connect and
    are OK with it), you’re ignoring the error messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-1: Checking to see whether the server is alive, and ignoring the
    error messages*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the VM finally comes up, it’s time to add it to the domain you created
    in the preceding chapter. The command that adds a computer to a domain is `Add-Computer`.
    Since you’re running all commands from the Hyper-V host itself, and aren’t depending
    on network connectivity, you need to wrap the `Add-Computer` command in a scriptblock
    and execute it via PowerShell Direct to run it directly on SQLSRV itself.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in [Listing 18-2](ch18.xhtml#ch18list2), you have to use both the
    local user account for the VM and a domain account. To do so, you first make a
    connection to the SQLSRV server itself by using `Invoke-Command`. Once you are
    connected, you’ll pass the domain credential to the domain controller to get authenticated,
    which will let you add the computer account.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-2: Retrieving the credentials and adding the computer to the domain*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you’re using the `$using` keyword ❶. This keyword allows you to
    pass the local variable `$addParams` to the remote session on your SQLSRV server.
  prefs: []
  type: TYPE_NORMAL
- en: Since you used the `Restart` switch parameter on `Add-Computer`, the VM will
    restart as soon as it gets added to the domain. Again, because you have further
    work to do, you need to wait for this to happen. However, this time, you need
    to wait for it to go down *and* come back up ([Listing 18-3](ch18.xhtml#ch18list3))
    because the script is so fast that if you don’t wait for it to go down first,
    you risk the script continuing because it detected that it was up when it didn’t
    even go down yet!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-3: Waiting for the server to reboot*'
  prefs: []
  type: TYPE_NORMAL
- en: You first check whether SQLSRV has been powered down by simply returning the
    number 1 on SQLSRV ❶. If it receives output, this means that PowerShell remoting
    is available and thus SQLSRV has not been powered down yet. If output is returned,
    you then pause for 10 seconds ❷, write a message to the screen ❸, and try again.
  prefs: []
  type: TYPE_NORMAL
- en: You then do the opposite when testing to see when SQLSRV comes back up. Once
    the script releases control of the console, SQLSRV should now be up and added
    to your Active Directory domain.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the SQL Server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve created a VM with Windows Server 2016, you can install SQL Server
    2016 to it. This is new code! Up until now, you simply leveraged existing code;
    now you’re back blazing new trails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing SQL Server via PowerShell consists of a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Copying, and tweaking, a SQL Server answer file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copying the SQL Server ISO file to the soon-to-be SQL server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mounting the ISO file on the soon-to-be SQL server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the SQL Server installer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dismounting the ISO file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning up any temporary copied files on the SQL server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copying Files to the SQL Server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As per our plan, the first thing to do is to get a few files on the soon-to-be
    SQL server. You need the unattended answer file that the SQL Server installer
    needs, and you also need the ISO file that contains the SQL Server installation
    content. Since we’re assuming that you have no network connectivity from the Hyper-V
    host to the VMs, you’ll again use PowerShell Direct to copy these files. To use
    PowerShell Direct to copy files, you first need to create a session on the remote
    VM. In the following code, you’re using the `Credential` parameter to authenticate
    to SQLSRV. If your server were in the same Active Directory domain as the computer
    you’re currently working on, the `Credential` parameter would not be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make a copy of the template *SQLServer.ini* file found in the PowerLab
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once that’s done, you’ll modify the file to match the configuration you need.
    Recall that earlier, when you needed to change some values, you manually opened
    the unattended XML file. This was more work than you needed to do—believe it or
    not, you can automate this step as well!
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 18-4](ch18.xhtml#ch18list4), you’re reading in the contents of the
    copied template file, looking for the strings `SQLSVCACCOUNT=`, `SQLSVCPASSWORD=`,
    and `SQLSYSADMINACCOUNTS=` and replacing those strings with specific values. When
    you’re finished, rewrite the copied template file with your new changed strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-4: Replacing the strings*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the answer file, and have copied that file and the SQL Server
    ISO file to the soon-to-be SQL server, the installer will be ready to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Running the SQL Server Installer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’re finally ready to install SQL Server. [Listing 18-5](ch18.xhtml#ch18list5)
    contains the code to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-5: Using `Invoke-Command` to mount, install, and dismount the image*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you mount the copied ISO file on the remote machine ❶; then you execute
    the installer, assigning the output to `$null` ❷ as you don’t need it; lastly,
    when you’re all done, you dismount the image ❸. In [Listing 18-5](ch18.xhtml#ch18list5),
    you’re using `Invoke-Command` and PowerShell Direct to remotely execute these
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: When SQL Server has been installed, do some cleanup work to ensure that you
    remove all the temporary copied files, as shown in [Listing 18-6](ch18.xhtml#ch18list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-6: Cleaning up the temporary files*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the SQL Server will be set up and ready to go! In just 64 lines
    of PowerShell, you created a Microsoft SQL Server from nothing but a Hyper-V host.
    This is great progress, but you can make it even better.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the SQL Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve done most of the heavy lifting already. By now, you have a script that
    does everything you need it to do. What you want next is to roll all that functionality
    into a few functions in your PowerLab module: the `New-PowerLabSqlServer` and
    `Install-PowerLabOperatingSystem` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll follow the basic automation pattern established in the previous chapters:
    build functions around all the common actions and call them instead of using hardcoded
    values in many places. The result will be a single function the user can call.
    In [Listing 18-7](ch18.xhtml#ch18list7), you use existing functions to create
    the VM and VHD, and create a second `Install-PowerLabSQLServer` function to house
    the code for installing the SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-7: The `New-PowerLabSqlServer` function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should recognize most of this code: it’s the exact same code we covered
    just a bit ago, here wrapped in a function for easy reuse! I used the same code
    body but instead of using hardcoded values, I parameterized many attributes, allowing
    you to install SQL Server with different parameters without changing the code
    itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Turning specific scripts into a general function preserves the functionality
    of your code and allows greater flexibility if at some point in the future you
    want to change the behavior of how you deploy SQL servers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the important pieces of the `Install-PowerLabSqlServer`
    code in [Listing 18-8](ch18.xhtml#ch18list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-8: The `Install-PowerLabSqlServer` PowerLab module function*'
  prefs: []
  type: TYPE_NORMAL
- en: You parameterize all the types of input you need to install SQL Server ❶ and
    add an error-handling step ❷ to check whether SQL Server is already installed.
    This allows you to run the function over and over again; if SQL Server is already
    installed, the function will simply skip over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that you call a function you haven’t seen before: `PrepareSqlServerInstallConfigFile`
    ❸. This is a *helper function*: a small function that captures some bit of functionality
    you’re likely to use again and again (helper functions are usually hidden from
    the user and used behind the scenes). Although not required by any means, breaking
    out small bits of functionality like this makes code more readable. As a general
    rule, functions should only do one “thing.” *Thing* here is, of course, a highly
    relative term, but the more you program, the more you’ll have an intuitive sense
    for when a function is doing too many things at once.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 18-9](ch18.xhtml#ch18list9) is the code for the `PrepareSqlServerInstallConfigFile`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 18-9: The `PrepareSqlServerInstallConfigFile` helper function*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll recognize this code from [Listing 18-4](ch18.xhtml#ch18list4); it hasn’t
    changed much. You added the parameters `Path`, `ServiceAccountName`, `ServiceAccountPassword`,
    and `SysAdminAccountName` to represent each attribute instead of the hardcoded
    values used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have all your functions in a row, bringing up an SQL server from
    scratch is just a few commands away. Run the following code to bring up a SQL
    server from scratch!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running Pester Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s that time again: let’s run some Pester tests to test the new changes you
    implemented. For this chapter, you installed SQL Server on the existing SQLSRV
    VM. You didn’t do too much configuring when you installed, and accepted most of
    the installation defaults, so you’ll have only a few Pester tests: you have to
    make sure that SQL Server is installed, and you have to make sure that during
    installation it read the unattended configuration file you supplied it. You can
    do this by verifying that `PowerLabUser` holds a server sysadmin role and that
    SQL Server is running under the `PowerLabUser` account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Everything checks out, so you’re good to go!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you finally saw a more fleshed-out example of what you can
    do with PowerShell. Building on the work in previous chapters, you added that
    final layer of automation: installing software (SQL Server) on top of an operating
    system that was “layered” on top of a virtual machine. You did this in much the
    same way as in the past few chapters. You used a single example to figure out
    the code you needed; then you packaged that code in a reusable format and put
    it inside your PowerLab module. And now that that’s done, you can build as many
    SQL servers as you want with nothing more than a few lines of code!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll do something a little different: revisit code you’ve
    already written and refactor it. You’ll learn about best coding practices and
    make sure your module is in the place you need it to be before adding the final
    piece in [Chapter 20](ch20.xhtml#ch20).'
  prefs: []
  type: TYPE_NORMAL
