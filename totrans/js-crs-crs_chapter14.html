<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>JavaScript Crash Course</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:26ab05bf-a247-42ca-b08d-ede069333d2b" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch14" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch14">
<span class="CN"><span aria-label=" Page 255. " epub:type="pagebreak" id="pg_255" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCING THE D3 LIBRARY</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.png"/>
</figure>
<p class="INTROTNI2">Today’s world is full of data, but raw data is basically impossible to understand without visualizing it in some way. Data visualizations can be incredibly simple, such as a chart on Wikipedia showing the average temperature each month in a particular city, or highly intricate, such as an animated infographic from a news organization illustrating the income mobility of tens of thousands of Americans. No matter the level of complexity, however, data visualizations always have the potential to give us more insight into the data we’re exploring.</p>
<p class="TX">In this project you’ll learn to use a powerful JavaScript library called D3.js (or D3 for short), which will enable you to create a whole range of <span aria-label=" Page 256. " epub:type="pagebreak" id="pg_256" role="doc-pagebreak"/>data visualizations in the browser. The great thing about using JavaScript to make data visualizations is that they can be dynamic and interactive. <i>Dynamic</i> means the visualization can change over time; for example, they can be updated as new data comes in. <i>Interactive</i> means the user can manipulate the visualization, for example, by clicking to reveal more detail about a particular aspect. Also, because you’re coding up the visualizations yourself, you’re free to customize them in any way you want.</p>
<p class="TX">This chapter introduces you to the basics of working with D3, to prepare you for the next chapter, where you’ll create an interactive visualization by loading data from an external API. D3 primarily uses a web graphics technology called Scalable Vector Graphics (SVG), so we’ll start with a crash course in SVG before we dive into D3 itself.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-85"/><samp class="SANS_Futura_Std_Bold_B_11">The SVG Graphics Format</samp></h3>
<p class="TNI1">SVG is a way of defining images using points, lines, and curves, rather than pixels. These images are known as <i>vector graphics</i>. Because you’re defining the <i>shape</i> of the image rather than the individual pixels themselves, you can resize or zoom in on an SVG image without it becoming pixelated (hence the <i>scalable</i> part of the name).</p>
<p class="TX">SVG is based on Extensible Markup Language (XML), a language for storing data that, like HTML, relies on a structure of nested elements with start and end tags. SVG XML looks similar to HTML, but it has its own set of tags that correspond directly to visual elements (in HTML, by contrast, the tags are used to define structure and content). SVG files can be standalone XML files, but SVG can also be embedded in an HTML file using the HTML <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element, making it easy to add SVG graphics to a web page.</p>
<p class="TX">One advantage of SVG over the Canvas API for rendering interactive graphics on the web is that each element of an SVG drawing is represented by a DOM element on the web page, which means you can style it with CSS and use JavaScript to add event handlers to respond to mouse events like clicks or hovers. On the other hand, Canvas-based graphics are faster to render, so applications like games that need a high frame rate tend to use the Canvas API rather than SVG.</p>
<p class="TX">Let’s write our first SVG. Make a new directory called <i>svg</i> and create an <i>index.html</i> file in that directory containing the content of <a href="#Lis14-1">Listing 14-1</a>. We’ll embed our SVG in this HTML file. Also create two empty files in the same directory, called <i>style.css</i> and <i>script.js</i>—we’ll fill those in later when we’re ready to style the SVG and make it interactive.</p>
<span id="Lis14-1"/>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;SVG&lt;/title&gt;
    &lt;link rel="stylesheet" href="style.css"&gt;
<span aria-label=" Page 257. " epub:type="pagebreak" id="pg_257" role="doc-pagebreak"/>  &lt;/head&gt;
  &lt;body&gt;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> &lt;svg width="600" height="600"&gt;&lt;/svg&gt;

    &lt;script src="script.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: An</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file for exploring SVG</samp></p>
<p class="TX">The code in <a href="#Lis14-1">Listing 14-1</a> follows our standard HTML template, with an empty <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element added <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element is given a width and height of 600 pixels. When you load the page in your browser, it should be blank, because we haven’t added content to our SVG yet.</p>
<p class="TX">Now let’s add some graphics. We’ll add a rectangle and some text to the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element, as shown in <a href="#Lis14-2">Listing 14-2</a>.</p>
<span id="Lis14-2"/>
<pre><code><var>--snip--</var>
<span class="gray">  &lt;body&gt;</span>
    &lt;svg width="600" height="600"&gt;
    <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> &lt;rect width="95" height="20" x="5" y="5"
        stroke="red" fill="none"&gt;&lt;/rect&gt;
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> &lt;text x="10" y="20" font-family="sans-serif"&gt;Hello, SVG!&lt;/text&gt;
    &lt;/svg&gt;

<b>    </b><span class="gray">&lt;script src="script.js"&gt;&lt;/script&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: Adding graphics to the svg</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">element</samp></p>
<p class="TX">Everything inside the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;svg&gt;</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;/svg&gt;</span> tags is SVG XML, which has its own set of tag names. In this example, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> elements. The <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> element draws a rectangle, according to the specifications set through the element’s attributes. We set the width and height to 95 pixels and 20 pixels, respectively, and its x- and y-coordinates (the location of the top-left corner of the rectangle) to (5, 5). We set the outline to red using the <span class="SANS_TheSansMonoCd_W5Regular_11">stroke</span> attribute and give it no fill color (the default fill color is black). The <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> element doesn’t contain any content, so the opening tag is immediately followed by the closing tag.</p>
<p class="TX">Similarly, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> element to insert text into the drawing. The <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> element also uses <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> attributes to set its position, but in this case they refer to the start of the <i>baseline</i> of the text. In typography, the baseline is the invisible line that runs along the bottom of most letters, excluding those with descenders like <i>p</i> or <i>g</i>. By default, the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> attribute gives the horizontal position of the start of the text. We set the font of the text to the default sans-serif font using the <span class="SANS_TheSansMonoCd_W5Regular_11">font-family</span> attribute. The content of the <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> element is the actual text that will be drawn, in this case “Hello, SVG!”</p>
<p class="TX">When you reload the page, you should see this text surrounded by a red-outlined rectangle, as shown in <a href="chapter14.xhtml#fig14-1">Figure 14-1</a>.<span aria-label=" Page 258. " epub:type="pagebreak" id="pg_258" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" class="img6" id="fig14-1" src="../images/Figure_14-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: Our first SVG drawing</samp></p></figcaption>
</figure>
<p class="TX">Try zooming in on the page (using <small>CTRL</small>-+ on Windows or Linux, or <small>COMMAND</small>-+ on macOS). The rectangle and text should remain sharp, even as you scale the image.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-81"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grouping Elements</samp></h4>
<p class="TNI1">You can group multiple SVG elements together by nesting them inside a <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> (for <i>group</i>) element. This is useful because any attributes set on the <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> element itself will apply to all its child elements. To demonstrate, update the contents of your <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element as shown in <a href="#Lis14-3">Listing 14-3</a>.</p>
<span id="Lis14-3"/>
<pre><code><var>--snip--</var>
<span class="gray">&lt;svg width="600" height="600"&gt;</span>
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> &lt;g font-family="sans-serif" fill="blue"&gt;
    &lt;text x="0" y="20"&gt;Always&lt;/text&gt;
    &lt;text x="0" y="40"&gt;Be&lt;/text&gt;
    &lt;text x="0" y="60"&gt;Coding&lt;/text&gt;
  &lt;/g&gt;
<span class="gray">&lt;/svg&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-3: Grouping elements with the g element</samp></p>
<p class="TX">In this example, we create a group with three child <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> elements, each containing a single word. The <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> elements have the same x-coordinate but different y-coordinates, so the words will be vertically stacked and left-aligned. The attributes of the parent <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> element (<span class="SANS_TheSansMonoCd_W5Regular_11">font-family</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">fill</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>) apply to all the child elements in the group. Reload the page and you should see that all three words are blue and in a sans-serif font.</p>
<p class="TX">Creating groupings with <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> elements also lets you apply <i>transformations</i> to all the child elements in a group. SVG supports several kinds of transformations, including translation, rotation, scaling, and skewing. We’ll use <span class="SANS_TheSansMonoCd_W5Regular_11">translate</span> to move all the elements by a fixed amount. Update <i>index.html</i> with the following change to the opening <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> element tag:</p>

<pre><code><var>--snip--</var>
<span class="gray">  &lt;g</span> transform="translate(100, 50)" <span class="gray">font-family="sans-serif" fill="blue"&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="TX"><span aria-label=" Page 259. " epub:type="pagebreak" id="pg_259" role="doc-pagebreak"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">transform</span> attribute takes a list of transformations, separated by spaces. Here we’re passing a single transformation: <span class="SANS_TheSansMonoCd_W5Regular_11">translate(100, 50)</span>. This says to move all the elements in the group 100 pixels along the x-axis and 50 pixels down the y-axis.</p>
<p class="TX">We can also resize the group by adding a <span class="SANS_TheSansMonoCd_W5Regular_11">scale</span> transformation after the <span class="SANS_TheSansMonoCd_W5Regular_11">translate</span> transformation:</p>

<pre><code><var>--snip--</var>
  <span class="gray">&lt;g transform="translate(100, 50)</span> scale(2, 3) <span class="gray">"font-family="sans-serif" fill="blue"&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="BodyContinued">After the translation, the elements are now scaled horizontally by a factor of 2 and vertically by a factor of 3, as shown in <a href="chapter14.xhtml#fig14-2">Figure 14-2</a>.</p>
<figure class="IMG"><img alt="" class="img5" id="fig14-2" src="../images/Figure_14-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: Transforming grouped elements</samp></p></figcaption>
</figure>
<p class="TX">All the transformations are relative to the origin (0, 0), unless an earlier translation has moved the origin. This means the scaling affects the placement of elements, as well as their size. For example, when you scale a square with a top-left corner of (10, 10) and a bottom-right corner of (30, 30) by 2, the new corners will be at (20, 20) and (60, 60). The x- and y-coordinates relative to the origin are all doubled.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<aside aria-label="box-43" class="box" id="sec3">
<h4 class="BH" id="box-43"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">14-1.</samp><samp class="SANS_Futura_Std_Book_11">  Try out some of the other transformations:</samp></p>
<ul class="ul">
<li class="BoxListBulletSub"><span class="SANS_TheSansMonoCd_W5Regular_11">rotate(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">deg</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> <samp class="SANS_Futura_Std_Book_11">rotates around the origin by</samp> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">deg</span> <samp class="SANS_Futura_Std_Book_11">degrees.</samp></li>
<li class="BoxListBulletSub"><span class="SANS_TheSansMonoCd_W5Regular_11">rotate(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">deg</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> <samp class="SANS_Futura_Std_Book_11">rotates around the point (</samp><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span><samp class="SANS_Futura_Std_Book_11">,</samp> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</span><samp class="SANS_Futura_Std_Book_11">) by</samp> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">deg</span> <samp class="SANS_Futura_Std_Book_11">degrees.</samp></li>
<li class="BoxListBulletSub"><span class="SANS_TheSansMonoCd_W5Regular_11">skewX(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">deg</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> <samp class="SANS_Futura_Std_Book_11">skews by</samp> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">deg</span> <samp class="SANS_Futura_Std_Book_11">degrees along the x-axis.</samp></li>
<li class="BoxListBulletSub"><span class="SANS_TheSansMonoCd_W5Regular_11">skewY(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">deg</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> <samp class="SANS_Futura_Std_Book_11">skews by</samp> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">deg</span> <samp class="SANS_Futura_Std_Book_11">degrees along the y-axis.</samp></li>
</ul>
</aside>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-82"/><span aria-label=" Page 260. " epub:type="pagebreak" id="pg_260" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing Circles</samp></h4>
<p class="TNI1">You can draw an SVG circle using the <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> element. The attributes <span class="SANS_TheSansMonoCd_W5Regular_11">cx</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">cy</span> set the coordinates for the center of the circle, and <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> sets the radius. To try it out, replace the content of the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element with the code in <a href="#Lis14-4">Listing 14-4</a>.</p>
<span id="Lis14-4"/>
<pre><code><var>--snip--</var>
<span class="gray">&lt;svg width="600" height="600"&gt;</span>
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> &lt;circle fill="#faa0a0" r="100" cx="124" cy="130"&gt;&lt;/circle&gt;

<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> &lt;g stroke="#944e30" stroke-width="3"&gt;
    &lt;rect width="8" height="100" x="120" y="90" fill="#e1704d"&gt;&lt;/rect&gt;
    &lt;circle fill="#acd270" r="18" cx="124" cy="150"&gt;&lt;/circle&gt;
    &lt;circle fill="#fdfce2" r="18" cx="124" cy="120"&gt;&lt;/circle&gt;
    &lt;circle fill="#f8c9dc" r="18" cx="124" cy="90"&gt;&lt;/circle&gt;
  &lt;/g&gt;
<span class="gray">&lt;/svg&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-4: Drawing circles</samp></p>
<p class="TX">In this example we’re using the new <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> element, as well as the <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> elements. The first circle <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> has a fill color of <span class="SANS_TheSansMonoCd_W5Regular_11">#faa0a0</span>, or salmon pink, a radius of 100 pixels, and center coordinates (124, 130). Note that we’re using <i>hex colors</i> here—see the “Hex Colors” box on the following page to learn more. Next, we use a group <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> to apply a standard stroke color (chestnut brown) and width (3 pixels) to a rectangle and three smaller circles, with fill colors green, yellow, and rose. The effect of all this is a cute illustration of some Japanese <i>hanami dango</i> (a sweet treat popular in Japan during cherry blossom season), as shown in <a href="chapter14.xhtml#fig14-3">Figure 14-3</a>.</p>
<figure class="IMG"><img alt="" class="img5" id="fig14-3" src="../images/Figure_14-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: An illustration of hanami dango using SVG circles</samp></p></figcaption>
</figure>
<p class="TX">Notice that the order in which elements are declared defines the order in which they’re drawn. The three small circles are declared from bottom to top, so in places where they overlap, the upper circle appears on top. <span aria-label=" Page 261. " epub:type="pagebreak" id="pg_261" role="doc-pagebreak"/>Likewise, since the large circle is declared first, it’s treated as a background for the rest of the illustration.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<aside aria-label="box-44" class="box" id="sec5">
<h4 class="BH" id="box-44"><samp class="SANS_Dogma_OT_Bold_B_11">HEX COLORS</samp></h4>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Hexadecimal color syntax, or</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">hex colors</samp> <samp class="SANS_Futura_Std_Book_11">for short, is a way of specifying RGB color values in CSS and other web graphics technologies like SVG and the Canvas API. Hex colors are written using the base-16 hexadecimal number system, in which digits range from</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <samp class="SANS_Futura_Std_Book_11">to</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">f</span> <samp class="SANS_Futura_Std_Book_11">(</samp><span class="SANS_TheSansMonoCd_W5Regular_11">a</span> <samp class="SANS_Futura_Std_Book_11">through</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">f</span> <samp class="SANS_Futura_Std_Book_11">correspond to the decimal numbers 10 to 15). In decimal numbers, the rightmost digit represents units, the second-rightmost digit represents 10s, the third represents 100s, and so on. In hexadecimal numbers, the rightmost digit represents units, the second represents 16s, the third 256s, and so on. One hex digit can convey 16 different values, and two hex digits can convey 256 different values. Hexadecimal is often used in programming because 1 byte can contain 256 different values, so using the hex digits</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">00</span> <samp class="SANS_Futura_Std_Book_11">through</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">ff</span> <samp class="SANS_Futura_Std_Book_11">gives us a convenient way to encode bytes in text.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Hex colors generally use three pairs of hex digits to represent an RGB color, preceded by a hash mark. For example, in the hex color</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">#944e30</span><samp class="SANS_Futura_Std_Book_11">, red has a value of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">94</span><samp class="SANS_Futura_Std_Book_11">, green has a value of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">4e</span><samp class="SANS_Futura_Std_Book_11">, and blue has a value of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">30</span><samp class="SANS_Futura_Std_Book_11">. These three values correspond to the decimal values 148, 78, and 48, which together form a chestnut brown color. (To demonstrate how the conversion works,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">94</span> <samp class="SANS_Futura_Std_Book_11">in hexadecimal is nine 16s and four units, so 9 × 16 + 4 = 148 in decimal.) If both digits of each color component are the same, you can also use a shorthand three-digit form, combining the duplicate digits into one. For example,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">#000000</span> <samp class="SANS_Futura_Std_Book_11">(black) can also be written as</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">#000</span><samp class="SANS_Futura_Std_Book_11">.</samp></p>
</aside>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="H2" id="sec6"><span id="h2-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Paths</samp></h4>
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">path</span> element is the most powerful SVG element of all, allowing you to create custom shapes by drawing straight or curved lines (“paths”) between different points. The <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> attribute of a <span class="SANS_TheSansMonoCd_W5Regular_11">path</span> element (short for <i>data</i>) is a string containing the path definition, which is a list of path commands. The syntax of this string is optimized to be as compact as possible, so complex paths can be represented using relatively short strings. This is good for computers, but not good for humans; don’t expect these strings to be easily readable.</p>
<p class="TX">In the next example we’re going to re-create the HTML5 logo with <span class="SANS_TheSansMonoCd_W5Regular_11">path</span> elements, starting with the outer shield shape. Replace the content of the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element in <i>index.html</i> with the code in <a href="#Lis14-5">Listing 14-5</a>.</p>
<span id="Lis14-5"/>
<pre><code><var>--snip--</var>
<span class="gray">&lt;svg width=</span><span class="gray">"600" height="600"&gt;</span>
  &lt;path fill="#e44d26" d="M 0 0 H 182 L 165 185 L 90 206 L 17 185 Z"/&gt;
  &lt;path fill="#f16529" d="M 91 15 H 165 L 151 173 L 91 190 Z"/&gt;
<span class="gray">&lt;/svg&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-5: Drawing the HTML5 logo shield</samp></p>
<p class="TX"><span aria-label=" Page 262. " epub:type="pagebreak" id="pg_262" role="doc-pagebreak"/>Before we dive deep into the path definition, it’ll help to know what the result is supposed to look like. Reload the page, and you should see the shield design shown in <a href="chapter14.xhtml#fig14-4">Figure 14-4</a>.</p>
<figure class="IMG"><img alt="" class="img4" id="fig14-4" src="../images/Figure_14-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: The HTML5 logo shield</samp></p></figcaption>
</figure>
<p class="TX">This design is made of two paths, one for the darker main shield shape, and one for the lighter highlight on the right half of the shield shape. Let’s look at the path definition for the darker part:</p>

<pre><code>M 0 0 H 182 L 165 185 L 90 206 L 17 185 Z</code></pre>
<p class="TX">There are six instructions here:</p>
<ul class="ul">
<li class="BL"><span class="SANS_TheSansMonoCd_W5Regular_11">M 0 0</span></li>
<li class="BL"><span class="SANS_TheSansMonoCd_W5Regular_11">H 182</span></li>
<li class="BL"><span class="SANS_TheSansMonoCd_W5Regular_11">L 165 185</span></li>
<li class="BL"><span class="SANS_TheSansMonoCd_W5Regular_11">L 90 206</span></li>
<li class="BL"><span class="SANS_TheSansMonoCd_W5Regular_11">L 17 185</span></li>
<li class="BL"><span class="SANS_TheSansMonoCd_W5Regular_11">Z</span></li>
</ul>
<p class="TX">Think of these commands as moving an imaginary pen around the screen to draw lines. The <span class="SANS_TheSansMonoCd_W5Regular_11">M</span> command takes a position as an (x, y) coordinate pair and moves the pen to that position without drawing anything. The <span class="SANS_TheSansMonoCd_W5Regular_11">H</span> command takes an x-coordinate and draws a horizontal line from the current pen position to that value of x. The <span class="SANS_TheSansMonoCd_W5Regular_11">L</span> command takes an (x, y) coordinate pair and draws a line from the current position to that position. Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">Z</span> command closes the path, drawing a line from the current position back to the start of the path. In English, the commands in the path say, “Move to (0, 0), draw a horizontal line to (182, 0), draw a line to (165, 185), draw a line to (90, 206), draw a line to (17, 185), then draw a line back to (0, 0) to close the path.” The second path uses the same technique to draw the inner highlight on the shield, using a different fill color.</p>
<p class="TX">These commands define the points to move to using <i>absolute positions</i>, exact x- and y-coordinates. However, there’s an alternative version of each command that takes a relative position instead, meaning the next point is <span aria-label=" Page 263. " epub:type="pagebreak" id="pg_263" role="doc-pagebreak"/>defined in relation to the current position of the pen. The absolute commands all use uppercase letters, and the relative ones use the same letters but lowercase. For example, the path definition we just looked at could be rewritten using relative path commands like this:</p>

<pre><code>m 0 0 h 182 l -17 185 l -75 21 l -73 -21 z</code></pre>
<p class="TX">In this case, the move command is the same because there’s no previous position to be relative to. The command <span class="SANS_TheSansMonoCd_W5Regular_11">h 182</span> says to draw a horizontal line 182 units to the right of the current position. The command <span class="SANS_TheSansMonoCd_W5Regular_11">l -17 185</span> says to draw a line 17 units to the left and 185 down from the current position, and so on. The <span class="SANS_TheSansMonoCd_W5Regular_11">Z</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> commands do the same thing and are just included in the SVG spec for completeness.</p>
<p class="TX">In fact, this relative path definition can be written even more compactly:</p>

<pre><code>m0 0h182l-17 185-75 21-73-21z</code></pre>
<p class="BodyContinued">Spaces are needed only to avoid ambiguity between two numbers, but are otherwise optional in SVG paths. Thanks to all the negative numbers, we’re able to remove almost all the spaces here. Also, if the same command is used multiple times in a row, you can include it once and then just keep providing numbers. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">l-17 185-75 21-73-21</span> is the compact version of <span class="SANS_TheSansMonoCd_W5Regular_11">l -17 185 l -75 21 l -73 -21</span>.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>The SvgPathEditor (</i><a href="https://yqnn.github.io/svg-path-editor/"><span class="note_LinkURL_Italic">https://yqnn.github.io/svg-path-editor/</span></a><i>)</i> <i>is a very helpful tool for experimenting with and manipulating paths, and for converting between absolute and relative commands (it’s what I used here to convert between the two forms). SVG has several additional path commands, mostly for drawing various types of curves. We won’t go into those here, but you can find a full list on MDN at</i> <a href="https://developer.mozilla.org/SVG"><span class="note_LinkURL_Italic">https://developer.mozilla.org/SVG</span></a>.</p>
<p class="TX">Now that you understand how path definitions work, we can add more paths to fill in the rest of the HTML5 logo. Update the content of the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element as shown in <a href="#Lis14-6">Listing 14-6</a> (though I won’t think any less of you if you decide this is too much typing!).</p>
<span id="Lis14-6"/>
<pre><code><var>--snip--</var>
<span class="gray">&lt;</span><span class="gray">svg width="600" height="600"&gt;</span>
<span class="gray">  &lt;path fill="#e44d26" d="M 0 0 H 182 L 165 185 L 90 206 L 17 185 Z"/&gt;</span>
<span class="gray">  &lt;path fill=</span><span class="gray">"#f16529" d="M 91 15 H 165 L 151 173 L 91 190 Z"/&gt;</span>
  &lt;path fill="#ebebeb" d="m 34 38 h 57 v 23 h -32 l 2 24 h 30 v 23 h -51 z"/&gt;
  &lt;path fill="#ebebeb" d="m 41 118 h 23 l 2 18 l 25 7 v 24 l -47 -13 z"/&gt;
  &lt;path fill="#fff" d="m 148 38 h -57 v 23 h 55 z"/&gt;
  &lt;path fill="#fff" d="m 143 85 h -52 v 23 h 28 l -3 30 l -25 5 v 24 l 47 -13 z"/&gt;
<span class="gray">&lt;/svg&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-6: Completing the HTML5 logo</samp></p>
<p class="TX"><span aria-label=" Page 264. " epub:type="pagebreak" id="pg_264" role="doc-pagebreak"/>I used relative path commands here partly for variety, and partly because the relative numbers were smaller and made for shorter lines. When you reload the page, you should see the complete HTML5 logo, as shown in <a href="chapter14.xhtml#fig14-5">Figure 14-5</a>. The two paths with the fill color <span class="SANS_TheSansMonoCd_W5Regular_11">#ebebeb</span> (light gray) draw the two parts of the left side of the 5, and the two paths with the fill color <span class="SANS_TheSansMonoCd_W5Regular_11">#fff</span> (white) draw the two parts of the right side of the 5.</p>
<figure class="IMG"><img alt="" class="img4" id="fig14-5" src="../images/Figure_14-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: The complete HTML5 logo</samp></p></figcaption>
</figure>
<p class="TX">In general, you won’t have to manually type out your own path definitions when you’re creating data visualizations. D3 will create them for you. Still, it’s helpful to understand the syntax so you can tell what’s going on when you’re debugging.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="h2-84"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Styling Elements with CSS</samp></h4>
<p class="TNI1">When you embed SVG in your HTML file, each SVG element becomes part of the DOM, so it can be styled with CSS. To see how this works, we’ll draw some SVG shapes and give them all class names. Replace the content of the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element with the code in <a href="#Lis14-7">Listing 14-7</a>.</p>
<span id="Lis14-7"/>
<pre><code><var>--snip--</var>
<span class="gray">&lt;svg width="600" height="600"&gt;</span>
  &lt;circle class="boring" r="40" cx="50" cy="50"&gt;&lt;/circle&gt;
  &lt;rect class="boring" x="120" y="10" width="80" height="80"&gt;&lt;/rect&gt;
  &lt;path class="boring" d="M 230 90 l 40 -80 l 40 80 z"&gt;&lt;/path&gt;"

  &lt;circle class="fun" r="40" cx="50" cy="180"&gt;&lt;/circle&gt;
  &lt;rect class="fun" x="120" y="140" width="80" height="80"&gt;&lt;/rect&gt;
  &lt;path class="fun" d="M 230 220 l 40 -80 l 40 80 z"&gt;&lt;/path&gt;"
<span class="gray">&lt;/svg&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-7: Some SVG elements with class names</samp></p>
<p class="TX">Here we’re drawing a circle, a square, and a triangle, and then another circle, square, and triangle. Notice that the triangles are drawn as paths—there’s no dedicated <span class="SANS_TheSansMonoCd_W5Regular_11">triangle</span> element like <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span>. The first three shapes have the class name <span class="SANS_TheSansMonoCd_W5Regular_11">boring</span>, and the second three have the class <span aria-label=" Page 265. " epub:type="pagebreak" id="pg_265" role="doc-pagebreak"/>name <span class="SANS_TheSansMonoCd_W5Regular_11">fun</span>. When you reload the page you should see two rows of three shapes, all with the same default black fill, as shown in <a href="chapter14.xhtml#fig14-6">Figure 14-6</a>.</p>
<figure class="IMG"><img alt="" class="img5" id="fig14-6" src="../images/Figure_14-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: SVG shapes, without style</samp></p></figcaption>
</figure>
<p class="TX">Now we’ll style the shapes. Because they all have class names, we can select them in CSS, just like we’d select HTML elements. Add the code in <a href="#Lis14-8">Listing 14-8</a> to your <i>style.css</i> file.</p>
<span id="Lis14-8"/>
<pre><code>.boring {
  fill: none;
  stroke: black;
  stroke-width: 3px;
}

.fun {
  fill: hotpink;
  stroke: greenyellow;
  stroke-width: 5px;
  stroke-dasharray: 10,5;
  stroke-linejoin: round;
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-8: Styles for the shapes</samp></p>
<p class="TX">In this listing, we’re giving different styles to the two classes: <span class="SANS_TheSansMonoCd_W5Regular_11">.boring</span> gets a simple black outline, and <span class="SANS_TheSansMonoCd_W5Regular_11">.fun</span> gets a pink fill and a thick dashed green-yellow outline. Note that the property names for styling SVG elements aren’t the same as for HTML elements. For example, HTML elements use <span class="SANS_TheSansMonoCd_W5Regular_11">background-color</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">border-color</span>, while SVG elements use <span class="SANS_TheSansMonoCd_W5Regular_11">fill</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">stroke</span>.</p>
<p class="TX">It’s worth noting that you could also apply these styles directly to the SVG elements as attributes in the <i>index.html</i> file. The advantage of using CSS is twofold: first, it means that all your styling information is in one place, so it’s easily updatable, and second, to style several elements the same way you only need to add a class name to each element, as opposed to copying all the attributes from one element to another.</p>
<p class="TX">When you reload the page, you should notice that your shapes now have some style, as shown in <a href="chapter14.xhtml#fig14-7">Figure 14-7</a>.<span aria-label=" Page 266. " epub:type="pagebreak" id="pg_266" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" class="img5" id="fig14-7" src="../images/Figure_14-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: SVG shapes, with style</samp></p></figcaption>
</figure>
<p class="TX">It’s also possible to use pseudo-classes like <span class="SANS_TheSansMonoCd_W5Regular_11">:hover</span> on SVG elements. Add the code in <a href="#Lis14-9">Listing 14-9</a> to the end of <i>style.css</i> to try this out.</p>
<span id="Lis14-9"/>
<pre><code><var>--snip--</var>
.fun:hover {
  fill: greenyellow;
  stroke: hotpink;
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-9: Adding a hover effect</samp></p>
<p class="TX">Here we’re swapping the fill and stroke color when the mouse hovers over one of the <span class="SANS_TheSansMonoCd_W5Regular_11">.fun</span> elements. Reload the page and see for yourself!</p>
<p class="TX">This is one of the great advantages of SVG over the Canvas API: the browser knows about the SVG elements, and it knows, for example, when the mouse is hovering over them. Compare this with the canvas, where the browser just knows that some colored pixels have been drawn, and any mouse hover effects have to be explicitly coded in JavaScript.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-85"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Interactivity with JavaScript</samp></h4>
<p class="TNI1">We can use JavaScript to add interactivity to our SVG elements, just as we can use CSS to style them. Again, this is possible because each SVG element embedded in the HTML becomes part of the DOM. To start with, we’ll just write a script that selects the elements and logs them to the console, as a refresher on JavaScript DOM methods. Add the code in <a href="#Lis14-10">Listing 14-10</a> to the currently empty <i>script.js</i>.</p>
<span id="Lis14-10"/>
<pre><code>document.querySelectorAll(".fun").forEach(element =&gt; {
  console.log(element);
});
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-10: Selecting the .fun elements</samp></p>
<p class="TX">In this listing, we’re using the <span class="SANS_TheSansMonoCd_W5Regular_11">querySelectorAll</span> method to select all the elements with the class name <span class="SANS_TheSansMonoCd_W5Regular_11">fun</span>. We then use the <span class="SANS_TheSansMonoCd_W5Regular_11">forEach</span> method to iterate <span aria-label=" Page 267. " epub:type="pagebreak" id="pg_267" role="doc-pagebreak"/>over the selected elements and log them to the console. When you run this code, you should see the three elements logged to the console on separate lines. If you hover over each element in the console, that element should also be highlighted on the web page.</p>
<p class="TX">Now we can add some interactivity. The changes to <i>script.js</i> in <a href="#Lis14-11">Listing 14-11</a> will make it so when you click one of the elements, that element will move to the right, and when you hold down <small>SHIFT</small> and click, the element will move to the left.</p>
<span id="Lis14-11"/>
<pre><code><span class="gray">document.querySelectorAll(".fun").forEach(element =&gt; {</span>
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> element.setAttribute("data-offset", 0);

<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> element.addEventListener("click", event =&gt; {
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> let offset = Number(event.target.getAttribute("data-offset"));

    if (event.shiftKey) {
      offset -=5;
    } else {
      offset +=5;
    }

  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> event.target.setAttribute("data-offset", offset);
  <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> event.target.setAttribute("transform", `translate(${offset}, 0)`);
  });
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-11: Moving SVG elements on click</samp></p>
<p class="TX">Inside the <span class="SANS_TheSansMonoCd_W5Regular_11">forEach</span> method call, we’re doing two things to each element. First, we set something called a <i>data attribute</i> on each element. Data attributes are HTML or SVG attributes that are just used for storing data in the DOM; their names all start with the string <span class="SANS_TheSansMonoCd_W5Regular_11">"data-"</span>. Specifically, we create the <span class="SANS_TheSansMonoCd_W5Regular_11">data-offset</span> data attribute, which we’ll use to keep track of how to position each element, and set its value to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Note that DOM attributes are always stored as strings, so the number <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> will be converted to the string <span class="SANS_TheSansMonoCd_W5Regular_11">"0"</span>.</p>
<p class="TX">Next, we attach a <span class="SANS_TheSansMonoCd_W5Regular_11">click</span> event handler to each element <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The first thing the handler does is extract the <span class="SANS_TheSansMonoCd_W5Regular_11">data-offset</span> attribute from the clicked element, using <span class="SANS_TheSansMonoCd_W5Regular_11">getAttribute</span>, and store its value in the variable <span class="SANS_TheSansMonoCd_W5Regular_11">offset</span> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The clicked element is available as the <span class="SANS_TheSansMonoCd_W5Regular_11">target</span> property on the <span class="SANS_TheSansMonoCd_W5Regular_11">event</span> object. Note that we use the <span class="SANS_TheSansMonoCd_W5Regular_11">Number</span> function here to convert the string into a number. The first time this handler is called, the variable <span class="SANS_TheSansMonoCd_W5Regular_11">offset</span> will be set to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, as that is the initial value we stored in the <span class="SANS_TheSansMonoCd_W5Regular_11">data-offset</span> attribute <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>.</p>
<p class="TX">We use the <span class="SANS_TheSansMonoCd_W5Regular_11">shiftKey</span> property on the event to determine if the <small>SHIFT</small> key was pressed when the mouse was clicked. If it was, we subtract 5 from <span class="SANS_TheSansMonoCd_W5Regular_11">offset</span>. Otherwise, we add 5 to <span class="SANS_TheSansMonoCd_W5Regular_11">offset</span>. We then assign the updated value to the <span class="SANS_TheSansMonoCd_W5Regular_11">data-offset</span> attribute using <span class="SANS_TheSansMonoCd_W5Regular_11">setAttribute</span> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Finally, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">setAttribute</span> method again, but this time to set the <span class="SANS_TheSansMonoCd_W5Regular_11">transform</span> SVG attribute <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. As you saw earlier in this chapter, we can use <span class="SANS_TheSansMonoCd_W5Regular_11">transform</span> to translate an element by some distance, with the string <span class="SANS_TheSansMonoCd_W5Regular_11">translate(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</span><span class="SANS_TheSansMonoCd_W5Regular_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">y</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span>. Here we’re setting the x value <span aria-label=" Page 268. " epub:type="pagebreak" id="pg_268" role="doc-pagebreak"/>of the translation to the value of <span class="SANS_TheSansMonoCd_W5Regular_11">offset</span> and the y value of the translation to 0. This means that if <span class="SANS_TheSansMonoCd_W5Regular_11">offset</span> is a positive value the element will move to the right, and if it’s a negative value the element will move to the left.</p>
<p class="TX">When you reload the page, the colorful SVG elements should now move when you click them. If you right-click one of the elements and select Inspect, you’ll see that element in the Elements panel. As you click different elements in the browser viewport, you should see the <span class="SANS_TheSansMonoCd_W5Regular_11">data-offset</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">transform</span> attributes update in the Elements panel.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="H1" id="sec9"><span id="h1-86"/><samp class="SANS_Futura_Std_Bold_B_11">The D3 Library</samp></h3>
<p class="TNI1">Now that you have an understanding of the basics of SVG, you can start to learn about the D3 library, which leverages SVG and JavaScript to create data visualizations. <i>D3</i>, short for <i>Data-Driven Documents</i>, gives you the ability to create documents whose contents are driven by data. It does this through a technique called <i>data binding</i>, where individual parts of the underlying data you want to visualize are linked to individual elements on the page. This way, if the data changes, the elements change as well. You’ll see how that works later in this section.</p>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-86"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setup</samp></h4>
<p class="TNI1">We’ll create a new set of files to explore D3. Make a new directory called <i>data</i>, containing an empty <i>script.js</i> file and an <i>index.html</i> file with the content in <a href="#Lis14-12">Listing 14-12</a>.</p>
<span id="Lis14-12"/>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Data&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> &lt;svg width="600" height="600"&gt;
      &lt;circle cx="50" cy="50" r="10"&gt;&lt;/circle&gt;
      &lt;circle cx="100" cy="50" r="10"&gt;&lt;/circle&gt;
      &lt;circle cx="150" cy="50" r="10"&gt;&lt;/circle&gt;
    &lt;/svg&gt;

  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> &lt;script src="https://unpkg.com/d3@7.4.4/dist/d3.js"&gt;&lt;/script&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-12: A new</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for working with D3</samp></p>
<p class="TX">First we create an <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and draw three circles. Then we use a <span class="SANS_TheSansMonoCd_W5Regular_11">script</span> element to link to a copy of the D3 library hosted on <a href="https://unpkg.com"><i>https://<wbr/>unpkg<wbr/>.com</i></a> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, much like we did with Tone.js for the music project. Now you’ll be able to use code from D3 in your <i>script.js</i> file. When you load the page, you should see three black circles. Soon we’ll manipulate those circles with D3.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-87"/><span aria-label=" Page 269. " epub:type="pagebreak" id="pg_269" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selections</samp></h4>
<p class="TNI1">One of D3’s basic building blocks is the <i>selection</i>, a way to pick out a group of elements so you can apply certain operations to those elements. Let’s use D3 to select the three SVG circles and change their fill color to hot pink. Add the code in <a href="#Lis14-13">Listing 14-13</a> to <i>script.js</i>.</p>
<span id="Lis14-13"/>
<pre><code>d3.selectAll("circle").attr("fill", "hotpink");</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-13: Selecting the circles</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">d3.selectAll</span> method takes a CSS selector, in this case the element name <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span>, and returns a D3 selection, on which you can chain more method calls. Those chained method calls will apply to all the elements matching the selector. Here we’re setting the <span class="SANS_TheSansMonoCd_W5Regular_11">"fill"</span> attribute of every element in the selection to <span class="SANS_TheSansMonoCd_W5Regular_11">"hotpink"</span>. When you reload the page, you should see that the black circles are now pink.</p>
<p class="TX">It’s also possible to use a function instead of a value when updating elements in a selection. When you do this, the function is called and its return value is used as the value for updating these elements. This gives you the ability to modify elements dynamically. Update the <i>script.js</i> code with the changes in <a href="#Lis14-14">Listing 14-14</a> to see how it works.</p>
<span id="Lis14-14"/>
<pre><code>d3
  .selectAll("circle")
  .attr("fill", "hotpink")
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> .attr("r", (d, i) =&gt; 10 + i * 5);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-14: Computing values with functions</samp></p>
<p class="TX">With long method chains like this, it’s common to split the code across multiple lines for readability. As before, we’re selecting all the circles and setting their fill color to hot pink, but this time we’re also updating each circle’s radius <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The function used for generating the value here has two parameters, <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>. We’ll cover the <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> parameter, short for <i>datum</i>, in the next section. <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>, short for <i>index</i>, is the index of the element in the selection (the first circle will have an index of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, the second <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, and so on). We’re using the code <span class="SANS_TheSansMonoCd_W5Regular_11">10 + i * 5</span> to give each circle a different radius, based on their index numbers. Specifically, the circles will have radii of 10, 15, and 20. When you reload the page, you should see the three circles are now all different sizes.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>D3 selection modification methods like <span class="SANS_TheSansMonoCd_W5Regular_11">.attr</span> return the selection itself. This lets us keep chaining modification methods, as we do with the two <span class="SANS_TheSansMonoCd_W5Regular_11">.attr</span> calls in <a href="#Lis14-14">Listing 14-14</a>.</i></p>
<p class="TX">If you want to select a single element rather than a group, use the <span class="SANS_TheSansMonoCd_W5Regular_11">d3.select</span> method instead of <span class="SANS_TheSansMonoCd_W5Regular_11">d3.selectAll</span>. For example, to insert an <span class="SANS_TheSansMonoCd_W5Regular_11">h1</span> element into the <span class="SANS_TheSansMonoCd_W5Regular_11">body</span> element of your HTML, you could add the code in <a href="#Lis14-15">Listing 14-15</a> to the end of your <i>script.js</i> file.</p>
<span id="Lis14-15"/>
<pre><code><span aria-label=" Page 270. " epub:type="pagebreak" id="pg_270" role="doc-pagebreak"/><var>--snip--</var>
d3
  .select("body")
  .insert("h1", "svg")
  .text("Hello, D3!");
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-15: Using select to select a single element</samp></p>
<p class="TX">In this example, we first select the <span class="SANS_TheSansMonoCd_W5Regular_11">body</span> element. We then call <span class="SANS_TheSansMonoCd_W5Regular_11">insert</span> on this selection, passing two arguments, <span class="SANS_TheSansMonoCd_W5Regular_11">"h1"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"svg"</span>. The first argument is the type of element to insert, and the second is the element before which to insert it. The <span class="SANS_TheSansMonoCd_W5Regular_11">insert</span> method returns a new selection containing the inserted element, and the <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> method adds text content to elements in that selection (in this case, the single <span class="SANS_TheSansMonoCd_W5Regular_11">h1</span> element). When you reload the page, you should see a heading above the SVG element with the text “Hello, D3!” This example also illustrates the fact that D3 selections can apply to both HTML and SVG elements.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="h2-88"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Binding</samp></h4>
<p class="TNI1">Perhaps the most important feature of D3 is its concept of data binding. In a D3-based application, you’ll have some data that you’re attempting to visualize. Each individual piece of the data, called a <span class="text">datum</span>, will be bound to an individual element on the page (usually an SVG element). You use the datum to set some attribute of the element it’s bound to, so the element visually reflects the datum.</p>
<p class="TX">To start with, we’ll look at how to bind data to preexisting SVG elements. Keep the circles in <i>index.html</i>, but replace the content of <i>script.js</i> with the code in <a href="#Lis14-16">Listing 14-16</a>.</p>
<span id="Lis14-16"/>
<pre><code>let numbers = [3, 2, 1];

d3
  .selectAll("circle")
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> .data(numbers)
  .attr("r", (d, i) =&gt; d * 5);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-16: Binding data to our circles</samp></p>
<p class="TX">We first create an array of numbers to use as data. Then we create a selection of all the <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> elements. The <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> method <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> binds the array of numbers to the selection of circles, one by one, so the first <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> element has the value <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> bound to it, the second <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, and the third <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>. Finally, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">attr</span> method to set the radius of each circle to a computed value based on the bound data. As you saw in the previous section, if you use a function instead of a value to set an attribute, that function will be called to compute the value for each element in the selection. The <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> parameter of the function corresponds to the datum bound to the current element.</p>
<p class="TX">When you reload the page, you should see three black circles that get smaller from left to right. To confirm that everything is working as expected, right-click the first circle and select <b>Inspect</b> to show the element <span aria-label=" Page 271. " epub:type="pagebreak" id="pg_271" role="doc-pagebreak"/>in the Elements panel. You should see its <span class="SANS_TheSansMonoCd_W5Regular_11">r</span> attribute set to 15, which is what we’d expect from <span class="SANS_TheSansMonoCd_W5Regular_11">d * 5</span> where <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>.</p>
<p class="TX">It’s also possible to directly see the datum set on an element using the Inspect tool, which can be very helpful for debugging, especially when your data is more complex than simple numbers. All you need is a reference to the element, which is easy to get through the Chrome console. Again, right-click the first circle and select <b>Inspect</b>. You should see something like <a href="chapter14.xhtml#fig14-8">Figure 14-8</a>.</p>
<figure class="IMG"><img alt="" class="img8" id="fig14-8" src="../images/Figure_14-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: Selecting a circle element in the Elements panel</samp></p></figcaption>
</figure>
<p class="TX">At the end of the selected line you should see the text <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">== $0</span>. This is an indication that a reference to the <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> element is stored under the global variable named <span class="SANS_TheSansMonoCd_W5Regular_11">$0</span>. To verify that this is the case, open the JavaScript console and enter <span class="SANS_TheSansMonoCd_W7Bold_B_11">$0</span>:</p>

<pre><code><b>$0</b>
&lt;circle cx="50" cy="50" r="15"&gt;&lt;/circle&gt;
</code></pre>
<p class="TX">The console prints the <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> element you selected, indicating that <span class="SANS_TheSansMonoCd_W5Regular_11">$0</span> is indeed a reference to that element. Now that you have that reference, you can see the datum bound to it using the <span class="SANS_TheSansMonoCd_W5Regular_11">__data__</span> property:</p>

<pre><code><b>$0.__data__</b>
3
</code></pre>
<p class="TX">This tells you the circle is bound to the value <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>, the first number from our array, just as we’d expect. <span class="SANS_TheSansMonoCd_W5Regular_11">$0</span> always references the currently selected element, so if you right-click and inspect a different circle, entering <span class="SANS_TheSansMonoCd_W5Regular_11">$0.__data__</span> in the console again will give you the datum bound to that other circle.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H2" id="sec13"><span id="h2-89"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Data Joins</samp></h4>
<p class="TNI1">You don’t always know exactly how long your data is going to be, so it would be difficult to always have exactly the right number of SVG elements ready to bind to your data. D3 solves this problem with the concept of <i>joins</i>. In D3, you use a join to add or remove the necessary elements to match the data being bound.</p>
<p class="TX">We can extend our example from <a href="#Lis14-16">Listing 14-16</a> with a join so that SVG <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> elements will be added or removed as needed, depending on the length of the <span class="SANS_TheSansMonoCd_W5Regular_11">numbers</span> array. Update the <i>script.js</i> file as shown in <a href="#Lis14-17">Listing 14-17</a>.</p>
<span id="Lis14-17"/>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> let numbers = [3, 2, 1, 2, 3];

<span class="gray">d3</span>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> .select("svg")
<span aria-label=" Page 272. " epub:type="pagebreak" id="pg_272" role="doc-pagebreak"/><span class="gray">  .selectAll("circle")</span>
<span class="gray">  .data(numbers)</span>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> .join("circle")
  <span class="gray">.attr("r", (d, i) =&gt; d * 5);</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-17: Joining in extra elements</samp></p>
<p class="TX">Here we’ve create a longer array of numbers <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We’ve also added a line to select the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> before selecting the <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> elements within it. This is necessary because D3 will need to add new <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> elements, and it needs to know which containing element to add them to. Finally, we’ve added a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This method takes the name of the element from the selection to add or remove to match the data. In this case, we’re saying that if there aren’t enough <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> elements in the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element for all the items in <span class="SANS_TheSansMonoCd_W5Regular_11">data</span>, then D3 should add more (or conversely, if there are too many, D3 should remove some).</p>
<p class="TX">If you reload the page, you’ll see this doesn’t quite work as you probably expected. The new circles all end up in the top-left corner of the drawing area. That’s because these new circles don’t have their <span class="SANS_TheSansMonoCd_W5Regular_11">cx</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">cy</span> attributes set, unlike the initial three circles that were defined in <i>index.html</i>. To fix this, we need to set these two attributes using D3, as shown in <a href="#Lis14-18">Listing 14-18</a>.</p>
<span id="Lis14-18"/>
<pre><code><span class="gray">let numbers = [3, 2, 1, 2, 3];</span>

<span class="gray">d3</span>
<span class="gray">  .select("svg")</span>
<span class="gray">  .selectAll("circle")</span>
<span class="gray">  .data(numbers)</span>
<span class="gray">  .join("circle")</span>
  .attr("cx", (d, i) =&gt; (i + 1) * 50)
  .attr("cy", 50)
<span class="gray">  .attr("r", (d, i) =&gt; d * 5);</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-18: Setting the cx and cy attributes</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cx</span> attribute is based on the index of the data. The first element should be at 50, the second at 100, and so on. The calculation <span class="SANS_TheSansMonoCd_W5Regular_11">(i + 1) * 50</span> gives us the right values. Because the circles are all in a line, the <span class="SANS_TheSansMonoCd_W5Regular_11">cy</span> attribute is just a constant value. Now when you reload the page you should see five circles in a line.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>As mentioned previously, you can use the same <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> technique to remove elements when you have too many. If you change the array of numbers to contain only two elements and reload the page, you’ll see only two circles.</i></p>
<p class="TX">Now that we’re using D3’s <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method to create new SVG elements as needed to suit the data, there’s no reason to create them in the HTML file. Modify <i>index.html</i> as shown in <a href="#Lis14-19">Listing 14-19</a>, removing all the <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> elements, then reload the page.</p>
<span id="Lis14-19"/>
<pre><code><span aria-label=" Page 273. " epub:type="pagebreak" id="pg_273" role="doc-pagebreak"/><var>--snip--</var>
<span class="gray">  &lt;body&gt;</span>
    &lt;svg width="600" height="600"&gt;&lt;/svg&gt;

<span class="gray">    &lt;script src="</span><span class="gray">https://unpkg.com/d3@7.4.4/dist/d3.js"&gt;&lt;/script&gt;</span>
<span class="gray">    &lt;script src="script.js"</span><span class="gray">&gt;&lt;/script&gt;</span>
<span class="gray">  &lt;/body&gt;</span>
<span class="gray">&lt;/html&gt;</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-19: Removing the circle elements</samp></p>
<p class="TX">Everything should still work, because the <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method adds in all the <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> elements it needs. Note that the <span class="SANS_TheSansMonoCd_W5Regular_11">.selectAll("circle")</span> line is still needed in <i>script.js</i> for the join to work correctly, even though the first time this is called there will be no circles to select.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="h2-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Real-Time Updates</samp></h4>
<p class="TNI1">If the underlying data changes, we’ll need to perform the join again to update the visualization. To do this, we’ll move all the data binding and joining code into its own function, which we can call as needed. We can test this out by adding some buttons to the page that allow us to add random values to the start or end of our <span class="SANS_TheSansMonoCd_W5Regular_11">numbers</span> array, or drop numbers from the array. Update <i>index.html</i> with the changes shown in <a href="#Lis14-20">Listing 14-20</a>.</p>
<span id="Lis14-20"/>
<pre><code><var>--snip--</var>
<span class="gray">  &lt;body&gt;</span>
    &lt;div&gt;
      &lt;button id="prepend"&gt;Prepend&lt;/button&gt;
      &lt;button id="append"&gt;Append&lt;/button&gt;
      &lt;button id="drop"&gt;Drop&lt;/button&gt;
    &lt;/div&gt;

<span class="gray">    &lt;svg width="600" height="600"&gt;&lt;/svg&gt;</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-20: Adding buttons to</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp></p>
<p class="TX">Reload the page and you should see the three new buttons at the top. Next, we’ll move the code that updates the visualization into its own function. Replace the code in <i>script.js</i> with the content of <a href="#Lis14-21">Listing 14-21</a>.</p>
<span id="Lis14-21"/>
<pre><code>let numbers = [3, 2, 1];

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> function update(data) {
  d3
    .select("svg")
    .selectAll("circle")
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> .data(data)
    .join("circle")
    .attr("cx", (d, i) =&gt; (i + 1) * 50)
    .attr("cy", 50)
<span aria-label=" Page 274. " epub:type="pagebreak" id="pg_274" role="doc-pagebreak"/>    .attr("r", (d, i) =&gt; d * 5);
}

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> update(numbers);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-21: Moving the update code into its own function</samp></p>
<p class="TX">There’s no functional change here—we’re just creating an <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function to do the SVG updating for us <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, and then calling it <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Notice that we’re passing <span class="SANS_TheSansMonoCd_W5Regular_11">data</span>, the function’s parameter, to the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> method <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, rather than passing the <span class="SANS_TheSansMonoCd_W5Regular_11">numbers</span> array directly.</p>
<p class="TX">Next we’ll add the code for handling button clicks, which will insert a random floating-point number between 1 and 5 into the <span class="SANS_TheSansMonoCd_W5Regular_11">numbers</span> array at the start or end, or drop the last element in the array. Add the code in <a href="#Lis14-22">Listing 14-22</a> to the end of <i>script.js</i>.</p>
<span id="Lis14-22"/>
<pre><code><var>--snip--</var>
<span class="gray">update(numbers);</span>

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> function getRandomNumber() {
  return 1 + Math.random() * 4;
}

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> d3.select("#append").on("click", () =&gt; {
  numbers.push(getRandomNumber());
  update(numbers);
});

<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> d3.select("#prepend").on("click", () =&gt; {
  numbers.unshift(getRandomNumber());
  update(numbers);
});

<span aria-label="annotation4" class="CodeAnnotationHang">❹</span> d3.select("#drop").on("click", () =&gt; {
  numbers.pop();
  update(numbers);
});
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-22: Updating on button clicks</samp></p>
<p class="TX">First we declare a helper function for generating a random number <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, since there are two places where we need to do this. Then we declare the handlers for the three buttons. Notice that instead of using the regular DOM API methods for adding click handlers, as we’ve done previously in this book, we’re using <span class="SANS_TheSansMonoCd_W5Regular_11">d3.select</span> to select the buttons and the <span class="SANS_TheSansMonoCd_W5Regular_11">on</span> method to add an event handler. The regular DOM API methods would work as well, but using D3 methods is more concise and more consistent with the other D3 code in this file.</p>
<p class="TX">The first handler is triggered by a click on the Append button <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>: it pushes a random number onto the end of the <span class="SANS_TheSansMonoCd_W5Regular_11">numbers</span> array, then we call the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function to redraw the visualization with an extra circle. The second handler, triggered by a click on the Prepend button, causes a random <span aria-label=" Page 275. " epub:type="pagebreak" id="pg_275" role="doc-pagebreak"/>number to be unshifted onto the front of the numbers array <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The third is triggered by a click on the Drop button; it pops the last number from the array <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. After each of these actions we also call the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function.</p>
<p class="TX">Reload the page and try out the different buttons. You should see the elements being added and removed as needed.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="h2-91"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transitions and Key Functions</samp></h4>
<p class="TNI1">Instead of updating a D3 visualization abruptly with each change in the data, you can use <i>transitions</i> to allow elements to animate their attributes as they change. Transitions are a useful feature in D3 because, if done right, they allow you to see how data evolves. Let’s add a transition to our <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function to see how this works. Make the changes shown in <a href="#Lis14-23">Listing 14-23</a>.</p>
<span id="Lis14-23"/>
<pre><code><var>--snip--</var>
<span class="gray">function update(data) {</span>
<span class="gray">  d3</span>
<span class="gray">    .select("svg")</span>
<span class="gray">    .selectAll("circle")</span>
<span class="gray">    .data(data)</span>
    .join("circle")
    .transition()
    .duration(500)
<span class="gray">    .attr("cx", (d, i) =&gt; (i + 1) * 50)</span>
<span class="gray">    .attr("cy", 50)</span>
<span class="gray">    .attr("r", (d, i) =&gt; d * 5);</span>
<span class="gray">}</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-23: Adding transitions</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span> method in a chain like this means that every following attribute change will animate from its current value to the new value. The <span class="SANS_TheSansMonoCd_W5Regular_11">duration</span> method sets the length of the animation in milliseconds. This means that the position and radius of each circle will take half a second (500 ms) to animate from its current value to the new value. New circles start off with default values of <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> for each attribute, so they will transition in from the top-left corner of the SVG.</p>
<p class="TX">Unfortunately, the way we’ve coded our <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function, the animation won’t be quite as satisfying as you might want. Reload the page and click <b>Prepend</b> a few times. You should see some odd behavior. You might have expected the existing circles to move over to the right, making room for a new circle being added on the left. Instead, the existing circles all appear to resize in place, while a new circle flies in from the top-left corner and takes its place to the right of the existing circles. With this animation, it’s actually very hard to see that an element is being <i>prepended</i> on the left. Rather, the animations suggest that an element is being <i>appended</i> on the right, and that all the elements are being resized. Clicking the Append button, on the other hand, does the correct thing: a new element animates in and appears at the end of the row, while the existing elements don’t change.</p>
<p class="TX"><span aria-label=" Page 276. " epub:type="pagebreak" id="pg_276" role="doc-pagebreak"/>The problem here is that when D3 updates an existing selection with a new array of data, it uses a default mode called <i>join-by-index</i>. This means that the first item in the array is joined with the first element in the selection (in this case, the leftmost circle), the second item in the array with the second element in the selection, and so on. If there are more items in the array than existing SVG elements, new elements are added at the end. Thus, when you click Prepend and add a new number to the start of the data array, every circle in the line is re-bound to a new datum. The first circle in the line is bound to the new number that’s been added to the start of the array, so it appears to resize. The second circle is bound to what used to be the first number in the array, so it appears to resize as well, and so on. Finally, since there’s now one more data item than there are SVG elements, a new circle is created and added at the end of the line.</p>
<p class="TX">The solution to making the animation more intuitive is to help D3 understand the <i>identity</i> of each element in the array of data. Instead of assuming that every index in the array will always map to the same index in the selection, we provide what D3 calls a <i>key function</i>. The key function allows us to specify something about each datum that identifies it uniquely. This way, each existing datum stays bound to the same SVG element even as new data is added, regardless of the ordering of the data.</p>
<p class="TX">The key function is passed as an optional second argument to the <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> method. <a href="#Lis14-24">Listing 14-24</a> shows the necessary change to the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function.</p>
<span id="Lis14-24"/>
<pre><code><var>--snip--</var>
<span class="gray">  .selectAll("circle")</span>
  .data(data, d =&gt; d)
<span class="gray">  .join("circle")</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-24: Adding a key function</samp></p>
<p class="TX">The key function <span class="SANS_TheSansMonoCd_W5Regular_11">d =&gt; d</span> here says that given a datum, the datum itself is the unique identifier. In this case, we’re just using raw numbers, so the value of the number is as good as we can get for a “unique” identifier. Usually you’ll be working with more complex data, and you can use the key function to expose an identifier that is actually unique. For example, if each datum were an object representing an employee with a unique <span class="SANS_TheSansMonoCd_W5Regular_11">employeeId</span> property, then you could use a key function like <span class="SANS_TheSansMonoCd_W5Regular_11">d =&gt; d.employeeId</span>.</p>
<p class="TX">Reload the page and click <b>Prepend</b>. You should now see all the circles slide to the right to accommodate the newly prepended element. This is because D3 now knows which item in the new array should map to which element in the selection when the array changes.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Advanced Joins</samp></h4>
<p class="TNI1">D3’s <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method has extra options that give you more control over how the visualization responds to changes in the data. When D3 joins new data to an existing selection, some elements may be updated, some may be added (for the case of a new datum with no existing element), and some elements <span aria-label=" Page 277. " epub:type="pagebreak" id="pg_277" role="doc-pagebreak"/>may be removed. In our case, we’ve seen how clicking Prepend both adds a new element and updates all the other elements by shifting them to the right. Meanwhile, clicking Drop removes the last element. In D3 parlance, adding a new element is called an <i>enter</i>, removing an existing element is called an <i>exit</i>, and modifying an existing element is called an <i>update</i>.</p>
<p class="TX">You can customize the <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method by passing it three functions that will be called for each of these three possible element changes. This way you’re able to specify three different behaviors: one for entering elements, one for elements that are being updated, and one for exiting elements. To test this functionality, modify your <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function as shown in <a href="#Lis14-25">Listing 14-25</a>. To start, these changes result in the same behavior we got from the simple <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method in the previous listing.</p>
<span id="Lis14-25"/>
<pre><code><var>--snip--</var>
<span class="gray">  .data(data, d =&gt; d)</span>
  .join(
    enter =&gt; enter.append("circle"),
    update =&gt; update,
    exit =&gt; exit.remove()
  )
<span class="gray">  .transition()</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-25: The join</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">method with enter, update, and exit functions</samp></p>
<p class="TX">This more advanced version of the <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method takes three functions. The first function has a single parameter called <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span>, which is a selection of temporary placeholders for each of the entering elements. To get the same behavior as the simple <span class="SANS_TheSansMonoCd_W5Regular_11">.join("circle")</span> version, we just use the <span class="SANS_TheSansMonoCd_W5Regular_11">append</span> method to add a circle to each <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> placeholder. Note that the <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> placeholders themselves aren’t elements in the DOM. They’re just a handle for D3 to give you a place to append your new entering elements, before they get added to the DOM. For example, if there were five new elements needing to be entered, then <span class="SANS_TheSansMonoCd_W5Regular_11">enter.append("circle")</span> would create five new <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> elements and place them inside the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element.</p>
<p class="TX">The second function has a single parameter called <span class="SANS_TheSansMonoCd_W5Regular_11">update</span>, which is a selection containing all the existing elements that are already bound to a datum. To get the same behavior as before, we just return the selection unchanged.</p>
<p class="TX">The third function has a single parameter called <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span>, which is a selection containing all the elements that should be removed because they no longer have a corresponding datum. To get the same behavior as before, we call the <span class="SANS_TheSansMonoCd_W5Regular_11">remove</span> method on the selection, which removes each exiting element from the DOM.</p>
<p class="TX">When you reload the page, you should see the same behavior as before; so far, this change doesn’t have any functional impact. Now that we have it working, though, we can rework our animations to add some finesse. The current shift-right animation for elements in the updating selection is fine, but entering elements currently fly in from the top-left corner, and exiting <span aria-label=" Page 278. " epub:type="pagebreak" id="pg_278" role="doc-pagebreak"/>elements just disappear. Let’s instead make it so entering elements grow into place from their correct position, and exiting elements shrink away to nothing at their current position. The changes to implement that behavior are shown in <a href="#Lis14-26">Listing 14-26</a>.</p>
<span id="Lis14-26"/>
<pre><code><var>--snip--</var>
<span class="gray">function update(data) {</span>
<span class="gray">  d3</span>
<span class="gray">    .select("svg")</span>
<span class="gray">    .selectAll("circle")</span>
<span class="gray">    .data(data, d =&gt; d)</span>
<span class="gray">    .join(</span>
      enter =&gt; enter
      <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> .append("circle")
        .attr("cx", (d, i) =&gt; (i + 1) * 50)
        .attr("cy", 50)
        .transition()
        .duration(500)
      <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> .attr("r", (d, i) =&gt; d * 5),
      update =&gt; update
        .transition()
        .duration(500)
      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> .attr("cx", (d, i) =&gt; (i + 1) * 50),
      exit =&gt; exit
        .transition()
        .duration(500)
      <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> .attr("r", 0)
      <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> .remove()
    );
<span class="gray">}</span>

<span class="gray">update(numbers); </span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-26: Finessing the animations</samp></p>
<p class="TX">In this updated code, we’ve moved all the transitions into the individual <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">update</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> functions, instead of having a single <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span> call for all the elements. The <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> function appends a <span class="SANS_TheSansMonoCd_W5Regular_11">circle</span> element <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and then immediately sets its position (the <span class="SANS_TheSansMonoCd_W5Regular_11">cx</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">cy</span> attributes), but not its radius. Once the position is set, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span> method to animate the radius from zero (the default value) to the value calculated from the datum <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The order here is important: anything that comes in the chain <i>before</i> the call to <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span> will happen immediately, and anything <i>after</i> the call to <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span> will be animated. This means that any new circles will appear in the right position immediately, and the change in size (from zero to the desired radius) will animate. This will arguably look more natural than the previous version, where all three attributes animated in from zero, leading to the circles flying in from the corner.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function has to animate only the <span class="SANS_TheSansMonoCd_W5Regular_11">cx</span> attribute of the circle <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> to slide it to its updated position. All other attributes should be unchanged for existing elements. Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> function animates the radius of the <span aria-label=" Page 279. " epub:type="pagebreak" id="pg_279" role="doc-pagebreak"/>circle back to zero <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> before removing it <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. If <span class="SANS_TheSansMonoCd_W5Regular_11">remove</span> is called after a call to <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span>, as it is here, the actual element removal won’t take place until after the animations have completed.</p>
<p class="TX">When you reload the page, you should see the new and improved animations: new elements expand in at the appropriate position and removed elements shrink away.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<aside aria-label="box-45" class="box" id="sec17">
<h4 class="BH" id="box-45"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">14-2.</samp><samp class="SANS_Futura_Std_Book_11">  Try modifying the animations for entering elements. For example, right now the radius expands from the default value of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span><samp class="SANS_Futura_Std_Book_11">, but what if you wanted the radius to start out big (say,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">50</span><samp class="SANS_Futura_Std_Book_11">) and then shrink to its correct value? Hint: you’ll need to set the starting radius before the call to</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span><samp class="SANS_Futura_Std_Book_11">.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">14-3.</samp><samp class="SANS_Futura_Std_Book_11">  You can also animate color. For example, try starting the elements with a</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">fill</span> <samp class="SANS_Futura_Std_Book_11">attribute of purple, and then animating them to red.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">14-4.</samp><samp class="SANS_Futura_Std_Book_11">  What if you wanted to animate the circles in from the top of the screen, with a fixed radius? Hint: move the setting of the radius to before</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span><samp class="SANS_Futura_Std_Book_11">, move the setting of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">cy</span> <samp class="SANS_Futura_Std_Book_11">to after</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span><samp class="SANS_Futura_Std_Book_11">, and add a starting</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">cy</span> <samp class="SANS_Futura_Std_Book_11">value of something like</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">-50</span><samp class="SANS_Futura_Std_Book_11">.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="h1-87"/><samp class="SANS_Futura_Std_Bold_B_11">Creating a Bar Graph</samp></h3>
<p class="TNI1">Now that you’ve learned the basics of D3, let’s put them to use in a small project: creating a bar graph that visualizes the frequency of characters in a text box. The bar graph will update as new text is typed or pasted into the box. Creating this visualization will let you practice data joins, teach you some new techniques like drawing axes to contextualize the data, and prepare you for the more substantial project in the next chapter.</p>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="H2" id="sec19"><span id="h2-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up</samp></h4>
<p class="TNI1">To get started, make a new directory called <i>frequency</i> and add empty <i>script.js</i> and <i>style.css</i> files. Then create an <i>index.html</i> file and add the code in <a href="#Lis14-27">Listing 14-27</a>.</p>
<span id="Lis14-27"/>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Character Frequency&lt;/title&gt;
    &lt;link rel="stylesheet" href="style.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
    <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> &lt;textarea rows="5" cols="70"&gt;&lt;/textarea&gt;
    &lt;/div&gt;
<span aria-label=" Page 280. " epub:type="pagebreak" id="pg_280" role="doc-pagebreak"/>    &lt;script src="https://unpkg.com/d3@7.4.4/dist/d3.js"&gt;&lt;/script&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-27: The</samp> <samp class="SANS_Futura_Std_Book_11">index.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file for the character frequency project</samp></p>
<p class="TX">This HTML document follows the same pattern we’ve been using throughout the book. The only new addition is the <span class="SANS_TheSansMonoCd_W5Regular_11">textarea</span> element <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which creates a multiline text input. The <span class="SANS_TheSansMonoCd_W5Regular_11">rows</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">cols</span> attributes set the number of lines and the width (in fixed-width characters) of the text area.</p>
<p class="TX">Notice that the document doesn’t contain an <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element. We’re going to create it using JavaScript. This is because we’ll need to refer to the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element’s width and height multiple times to determine the placement of elements in the visualization, so it makes sense to define those parameters in the JavaScript rather than in the HTML file. And since we’ll be defining the width and height in the JavaScript, we may as well create the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element itself in the JavaScript, too. We’ll do that right now. Add the code in <a href="#Lis14-28">Listing 14-28</a> to <i>script.js</i>.</p>
<span id="Lis14-28"/>
<pre><code>const width = 600;
const height = 600;

// Add an svg element to the page
let svg = d3
  .select("body")
  .append("svg")
  .attr("width", width)
  .attr("height", height);
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-28: Creating the svg element using JavaScript</samp></p>
<p class="TX">We first declare constants for the width and height of the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element. Then we use D3 to select the <span class="SANS_TheSansMonoCd_W5Regular_11">body</span> element and append an <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element to it, setting the <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attributes in the process. We save the result of creating the element into the variable <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> because we’re going to need it later.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="H2" id="sec20"><span id="h2-94"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating Character Frequencies</samp></h4>
<p class="TNI1">Next, we’ll add the code for reading the text from the text area and counting the number of occurrences of each character. This generates the underlying data for the visualization. Anytime the text changes, we’ll need to update the data and redraw the chart. For now, though, we’ll just read the text, figure out the character frequencies, and log the output to the console. Add the code in <a href="#Lis14-29">Listing 14-29</a> to the end of <i>script.js</i>.</p>
<span id="Lis14-29"/>
<pre><code><var>--snip--</var>
d3.select("textarea").on(<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> "input", e =&gt; {
<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> let frequencies = {};

<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> e.target.value.split(" ").forEach(char =&gt; {
    let currentCount = frequencies[char] || 0;
<span aria-label=" Page 281. " epub:type="pagebreak" id="pg_281" role="doc-pagebreak"/>    frequencies[char] = currentCount + 1;
  });

  console.log(frequencies);
});
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-29: Calculating character frequencies</samp></p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">input</span> event <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> is triggered anytime the content of the text area changes, whether from typing, deleting, pasting, or some other action. The first thing we do in the event’s handler function is initialize a new object for keeping track of the character frequencies <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This <span class="SANS_TheSansMonoCd_W5Regular_11">frequencies</span> object will use characters for its keys and the number of appearances of that character for its values. We then get the <span class="SANS_TheSansMonoCd_W5Regular_11">target</span> of the event (the text area), get its <span class="SANS_TheSansMonoCd_W5Regular_11">value</span> (the text), and split it into its individual characters <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. For each character, we determine the current count for that character, defaulting to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> if it hasn’t been seen yet. Then we add <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to that count and store the new count back in the object. Once all the characters have been counted, we log the <span class="SANS_TheSansMonoCd_W5Regular_11">frequencies</span> object to the console so we can check everything is working as expected. Note that we recalculate the <span class="SANS_TheSansMonoCd_W5Regular_11">frequencies</span> object every time the text changes, rather than just trying to track added or deleted characters. This makes it much easier to handle cases where multiple characters are added or removed at once, for example, when text is pasted into the box.</p>
<p class="TX">Load the page, and you should see the text area (the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element is invisible, but you can see it in the Elements panel if you want to check it’s there). When you type text into the text area, you should see objects being logged to the console on every keystroke, each time containing the frequencies of the characters in the text area. For example, if you type in the word <i>hello</i>, you’ll get this object after typing the final <i>o</i>:</p>

<pre><code>{"h": 1, "e": 1, "l": 2, "o": 1}</code></pre>
<p class="TX">A single object containing all the characters and their frequencies works well for logging to the console, but what we’re going to want for rendering with D3 is an array of objects, each describing a single character and its associated frequency. This way, each entry in the array will be a datum bound to a bar in our bar chart. To make the chart easier to read, the array should be sorted alphabetically by character. Continuing with the word <i>hello</i>, instead of the object shown previously, we need something like this:</p>

<pre><code>[
  {"char": "e", "count": 1},
  {"char": "h", "count": 1},
  {"char": "l", "count": 2},
  {"char": "o", "count": 1}
]
</code></pre>
<p class="TX">To put the data in this array format, change the end of <i>script.js</i> as shown in <a href="#Lis14-30">Listing 14-30</a>.</p>
<span id="Lis14-30"/>
<pre><code><span aria-label=" Page 282. " epub:type="pagebreak" id="pg_282" role="doc-pagebreak"/><var>--snip--</var>
<span class="gray">    frequencies[char] = currentCount + 1;</span>
<span class="gray">  });</span>

<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> let data = Object.entries(frequencies).map(pair =&gt; {
    return {char: pair[0], count: pair[1]};
  });

<span aria-label="annotation2" class="CodeAnnotationCode">❷</span> data.sort((a, b) =&gt; d3.ascending(a.char, b.char));

  console.log(data);
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-30: Converting the frequency data to an array</samp></p>
<p class="TX">First, we use <span class="SANS_TheSansMonoCd_W5Regular_11">Object.entries</span> to convert the <span class="SANS_TheSansMonoCd_W5Regular_11">frequencies</span> object into an array of two-element arrays <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, where the first element is the key and the second element is the value. We map this array into an array of objects, where the key is stored under the property <span class="SANS_TheSansMonoCd_W5Regular_11">char</span> and the value is stored under the property <span class="SANS_TheSansMonoCd_W5Regular_11">count</span>. Next, we want to sort the data by character. The <span class="SANS_TheSansMonoCd_W5Regular_11">sort</span> method <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> orders the elements in an array by applying a comparison function to every pair of elements <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, to determine whether <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> should be sorted after <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> or vice versa. Here we use the <span class="SANS_TheSansMonoCd_W5Regular_11">d3.ascending</span> comparison function, passing <span class="SANS_TheSansMonoCd_W5Regular_11">a.char</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">b.char</span>, which means the array will be sorted into ascending alphabetical order based on the <span class="SANS_TheSansMonoCd_W5Regular_11">char</span> property of each object.</p>
<p class="TX">Reload the page, and you should now see this new <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> array being logged as text changes in the text area.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H2" id="sec21"><span id="h2-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Drawing the Bar Graph</samp></h4>
<p class="TNI1">Now that we have the data in the format we need, we can render it as a bar graph. We’re going to start out with a basic, naive rendering for now, where we simply create SVG <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> elements with widths proportional to the character frequencies. We’ll gradually build from there to create a more informative visualization. Make the changes to <i>script.js</i> shown in <a href="#Lis14-31">Listing 14-31</a>.</p>
<span id="Lis14-31"/>
<pre><code><var>--snip--</var>
<span class="gray">// Add an svg element to the page</span>
<span class="gray">let svg = d3</span>
<span class="gray">  .select("body")</span>
<span class="gray">  .append("svg")</span>
<span class="gray">  .attr("width", width)</span>
<span class="gray">  .attr("height", height);</span>

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> function update(data) {
  svg
    .selectAll("rect")
    .data(data)
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> .join("rect")
    .attr("width", (d, i) =&gt; d.count * 5)
    .attr("height", 10)
    .attr("x", 20)
<span aria-label=" Page 283. " epub:type="pagebreak" id="pg_283" role="doc-pagebreak"/>    .attr("y", (d, i) =&gt; i * 20);
}

<span class="gray">d3.select("textarea").on("input", e =&gt; {</span>
<span class="TheSansMonoCd_W5Regular_Italic_I_11">--snip--</span>

<span class="gray">  data.sort((a, b) =&gt; d3.ascending(a.char, b.char));</span>

<span aria-label="annotation3" class="CodeAnnotationCode">❸</span> update(data);
<span class="gray">});</span>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-31: Defining the update function</samp></p>
<p class="TX">Here we declare an <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which gets called every time the text changes <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The function creates, updates, or deletes the SVG elements needed to render the data, according to the same pattern we learned earlier for binding data to a selection (using the <span class="SANS_TheSansMonoCd_W5Regular_11">data</span> method) and joining in the necessary elements with the simple version of the <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method returns a selection containing all the current <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> elements <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, including any that were just added. Each <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> is now bound to a single datum, which represents a single character and the number of occurrences of that character. We set the <span class="SANS_TheSansMonoCd_W5Regular_11">width</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">height</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> attributes as appropriate to create a horizontally oriented bar chart. The <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> attribute is set to 5 times the character count, so every new instance of a character makes the bar 5 pixels wider. The <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attribute is a constant value of 10 (all bars are the same height), and the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> attribute is a constant value of 20 (all bars start 20 pixels from the left of the SVG element). The <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> attribute is set to 20 times the index of the datum, meaning that there will be a bar every 20 pixels, giving 10 pixels of space between each bar.</p>
<p class="TX">Reload the page and type the word <i>hello</i> into the text area. As you type each letter, you should see bars appear or update in the SVG element, ending with something like <a href="chapter14.xhtml#fig14-9">Figure 14-9</a>.</p>
<figure class="IMG"><img alt="" class="img4" id="fig14-9" src="../images/Figure_14-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: A basic bar chart</samp></p></figcaption>
</figure>
<p class="TX">So far so good, but we still have a ways to go. There are two major issues here. First, there are no axes or labels, so we don’t know what character each bar represents or what the width of the bar corresponds to. Second, there’s no autoscaling of the bar widths and heights, meaning that we currently have a limit of 30 distinct characters and a count of 116 per character <span aria-label=" Page 284. " epub:type="pagebreak" id="pg_284" role="doc-pagebreak"/>before the bars don’t fit in the 600×600-pixel SVG element. Luckily, both of these problems are easy to fix using D3.</p>
<p class="HeadC"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Scaling the Bars</samp></p>
<p class="TNI1">A <i>scale</i> in D3 is a way of converting from some data value to a visual value. For example, earlier we set the width of the bars in our character frequency graph to be five times the data value, which is a simple form of scaling. In that case, we set the scale factor manually, but D3 can also determine the scaling automatically based on the minimum and maximum data values, known as the <i>domain</i>, and the minimum and maximum display values, known as the <i>range</i>.</p>
<p class="TX">For example, say you’re plotting a graph of people’s ages. Your data values range from 0 to 105, and the space for rendering those values ranges from 30 to 330 pixels from the left side of the SVG. Your domain is thus [0, 105], and your range is [30, 330]. A value of 0 in the data domain maps to 30 in the visual range, and a value of 105 maps to 330. See <a href="chapter14.xhtml#fig14-10">Figure 14-10</a> for a visual representation of this mapping.</p>
<figure class="IMG"><img alt="" class="img8" id="fig14-10" src="../images/Figure_14-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: Scaling values from a domain of [0, 105] to a range of [30, 330]</samp></p></figcaption>
</figure>
<p class="TX">The beauty of D3 scaling is that the scale factor can change dynamically based on changes in the domain. This way, the current maximum data value can always map to the full visual range, even as the maximum data value changes. To implement this dynamic scaling for our bar graph, we need to keep track of the maximum <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> value among all the data, and use that as the upper value of the domain. As a result, if the maximum count increases, the bars that aren’t at the maximum count will all scale down accordingly, while the bar at the maximum count will continue to occupy the full horizontal range. For example, say that our visual range for the bars is [0, 500], and we have the following data:</p>

<pre><code>[
  {"char": "a", "count": 1},
  {"char": "b", "count": 1},
  {"char": "c", "count": 2}
]
</code></pre>
<p class="TX">The domain of our data would be [0, 2]. The <span class="SANS_TheSansMonoCd_W5Regular_11">"c"</span> bar would be 500 units wide, and the <span class="SANS_TheSansMonoCd_W5Regular_11">"a"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"b"</span> bars would each be 250 units wide. If we then added another two c’s, the <span class="SANS_TheSansMonoCd_W5Regular_11">"c"</span> bar would still be 500 units wide, but now the <span class="SANS_TheSansMonoCd_W5Regular_11">"a"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"b"</span> bars would each be 125 units wide.</p>
<p class="TX">Let’s implement that dynamic horizontal scaling now. Modify your script with the code shown in <a href="#Lis14-32">Listing 14-32</a>.</p>
<span id="Lis14-32"/>
<pre><code><span aria-label=" Page 285. " epub:type="pagebreak" id="pg_285" role="doc-pagebreak"/><var>--snip--</var>
<span class="gray">// Add an svg element to the page</span>
<span class="gray">let svg = d3</span>
<span class="gray">  .select("body")</span>
<span class="gray">  .append("svg")</span>
<span class="gray">  .attr("width", width)</span>
<span class="gray">  .attr("height", height);</span>

let margin = {top: 20, right: 10, bottom: 20, left: 50};

<span class="gray">function update(data) {</span>
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> let xScale = d3.scaleLinear()
    .domain([0, d3.max(data, d =&gt; d.count)])
    .range([margin.left, width - margin.right]);

<span class="gray">  svg</span>
<span class="gray">    .selectAll("rect")</span>
<span class="gray">    .data(data)</span>
<span class="gray">    .join("rect")</span>
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> .attr("width", (d, i) =&gt; xScale(d.count) - xScale(0))
<span class="gray">    .attr("height", 10)</span>
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> .attr("x", xScale(0))
<span class="gray">    .attr("y", (d, i) =&gt; i * 20);</span>
<span class="gray">}</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-32: Creating a scale for the bar widths</samp></p>
<p class="TX">First, immediately before the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function definition, we create an object describing the margins of our bar chart diagram. These values indicate how far from the edges of the SVG element the main body of the diagram will be. As <a href="chapter14.xhtml#fig14-11">Figure 14-11</a> shows, when the time comes we’ll use these margins to determine where to draw the bars and the axes.</p>
<figure class="IMG"><img alt="" class="img5" id="fig14-11" src="../images/Figure_14-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: How margins can be used to position a diagram in an SVG element (the dotted line)</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 286. " epub:type="pagebreak" id="pg_286" role="doc-pagebreak"/>Inside the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">d3.scaleLinear</span> method to create a scale <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This means that input values map linearly to output values (as opposed to logarithmically, for example). We set the domain from zero to the max count, using the D3 <span class="SANS_TheSansMonoCd_W5Regular_11">max</span> helper. This helper takes an array of data and a function that returns a value from the datum, and returns the maximum value. In this case, it’s returning the maximum <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> value. The range is set from <span class="SANS_TheSansMonoCd_W5Regular_11">margin.left</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">width - margin.right</span> and gives us the position of the right side of the longest bar.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">scaleLinear</span> helper gives us a function that maps from the data domain to the visual range, which we assign to the variable <span class="SANS_TheSansMonoCd_W5Regular_11">xScale</span>. (As discussed in <a href="chapter5.xhtml">Chapter 5</a>, it’s possible for a higher-order function to return another function, as <span class="SANS_TheSansMonoCd_W5Regular_11">scaleLinear</span> is doing here.) We modify our <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> attribute setting to call that <span class="SANS_TheSansMonoCd_W5Regular_11">xScale</span> function, passing the <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> from each datum <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Here, <span class="SANS_TheSansMonoCd_W5Regular_11">xScale(0)</span> gives the horizontal position of the left side of the bar, which corresponds to the <span class="SANS_TheSansMonoCd_W5Regular_11">domain</span> value <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">xScale(d.count)</span> gives the horizontal position of the right side of the bar. To get the width of the bar, we need to subtract <span class="SANS_TheSansMonoCd_W5Regular_11">xScale(0)</span> from <span class="SANS_TheSansMonoCd_W5Regular_11">xScale(d.count</span>), because the width is just the distance between the left side of the bar and the right side of the bar. This will give an appropriately scaled bar width based on the count of each datum and the maximum count. We set the <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> attribute of the bar to <span class="SANS_TheSansMonoCd_W5Regular_11">xScale(0)</span> to enforce the left margin <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">Reload the page and start typing into the text area. The first time you enter a character, a single bar will appear, at the maximum width. Try typing <i>abccc</i> into the text area; you’ll see that as you add more c’s, the first two bars (for a and b) get smaller.</p>
<p class="TX">Now let’s create a scale for the height of the bars, to make full use of the vertical space of the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element. The bars will start out tall but get shorter to accommodate more bars as new characters are added to the text field. Make the changes shown in <a href="#Lis14-33">Listing 14-33</a>.</p>
<span id="Lis14-33"/>
<pre><code><var>--snip--</var>
<span class="gray">function update(data) {</span>
<span class="gray">  let xScale = d3.scaleLinear()</span>
<span class="gray">    .domain([0, d3.max(data, d =&gt; d.count)])</span>
<span class="gray">    .range([margin.left, width - margin.right]);</span>

<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> let yScale = d3.scaleBand()
    .domain(data.map(d =&gt; d.char))
    .range([margin.top, height - margin.bottom])
    .padding(0.5);

<span class="gray">  svg</span>
<span class="gray">    .selectAll("rect")</span>
<span class="gray">    .data(data)</span>
<span class="gray">    .join("rect")</span>
<span class="gray">    .attr("width", (d, i) =&gt; xScale(d.count) - xScale(0))</span>
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> .attr("height", yScale.bandwidth())
<span class="gray">    .attr("x", xScale(0))</span>
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> .attr("y", (d, i) =&gt; yScale(d.char));
<span class="gray">}</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-33: Scaling the bar heights</samp></p>
<p class="TX"><span aria-label=" Page 287. " epub:type="pagebreak" id="pg_287" role="doc-pagebreak"/>To create a scale for the heights of the bars, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">d3.scaleBand</span> helper <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This lets us create a set of evenly spaced bands. The domain here is slightly different, because instead of an array giving the minimum and maximum values, it contains the full set of values. For example, if the content of the text area were the word <i>hello</i>, the domain of the y scale would be <span class="SANS_TheSansMonoCd_W5Regular_11">["e", "h", "l", "o"]</span> (remember that we sort the data alphabetically). This would map to four evenly spaced bars.</p>
<p class="TX">The range here is from <span class="SANS_TheSansMonoCd_W5Regular_11">margin.top</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">height - margin.bottom</span>, which gives the range of y values the bars will exist in (the first bar will be at the top and the last at the bottom). The <span class="SANS_TheSansMonoCd_W5Regular_11">padding</span> value defines how much space there is between bars based on the space available: <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> means that they are as tall as possible and will be touching, while <span class="SANS_TheSansMonoCd_W5Regular_11">0.5</span> means that the bars will take up half of the space available.</p>
<p class="TX">Scales created using <span class="SANS_TheSansMonoCd_W5Regular_11">scaleBand</span> also have a <span class="SANS_TheSansMonoCd_W5Regular_11">bandwidth</span> method that returns the scaled size of the bands, which we can use to set the height of the bars <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. (The method is called <span class="SANS_TheSansMonoCd_W5Regular_11">band</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">width</span> on the assumption that the bars are oriented vertically, whereas ours are oriented horizontally.) To get the <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> attribute of the bar, we pass <span class="SANS_TheSansMonoCd_W5Regular_11">d.char</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">yScale</span> function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, because the domain of this scale is all the characters present in the data.</p>
<p class="TX">Reload the page and type some text into the text area. The first character you enter will cause a single tall black bar to appear, but for every unique character you type a new bar will be added, and the heights of the existing bars will decrease to make space. <a href="chapter14.xhtml#fig14-12">Figure 14-12</a> shows how the visualization should look.</p>
<figure class="IMG"><img alt="" class="img5" id="fig14-12" src="../images/Figure_14-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: Our bar graph scaled in both dimensions</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 288. " epub:type="pagebreak" id="pg_288" role="doc-pagebreak"/>Try typing in different text to get a feel for how the bars update as the data changes. Next we’ll add axes with labels, which will update along with the scaling to show the actual range of data. This will make it much easier to understand the graph.</p>
<p class="HeadC"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding Labeled Axes</samp></p>
<p class="TNI1">The D3 axis helpers allow you to draw axes along the sides of your diagrams. An axis in D3 includes a horizontal or vertical line, with small tick marks drawn perpendicular to this line and the value for each tick, as shown in <a href="chapter14.xhtml#fig14-13">Figure 14-13</a>. The axis allows you to see the values in the data domain.</p>
<figure class="IMG"><img alt="" class="img1" id="fig14-13" src="../images/Figure_14-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-13: An axis for the numbers 0 to 8</samp></p></figcaption>
</figure>
<p class="TX">Axes are closely linked to scales, and indeed you need a scale to create an axis. For example, the axis in <a href="chapter14.xhtml#fig14-13">Figure 14-13</a> is 540 pixels wide and contains the numbers from 0 to 8. This axis was created using a scale with a domain of [0, 8] and a range of [0, 540].</p>
<p class="TX">To draw an axis, you first have to define a <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> element that will contain the axis elements. You then create an axis generator object using one of the D3 axis helpers, and finally use the generator object to draw the axis elements into the <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> element.</p>
<p class="TX">Our diagram is going to have two axes: a top axis for showing the count values, and a left axis for showing the character values. First, we’ll add the <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> elements, as shown in <a href="#Lis14-34">Listing 14-34</a>.</p>
<span id="Lis14-34"/>
<pre><code><var>--snip--</var>
<span class="gray">let margin = {top: 20, right: 10, bottom: 20, left: 50};</span>

// Top axis container
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> let topContainer = svg
  .append("g")
  .attr("id", "top")
  .attr("transform", <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> `translate(0, ${margin.top})`);

// Left axis container
<span aria-label="annotation3" class="CodeAnnotationHang">❸</span> let leftContainer = svg
  .append("g")
  .attr("id", "left")
  .attr("transform", <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> `translate(${margin.left}, 0)`);

<span class="gray">function update(data) {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-34: Adding g elements for containing the top and left axes</samp></p>
<p class="TX">We create the top axis container <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> by appending a <span class="SANS_TheSansMonoCd_W5Regular_11">g</span> element to the <span class="SANS_TheSansMonoCd_W5Regular_11">svg</span> element and giving it an <span class="SANS_TheSansMonoCd_W5Regular_11">id</span> of <span class="SANS_TheSansMonoCd_W5Regular_11">"top"</span>. Because we defined the range for <span aria-label=" Page 289. " epub:type="pagebreak" id="pg_289" role="doc-pagebreak"/><span class="SANS_TheSansMonoCd_W5Regular_11">xScale</span> to be <span class="SANS_TheSansMonoCd_W5Regular_11">[margin.left, width - margin.right]</span>, that will also define the visual range of the axis. <span class="SANS_TheSansMonoCd_W5Regular_11">xScale</span> doesn’t have any knowledge of vertical positioning, however, which is why we have to translate it down by <span class="SANS_TheSansMonoCd_W5Regular_11">margin.top</span> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We store the element selection in a variable called <span class="SANS_TheSansMonoCd_W5Regular_11">topContainer</span> so we have a reference to it for later when drawing the axis into the container. The left axis container is created similarly <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, but this time we have to translate it to the right by <span class="SANS_TheSansMonoCd_W5Regular_11">margin.left</span> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, since <span class="SANS_TheSansMonoCd_W5Regular_11">yScale</span> has no knowledge of horizontal positioning.</p>
<p class="TX">Now that we have the containers, we can draw the axes. Make the changes shown in <a href="#Lis14-35">Listing 14-35</a> to the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function.</p>
<span id="Lis14-35"/>
<pre><code><var>--snip--</var>
<span class="gray">  let yScale = d3.scaleBand()</span>
<span class="gray">    .domain(data.map(d =&gt; d.char))</span>
<span class="gray">    .range([margin.top, height - margin.bottom])</span>
<span class="gray">    .padding(0.5);</span>

  let topAxis = d3.axisTop(xScale);

  let leftAxis = d3.axisLeft(yScale);

  topContainer
    .call(topAxis);

  leftContainer
    .call(leftAxis);

  <span class="gray">svg</span>
<span class="gray">    .selectAll("rect")</span>
<span class="gray">    .data(data)</span>
<span class="gray">    .join("rect")</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-35: Drawing the axes</samp></p>
<p class="TX">Here we call <span class="SANS_TheSansMonoCd_W5Regular_11">d3.axisTop</span>, passing <span class="SANS_TheSansMonoCd_W5Regular_11">xScale</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">d3.axisLeft</span>, passing <span class="SANS_TheSansMonoCd_W5Regular_11">yScale</span>. This gives us two axis generators, <span class="SANS_TheSansMonoCd_W5Regular_11">topAxis</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">leftAxis</span>. Axis generators take a selection of an element and draw an axis into that element. Instead of passing a selection to the axis generators, however, we instead pass the generators themselves to a D3 method called <span class="SANS_TheSansMonoCd_W5Regular_11">call</span>. This method, when chained to a selection (such as <span class="SANS_TheSansMonoCd_W5Regular_11">topContainer</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">leftContainer</span>, in this case), calls the provided function on the current selection. Thus, writing <span class="SANS_TheSansMonoCd_W5Regular_11">topContainer .call(topAxis);</span> is equivalent to writing <span class="SANS_TheSansMonoCd_W5Regular_11">topAxis(topContainer);</span>, with either statement drawing the top axis of the bar graph. It’s considered more idiomatic to use <span class="SANS_TheSansMonoCd_W5Regular_11">call</span>, and this makes it easier to chain other methods to the statement.</p>
<p class="TX">Reload the page and type some text in the text area. You’ll see the axes, as shown in <a href="chapter14.xhtml#fig14-14">Figure 14-14</a>.<span aria-label=" Page 290. " epub:type="pagebreak" id="pg_290" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="" class="img5" id="fig14-14" src="../images/Figure_14-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-14: Our bar chart, now with axes</samp></p></figcaption>
</figure>
<p class="TX">If you inspect the axes in the web inspector, you’ll see that they’re made up of <span class="SANS_TheSansMonoCd_W5Regular_11">g</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">path</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">text</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">line</span> elements. A <span class="SANS_TheSansMonoCd_W5Regular_11">line</span> element is like a path, but it just defines the start and end points with the <span class="SANS_TheSansMonoCd_W5Regular_11">x1</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">x2</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">y1,</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y2</span> attributes. These attributes default to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> in the SVG specification, which often works just fine for the purposes of drawing these axes, so you’ll notice in the inspector that many of the <span class="SANS_TheSansMonoCd_W5Regular_11">line</span> attributes aren’t set explicitly.</p>
<p class="TX">There are two things that are a bit off about the top axis right now. First, as you can see in <a href="chapter14.xhtml#fig14-14">Figure 14-14</a>, the labels include numbers with decimal points, like 2.5, but we care only about whole numbers (you can’t have half a character). So, we need to find a way to render only whole numbers, also known as integers. Second, if you enter a string of 15 of the same character (for example, <i>aaaaaaaaaaaaaaa</i>), then the labels will show only even numbers from 0 to 14, and there won’t be a label for 15, as shown in <a href="chapter14.xhtml#fig14-15">Figure 14-15</a>. You’ll continue to see this problem as the maximum count increases, especially beyond 30, where the ticks switch to multiples of 5.</p>
<figure class="IMG"><img alt="" class="img1" id="fig14-15" src="../images/Figure_14-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-15: The top axis when the maximum count is 15</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 291. " epub:type="pagebreak" id="pg_291" role="doc-pagebreak"/>What we’d prefer here is for the domain to extend to 16, to give a nicer-looking axis. Luckily, this second problem is easy to fix. D3 scales have a <span class="SANS_TheSansMonoCd_W5Regular_11">nice</span> method that extends their domain to the next “round” number, which in this case means the next number for which a tick would be drawn. <a href="#Lis14-36">Listing 14-36</a> shows how to incorporate this method.</p>
<span id="Lis14-36"/>
<pre><code><var>--snip--</var>
<span class="gray">  let xScale = d3.scaleLinear()</span>
<span class="gray">    .domain([0, d3.max(data, d =&gt; d.count)])</span>
    .range([margin.left, width - margin.right])
    .nice();
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-36: Making our x scale “nice”</samp></p>
<p class="TX">When you reload the page and again type in 15 of the same character, you’ll see that the axis now extends to 16. Rendering only integers requires a little more effort. The basic approach here is to get the tick values, filter them to only integers, and then set those tick values on the axis. Additionally, we want to change the number rendering to exclude the decimal point, so we render 1 and not 1.0. These changes are shown in <a href="#Lis14-37">Listing 14-37</a>.</p>
<span id="Lis14-37"/>
<pre><code><var>--snip--</var>
<span class="gray">  let yScale = d3.scaleBand()</span>
<span class="gray">  .domain(data.map(d =&gt; d.char))</span>
<span class="gray">  .range([margin.top, height - margin.bottom])</span>
<span class="gray">  .padding(0.5);</span>

<span aria-label="annotation1" class="CodeAnnotationCode">❶</span> let topAxisTicks = xScale.ticks()
    .filter(tick =&gt; Number.isInteger(tick));

  let topAxis = d3.axisTop(xScale)
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> .tickValues(topAxisTicks)
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> .tickFormat(d3.format("d"));

<span class="gray">  let leftAxis = d3.axisLeft(yScale); </span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-37: Rendering integer ticks on the top axis</samp></p>
<p class="TX">First we have to get the ticks, which are available using the <span class="SANS_TheSansMonoCd_W5Regular_11">ticks</span> method on the <span class="SANS_TheSansMonoCd_W5Regular_11">xScale</span> generator <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then filter the ticks to integer values using <span class="SANS_TheSansMonoCd_W5Regular_11">Number.isInteger</span>. This will convert an array like <span class="SANS_TheSansMonoCd_W5Regular_11">[0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4]</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">[0, 1, 2, 3, 4]</span>. Next, we set the filtered tick values on the top axis using the <span class="SANS_TheSansMonoCd_W5Regular_11">tickValues</span> method <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Finally, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">tickFormat</span> method to set a rendering format for the numbers <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This method takes a formatting function that will be used to format each tick value. In this case, <span class="SANS_TheSansMonoCd_W5Regular_11">d3.format("d")</span> returns a function that formats numbers without the decimal point.</p>
<p class="TX">Reload the page and enter some text again; you should see whole numbers rendered without the decimal point.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H2" id="sec22"><span id="h2-96"/><span aria-label=" Page 292. " epub:type="pagebreak" id="pg_292" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Styling with CSS and Regular Expressions</samp></h4>
<p class="TNI1">Next we’re going to improve the appearance of our graph with some CSS styles. In order to better differentiate the types of characters, we’ll give different colors to the bars depending on whether they’re lowercase letters, uppercase letters, numbers, or any other character. To do this, we’ll need a function that can distinguish between these types of characters. The function will use <i>regular expressions</i>, which are a way of specifying patterns in strings of text and then determining if other strings match those patterns.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>JavaScript’s regular expression capabilities are very powerful, but we’ll be considering only the features we need for this project. To learn more, check out the website</i> <a href="https://www.regular-expressions.info"><span class="note_LinkURL_Italic">https://www.regular-expressions.info</span></a>, <i>or search MDN for “regular expressions.”</i></p>
<p class="TX">JavaScript has a regular expression literal syntax that is delimited by forward slashes. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">/hi/</span> is a regular expression literal that matches any string containing the sequence of characters <i>hi</i>. The <i>hi</i> can occur anywhere in the string. For example, the regular expression <span class="SANS_TheSansMonoCd_W5Regular_11">/hi/</span> would match the words <i>hither</i>, <i>Chicken</i>, and <i>sushi</i>. You can more narrowly define a regular expression’s pattern by adding special characters. For example, a caret (<span class="SANS_TheSansMonoCd_W5Regular_11">^</span>) at the start of an expression indicates the character sequence should occur at the start of a string, so <span class="SANS_TheSansMonoCd_W5Regular_11">/^hi/</span> matches any string that starts with <i>hi</i>. Similarly, a dollar sign (<span class="SANS_TheSansMonoCd_W5Regular_11">$</span>) at the end of an expression indicates the character sequence should occur at the end of a string, so <span class="SANS_TheSansMonoCd_W5Regular_11">/hi$/</span> matches any string that ends with <i>hi</i>.</p>
<p class="TX">You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">test</span> method on a regular expression to see if a particular string matches it. Here are some examples in the JavaScript console:</p>

<pre><code><b>/^hi/.test("hi there");</b>
true
<b>/</b><b>^hi/.test("Chicken");</b>
false
</code></pre>
<p class="BodyContinued">The string <span class="SANS_TheSansMonoCd_W5Regular_11">"hi there"</span> passes the test, because <i>hi</i> appears at the beginning of the string, whereas <span class="SANS_TheSansMonoCd_W5Regular_11">"Chicken"</span> fails.</p>
<p class="TX">You can use <span class="SANS_TheSansMonoCd_W5Regular_11">^</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">$</span> together to create a regular expression where the full string must match. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">/^hi$/</span> will match only the string <span class="SANS_TheSansMonoCd_W5Regular_11">"hi"</span> and nothing else, as you can see here:</p>

<pre><code><b>/</b><b>^hi$/.test("hi");</b>
true
<b>/^hi$/.test("him");</b>
false
</code></pre>
<p class="TX">To match a range of characters instead of a single character, use square brackets and a hyphen to describe the range. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">/[a-z]/</span> matches any lowercase character from <i>a</i> to <i>z</i>. The regular expression <span class="SANS_TheSansMonoCd_W5Regular_11">/^[A-Z][a-z]$/</span> matches a string containing an uppercase letter followed by a lowercase letter, and no other characters. Try it out in your console:</p>

<pre><code><span aria-label=" Page 293. " epub:type="pagebreak" id="pg_293" role="doc-pagebreak"/><b>/^[A-Z][a-z]$/.test("Hi");</b>
true
<b>/^[A-Z][a-z]$/.test("iH");</b>
false
<b>/^[A-Z][a-z]$/.test("Hip");</b>
false
</code></pre>
<p class="TX">For this project, we need three regular expressions: <span class="SANS_TheSansMonoCd_W5Regular_11">/^[a-z]$/</span> (matching a single lowercase letter), <span class="SANS_TheSansMonoCd_W5Regular_11">/^[A-Z]$/</span> (matching a single uppercase letter), and <span class="SANS_TheSansMonoCd_W5Regular_11">/^[0-9]$/</span> (matching a single digit). If a character doesn’t match any of those expressions, we’ll know it’s some other kind of character, like a space or a punctuation mark. See <a href="#Lis14-38">Listing 14-38</a> for the new <span class="SANS_TheSansMonoCd_W5Regular_11">getClass</span> function, which uses those regular expressions to choose a CSS class name for a given character’s bar. Add this function to <i>script.js</i> immediately before the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function.</p>
<span id="Lis14-38"/>
<pre><code><var>--snip--</var>
<span class="gray">// Left axis container</span>
<span class="gray">let leftContainer = svg</span>
<span class="gray">  .append("g")</span>
<span class="gray">  .attr("id", "left")</span>
<span class="gray">  .attr("transform", `translate(${margin.left}, 0)`);</span>

function getClass(char) {
  if (/^[a-z]$/.test(char)) {
    return "lower";
  } else if (/^[A-Z]$/.test(char)) {
    return "upper";
  } else if (/^[0-9]$/.test(char)) {
    return "number";
  } else {
    return "other";
  }
}

<span class="gray">function update(data) {</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-38: The getClass function</samp></p>
<p class="TX">This function tests a character against the provided regular expressions and returns the appropriate class name: <span class="SANS_TheSansMonoCd_W5Regular_11">"lower"</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">"upper"</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">"number"</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">"other"</span>. Next, we’ll update the rendering code to use this function to set a class name on each <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> element, as shown in <a href="#Lis14-39">Listing 14-39</a>.</p>
<span id="Lis14-39"/>
<pre><code><var>--snip--</var>
<span class="gray">  svg</span>
<span class="gray">    .selectAll("rect")</span>
<span class="gray">    .data(data)</span>
<span class="gray">    .join("rect")</span>
<span class="gray">    .attr("width", (d, i) =&gt; xScale(d.count) – xScale(0))</span>
<span class="gray">    .attr("height", yScale.bandwidth())</span>
<span class="gray">    .attr("x", xScale(0))</span>
<span aria-label=" Page 294. " epub:type="pagebreak" id="pg_294" role="doc-pagebreak"/>    .attr("y", (d, i) =&gt; yScale(d.char))
    .attr("class", (d, i) =&gt; getClass(d.char));
<span class="gray">}</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-39: Applying the class name based on the character</samp></p>
<p class="TX">Now every <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> element will have a class name based on the character from that element’s datum. The last step is to write the CSS that will give each class name a different fill color. Add the CSS code in <a href="#Lis14-40">Listing 14-40</a> to <i>style.css</i>.</p>
<span id="Lis14-40"/>
<pre><code>.lower {
  fill: purple;
}

.upper {
  fill: orangered;
}

.number {
  fill: green;
}

.other {
  fill: #555;
}
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-40: Defining styles for the different classes</samp></p>
<p class="TX">Now when you reload the page and type in some different characters, you should see something like <a href="chapter14.xhtml#fig14-16">Figure 14-16</a>.</p>
<figure class="IMG"><img alt="" class="img5" id="fig14-16" src="../images/Figure_14-16.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-16: Color-coded bars</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 295. " epub:type="pagebreak" id="pg_295" role="doc-pagebreak"/>The bars should be assigned different colors based on the kind of character entered.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="H2" id="sec23"><span id="h2-97"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cleaning the Data</samp></h4>
<p class="TNI1">Often it’s necessary to clean a dataset by fixing any mistakes or irregularities it contains before visualizing it. For example, one problem with the current approach to our bar graph is that different whitespace characters show up as different bars, each with an invisible label (because the text of the label is just whitespace). These whitespace characters include spaces, newlines, tabs, and various other kinds of spaces that you can type with different key combinations (for example, a non-breaking space, which you can enter with <small>OPTION</small>-spacebar on macOS or <small>CTRL</small>-<small>SHIFT</small>-spacebar on Windows). To fix this, we’ll convert all whitespace characters to the same <span class="SANS_TheSansMonoCd_W5Regular_11">"&lt;space&gt;"</span> string before the character counting, so all whitespace will be visualized by a single bar with a readable label. Update your <i>script.js</i> file as shown in <a href="#Lis14-41">Listing 14-41</a>. These updates come near the end of the file.</p>
<span id="Lis14-41"/>
<pre><code><var>--snip--</var>
function standardizeSpace(char) {
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> if (char.trim() == " ") {
    return "&lt;space&gt;";
  } else {
    return char;
  }
}

<span class="gray">d3.select("textarea").on("input", e =&gt; {</span>
<span class="gray">  let frequencies = {};</span>

  <span class="gray">e.target.value.split(" ").forEach(char =&gt; {</span>
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> let standardized = standardizeSpace(char);
    let currentCount = frequencies[standardized] || 0;
    frequencies[standardized] = currentCount + 1;
<span class="gray">  });</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-41: Standardizing whitespace characters</samp></p>
<p class="TX">We first declare a <span class="SANS_TheSansMonoCd_W5Regular_11">standardizeSpace</span> function that takes a character and calls the <span class="SANS_TheSansMonoCd_W5Regular_11">trim</span> method on it <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">trim</span> method removes whitespace at the start or end of a string, so if it returns an empty string, we know the character is whitespace. In this case, we return the string <span class="SANS_TheSansMonoCd_W5Regular_11">"&lt;space&gt;"</span>. Otherwise, we return the character unchanged. We then have to modify the text processing code to call our function and standardize the whitespace characters <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> before using them as keys in the <span class="SANS_TheSansMonoCd_W5Regular_11">frequencies</span> object.</p>
<p class="TX">Now when you enter various kinds of whitespace characters in the text area, you should see a single bar labeled <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;space&gt;</span> instead of multiple bars with empty labels.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="H2" id="sec24"><span id="h2-98"/><span aria-label=" Page 296. " epub:type="pagebreak" id="pg_296" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Animating the Changes</samp></h4>
<p class="TNI1">Our final task is to add animations to the axes and bars. This will make it easier to see when new elements are added and when the counts for existing elements change. To animate the axes, all we need to do is add a call to <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span> to the <span class="SANS_TheSansMonoCd_W5Regular_11">topContainer</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">leftContainer</span> selections inside the <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function, as shown in <a href="#Lis14-42">Listing 14-42</a>.</p>
<span id="Lis14-42"/>
<pre><code><var>--snip--</var>
<span class="gray">let leftAxis = d3.axisLeft(yScale);</span>

<span class="gray">topContainer</span>
  .transition()
<span class="gray">  .call(topAxis);</span>

<span class="gray">leftContainer</span>
  .transition()
<span class="gray">  .call(leftAxis);</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-42: Adding animations to the axes</samp></p>
<p class="TX">Now when the domains for the axes update to accommodate new data, the existing ticks will animate to their updated positions, and new ticks will fade in.</p>
<p class="TX">We have two options for adding transitions to the bars: we could keep the existing <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> code and just add a single call to <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span>, or we could use the advanced join technique described earlier, which would let us customize the transitions depending on whether the elements are entering, updating, or exiting. As you might guess, we’re going to go with the advanced version! You can find the updated <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> code in <a href="#Lis14-43">Listing 14-43</a>.</p>
<span id="Lis14-43"/>
<pre><code><var>--snip--</var>
<span class="gray">  leftContainer</span>
<span class="gray">    .transition()</span>
<span class="gray">    .call(leftAxis);</span>

<span class="gray">  svg</span>
<span class="gray">    .selectAll("rect")</span>
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> .data(data, d =&gt; d.char)
    .join(
    <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> enter =&gt; enter
        .append("rect")
        .attr("x", xScale(0))
        .attr("y", (d, i) =&gt; yScale(d.char))
        .attr("class", d =&gt; getClass(d.char))
        .transition()
        .attr("width", d =&gt; xScale(d.count) - xScale(0))
        .attr("height", yScale.bandwidth()),
    <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> update =&gt; update
        .transition()
        .attr("width", d =&gt; xScale(d.count) - xScale(0))
<span aria-label=" Page 297. " epub:type="pagebreak" id="pg_297" role="doc-pagebreak"/>        .attr("height", yScale.bandwidth())
        .attr("y", (d, i) =&gt; yScale(d.char)),
    <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> exit =&gt; exit
        .transition()
        .attr("width", 0)
        .attr("height", 0)
        .remove()
    );
<span class="gray">}</span>
<var>--snip--</var>
</code></pre>
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-43: Animating the bars</samp></p>
<p class="TX">The first thing we have to do is set a key function <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> to tell D3 that the datum’s <span class="SANS_TheSansMonoCd_W5Regular_11">char</span> property should be used as its identifier. Next, we switch to the advanced join technique, similar to <a href="#Lis14-25">Listing 14-25</a>. The <span class="SANS_TheSansMonoCd_W5Regular_11">enter</span> function <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> first adds the <span class="SANS_TheSansMonoCd_W5Regular_11">rect</span> element and sets its <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">class</span> attributes before the call to <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span>, meaning that these attributes won’t be animated. The <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> attributes come after the call to <span class="SANS_TheSansMonoCd_W5Regular_11">transition</span>, so these attributes <i>will</i> be animated. This way, new elements will grow in place from the left axis.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">update</span> function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> animates the <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> again, but also animates the <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> attribute. This means that existing elements will slide up or down to their new position when new elements are added.</p>
<p class="TX">Finally, the <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> function <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> animates the <span class="SANS_TheSansMonoCd_W5Regular_11">width</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">height</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> before the element is removed, causing elements to shrink away to nothing at their previous position.</p>
<p class="TX">Reload the page and try adding and removing characters in the text area. Enjoy watching how the elements animate in, out, or update.</p>
</section>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H1" id="sec25"><span id="h1-88"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI1">In this chapter you learned the basics of SVG, and how to use D3 to create, update, and remove SVG elements based on real-time changes in a dataset. By now, you should have a pretty good understanding of how to build a data-based application in D3. In the next chapter, we’ll put this knowledge to work by building an application that reads data from an API and renders it into an interactive diagram.</p>
</section>
</section>
</body>
</html>