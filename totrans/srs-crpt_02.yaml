- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: ENCRYPTION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 加密
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Encryption is the principal application of cryptography; it makes data incomprehensible
    in order to ensure its *confidentiality*. Encryption uses an algorithm called
    a *cipher* and a secret value called the *key*; if you don’t know the secret key,
    you can’t decrypt, nor can you learn any bit of information on the encrypted message—and
    neither can any attacker.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是密码学的主要应用，它使数据变得无法理解，以确保其*机密性*。加密使用一种叫做*密码*的算法和一个叫做*密钥*的秘密值；如果你不知道秘密密钥，就无法解密，也无法知道任何加密消息中的信息——攻击者也是如此。
- en: This chapter will focus on symmetric encryption, which is the simplest kind
    of encryption. In *symmetric encryption*, the key used to decrypt is the same
    as the key used to encrypt (unlike *asymmetric encryption*, or *public-key encryption*,
    in which the key used to decrypt is different from the key used to encrypt). You’ll
    start by learning about the weakest forms of symmetric encryption, classical ciphers
    that are secure against only the most illiterate attacker, and then move on to
    the strongest forms that are secure forever.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讲解对称加密，它是最简单的加密方式。在*对称加密*中，解密所使用的密钥与加密所使用的密钥相同（与*非对称加密*或*公钥加密*不同，后者解密所使用的密钥与加密所使用的密钥不同）。你将从学习最弱的对称加密形式开始，这些经典密码只能抵御最没有技术基础的攻击者，然后逐步学习最强的加密形式，它们是永远安全的。
- en: The Basics
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'When we’re encrypting a message, *plaintext* refers to the unencrypted message
    and *ciphertext* to the encrypted message. A cipher is therefore composed of two
    functions: *encryption* turns a plaintext into a ciphertext, and *decryption*
    turns a ciphertext back into a plaintext. But we’ll often say “cipher” when we
    actually mean “encryption.” For example, [Figure 1-1](ch01.xhtml#ch1fig1) shows
    a cipher, **E**, represented as a box taking as input a plaintext, *P*, and a
    key, *K*, and producing a ciphertext, *C*, as output. I’ll write this relation
    as *C* = **E**(*K*, *P*). Similarly, when the cipher is in decryption mode, I’ll
    write **D**(*K*, *C*).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加密一条信息时，*明文*指的是未加密的信息，而*密文*指的是加密后的信息。因此，密码由两个功能组成：*加密*将明文转化为密文，*解密*将密文还原为明文。但我们通常会说“密码”，实际上是指“加密”。例如，[图
    1-1](ch01.xhtml#ch1fig1)展示了一个密码**E**，它被表示为一个框，输入明文*P*和密钥*K*，输出密文*C*。我会将这个关系写作*C*
    = **E**(*K*, *P*)。类似地，当密码处于解密模式时，我会写作**D**(*K*, *C*)。
- en: '![image](../images/f01-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-01.jpg)'
- en: '*Figure 1-1: Basic encryption and decryption*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：基本加密与解密*'
- en: '**NOTE**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For some ciphers, the ciphertext is the same size as the plaintext; for some
    others, the ciphertext is slightly longer. However, ciphertexts can never be shorter
    than plaintexts.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于某些密码，密文与明文大小相同；对于其他一些密码，密文稍微长一些。然而，密文永远不可能比明文短。*'
- en: Classical Ciphers
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典密码
- en: Classical ciphers are ciphers that predate computers and therefore work on letters
    rather than on bits. They are much simpler than a modern cipher like DES—for example,
    in ancient Rome or during WWI, you couldn’t use a computer chip’s power to scramble
    a message, so you had to do everything with only pen and paper. There are many
    classical ciphers, but the most famous are the Caesar cipher and Vigenère cipher.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 经典密码是指早于计算机的密码，因此它们操作的是字母而非比特。它们比现代密码（如DES）简单得多——例如，在古罗马或第一次世界大战期间，你无法使用计算机芯片的强大算力来加密消息，因此只能用笔和纸完成所有工作。经典密码有很多种，但最著名的是凯撒密码和维吉尼亚密码。
- en: '*The Caesar Cipher*'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*凯撒密码*'
- en: The Caesar cipher is so named because the Roman historian Suetonius reported
    that Julius Caesar used it. It encrypts a message by shifting each of the letters
    down three positions in the alphabet, wrapping back around to A if the shift reaches
    Z. For example, ZOO encrypts to CRR, FDHVDU decrypts to CAESAR, and so on, as
    shown in [Figure 1-2](ch01.xhtml#ch1fig2). There’s nothing special about the value
    3; it’s just easier to compute in one’s head than 11 or 23.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码之所以得名，是因为罗马历史学家苏埃托尼乌斯报道了尤利乌斯·凯撒使用它。它通过将每个字母在字母表中向下移动三个位置来加密信息，当移位到Z时会回绕到A。例如，ZOO加密为CRR，FDHVDU解密为CAESAR，依此类推，如[图
    1-2](ch01.xhtml#ch1fig2)所示。数字3并没有什么特别的意义，它只比11或23更容易在脑海中计算。
- en: 'The Caesar cipher is super easy to break: to decrypt a given ciphertext, simply
    shift the letters three positions back to retrieve the plaintext. That said, the
    Caesar cipher may have been strong enough during the time of Crassus and Cicero.
    Because no secret key is involved (it’s always 3), users of Caesar’s cipher only
    had to assume that attackers were illiterate or too uneducated to figure it out—an
    assumption that’s much less realistic today. (In fact, in 2006, the Italian police
    arrested a mafia boss after decrypting messages written on small scraps of paper
    that were encrypted using a variant of the Caesar cipher: ABC was encrypted to
    456 instead of DEF, for example.)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码非常容易破解：要解密给定的密文，只需将字母向后移动三个位置，即可恢复明文。也就是说，凯撒密码在克拉苏斯和西塞罗时代可能足够强大。因为没有涉及秘密密钥（始终是3），使用凯撒密码的人只需假设攻击者是文盲或者教育水平太低，无法破解密码——这一假设在今天显然不再现实。（事实上，2006年，意大利警方在破译使用凯撒密码变体加密的纸条上的信息后逮捕了一名黑帮老大：例如，ABC被加密为456，而不是DEF。）
- en: '![image](../images/f01-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-02.jpg)'
- en: '*Figure 1-2: The Caesar cipher*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-2：凯撒密码*'
- en: Could the Caesar cipher be made more secure? You can, for example, imagine a
    version that uses a secret shift value instead of always using 3, but that wouldn’t
    help much because an attacker could easily try all 25 possible shift values until
    the decrypted message makes sense.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码能否变得更加安全？你可以想象一个版本，使用一个秘密的偏移值，而不是始终使用3，但这并不会有太大帮助，因为攻击者可以轻松地尝试所有25种可能的偏移值，直到解密出的消息有意义。
- en: '*The Vigenère Cipher*'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*维杰尼尔密码*'
- en: It took about 1500 years to see a meaningful improvement of the Caesar cipher
    in the form of the Vigenère cipher, created in the 16th century by an Italian
    named Giovan Battista Bellaso. The name “Vigenère” comes from the Frenchman Blaise
    de Vigenère, who invented a different cipher in the 16th century, but due to historical
    misattribution, Vigenère’s name stuck. Nevertheless, the Vigenère cipher became
    popular and was later used during the American Civil War by Confederate forces
    and during WWI by the Swiss Army, among others.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大约1500年后，凯撒密码才迎来了有意义的改进，即由意大利人乔凡·巴蒂斯塔·贝拉索（Giovan Battista Bellaso）在16世纪创造的维杰尼尔密码。“维杰尼尔”这个名字来源于法国人布莱兹·德·维杰尼尔（Blaise
    de Vigenère），他在16世纪发明了一种不同的密码，但由于历史上的误归功，维杰尼尔的名字被广泛使用。尽管如此，维杰尼尔密码变得非常流行，并且后来在美国内战期间被南方联邦军使用，第一次世界大战期间被瑞士军队等使用。
- en: 'The Vigenère cipher is similar to the Caesar cipher, except that letters aren’t
    shifted by three places but rather by values defined by a *key*, a collection
    of letters that represent numbers based on their position in the alphabet. For
    example, if the key is DUH, letters in the plaintext are shifted using the values
    3, 20, 7 because *D* is three letters after *A*, *U* is 20 letters after *A*,
    and *H* is seven letters after *A*. The 3, 20, 7 pattern repeats until you’ve
    encrypted the entire plaintext. For example, the word CRYPTO would encrypt to
    FLFSNV using DUH as the key: *C* is shifted three positions to *F*, *R* is shifted
    20 positions to *L*, and so on. [Figure 1-3](ch01.xhtml#ch1fig3) illustrates this
    principle when encrypting the sentence THEY DRINK THE TEA.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 维杰尼尔密码与凯撒密码类似，不同之处在于字母不是按三个位置偏移，而是根据一个*密钥*的值来偏移，密钥是一个字母集合，根据字母在字母表中的位置表示数字。例如，如果密钥是DUH，明文中的字母将使用3、20、7的值进行偏移，因为*D*距离*A*三个字母，*U*距离*A*二十个字母，*H*距离*A*七个字母。3、20、7的模式将重复，直到你加密完整个明文。例如，单词CRYPTO使用DUH作为密钥加密后会变成FLFSNV：*C*向后移动三位变成*F*，*R*向后移动二十位变成*L*，依此类推。[图1-3](ch01.xhtml#ch1fig3)展示了这一加密原理，使用密钥加密句子“THEY
    DRINK THE TEA”。
- en: '![image](../images/f01-03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-03.jpg)'
- en: '*Figure 1-3: The Vigenère cipher*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-3：维杰尼尔密码*'
- en: The Vigenère cipher is clearly more secure than the Caesar cipher, yet it’s
    still fairly easy to break. The first step to breaking it is to figure out the
    key’s length. For example, take the example in [Figure 1-3](ch01.xhtml#ch1fig3),
    wherein THEY DRINK THE TEA encrypts to WBLBXYLHRWBLWYH with the key DUH. (Spaces
    are usually removed to hide word boundaries.) Notice that in the ciphertext WBLBXYLHRWBLWYH,
    the group of three letters WBL appears twice in the ciphertext at nine-letter
    intervals. This suggests that the same three-letter word was encrypted using the
    same shift values, producing WBL each time. A cryptanalyst can then deduce that
    the key’s length is either nine or a value divisible by nine (that is, three).
    Furthermore, they may guess that this repeated three-letter word is THE and therefore
    determine DUH as a possible encryption key.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 维吉尼亚密码显然比凯撒密码更安全，但它仍然相对容易破解。破解它的第一步是确定密钥的长度。例如，参考[图1-3](ch01.xhtml#ch1fig3)，其中“THEY
    DRINK THE TEA”被加密为“WBLBXYLHRWBLWYH”使用密钥“DUH”。（通常会去掉空格以隐藏词边界。）注意到在密文“WBLBXYLHRWBLWYH”中，字母组“WBL”在密文中每隔九个字母就出现一次。这表明相同的三字母单词是使用相同的移位值加密的，每次都会产生“WBL”。密码分析员可以推测，密钥的长度要么是九，要么是九的倍数（即三）。此外，他们可能会猜测这个重复的三字母单词是“THE”，从而确定“DUH”是可能的加密密钥。
- en: The second step to breaking the Vigenère cipher is to determine the actual key
    using a method called *frequency analysis*, which exploits the uneven distribution
    of letters in languages. For example, in English, *E* is the most common letter,
    so if you find that *X* is the most common letter in a ciphertext, then the most
    likely plaintext value at this position is *E*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 破解维吉尼亚密码的第二步是使用一种叫做*频率分析*的方法来确定实际的密钥，该方法利用语言中字母分布的不均匀性。例如，在英语中，*E*是最常见的字母，因此，如果你发现*X*是密文中最常见的字母，那么该位置上最可能的明文字母就是*E*。
- en: Despite its relative weakness, the Vigenère cipher may have been good enough
    to securely encrypt messages when it was used. First, because the attack just
    outlined needs messages of at least a few sentences, it wouldn’t work if the cipher
    was used to encrypt only short messages. Second, most messages needed to be secret
    only for short periods of time, so it didn’t matter if ciphertexts were eventually
    decrypted by the enemy. (The 19th-century cryptographer Auguste Kerckhoffs estimated
    that most encrypted wartime messages required confidentiality for only three to
    four hours.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相对较弱，维吉尼亚密码在它被使用时可能足够安全地加密信息。首先，因为刚才提到的攻击方法需要至少几句话的信息，如果密码只用来加密简短的消息，这个方法就不适用。其次，大多数消息只需要在短时间内保持机密，因此即使密文最终被敌人解密，也没有太大关系。（19世纪的密码学家奥古斯特·凯尔科夫估计，大多数加密的战时消息只需要保密三到四个小时。）
- en: How Ciphers Work
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码是如何工作的
- en: 'Based on simplistic ciphers like the Caesar and Vigenère ciphers, we can try
    to abstract out the workings of a cipher, first by identifying its two main components:
    a permutation and a mode of operation. A *permutation* is a function that transforms
    an item (in cryptography, a letter or a group of bits) such that each item has
    a unique inverse (for example, the Caesar cipher’s three-letter shift). A *mode
    of operation* is an algorithm that uses a permutation to process messages of arbitrary
    size. The mode of the Caesar cipher is trivial: it just repeats the same permutation
    for each letter, but as you’ve seen, the Vigenère cipher has a more complex mode,
    where letters at different positions undergo different permutations.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 基于像凯撒和维吉尼亚密码这样简单的密码，我们可以尝试抽象出密码的工作原理，首先通过识别它的两个主要组件：排列和操作模式。*排列*是一个函数，它将一个项（在密码学中是一个字母或一组比特）转换，使得每个项都有一个唯一的逆项（例如，凯撒密码的三字母移位）。*操作模式*是一个算法，它使用排列来处理任意大小的消息。凯撒密码的操作模式很简单：它只是对每个字母重复相同的排列，但正如你所见，维吉尼亚密码有一个更复杂的模式，其中不同位置的字母会经历不同的排列。
- en: In the following sections, I discuss in more detail what these are and how they
    relate to a cipher’s security. I use each component to show why classical ciphers
    are doomed to be insecure, unlike modern ciphers that run on high-speed computers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将更详细地讨论这些内容，以及它们如何与密码的安全性相关。我使用每个组件来展示为什么经典密码注定是不安全的，而现代密码则能在高速计算机上运行。
- en: '*The Permutation*'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*排列*'
- en: 'Most classical ciphers work by replacing each letter with another letter—in
    other words, by performing a *substitution*. In the Caesar and Vigenère ciphers,
    the substitution is a shift in the alphabet, though the alphabet or set of symbols
    can vary: instead of the English alphabet, it could be the Arabic alphabet; instead
    of letters, it could be words, numbers, or ideograms, for example. The representation
    or encoding of information is a separate matter that is mostly irrelevant to security.
    (We’re just considering Latin letters because that’s what classical ciphers use.)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数经典密码通过将每个字母替换为另一个字母来工作——换句话说，通过进行*替代*。在凯撒密码和维热内密码中，替代是字母表的移位，尽管字母表或符号集可以变化：例如，它可以是阿拉伯字母表；也可以是单词、数字或象形文字，而不仅仅是字母。信息的表示或编码是一个单独的问题，与安全性关系不大。（我们这里只考虑拉丁字母，因为经典密码使用的是这些字母。）
- en: A cipher’s substitution can’t be just any substitution. It should be a permutation,
    which is a rearrangement of the letters *A* to *Z*, such that each letter has
    a unique inverse. For example, a substitution that transforms the letters *A*,
    *B*, *C*, and *D*, respectively to *C*, *A*, *D*, and *B* is a permutation, because
    each letter maps onto another single letter. But a substitution that transforms
    *A*, *B*, *C*, *D* to *D*, *A*, *A*, *C* is not a permutation, because both B
    and C map onto A. With a permutation, each letter has exactly one inverse.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 密码的替代不能只是任何替代。它应该是一个置换，即字母*A*到*Z*的重新排列，使得每个字母都有一个唯一的逆。例如，一个将字母*A*、*B*、*C*、*D*分别替换为*C*、*A*、*D*、*B*的替代是一个置换，因为每个字母都映射到另一个唯一的字母。但一个将*A*、*B*、*C*、*D*替换为*D*、*A*、*A*、*C*的替代就不是一个置换，因为*B*和*C*都映射到*A*。在置换中，每个字母只有一个逆。
- en: 'Still, not every permutation is secure. In order to be secure, a cipher’s permutation
    should satisfy three criteria:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不是每个置换都是安全的。为了确保安全，密码的置换应满足三个标准：
- en: '**The permutation should be determined by the key**, so as to keep the permutation
    secret as long as the key is secret. In the Vigenère cipher, if you don’t know
    the key, you don’t know which of the 26 permutations was used; hence, you can’t
    easily decrypt.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**置换应该由密钥决定**，这样只要密钥保密，置换也能保持保密。在维热内密码中，如果你不知道密钥，你就不知道使用了哪种26种置换；因此，你无法轻易解密。'
- en: '**Different keys should result in different permutations**. Otherwise, it becomes
    easier to decrypt without the key: if different keys result in identical permutations,
    that means there are fewer distinct keys than distinct permutations, and therefore
    fewer possibilities to try when decrypting without the key. In the Vigenère cipher,
    each letter from the key determines a substitution; there are 26 distinct letters,
    and as many distinct permutations.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的密钥应产生不同的置换**。否则，它会变得更容易在没有密钥的情况下进行解密：如果不同的密钥产生相同的置换，这意味着不同的密钥比不同的置换少，因此在没有密钥的情况下解密时可尝试的可能性会更少。在维热内密码中，密钥中的每个字母决定了一个替换；有26个不同的字母，也有同样多的不同置换。'
- en: '**The permutation should look random**, loosely speaking. There should be no
    pattern in the ciphertext after performing a permutation, because patterns make
    a permutation predictable for an attacker, and therefore less secure. For example,
    the Vigenère cipher’s substitution is pretty predictable: if you determine that
    *A* encrypts to *F*, you could conclude that the shift value is 5 and you would
    also know that *B* encrypts to *G*, that *C* encrypts to *H*, and so on. However,
    with a randomly chosen permutation, knowing that *A* encrypts to *F* would only
    tell you that *B* does *not* encrypt to *F*.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**置换应该看起来像是随机的**，简单来说。执行置换后，密文中不应有任何模式，因为模式会使得攻击者能够预测置换，从而降低其安全性。例如，维热内密码的替代是相当可预测的：如果你确定*A*加密成*F*，你可以推断出移位值是5，并且你还会知道*B*加密成*G*，*C*加密成*H*，依此类推。然而，使用随机选择的置换，知道*A*加密成*F*只会告诉你*B*不会加密成*F*。'
- en: We’ll call a permutation that satisfies these criteria a *secure permutation*.
    But as you’ll see next, a secure permutation is necessary but not sufficient on
    its own for building a secure cipher. A cipher will also need a mode of operation
    to support messages of any length.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将满足这些标准的置换称为*安全置换*。但正如你接下来会看到的，安全置换是构建安全密码所必需的，但仅凭它还不足够。密码还需要一种操作模式，以支持任意长度的消息。
- en: '*The Mode of Operation*'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*操作模式*'
- en: Say we have a secure permutation that transforms *A* to *X*, *B* to *M*, and
    *N* to *L*, for example. The word BANANA therefore encrypts to MXLXLX, where each
    occurrence of *A* is replaced by an *X*. Using the same permutation for all the
    letters in the plaintext thus reveals any duplicate letters in the plaintext.
    By analyzing these duplicates, you might not learn the entire message, but you’ll
    learn *something* about the message. In the BANANA example, you don’t need the
    key to guess that the plaintext has the same letter at the three *X* positions
    and another same letter at the two *L* positions. So if you know, for example,
    that the message is a fruit’s name, you could determine that it’s BANANA rather
    than CHERRY, LYCHEE, or another six-letter fruit.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个安全的置换，它将 *A* 转换为 *X*，将 *B* 转换为 *M*，将 *N* 转换为 *L*，例如。那么单词 BANANA 会被加密为
    MXLXLX，其中每个 *A* 都被替换成 *X*。对明文中的所有字母使用相同的置换就会暴露出明文中的重复字母。通过分析这些重复字母，虽然你可能无法完全理解整个信息，但你可以了解到关于信息的*某些*内容。在
    BANANA 示例中，你无需密钥就能猜到明文的三个 *X* 位置上是相同的字母，两个 *L* 位置上也有相同的字母。因此，假如你知道信息是一个水果的名字，你可以判断它是
    BANANA 而不是 CHERRY、LYCHEE 或其他六个字母的水果。
- en: 'The mode of operation (or just *mode*) of a cipher mitigates the exposure of
    duplicate letters in the plaintext by using different permutations for duplicate
    letters. The mode of the Vigenère cipher partially addresses this: if the key
    is *N* letters long, then *N* different permutations will be used for every *N*
    consecutive letters. However, this can still result in patterns in the ciphertext
    because every *N*th letter of the message uses the same permutation. That’s why
    frequency analysis works to break the Vigenère cipher, as you saw earlier.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 密码的操作模式（或称为*模式*）通过对重复字母使用不同的置换，减少了明文中重复字母的暴露。维吉尼亚密码的模式部分解决了这个问题：如果密钥的长度是 *N*
    字符，那么每 *N* 个连续字母将使用 *N* 个不同的置换。然而，这仍然可能导致密文中的模式，因为每 *N* 个字母使用相同的置换。这就是为什么频率分析能破译维吉尼亚密码的原因，正如你之前看到的。
- en: 'Frequency analysis can be defeated if the Vigenère cipher only encrypts plaintexts
    that are of the same length as the key. But even then, there’s another problem:
    reusing the same key several times exposes similarities between plaintexts. For
    example, with the key KYN, the words TIE and PIE encrypt to DGR and ZGR, respectively.
    Both end with the same two letters (*GR*), revealing that both plaintexts share
    their last two letters as well. Finding these patterns shouldn’t be possible with
    a secure cipher.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 频率分析可以被抵消，如果维吉尼亚密码只加密与密钥长度相同的明文。但即便如此，还有另一个问题：多次重复使用相同的密钥会暴露明文之间的相似性。例如，使用密钥
    KYN，单词 TIE 和 PIE 会分别加密为 DGR 和 ZGR。两者都以相同的两个字母（*GR*）结尾，揭示了两个明文的最后两个字母是相同的。用安全的密码，这种发现不应该是可能的。
- en: To build a secure cipher, you must combine a secure permutation with a secure
    mode. Ideally, this combination prevents attackers from learning anything about
    a message other than its length.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个安全的密码，你必须将一个安全的置换与一个安全的模式相结合。理想情况下，这种组合可以防止攻击者了解信息的任何内容，除了其长度之外。
- en: '*Why Classical Ciphers Are Insecure*'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为什么经典密码不安全*'
- en: Classical ciphers are doomed to be insecure because they’re limited to operations
    you can do in your head or on a piece of paper. They lack the computational power
    of a computer and are easily broken by simple computer programs. Let’s see the
    fundamental reason why that simplicity makes them insecure in today’s world.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 经典密码注定不安全，因为它们仅限于你可以在脑海中或在纸上完成的操作。它们缺乏计算机的计算能力，且很容易被简单的计算机程序破解。让我们来看看为什么这种简单性会在今天的世界中使它们不安全的根本原因。
- en: 'Remember that a cipher’s permutation should look random in order to be secure.
    Of course, the best way to look random is to *be* random—that is, to select every
    permutation randomly from the set of all permutations. And there are many permutations
    to choose from. In the case of the 26-letter English alphabet, there are approximately
    2^(88) permutations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个密码的置换应该看起来是随机的，以保证安全。当然，最好的“看起来”随机的方式就是*真正*随机——也就是说，从所有置换的集合中随机选择每一个置换。并且有很多置换可以选择。在26个字母的英语字母表中，约有
    2^(88) 种置换：
- en: 26! = 403291461126605635584000000 ≈ 2^(88)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 26! = 403291461126605635584000000 ≈ 2^(88)
- en: 'Here, the exclamation point (!) is the factorial symbol, defined as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，感叹号 (!) 是阶乘符号，定义如下：
- en: '*n*! = *n* × (*n* − 1) × (*n* – 2) × … × 3 × 2'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*! = *n* × (*n* − 1) × (*n* – 2) × … × 3 × 2'
- en: '(To see why we end up with this number, count the permutations as lists of
    reordered letters: there are 26 choices for the first possible letter, then 25
    possibilities for the second, 24 for the third, and so on.) This number is huge:
    it’s of the same order of magnitude as the number of atoms in the human body.
    But classical ciphers can only use a small fraction of those permutations—namely,
    those that need only simple operations (such as shifts) and that have a short
    description (like a short algorithm or a small look-up table). The problem is
    that a secure permutation can’t accommodate both of these limitations.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: （要理解为什么我们得到这个数字，可以将置换视为字母重新排序的列表进行计数：第一个字母有 26 种选择，第二个字母有 25 种选择，第三个字母有 24 种选择，依此类推。）这个数字非常庞大：它的数量级与人体内原子的数量级相当。但经典的密码只能使用这些置换的一个小部分——即那些只需要简单操作（如移位）并且具有简短描述（如短算法或小型查找表）的置换。问题在于，一个安全的置换无法同时满足这两种限制。
- en: You can get secure permutations using simple operations by picking a random
    permutation, representing it as a table of 25 letters (enough to represent a permutation
    of 26 letters, with the 26th one missing), and applying it by looking up letters
    in this table. But then you wouldn’t have a short description. For example, it
    would take 250 letters to describe 10 different permutations, rather than just
    the 10 letters used in the Vigenère cipher.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单的操作来获得安全的置换，方法是选择一个随机的置换，将其表示为一个包含 25 个字母的表格（足够表示 26 个字母的置换，缺少第 26 个字母），然后通过查找该表格中的字母来应用它。但这样做就没有一个简短的描述。例如，描述
    10 种不同置换需要 250 个字母，而不仅仅是维吉尼亚密码中使用的 10 个字母。
- en: 'You can also produce secure permutations with a short description. Instead
    of just shifting the alphabet, you could use more complex operations such as addition,
    multiplication, and so on. That’s how modern ciphers work: given a key of typically
    128 or 256 bits, they perform hundreds of bit operations to encrypt a single letter.
    This process is fast on a computer that can do billions of bit operations per
    second, but it would take hours to do by hand, and would still be vulnerable to
    frequency analysis.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用简短的描述生成安全的置换。你可以不只是对字母表进行简单的移位，而是使用更复杂的操作，例如加法、乘法等。这就是现代密码学的工作原理：给定一个通常为
    128 或 256 位的密钥，它们执行数百次比特操作来加密单个字母。在每秒能执行数十亿次比特操作的计算机上，这个过程非常迅速，但如果手动进行，则需要数小时，而且仍然容易受到频率分析的攻击。
- en: 'Perfect Encryption: The One-Time Pad'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完美加密：一次性密码本
- en: 'Essentially, a classical cipher can’t be secure unless it comes with a huge
    key, but encrypting with a huge key is impractical. However, the one-time pad
    is such a cipher, and it is the most secure cipher. In fact, it guarantees *perfect
    secrecy*: even if an attacker has unlimited computing power, it’s impossible to
    learn anything about the plaintext except for its length.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，经典的密码学方法如果没有一个巨大的密钥，是无法保证安全的，但用一个巨大的密钥进行加密是不切实际的。然而，一次性密码本就是这样一种密码，它是最安全的密码。事实上，它保证了*完美的保密性*：即使攻击者拥有无限的计算能力，也不可能通过密文得知明文的任何信息，除了它的长度。
- en: In the next sections, I’ll show you how a one-time pad works and then offer
    a sketch of its security proof.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将向你展示一次性密码本是如何工作的，并提供其安全性证明的概述。
- en: '*Encrypting with the One-Time Pad*'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*使用一次性密码本进行加密*'
- en: The one-time pad takes a plaintext, *P*, and a random key, *K*, that’s the same
    length as *P* and produces a ciphertext *C*, defined as
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本将明文 *P* 和与 *P* 长度相同的随机密钥 *K* 作为输入，生成密文 *C*，定义为
- en: '*C* = *P* ⊕ *K*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* = *P* ⊕ *K*'
- en: where *C*, *P*, and *K* are bit strings of the same length and where ⊕ is the
    bitwise exclusive OR operation (XOR), defined as 0 ⊕ 0 = 0, 0 ⊕ 1 = 1, 1 ⊕ 0 =
    1, 1 ⊕ 1 = 0.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *C*、*P* 和 *K* 是相同长度的比特串，而 ⊕ 是按位异或操作（XOR），定义为 0 ⊕ 0 = 0, 0 ⊕ 1 = 1, 1 ⊕ 0
    = 1, 1 ⊕ 1 = 0。
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’m presenting the one-time pad in its usual form, as working on bits, but
    it can be adapted to other symbols. With letters, for example, you would end up
    with a variant of the Caesar cipher with a shift index picked at random for each
    letter.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*我正在以通常的形式展示一次性密码本，即按比特工作，但它也可以适配到其他符号上。例如，对于字母，你将得到一种变体的凯撒密码，其中每个字母的移位索引是随机选择的。*'
- en: 'The one-time pad’s decryption is identical to encryption; it’s just an XOR:
    *P* = *C* ⊕ *K*. Indeed, we can verify *C* ⊕ *K* = *P* ⊕ *K* ⊕ *K* = *P* because
    XORing *K* with itself gives the all-zero string 000 … 000\. That’s it—even simpler
    than the Caesar cipher.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本的解密与加密相同；它只是一个异或操作：*P* = *C* ⊕ *K*。事实上，我们可以验证 *C* ⊕ *K* = *P* ⊕ *K* ⊕
    *K* = *P*，因为将 *K* 与自身进行异或操作会得到全零字符串 000 … 000。就是这样——比凯撒密码还简单。
- en: 'For example, if *P* = 01101101 and *K* = 10110100, then we can calculate the
    following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果*P* = 01101101且*K* = 10110100，则我们可以计算出以下内容：
- en: '*C* = *P* ⊕ *K* = 01101101 ⊕ 10110100 = 11011001'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* = *P* ⊕ *K* = 01101101 ⊕ 10110100 = 11011001'
- en: 'Decryption retrieves *P* by computing the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 解密过程通过计算以下内容来恢复*P*：
- en: '*P* = *C* ⊕ *K* = 11011001 ⊕ 10110100 = 01101101'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* = *C* ⊕ *K* = 11011001 ⊕ 10110100 = 01101101'
- en: 'The important thing is that a one-time pad can only be used *one time*: each
    key *K* should be used only once. If the same *K* is used to encrypt *P*[1] and
    *P*[2] to *C*[1] and *C*[2], then an eavesdropper can compute the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，一次性密码本只能使用*一次*：每个密钥*K*应该只使用一次。如果同一个*K*被用来加密*P*[1]和*P*[2]，从而生成*C*[1]和*C*[2]，那么窃听者可以计算出以下内容：
- en: '*C*[1] ⊕ *C*[2] = (*P*[1] ⊕ *K*) ⊕ (*P*[2] ⊕ *K*) = *P*[1] ⊕ *P*[2] ⊕ *K* ⊕
    *K* = *P*[1] ⊕ *P*[2]'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[1] ⊕ *C*[2] = (*P*[1] ⊕ *K*) ⊕ (*P*[2] ⊕ *K*) = *P*[1] ⊕ *P*[2] ⊕ *K* ⊕
    *K* = *P*[1] ⊕ *P*[2]'
- en: An eavesdropper would thus learn the XOR difference of *P*[1] and *P*[2], information
    that should be kept secret. Moreover, if either plaintext message is known, then
    the other message can be recovered.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，窃听者将会得知*P*[1]和*P*[2]之间的异或差异，而这应该是保密的信息。此外，如果其中一个明文消息已知，则可以恢复另一个消息。
- en: Of course, the one-time pad is utterly inconvenient to use because it requires
    a key as long as the plaintext and a new random key for each new message or group
    of data. To encrypt a one-terabyte hard drive, you’d need another one-terabyte
    drive to store the key! Nonetheless, the one-time pad has been used throughout
    history. For example, it was used by the British Special Operations Executive
    during WWII, by KGB spies, by the NSA, and is still used today in specific contexts.
    (I’ve heard of Swiss bankers who couldn’t agree on a cipher trusted by both parties
    and ended up using one-time pads, but I don’t recommend doing this.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一次性密码本在使用上极为不便，因为它要求密钥与明文一样长，并且每条新消息或每组数据都需要一个新的随机密钥。要加密一个一TB的硬盘，你还需要另一个一TB的硬盘来存储密钥！尽管如此，一次性密码本在历史上确实被使用过。例如，二战期间，英国特别行动处、KGB间谍、NSA都使用过一次性密码本，至今在某些特定的场景下仍然使用。（我听说过一些瑞士银行家，由于无法就双方都信任的密码达成一致，最终使用了一次性密码本，但我不推荐这么做。）
- en: '*Why Is the One-Time Pad Secure?*'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为什么一次性密码本是安全的？*'
- en: Although the one-time pad is not practical, it’s important to understand what
    makes it secure. In the 1940s, American mathematician Claude Shannon proved that
    the one-time pad’s key must be at least as long as the message to achieve perfect
    secrecy. The proof’s idea is fairly simple. You assume that the attacker has unlimited
    power, and thus can try all the keys. The goal is to encrypt such that the attacker
    can’t rule out any possible plaintext given some ciphertext.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一次性密码本并不实用，但理解其安全性原理仍然很重要。在1940年代，美国数学家克劳德·香农证明了一次性密码本的密钥必须至少与消息一样长，才能实现完美的保密性。该证明的思路相当简单。你假设攻击者拥有无限的计算能力，因此可以尝试所有的密钥。目标是加密使得攻击者在给定某些密文的情况下，无法排除任何可能的明文。
- en: 'The intuition behind the one-time pad’s perfect secrecy goes as follows: if
    *K* is random, the resulting *C* looks as random as *K* to an attacker because
    the XOR of a random string with any fixed string yields a random string. To see
    this, consider the probability of getting 0 as the first bit of a random string
    (namely, a probability of 1/2). What’s the probability that a random bit XORed
    with the second bit is 0? Right, 1/2 again. The same argument can be iterated
    over bit strings of any length. The ciphertext *C* thus looks random to an attacker
    that doesn’t know *K*, so it’s literally impossible to learn anything about *P*
    given *C*, even for an attacker with unlimited time and power. In other words,
    knowing the ciphertext gives no information whatsoever about the plaintext except
    its length—pretty much the definition of a secure cipher.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本的完美保密性的直觉可以这样理解：如果*K*是随机的，那么对攻击者来说，得到的*C*看起来和*K*一样随机，因为随机字符串与任何固定字符串进行异或运算得到的结果是随机的。为了验证这一点，考虑一下得到随机字符串的第一个比特为0的概率（即1/2的概率）。那么一个随机比特与第二个比特进行异或得到0的概率是多少？对，还是1/2。相同的推理可以对任意长度的比特字符串进行迭代。因此，密文*C*对于一个不知道*K*的攻击者来说看起来是随机的，所以即使攻击者拥有无限的时间和能力，也不可能从*C*中了解任何关于*P*的信息。换句话说，知道密文不会提供任何关于明文的信息，除了它的长度——这几乎就是安全密码的定义。
- en: For example, if a ciphertext is 128 bits long (meaning the plaintext is 128
    bits as well), there are 2^(128) possible ciphertexts; therefore, there should
    be 2^(128) possible plaintexts from the attacker’s point of view. But if there
    are fewer than 2^(128) possible keys, the attacker can rule out some plaintexts.
    If the key is only 64 bits, for example, the attacker can determine the 2^(64)
    possible plaintexts and rule out the overwhelming majority of 128-bit strings.
    The attacker wouldn’t learn what the plaintext is, but they would learn what the
    plaintext is not, which makes the encryption’s secrecy imperfect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果密文是128位长（意味着明文也是128位），那么有2^(128)种可能的密文；因此，从攻击者的角度来看，应该有2^(128)种可能的明文。但如果可能的密钥少于2^(128)，攻击者就可以排除一些明文。如果密钥只有64位，例如，攻击者可以确定2^(64)种可能的明文并排除掉绝大多数128位的字符串。攻击者虽然无法知道明文是什么，但他们可以知道明文不是什么，这使得加密的保密性不完美。
- en: As you can see, you must have a key as long as the plaintext to achieve perfect
    security, but this quickly becomes impractical for real-world use. Next, I’ll
    discuss the approaches taken in modern-day encryption to achieve the best security
    that’s both possible and practical.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，要实现完美的安全性，你必须拥有与明文长度相等的密钥，但这对于实际应用来说很快就变得不切实际。接下来，我将讨论现代加密中为实现既可能又实用的最佳安全性所采取的方法。
- en: PROBABILITY IN CRYPTOGRAPHY
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学中的概率
- en: A *probability* is a number that expresses the likelihood, or chance, of some
    event happening. It’s expressed as a number between 0 and 1, where 0 means “never”
    and 1 means “always.” The higher the probability, the greater the chance. You’ll
    find many explanations of probability, usually in terms of white balls and red
    balls in a bag and the probability of picking a ball of either color.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*概率*是一个数字，用来表示某个事件发生的可能性或机会。它的值在0和1之间，其中0表示“永不发生”，而1表示“总是发生”。概率越高，机会越大。你会看到很多关于概率的解释，通常是用袋子里的白球和红球，以及抽取任意颜色球的概率来描述。'
- en: Cryptography often uses probabilities to measure an attack’s chances of success,
    by 1) counting the number of successful events (for example, the event “find the
    one correct secret key”) and 2) counting the total number of possible events (for
    example, the total number of keys is 2^(*n*) if we deal with *n*-bit keys). In
    this example, the probability that a randomly chosen key is the correct one is
    1/2^(*n*), or the count of successful events (1 secret key) and the count of possible
    events (2^(*n*) possible keys). The number 1/2^(*n*) is negligibly small for common
    key lengths such as 128 and 256.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学通常使用概率来衡量攻击成功的机会，方法是：1) 计算成功事件的数量（例如，事件“找到唯一正确的秘密密钥”）；2) 计算所有可能事件的总数（例如，如果我们使用*n*位密钥，则所有可能的密钥总数为2^(*n*)）。在这个例子中，随机选择一个密钥是正确的概率为1/2^(*n*)，即成功事件的数量（1个秘密密钥）与所有可能事件的数量（2^(*n*)个可能密钥）之比。对于常见的密钥长度如128位和256位来说，1/2^(*n*)的数字非常小，可以忽略不计。
- en: The probability of an event *not happening* is 1 – *p*, if the event’s probability
    is *p*. The probability of getting a wrong key in our previous example is therefore
    1 – 1/2^(*n*), a number very close to 1, meaning almost certainty.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件的概率是*p*，那么该事件*不发生*的概率为1 – *p*。因此，在我们之前的例子中，得到错误密钥的概率是1 – 1/2^(*n*)，这是一个非常接近1的数字，意味着几乎确定。
- en: Encryption Security
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密安全
- en: You’ve seen that classical ciphers aren’t secure and that a perfectly secure
    cipher like the one-time pad is impractical. We’ll thus have to give a little
    in terms of security if we want secure *and* usable ciphers. But what does “secure”
    really mean, besides the obvious and informal “eavesdroppers can’t decrypt secure
    messages”?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道经典的加密算法并不安全，而像一次性密码本这样的完全安全的加密算法则不实际。因此，如果我们想要既安全又可用的加密算法，就不得不在安全性上做一些妥协。但是，“安全”到底意味着什么呢？除了显而易见且非正式的“窃听者无法解密安全信息”之外，还有什么含义？
- en: 'Intuitively, a cipher is secure if, even given a large number of plaintext–ciphertext
    pairs, *nothing can be learned* about the cipher’s behavior when applied to other
    plaintexts or ciphertexts. This opens up new questions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 直观来说，如果即使在拥有大量明文–密文对的情况下，*也无法得出任何关于密码行为的信息*，那么该密码就是安全的。这引出了新的问题：
- en: How does an attacker come by these pairs? How large is a “large number”? This
    is all defined by *attack models*, assumptions about what the attacker can and
    cannot do.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者是如何获得这些对的？什么算是“大量”？这一切都由*攻击模型*来定义，即关于攻击者能够做什么和不能做什么的假设。
- en: What could be “learned” and what “cipher’s behavior” are we talking about? This
    is defined by *security goals*, descriptions of what is considered a successful
    attack.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论的“学习内容”和“密码行为”是什么？这是由*安全目标*定义的，描述了什么是成功的攻击。
- en: Attack models and security goals must go together; you can’t claim that a system
    is secure without explaining against whom or from what it’s safe. A *security
    notion* is thus the combination of some security goal with some attack model.
    We’ll say that a cipher *achieves* a certain security notion if any attacker working
    in a given model can’t achieve the security goal.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击模型和安全目标必须结合在一起；你不能在没有解释对谁或从什么方面安全的情况下声称系统是安全的。*安全概念*因此是某个安全目标与某个攻击模型的结合。如果在给定的模型中，任何攻击者都无法达到安全目标，我们就说一个密码*实现了*某种安全概念。
- en: '*Attack Models*'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*攻击模型*'
- en: 'An attack model is a set of assumptions about how attackers might interact
    with a cipher and what they can and can’t do. The goals of an attack model are
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击模型是一组关于攻击者如何与密码交互以及他们能做什么和不能做什么的假设。攻击模型的目标如下：
- en: To set requirements for cryptographers who design ciphers, so that they know
    what attackers and what kinds of attacks to protect against.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为设计密码的密码学家设定要求，使他们知道需要防范哪些攻击者和哪些类型的攻击。
- en: To give guidelines to users, about whether a cipher will be safe to use in their
    environment.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户提供指导，帮助他们判断密码在其环境中是否安全可用。
- en: To provide clues for cryptanalysts who attempt to break ciphers, so they know
    whether a given attack is valid. An attack is only valid if it’s doable in the
    model considered.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为试图破解密码的密码分析人员提供线索，让他们知道某个攻击是否有效。只有当某个攻击在考虑的模型中是可行的，才能称之为有效攻击。
- en: Attack models don’t need to match reality exactly; they’re an approximation.
    As the statistician George E. P. Box put it, “all models are wrong; the practical
    question is how wrong do they have to be to not be useful.” To be useful in cryptography,
    attack models should at least encompass what attackers can actually do to attack
    a cipher. It’s okay and a good thing if a model overestimates attackers’ capabilities,
    because it helps anticipate future attack techniques—only the paranoid cryptographers
    survive. A bad model underestimates attackers and provides false confidence in
    a cipher by making it seem secure in theory when it’s not secure in reality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击模型不需要完全符合现实；它们是近似的。正如统计学家乔治·E·P·博克斯所说：“所有模型都是错误的；实际的问题是它们必须错误到什么程度才不再有用。”
    在密码学中，为了有用，攻击模型至少应涵盖攻击者能够做的事情来攻击密码。如果一个模型高估了攻击者的能力，那是可以接受的，也是件好事，因为它有助于预测未来的攻击技术——只有偏执的密码学家才能生存。一个不好的模型低估了攻击者的能力，通过让密码在理论上看似安全，实则在现实中并不安全，从而提供了错误的信心。
- en: Kerckhoffs’s Principle
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 克尔霍夫原则
- en: 'One assumption made in all models is the so-called *Kerckhoffs’s principle*,
    which states that the security of a cipher should rely only on the secrecy of
    the key and not on the secrecy of the cipher. This may sound obvious today, when
    ciphers and protocols are publicly specified and used by everyone. But historically,
    Dutch linguist Auguste Kerckhoffs was referring to military encryption machines
    specifically designed for a given army or division. Quoting from his 1883 essay
    “La Cryptographie Militaire,” where he listed six requirements of a military encryption
    system: “The system must not require secrecy and can be stolen by the enemy without
    causing trouble.”'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模型中都做出一个假设，即所谓的*克尔霍夫原则*，该原则指出，密码的安全性应仅依赖于密钥的保密性，而不依赖于密码本身的保密性。今天，这听起来可能很显然，因为密码和协议都是公开指定并被大家使用的。但是从历史上看，荷兰语言学家奥古斯特·克尔霍夫指的是专为某个军队或军区设计的军事加密机器。引用他在1883年发表的《军事密码学》一文中的话，其中列出了军事加密系统的六项要求：“系统不应要求保密，并且可以被敌人窃取而不会造成问题。”
- en: Black-Box Models
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 黑盒模型
- en: Let’s now consider some useful attack models expressed in terms of what the
    attacker can observe and what queries they can make to the cipher. A *query* for
    our purposes is the operation that sends an input value to some function and gets
    the output in return, without exposing the details of that function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一些有用的攻击模型，这些模型通过攻击者能观察到的内容和他们能对密码做出的查询来表达。对于我们的目的，*查询*是指将输入值传送给某个函数并返回输出的操作，而不暴露该函数的细节。
- en: An *encryption query*, for example, takes a plaintext and returns a corresponding
    ciphertext, without revealing the secret key.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，一个*加密查询*接受明文并返回相应的密文，而不泄露密钥。
- en: We call these models *black-box models*, because the attacker only sees what
    goes in and out of the cipher. For example, some smart card chips securely protect
    a cipher’s internals as well as its keys, yet you’re allowed to connect to the
    chip and ask it to decrypt any ciphertext. The attacker would then receive the
    corresponding plaintext, which may help them determine the key. That’s a real
    example where *decryption queries* are possible.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这些模型为*黑盒模型*，因为攻击者只能看到加密过程的输入和输出。例如，一些智能卡芯片安全地保护加密器的内部结构以及其密钥，但你可以连接到芯片并请求它解密任何密文。攻击者随后会收到相应的明文，这可能帮助他们确定密钥。这是一个现实的例子，其中*解密查询*是可能的。
- en: 'There are several different black-box attack models. Here, I list them in order
    from weakest to strongest, describing attackers’ capabilities for each model:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的黑盒攻击模型。在这里，我按从最弱到最强的顺序列出了它们，并描述了每种模型中攻击者的能力：
- en: '*Ciphertext-only attackers (COA)* observe ciphertexts but don’t know the associated
    plaintexts, and don’t know how the plaintexts were selected. Attackers in the
    COA model are passive and can’t perform encryption or decryption queries.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密文-only攻击者（COA）* 观察密文，但不知道关联的明文，也不知道这些明文是如何被选择的。COA模型中的攻击者是被动的，不能执行加密或解密查询。'
- en: '*Known-plaintext attackers (KPA)* observe ciphertexts and do know the associated
    plaintexts. Attackers in the KPA model thus get a list of plaintext–ciphertext
    pairs, where plaintexts are assumed to be randomly selected. Again, KPA is a passive
    attacker model.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*已知明文攻击者（KPA）* 观察密文并知道关联的明文。KPA模型中的攻击者因此得到明文-密文对的列表，假设明文是随机选择的。再一次，KPA是一个被动攻击者模型。'
- en: '*Chosen-plaintext attackers (CPA)* can perform encryption queries for plaintexts
    of their choice and observe the resulting ciphertexts. This model captures situations
    where attackers can choose all or part of the plaintexts that are encrypted and
    then get to see the ciphertexts. Unlike COA or KPA, which are passive models,
    CPA are *active* attackers, because they influence the encryption processes rather
    than passively eavesdropping.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择明文攻击者（CPA）* 可以对自己选择的明文进行加密查询，并观察结果的密文。这个模型描述了攻击者可以选择全部或部分被加密的明文，并查看相应的密文的情形。与COA或KPA这种被动模型不同，CPA是*主动*攻击者，因为他们影响加密过程，而不是被动地窃听。'
- en: '*Chosen-ciphertext attackers (CCA)* can both encrypt and decrypt; that is,
    they get to perform encryption queries and decryption queries. The CCA model may
    sound ludicrous at first—if you can decrypt, what else do you need?—but like the
    CPA model, it aims to represent situations where attackers can have some influence
    on the ciphertext and later get access to the plaintext. Moreover, decrypting
    something is not always enough to break a system. For example, some video-protection
    devices allow attackers to perform encryption queries and decryption queries using
    the device’s chip, but in that context attackers are interested in the key in
    order to redistribute it; in this case, being able to decrypt “for free” isn’t
    sufficient to break the system.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择密文攻击者（CCA）* 可以同时执行加密和解密；也就是说，他们能够执行加密查询和解密查询。CCA模型一开始可能听起来很荒谬——如果你能解密，还需要什么？——但和CPA模型一样，它旨在表示攻击者可以对密文产生一定影响并后来获得明文的情形。而且，解密某个内容并不总是足够打破一个系统。例如，一些视频保护设备允许攻击者使用设备的芯片执行加密查询和解密查询，但在这种情况下，攻击者关注的是密钥以便重新分发；在这种情况下，能够“免费”解密并不足以破坏系统。'
- en: In the preceding models, ciphertexts that are observed as well as queried don’t
    come for free. Each ciphertext comes from the computation of the encryption function.
    This means that generating 2^(*n*) plaintext–ciphertext pairs through encryption
    queries takes about as much computation as trying 2^(*n*) keys, for example. The
    cost of queries should be taken into account when you’re computing the cost of
    an attack.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述模型中，观察到并查询的密文并不是免费的。每个密文都来自加密函数的计算。这意味着，通过加密查询生成2^(*n*)明文-密文对所需的计算量大致等同于尝试2^(*n*)个密钥的计算量。例如，在计算攻击成本时，应考虑查询的成本。
- en: Gray-Box Models
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 灰盒模型
- en: In a *gray-box model*, the attacker has access to a cipher’s *i**mplementation*.
    This makes gray-box models more realistic than black-box models for applications
    such as smart cards, embedded systems, and virtualized systems, to which attackers
    often have physical access and can thus tamper with the algorithms’ internals.
    By the same token, gray-box models are more difficult to define than black-box
    ones because they depend on physical, analog properties rather than just on an
    algorithm’s input and outputs, and crypto theory will often fail to abstract the
    complexity of the real world.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在*灰盒模型*中，攻击者可以访问密码的*实现*。这使得灰盒模型比黑盒模型更符合实际应用，例如智能卡、嵌入式系统和虚拟化系统，因为攻击者通常可以物理接触这些系统，从而篡改算法的内部结构。与此同时，灰盒模型比黑盒模型更难定义，因为它们依赖于物理和模拟属性，而不仅仅是算法的输入和输出，密码理论往往无法抽象出现实世界的复杂性。
- en: S*ide-channel attacks* are a family of attacks within gray-box models. A side
    channel is a source of information that depends on the implementation of the cipher,
    be it in software or hardware. Side-channel attackers observe or measure analog
    characteristics of a cipher’s implementation but don’t alter its integrity; they
    are *noninvasive*. For pure software implementations, typical side channels are
    the execution time and the behavior of the system that surrounds the cipher, such
    as error messages, return values, branches, and so on. In the case of implementations
    on smart cards, for example, typical side-channel attackers measure power consumption,
    electromagnetic emanations, or acoustic noise.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*侧信道攻击*是一类存在于灰盒模型中的攻击。侧信道是一个依赖于密码实现的、无论是软件还是硬件，的信息源。侧信道攻击者观察或测量密码实现的模拟特征，但不会改变其完整性；他们是*非侵入性的*。对于纯软件实现，典型的侧信道包括执行时间和围绕密码的系统行为，如错误消息、返回值、分支等。例如，在智能卡的实现中，典型的侧信道攻击者会测量功耗、电磁辐射或声学噪声。'
- en: '*Invasive* *attacks* are a family of attacks on cipher implementations that
    are more powerful than side-channel attacks, and more expensive because they require
    sophisticated equipment. You can run basic side-channel attacks with a standard
    PC and an off-the-shelf oscilloscope, but invasive attacks require tools such
    as a high-resolution microscopes and a chemical lab. Invasive attacks thus consist
    of a whole set of techniques and procedures, from using nitric acid to remove
    a chip’s packaging to microscopic imagery acquisition, partial reverse engineering,
    and possible modification of the chip’s behavior with something like laser fault
    injection.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*侵入性* *攻击*是一类比侧信道攻击更强大的攻击方式，并且更为昂贵，因为它们需要复杂的设备。你可以使用标准PC和市场上的示波器进行基本的侧信道攻击，但侵入性攻击则需要诸如高分辨率显微镜和化学实验室之类的工具。因此，侵入性攻击包括一整套技术和程序，从使用硝酸去除芯片包装到显微成像获取、部分逆向工程以及可能通过激光故障注入等方式修改芯片行为。'
- en: '*Security Goals*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安全目标*'
- en: 'I’ve informally defined the goal of security as “nothing can be learned about
    the cipher’s behavior.” To turn this idea into a rigorous mathematical definition,
    cryptographers define two main security goals that correspond to different ideas
    of what it means to learn something about a cipher’s behavior:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我非正式地将安全目标定义为“无法从密码的行为中学到任何东西。”为了将这个想法转化为严格的数学定义，密码学家定义了两个主要的安全目标，分别对应于对“了解密码行为”的不同理解：
- en: '**Indistinguishability (IND)** Ciphertexts should be indistinguishable from
    random strings. This is usually illustrated with this hypothetical game: if an
    attacker picks two plaintexts and then receives a ciphertext of one of the two
    (chosen at random), they shouldn’t be able to tell which plaintext was encrypted,
    even by performing encryption queries with the two plaintexts (and decryption
    queries, if the model is CCA rather than CPA).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可区分性（IND）** 密文应当与随机字符串不可区分。通常通过以下假设游戏来说明这一点：如果攻击者选择了两个明文，然后随机收到其中一个明文加密后的密文，他们不应能判断出哪个明文被加密，即使通过使用这两个明文进行加密查询（如果模型是CCA而非CPA，还可以进行解密查询）。'
- en: '**Non-malleability (NM)** Given a ciphertext *C*[1] = **E**(*K*, *P*[1]), it
    should be impossible to create another ciphertext, *C*[2], whose corresponding
    plaintext, *P*[2], is related to *P*[1] in a meaningful way (for example, to create
    a *P*[2] that is equal to *P*[1] ⊕ 1 or to *P*[1] ⊕ *X* for some known value *X*).
    Surprisingly, the one-time pad is malleable: given a ciphertext *C*[1] = *P*[1]
    ⊕ *K*, you can define *C*[2] = *C*[1] ⊕ 1, which is a valid ciphertext of *P*[2]
    = *P*[1] ⊕ 1 under the same key *K*. Oops, so much for our perfect cipher.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可篡改性 (NM)** 给定密文*C*[1] = **E**(*K*, *P*[1])，应该不可能创建另一个密文*C*[2]，其对应的明文*P*[2]与*P*[1]在某种意义上相关（例如，创建一个*P*[2]，使得*P*[2]
    = *P*[1] ⊕ 1，或者*P*[2] = *P*[1] ⊕ *X*，其中*X*是某个已知的值）。令人惊讶的是，一次性密码本是可篡改的：给定密文*C*[1]
    = *P*[1] ⊕ *K*，你可以定义*C*[2] = *C*[1] ⊕ 1，这实际上是密文*P*[2] = *P*[1] ⊕ 1在相同密钥*K*下的有效密文。哎呀，这就是我们完美密码的缺陷。'
- en: Next, I’ll discuss these security goals in the context of different attack models.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将讨论在不同攻击模型下的安全目标。
- en: '*Security Notions*'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安全概念*'
- en: Security goals are only useful when combined with an attack model. The convention
    is to write a security notion as *GOAL*-*MODEL*. For example, IND-CPA denotes
    indistinguishability against chosen-plaintext attackers, NM-CCA denotes nonmalleability
    against chosen-ciphertext attackers, and so on. Let’s start with the security
    goals for an attacker.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 安全目标只有与攻击模型结合使用时才有意义。约定是将安全概念写作*目标*-*模型*。例如，IND-CPA表示对选择明文攻击者的不可区分性，NM-CCA表示对选择密文攻击者的不可篡改性，等等。让我们从攻击者的安全目标开始。
- en: 'Semantic Security and Randomized Encryption: IND-CPA'
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 语义安全和随机加密：IND-CPA
- en: The most important security notion is IND-CPA, also called *semantic* *security*.
    It captures the intuition that ciphertexts shouldn’t leak any information about
    plaintexts as long as the key is secret. To achieve IND-CPA security, encryption
    must return different ciphertexts if called twice on the same plaintext; otherwise,
    an attacker could identify duplicate plaintexts from their ciphertexts, contradicting
    the definition that ciphertexts shouldn’t reveal any information.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的安全概念是IND-CPA，也叫做*语义* *安全性*。它传达的直觉是，只要密钥保密，密文不应泄露任何关于明文的信息。为了实现IND-CPA安全性，加密必须在对同一明文进行两次加密时返回不同的密文；否则，攻击者可能会通过密文识别重复的明文，从而与密文不应泄露任何信息的定义相矛盾。
- en: One way to achieve IND-CPA security is to use *randomized encryption*. As the
    name suggests, it randomizes the encryption process and returns different ciphertexts
    when the same plaintext is encrypted twice. Encryption can then be expressed as
    *C* = **E**(*K*, *R*, *P*), where *R* is fresh random bits. Decryption remains
    deterministic, however, because given **E**(*K*, *R*, *P*), you should always
    get *P*, regardless of the value of *R*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实现IND-CPA安全性的一种方法是使用*随机加密*。顾名思义，它使加密过程具有随机性，并在对同一明文进行两次加密时返回不同的密文。加密可以表示为*C*
    = **E**(*K*, *R*, *P*)，其中*R*是新生成的随机位。然而，解密仍然是确定性的，因为给定**E**(*K*, *R*, *P*)，无论*R*的值是什么，你都应该始终得到*P*。
- en: What if encryption isn’t randomized? In the IND game introduced in [“Security
    Goals”](ch01.xhtml#lev2sec13) on page 12, the attacker picks two plaintexts, *P*[1]
    and *P*[2], and receives a ciphertext of one of the two, but doesn’t know which
    plaintext the ciphertext corresponds to. That is, they get *C*[*i*] = **E**(*K*,
    *P*[*i*]) and have to guess whether *i* is 1 or 2\. In the CPA model, the attacker
    can perform encryption queries to determine both *C*[1] = **E**(*K*, *P*[1]) and
    *C*[2] = **E**(*K*, *P*[2]). If encryption isn’t randomized, it suffices to see
    if *C*[*i*] is equal to *C*[1] or to *C*[2] in order to determine which plaintext
    was encrypted and thereby win the IND game. Therefore, randomization is key to
    the IND-CPA notion.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加密不是随机的呢？在[《安全目标》](ch01.xhtml#lev2sec13)中引入的IND游戏中，攻击者选择两个明文，*P*[1]和*P*[2]，并收到其中一个的密文，但不知道密文对应的是哪个明文。也就是说，他们得到*C*[*i*]
    = **E**(*K*, *P*[*i*])，并且必须猜测*i*是1还是2。在CPA模型中，攻击者可以执行加密查询，确定*C*[1] = **E**(*K*,
    *P*[1])和*C*[2] = **E**(*K*, *P*[2])。如果加密不是随机的，攻击者只需查看*C*[*i*]是否等于*C*[1]或*C*[2]，即可判断加密的是哪个明文，从而赢得IND游戏。因此，随机化是IND-CPA概念的关键。
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*With randomized encryption, ciphertexts must be slightly longer than plaintexts
    in order to allow for more than one possible ciphertext per plaintext. For example,
    if there are 2^(64) possible ciphertexts per plaintext, ciphertexts must be at
    least 64 bits longer than plaintexts.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于随机加密，密文必须比明文稍长，以便每个明文有多个可能的密文。例如，如果每个明文有 2^(64) 个可能的密文，那么密文必须至少比明文长 64 位。*'
- en: Achieving Semantically Secure Encryption
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现语义安全加密
- en: 'One of the simplest constructions of a semantically secure cipher uses a *deterministic
    random bit generator (DRBG)*, an algorithm that returns random-looking bits given
    some secret value:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一种最简单的语义安全密码构造方法使用了 *确定性随机位生成器（DRBG）*，这是一种根据某些秘密值返回看似随机位的算法：
- en: '*E*(*K*, *R*, *P*) = (**DRBG**(*K* || *R*) ⊕ *P*, *R*)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*(*K*, *R*, *P*) = (**DRBG**(*K* || *R*) ⊕ *P*, *R*)'
- en: 'Here, *R* is a string randomly chosen for each new encryption and given to
    a DRBG along with the key (*K* || *R* denotes the string consisting of *K* followed
    by *R*). This approach is reminiscent of the one-time pad: instead of picking
    a random key of the same length as the message, we leverage a random bit generator
    to get a random-looking string.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*R* 是为每个新加密随机选择的字符串，并与密钥一起提供给 DRBG（*K* || *R* 表示由 *K* 和 *R* 组成的字符串）。这种方法让人联想到一次性密码本：我们不是选择一个与消息长度相同的随机密钥，而是利用随机位生成器来获得一个看似随机的字符串。
- en: 'The proof that this cipher is IND-CPA secure is simple, if we assume that the
    DRBG produces random bits. The proof works ad absurdum: if you can distinguish
    ciphertexts from random strings, which means that you can distinguish **DRBG**(*K*
    || *R*) ⊕ *P* from random, then this means that you can distinguish **DRBG**(*K*
    || *R*) from random. Remember that the CPA model lets you get ciphertexts for
    chosen values of *P*, so you can XOR *P* to **DRBG**(*K*, *R*) ⊕ *P* and get **DRBG**(*K*,
    *R*). But now we have a contradiction, because we started by assuming that **DRBG**(*K*,
    *R*) can’t be distinguished from random, producing random strings. So we conclude
    that ciphertexts can’t be distinguished from random strings, and therefore that
    the cipher is secure.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 证明该密码是 IND-CPA 安全的过程很简单，前提是我们假设 DRBG 生成的是随机位。这个证明采用反证法：如果你能区分密文和随机字符串，也就是说，你能区分
    **DRBG**(*K* || *R*) ⊕ *P* 与随机字符串的区别，那么这就意味着你能区分 **DRBG**(*K* || *R*) 与随机字符串的区别。记住，CPA
    模型允许你获取选择的 *P* 值对应的密文，所以你可以将 *P* 与 **DRBG**(*K*, *R*) ⊕ *P* 做异或运算，得到 **DRBG**(*K*,
    *R*)。但是现在我们遇到矛盾，因为我们一开始假设 **DRBG**(*K*, *R*) 无法与随机字符串区分开来，从而生成随机字符串。所以我们得出结论，密文无法与随机字符串区分开来，因此该密码是安全的。
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As an exercise, try to determine what other security notions are satisfied
    by the above cipher **E***(**K**, **R**, **P**) = (***DRBG***(**K** || **R**)
    ⊕ **P**, **R**). *Is it NM-CPA? IND-CCA? You’ll find the answers in the next section.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为练习，试着确定上述密码 **E**(*K*, *R*, *P*) = (***DRBG**(*K* || *R*) ⊕ *P*, *R*) 满足哪些其他安全概念。*它是
    NM-CPA 吗？是 IND-CCA 吗？你将在下一节中找到答案。*'
- en: Comparing Security Notions
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比较安全概念
- en: You’ve learned that attack models such as CPA and CCA are combined with security
    goals such as NM and IND to build the security notions NM-CPA, NM-CCA, IND-CPA,
    and IND-CCA. How are these notions related? Can we prove that satisfying notion
    X implies satisfying notion Y?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，攻击模型如 CPA 和 CCA 与安全目标如 NM 和 IND 结合，构建了安全概念 NM-CPA、NM-CCA、IND-CPA 和 IND-CCA。这些概念是如何关联的？我们能否证明满足概念
    X 就意味着满足概念 Y？
- en: 'Some relations are obvious: IND-CCA implies IND-CPA, and NM-CCA implies NM-CPA,
    because anything a CPA attacker can do, a CCA attacker can do as well. That is,
    if you can’t break a cipher by performing chosen-ciphertext and chosen-plaintext
    queries, you can’t break it by performing chosen-plaintext queries only.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关系是显而易见的：IND-CCA 蕴含 IND-CPA，NM-CCA 蕴含 NM-CPA，因为 CPA 攻击者能做的事情，CCA 攻击者也能做。也就是说，如果你不能通过执行选择密文和选择明文查询来破解一个密码，那么你也不能仅通过执行选择明文查询来破解它。
- en: 'A less obvious relation is that IND-CPA does not imply NM-CPA. To understand
    this, observe that the previous IND-CPA construction (**DRBG**(*K* || *R*) ⊕ *P*,
    *R*) is not NM-CPA: given a ciphertext (*X*, *R*), you can create the ciphertext
    (*X* ⊕ 1, *R*), which is a valid ciphertext of *P* ⊕ 1, thus contradicting the
    notion of non-malleability.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太显而易见的关系是，IND-CPA 并不蕴含 NM-CPA。为了理解这一点，可以观察到之前的 IND-CPA 构造（**DRBG**(*K* ||
    *R*) ⊕ *P*, *R*）并不是 NM-CPA：给定一个密文 (*X*, *R*)，你可以创建密文 (*X* ⊕ 1, *R*)，这就是 *P* ⊕
    1 的有效密文，从而与不可篡改性的概念相矛盾。
- en: 'But the opposite relation does hold: NM-CPA implies IND-CPA. The intuition
    is that IND-CPA encryption is like putting items in a bag: you don’t get to see
    them, but you can rearrange their positions in the bag by shaking it up and down.
    NM-CPA is more like a safe: once inside, you can’t interact with what you put
    in there. But this analogy doesn’t work for IND-CCA and NM-CCA, which are equivalent
    notions that each imply the presence of the other. I’ll spare you the proof, which
    is pretty technical.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，相反的关系是成立的：NM-CPA蕴含IND-CPA。直觉上，IND-CPA加密就像把物品放进一个袋子里：你看不见它们，但可以通过上下摇动袋子来重新排列它们的位置。NM-CPA更像一个保险箱：一旦放入，你就无法与里面的物品互动。但这种类比不适用于IND-CCA和NM-CCA，它们是等价的概念，每个都蕴含另一个。我就不赘述证明过程了，那个非常技术性。
- en: TWO TYPES OF ENCRYPTION APPLICATIONS
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的加密应用
- en: 'There are two main types of encryption applications. *In-transit* encryption
    protects data sent from one machine to another: data is encrypted before being
    sent and decrypted after being received, as in encrypted connections to e-commerce
    websites. *At-rest encryption* protects data stored on an information system.
    Data is encrypted before being written to memory and decrypted before being read.
    Examples include disk encryption systems on laptops as well as virtual machine
    encryption for cloud virtual instances. The security notions we’ve seen apply
    to both types of applications, but the right notion to consider may depend on
    the application.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 加密应用有两种主要类型。*传输中*加密保护从一台机器发送到另一台机器的数据：数据在发送之前被加密，接收之后被解密，就像电子商务网站的加密连接。*静态加密*保护存储在信息系统中的数据。数据在写入内存之前被加密，在读取之前被解密。例子包括笔记本电脑上的磁盘加密系统，以及云虚拟实例的虚拟机加密。我们看到的安全概念适用于这两种类型的应用，但需要考虑的正确概念可能取决于具体应用。
- en: Asymmetric Encryption
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非对称加密
- en: 'So far we’ve considered only symmetric encryption, where two parties share
    a key. In *asymmetric encryption*, there are two keys: one to encrypt and another
    to decrypt. The encryption key is called a *public key* and is generally considered
    publicly available to anyone who wants to send you encrypted messages. The decryption
    key, however, must remain secret and is called a *private key*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了对称加密，其中两个方共享一个密钥。在*非对称加密*中，有两个密钥：一个用于加密，另一个用于解密。加密密钥称为*公钥*，通常被认为是公开的，任何想给你发送加密消息的人都可以使用。解密密钥必须保持秘密，称为*私钥*。
- en: The public key can be computed from the private key, but obviously the private
    key can’t be computed from the public key. In other words, it’s easy to compute
    in one direction, but not in the other—and that’s the point of *public-key cryptography*,
    whose functions are easy to compute in one direction but practically impossible
    to invert.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥可以从私钥中计算得出，但显然私钥不能从公钥中计算得出。换句话说，计算方向是单向的，容易计算，但反向计算几乎是不可能的——这就是*公钥加密学*的关键，其函数在一个方向上易于计算，但几乎无法逆向计算。
- en: The attack models and security goals for asymmetric encryption are about the
    same as for symmetric encryption, except that because the encryption key is public,
    any attacker can make encryption queries by using the public key to encrypt. The
    default model for asymmetric encryption is therefore the chosen-plaintext attacker
    (CPA).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密的攻击模型和安全目标与对称加密差不多，只不过由于加密密钥是公开的，任何攻击者都可以使用公开密钥进行加密查询。因此，非对称加密的默认模型是选择明文攻击者（CPA）。
- en: Symmetric and asymmetric encryption are the two main types of encryption, and
    they are usually combined to build secure communication systems. They’re also
    used to form the basis of more sophisticated schemes, as you’ll see next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密和非对称加密是两种主要的加密方式，通常结合使用来构建安全通信系统。它们也用作更复杂方案的基础，正如你接下来会看到的。
- en: When Ciphers Do More Than Encryption
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当密码学做的不仅仅是加密
- en: Basic encryption turns plaintexts into ciphertexts and ciphertexts into plaintexts,
    with no requirements other than security. However, some applications often need
    more than that, be it extra security features or extra functionalities. That’s
    why cryptographers created variants of symmetric and asymmetric encryption. Some
    are well-understood, efficient, and widely deployed, while others are experimental,
    hardly used, and offer poor performance.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 基本加密将明文转化为密文，将密文转化为明文，唯一的要求是安全性。然而，一些应用往往需要更多的东西，不论是额外的安全特性还是额外的功能。因此，加密学家们创建了对称加密和非对称加密的变体。某些变体已被广泛理解、高效且广泛应用，而其他一些则是实验性的，使用很少，且性能较差。
- en: '*Authenticated Encryption*'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*认证加密*'
- en: '*Authenticated encryption (AE)* is a type of symmetric encryption that returns
    an *authentication tag* in addition to a ciphertext. [Figure 1-4](ch01.xhtml#ch1fig4)
    shows authenticated encryption sets **AE**(*K*, *P*) = (*C*, *T*), where the authentication
    tag *T* is a short string that’s impossible to guess without the key. Decryption
    takes *K*, *C*, and *T* and returns the plaintext *P* only if it verifies that
    *T* is a valid tag for that plaintext–ciphertext pair; otherwise, it aborts and
    returns some error.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证加密（AE）*是一种对称加密方式，它返回一个*认证标签*，除了密文之外。[图 1-4](ch01.xhtml#ch1fig4)展示了认证加密集
    **AE**(*K*, *P*) = (*C*, *T*)，其中认证标签*T*是一个短字符串，只有拥有密钥的人才能猜测出来。解密过程需要*K*、*C*和*T*，并且只有在验证*T*是该明文-密文对的有效标签时，才会返回明文*P*；否则，它会中止并返回错误。'
- en: '![image](../images/f01-04.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-04.jpg)'
- en: '*Figure 1-4: Authenticated encryption*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：认证加密*'
- en: The tag ensures the *integrity* of the message and serves as evidence that the
    ciphertext received is identical to the one sent in the first place by a legitimate
    party that knows the key *K*. When *K* is shared with only one other party, the
    tag also guarantees that the message was sent by that party; that is, it implicitly
    *authenticates* the expected sender as the actual creator of the message.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该标签确保消息的*完整性*，并作为证据证明接收到的密文与最初由知道密钥*K*的合法方发送的密文完全相同。当*K*仅与另一个方共享时，该标签还保证消息是由该方发送的；即，它隐式地*验证*了预期的发送者作为消息的实际创建者。
- en: '**NOTE**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I use “creator” rather than “sender” here because an eavesdropper can record
    some* (C, T) *pairs sent by party A to party B and then send them again to B,
    pretending to be A. This is called a replay attack, and it can be prevented, for
    example, by including a counter number in the message. When a message is decrypted,
    its counter* i *is increased by one:* i + 1\. *In this way, one could check the
    counter to see if a message has been sent twice, indicating that an attacker is
    attempting a replay attack by resending the message. This also enables the detection
    of lost messages.*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在这里使用“创建者”而非“发送者”，因为窃听者可以记录一些由A方发送给B方的(C, T)对，并且再将它们发送给B方，假装是A方发送的。这被称为重放攻击，可以通过在消息中包含一个计数器数字来防止。例如，当消息被解密时，其计数器*i*会增加1：i
    + 1。*通过这种方式，可以检查计数器，查看消息是否已被发送两次，从而表明攻击者正在通过重新发送消息进行重放攻击。这也可以检测丢失的消息。*'
- en: '*Authenticated encryption* *with associated data (AEAD)* is an extension of
    authenticated encryption that takes some cleartext and unencrypted data and uses
    it to generate the authentication tag **AEAD**(*K*, *P*, *A*) = (*C*, *T*). A
    typical application of AEAD is used to protect protocols’ datagrams with a cleartext
    header and an encrypted payload. In such cases, at least some header data has
    to remain in the clear; for example, destination addresses need to be clear in
    order to route network packets.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证加密* *与附加数据（AEAD）*是认证加密的扩展，它采用一些明文和未加密的数据，并利用这些数据生成认证标签**AEAD**(*K*, *P*,
    *A*) = (*C*, *T*)。AEAD的一个典型应用是保护协议的数据报，其中包含一个明文头部和一个加密负载。在这种情况下，至少有一些头部数据必须保持明文；例如，目标地址需要保持明文，以便路由网络数据包。'
- en: For more on authenticated encryption, jump to [Chapter 8](ch08.xhtml#ch8).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于认证加密的信息，请跳转到[第8章](ch08.xhtml#ch8)。
- en: '*Format-Preserving Encryption*'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*格式保留加密*'
- en: A basic cipher takes bits and returns bits; it doesn’t care whether bits represents
    text, an image, or a PDF document. The ciphertext may in turn be encoded as raw
    bytes, hexadecimal characters, base64, and other formats. But what if you need
    the ciphertext to have the same format as the plaintext, as is sometimes required
    by database systems that can only record data in a prescribed format?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的密码算法处理比特并返回比特；它不关心比特表示的是文本、图像还是PDF文档。密文可以进一步编码为原始字节、十六进制字符、base64等格式。但如果需要密文与明文具有相同格式呢？例如，一些数据库系统要求数据只能以预定格式记录，那么该如何处理？
- en: '*Format-preserving encryption (FPE)* solves this problem. It can create ciphertexts
    that have the same format as the plaintext. For example, FPE can encrypt IP addresses
    to IP addresses (as shown in [Figure 1-5](ch01.xhtml#ch1fig5)), ZIP codes to ZIP
    codes, credit card numbers to credit card numbers with a valid checksum, and so
    on.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*格式保留加密（FPE）*解决了这个问题。它可以创建与明文具有相同格式的密文。例如，FPE可以将IP地址加密为IP地址（如[图 1-5](ch01.xhtml#ch1fig5)所示），将邮政编码加密为邮政编码，将信用卡号码加密为带有效校验和的信用卡号码，等等。'
- en: '![image](../images/f01-05.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-05.jpg)'
- en: '*Figure 1-5: Format-preserving encryption for IP addresses*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-5：IP地址的格式保留加密*'
- en: '*Fully Homomorphic Encryption*'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*完全同态加密*'
- en: '*Fully homomorphic encryption (FHE)* is the holy grail to cryptographers: it
    enables its users to replace a ciphertext, *C* = **E**(*K*, *P*), with another
    ciphertext, *C*′ = **E**(*K*, **F**(*P*)), for **F**(*P*) can be any function
    of *P*, and without ever decrypting the initial ciphertext *C*. For example, *P*
    can be a text document, and **F** can be the modification of part of the text.
    You can imagine a cloud application that stores your encrypted data, but where
    the cloud provider doesn’t know what the data is or the type of changes made when
    you change that data. Sounds amazing, doesn’t it?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*完全同态加密（FHE）*是密码学家的圣杯：它使得用户能够将密文*C* = **E**(*K*, *P*)替换为另一个密文*C*′ = **E**(*K*,
    **F**(*P*))，其中**F**(*P*)可以是*P*的任何函数，而无需解密初始密文*C*。例如，*P*可以是一个文本文件，**F**可以是对部分文本的修改。你可以想象一个云应用程序，它存储你的加密数据，而云服务提供商既不知道数据是什么，也不知道你更改数据时做了什么类型的更改。听起来是不是很神奇？'
- en: 'But there’s a flip side: this type of encryption is slow—so slow that even
    the most basic operation would take an unacceptably long time. The first FHE scheme
    was created in 2009, and since then more efficient variants appeared, but it remains
    unclear whether FHE will ever be fast enough to be useful.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有一面：这种加密类型非常慢——慢到即使是最基本的操作也会耗费不可接受的时间。第一个FHE方案诞生于2009年，从那时起出现了更高效的变体，但目前尚不清楚FHE是否能快到足以实际应用。
- en: '*Searchable Encryption*'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*可搜索加密*'
- en: '*Searchable encryption* enables searching over an encrypted database without
    leaking the searched terms by encrypting the search query itself. Like fully homomorphic
    encryption, searchable encryption could enhance the privacy of many cloud-based
    applications by hiding your searches from your cloud provider. Some commercial
    solutions claim to offer searchable encryption, though they’re mostly based on
    standard cryptography with a few tricks to enable partial searchability. As of
    this writing, however, searchable encryption remains experimental within the research
    community.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*可搜索加密*通过对搜索查询本身进行加密，使得可以在加密数据库上进行搜索而不会泄露搜索的内容。像完全同态加密一样，可搜索加密能够通过隐藏搜索内容来增强许多基于云的应用程序的隐私，防止云服务提供商窥探你的搜索内容。一些商业解决方案声称提供可搜索加密，尽管它们大多基于标准加密技术，并通过一些技巧实现部分可搜索性。然而，截至目前，可搜索加密在研究社区仍然处于实验阶段。'
- en: '*Tweakable Encryption*'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*可调加密*'
- en: '*Tweakable encryption (TE)* is similar to basic encryption, except for an additional
    parameter called the *tweak*, which aims to simulate different versions of a cipher
    (see [Figure 1-6](ch01.xhtml#ch1fig6)). The tweak might be a unique per-customer
    value to ensure that a customer’s cipher can’t be cloned by other parties using
    the same product, but the main application of TE is *disk encryption*. However,
    TE is not bound to a single application and is a lower-level type of encryption
    used to build other schemes, such as authentication encryption modes.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*可调加密（TE）*类似于基础加密，只不过增加了一个叫做*调整值*的附加参数，它旨在模拟密码的不同版本（见[图1-6](ch01.xhtml#ch1fig6)）。调整值可能是一个独特的每个客户的值，以确保客户的加密算法无法被其他使用相同产品的方克隆，但TE的主要应用是*磁盘加密*。然而，TE并不局限于单一应用，它是一种低级别的加密类型，可用于构建其他方案，如认证加密模式。'
- en: '![image](../images/f01-06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-06.jpg)'
- en: '*Figure 1-6: Tweakable encryption*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-6：可调加密*'
- en: In disk encryption, TE encrypts the content of storage devices such as hard
    drives or solid-state drives. (Randomized encryption can’t be used because it
    increases the size of the data, which is unacceptable for files on storage media.)
    To make encryption unpredictable, TE uses a tweak value that depends on the position
    of the data encrypted, which is usually a sector number or a block index.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在磁盘加密中，TE加密存储设备的内容，如硬盘或固态硬盘。（由于随机化加密会增加数据的大小，这对于存储介质上的文件来说是不可接受的，因此无法使用随机化加密。）为了使加密不可预测，TE使用一个取决于加密数据位置的调整值，通常是扇区号或块索引。
- en: How Things Can Go Wrong
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误的可能性
- en: Encryption algorithms or implementations thereof can fail to protect confidentiality
    in many ways. This can be due to a failure to match the security requirements
    (such as “be IND-CPA secure”) or to set requirements matching reality (if you
    target only IND-CPA security when attackers can actually perform chosen-ciphertext
    queries). Alas, many engineers don’t even think about cryptographic security requirements
    and just want to be “secure” without understanding what that actually means. That’s
    usually a recipe for disaster. Let’s look at two examples.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法或其实现可能以多种方式未能保护机密性。这可能是因为未能匹配安全要求（例如“符合IND-CPA安全”），或未设定与现实相匹配的要求（如果你只针对IND-CPA安全，而攻击者实际上可以执行选择密文查询）。可悲的是，许多工程师甚至没有考虑加密安全要求，只想要“安全”，却不理解这到底意味着什么。通常，这种做法注定会带来灾难。让我们来看两个例子。
- en: '*Weak Cipher*'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*弱密码*'
- en: Our first example concerns ciphers that can be attacked using cryptanalysis
    techniques, as occurred with the 2G mobile communication standard. Encryption
    in 2G mobile phones used a cipher called A5/1 that turned out to be weaker than
    expected, enabling the interception of calls by anyone with the right skills and
    tools. Telecommunication operators had to find workarounds to prevent the attack.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子涉及使用密码分析技术可以被攻击的密码，就像2G移动通信标准的情况一样。2G手机中的加密使用了一种名为A5/1的密码，结果比预期的弱，使得任何拥有正确技能和工具的人都能拦截通话。电信运营商不得不寻找解决方法来防止这种攻击。
- en: '**NOTE**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The 2G standard also defined A5/2, a cipher for areas other than the EU and
    US. A5/2 was purposefully weaker to prevent the use of strong encryption everywhere.*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*2G标准还定义了A5/2，这是一个用于欧盟和美国以外地区的密码。A5/2故意被设计得较弱，以防止在任何地方使用强加密。*'
- en: That said, attacking A5/1 isn’t trivial, and it took more than 10 years for
    researchers to come up with an effective cryptanalysis method. Furthermore, the
    attack is a *time-memory trade-off (TMTO)*, a type of method that first runs computations
    for days or weeks in order to build large look-up tables, which are subsequently
    used for the actual attack. For A5/1, the precomputed tables are more than 1TB.
    Later standards for mobile encryption, such as 3G and LTE, specify stronger ciphers,
    but that doesn’t mean that their encryption won’t be compromised; rather, it simply
    means that the encryption won’t be compromised by breaking the symmetric cipher
    that’s part of the system.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，攻击A5/1并不简单，研究人员花费了超过10年的时间才提出了一种有效的密码分析方法。此外，这种攻击是一种*时间-内存权衡（TMTO）*，即首先进行数天或数周的计算以构建大型查找表，然后这些表被用于实际的攻击。对于A5/1，预计算的表格大小超过1TB。后来的移动加密标准，如3G和LTE，指定了更强的密码，但这并不意味着它们的加密不会被攻破；而是意味着加密不会通过破解系统中的对称密码来被攻破。
- en: '*Wrong Model*'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*错误模型*'
- en: The next example concerns an invalid attack model that overlooked some side
    channels.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子涉及一个忽视某些侧信道的无效攻击模型。
- en: Many communication protocols that use encryption ensure that they use ciphers
    considered secure in the CPA or CCA model. However, some attacks don’t require
    encryption queries, as in the CPA model, nor do they require decryption queries,
    as in the CCA model. They simply need *validity queries* to tell whether a ciphertext
    is valid, and these queries are usually sent to the system responsible for decrypting
    ciphertexts. *Padding oracle attacks* are an example of such attacks, wherein
    an attacker learns whether a ciphertext conforms to the required format.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加密的许多通信协议确保它们使用在CPA或CCA模型中被认为安全的密码。然而，一些攻击并不需要加密查询，如在CPA模型中，也不需要解密查询，如在CCA模型中。它们只需要*有效性查询*来判断一个密文是否有效，这些查询通常发送到负责解密密文的系统。*填充Oracle攻击*就是这类攻击的一个例子，在这种攻击中，攻击者通过观察密文是否符合要求的格式来获取信息。
- en: Specifically, in the case of padding oracle attacks, a ciphertext is valid only
    if its plaintext has the proper *padding*, a sequence of bytes appended to the
    plaintext to simplify encryption. Decryption fails if the padding is incorrect,
    and attackers can often detect decryption failures and attempt to exploit them.
    For example, the presence of the Java exception `javax.crypto.BadPaddingException`
    would indicate that an incorrect padding was observed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在填充Oracle攻击中，只有当密文的明文具有正确的*填充*时，密文才是有效的，填充是附加到明文的字节序列，以简化加密。如果填充不正确，解密将失败，攻击者通常能检测到解密失败并尝试利用它们。例如，Java异常`javax.crypto.BadPaddingException`的出现将表明观察到了错误的填充。
- en: In 2010, researchers found padding oracle attacks in several web application
    servers. The validity queries consisted of sending a ciphertext to some system
    and observing whether it threw an error. Thanks to these queries, they could decrypt
    otherwise secure ciphertexts without knowing the key.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，研究人员在多个Web应用服务器中发现了填充Oracle攻击。这些有效性查询通过向某个系统发送密文并观察它是否抛出错误来进行。通过这些查询，他们可以解密原本安全的密文，而无需知道密钥。
- en: Cryptographers often overlook attacks like padding oracle attacks because they
    usually depend on an application’s behavior and on how users can interact with
    the application. But if you don’t anticipate such attacks and fail to include
    them in your model when designing and deploying cryptography, you may have some
    nasty surprises.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学家通常忽视像填充Oracle攻击这样的攻击，因为它们通常依赖于应用程序的行为以及用户与应用程序的交互方式。但是，如果你没有预见到这些攻击，并且在设计和部署加密时没有将它们纳入模型，你可能会遇到一些令人吃惊的麻烦。
- en: Further Reading
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We discuss encryption and its various forms in more detail throughout this book,
    especially how modern, secure ciphers work. Still, we can’t cover everything,
    and many fascinating topics won’t be discussed. For example, to learn the theoretical
    foundations of encryption and gain a deeper understanding of the notion of indistinguishability
    (IND), you should read the 1982 paper that introduced the idea of semantic security,
    “Probabilistic Encryption and How to Play Mental Poker Keeping Secret All Partial
    Information” by Goldwasser and Micali. If you’re interested in physical attacks
    and cryptographic hardware, the proceedings of the CHES conference are the main
    reference.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们详细讨论了加密及其多种形式，尤其是现代安全密码的工作原理。不过，我们无法涵盖所有内容，许多有趣的主题将不会讨论。例如，要学习加密的理论基础并深入理解不可区分性（IND）的概念，你应该阅读1982年由Goldwasser和Micali提出的关于语义安全的论文《概率加密及如何在保持所有部分信息秘密的情况下玩心理扑克》。如果你对物理攻击和密码硬件感兴趣，CHES会议的论文集是主要参考资料。
- en: There are also many more types of encryption than those presented in this chapter,
    including attribute-based encryption, broadcast encryption, functional encryption,
    identity-based encryption, message-locked encryption, and proxy re-encryption,
    to cite but a few. For the latest research on those topics, you should check *[https://eprint.iacr.org/](https://eprint.iacr.org/)*,
    an electronic archive of cryptography research papers.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型的加密方法，远超本章所介绍的，包括基于属性的加密、广播加密、功能加密、基于身份的加密、消息锁定加密和代理重加密等。关于这些主题的最新研究，你可以查看*[https://eprint.iacr.org/](https://eprint.iacr.org/)*，这是一个密码学研究论文的电子档案。
