- en: '![Image](../images/pg063-01.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
- en: '4'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Robot Heist: Creating Rules and Obstacles'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll build the *Robot Heist* game from the ground up. You’ll
    make two robot objects that the player will use to navigate each level. You’ll
    also create the backdrop and other objects, such as crates, guns, and panels.
    You’ll use PuzzleScript rules to make these objects interact with one another
    in interesting ways.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 2](ch02.xhtml) that the `RULES` section in your code is
    where you write instructions to change one set of objects into another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: How Robot Heist Works
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Robot Heist*, two robots work together to rob a Data Bank. Each robot has
    different capabilities, so the player needs to switch between them to solve puzzles.
    There are security robots and lasers to avoid, and a treasure to steal. You’ll
    find the game at *[http://tinyurl.com/robotheist/](http://tinyurl.com/robotheist/)*.
    This is what the game looks like.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg064-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: '*Example level in* Robot Heist'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The game begins with only one robot named Vertibot because we want the player
    to learn the basics before introducing a second robot. Vertibot can push objects
    vertically (up and down). Later in the game, the player meets another robot named
    Horibot that can push objects horizontally (left and right). To take advantage
    of their different pushing capabilities, the player must make Vertibot and Horibot
    work together to solve the game’s puzzles.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Brainstorming Objects and Interactions
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before I started working on my *Robot Heist* game, I thought carefully about
    what objects I wanted in the game. I didn’t just want objects that were cool:
    I wanted objects that worked together in intriguing ways. Choosing your game’s
    objects is like casting a play, and a play in which none of the characters talk
    to each other would be very boring.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg065-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'The objects I came up with were the robots (the player characters), crates
    to push, gates to open and close, security lasers, and patrolling guard robots.
    Each of these objects interacts with the others in the following ways:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Robots (the player)** Robots can push crates and open gates. They need to
    avoid lasers and guards.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Crates** Robots can push crates to block lasers or hold gates open. Crates
    can also block guards, so robots can put them in a guard’s path to confuse them.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Gates** Robots and guards can open and close gates. Crates can be used to
    keep gates open. Gates block lasers when they’re closed but let lasers through
    when they’re open.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Lasers** A laser will catch the robots if one of them tries to cross it,
    but robots can block a laser with a crate or a gate. Guards can block lasers as
    well, so the robots can sometimes sneak past while a guard is blocking the laser.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Guards** Guards can open and close gates or block lasers. Guards can catch
    robots, so robots should avoid them. Robots can use crates to block the guards’
    paths.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: This is my cast of characters! Because I can make them all interact with each
    other, I should be able to make a lot of fun levels.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PuzzleScript remembers the last 20 versions you’ve saved, but it’ll forget any
    versions after that. You can click the **Load** menu at the top of the window
    to see your saved versions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Before you start a new project, be sure to make a copy of the previous one!
    The easiest way to do this is to click **Share** as if you were sharing your game
    and keep a copy of the link. When you click the link, you should see the **hack**
    button that lets you access your game’s code again.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE:** You could also copy all the code and email it to yourself. Click
    the **Export** button to create an HTML copy of your game. To find the game code
    in your HTML file, open it using a plain text editor. The text between “sourceCode=”
    and “;compile” is your game code! Copy and paste the unformatted code into a free
    formatting tool like *[https://www.freeformatter.com/javascript-escape.html](https://www.freeformatter.com/javascript-escape.html)*
    and then click **UNESCAPE**. You should now see the complete code of your game.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve backed up your old project, you can start the new one. Click **Load
    Example**▸**Blank Project** to start a new game from scratch.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg067-01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: '*Creating a new project*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Give your new game a title and an author. You can add these at the beginning
    of your code, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Keep in mind that the title and author should go before your code’s `OBJECTS`
    section. Now that you’ve labeled your new game, you’re ready to start adding objects
    to the game.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Creating Objects
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Objects are a very important part of your code because they outline all the
    items that make up your game. Whenever you add a new element to your game, you’ll
    follow these steps to create an object for it in your code’s `OBJECTS` section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Add an object to the `OBJECTS` section, giving it a name and appearance.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the object to the `LEGEND` section so it appears in the level editor.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the object to the `COLLISIONLAYERS` section. PuzzleScript won’t run if there
    are objects that don’t have a collision layer, because it won’t know what to do
    if they touch another object.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the rules that tell PuzzleScript what the object should do.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start, let’s add the most basic objects we need: a background and some sort
    of solid wall.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Your background and wall can look like these, or you can use your own colors.
    Keep in mind that if you give an object just a color but no numbered pixels, the
    object will just look like a solid square of that color. For example, in the example
    level shown at the beginning of this chapter, I made the background `Green` without
    including numbered pixels, which means it will be a solid green. But I list two
    colors for the wall: `LightGreen` and `DarkGreen`. Then I use a grid of numbers
    below that to specify that the outer pixels will be in dark green to make a border
    around the light green interior.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use these objects, we need to add them to the `LEGEND` section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能使用这些对象之前，需要将它们添加到`LEGEND`部分。
- en: Creating the Legend
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建图鉴
- en: 'Adding an object to the legend makes it appear in the level editor so we can
    draw with it. Let’s add the background and wall to the `LEGEND` section and assign
    a symbol to each, as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 向图鉴中添加一个对象会使它在关卡编辑器中出现，以便我们能够用它绘制。让我们将背景和墙壁添加到`LEGEND`部分，并为每个对象分配一个符号，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Not all objects need to be in the legend. For example, some objects never appear
    at the very start of a level, so we don’t need them in the level editor. We’ll
    make some objects like that soon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有对象都需要出现在图鉴中。例如，有些对象在关卡开始时永远不会出现，因此我们不需要在关卡编辑器中显示它们。我们很快会制作一些这样的对象。
- en: 'Now add your new objects to the `COLLISIONLAYERS` section:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将你的新对象添加到`COLLISIONLAYERS`部分：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that objects collide with each other only if they’re on the same
    collision layer. Because the background and wall objects are on different layers
    (each on its own line of code), they can share the same space without colliding.
    This allows the wall to sit on top of a background tile, which acts as the floor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，只有当对象位于同一碰撞层时，它们才会相互碰撞。由于背景和墙壁对象位于不同的层（每个对象在自己的代码行上），它们可以共享相同的空间而不发生碰撞。这使得墙壁可以位于背景瓦片的上方，背景瓦片充当地面。
- en: We don’t need to add any rules for these objects, because we don’t need them
    to do anything but display on the screen. Any other solid object we add from this
    point forward will need to be on the same collision layer as the wall because
    the walls should be able to block other objects from moving through them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为这些对象添加任何规则，因为我们只需要它们显示在屏幕上。我们从这一点开始添加的任何其他固体对象都需要与墙壁处于相同的碰撞层，因为墙壁应该能够阻止其他对象穿过它们。
- en: Now that we have our basic building blocks, we can run our game, right? Not
    so fast! PuzzleScript won’t let you run a game unless it has a player object.
    Let’s figure out how our two player robots are going to work!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了基本的构建模块，是否就可以运行游戏了？不，别着急！PuzzleScript不会让你运行游戏，除非它有一个玩家对象。我们来看看我们的两个玩家机器人是如何工作的！
- en: Player Swapping
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家切换
- en: Think about what we need the player objects to do. We want two robots that are
    onscreen at the same time, but the player can control only one at a time. The
    player can switch between the two robots at any time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想我们希望玩家对象做什么。我们想要两个机器人同时出现在屏幕上，但玩家一次只能控制其中一个。玩家可以随时在两个机器人之间切换。
- en: '![image](../images/pg070-01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg070-01.jpg)'
- en: One way to think about this scenario is that only one robot is *awake* at any
    given time while the other one is *asleep.* (Just like the cats in *Herding Cats*!)
    When the player presses the *action key*, the sleeping robot wakes up and the
    awake robot goes to sleep.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一种思考这种场景的方式是，始终只有一个机器人处于*醒着*状态，而另一个则处于*睡眠*状态。（就像《*Herding Cats*》中的猫一样！）当玩家按下*行动键*时，睡着的机器人醒来，醒着的机器人则进入睡眠状态。
- en: 'We can program the action key (either X or the spacebar) to do whatever we
    want, and the player can press it during the game. In our game, we’ll use the
    action key to allow the player to switch between robots. This means we need four
    objects in total to pull off this wacky scheme. Because we have two different
    robots, each needs two possible states: awake or asleep.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编程设定行动键（X键或空格键）执行我们希望的任何操作，玩家可以在游戏中按下它。在我们的游戏中，我们将使用行动键允许玩家在机器人之间切换。这意味着我们总共需要四个对象来完成这个疯狂的方案。因为我们有两个不同的机器人，每个机器人需要两种可能的状态：醒着或睡着。
- en: Our robots will also need something to push around, so let’s make a crate object
    while we’re creating the four robot objects. Add the four robot objects and the
    crate object to your game, using the following code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人还需要一些物品来推动，因此在创建四个机器人对象时，我们来制作一个箱子对象。使用以下代码将四个机器人对象和箱子对象添加到游戏中。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, I drew the Vertibot to look tall and thin and the Horibot to
    look short and stout to make it easy to tell them apart. I made the sleeping version
    of each robot look different from the awake version by making the sleeping robots
    gray. The player should be able to tell just by looking at the colors which robot
    is awake and which is asleep. The crate is a square object that has a yellow border
    around its brown interior.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我画的Vertibot（垂直机器人）看起来又高又瘦，而Horibot（水平机器人）则显得矮胖，这样可以很容易地区分它们。我让每个机器人的睡眠状态与醒着的状态不同，通过将睡眠中的机器人涂成灰色。玩家应该能仅通过颜色区分出哪个机器人醒着，哪个机器人睡着了。箱子是一个方形物体，周围有黄色边框，内部是棕色的。
- en: Updating the Legend
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新图鉴
- en: 'Now we need to put our new objects in the legend so we can use them in our
    levels. I picked the letter *I* for Vertibots because it’s tall and vertical and
    an *H* for Horibot. Let’s update the `LEGEND` section, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将新对象放入图例中，以便在关卡中使用它们。我选择了字母 *I* 代表 Vertibots，因为它高且垂直，而 *H* 代表 Horibot。让我们更新
    `LEGEND` 部分，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Any objects we add to the legend should now appear in the level editor. You
    might notice that we only added two robot objects to the legend: the awake Vertibot
    and the asleep Horibot. The reason is that what we’re drawing in the level editor
    is the starting position for each level. In other words, we’re designing the way
    the level looks at the very beginning of play. Whenever a level begins, one robot
    should be awake and the other asleep. For consistency, I decided that at the start
    of each level, Vertibot will always be the robot that’s awake and Horibot will
    always be asleep.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在添加到图例中的任何对象应该都会出现在关卡编辑器中。你可能会注意到我们只在图例中添加了两个机器人对象：醒着的 Vertibot 和睡着的 Horibot。原因是我们在关卡编辑器中绘制的是每个关卡的起始位置。换句话说，我们正在设计游戏开始时关卡的外观。每当一个关卡开始时，一个机器人应该是醒着的，另一个是睡着的。为了保持一致性，我决定在每个关卡开始时，Vertibot
    总是醒着的，而 Horibot 总是睡着的。
- en: 'PuzzleScript won’t let us run our game until we have a player object. Without
    it, PuzzleScript won’t know which of the two objects to move when the player presses
    the keys. Fortunately, the legend lets us define groups. You can use a group to
    contain multiple objects, which you can then refer to by the same name. For example,
    we can create a group called `Player` and add both robots to it by adding the
    following code to the `LEGEND` section:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript 不会让我们运行游戏，直到我们有了玩家对象。没有它，PuzzleScript 不知道在玩家按下按键时应该移动哪一个对象。幸运的是，图例允许我们定义组。你可以使用一个组来包含多个对象，然后用相同的名称引用它们。例如，我们可以创建一个名为
    `Player` 的组，并通过将以下代码添加到 `LEGEND` 部分将两个机器人都添加进去：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By writing `Vertibot or Horibot`, we specify that only one of the awake versions
    of the robots counts as a player. Because `VertibotSleeping` and `HoribotSleeping`
    don’t count as players, they won’t move when the player runs the game.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写 `Vertibot or Horibot`，我们指定只有一个醒着的机器人版本算作玩家。因为 `VertibotSleeping` 和 `HoribotSleeping`
    不算作玩家，所以它们在玩家运行游戏时不会移动。
- en: PuzzleScript lets you have as many players onscreen as you like at the same
    time. But in our game, the two robots won’t ever be awake at the same time. Whichever
    one is awake will act as the player and move when the player presses the arrow
    keys.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript 允许你在屏幕上同时拥有任意数量的玩家。但在我们的游戏中，两个机器人永远不会同时醒着。无论哪个机器人醒着，它都会充当玩家，并在玩家按下箭头键时移动。
- en: Updating the Collision Layers
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新碰撞层
- en: 'Because PuzzleScript won’t run if an object doesn’t have a collision layer,
    we need to put all our newly added objects into the `COLLISIONLAYERS` section.
    We want the robots to bump into walls and to be able to push crates around, so
    we should make sure the robots, crates, and walls are all on the same collision
    layer, as shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果一个对象没有碰撞层，PuzzleScript 将无法运行，我们需要将所有新添加的对象放入 `COLLISIONLAYERS` 部分。我们希望机器人能撞到墙壁并能够推动箱子，因此我们应该确保机器人、箱子和墙壁都在同一个碰撞层上，如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Right now, the only object that should be on a separate collision layer is the
    background, which is on its own line of code. Save your game, and click **Rebuild**
    to make sure everything in your game works. If it does, a `Successful Compilation`
    message should appear under the game window.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，唯一应该放在单独碰撞层上的对象是背景，它位于自己的代码行中。保存你的游戏，然后点击**重建**以确保游戏中的所有内容正常运行。如果一切正常，游戏窗口下方应该会出现
    `编译成功` 的消息。
- en: '![image](../images/pg073-01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg073-01.jpg)'
- en: '*Successful Compilation message*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译成功信息*'
- en: If something is wrong with the code, such as if any of the objects are not in
    the `COLLISIONLAYERS` section or if you forgot to add a player to the `LEGEND`
    section, you might see a bright red error message pop up that looks like this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码出现问题，比如某些对象没有在 `COLLISIONLAYERS` 部分，或者你忘了将玩家添加到 `LEGEND` 部分，你可能会看到一个明亮的红色错误信息，类似于下面的样子。
- en: '![image](../images/pg074-01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg074-01.jpg)'
- en: '*Compilation Error message*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译错误信息*'
- en: We’re done updating the `COLLISIONLAYERS` section, so let’s create an action
    key that allows the player to switch between robots.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `COLLISIONLAYERS` 部分的更新，现在让我们创建一个操作键，允许玩家在机器人之间切换。
- en: Writing Rules to Switch Characters
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写切换角色的规则
- en: As mentioned earlier, we can program an action key to do whatever we want it
    to. Pressing either the X key or spacebar triggers action in PuzzleScript. The
    player can use whichever one they’re more comfortable with. While the player uses
    the arrow keys to move around, they can use the action key to jump, pull a switch,
    put on a hat, or do whatever the rules say happens when the player presses the
    action key.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以编程让行动键执行任何我们希望的操作。按下X键或空格键都可以触发PuzzleScript中的动作。玩家可以选择他们更舒适的按键。玩家用方向键移动时，也可以使用行动键进行跳跃、拉开开关、戴上帽子，或执行任何当玩家按下行动键时规则定义的操作。
- en: 'In our game, the action key will switch between characters by waking up one
    robot and putting the other to sleep. Keep in mind that the action key won’t do
    anything until we write rules telling PuzzleScript what it should do. So let’s
    add the following rules in the `RULES` section:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，行动键会通过唤醒一个机器人并让另一个进入睡眠来切换角色。请记住，直到我们编写规则告诉PuzzleScript该做什么之前，行动键不会有任何作用。所以让我们在`RULES`部分添加以下规则：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: PuzzleScript ignores anything in parentheses, so `(switching characters)` is
    just a note to me to help me remember what this part of the code does when I look
    at it later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: PuzzleScript会忽略括号内的内容，因此`(switching characters)`只是一个提醒我用的注释，帮助我在稍后查看代码时记得这部分代码的功能。
- en: The two lines of code below the note check to see when the player presses the
    action key and then switches each robot to its sleeping and awake state. In PuzzleScript,
    the action key is based on a condition, just like movement. For example, if `>
    Horibot` represents a moving Horibot, `action Horibot` represents a Horibot that’s
    doing the action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下方的两行代码会检查玩家按下行动键的时机，然后切换每个机器人的睡眠与清醒状态。在PuzzleScript中，行动键是基于条件的，类似于移动。例如，`>
    Horibot`代表一个正在移动的Horibot，而`action Horibot`代表一个正在执行动作的Horibot。
- en: If the awake Horibot has the action condition, it becomes `HoribotSleeping`,
    and `VertibotSleeping` becomes `Vertibot`, the awake version. And if `Vertibot`
    is the one doing the action, then it goes to sleep and the sleeping Horibot wakes
    up.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果清醒的Horibot满足行动条件，它会变成`HoribotSleeping`，而`VertibotSleeping`则变成清醒状态的`Vertibot`。如果是`Vertibot`在执行动作，它就会进入睡眠状态，而清醒的Horibot则会醒来。
- en: Note that because the characters are enclosed in separate square brackets, they
    don’t need to be next to each other for the switching rule to work. In PuzzleScript
    rules, we use sets of brackets to group objects together. A series of objects
    in the same set of brackets, divided by a vertical bar, indicates objects that
    are next to each other on the level’s grid (for example, `[ Vertibot | HoribotSleeping
    ]`). If we put the two objects together *without* the vertical bar, it means the
    two objects are sharing the same space (for example, `[ Vertibot Background ]`).
    We’ll talk more about this format shortly!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于角色被分别放在不同的方括号中，它们不需要在彼此旁边才能使切换规则生效。在PuzzleScript规则中，我们使用一组方括号将物体组合在一起。一个方括号内有一系列用竖线分隔的物体，表示这些物体在关卡网格中是相邻的（例如，`[
    Vertibot | HoribotSleeping ]`）。如果我们将两个物体放在一起*没有*使用竖线，意味着这两个物体共享同一个空间（例如，`[ Vertibot
    Background ]`）。我们稍后会详细讲解这种格式！
- en: If we put one object in its own set of brackets and one in another set of brackets,
    that just means two objects are in two different grid spaces (for example, `[
    Vertibot ] [ HoribotSleeping ]`). They could be next to each other, or they could
    be across the level from each other. All PuzzleScript checks for is that they’re
    on the same level at the same time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个物体放在它自己的方括号组里，另一个物体放在另一个方括号组里，这意味着这两个物体位于不同的网格空间中（例如，`[ Vertibot ] [
    HoribotSleeping ]`）。它们可以相邻，也可以在关卡的不同位置。PuzzleScript只检查它们是否在同一层级、同一时刻。
- en: But because both characters are listed in each rule, they both need to be in
    the same level for the switch to work. This automatically means that if only one
    character is in the level, the program will ignore these rules. That’s perfect
    if we want to design levels with only one of the characters, like we do in this
    case!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个规则中都列出了这两个角色，它们必须处于相同的层级才能使切换规则生效。这意味着，如果只有一个角色在该层级，程序将忽略这些规则。如果我们想设计只有一个角色的关卡，这样的设计就很完美，正如我们在这个案例中所做的！
- en: Note that even if the objects are in different places, there need to be as many
    objects on the left side of the rule as on the right side. If you entered `[ Vertibot
    ] [ HoribotSleeping ] -> [ VertibotSleeping ]`, PuzzleScript would give you an
    error message. It wouldn’t know what to do with `HoribotSleeping`!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使物体位于不同的位置，规则的左侧和右侧也需要有相同数量的物体。如果你输入了`[ Vertibot ] [ HoribotSleeping ]
    -> [ VertibotSleeping ]`，PuzzleScript会给出错误信息。它不知道如何处理`HoribotSleeping`！
- en: Let’s take a moment to make sure the rules we wrote are working.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间确保我们写的规则有效。
- en: Building a Test Level
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建测试关卡
- en: 'To test our rules, we’ll create a quick test level to make sure everything
    in the game works so far. Enter this text in the `LEVELS` section:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的规则，我们将创建一个快速测试关卡，以确保目前为止游戏中的所有内容都能正常工作。在`LEVELS`部分输入以下文本：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This level includes all the objects we’ve added so far. Recall from the legend
    that the `I` and `H` are the robots, the `*` is a crate, the `#` is the wall,
    and the `.` is the background. Click **Save** and then click **Run**. Now when
    you start the game, you should see something like this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关卡包括了我们到目前为止添加的所有物体。从图例中回忆一下，`I`和`H`是机器人，`*`是箱子，`#`是墙壁，`.`是背景。点击**保存**，然后点击**运行**。现在，当你开始游戏时，应该能看到类似这样的画面。
- en: '![image](../images/pg076-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg076-01.jpg)'
- en: '*Test level*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试关卡*'
- en: This level doesn’t look as pretty as it will in the finished game, but for now
    we just want to make sure the basics work. Try pressing the arrow keys to move
    the characters around and X or the spacebar to switch between them. Move one character
    around, switch to the other, move *that* character around, and then switch back.
    The robots shouldn’t be able to move through the walls or the crate because they’re
    on the same collision layer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关卡看起来不如最终游戏中的美观，但目前我们只是想确保基本功能正常。尝试按方向键来移动角色，使用X键或空格键在它们之间切换。移动一个角色，切换到另一个，移动*那个*角色，然后切换回来。机器人应该不能穿过墙壁或箱子，因为它们在同一碰撞层上。
- en: But we don’t want the crate to simply stop the robots. We want the robots to
    be able to *push* the crate around! Let’s add a few rules to make that happen.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不希望箱子仅仅停住机器人。我们希望机器人能够*推动*箱子！让我们添加一些规则来实现这个目标。
- en: Adding Pushing Rules
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加推动规则
- en: 'Here are some rules that let both robots push crates:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些规则，允许两个机器人推动箱子：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This rule is similar to the one we saw in the demo game in [Chapter 1](ch01.xhtml)
    except this one includes `horizontal` and `vertical`. A PuzzleScript rule is applied
    in four different directions. We can specify which direction to apply a rule by
    giving PuzzleScript a specific direction, like `left` or `right` or `down`. In
    this case, `horizontal` means left and right, and `vertical` means up and down.
    This rule tells the program that a moving Horibot can only move a crate left and
    right, and a moving Vertibot can only move a crate up and down.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则与我们在[第1章](ch01.xhtml)的演示游戏中看到的规则类似，只是这次包括了`horizontal`和`vertical`。PuzzleScript规则可以应用于四个不同的方向。我们可以通过给PuzzleScript指定特定的方向，如`left`或`right`或`down`，来指定规则应用的方向。在这个例子中，`horizontal`表示左右，`vertical`表示上下。这个规则告诉程序，移动的Horibot只能左右移动箱子，而移动的Vertibot只能上下移动箱子。
- en: 'Click **Save** and then click **Rebuild**. Try pushing the crate around. Each
    robot should be able to push the crate in two directions: left and right horizontally
    or up and down vertically.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**保存**，然后点击**重建**。尝试推动箱子。每个机器人应该能够推动箱子朝两个方向移动：水平的左和右，或者垂直的上下。
- en: Making Groups of Pushable Objects
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建可推动物体的组
- en: Now our robots can push crates, but what if the awake robot could push around
    the robot that’s asleep? This would create even more chances for teamwork and
    would cut down on traffic jams. For example, if the sleeping robot is in the way
    of the awake robot, instead of having to switch to the sleeping robot to move
    it, the player could just push it out of the way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的机器人可以推动箱子了，但如果清醒的机器人能够推动正在睡觉的机器人怎么办？这将创造更多的团队合作机会，并减少交通堵塞。例如，如果睡着的机器人挡住了清醒的机器人的路，玩家就不必切换到睡觉的机器人来移动它，而可以直接将其推开。
- en: In the legend, we used a group to tell PuzzleScript that both Vertibot and Horibot
    count as players. Similarly, we can update the legend to say that crates and sleeping
    robots count as pushable objects. Note that the pushable group is a group we’re
    making up. The word “pushable” doesn’t mean anything to PuzzleScript until we
    tell it what it means. After we define a pushable group, we can write rules telling
    the robots to push pushables in general instead of just crates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在传奇中，我们使用一个组来告诉PuzzleScript，Vertibot和Horibot都算作玩家。同样，我们可以更新传奇，声明箱子和正在睡觉的机器人算作可推动物体。请注意，推送组是我们自己创建的。单词“pushable”对PuzzleScript来说没有任何意义，直到我们告诉它它的含义。在我们定义了推送组之后，我们可以编写规则，指示机器人推动所有可推动物体，而不仅仅是箱子。
- en: Add this line to the `LEGEND` section to tell PuzzleScript that crates and sleeping
    robots all count as pushables.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LEGEND`部分添加这一行代码，告诉PuzzleScript箱子和正在睡觉的机器人都算作可推动物体。
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![image](../images/pg078-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg078-01.jpg)'
- en: 'Now when we write a rule using the word `Pushable`, we tell PuzzleScript to
    check for any of those three objects. Let’s go back and change the pushing rules
    we wrote earlier so they check for pushables instead of crates. Replace all instances
    of `Crate` with `Pushable` so the code looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们编写规则时，使用“Pushable”这个词，告诉PuzzleScript检查这三种物体中的任何一种。让我们回去修改之前编写的推动规则，使其检查可推动物体，而不是箱子。将所有“Crate”的实例替换为“Pushable”，使代码如下所示：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A robot that is moving toward an object can now push that object if it’s defined
    as `Pushable`, which includes crates and the robot’s sleeping partner. Click **Rebuild**
    and try it out. Of course, Horibot should only be able to push a sleeping Vertibot
    horizontally, and Vertibot should only be able to push a sleeping Horibot vertically.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正在朝某个物体移动的机器人，现在如果该物体被定义为`Pushable`（可推动物体），例如箱子和机器人正在睡觉的伙伴，它就可以推动该物体。点击**Rebuild**并尝试一下。当然，Horibot只能水平推动正在睡觉的Vertibot，而Vertibot只能垂直推动正在睡觉的Horibot。
- en: Allowing Characters to Push Multiple Objects
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 允许角色推动多个物体
- en: What happens when you try pushing the crate into a sleeping robot or a sleeping
    robot into the crate? It stops, and you can’t push it any farther. As they are
    now, the rules only allow a character to push a single pushable at a time. But
    the ability to push in one direction or the other is each robot’s only superpower.
    So they should be able to push as many objects as they want, as long as it’s in
    the right direction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将箱子推入一个正在睡觉的机器人，或者将一个正在睡觉的机器人推入箱子时，会发生什么？它会停下，你不能再推动它了。目前的规则只允许一个角色一次推动一个可推动物体。但是，能够推动物体的能力是每个机器人唯一的超级能力。所以只要在正确的方向，它们应该能够推动任意数量的物体。
- en: 'To allow robots to push multiple objects at a time, add this line of code to
    the `RULES` section, under the pushing rules we already have:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许机器人一次推动多个物体，请在`RULES`部分的现有推动规则下添加这一行代码：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that this rule isn’t directional because Vertibot and Horibot already have
    rules telling them which directions they can push. Remember that PuzzleScript
    runs rules in order from top to bottom, and we want this new rule to happen after
    pushing starts. The rule checks whether one pushable is being pushed into another,
    and if it is, the rule tells the second pushable to move in the same direction.
    And because PuzzleScript can run each rule as many times as possible, if the second
    pushable is pushed into a third, that third one will also move in the same direction,
    and so on. Now our robots can push as many objects as they want, as long as there’s
    room.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个规则不是方向性的，因为Vertibot和Horibot已经有规则告诉它们可以推动的方向。记住，PuzzleScript按从上到下的顺序运行规则，我们希望这个新规则发生在推动开始之后。该规则检查一个可推动物体是否被推向另一个物体，如果是，规则会告诉第二个可推动物体朝相同的方向移动。而且因为PuzzleScript可以多次运行每个规则，如果第二个可推动物体被推向第三个物体，那么第三个物体也会朝相同的方向移动，依此类推。现在我们的机器人可以推动任意数量的物体，只要有空间。
- en: Creating Win Conditions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建胜利条件
- en: How does the player win a *Robot Heist* level and go on to the next one? We
    can specify this by defining our win condition. In our game, a player satisfies
    the win condition, or completes a level, when both characters make it to the exit,
    which is a physical location in the level.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家如何才能在*机器人抢劫*关卡中获胜并进入下一关？我们可以通过定义胜利条件来指定这一点。在我们的游戏中，玩家在两个角色都到达出口时满足胜利条件，出口是关卡中的一个物理位置。
- en: To add this condition to *Robot Heist*, we first need to make a new `Exit` object,
    as shown here.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个条件添加到*机器人抢劫*中，我们首先需要创建一个新的`Exit`对象，如下所示。
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the robots are on the exit, the level is finished! I made my exit look
    like a black-and-white checkered flag.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器人站在出口上时，关卡就完成了！我把我的出口做成了一个黑白棋盘格的旗帜样式。
- en: '![image](../images/pg080-01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg080-01.jpg)'
- en: 'Add the `Exit` object to your `LEGEND` section, like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Exit` 对象添加到你的 `LEGEND` 部分，像这样：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Of course, I used `X` for `Exit`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我使用了 `X` 来代表 `Exit`。
- en: Adding Exit to a Collision Layer
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 Exit 添加到碰撞层
- en: 'As with every object we add to a game, we need to assign `Exit` to a collision
    layer. But we’ll put it on a different collision layer than the robots because
    we want them to be able to stand on top of the exit. You can think of the exit
    as a checkered pattern painted on the ground at the end of a racetrack. Update
    the `COLLISIONLAYERS` section like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们向游戏中添加的每个对象一样，我们需要将 `Exit` 分配给一个碰撞层。但我们会将它放在与机器人不同的碰撞层上，因为我们希望机器人能站在出口上。你可以把出口想象成赛车道尽头地面上画的一种黑白棋盘图案。更新
    `COLLISIONLAYERS` 部分，像这样：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The placement of `Exit` gives it its own layer, which means the other objects
    won’t be able to collide with it. In fact, the higher up an object is in the `COLLISIONLAYERS`
    section’s list, the farther back it will be drawn in the game. For example, the
    background layer in the game is all the way in the back. The exit layer is in
    front of the background layer, and the solid objects (robots and crates) layer
    is in front of the exit layer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exit` 的放置为其提供了一个独立的层，这意味着其他对象无法与它发生碰撞。事实上，`COLLISIONLAYERS` 部分列表中排得越靠前的对象，在游戏中的显示位置就越靠后。例如，游戏中的背景层是最靠后的。出口层位于背景层前面，固体物体（机器人和箱子）层则位于出口层前面。'
- en: 'Now we’re ready to write the win condition. It should state that both robots
    need to be on the `Exit` object to win the level. We could try something like
    this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编写赢的条件。它应该声明两只机器人都需要站在 `Exit` 对象上才能赢得关卡。我们可以试试类似这样的方法：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But this condition will work only if Vertibot is awake and Horibot is asleep.
    What if the opposite is true? Or what if only one of the robots is in the level?
    We need code that’s a little more versatile.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个条件只在 Vertibot 清醒而 Horibot 睡着时有效。如果情况正好相反呢？或者如果只有一只机器人在关卡里呢？我们需要写一些更灵活的代码。
- en: Creating the Buddy Group for the Win Condition
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为赢的条件创建 Buddy 组
- en: 'Fortunately, we can use groups for the win condition too. Just like we made
    a pushable group to turn crates and sleeping robots into pushable objects, we
    can make a new group to make robots count as the same thing, whether they’re sleeping
    or awake. Let’s update the legend by adding the following line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们也可以使用组来设置赢的条件。就像我们创建一个可推组来让箱子和睡着的机器人变成可推物体一样，我们也可以创建一个新的组，使得机器人无论是睡着还是清醒，都算作同一类物体。让我们通过添加以下行来更新
    legend：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that because `Player` already includes `Horibot` and `Vertibot`, we can
    just use `Player` to create a new group called `Buddy` that includes both robots.
    Now, whenever we refer to a `Buddy`, we’re referring to any robot in either state,
    asleep or awake.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为 `Player` 已经包含了 `Horibot` 和 `Vertibot`，我们可以直接使用 `Player` 来创建一个新的组，叫做 `Buddy`，包含这两个机器人。现在，每当我们提到
    `Buddy` 时，我们指的就是处于任何状态下的机器人，无论是睡着还是清醒。
- en: 'Let’s update our `WINCONDITIONS` section using `Buddy`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `Buddy` 更新我们的 `WINCONDITIONS` 部分：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code `all Buddy` refers to all `Buddy` objects currently in the level. If
    there’s only one robot in a level, `all Buddy` means just that one robot. If both
    robots are in the level, `all Buddy` means both of them. Because sleeping and
    awake robots count as `Buddy` objects, it doesn’t matter what state they’re in.
    As long as all the `Buddy` objects in the current level are on an `Exit` object,
    the win condition is satisfied.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码 `all Buddy` 指的是当前关卡中的所有 `Buddy` 对象。如果关卡中只有一个机器人，那么 `all Buddy` 就只表示那一个机器人。如果关卡中有两个机器人，`all
    Buddy` 就表示这两个机器人。因为处于睡眠状态和清醒状态的机器人都算作 `Buddy` 对象，所以它们的状态并不重要。只要当前关卡中的所有 `Buddy`
    对象都位于 `Exit` 对象上，赢的条件就满足了。
- en: 'One more thing! To make sure that both robots can fit on the exit, each level
    needs to have at least two `Exit` spaces. Add two `Exit` spaces to your level,
    as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事！为了确保两个机器人都能站到出口上，每个关卡需要至少有两个 `Exit` 空间。像这里这样，给关卡添加两个 `Exit` 空间：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can either add two Xs to your `LEVELS` section code, or you could add the
    `Exit` spaces using the level editor (see [Chapter 3](ch03.xhtml) to review how
    to do this). Here’s what the updated level should like:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `LEVELS` 部分的代码中添加两个 X，或者你也可以使用关卡编辑器添加 `Exit` 空间（查看[第3章](ch03.xhtml)以了解如何操作）。更新后的关卡应该像这样：
- en: '![image](../images/pg083-01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/pg083-01.jpg)'
- en: '*Creating exits for each robot*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*为每个机器人创建出口*'
- en: Now that we’ve created `Exit` objects and defined our win condition, let’s make
    our game even more fun to play by creating gates that open and close.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Making Gates That Open and Close
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We decided that creating gates that open and close would help foster teamwork
    between the two robots. Because these gates can open only when a robot is holding
    them open, one robot must hold the gate open while the other goes through.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Gates are a great idea for our game, but how do they actually work? To keep
    the idea simple, you can think of a gate as a type of wall that can be turned
    on and off. When it’s on, it’s in the same collision layer as the robots and other
    solid objects, acting like a wall. But when it’s off, it’s on another collision
    layer, so the robots can walk over it. In its off state, the gate acts more like
    a floor.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: We also need some sort of trigger, or switch, for the gate opening and closing.
    Have you ever seen a movie where someone steps on a hidden panel in the floor,
    and then a secret passage opens or a bunch of poison darts fly out of the wall?
    We’ll use this idea to make our trigger a switch panel that robots can step on
    to open gates. This is a good solution because it means that other solid objects,
    like crates and guards, can also activate these switches. When the game finds
    a solid object on top of a panel, the gates will be in floor mode. If there’s
    no object on a switch panel, the gates will be in wall mode.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg084-01.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Creating the Gate Objects
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve identified three different objects we need to make our gates work. Similar
    to how we have two versions of each robot (asleep and awake), we need two versions
    of our gate: open and closed. We’ll put the closed version on the same collision
    layer as the robots. The open version will be on a different collision layer.
    The third object we need is the trigger panel that opens the gates.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by adding these objects to our game and describing what they look
    like.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Creating gates and panel objects*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: When objects work together in some way, like the panel and the gate, it’s a
    good idea to make them look similar. This helps the player make the connection
    between the two objects. Here, I made `GateClosed` and `Panel` in the same color
    so they match. I also made `GateOpen` blue but in a darker shade so it’s similar
    to the background. This will let the player know they can pass over it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Gates to the Legend and the Collision Layers
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we need to add these objects to the legend so we can use them in the level
    editor. I chose the letter *T* (`T`) for the gate because it looks kind of like
    a fence and a forward slash (`/`) for the panel because it looks like a lever
    you might pull.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We don’t need a symbol for an open gate because the gates will start out closed,
    and we’re only defining the start of each level.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add our new objects to the `COLLISIONLAYERS` section. Update
    the `COLLISIONLAYERS` section by adding the highlighted objects, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Because we want the robots to be able to step on or walk through the panel and
    any open gates, they’re in a different layer than the robots. But we want the
    robots to collide with closed gates, so `GateClosed` is in the same layer as the
    robots. Keep in mind that the closer a collision layer is to the top of the list,
    the farther back it is. This is why we need to make sure that the objects the
    robots can step on appear above the robots in code, not below.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Writing Rules for Gates
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we can write the rules that tell our panels and gates what to do. So how
    do our gates work?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Solid object on a panel means gates are open
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No solid object on any panels means gates are closed
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Which solid objects can activate a panel? The robots, definitely, and crates,
    so robots can use them to keep gates open. It’d be fun to have guards operate
    panels, too. It sounds like we need a new group to contain all the objects that
    can activate a panel. Let’s define a new group called `Depressor` by adding the
    following to the legend (I’ve called the group “Depressor” because these objects
    can *depress* a panel in the floor, not because they’re depressing):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, I use two groups I’ve already defined to name all the objects I want
    to include in the `Depressor` group. The first is `Player`, which includes the
    awake versions of both robots, and the second is `Pushable`, which includes the
    sleeping versions of both robots, plus crates. This is handy because if I ever
    introduce another pushable object, I only need to update the `Pushable` group.
    Because the `Pushable` group is in the `Depressor` group, it will get updated
    automatically!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg087-01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: 'Now let’s translate our ideas into rules PuzzleScript can understand by adding
    the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first rule states that when there’s no depressor on a panel, open gates
    should change to closed gates. The second rule states that when there *is* a depressor
    on a panel, closed gates should change to opened gates.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Recall how we check for two objects next to each other. For example, in `[ SleepingCat
    | WakerUpper ]` the vertical bar indicates that the two objects are in two different
    spaces but right next to each other. So if we don’t use a line to separate two
    objects, that would mean that they’re in the same space. So `[Panel Depressor]`
    means that the space contains a panel and a depressor stepping on that panel.
    Similarly, `[Panel no Depressor]` means that there’s a panel in a space with no
    depressor on top of it. Naturally, two objects can share the same space only if
    they’re on different collision layers, which is why we put the panels and the
    depressors on different collision layers in the previous section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: When we put two separate, bracketed items next to each other, like `[Panel Depressor]`
    and `[GateClosed]`, it means we’re looking for both states occurring at the same
    time anywhere in the level but not necessarily next to each other. So `[Panel
    Depressor] [GateClosed]` checks for instances where there’s a depressor on a panel
    *anywhere* and a closed gate *anywhere*. If that condition is met, we transform
    the closed gate into an open one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The full rule is `late [ Panel Depressor ] [ GateClosed ] -> [ Panel Depressor
    ] [ GateOpen ]`. Notice that on the right side of the arrow, `GateClosed` has
    changed to `GateOpen`, but the panel and the depressor haven’t changed. We don’t
    want them to change, so to indicate that to PuzzleScript, we write them in the
    same way on both sides of the arrow.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that both rules are late. You learned in [Chapter 3](ch03.xhtml)
    that late rules happen after movement, not before. Because we want gates to open
    after a robot has stepped onto a panel, we run this rule late.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Gates
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s build a new test level to make sure our gates and panels work the way
    we want. I drew a level with both robots, a long gate, a panel, and a crate for
    the robots to push onto the panel, as shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can either type this in to the `LEVELS` section manually, or you can use
    the level editor. (Press **E** to switch into editing mode, and then click the
    **S** button in the corner to see a text version of your level.)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Now *playtest* your level. Playtesting is about trying as many features as possible
    in the game to make sure they work. Try to do as many actions as you can think
    of to see how the code handles different scenarios. Imagine you’re a detective,
    carefully trying to find the hidden bugs. There’s one in the game right now. Can
    you find it?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: To find the bug, have one robot stand on the panel and hold the gate open. Next,
    move the other robot on top of an open gate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg089-01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '*Holding a gate open*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Then have both robots stand right on top of the open gate. Finally, switch back
    to the first robot and have them step off the panel. What happens?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '*Boosh!* The robot disappears forever because the closed gate object is on
    the same collision layer as the character object. Two objects on the same collision
    layer can’t share the same space, so when the open gate becomes a closed gate,
    the robot disappears.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg090-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: '*Finding the bug*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: To fix this bug, we need to tell PuzzleScript to do something normally *except*
    in a specific case. In this case, we want the `GateOpen` to become a `GateClosed`
    *except* when there’s already a depressor on top of it. In other words, when a
    depressor is on top of an open gate, the gate should not close to prevent the
    depressor from disappearing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update our rule with this exception by changing `[ GateOpen ]` to `[
    GateOpen no Depressor ]`, as shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Updating the rule to `[ GateOpen no Depressor ]` tells PuzzleScript that if
    no depressor is on top of a panel, only the open gates without a depressor on
    them should close, *except* any that have depressors standing on them. Click **Rebuild**
    to rerun your game, and try to replicate the bug by trying to do the same action
    that caused the robot to disappear previously. Now when an object is on top of
    an open gate, for example, the gate won’t be able to close, even when another
    object is activating the switch. But when nothing is on top of the open gate,
    the gate should close.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Security Lasers
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve created crates and gates, and written rules for how they interact,
    we’re ready to introduce *security lasers*, a threat that the robots can avoid
    using the gates and crates! To do this, we’ll make a laser gun that shoots out
    lasers at every turn. If a laser hits a robot, the player loses! But if the laser
    hits another solid object, like a crate or gate, it’ll stop there.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Laser Objects
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start by drawing our objects. We’ll need three objects:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The laser gun (`Gun`) is shaped like a cross, and the two lasers (`LaserVertical`
    and `LaserHorizontal`) are beams of red light. The vertical laser, as you can
    imagine, fires up and down, and the horizontal laser fires left and right.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Adding Lasers to the Legend
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because we only need to add objects to the legend that will be at the very beginning
    of the level, we only need to add the guns, which definitely will be at the start
    of the level. The lasers appear only when the guns fire them, so we don’t need
    to give them a symbol here. I used a plus sign (`+`) to represent the gun because
    it’s also plus-shaped.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Can you think of any groups we should add to the legend before we start writing
    our rules? For example, it would be useful to create a group for objects that
    block the laser, like walls, closed gates, and crates. We’ll group these objects
    into a new group called `Blocker`, as shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This line tells PuzzleScript that the `Wall`, `GateClosed`, and `Crate` will
    all be able to block the lasers. We don’t use the `Pushable` group here because
    it includes Vertibot and Horibot in their sleeping forms, and we want them to
    trigger an alarm if a laser hits them. Note that we also want the `Gun` to be
    able to block lasers, because we want the lasers to shoot *from* our guns, not
    *through* them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Because we have two different kinds of lasers, let’s add them to the group `Laser`
    to easily refer to both. This should make it easier to check whether something
    has been hit by a laser. Without this group, we’d have to do two separate checks,
    one for each kind of laser.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding Lasers to the Collision Layers
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s add our new objects to the `COLLISIONLAYERS` section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We place the gun on the same layer as all the other solid objects that the robots
    can bump into. The different lasers are on different layers because we want the
    laser beams to be able to pass through the solid objects.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each laser is on its own collision layer. The reason is that if
    they were on the same layer, the vertical laser beam would be able to block the
    horizontal laser, and vice versa! In real life, lasers are just beams of light,
    and one laser can’t block another, or can it? If any scientists are reading this,
    please let me know!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Writing Laser Rules
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The laser objects we made are just a single piece of a laser beam, which is
    big enough to fit only a single space in a given level. If we put a bunch of them
    in a row, we’ll have a much longer laser. We want the lasers to keep going until
    they hit a `Blocker`. The following rules make this happen:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we need to make the laser guns fire. A gun fires laser beams in whatever
    directions aren’t blocked by a blocker. PuzzleScript checks a rule in all four
    directions (up, down, left, and right) unless you tell it to do otherwise. We
    don’t want the horizontal lasers to shoot up and down or the vertical lasers to
    shoot left and right. So we tell PuzzleScript that horizontal lasers fire horizontally
    and vertical lasers fire vertically using `horizontal` and `vertical`, respectively.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `horizontal [ Gun | no Blocker ] -> [ Gun | LaserHorizontal ]`
    checks that there’s no blocker next to a gun, and if this is true, the space next
    to the gun turns into a horizontal laser beam. We use the same idea for the vertical
    laser beam.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Lasers
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s return to our `LEVELS` section to test our laser rules. Add a laser to
    the test level by updating the code to look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I’ve put the laser behind the gate so I can test whether gates block lasers
    like they’re supposed to. Click **Rebuild** to run the game, and you should see
    something like this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg094-01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: '*Test level with laser gun*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg095-01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: As you can see, the lasers fire, but the beams extend only a single space in
    each direction. The laser beams are too short! We need to add a rule that makes
    the beams extend until they eventually hit a blocker. All the objects in PuzzleScript
    are the same size. To create a longer laser, we’ll put a bunch of laser objects
    in a line. We need to add a rule that does that.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we’ll create separate rules for vertical and horizontal lasers. If every
    laser extended in every direction, it would be *extremely dangerous*, as you can
    imagine. Instead, we’ll extend horizontal lasers left and right and extend vertical
    lasers up and down. Add the following lines of code below your existing laser
    rules:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These additional rules check for empty spaces next to the laser beams. As we
    did when we checked for a panel with no depressors on it using `[ Panel no Depressor
    ]`, we use `[ LaserVertical | no blocker ]` to check for a laser with no blocker
    objects next to it. If there’s no blocker in the space next to the laser beam,
    we extend the laser into that space by changing `no blocker` to a `LaserVertical`
    or `LaserHorizontal`. But if there *is* a blocker in the space, the rule would
    stop there.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: PuzzleScript runs a single rule over and over until it stops before moving on
    to the next rule. So this rule continues to run for all adjacent spaces in a laser’s
    path as long as there’s no blocker in those spaces. As a result of this rule,
    a continuous laser beam shoots out from the gun horizontally and vertically.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: To test the updated laser rules, click **Rebuild** and check whether the laser
    beams extend to the wall. Also, try using the panel to open the gate. The laser
    should extend through the opened gate.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the Laser Bug
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s still a problem with the lasers. If you step off the panel, the gate
    closes and blocks the laser, but the laser beam continues on the other side of
    the gate.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg096-01.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: '*Test level showing a laser bug*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg097-01.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: The game design process often involves adding some code to your game, checking
    how it works, making little changes, and then checking it again. Every time we
    do this, we get a little closer to making our game exactly how we want it. In
    this case, we need to tweak our laser rules so a closed gate completely blocks
    a laser beam.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to remind ourselves what a single turn in a PuzzleScript
    game looks like. PuzzleScript runs a turn whenever the player presses a key (either
    the arrow keys or the action key). This is what happens in a turn:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: PuzzleScript marks any player objects that are trying to move (in the rules,
    this looks like `> Vertibot` instead of `Vertibot`).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PuzzleScript runs every rule in order from top to bottom as many times as it
    can.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anything marked to move moves.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PuzzleScript runs any *late* moves in order from top to bottom as many times
    as it can.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The problem with our current rules is that we never get rid of lasers after
    they’re cut off by a blocker object. Let’s add the following rule that does that:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we use the `laser` group we defined earlier. This simple addition tells
    PuzzleScript that any laser beams no longer attached to a gun should disappear.
    The rule also tells PuzzleScript to change the lasers into empty spaces to get
    rid of the laser beams after they’ve been blocked by a closed gate. Then PuzzleScript
    creates new lasers that extend out to erase all the lasers left over from the
    previous turn. The square brackets represent an empty space, so `[ laser ] ->
    [ ]` tells PuzzleScript to find all the laser objects and get rid of them. Then,
    we’ll redraw our lasers based on the *current* layout of the level.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Click **Rebuild** and run this test again! Try standing on and moving off the
    panel a few times. We’re a bit closer, but the program is still a little wonky.
    When the robot steps off the panel, the beams *are* cut off, but it doesn’t happen
    until the next turn!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/pg098-01.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'Fortunately, there’s an easy solution to fixing this delay. On any given turn,
    PuzzleScript runs through each rule and then objects move according to the rules.
    Right now the rules governing our lasers are happening *before* the robots move
    on or off of the panel. Let’s make sure those rules happen *after* movement, which
    we can accomplish by simply making the laser rules happen *late*, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notice also that the lasers don’t fire immediately. They wait until after you’ve
    made a move and then fire. To have the lasers begin firing right away, just add
    `run_rules_on_level_start` to the very beginning of your PuzzleScript code, under
    the name of your game, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You might have noticed when you hold down the action button to switch characters,
    the selection flickers back and forth quite quickly. The `norepeat_action` command
    makes sure the action button switches character only once, no matter how long
    you press it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: When you’re done, try the following challenges.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Bonus Challenges
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Try making four different lasers, each of which shoots in only one direction:
    up, down, left, and right.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: In the finished *Robot Heist* game, there are two kinds of gates and panels,
    pink and blue. There are also some gates that close instead of open when a Depressor
    steps on a panel. See if you can figure out how to do this in your own game!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: If you need help, try clicking the **hack** link in *Robot Heist* (*[http://tinyurl.com/robotheist/](http://tinyurl.com/robotheist/)*)
    to see how this code works.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far you successfully created the basic building blocks of the *Robot Heist*
    game, including the two robot objects the player will use to navigate the level,
    the background and wall that provide the backdrop, and other objects, such as
    crates, guns, and panels. You learned to write rules for each of these objects
    so they interact with one another in interesting ways. You also created obstacles,
    such as lasers, which some objects can block. But right now, our lasers aren’t
    a real threat because they don’t do anything.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll explore the concept of *losing* in game design and
    learn how to raise the stakes for the player. You’ll also explore PuzzleScript’s
    “realtime” mode by creating obstacles that move on their own. See you there!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
