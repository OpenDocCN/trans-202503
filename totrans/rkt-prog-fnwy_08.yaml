- en: '8'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LOGIC PROGRAMMING
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Logic programming* derives its roots from the discipline of formal logic.
    It’s a declarative programming style that focuses on *what* needs to be done,
    rather than *how* it is to be done. The most well-known programming language in
    this arena is Prolog (see [**5**]). The great strength of Prolog, and logic programming,
    in general is that it provides a platform to express and solve certain types of
    problems (typically involving some type of search) in a natural and fluid way.
    The disadvantage is that for other types of problems, logic programming can be
    very inefficient.'
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that Racket allows you to have the best of both worlds. Racket
    provides a Prolog-style logic programming library called *Racklog*. Racklog closely
    mirrors Prolog semantics, but as an embedded extension of the Racket syntax. The
    Racklog library can be accessed via the `(require racklog)` form.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Logic programming is all about facts and the relationships between facts. In
    normal Racket, to define what we consider a coffee drink, we might do it this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We could then ask whether something is a coffee drink by using the member function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Racklog way of defining our coffee facts is the following. Note that all
    built-in Racklog object names are prefixed with a percent sign (`%`) to avoid
    conflicts with the standard Racket names. Usernames aren’t required to use this
    convention.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Such a collection of facts is often referred to as a *database* in Prolog. We
    can *query* our coffee facts (technically *clauses*) via the `%which` form (asking
    *which* facts are true). Note that the purpose of the empty parentheses in the
    `%rel` and `%which` forms will become clear a bit later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since ’`milk` is not in our `%coffee` facts, the query `(%which () (%coffee`
    ’`milk))` returned false as expected. The expression `(%coffee` ’`milk)` in the
    `%which` clause is called the *goal*. Used in this way, `%coffee` is said to be
    a *predicate*. In essence we’re asking, *Is milk a coffee?* In this case, the
    goal is said to have *failed*. When we asked about ’`latte`, our query returned
    the empty list ’`()`. A returned list of any type (even an empty one) is Racklog’s
    way of indicting success. It’s possible to query Racklog with explicit goals that
    always succeed or always fail as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we wanted to know which things are considered a coffee drink. We can
    ask this way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When `%which` finds a match, it returns a list of pairs. The `c` identifier
    is a local logic variable that’s used by the `%which` form to indicate which item
    was matched (that is *bound* or *instantiated*) to the identifier. Note that binding
    a logic variable is a somewhat different process than binding a Racket identifier.
    In this case, the identifier `c` isn’t assigned a value, but is rather used as
    a mechanism to associate the logic variable with a value retrieved from the database.
    While the term *bind* can be used in both senses, we’ll usually use the term *instantiate*
    to distinguish binding a logic variable from binding a Racket identifier. The
    second subform of `%which` (that is, `(c)`) can be a list of such local logic
    variables. This list is simply used as a way to declare to Racklog the logic variables
    that are being used in the remainder of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: What’s going on here is a process called *unification*. There are two important
    factors at work. The first is pattern matching. The second is the aforementioned
    instantiation. If there are no logic variables in a query, the structure of the
    query expression must exactly match a corresponding value in the database to succeed.
    We saw this process fail with the query attempt `(%which () (%coffee` ’`milk))`,
    since there was no exact match in the database. If logic variables are part of
    the query expression, they’re allowed to match with corresponding elements in
    the database. So far, we’ve only seen a simple example involving a query expression
    that just consists of a single logic variable where we’re querying a database
    that just contains some atomic values. We’ll soon encounter more interesting examples.
  prefs: []
  type: TYPE_NORMAL
- en: We can query our coffee database for more coffee drinks using `(%more)`. Each
    time `%more` is invoked, additional matches are generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we run out of coffee facts, `(%more)` fails (returns `#f`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we just needed to know whether there’s any coffee, we could ask this way,
    where the expression `(_)` designates an anonymous variable that will match to
    anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What I’ve shown you so far just looks like a more verbose way to do the same
    thing Racket already does, but Racklog is built for much more. We’ll see that
    more-complex relationships can be defined, such as parent–child. This type of
    relationship can be naturally extended to grandparent–child, and so on. Given
    that these relationships are defined in our database, we can ask questions such
    as *Who are the parents of Tom?* or *Who are Dick’s grandchildren?*
  prefs: []
  type: TYPE_NORMAL
- en: '***Knowing Your Relatives***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Knowing about coffee drinks probably won’t keep you awake at night, but knowing
    who your relatives are just might. That not withstanding, we’re going to create
    a little parent–child database to further expand our knowledge of Racklog.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first item of each relation is the parent, and the second is the child (in
    reality you can decide which is which; it’s just a convention). Suppose that after
    `%parent` was defined, it was discovered that ’`Lisa` and ’`Maggie` needed to
    be added as children of ’`Homer`. This can be remedied by use of one of two `%assert!`
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first expression adds ’`Homer` as a parent of ’`Lisa` after all the other
    clauses. But be aware that `%assert-after!` adds a clause *before* all the other
    clauses (don’t ask us). To demonstrate this, let’s find all the children of ’`Homer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It isn’t necessary to pre-populate a relation with values. We can create an
    empty relation and add items to it as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t need to constrain ourselves to a single generation. We can also ask
    about grandparents. A grandparent is someone whose child is a parent of someone
    else. We can define such a relationship in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the second subform ➊ is a list of symbols `(g p c)` (representing
    grandparent, parent, and child respectively). As mentioned with `%which`, this
    list is simply a way to declare to Racklog the local logic variables that will
    be used in the rest of the expression. Unlike other relations where each clause
    only contained a single expression, in this case the clause has three expressions.
    If you’re familiar with Prolog (don’t worry if you’re not), this would be expressed
    as something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: An expression of this type is known as a *rule*. In the Racklog version, we
    have the expression being matched against ➋. In Prolog terminology, this is known
    as the *head* of the rule (the Racket code `(g c)` would be equivalent to `grand(G,C)`
    in the Prolog version). Following this, we have two subgoals (known as the rule
    *body*) that must also be matched ➌. In plain English this is interpreted to mean
    `g` is the grandparent of `c` if `g` is the parent of `p` and `p` is the parent
    of `c`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at what happens with the query `(%which (k) (%grand` ’`Tom
    k))`, which is asking which person (`k`) is a grandchild of ’`Tom`. With this
    query, the local variable `g` ➌ of our `%grand` definition is instantiated to
    the value ’`Tom`. The variables `k` and `c` are tied together (even though neither,
    as yet, has a concrete value); as mentioned above, the process of associating
    these variables is called *unification*. Racklog then scans through its parent
    database (assuming our original set of parents) until it finds an entry where
    ’`Tom` is a parent. In this case, there’s a record indicating that ’`Tom` is the
    parent of ’`Dick`. So the first subgoal succeeds with the result being that `p`
    is instantiated to ’`Dick`. Now the second subgoal is tested (`(%parent p c)`,
    which through unification becomes `(%parent` ’`Dick c)`). Racklog scans its parent
    database and finds that ’`Dick` is the parent of ’`Harry`, at which point the
    variable `c` (and by unification `k`) is instantiated to the value ’`Harry`. Executing
    the query in DrRacket, we indeed arrive at the expected results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we want to see if ’`Tom` has any other grandchildren, we can use `(%more)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At the point that the original match was made for ’`Harry`, parent (`p`) was
    instantiated to ’`Dick`. What’s happening behind the scenes with `(%more)` is
    that it’s actually triggering a failure of the rule. Racklog then *backtracks*
    over the goal `(%parent p c)` and uninstantiates the variable `c` (it does not
    uninstantiate `p`, since this was instantiated in the previous goal). It then
    looks through the database for another match for a parent of ’`Dick` and finds
    a second record with ’`Harriet` as his child (hence, a grandchild to ’`Tom`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One nice feature of logic programming is that the same relation allows questions
    to be asked in different ways. We’ve asked who is ’`Tom`’s grandchild, but we
    could also ask who has grandchildren by framing our query this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Or we could ask whether ’`Homer` is a grandparent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is one way in which Racklog extends the capability of Racket. We’ll see
    more of this type of flexibility in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we simply wanted to list the parents, we could use the goal `(%parent p
    (_))`, followed by entering some number of `(%more)` commands. It can be a bit
    cumbersome to have to keep entering `(%more)` to see if a goal can be re-satisfied.
    One way around this is to use `%bag-of`. The `%bag-of` predicate takes three arguments:
    a Racket expression we want to return (in this case, just the value of the logic
    variable `p`), the goal to test (in this case `(%parent p (_))`), and a variable
    to instantiate the computed list of results to (also `p`). Here’s an example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we just used `p` as the computed value, but we could dress up
    the output a bit by forming a query this way (from this we see that the value
    of logic variable `p` is `cons`’d with the literal ’`parent` to produce the final
    result).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a simpler way to get a similar output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using `%bag-of` and `%find-all` will list values in the same order that would
    result from using `(%more)`. Because of this, some entries may be repeated (such
    as ’`Dick` in this example). To only get unique values, we can use `%set-of` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ve covered some of the basic ideas behind logic programming.
    For a more detailed description of backtracking, unification, and such, refer
    to the classic (and very approachable) work on the subject in *Programming in
    Prolog* by Clocksin and Mellish [**5**].
  prefs: []
  type: TYPE_NORMAL
- en: '***Racklog Predicates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve explored some of the fundamental capabilities that Racklog offers.
    Logic programming is a unique paradigm that dictates the need for some specialized
    tools to make it fully useful. In this section, we’ll take a look at a few of
    those tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Equality**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve seen that unification plays a key role in the semantics of logic programming.
    Racklog provides the equality predicate `%=`, which uses unification in a direct
    way to test structural equality and implement the instantiation process. The following
    examples should provide some insight into various ways in which this predicate
    can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What’s happening in the first example is subtle. Note that `(1 potato sack)`
    is in fact equivalent to `(1 . (potato sack))` and `(cons a b)` is equivalent
    to `(a . b)`. This means that via unification, `a` gets instantiated to 1 and
    `b` gets instantiated to `(potato sack)`. The result is ’`((a . 1) (b potato sack))`.
    An instantiation is always shown as a pair, but we see the first element, `(a`
    `. 1)`, displayed as a pair and the second element, `(b potato sack)`, shown as
    a list. Recall that a list *is* in fact a pair, just displayed a bit differently.
    In the case of `(b potato sack)`, `b` is the `car` of the pair and `(potato sack)`
    is the `cdr` of the pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite of `%=` is `%/=`, which means not unifiable. Recall that unification
    is essentially a matching process. Leveraging the last example, observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While in the first example it was possible to instantiate the logic variable
    `a` to 5, the attempt to match the 4 in the first list to the 5 in the second
    list caused the unification to fail. In the second example, the unification still
    failed, but since we used the not-equal predicate, a list was returned with the
    logic variable `a` unbound.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the equality predicate is the *identical* predicate `%==`. Unlike
    `%=`, `%==` does not do any instantiation. It checks to see whether two expressions
    are *exactly* the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The opposite of `%==` is `%/==`, which means not identical.
  prefs: []
  type: TYPE_NORMAL
- en: '**Let**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s sometimes desirable to use local variables in a query to produce an intermediate
    result and not have those variables shown in the output. The `%let` predicate
    provides a way to establish these hidden variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `%bag-of` predicate creates a cons pair from the result
    of `friends` and instantiates it to `pals`. Here `a` and `b` are lexically local
    to the `%let`, so only the unified results are passed out of the expression to
    `pals`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Is**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `%is`predicate acts a bit differently than the other Racklog predicates.
    It takes two arguments: the first expression is frequently (but not always) an
    identifier and the second a normal Racket expression. The `%is` expression instantiates
    the result of evaluating the second expression to the first. Normally, all identifiers
    in the second expression will need to be instantiated before the `%is` expression
    is evaluated. The `%is` expression can be used to assign a value to the first
    argument or to test equality.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: One difference between `%is` and `%=` is that for `%is`, any logic variables
    in its second argument generally need to be instantiated, as seen in these examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are, however, situations where `%is` may be advantageous. See the Racket
    manual for details.^([1](footnote.xhtml#ch08foot_1))
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic Comparisons**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Racklog uses `%=:=` to test for numeric equality and `%=/=` to test for numeric
    inequality, but the other predicates are what you’d normally expect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that these comparisons only perform tests without instantiating logic variables,
    so an expression like `(%which (a) (%=:= a 2))` will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Logical Operators**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Racklog supports the expected logical predicates `%not`, `%and`, and `%or`,
    as shown below. The built-in `%fail` goal always fails, and the `%true` goal always
    succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s also an `%if-then-else` predicate: when given three goals, if the first
    goal succeeds, it evaluates the second goal; otherwise, it evaluates the third
    goal. Here’s a little test framework.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following exchange illustrates `%if-then-else` in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Because ’`broccoli` isn’t in the `%spud` database, the last goal is evaluated
    and ’`unknown` is instantiated to `taste` (via `t`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Append**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve already seen the standard Racket version of `append`, which is a function
    that (typically) takes two lists and returns a list that consists of the two lists
    concatenated together, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a one-way street. We only get to ask one question: if I have two lists,
    what does the resulting list look like if I join the lists together? With the
    Racklog version we are about to explore, we can also ask these questions:'
  prefs: []
  type: TYPE_NORMAL
- en: If I have a result list, what other lists can I combine to get this list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If I have a starting list and a resulting list, what list can I join to the
    starting list to get the resulting list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If I have an ending list and a result list, what list can I join to the start
    of the ending list to get the result list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If I have three lists, is the third list the result of appending the first two?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we explain how Racklog’s `%append` works, let’s take a look at a few
    examples. This first query answers the original question (the result of concatenating
    two lists).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This query answers question two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This query answers question three.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And this query answers question one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Generating all possibilities that satisfy certain conditions is one of the strengths
    of logic programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `%append` weren’t already defined in Racklog, it would be easy enough to
    create it from scratch (adapted from [**5**]):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So what’s going on with our predicate `%append`? It consists of two clauses.
    The first ➊ simply says that if the first list is empty, the result of concatenating
    that list to any list `l` is just `l`. The second clause ➋ is more complicated:
    `((cons h l1) l2 (cons h l3))` is the head of a rule. The head of this rule expects
    three arguments, each of which is either a list or an uninstantiated variable:'
  prefs: []
  type: TYPE_NORMAL
- en: The first element of this argument (if a list) is instantiated to `h`, and the
    rest of the list is instantiated to `l1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second argument is instantiated to `l2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the third argument is a logic variable, `(cons h l3)` is used to construct
    the return value from the `h` provided in the first argument and `l3` produced
    in the recursive call to `%append` ➌. If this argument is a list, its head must
    match the `h` in the first argument, and the rest of the list is matched to `l3`
    in the last line ➌.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we’ve seen, any one or two of the arguments to `%append` may simply be an
    uninstantiated variable. Racklog uses its unification process to link concrete
    values to the appropriate values and uses placeholders to temporarily allocate
    space for the other variables until a proper instantiation can be made. We consider
    the case where the first and second arguments are instantiated to explicit lists.
    Once the unification process is complete ➋, the variables `l1` (instantiated to
    the tail of the first supplied list) and `l2` (instantiated to the second list)
    are used to make a recursive call to `%append` ➌ with the expectation that `l3`
    will be populated by the recursive call with the result of concatenating the now
    shorter list `l1` with `l2`. Since `(cons h l3)` is used to form the final value,
    the end result is that both the original supplied lists are concatenated together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a walk-through where we append ’`(1)` and ’`(2 3)` (for the sake of
    brevity, we’ll use the equal sign (=) to indicated logic variable bindings):'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to call `(%which (a) (%append` ’`(1)` ’`(2 3) a))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then comes our first port of call ➊. Since ’`(1)` doesn’t match ’`()`, we fall
    through to the next case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point in the code we have `h=1`, `l1=`’`()` and `l2=`’`(2 3)` ➋ (we’ll
    get to `l3` later; it’s used to construct the returned value).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next is the recursive call ➌. With the instantiated values, this resolves to
    `(%which (l3) (%append` ’`()` ’`(2 3) l3))`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’re at our first port of call again ➊, but now the empty lists do match. With
    `l=`’`(2 3)` instanciated with `l3`, we return `l3=`’`(2 3)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we’ve returned from the recursive call, the logic variable will be back
    to the values given in step 3; of particular interest is `h=1`. But now we also
    have the value returned from the recursive call of `l3=`’`(2 3)`. Our code ➋ says
    that our return value (`a`) from this stage is constructed from `(cons h l3)`.
    That’s ’`(1 2 3)`, the desired end result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other instantiation scenarios can be analyzed in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Member**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Another Racket function that has a Racklog equivalent is `%member`. If we needed
    to create this function ourselves, one way to do it would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Is should be clear that this first checks to see if `x` is at the start of the
    list (that is, `(cons x (~_))` assigns `x` the value at the head of the list,
    so it must match the value being searched for); if not, it checks to see if it
    occurs somewhere in the rest of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '***Racklog Utilities***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll look at implementing a few additional predicates in Racklog.
    These are all common list operations whose implementations show off the capabilities
    of logic programming and Racklog. We’ll only make use of the `%permutation` predicate
    later (which we’ll explain in detail). You can take the remainder as black boxes,
    meaning that we illustrate what they do and how to use them via provided examples,
    without providing detailed explanations of the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Select**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Depending on how `select` is used, it can either pick single items from a list,
    return a list with an item removed, or return a list with an item inserted. Here’s
    the definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And here are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Subtract**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `%subtract` predicate is designed to remove one set of elements in a list
    from the set of elements in another list. It leverages the functionality of the
    `%select` predicate to achieve its result. The implementation is straightforward
    and should be easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the predicate is the source list of items, the second
    parameter is the list of items to be removed, and the last parameter is the list
    to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few examples illustrating the use of `%subtract`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '**Permutation**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It can sometimes be useful to obtain all the permutations of a given list. To
    provide a bit of background on how the following predicate works, it’s helpful
    to imagine a simple way of generating all the permutations of a given list. Suppose
    we have a list of the digits from 1 to 4\. It’s clear that each digit must, at
    some point, appear as the first digit in the list. So one approach is to start
    with four lists, each of these consisting of a single digit from 1 to 4\. For
    each of these lists, we create a corresponding list that contains all the remaining
    digits as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now made our problem a bit smaller. Instead of having to generate all
    the permutations of a list of four digits, we now only need a way to generate
    the permutations of a list of three digits. Of course we’re smart enough to know
    that we can recursively continue this process to work on smaller and smaller lists.
    All that remains is to just join the parts back together. This is essentially
    what the `%permutation` predicate does.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the code, it’s helpful to recall that `%append` can be used
    not just to append two lists together, but to find all the ways a list can be
    split into two parts. For example, if we call `%which (l1 l2)` ’`(1 2 3 4)`, one
    of the possible outputs is ’`((l1) (l2 1 2 3 4))` (the value of `l1` is the empty
    list). With that bit of background under our belt, here’s the predicate (the code
    is adapted from [5]).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This predicate takes two arguments: a list to permutate and an identifier to
    instantiate the returned list of permutations to. Let’s see what happens when
    we call `(%which (a) (%permutation` ’`(1 2 3 4) a))`. Because the list isn’t empty,
    we blow by the first match attempt ➊. Next, we have `l=`’`(1 2 3 4)` ➋. The rest
    of the code at this point is used to construct the return value, so we’ll come
    back to that a bit later. The next line is where things get a bit interesting
    ➌. As mentioned above, the first call to `%append` with a list as its third argument
    will yield an empty list and the list ’`(1 2 3 4)`. With this result, we have
    `v =` ’`()`, `h=1`, and `u=`’`(2 3 4)`. Moving to the next line, we see that `v=`’`()`
    and `u=`’`(2 3 4)` are instantiated but `w` is not, so `(%append v u w)` just
    binds `w` to ’`(2 3 4)` ➍. Finally, we generate the permutations of ’`(2 3 4)`
    and instantiate the result to `t` ➎. We’re now in a position to construct the
    return value(s) ➋. This will generate all the permutations that start with 1.'
  prefs: []
  type: TYPE_NORMAL
- en: So what about the remaining permutations? Once we’ve exhausted all the permutations
    starting with 1, via backtracking ➌, we eventually have `%append` yielding the
    lists ’`(1)` and ’`(2 3 4)`. At this point we have `v=`’`(1)`, `h=2`, and `u=`’`(3
    4)`, so now we have `w=`’`(1 3 4)` ➍. The process continues as before, now constructing
    the permutations of lists starting with 2.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the different ways we can arrange the four card suits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'By making a small adjustment, we can create a version of `%permutation` that
    generates all permutations of a certain length by taking an additional parameter,
    the desired length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The exclamation point (`!`) on the third line is called a *cut*. The cut is
    a goal that always succeeds, but is used to prevent backtracking across the cut.
    What this means is that if the goal immediately following the cut fails (via backtracking
    or any other reason), the cut prevents backtracking to any previous goals. In
    this case, once we reach a count of zero, there’s no need to look for additional,
    longer permutations. This will make the process a bit more efficient (that is,
    the predicate will still work properly without it, but without testing additional
    permutations that are not needed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the pattern matching done by Racklog, there’s no need to have two separate
    predicates. We can combine these into a single predicate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve laid the groundwork, let’s look at a few applications.
  prefs: []
  type: TYPE_NORMAL
- en: Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve introduced the basic mechanics of logic programming. As interesting
    as these topics are, we’ll now take a look at solving some real world (but recreational)
    problems. Here we’ll see how logic programming provides a framework to solve problems
    using a declarative style that more directly mirrors the problem constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '***SEND + MORE = MONEY***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following famous recreational math problem was published in the July 1924
    issue of *The Strand Magazine* by Henry Dudeney.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p0245-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each letter represents a different digit in the solution. Problems of this
    type are variously known as alphametics, cryptarithmetic, cryptarithm, or word
    addition. While this problem can be solved with just a pencil and paper, we’re
    going to leverage Racket (via Racklog) to solve it instead. We’re going to use
    an approach that’s generally frowned on: brute force. This means we’re going to
    generate (almost) all the possible ways we can assign numbers to the letters (it’s
    obvious that M is 1, so we won’t bother looking for that value).'
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we use the `%permute-n` predicate defined in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The predicate to solve the puzzle is `%solve` ➍. First, it assigns 1 to M as
    previously discussed. The unique letters (aside from M) used in this puzzle are
    S, E, N, D, O, R, and Y. The next step is to generate all the possible permutations
    of ’`(0, 2, 3, 4, 5, 6, 7, 8, 9)` ➎ (taken 7 numbers at a time). A call to the
    predicate `%check` is used to test whether the particular permutation will result
    in a solution to the puzzle (more on `%check` in a bit). If the current permutation
    generates a solution, the resulting assignments are returned ➏. Note that if `%check`
    fails, we backtrack ➎ to generate another permutation.
  prefs: []
  type: TYPE_NORMAL
- en: The code for `%check` is also fairly simple. At the first `%is` statement ➋,
    we just form the arithmetic sum for the current permutation of `s1` = SEND + MORE
    (remember M is implicitly 1—here expanded to 1000). At the second `%is` statement
    ➌, we form the sum `s2` = MONEY. Finally we test whether `s1` = `s2`. Due to the
    fairly lengthy arithmetic expressions ➋ ➌, we’re taking advantage of the *infix*
    library so that the computation is clear.
  prefs: []
  type: TYPE_NORMAL
- en: We generate the solution as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Even though we’re using a highly inefficient brute-force approach, on a fairly
    healthy computer, the solution should appear in under a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '***Fox, Goose, Beans***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The fox, goose, and a bag of beans puzzle is an example of a class of puzzles
    called river crossing puzzles. It’s quite old and dates back to at least the 9th
    century. These types of puzzles are a natural fit for logic programming systems.
    The narrative of the puzzle goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Once upon a time, a farmer went to the market and purchased a fox, a goose,
    and a bag of beans. On his way home, the farmer comes to the bank of the river
    where he left his boat. But his boat is rather small, and the farmer can carry
    only himself and a single one of his purchases—the fox, the goose, or the bag
    of the beans. If left alone, the fox would eat the goose, and the goose would
    eat the beans.
  prefs: []
  type: TYPE_NORMAL
- en: The farmer’s task is to get himself and his purchases (still intact) to the
    far bank of the river. How does he do it?
  prefs: []
  type: TYPE_NORMAL
- en: While this puzzle is not difficult to solve by hand, it affords us an opportunity
    to exercise the inherent ability of Racklog to perform a *depth-first search (DFS)*.
    To get some idea of how this type of search works, imagine you’re on a small island
    and need to get to the lighthouse, but you don’t know how to get there and you
    don’t have a map. One way to get to your destination is just to begin driving
    and every time you get to a fork in the road, carefully record which path you
    take. You keep going until you either arrive at your destination or you get to
    a dead end or a place you already visited. If you get to a dead end or a place
    you already visited, you *backtrack* to the previous fork and take a path you
    haven’t taken before. If you’ve already tried all the paths at a particular fork,
    you backtrack to the fork before that. Eventually, if you keep working in this
    fashion, you’ll have tried all the possible paths and arrived at your destination
    or you’ll discover that you’re actually on the wrong island (oops).
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the farmer travels east and west across the river. Using the DFS strategy,
    we keep track of which items we’ve had on each bank as the search progresses.
    We begin then with a record of all items on the east bank. At any point, we may
    elect to travel back to the opposite bank without an item, or we may select a
    single item to carry back to the opposite bank (as long as these movements do
    not violate the constraints of the puzzle). We must also ensure that the resulting
    movement does not create an arrangement of items that previously existed. For
    example, suppose we begin by carrying the goose across the river. We now have
    two stored states: one with all the items (including the farmer) on the east bank,
    and one with the fox and beans on the east bank with the farmer and goose on the
    west bank. At this point the farmer may elect to travel alone back to the east
    bank, since this generates a new state, but if the farmer (stupidly) carries the
    goose back to the east bank, this results in a state already seen (the start state)
    and should not be considered. Play continues in this fashion until the solution
    is found.'
  prefs: []
  type: TYPE_NORMAL
- en: The west bank is designated by the number 0, and the east bank designated by
    the number 1\. A four-element vector is used to keep track of the program state.
    Each element of the vector will indicate the location (that is, bank) of each
    character, as indicated in [Table 8-1](ch08.xhtml#ch8tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-1**: Fox, Goose, Beans State Vector'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | **Character** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Farmer |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Fox |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Goose |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Beans |'
  prefs: []
  type: TYPE_TB
- en: We begin by defining which states aren’t permissible in a predicate called `%rejects`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The first rejected state indicates that if the farmer is on bank 0, it’s not
    permissible to have the fox, goose, and beans on bank 1\. The remaining states
    can be analyzed in a similar fashion. Observing the pattern of the numbers, `%rejects`
    can be written a bit more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If the farmer moves an item from one bank to the other, it’s necessary to toggle
    both the farmer’s bank and the item’s bank. This is handled by the `toggle-item`
    function, which takes a state vector and an element index and returns a new state
    vector. Notice that’s a normal Racket function and not a Racklog predicate. How
    this fits in will be shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The code `(zero? i)` tests for the farmer’s index (0), and `(= i a)` checks
    for the item’s index ➊. Recall that `for/vector` forms a new vector from the results
    of each item computed in the `let` body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `%gen-move` predicate below generates moves consisting of each of the four
    possible types of boat passengers (represented by the numbers 0 through 3 respectively):
    the farmer alone, or the farmer with a fox, goose, or bag of beans.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The predicate is initially called with the list ’`(0 1 2 3)` (representing
    all the items that can be moved) and the current state. It returns a pair with
    the `car` indicating the item being moved and the `cdr` giving the resulting state.
    We have the situation where there are no items left to move ➊, so the next line
    simply toggles the state of the farmer. Notice the cut (!): there’s no need to
    generate additional moves, since there’s nothing left to move. Next, we have a
    non-empty list, so we take the head of the list and toggle the state of that item
    ➋. Finally, we tackle the rest of the list with a recursive call to `%gen-move`
    ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: As the search progresses, it’ll be necessary to ensure that the program doesn’t
    get into an infinite loop by rechecking states that have already been tested.
    To facilitate this, we maintain a list that contains the states that have already
    been visited, and pass this list and a state to check to a `%check-history` predicate.
    If the state is in the history list, the check will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve encountered a previous state, so we fail without backtracking by
    following the cut with `%fail` ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the `%gen-valid-move` predicate. This predicate is passed the current
    state and move history. It first generates a potential move and checks whether
    the items left on the bank after the move form a legitimate combination (that
    is, the state isn’t in the reject list). If so, it then checks whether the current
    state has been seen before. If not, it returns the move as a valid move.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previous appetizers under our belt, we now move on to the main course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The overall strategy is quite simple: generate a valid move and check for the
    solved state. If we reach a dead-end, Racklog’s automatic backtrack mechanism
    will back up and try another move that doesn’t lead to a previous state. The `%solve`
    predicate is called with the initial state, an empty list (representing the state
    history), and a list with the moves generated so far (also empty). The final parameter
    is an identifier to be instantiated to the list of moves solving the puzzle. First
    we check to see whether the puzzle is in the solved state ➊; if so, we return
    the move list. If this isn’t the case, we get the next move candidate and resulting
    state ➋ (these are assigned to `move` ➌), which is used to recursively call `%solve`
    ➍. If a failure is generated by the `%solve` predicate ➍, backtracking occurs.
    Since `%is` cannot be re-satisfied, backtracking continues back ➋ where another
    possible solution is generated. The `%solve` predicate returns a pair: the first
    element is an indicator of the passengers in the boat (see discussion of `%gen-move`
    for meaning of numbers), and the second is the state of the east bank after the
    move.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually solve the puzzle, we call `%solve` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In addition to being in reverse order, the output listing leaves a bit to be
    desired in terms of readability. To get a more intuitive output, we define a couple
    of new helper procedures. First, we create a Racklog predicate version of the
    Racket `printf` form that we call `%print`. It takes a format string as its first
    argument and a value to print as its second. Making this work requires a bit of
    a trick. The `printf` function can’t be called as a Racklog goal since it isn’t
    a predicate. It doesn’t return a value, so normal instantiation won’t work. The
    trick is to enclose the `printf` form in a `begin` form (which evaluates expressions
    in order and returns the value of the last one), where we return `#t` as its final
    expression. We can then use `%is` to instantiate this with the constant `#t` to
    create a predicate that always succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The second helper procedure is a regular Racket function that takes a state
    vector and a bank number. It returns a list indicating which items are currently
    on the bank.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Given a list of solution moves, `%print-moves` (see below) will provide two
    lines of output for each move: the first line will indicate the direction of movement
    and the passenger(s) of the boat; the second line of output will consist of a
    list where the first item is the occupants of bank 0 and the second item is the
    occupants of bank 1\. We leave it as a little exercise for the reader to figure
    out how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The procedure `%print-solution` doesn’t take any arguments, but it generates
    the solution of the puzzle, reverses the list of moves, and calls `%print-moves`
    to print out the solution. Here’s the much more readable end result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the final empty list is Racklog’s way of indicating success.
  prefs: []
  type: TYPE_NORMAL
- en: '***How Many Donuts?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following problem appeared in the October 27, 2007, “AskMarilyn” column
    of *Parade* magazine:'
  prefs: []
  type: TYPE_NORMAL
- en: Jack, Janet, and Chrissy meet at their corner coffeehouse and buy half a dozen
    donuts. Each friend always tells the truth or always lies. Jack says that he got
    one donut, but Janet says that Jack got two, and Chrissy says that Jack got more
    than three. On the other hand, all three friends agree that Janet got two. Assuming
    that each friend got at least one and that no donut was cut and divided, how many
    donuts did each friend get?
  prefs: []
  type: TYPE_NORMAL
- en: Logic programming systems eat this type of problem for breakfast (donuts, breakfast—funny,
    eh?), and Racklog is no exception. What’s nice about this problem is that its
    solution in Racklog is mainly just a declarative statement of the facts (embellished
    with a few helper items).
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few basic definitions; the comments should be sufficient to explain
    their function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The intent here is to determine how many donuts an individual can have, if we
    say they can’t have a certain number (provided as the second argument). Since
    `%can-have` gives all the donuts a person can have, the statement `(%=/= n d)])`
    will give all the donuts they can have, excluding the number they can’t have.
  prefs: []
  type: TYPE_NORMAL
- en: Now we list each person’s statement in two versions (one in case they’re telling
    the truth, and the other in case they’re lying). Here we are abbreviating “Chrissy”
    to “Chris.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Our solver just needs to check each person’s statements and see if the total
    donuts add up to six.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And voilà:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '***Boles and Creots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Boles and Creots is an old pencil and paper code-breaking game. It’s also known
    as Bulls and Cows, or Pigs and Bulls. A commercial variation, called *Mastermind*,
    involves codes consisting of colored pegs. Gameplay progresses by one player selecting
    a secret code (typically a sequence of four or five unique digits or letters).
    The other player then proposes a guess, to which they’re provided a hint consisting
    of the number of boles (correct digits in the correct position) and the number
    of creots (correct digits in the wrong position). The players continue exchanging
    guesses and hints until the guessing player gets all digits in the proper order.
  prefs: []
  type: TYPE_NORMAL
- en: Here we have the computer attempt to guess a number provided by a human player.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy is fairly simple: the guessing player (in this case the Racklog
    program) keeps a record of each guess and the corresponding number of boles and
    creots. Candidate guesses are generated (by a brute-force generation of all possible
    permutations of the digits 0 through 9) where each candidate is tested against
    previous guesses to see if they yield a consistent number of boles and creots.
    If a candidate guess isn’t found to be inconsistent with previous guesses, it
    becomes the next guess presented to the user. To see what we mean, suppose play
    has progressed as shown in [Table 8-2](ch08.xhtml#ch8tab2) below.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 8-2**: Boles and Creots in Progress'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Guess** | **Boles** | **Creots** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2359 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1297 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: For the next turn, the first candidate guess is 1973\. This guess, compared
    to the first guess in the table, has two correct digits (but in the wrong position),
    which gives 0 boles and 2 creots. So far, so good; but when compared with the
    second guess, we have 1 bole and 2 creots, so it’s rejected. Suppose our next
    candidate guess is 9247\. This gives 0 boles and 2 creots when compared to the
    first guess, and 2 boles and 1 creot when compared to the second guess, so it’s
    a good candidate guess. The program guesses 9247, gets a hint from the user, and
    updates the table with the guess, boles, and creots. The process repeats until
    someone wins.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate a game between a guessing computer and hinting human, our Racklog
    program uses a read-evaluate-print loop (REPL) that prints a guess, waits for
    input (a hint) from the user, reads that input, and evaluates it to form its next
    guess.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at a sample session before we begin digging into the code.
    I’ve decided the number to be guessed is 12345\. My response to each guess is
    a two-digit number representing the number of boles and creots respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The code for the overall process is given below. It relies on a number of supporting
    processes that are explained in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The constant `DIGITS` specifies the number of digits to be used for a guess.
    The `%repl` predicate implements the read-evaluate-print loop. The `%repl` code
    generates a randomized list of digits to be used to generate the guesses ➊, and
    the `history` list is cleared ➋. The actual loop starts ➌ where the permutations
    are generated. Each permutation is tested ➍, and backtracking occurs until an
    acceptable candidate guess is generated. Once that happens, the user is presented
    the guess ➎. The user is then prompted to provide the number of boles and creots,
    with the resulting input parsed ➏. The history list is then updated ➐. Finally,
    the input is tested on to see if all the digits are correct ➑, in which case a
    cut (`!`) is used to terminate the process. Otherwise a failure is generated,
    which triggers backtracking and additional guesses.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep track of prior guesses, a `history` list is defined. Each element of
    the list is a three-element list consisting of the following: a guess, the number
    of boles, and the number of creots. The history list is populated by the `%update-history`
    predicate.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As seen above, a guess is represented by a list of digits. We define a `score`
    function that, given two lists of digits, compares them and returns the corresponding
    number of boles and creots in a pair.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent the program from always starting with the same initial guess, we
    define a number generator function to create a jumbled set of digits to choose
    from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: To create guess candidates, we need to generate lists of permutations of our
    randomized digits. For this purpose, we reuse the `%permute-n` predicate we introduced
    in an earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: A predicate called `%consistent?` takes a guess and tests whether it’s consistent
    (as defined above) with the elements of `history`. It’s called with a candidate
    guess.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Controlling input and output is the job of `get-input` and `%print`, as given
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In the opening sections of this chapter, we introduced the logic programming
    paradigm and various tools and utilities that expand its capabilities. In this
    section, we looked at a number of puzzles and problems in recreational mathematics
    that can be solved via logic programming in a natural and declarative way. These
    problems illustrate the powerful search mechanism that’s an inherent feature of
    logic programming.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we’ve given an overview of the logic programming paradigm and
    looked at a number of interesting applications. We’ve seen that in addition to
    Racket’s functional and imperative programming capabilities, it’s also quite adept
    at logic programming given its Racklog library. Logic programming (specifically
    Prolog) is known to be Turing complete. What this means, in simple terms, is that
    anything that can be computed with a typical imperative programming language can
    be computed with a logic program. Technically it means that it can be used to
    simulate a Turing machine (more on this in a bit). That being said, there are
    problem domains where logic programming isn’t going to be optimal. Cases involving
    extensive numerical calculations or where a well-known imperative algorithm is
    already available speak against using logic programming. Logic programming particularly
    shines in search problems such as we saw in the application section and at symbolic
    calculations such as those involved in theorem proving. The good news with Racket
    is that you can choose whichever approach best suits the problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll take a look at a number of abstract computing machines,
    such as the aforementioned Turing machine.
  prefs: []
  type: TYPE_NORMAL
