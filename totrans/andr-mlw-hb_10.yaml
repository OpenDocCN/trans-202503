- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: ROOTING MALWARE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根植恶意软件**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Malware developers often seek ways of elevating their apps’ privileges to gain
    root access, which requires a privilege escalation exploit of some sort. Once
    operating as root, malware can use app and system resources to perform operations
    such as installing system-level applications, accessing other apps’ protected
    files, and modifying filesystem permissions to allow other malicious apps to view
    sensitive data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件开发者常常寻求提升应用程序权限的方式，以获得root访问权限，这需要某种权限提升漏洞。一旦以root身份运行，恶意软件可以利用应用和系统资源执行操作，如安装系统级应用、访问其他应用的受保护文件以及修改文件系统权限，以允许其他恶意应用查看敏感数据。
- en: We covered multiple examples of rooting malware in [Chapter 2](ch02.xhtml).
    In this chapter, we’ll first discuss some well-known rooting malware families
    we haven’t yet explored. Then we’ll examine the performance of different machine
    learning techniques used to separate rooting malware from goodware, as well as
    from other forms of Android malware, and the key features used to do so. Though
    we’ll use the Rootnik rooting malware as an example throughout the chapter, we’ll
    also apply the detection techniques to the DroidDream malware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](ch02.xhtml)中介绍了多个关于根植恶意软件的例子。在本章中，我们将首先讨论一些我们尚未探讨的著名根植恶意软件家族。接下来，我们将分析用于将根植恶意软件与良性软件区分开来，以及与其他形式的安卓恶意软件区分的不同机器学习技术的表现，并探讨实现这一目标的关键特征。尽管我们将以Rootnik根植恶意软件作为全章的示例，但我们也将把这些检测技术应用于DroidDream恶意软件。
- en: '**Rooting Malware Families**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**根植恶意软件家族**'
- en: 'To the best of our knowledge, ZNIU was the first rooting malware to leverage
    the Dirty COW (copy-on-write) vulnerability, which allows privilege escalation
    in the Linux kernel. According to Trend Micro’s blog post “ZNIU: First Android
    Malware to Exploit Dirty COW,” it was distributed via over 1,200 apps and through
    infected websites. Once the app was installed on a device, it reached out to a
    command-and-control server and engaged in transactions with the compromised device’s
    mobile carrier through an SMS-enabled payment service, incurring charges to a
    company located in China. ZNIU used root privileges to circumvent Android’s default
    workflow, which requires user consent to grant an app SMS-related permissions.
    Some versions of ZNIU leveraged exploits other than Dirty COW, such as Iovyroot,
    which targets a Linux kernel vulnerability, or various exploits from the KingoRoot
    rooting app.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 据我们所知，ZNIU是首个利用Dirty COW（写时复制）漏洞进行权限提升的根植恶意软件，Dirty COW漏洞允许在Linux内核中提升权限。根据趋势科技博客文章《ZNIU：首个利用Dirty
    COW漏洞的安卓恶意软件》所述，它通过1200多个应用程序和被感染的网站进行分发。一旦该应用程序安装在设备上，它会联系一个指挥与控制服务器，并通过启用短信支付服务与受感染设备的移动运营商进行交易，从而向一家位于中国的公司产生费用。ZNIU使用root权限绕过了安卓的默认工作流程，该工作流程要求用户同意授予应用短信相关权限。ZNIU的某些版本利用了除了Dirty
    COW之外的漏洞，如Iovyroot，它利用了Linux内核漏洞，或者利用了KingoRoot根植应用的各种漏洞。
- en: In 2017, researchers at Kaspersky Lab discovered Dvmap. Its authors first uploaded
    a benign app to Google Play and later updated it to a malicious version, a behavior
    common in malware because it helps the app build a user base without raising suspicion.
    The authors would make the malicious version available for short periods and then
    replace it with a benign version.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年，卡巴斯基实验室的研究人员发现了Dvmap。其作者首先将一个良性应用上传到Google Play，后来将其更新为恶意版本，这种行为在恶意软件中很常见，因为它有助于应用建立用户基础而不引起怀疑。作者会将恶意版本提供短时间，然后再用良性版本替换。
- en: 'Dvmap was the first rooting malware sample known to use code injection techniques.
    It would substitute the executable file */system/bin/ip* with a completely new
    file that contained malicious functionality, then inject code to execute the new
    file into two system libraries associated with Android’s Dalvik and ART runtimes,
    ensuring that it would run with elevated privileges. Replacing the file, and the
    subsequent code injection into the system libraries, required using a privilege
    escalation exploit. You can read more about this malware in the Kaspersky blog
    post “Dvmap: Android Malware with a New Technique for Controlling Devices Appears
    on Google Play.”'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Dvmap是已知的第一个使用代码注入技术的根植恶意软件样本。它会将可执行文件*/system/bin/ip*替换为一个完全新的包含恶意功能的文件，然后将代码注入到与安卓Dalvik和ART运行时相关的两个系统库中，以确保其以提升的权限运行。替换文件和随后的代码注入到系统库中需要使用权限提升漏洞。你可以在卡巴斯基的博客文章《Dvmap：安卓恶意软件在Google
    Play上出现，使用新技术控制设备》中了解更多关于该恶意软件的信息。
- en: 'In September 2017, the Android Security team discovered Tizi, which roots devices,
    mostly in Africa, to carry out spyware operations by leveraging a number of vulnerabilities
    discovered in 2012 and 2013\. Once it has obtained root privileges, Tizi uses
    this access to record calls on encrypted services such as WhatsApp, Skype, and
    Viber and monitor social media activity on Facebook, X, LinkedIn, and Telegram.
    You can read more about this malware in an Android Security team blog post titled
    “Tizi: Detecting and Blocking Socially Engineered Spyware on Android.”'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年9月，安卓安全团队发现了Tizi，这是一种通过利用2012年和2013年发现的多个漏洞来对设备进行root的间谍软件，主要在非洲地区活动。一旦获得root权限，Tizi便可以利用这一访问权限记录WhatsApp、Skype和Viber等加密服务的通话内容，并监控Facebook、X、LinkedIn和Telegram等社交媒体上的活动。你可以在安卓安全团队的博客文章《Tizi：检测和阻止安卓平台上的社交工程间谍软件》中了解更多有关该恶意软件的信息。
- en: '**Testing Classifier Performance**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**测试分类器性能**'
- en: To evaluate how well machine learning classifiers can distinguish rooting malware
    from goodware, we tested 10 classifiers by feeding them various sets of features,
    as shown in [Table 7-1](ch07.xhtml#ch7tab1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估机器学习分类器区分rooting恶意软件与良性软件的能力，我们通过提供不同特征集来测试了10个分类器，如[表7-1](ch07.xhtml#ch7tab1)所示。
- en: '**Table 7-1:** Classifier Performance—Rooting Malware vs. Goodware'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** 分类器性能——Rooting恶意软件与良性软件'
- en: '| **Feature set** | **Best classifier** | **AUC** | **Precision** | **Recall**
    | **F1** | **FPR** | **FNR** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **特征集** | **最佳分类器** | **AUC** | **精确度** | **召回率** | **F1** | **假阳性率** | **假阴性率**
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| API package | GBDT | 0.9939 | 0.9324 | 0.9009 | 0.9164 | 0.0676 | 0.0146
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| API包 | GBDT | 0.9939 | 0.9324 | 0.9009 | 0.9164 | 0.0676 | 0.0146 |'
- en: '| Static (S) | XGBoost | 0.9811 | 0.8658 | 0.7783 | 0.8197 | 0.1342 | 0.0296
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 静态（S） | XGBoost | 0.9811 | 0.8658 | 0.7783 | 0.8197 | 0.1342 | 0.0296 |'
- en: '| Dynamic (D) | RF | 0.9065 | 0.8735 | 0.5271 | 0.6575 | 0.1265 | 0.0608 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 动态（D） | 随机森林（RF） | 0.9065 | 0.8735 | 0.5271 | 0.6575 | 0.1265 | 0.0608 |'
- en: '| S + D | XGBoost | 0.9848 | 0.8889 | 0.8079 | 0.8465 | 0.1111 | 0.0257 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| S + D | XGBoost | 0.9848 | 0.8889 | 0.8079 | 0.8465 | 0.1111 | 0.0257 |'
- en: '| API + S + D | XGBoost | 0.9974 | 0.9564 | 0.9187 | 0.9372 | 0.0436 | 0.0109
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D | XGBoost | 0.9974 | 0.9564 | 0.9187 | 0.9372 | 0.0436 | 0.0109
    |'
- en: '| TSG | XGBoost | 0.9927 | 0.9018 | 0.8896 | 0.8957 | 0.0982 | 0.0163 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| TSG | XGBoost | 0.9927 | 0.9018 | 0.8896 | 0.8957 | 0.0982 | 0.0163 |'
- en: '| LM | XGBoost | 0.9791 | 0.8375 | 0.7488 | 0.7906 | 0.1625 | 0.0335 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| LM | XGBoost | 0.9791 | 0.8375 | 0.7488 | 0.7906 | 0.1625 | 0.0335 |'
- en: '| FC | XGBoost | 0.9729 | 0.8507 | 0.7438 | 0.7937 | 0.1493 | 0.0341 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| FC | XGBoost | 0.9729 | 0.8507 | 0.7438 | 0.7937 | 0.1493 | 0.0341 |'
- en: '| CG | RF | 0.9571 | 0.8349 | 0.6724 | 0.7449 | 0.1651 | 0.0432 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| CG | 随机森林（RF） | 0.9571 | 0.8349 | 0.6724 | 0.7449 | 0.1651 | 0.0432 |'
- en: '| API + S + D + TSG | XGBoost | 0.9970 | 0.9337 | 0.9015 | 0.9173 | 0.0663
    | 0.0133 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + TSG | XGBoost | 0.9970 | 0.9337 | 0.9015 | 0.9173 | 0.0663
    | 0.0133 |'
- en: '| API + S + D + LM | XGBoost | 0.9972 | 0.9514 | 0.9163 | 0.9335 | 0.0486 |
    0.0113 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + LM | XGBoost | 0.9972 | 0.9514 | 0.9163 | 0.9335 | 0.0486 |
    0.0113 |'
- en: '| API + S + D + FC | XGBoost | 0.9972 | 0.9540 | 0.9187 | 0.9360 | 0.0460 |
    0.0110 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + FC | XGBoost | 0.9972 | 0.9540 | 0.9187 | 0.9360 | 0.0460 |
    0.0110 |'
- en: '| API + S + D + CG | XGBoost | 0.9971 | 0.9580 | 0.8990 | 0.9276 | 0.0420 |
    0.0136 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + CG | XGBoost | 0.9971 | 0.9580 | 0.8990 | 0.9276 | 0.0420 |
    0.0136 |'
- en: '| All features | XGBoost | 0.9970 | 0.9482 | 0.9015 | 0.9242 | 0.0518 | 0.0133
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 所有特征 | XGBoost | 0.9970 | 0.9482 | 0.9015 | 0.9242 | 0.0518 | 0.0133 |'
- en: '| Best late fusion | XGBoost | 0.9994 | 0.9854 | 0.9828 | **0.9840** | 0.0146
    | 0.0023 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 最佳晚期融合 | XGBoost | 0.9994 | 0.9854 | 0.9828 | **0.9840** | 0.0146 | 0.0023
    |'
- en: We first used a set of basic features derived from API packages, static analysis,
    and dynamic analysis (API, S, and D), as well as two combinations of these (S
    + D and API + S + D). The “Best classifier” column records the classifier with
    the best F1 score. As you can see, gradient-boosted decision tree (GDBT), XGBoost,
    and random forest (RF) classifiers perform best.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用了从API包、静态分析和动态分析（API、S和D）中得出的基本特征集，以及其中两种组合（S + D 和 API + S + D）。"最佳分类器"列记录了具有最佳F1得分的分类器。如你所见，梯度提升决策树（GBDT）、XGBoost和随机森林（RF）分类器的表现最佳。
- en: 'The table lists several performance metrics, all of which were introduced in
    [Chapter 5](ch05.xhtml): AUC, precision, recall, F1 score, false positive rate
    (FPR), and false negative rate (FNR). The F1 score is the most important of these,
    as it balances precision and recall. You can see that using API features alone
    already achieves a high F1 score (0.9164), outperforming the use of static features,
    dynamic features, or a combinations of these. Combining static, dynamic, and API
    features further improves the F1 score to 0.9372.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该表列出了几项性能指标，所有指标在[第5章](ch05.xhtml)中有介绍：AUC、精确率、召回率、F1分数、假阳性率（FPR）和假阴性率（FNR）。其中，F1分数是最重要的，因为它平衡了精确率和召回率。可以看到，单独使用API特征已经能够获得较高的F1分数（0.9164），超越了使用静态特征、动态特征或它们的组合。将静态、动态和API特征结合使用，F1分数进一步提高至0.9372。
- en: For the advanced features, we tested triadic suspicion graph–based features,
    landmark-based features, feature clustering features, and correlation graph–based
    features (TSG, LM, FC, and CG). We also combined each of these with the basic
    features. The results show that using just one kind of advanced feature achieves
    an F1 score ranging from 0.7449 to 0.8957, with TSG ranked the highest. When we
    add the basic features to the advanced features, performance significantly improves,
    with the best F1 score achieved by combining FC features with the basic features.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级特征，我们测试了基于三元疑似图（TSG）、基于地标的特征（LM）、特征聚类特征（FC）和基于关联图的特征（CG）。我们还将每种高级特征与基本特征结合使用。结果表明，仅使用一种高级特征就能获得0.7449到0.8957之间的F1分数，其中TSG排名最高。当我们将基本特征与高级特征结合时，性能显著提高，最好的F1分数是将FC特征与基本特征结合时获得的。
- en: 'Lastly, we combined all of the features using two methods: inputting all of
    them to each classifier and using late fusion to combine the predictions of seven
    classifiers, each using one kind of feature. *Late fusion* is a classification
    technique that combines the predictions made by multiple classifiers. Suppose,
    for instance, that we used three different classifiers to predict the probability
    that a given app is malicious. These three classifiers would each return a probability,
    *p*[1], *p*[2], and *p*[3], respectively. Late fusion tries to find weights *w*[1],
    *w*[2], and *w*[3] such that when their sum is greater than 0.5, the likelihood
    of the app being malicious is as high as possible. As the last two rows in [Table
    7-1](ch07.xhtml#ch7tab1) show, the best late fusion result outperforms all other
    methods, with an F1 score of 0.9840.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过两种方法将所有特征结合起来：将它们全部输入到每个分类器中，并使用晚期融合（late fusion）将七个分类器的预测结果合并，每个分类器使用一种特征。*晚期融合*是一种分类技术，它将多个分类器的预测结果进行组合。假设我们使用了三个不同的分类器来预测一个给定应用是否是恶意的，这三个分类器分别返回概率
    *p*[1]、*p*[2] 和 *p*[3]。晚期融合试图找到权重 *w*[1]、*w*[2] 和 *w*[3]，使得当它们的总和大于0.5时，应用是恶意的可能性最大。如[表7-1](ch07.xhtml#ch7tab1)的最后两行所示，最佳的晚期融合结果优于所有其他方法，F1分数为0.9840。
- en: We also tested the ability of each classifier to distinguish rooting malware
    from other kinds of malware. This ability can be advantageous; for instance, if
    a machine learning classifier flags an app as rooting malware, you can send it
    to a rooting malware specialist for analysis. You can see the inputs and their
    performance in [Table 7-2](ch07.xhtml#ch7tab2).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还测试了每个分类器区分Rooting恶意软件与其他类型恶意软件的能力。这项能力是有优势的；例如，如果一个机器学习分类器将某个应用标记为Rooting恶意软件，您可以将其发送给Rooting恶意软件专家进行分析。您可以在[表7-2](ch07.xhtml#ch7tab2)中看到输入和它们的表现。
- en: '**Table 7-2:** Classifier Performance—Rooting Malware vs. Other Malware'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7-2：** 分类器性能—Rooting恶意软件与其他恶意软件'
- en: '| **Feature set** | **Best classifier** | **AUC** | **Precision** | **Recall**
    | **F1** | **FPR** | **FNR** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **特征集** | **最佳分类器** | **AUC** | **精确率** | **召回率** | **F1** | **假阳性率** | **假阴性率**
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| API package | RF | 0.9801 | 0.9669 | 0.7883 | 0.8685 | 0.0331 | 0.0435 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| API包 | RF | 0.9801 | 0.9669 | 0.7883 | 0.8685 | 0.0331 | 0.0435 |'
- en: '| Static (S) | XGBoost | 0.9530 | 0.7890 | 0.6724 | 0.7261 | 0.2110 | 0.0621
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 静态 (S) | XGBoost | 0.9530 | 0.7890 | 0.6724 | 0.7261 | 0.2110 | 0.0621 |'
- en: '| Dynamic (D) | RF | 0.8686 | 0.8444 | 0.4680 | 0.6022 | 0.1556 | 0.0955 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 动态 (D) | RF | 0.8686 | 0.8444 | 0.4680 | 0.6022 | 0.1556 | 0.0955 |'
- en: '| S + D | RF | 0.9610 | 0.9085 | 0.6847 | 0.7809 | 0.0915 | 0.0587 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| S + D | RF | 0.9610 | 0.9085 | 0.6847 | 0.7809 | 0.0915 | 0.0587 |'
- en: '| API + S + D | XGBoost | 0.9898 | 0.9472 | 0.8842 | 0.9146 | 0.0528 | 0.0223
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D | XGBoost | 0.9898 | 0.9472 | 0.8842 | 0.9146 | 0.0528 | 0.0223
    |'
- en: '| TSG | RF | 0.9717 | 0.9358 | 0.7883 | 0.8557 | 0.0642 | 0.0437 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| TSG | RF | 0.9717 | 0.9358 | 0.7883 | 0.8557 | 0.0642 | 0.0437 |'
- en: '| LM | XGBoost | 0.9466 | 0.7922 | 0.6010 | 0.6835 | 0.2078 | 0.0743 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| LM | XGBoost | 0.9466 | 0.7922 | 0.6010 | 0.6835 | 0.2078 | 0.0743 |'
- en: '| FC | RF | 0.9139 | 0.8796 | 0.5936 | 0.7088 | 0.1204 | 0.0746 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| FC | RF | 0.9139 | 0.8796 | 0.5936 | 0.7088 | 0.1204 | 0.0746 |'
- en: '| CG | RF | 0.8452 | 0.7093 | 0.5049 | 0.5899 | 0.2907 | 0.0914 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| CG | RF | 0.8452 | 0.7093 | 0.5049 | 0.5899 | 0.2907 | 0.0914 |'
- en: '| API + S + D + TSG | XGBoost | 0.9896 | 0.9395 | 0.8793 | 0.9084 | 0.0605
    | 0.0233 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + TSG | XGBoost | 0.9896 | 0.9395 | 0.8793 | 0.9084 | 0.0605
    | 0.0233 |'
- en: '| API + S + D + LM | XGBoost | 0.9897 | 0.9395 | 0.8793 | 0.9084 | 0.0605 |
    0.0233 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + LM | XGBoost | 0.9897 | 0.9395 | 0.8793 | 0.9084 | 0.0605 |
    0.0233 |'
- en: '| API + S + D + FC | XGBoost | 0.9898 | 0.9446 | 0.8818 | 0.9121 | 0.0554 |
    0.0228 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + FC | XGBoost | 0.9898 | 0.9446 | 0.8818 | 0.9121 | 0.0554 |
    0.0228 |'
- en: '| API + S + D + CG | XGBoost | 0.9896 | 0.9523 | 0.8842 | 0.9170 | 0.0477 |
    0.0223 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + CG | XGBoost | 0.9896 | 0.9523 | 0.8842 | 0.9170 | 0.0477 |
    0.0223 |'
- en: '| All features | XGBoost | 0.9893 | 0.9333 | 0.8966 | 0.9146 | 0.0667 | 0.0200
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 所有特征 | XGBoost | 0.9893 | 0.9333 | 0.8966 | 0.9146 | 0.0667 | 0.0200 |'
- en: '| Best late fusion | XGBoost | 0.9988 | 0.9927 | 0.9409 | **0.9656** | 0.0073
    | 0.0114 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 最佳后期融合 | XGBoost | 0.9988 | 0.9927 | 0.9409 | **0.9656** | 0.0073 | 0.0114
    |'
- en: Again, API features worked the best of any individual basic feature, but combining
    all of the basic features further improved the F1 score. Of the advanced features,
    TSG again had the highest F1 score, though adding basic features to each kind
    of advanced feature significantly improved performance. Specifically, combining
    CG features with the basic features achieved the best F1 score, a result that
    differs from the best way to distinguish rooting malware from goodware. When we
    combined all basic and advanced features, late fusion results again outperformed
    all classifiers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，API 特征是所有基本特征中表现最好的，但将所有基本特征结合起来进一步提高了 F1 分数。在高级特征中，TSG 再次取得了最高的 F1 分数，尽管将基本特征添加到每种高级特征中显著提高了性能。具体来说，将
    CG 特征与基本特征结合取得了最佳的 F1 分数，这一结果与区分根植恶意软件和良性软件的最佳方法不同。当我们将所有基本和高级特征结合时，后期融合的结果再次超越了所有分类器。
- en: '**Rooting Malware vs. Goodware**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**根植恶意软件与良性软件**'
- en: We’ll use a malware family called Rootnik to illustrate how the features of
    rooting malware differ from those of goodware apps. Rootnik delivers its rooting
    malware through a variety of apps, such as *com.web.sdfile* (v2, f214), that claim
    to manage documents, videos, pictures, music, and other files on a user’s device.
    Once installed, the app reaches out to a command-and-control server, where it
    downloads code at will to perform a veritable laundry list of malicious acts,
    from pushing pornography and ads to the device to silently installing new apps.
    It embeds itself into a wide variety of legitimate applications and, once a device
    is rooted, steals Wi-Fi information including passwords and keys, the user’s location,
    and the device’s MAC address.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 Rootnik 的恶意软件家族来说明根植恶意软件的特征如何与良性软件应用的特征不同。Rootnik 通过各种应用程序传播其根植恶意软件，例如
    *com.web.sdfile*（v2, f214），这些应用宣称可以管理用户设备上的文档、视频、图片、音乐和其他文件。安装后，应用会连接到一个指挥与控制服务器，随意下载代码执行各种恶意行为，从向设备推送色情内容和广告到悄悄安装新应用程序。它将自己嵌入到各种合法应用程序中，一旦设备被根植，就会窃取
    Wi-Fi 信息，包括密码和密钥、用户的位置以及设备的 MAC 地址。
- en: '![Image](../images/ch07fig01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch07fig01.jpg)'
- en: '*Figure 7-1: Top 20 features that best distinguish Android rooting malware
    from goodware*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：最佳区分 Android 根植恶意软件与良性软件的 20 个特征*'
- en: In this section, we will consider a set of 1,829 Rootnik hashes. Of these, 444
    are distinct, in the sense that they lead to different feature vectors of the
    type discussed in [Chapters 5](ch05.xhtml) and [6](ch06.xhtml). We’ll cover the
    20 features that best distinguish between rooting malware and goodware using the
    Extra-Trees classifier (short for extremely randomized trees, a variant of the
    random forest classifier), which randomly chooses multiple subsets of the training
    set, learns a decision tree for each subset, and then aggregates the decision
    trees. [Figure 7-1](ch07.xhtml#ch7fig1) shows these features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑一组 1,829 个 Rootnik 哈希值。在这些哈希值中，有 444 个是不同的，它们生成的特征向量不同，属于在[第 5 章](ch05.xhtml)和[第
    6 章](ch06.xhtml)中讨论的那类。我们将使用 Extra-Trees 分类器（即极端随机树，一种随机森林分类器的变体）来介绍最能区分根植恶意软件和良性软件的
    20 个特征，该分类器随机选择训练集的多个子集，为每个子集学习一棵决策树，然后聚合所有决策树。[图 7-1](ch07.xhtml#ch7fig1)展示了这些特征。
- en: They include nine static permission-related features, a static feature based
    on the `sendnet` method, a static API call feature, six suspicion score features,
    two suspicion rank features, and one correlation graph feature. We will explain
    `sendnet` in more detail later in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 它们包括九个静态权限相关特性，一个基于 `sendnet` 方法的静态特性，一个静态 API 调用特性，六个可疑分数特性，两个可疑排名特性，以及一个关联图特性。我们将在本章稍后详细解释
    `sendnet`。
- en: '***Permission-Related Features***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***与权限相关的特性***'
- en: '[Listing 7-1](ch07.xhtml#ch7lis1) shows every permission requested by Rootnik
    in the app’s manifest file.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-1](ch07.xhtml#ch7lis1) 显示了 Rootnik 在应用清单文件中请求的每个权限。'
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: All requested permissions in Rootnik*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-1：Rootnik 中请求的所有权限*'
- en: Apps seek the `INSTALL_PACKAGES` privileged permission when they want to install
    other packages or apps during runtime. Over the years, malware developers have
    tried to use this to sideload new packages. One big advantage of this permission
    is that it can be used to install apps without user consent, unlike its unprivileged
    counterpart `REQUEST_INSTALL_PACKAGES`. Sideloaded apps can then request arbitrary
    permissions and form the launchpad for even more malicious attacks. The classifier’s
    output shows that while 20.27 percent of rooting malware requests this permission,
    only 0.22 percent of goodware requests it. This is expected, as the privileged
    permission is only available to apps that have already successfully elevated their
    privilege level above that of regular apps.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 应用在运行时希望安装其他包或应用时，会寻求 `INSTALL_PACKAGES` 特权权限。多年来，恶意软件开发者试图利用此权限侧载新的应用包。此权限的一大优势是，它可以在没有用户同意的情况下安装应用，而不像它的非特权对等权限
    `REQUEST_INSTALL_PACKAGES`。侧载的应用随后可以请求任意权限，为更多的恶意攻击提供跳板。分类器的输出显示，虽然 20.27% 的 root
    恶意软件请求此权限，但只有 0.22% 的良性软件请求此权限。这是可以预见的，因为特权权限仅适用于那些已成功提升其权限级别高于普通应用的应用。
- en: The `GET_PACKAGE_SIZE` permission allows an app to get the package size of other
    apps. You can see from the classifier’s output that 30.75 percent of rooting malware
    requests this permission, compared to only 1.86 percent of goodware. Historically,
    Android used the `GET_PACKAGE_SIZE` permission to protect only a single Android
    API (`PackageManager.getPackageSizeInfo`), which was removed in Android 8.0 (Oreo).
    Spot-checking a few rooting apps showed that while they request this permission,
    they don’t seem to use it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET_PACKAGE_SIZE` 权限允许应用获取其他应用的包大小。从分类器的输出可以看出，30.75% 的 root 恶意软件请求此权限，而只有
    1.86% 的良性软件请求此权限。历史上，Android 使用 `GET_PACKAGE_SIZE` 权限来保护单一的 Android API（`PackageManager.getPackageSizeInfo`），该
    API 在 Android 8.0（Oreo）中被移除。对一些 root 应用的抽查显示，尽管它们请求了此权限，但似乎并未使用它。'
- en: The `KILL_BACKGROUND_PROCESSES` permission allows an Android app to kill processes
    running silently in the background. There are both legitimate and malicious reasons
    for apps to request this permission. For instance, a benign app may want this
    permission in order to free up system resources in cases when another app is running
    in the background but not being actively used. On the other hand, malicious apps
    may request this permission in order to kill security processes running in the
    background. You can see that 28.33 percent of rooting malware requests this permission,
    but only 2.04 percent of goodware does.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`KILL_BACKGROUND_PROCESSES` 权限允许 Android 应用终止在后台默默运行的进程。应用请求此权限的原因有合法和恶意两种。例如，一个良性应用可能希望获取此权限，以便在另一个应用在后台运行但未被积极使用时释放系统资源。另一方面，恶意应用可能请求此权限以终止后台运行的安全进程。从分类器的输出可以看出，28.33%
    的 root 恶意软件请求此权限，但只有 2.04% 的良性软件请求此权限。'
- en: Another important permission is `GET_TASKS`. Although deprecated in 2014, it
    lets an app identify the running processes on a device. As you can see from the
    classifier’s output, 67.81 percent of rooting malware requests this permission,
    compared to a mere 13.57 percent of goodware. Thus, an app that requests it is
    almost five times more likely to be rooting malware than goodware. Android has
    severely restricted this feature to further improve sandboxing between apps.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的权限是 `GET_TASKS`。尽管该权限在 2014 年已被弃用，但它允许应用识别设备上正在运行的进程。从分类器的输出可以看出，67.81%
    的 root 恶意软件请求此权限，而只有 13.57% 的良性软件请求此权限。因此，申请此权限的应用更可能是 root 恶意软件，而不是良性软件，比例大约是
    5:1。为了进一步增强应用间的沙箱隔离，Android 严格限制了此功能。
- en: Apps request the `MOUNT_UNMOUNT_FILESYSTEMS` permission to mount or unmount
    the device’s filesystems. This also enables them to add new files, delete files,
    or modify files on parts of the device that were previously restricted. This permission
    is frequently used to drop the BusyBox executable in the */system/bin* directory.
    As BusyBox makes many standard Linux commands available in one executable, it’s
    a nice way to get a lot of standard malware capabilities onto a rooted device
    without having to download, copy, and install too many individual executable files.
    The malware itself may then use these capabilities as needed. The probability
    of the `MOUNT_UNMOUNT_FILESYSTEMS` permission being requested by rooting malware
    is 42.65 percent, compared to 4.21 percent for goodware, as unprivileged apps
    can’t use the permission at all.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 应用请求 `MOUNT_UNMOUNT_FILESYSTEMS` 权限以挂载或卸载设备的文件系统。这也使它们能够在以前被限制的设备部分添加新文件、删除文件或修改文件。此权限常用于将
    BusyBox 可执行文件放置在 */system/bin* 目录中。由于 BusyBox 将许多标准 Linux 命令集成在一个可执行文件中，它是将大量标准恶意软件功能加载到已
    root 的设备上的一种有效方式，而无需下载、复制和安装太多独立的可执行文件。恶意软件本身可以根据需要使用这些功能。请求 `MOUNT_UNMOUNT_FILESYSTEMS`
    权限的 root 恶意软件的概率为 42.65%，而良性应用的概率仅为 4.21%，因为未特权的应用根本无法使用此权限。
- en: The `SYSTEM_ALERT_WINDOW` permission lets an app display pop-up alert windows
    even if the app isn’t currently being used, offering clear and ample opportunity
    for abuse via phishing. We haven’t seen cases of such misuse in rooting apps,
    but many rooting malware apps may bundle their code into benign apps that use
    this permission for their normal operation. Rooting malware is far more likely
    to request this feature than goodware (53.76 percent versus 11.13 percent).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYSTEM_ALERT_WINDOW` 权限允许应用在未被使用时仍能显示弹出警告窗口，这为通过钓鱼攻击提供了明显且充分的滥用机会。我们尚未在 root
    应用中看到此类滥用案例，但许多恶意 root 应用可能将其代码打包到正常使用该权限的无害应用中。恶意 root 软件请求此权限的可能性远高于良性软件（53.76%
    对比 11.13%）。'
- en: The `RECEIVE_BOOT_COMPLETED` permission allows an app to know when the system
    has completed a boot or reboot. Both goodware and malware apps can use this broadcast
    message to start when the boot finishes. The classifier’s output shows that 66.41
    percent of rooting malware requests this permission, compared to 24.38 percent
    of goodware. Malware seems to be more likely to want to restart immediately after
    a reboot than goodware, which usually starts only when the user wants to interact
    with it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`RECEIVE_BOOT_COMPLETED` 权限允许应用知道系统何时完成启动或重启。良性应用和恶意应用都可以使用此广播消息在启动完成时启动。分类器的输出显示，66.41%
    的恶意 root 应用请求此权限，而良性应用仅为 24.38%。恶意软件似乎更可能在重启后立即请求重启，而良性软件通常只有在用户想要与之交互时才会启动。'
- en: 'Malicious apps also often request the `READ_PHONE_STATE` and `ACCESS_WIFI_STATE`
    permissions. Benign apps might use the first of these to get the phone’s IMEI
    number, as well as information about the kinds of networks the phone is connected
    to. For example, mobile payment apps may need this type of information to verify
    the identity of the device sending a payment request. Malware can use this permission
    to capture private information about a victim’s phone and is more than twice as
    likely to request it: 35.98 percent of goodware requests the `READ_PHONE_STATE`
    permission, compared to 83.01 percent of rooting malware. Similarly, hackers can
    use `ACCESS_WIFI_STATE` to capture Wi-Fi service set identifiers (SSIDs). While
    80.57 percent of rooting malware requests this permission, its probability of
    being requested by goodware is half this (40.02 percent).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意应用也经常请求 `READ_PHONE_STATE` 和 `ACCESS_WIFI_STATE` 权限。无害应用可能使用第一个权限获取手机的 IMEI
    号以及有关手机连接的网络类型的信息。例如，移动支付应用可能需要这些信息来验证发送支付请求的设备身份。恶意软件可以使用此权限捕获受害者手机的私人信息，并且请求此权限的概率是良性应用的两倍多：35.98%
    的良性软件请求 `READ_PHONE_STATE` 权限，而 83.01% 的 root 恶意软件请求此权限。同样，黑客可以使用 `ACCESS_WIFI_STATE`
    捕获 Wi-Fi 服务集标识符（SSID）。虽然 80.57% 的 root 恶意软件请求此权限，但良性应用请求此权限的概率只有其一半（40.02%）。
- en: '***Network-Based Features***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基于网络的功能***'
- en: In addition to the permission-related features, features related to the app’s
    network communications can help machine learning algorithms identify rooting malware.
    For instance, the static `sendnet` feature is set to the number of times that
    the application’s code invokes the `sendnet` method to send data over the internet.
    We can collect this kind of information by running the Android app within an Android
    sandbox environment called DroidBox that enables us to run Android apps safely
    and gather dynamic features of the kind mentioned in [Chapter 6](ch06.xhtml).
    [Listing 7-2](ch07.xhtml#ch7lis2) shows the Rootnik malware calling `sendnet`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了权限相关特征外，与应用网络通信相关的特征可以帮助机器学习算法识别根植恶意软件。例如，静态的`sendnet`特征记录了应用代码调用`sendnet`方法通过互联网发送数据的次数。我们可以通过在名为DroidBox的Android沙箱环境中运行Android应用来收集这种信息，DroidBox可以安全地运行Android应用并收集如[第6章](ch06.xhtml)中所提到的动态特征。[列表7-2](ch07.xhtml#ch7lis2)显示了Rootnik恶意软件调用`sendnet`。
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: The* sendnet *method, used to send data over the internet, in
    Rootnik*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-2：在Rootnik中用于通过互联网发送数据的*sendnet*方法*'
- en: The DroidBox output shows Rootnik sending traffic to the external URL *abc.jxyxteam.com*,
    which likely belongs to a site operated by the malware developers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DroidBox输出显示Rootnik将流量发送到外部网址*abc.jxyxteam.com*，该网址很可能属于恶意软件开发者运营的站点。
- en: The value of the `sendnet` feature is far more likely to be greater than zero
    for rooting malware than for goodware. The classifier’s output shows that 7.65
    percent of malware uses this method, compared to only 0.057 percent of goodware,
    meaning that a rooting malware app is about 134 times more likely than goodware
    to use it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendnet`功能的值对于根植恶意软件来说远远大于零，而对于良性软件来说则较小。分类器的输出显示，7.65%的恶意软件使用此方法，而仅有0.057%的良性软件使用，这意味着根植恶意软件应用使用此方法的可能性是良性软件的约134倍。'
- en: Another feature used in distinguishing rooting malware from goodware is `org.apache.http.conn.scheme`,
    which captures the number of times the app’s code invokes the HTTP or HTTPS protocols.
    Rooting malware invokes this feature far more often than goodware (33.27 percent
    versus a mere 1.59 percent). In [Listing 7-3](ch07.xhtml#ch7lis3), you can see
    the Rootnik rooting malware calling the `org.apache.http.conn.scheme` API.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用来区分根植恶意软件和良性软件的特征是`org.apache.http.conn.scheme`，它捕获了应用代码调用HTTP或HTTPS协议的次数。根植恶意软件调用此特征的频率远高于良性软件（33.27%对比仅1.59%）。在[列表7-3](ch07.xhtml#ch7lis3)中，你可以看到Rootnik根植恶意软件调用了`org.apache.http.conn.scheme`
    API。
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: The org.apache.http.conn.scheme API called in Rootnik*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-3：Rootnik中调用的org.apache.http.conn.scheme API*'
- en: Keep in mind that there is nothing inherently malicious about using this method,
    which can support both benign and malicious traffic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用这种方法本身并不带有恶意，它可以支持善意和恶意的流量。
- en: '**Rooting Malware vs. Other Malware**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**根植恶意软件与其他恶意软件**'
- en: Now let’s discuss the features that best distinguish rooting malware from other
    forms of malware. [Figure 7-2](ch07.xhtml#ch7fig2) shows the strongest 20 features
    for this purpose identified by the Extra-Trees classifier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下哪些特征能最好地区分根植恶意软件与其他类型的恶意软件。[图7-2](ch07.xhtml#ch7fig2)展示了Extra-Trees分类器为此目的识别出的最强的20个特征。
- en: These include 10 permission-related features, 8 suspicion score or suspicion
    rank features, 1 API-related feature, and 1 landmark-based feature. In this section,
    we’ll cover some of the highlights. Because rooting malware is much more similar
    to other forms of malware than to goodware, the differences discussed here are
    smaller.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征包括10个权限相关特征，8个怀疑分数或怀疑等级特征，1个API相关特征，以及1个基于地标的特征。在这一部分，我们将介绍一些重点内容。因为根植恶意软件与其他类型的恶意软件相比，更类似于其他恶意软件而非良性软件，所以在此讨论的差异较小。
- en: '***Permission-Related Features***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***权限相关特征***'
- en: Ten permissions help the Extra-Trees classifier separate rooting malware from
    other malware. The first is `GET_PACKAGE_SIZE`. Apps that request this permission
    are far more likely to be rooting malware than other forms of malware; 30.15 percent
    of rooting malware requests it, compared to only 7.83 percent of other malware.
    However, the fact that some apps request this permission isn’t necessarily malicious.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 十个权限有助于Extra-Trees分类器区分根植恶意软件与其他恶意软件。第一个是`GET_PACKAGE_SIZE`。请求此权限的应用更可能是根植恶意软件，而非其他类型的恶意软件；30.15%的根植恶意软件请求此权限，而其他恶意软件的请求比例仅为7.83%。然而，一些应用请求此权限并不一定意味着它们是恶意的。
- en: The next four, `MOUNT_UNMOUNT_FILESYSTEMS`, `GET_TASKS`, `ACCESS_WIFI_STATE`,
    and `INSTALL_PACKAGES`, were also among the 20 features most useful for distinguishing
    rooting malware from goodware. Two additional permissions rooting malware requests
    slightly more often than other malware are `READ_LOGS` and `RESTART_PACKAGES`.
    The `READ_LOGS` permission grants access to all systems logs for privileged apps,
    but only an app’s own logs for unprivileged apps; `RESTART_PACKAGES` has been
    deprecated since API 15\. In all of these cases, the differences in the percentages
    of rooting malware versus other types of malware requesting the permissions aren’t
    huge, and using any one of these features individually to classify apps as rooting
    malware rather than some other kind malware will likely lead to errors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个权限，`MOUNT_UNMOUNT_FILESYSTEMS`、`GET_TASKS`、`ACCESS_WIFI_STATE` 和 `INSTALL_PACKAGES`，也出现在区分
    Root 恶意软件与良性软件的 20 个最有用特性中。Root 恶意软件请求的两个额外权限是 `READ_LOGS` 和 `RESTART_PACKAGES`，它们比其他恶意软件稍微更常请求。`READ_LOGS`
    权限允许特权应用访问所有系统日志，而普通应用只能访问自己的日志；`RESTART_PACKAGES` 从 API 15 开始已被弃用。在所有这些情况下，Root
    恶意软件请求这些权限与其他类型恶意软件请求这些权限的比例差异并不大，单独使用这些特性来将应用分类为 Root 恶意软件而不是其他类型的恶意软件，可能会导致错误。
- en: '![Image](../images/ch07fig02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch07fig02.jpg)'
- en: '*Figure 7-2: Top 20 features that best distinguish Android rooting malware
    from other forms of malware*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：最佳区分 Android Root 恶意软件与其他恶意软件的前 20 个特性*'
- en: Lastly, we have already seen that `READ_PHONE_STATE` and `RECEIVE_BOOT_COMPLETED`
    were important in distinguishing rooting malware from good-ware. Interestingly,
    [Figure 7-2](ch07.xhtml#ch7fig2) shows that rooting malware is slightly less likely
    to request these permissions than other forms of malware, which might use them
    to start whenever the system is rebooted or to capture IMSI and IMEI information
    about the device.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经看到，`READ_PHONE_STATE` 和 `RECEIVE_BOOT_COMPLETED` 在区分 Root 恶意软件与良性软件时非常重要。有趣的是，[图
    7-2](ch07.xhtml#ch7fig2)显示 Root 恶意软件请求这些权限的可能性略低于其他类型的恶意软件，后者可能利用这些权限在系统重启时启动或获取设备的
    IMSI 和 IMEI 信息。
- en: '***Other Features***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他特性***'
- en: The suspicion score and suspicion rank features play a far more important role
    in distinguishing rooting malware from other forms of malware than they did in
    the case of separating rooting malware from goodware. These more technical features
    seem able to make fine-grained distinctions that the coarser permission-related
    features miss.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 疑似分数和疑似排名特性在区分 Root 恶意软件与其他恶意软件时，比在区分 Root 恶意软件与良性软件时更为重要。这些更具技术性的特性似乎能够做出更精细的区分，而粗略的基于权限的特性可能会遗漏这些细微差异。
- en: The API feature *org.apache.http.conn.scheme*, which captures the number of
    times in the code that the app invokes the HTTP or HTTPS protocols, is also helpful
    here. While 63.27 percent of rooting malware makes at least one call to one of
    these protocols in its code, other forms of malware don’t use the Apache libraries
    nearly as often (though they may use other libraries for the same purpose). This
    class represents a number of protocols and describes protocol properties like
    which socket to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: API 特性 *org.apache.http.conn.scheme*，它捕获应用在代码中调用 HTTP 或 HTTPS 协议的次数，也在这里很有帮助。虽然
    63.27% 的 Root 恶意软件在其代码中至少调用过一次这些协议，但其他类型的恶意软件并没有那么频繁使用 Apache 库（尽管它们可能使用其他库来完成相同的任务）。这个类表示了多个协议，并描述了诸如使用哪个套接字等协议属性。
- en: '**DroidDream: A Case Study**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**DroidDream：案例分析**'
- en: DroidDream was the first known rooting malware on the Android platform. In this
    section, we’ll apply the detection strategies learned in the earlier part of this
    chapter to analyze it. [Listing 7-4](ch07.xhtml#ch7lis4) shows the permissions
    the app requests in *com.fall.down* (v1, 7d1d).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: DroidDream 是已知的第一个 Android 平台上的 Root 恶意软件。在这一部分，我们将应用本章前面学习的检测策略来分析它。[列表 7-4](ch07.xhtml#ch7lis4)显示了应用在
    *com.fall.down*（v1，7d1d）中请求的权限。
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-4: The permissions used in the DroidDream malware*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-4：DroidDream 恶意软件中使用的权限*'
- en: We see that DroidDream asks for only a few of the 20 permissions discussed earlier
    in this chapter. The ones that our analysis deemed significant for recognizing
    rooting malware are `READ_PHONE_STATE` and `ACCESS_WIFI_STATE`. In [Listing 7-5](ch07.xhtml#ch7lis5),
    you can see the app using `READ_PHONE_STATE` to request IMEI information from
    the device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，DroidDream 只请求了本章前面讨论的 20 个权限中的一小部分。我们分析认为，在识别 Root 恶意软件时，`READ_PHONE_STATE`
    和 `ACCESS_WIFI_STATE` 是关键。你可以在[列表 7-5](ch07.xhtml#ch7lis5)中看到该应用使用 `READ_PHONE_STATE`
    请求设备的 IMEI 信息。
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-5: IMEI access by the DroidDream malware*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-5：DroidDream 恶意软件访问 IMEI*'
- en: '[Listing 7-6](ch07.xhtml#ch7lis6) contains DroidBox output that shows the DroidDream
    app accessing IMSI information, another activity that requires the `READ_PHONE_STATE`
    permission. Later in the code, the app sends both the IMEI and IMSI to its command-and-control
    server.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-6](ch07.xhtml#ch7lis6)包含了 DroidBox 输出，显示 DroidDream 应用访问 IMSI 信息，这是另一个需要
    `READ_PHONE_STATE` 权限的活动。在代码后面，应用将 IMEI 和 IMSI 一同发送到其指挥控制服务器。'
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-6: IMSI access by the DroidDream malware*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6：DroidDream 恶意软件访问 IMSI*'
- en: The app also collects information about the device hardware and operating system,
    which requires the `INTERNET` permission. DroidDream uses this permission to connect
    to various external URLs, too. [Listing 7-7](ch07.xhtml#ch7lis7) shows the list
    of URLs included in the DroidDream code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用还收集有关设备硬件和操作系统的信息，这需要 `INTERNET` 权限。DroidDream 也使用该权限连接到各种外部 URL。[列表 7-7](ch07.xhtml#ch7lis7)
    显示了 DroidDream 代码中包含的 URL 列表。
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-7: External URLs accessed by the DroidDream malware*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：DroidDream 恶意软件访问的外部 URL*'
- en: Individually, none of these features provides a smoking gun establishing that
    DroidDream is malicious. However, their collective presence is enough for our
    ensemble-based machine learning algorithm to label it as such. A security analyst
    could then examine the malware to find conclusive proof (for example, the `runExploid`
    method, shown in [Listing 7-6](ch07.xhtml#ch7lis6)). If they did so, they’d determine
    that DroidDream roots phones with the so-called Rage-Against-the-Cage exploit,
    then uses its root privileges to install another app with elevated privileges.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，这些特性并不足以证明 DroidDream 是恶意的。然而，它们的共同存在足以让我们的基于集成的机器学习算法将其标记为恶意软件。然后，安全分析师可以检查恶意软件以找到确凿的证据（例如，`runExploid`
    方法，如 [列表 7-6](ch07.xhtml#ch7lis6) 所示）。如果他们这样做，他们将发现 DroidDream 利用所谓的 Rage-Against-the-Cage
    漏洞进行 root 操作，然后使用其 root 权限安装另一个具有提升权限的应用。
- en: '**Up Next**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**接下来**'
- en: In this chapter, we showed that it’s possible to achieve high levels of predictive
    efficacy in malware detection using ensemble late fusion, which has a significantly
    higher performance than any other classifier. We also showed that while all feature
    types help separate rooting malware from goodware, as well as from other forms
    of malware, the advanced features covered in [Chapter 6](ch06.xhtml) do especially
    well. In particular, the TSG suspicion scores and suspicion ranks make the biggest
    contribution to ensembles. Permissions also proved important.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了通过集成晚期融合（ensemble late fusion）方法，在恶意软件检测中可以实现高水平的预测效果，且其性能显著高于其他任何分类器。我们还展示了，尽管所有特征类型都有助于将
    root 恶意软件与良性软件以及其他类型的恶意软件区分开，但在 [第 6 章](ch06.xhtml) 中讨论的高级特征特别有效。特别是，TSG 怀疑分数和怀疑排名对集成方法的贡献最大。权限也被证明很重要。
- en: 'The next chapter introduces detection techniques for another widely prevalent
    form of Android malware: spyware, which gathers personal information and uses
    it for a variety of nefarious purposes.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了另一种广泛流行的 Android 恶意软件——间谍软件的检测技术，它收集个人信息并用于多种恶意目的。
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[*OceanofPDF.com*](https://oceanofpdf.com)'
