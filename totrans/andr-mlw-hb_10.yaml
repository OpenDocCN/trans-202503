- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ROOTING MALWARE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Malware developers often seek ways of elevating their apps’ privileges to gain
    root access, which requires a privilege escalation exploit of some sort. Once
    operating as root, malware can use app and system resources to perform operations
    such as installing system-level applications, accessing other apps’ protected
    files, and modifying filesystem permissions to allow other malicious apps to view
    sensitive data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We covered multiple examples of rooting malware in [Chapter 2](ch02.xhtml).
    In this chapter, we’ll first discuss some well-known rooting malware families
    we haven’t yet explored. Then we’ll examine the performance of different machine
    learning techniques used to separate rooting malware from goodware, as well as
    from other forms of Android malware, and the key features used to do so. Though
    we’ll use the Rootnik rooting malware as an example throughout the chapter, we’ll
    also apply the detection techniques to the DroidDream malware.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Rooting Malware Families**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To the best of our knowledge, ZNIU was the first rooting malware to leverage
    the Dirty COW (copy-on-write) vulnerability, which allows privilege escalation
    in the Linux kernel. According to Trend Micro’s blog post “ZNIU: First Android
    Malware to Exploit Dirty COW,” it was distributed via over 1,200 apps and through
    infected websites. Once the app was installed on a device, it reached out to a
    command-and-control server and engaged in transactions with the compromised device’s
    mobile carrier through an SMS-enabled payment service, incurring charges to a
    company located in China. ZNIU used root privileges to circumvent Android’s default
    workflow, which requires user consent to grant an app SMS-related permissions.
    Some versions of ZNIU leveraged exploits other than Dirty COW, such as Iovyroot,
    which targets a Linux kernel vulnerability, or various exploits from the KingoRoot
    rooting app.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In 2017, researchers at Kaspersky Lab discovered Dvmap. Its authors first uploaded
    a benign app to Google Play and later updated it to a malicious version, a behavior
    common in malware because it helps the app build a user base without raising suspicion.
    The authors would make the malicious version available for short periods and then
    replace it with a benign version.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Dvmap was the first rooting malware sample known to use code injection techniques.
    It would substitute the executable file */system/bin/ip* with a completely new
    file that contained malicious functionality, then inject code to execute the new
    file into two system libraries associated with Android’s Dalvik and ART runtimes,
    ensuring that it would run with elevated privileges. Replacing the file, and the
    subsequent code injection into the system libraries, required using a privilege
    escalation exploit. You can read more about this malware in the Kaspersky blog
    post “Dvmap: Android Malware with a New Technique for Controlling Devices Appears
    on Google Play.”'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In September 2017, the Android Security team discovered Tizi, which roots devices,
    mostly in Africa, to carry out spyware operations by leveraging a number of vulnerabilities
    discovered in 2012 and 2013\. Once it has obtained root privileges, Tizi uses
    this access to record calls on encrypted services such as WhatsApp, Skype, and
    Viber and monitor social media activity on Facebook, X, LinkedIn, and Telegram.
    You can read more about this malware in an Android Security team blog post titled
    “Tizi: Detecting and Blocking Socially Engineered Spyware on Android.”'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing Classifier Performance**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To evaluate how well machine learning classifiers can distinguish rooting malware
    from goodware, we tested 10 classifiers by feeding them various sets of features,
    as shown in [Table 7-1](ch07.xhtml#ch7tab1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Classifier Performance—Rooting Malware vs. Goodware'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature set** | **Best classifier** | **AUC** | **Precision** | **Recall**
    | **F1** | **FPR** | **FNR** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| API package | GBDT | 0.9939 | 0.9324 | 0.9009 | 0.9164 | 0.0676 | 0.0146
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| Static (S) | XGBoost | 0.9811 | 0.8658 | 0.7783 | 0.8197 | 0.1342 | 0.0296
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| Dynamic (D) | RF | 0.9065 | 0.8735 | 0.5271 | 0.6575 | 0.1265 | 0.0608 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| S + D | XGBoost | 0.9848 | 0.8889 | 0.8079 | 0.8465 | 0.1111 | 0.0257 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| API + S + D | XGBoost | 0.9974 | 0.9564 | 0.9187 | 0.9372 | 0.0436 | 0.0109
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| TSG | XGBoost | 0.9927 | 0.9018 | 0.8896 | 0.8957 | 0.0982 | 0.0163 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: '| LM | XGBoost | 0.9791 | 0.8375 | 0.7488 | 0.7906 | 0.1625 | 0.0335 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| FC | XGBoost | 0.9729 | 0.8507 | 0.7438 | 0.7937 | 0.1493 | 0.0341 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| CG | RF | 0.9571 | 0.8349 | 0.6724 | 0.7449 | 0.1651 | 0.0432 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + TSG | XGBoost | 0.9970 | 0.9337 | 0.9015 | 0.9173 | 0.0663
    | 0.0133 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + LM | XGBoost | 0.9972 | 0.9514 | 0.9163 | 0.9335 | 0.0486 |
    0.0113 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + FC | XGBoost | 0.9972 | 0.9540 | 0.9187 | 0.9360 | 0.0460 |
    0.0110 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + CG | XGBoost | 0.9971 | 0.9580 | 0.8990 | 0.9276 | 0.0420 |
    0.0136 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| All features | XGBoost | 0.9970 | 0.9482 | 0.9015 | 0.9242 | 0.0518 | 0.0133
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| Best late fusion | XGBoost | 0.9994 | 0.9854 | 0.9828 | **0.9840** | 0.0146
    | 0.0023 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: We first used a set of basic features derived from API packages, static analysis,
    and dynamic analysis (API, S, and D), as well as two combinations of these (S
    + D and API + S + D). The “Best classifier” column records the classifier with
    the best F1 score. As you can see, gradient-boosted decision tree (GDBT), XGBoost,
    and random forest (RF) classifiers perform best.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The table lists several performance metrics, all of which were introduced in
    [Chapter 5](ch05.xhtml): AUC, precision, recall, F1 score, false positive rate
    (FPR), and false negative rate (FNR). The F1 score is the most important of these,
    as it balances precision and recall. You can see that using API features alone
    already achieves a high F1 score (0.9164), outperforming the use of static features,
    dynamic features, or a combinations of these. Combining static, dynamic, and API
    features further improves the F1 score to 0.9372.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: For the advanced features, we tested triadic suspicion graph–based features,
    landmark-based features, feature clustering features, and correlation graph–based
    features (TSG, LM, FC, and CG). We also combined each of these with the basic
    features. The results show that using just one kind of advanced feature achieves
    an F1 score ranging from 0.7449 to 0.8957, with TSG ranked the highest. When we
    add the basic features to the advanced features, performance significantly improves,
    with the best F1 score achieved by combining FC features with the basic features.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we combined all of the features using two methods: inputting all of
    them to each classifier and using late fusion to combine the predictions of seven
    classifiers, each using one kind of feature. *Late fusion* is a classification
    technique that combines the predictions made by multiple classifiers. Suppose,
    for instance, that we used three different classifiers to predict the probability
    that a given app is malicious. These three classifiers would each return a probability,
    *p*[1], *p*[2], and *p*[3], respectively. Late fusion tries to find weights *w*[1],
    *w*[2], and *w*[3] such that when their sum is greater than 0.5, the likelihood
    of the app being malicious is as high as possible. As the last two rows in [Table
    7-1](ch07.xhtml#ch7tab1) show, the best late fusion result outperforms all other
    methods, with an F1 score of 0.9840.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: We also tested the ability of each classifier to distinguish rooting malware
    from other kinds of malware. This ability can be advantageous; for instance, if
    a machine learning classifier flags an app as rooting malware, you can send it
    to a rooting malware specialist for analysis. You can see the inputs and their
    performance in [Table 7-2](ch07.xhtml#ch7tab2).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** Classifier Performance—Rooting Malware vs. Other Malware'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature set** | **Best classifier** | **AUC** | **Precision** | **Recall**
    | **F1** | **FPR** | **FNR** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| API package | RF | 0.9801 | 0.9669 | 0.7883 | 0.8685 | 0.0331 | 0.0435 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| Static (S) | XGBoost | 0.9530 | 0.7890 | 0.6724 | 0.7261 | 0.2110 | 0.0621
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| Dynamic (D) | RF | 0.8686 | 0.8444 | 0.4680 | 0.6022 | 0.1556 | 0.0955 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| S + D | RF | 0.9610 | 0.9085 | 0.6847 | 0.7809 | 0.0915 | 0.0587 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| API + S + D | XGBoost | 0.9898 | 0.9472 | 0.8842 | 0.9146 | 0.0528 | 0.0223
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| TSG | RF | 0.9717 | 0.9358 | 0.7883 | 0.8557 | 0.0642 | 0.0437 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| LM | XGBoost | 0.9466 | 0.7922 | 0.6010 | 0.6835 | 0.2078 | 0.0743 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| LM | XGBoost | 0.9466 | 0.7922 | 0.6010 | 0.6835 | 0.2078 | 0.0743 |'
- en: '| FC | RF | 0.9139 | 0.8796 | 0.5936 | 0.7088 | 0.1204 | 0.0746 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| FC | RF | 0.9139 | 0.8796 | 0.5936 | 0.7088 | 0.1204 | 0.0746 |'
- en: '| CG | RF | 0.8452 | 0.7093 | 0.5049 | 0.5899 | 0.2907 | 0.0914 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| CG | RF | 0.8452 | 0.7093 | 0.5049 | 0.5899 | 0.2907 | 0.0914 |'
- en: '| API + S + D + TSG | XGBoost | 0.9896 | 0.9395 | 0.8793 | 0.9084 | 0.0605
    | 0.0233 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + TSG | XGBoost | 0.9896 | 0.9395 | 0.8793 | 0.9084 | 0.0605
    | 0.0233 |'
- en: '| API + S + D + LM | XGBoost | 0.9897 | 0.9395 | 0.8793 | 0.9084 | 0.0605 |
    0.0233 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + LM | XGBoost | 0.9897 | 0.9395 | 0.8793 | 0.9084 | 0.0605 |
    0.0233 |'
- en: '| API + S + D + FC | XGBoost | 0.9898 | 0.9446 | 0.8818 | 0.9121 | 0.0554 |
    0.0228 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + FC | XGBoost | 0.9898 | 0.9446 | 0.8818 | 0.9121 | 0.0554 |
    0.0228 |'
- en: '| API + S + D + CG | XGBoost | 0.9896 | 0.9523 | 0.8842 | 0.9170 | 0.0477 |
    0.0223 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| API + S + D + CG | XGBoost | 0.9896 | 0.9523 | 0.8842 | 0.9170 | 0.0477 |
    0.0223 |'
- en: '| All features | XGBoost | 0.9893 | 0.9333 | 0.8966 | 0.9146 | 0.0667 | 0.0200
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 所有特征 | XGBoost | 0.9893 | 0.9333 | 0.8966 | 0.9146 | 0.0667 | 0.0200 |'
- en: '| Best late fusion | XGBoost | 0.9988 | 0.9927 | 0.9409 | **0.9656** | 0.0073
    | 0.0114 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 最佳后期融合 | XGBoost | 0.9988 | 0.9927 | 0.9409 | **0.9656** | 0.0073 | 0.0114
    |'
- en: Again, API features worked the best of any individual basic feature, but combining
    all of the basic features further improved the F1 score. Of the advanced features,
    TSG again had the highest F1 score, though adding basic features to each kind
    of advanced feature significantly improved performance. Specifically, combining
    CG features with the basic features achieved the best F1 score, a result that
    differs from the best way to distinguish rooting malware from goodware. When we
    combined all basic and advanced features, late fusion results again outperformed
    all classifiers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，API 特征是所有基本特征中表现最好的，但将所有基本特征结合起来进一步提高了 F1 分数。在高级特征中，TSG 再次取得了最高的 F1 分数，尽管将基本特征添加到每种高级特征中显著提高了性能。具体来说，将
    CG 特征与基本特征结合取得了最佳的 F1 分数，这一结果与区分根植恶意软件和良性软件的最佳方法不同。当我们将所有基本和高级特征结合时，后期融合的结果再次超越了所有分类器。
- en: '**Rooting Malware vs. Goodware**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**根植恶意软件与良性软件**'
- en: We’ll use a malware family called Rootnik to illustrate how the features of
    rooting malware differ from those of goodware apps. Rootnik delivers its rooting
    malware through a variety of apps, such as *com.web.sdfile* (v2, f214), that claim
    to manage documents, videos, pictures, music, and other files on a user’s device.
    Once installed, the app reaches out to a command-and-control server, where it
    downloads code at will to perform a veritable laundry list of malicious acts,
    from pushing pornography and ads to the device to silently installing new apps.
    It embeds itself into a wide variety of legitimate applications and, once a device
    is rooted, steals Wi-Fi information including passwords and keys, the user’s location,
    and the device’s MAC address.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 Rootnik 的恶意软件家族来说明根植恶意软件的特征如何与良性软件应用的特征不同。Rootnik 通过各种应用程序传播其根植恶意软件，例如
    *com.web.sdfile*（v2, f214），这些应用宣称可以管理用户设备上的文档、视频、图片、音乐和其他文件。安装后，应用会连接到一个指挥与控制服务器，随意下载代码执行各种恶意行为，从向设备推送色情内容和广告到悄悄安装新应用程序。它将自己嵌入到各种合法应用程序中，一旦设备被根植，就会窃取
    Wi-Fi 信息，包括密码和密钥、用户的位置以及设备的 MAC 地址。
- en: '![Image](../images/ch07fig01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch07fig01.jpg)'
- en: '*Figure 7-1: Top 20 features that best distinguish Android rooting malware
    from goodware*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：最佳区分 Android 根植恶意软件与良性软件的 20 个特征*'
- en: In this section, we will consider a set of 1,829 Rootnik hashes. Of these, 444
    are distinct, in the sense that they lead to different feature vectors of the
    type discussed in [Chapters 5](ch05.xhtml) and [6](ch06.xhtml). We’ll cover the
    20 features that best distinguish between rooting malware and goodware using the
    Extra-Trees classifier (short for extremely randomized trees, a variant of the
    random forest classifier), which randomly chooses multiple subsets of the training
    set, learns a decision tree for each subset, and then aggregates the decision
    trees. [Figure 7-1](ch07.xhtml#ch7fig1) shows these features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将考虑一组 1,829 个 Rootnik 哈希值。在这些哈希值中，有 444 个是不同的，它们生成的特征向量不同，属于在[第 5 章](ch05.xhtml)和[第
    6 章](ch06.xhtml)中讨论的那类。我们将使用 Extra-Trees 分类器（即极端随机树，一种随机森林分类器的变体）来介绍最能区分根植恶意软件和良性软件的
    20 个特征，该分类器随机选择训练集的多个子集，为每个子集学习一棵决策树，然后聚合所有决策树。[图 7-1](ch07.xhtml#ch7fig1)展示了这些特征。
- en: They include nine static permission-related features, a static feature based
    on the `sendnet` method, a static API call feature, six suspicion score features,
    two suspicion rank features, and one correlation graph feature. We will explain
    `sendnet` in more detail later in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '***Permission-Related Features***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 7-1](ch07.xhtml#ch7lis1) shows every permission requested by Rootnik
    in the app’s manifest file.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: All requested permissions in Rootnik*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Apps seek the `INSTALL_PACKAGES` privileged permission when they want to install
    other packages or apps during runtime. Over the years, malware developers have
    tried to use this to sideload new packages. One big advantage of this permission
    is that it can be used to install apps without user consent, unlike its unprivileged
    counterpart `REQUEST_INSTALL_PACKAGES`. Sideloaded apps can then request arbitrary
    permissions and form the launchpad for even more malicious attacks. The classifier’s
    output shows that while 20.27 percent of rooting malware requests this permission,
    only 0.22 percent of goodware requests it. This is expected, as the privileged
    permission is only available to apps that have already successfully elevated their
    privilege level above that of regular apps.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The `GET_PACKAGE_SIZE` permission allows an app to get the package size of other
    apps. You can see from the classifier’s output that 30.75 percent of rooting malware
    requests this permission, compared to only 1.86 percent of goodware. Historically,
    Android used the `GET_PACKAGE_SIZE` permission to protect only a single Android
    API (`PackageManager.getPackageSizeInfo`), which was removed in Android 8.0 (Oreo).
    Spot-checking a few rooting apps showed that while they request this permission,
    they don’t seem to use it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The `KILL_BACKGROUND_PROCESSES` permission allows an Android app to kill processes
    running silently in the background. There are both legitimate and malicious reasons
    for apps to request this permission. For instance, a benign app may want this
    permission in order to free up system resources in cases when another app is running
    in the background but not being actively used. On the other hand, malicious apps
    may request this permission in order to kill security processes running in the
    background. You can see that 28.33 percent of rooting malware requests this permission,
    but only 2.04 percent of goodware does.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Another important permission is `GET_TASKS`. Although deprecated in 2014, it
    lets an app identify the running processes on a device. As you can see from the
    classifier’s output, 67.81 percent of rooting malware requests this permission,
    compared to a mere 13.57 percent of goodware. Thus, an app that requests it is
    almost five times more likely to be rooting malware than goodware. Android has
    severely restricted this feature to further improve sandboxing between apps.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Apps request the `MOUNT_UNMOUNT_FILESYSTEMS` permission to mount or unmount
    the device’s filesystems. This also enables them to add new files, delete files,
    or modify files on parts of the device that were previously restricted. This permission
    is frequently used to drop the BusyBox executable in the */system/bin* directory.
    As BusyBox makes many standard Linux commands available in one executable, it’s
    a nice way to get a lot of standard malware capabilities onto a rooted device
    without having to download, copy, and install too many individual executable files.
    The malware itself may then use these capabilities as needed. The probability
    of the `MOUNT_UNMOUNT_FILESYSTEMS` permission being requested by rooting malware
    is 42.65 percent, compared to 4.21 percent for goodware, as unprivileged apps
    can’t use the permission at all.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The `SYSTEM_ALERT_WINDOW` permission lets an app display pop-up alert windows
    even if the app isn’t currently being used, offering clear and ample opportunity
    for abuse via phishing. We haven’t seen cases of such misuse in rooting apps,
    but many rooting malware apps may bundle their code into benign apps that use
    this permission for their normal operation. Rooting malware is far more likely
    to request this feature than goodware (53.76 percent versus 11.13 percent).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The `RECEIVE_BOOT_COMPLETED` permission allows an app to know when the system
    has completed a boot or reboot. Both goodware and malware apps can use this broadcast
    message to start when the boot finishes. The classifier’s output shows that 66.41
    percent of rooting malware requests this permission, compared to 24.38 percent
    of goodware. Malware seems to be more likely to want to restart immediately after
    a reboot than goodware, which usually starts only when the user wants to interact
    with it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Malicious apps also often request the `READ_PHONE_STATE` and `ACCESS_WIFI_STATE`
    permissions. Benign apps might use the first of these to get the phone’s IMEI
    number, as well as information about the kinds of networks the phone is connected
    to. For example, mobile payment apps may need this type of information to verify
    the identity of the device sending a payment request. Malware can use this permission
    to capture private information about a victim’s phone and is more than twice as
    likely to request it: 35.98 percent of goodware requests the `READ_PHONE_STATE`
    permission, compared to 83.01 percent of rooting malware. Similarly, hackers can
    use `ACCESS_WIFI_STATE` to capture Wi-Fi service set identifiers (SSIDs). While
    80.57 percent of rooting malware requests this permission, its probability of
    being requested by goodware is half this (40.02 percent).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '***Network-Based Features***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the permission-related features, features related to the app’s
    network communications can help machine learning algorithms identify rooting malware.
    For instance, the static `sendnet` feature is set to the number of times that
    the application’s code invokes the `sendnet` method to send data over the internet.
    We can collect this kind of information by running the Android app within an Android
    sandbox environment called DroidBox that enables us to run Android apps safely
    and gather dynamic features of the kind mentioned in [Chapter 6](ch06.xhtml).
    [Listing 7-2](ch07.xhtml#ch7lis2) shows the Rootnik malware calling `sendnet`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了权限相关特征外，与应用网络通信相关的特征可以帮助机器学习算法识别根植恶意软件。例如，静态的`sendnet`特征记录了应用代码调用`sendnet`方法通过互联网发送数据的次数。我们可以通过在名为DroidBox的Android沙箱环境中运行Android应用来收集这种信息，DroidBox可以安全地运行Android应用并收集如[第6章](ch06.xhtml)中所提到的动态特征。[列表7-2](ch07.xhtml#ch7lis2)显示了Rootnik恶意软件调用`sendnet`。
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: The* sendnet *method, used to send data over the internet, in
    Rootnik*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-2：在Rootnik中用于通过互联网发送数据的*sendnet*方法*'
- en: The DroidBox output shows Rootnik sending traffic to the external URL *abc.jxyxteam.com*,
    which likely belongs to a site operated by the malware developers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DroidBox输出显示Rootnik将流量发送到外部网址*abc.jxyxteam.com*，该网址很可能属于恶意软件开发者运营的站点。
- en: The value of the `sendnet` feature is far more likely to be greater than zero
    for rooting malware than for goodware. The classifier’s output shows that 7.65
    percent of malware uses this method, compared to only 0.057 percent of goodware,
    meaning that a rooting malware app is about 134 times more likely than goodware
    to use it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendnet`功能的值对于根植恶意软件来说远远大于零，而对于良性软件来说则较小。分类器的输出显示，7.65%的恶意软件使用此方法，而仅有0.057%的良性软件使用，这意味着根植恶意软件应用使用此方法的可能性是良性软件的约134倍。'
- en: Another feature used in distinguishing rooting malware from goodware is `org.apache.http.conn.scheme`,
    which captures the number of times the app’s code invokes the HTTP or HTTPS protocols.
    Rooting malware invokes this feature far more often than goodware (33.27 percent
    versus a mere 1.59 percent). In [Listing 7-3](ch07.xhtml#ch7lis3), you can see
    the Rootnik rooting malware calling the `org.apache.http.conn.scheme` API.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用来区分根植恶意软件和良性软件的特征是`org.apache.http.conn.scheme`，它捕获了应用代码调用HTTP或HTTPS协议的次数。根植恶意软件调用此特征的频率远高于良性软件（33.27%对比仅1.59%）。在[列表7-3](ch07.xhtml#ch7lis3)中，你可以看到Rootnik根植恶意软件调用了`org.apache.http.conn.scheme`
    API。
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: The org.apache.http.conn.scheme API called in Rootnik*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表7-3：Rootnik中调用的org.apache.http.conn.scheme API*'
- en: Keep in mind that there is nothing inherently malicious about using this method,
    which can support both benign and malicious traffic.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用这种方法本身并不带有恶意，它可以支持善意和恶意的流量。
- en: '**Rooting Malware vs. Other Malware**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**根植恶意软件与其他恶意软件**'
- en: Now let’s discuss the features that best distinguish rooting malware from other
    forms of malware. [Figure 7-2](ch07.xhtml#ch7fig2) shows the strongest 20 features
    for this purpose identified by the Extra-Trees classifier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下哪些特征能最好地区分根植恶意软件与其他类型的恶意软件。[图7-2](ch07.xhtml#ch7fig2)展示了Extra-Trees分类器为此目的识别出的最强的20个特征。
- en: These include 10 permission-related features, 8 suspicion score or suspicion
    rank features, 1 API-related feature, and 1 landmark-based feature. In this section,
    we’ll cover some of the highlights. Because rooting malware is much more similar
    to other forms of malware than to goodware, the differences discussed here are
    smaller.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特征包括10个权限相关特征，8个怀疑分数或怀疑等级特征，1个API相关特征，以及1个基于地标的特征。在这一部分，我们将介绍一些重点内容。因为根植恶意软件与其他类型的恶意软件相比，更类似于其他恶意软件而非良性软件，所以在此讨论的差异较小。
- en: '***Permission-Related Features***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***权限相关特征***'
- en: Ten permissions help the Extra-Trees classifier separate rooting malware from
    other malware. The first is `GET_PACKAGE_SIZE`. Apps that request this permission
    are far more likely to be rooting malware than other forms of malware; 30.15 percent
    of rooting malware requests it, compared to only 7.83 percent of other malware.
    However, the fact that some apps request this permission isn’t necessarily malicious.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 十个权限有助于Extra-Trees分类器区分根植恶意软件与其他恶意软件。第一个是`GET_PACKAGE_SIZE`。请求此权限的应用更可能是根植恶意软件，而非其他类型的恶意软件；30.15%的根植恶意软件请求此权限，而其他恶意软件的请求比例仅为7.83%。然而，一些应用请求此权限并不一定意味着它们是恶意的。
- en: The next four, `MOUNT_UNMOUNT_FILESYSTEMS`, `GET_TASKS`, `ACCESS_WIFI_STATE`,
    and `INSTALL_PACKAGES`, were also among the 20 features most useful for distinguishing
    rooting malware from goodware. Two additional permissions rooting malware requests
    slightly more often than other malware are `READ_LOGS` and `RESTART_PACKAGES`.
    The `READ_LOGS` permission grants access to all systems logs for privileged apps,
    but only an app’s own logs for unprivileged apps; `RESTART_PACKAGES` has been
    deprecated since API 15\. In all of these cases, the differences in the percentages
    of rooting malware versus other types of malware requesting the permissions aren’t
    huge, and using any one of these features individually to classify apps as rooting
    malware rather than some other kind malware will likely lead to errors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig02.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Top 20 features that best distinguish Android rooting malware
    from other forms of malware*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have already seen that `READ_PHONE_STATE` and `RECEIVE_BOOT_COMPLETED`
    were important in distinguishing rooting malware from good-ware. Interestingly,
    [Figure 7-2](ch07.xhtml#ch7fig2) shows that rooting malware is slightly less likely
    to request these permissions than other forms of malware, which might use them
    to start whenever the system is rebooted or to capture IMSI and IMEI information
    about the device.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Features***'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The suspicion score and suspicion rank features play a far more important role
    in distinguishing rooting malware from other forms of malware than they did in
    the case of separating rooting malware from goodware. These more technical features
    seem able to make fine-grained distinctions that the coarser permission-related
    features miss.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The API feature *org.apache.http.conn.scheme*, which captures the number of
    times in the code that the app invokes the HTTP or HTTPS protocols, is also helpful
    here. While 63.27 percent of rooting malware makes at least one call to one of
    these protocols in its code, other forms of malware don’t use the Apache libraries
    nearly as often (though they may use other libraries for the same purpose). This
    class represents a number of protocols and describes protocol properties like
    which socket to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**DroidDream: A Case Study**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DroidDream was the first known rooting malware on the Android platform. In this
    section, we’ll apply the detection strategies learned in the earlier part of this
    chapter to analyze it. [Listing 7-4](ch07.xhtml#ch7lis4) shows the permissions
    the app requests in *com.fall.down* (v1, 7d1d).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 7-4: The permissions used in the DroidDream malware*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We see that DroidDream asks for only a few of the 20 permissions discussed earlier
    in this chapter. The ones that our analysis deemed significant for recognizing
    rooting malware are `READ_PHONE_STATE` and `ACCESS_WIFI_STATE`. In [Listing 7-5](ch07.xhtml#ch7lis5),
    you can see the app using `READ_PHONE_STATE` to request IMEI information from
    the device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-5: IMEI access by the DroidDream malware*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-6](ch07.xhtml#ch7lis6) contains DroidBox output that shows the DroidDream
    app accessing IMSI information, another activity that requires the `READ_PHONE_STATE`
    permission. Later in the code, the app sends both the IMEI and IMSI to its command-and-control
    server.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-6: IMSI access by the DroidDream malware*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The app also collects information about the device hardware and operating system,
    which requires the `INTERNET` permission. DroidDream uses this permission to connect
    to various external URLs, too. [Listing 7-7](ch07.xhtml#ch7lis7) shows the list
    of URLs included in the DroidDream code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-7: External URLs accessed by the DroidDream malware*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Individually, none of these features provides a smoking gun establishing that
    DroidDream is malicious. However, their collective presence is enough for our
    ensemble-based machine learning algorithm to label it as such. A security analyst
    could then examine the malware to find conclusive proof (for example, the `runExploid`
    method, shown in [Listing 7-6](ch07.xhtml#ch7lis6)). If they did so, they’d determine
    that DroidDream roots phones with the so-called Rage-Against-the-Cage exploit,
    then uses its root privileges to install another app with elevated privileges.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Up Next**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed that it’s possible to achieve high levels of predictive
    efficacy in malware detection using ensemble late fusion, which has a significantly
    higher performance than any other classifier. We also showed that while all feature
    types help separate rooting malware from goodware, as well as from other forms
    of malware, the advanced features covered in [Chapter 6](ch06.xhtml) do especially
    well. In particular, the TSG suspicion scores and suspicion ranks make the biggest
    contribution to ensembles. Permissions also proved important.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter introduces detection techniques for another widely prevalent
    form of Android malware: spyware, which gathers personal information and uses
    it for a variety of nefarious purposes.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
