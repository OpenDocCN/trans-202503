- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ROOTING MALWARE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Malware developers often seek ways of elevating their apps’ privileges to gain
    root access, which requires a privilege escalation exploit of some sort. Once
    operating as root, malware can use app and system resources to perform operations
    such as installing system-level applications, accessing other apps’ protected
    files, and modifying filesystem permissions to allow other malicious apps to view
    sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: We covered multiple examples of rooting malware in [Chapter 2](ch02.xhtml).
    In this chapter, we’ll first discuss some well-known rooting malware families
    we haven’t yet explored. Then we’ll examine the performance of different machine
    learning techniques used to separate rooting malware from goodware, as well as
    from other forms of Android malware, and the key features used to do so. Though
    we’ll use the Rootnik rooting malware as an example throughout the chapter, we’ll
    also apply the detection techniques to the DroidDream malware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rooting Malware Families**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To the best of our knowledge, ZNIU was the first rooting malware to leverage
    the Dirty COW (copy-on-write) vulnerability, which allows privilege escalation
    in the Linux kernel. According to Trend Micro’s blog post “ZNIU: First Android
    Malware to Exploit Dirty COW,” it was distributed via over 1,200 apps and through
    infected websites. Once the app was installed on a device, it reached out to a
    command-and-control server and engaged in transactions with the compromised device’s
    mobile carrier through an SMS-enabled payment service, incurring charges to a
    company located in China. ZNIU used root privileges to circumvent Android’s default
    workflow, which requires user consent to grant an app SMS-related permissions.
    Some versions of ZNIU leveraged exploits other than Dirty COW, such as Iovyroot,
    which targets a Linux kernel vulnerability, or various exploits from the KingoRoot
    rooting app.'
  prefs: []
  type: TYPE_NORMAL
- en: In 2017, researchers at Kaspersky Lab discovered Dvmap. Its authors first uploaded
    a benign app to Google Play and later updated it to a malicious version, a behavior
    common in malware because it helps the app build a user base without raising suspicion.
    The authors would make the malicious version available for short periods and then
    replace it with a benign version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dvmap was the first rooting malware sample known to use code injection techniques.
    It would substitute the executable file */system/bin/ip* with a completely new
    file that contained malicious functionality, then inject code to execute the new
    file into two system libraries associated with Android’s Dalvik and ART runtimes,
    ensuring that it would run with elevated privileges. Replacing the file, and the
    subsequent code injection into the system libraries, required using a privilege
    escalation exploit. You can read more about this malware in the Kaspersky blog
    post “Dvmap: Android Malware with a New Technique for Controlling Devices Appears
    on Google Play.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'In September 2017, the Android Security team discovered Tizi, which roots devices,
    mostly in Africa, to carry out spyware operations by leveraging a number of vulnerabilities
    discovered in 2012 and 2013\. Once it has obtained root privileges, Tizi uses
    this access to record calls on encrypted services such as WhatsApp, Skype, and
    Viber and monitor social media activity on Facebook, X, LinkedIn, and Telegram.
    You can read more about this malware in an Android Security team blog post titled
    “Tizi: Detecting and Blocking Socially Engineered Spyware on Android.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing Classifier Performance**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To evaluate how well machine learning classifiers can distinguish rooting malware
    from goodware, we tested 10 classifiers by feeding them various sets of features,
    as shown in [Table 7-1](ch07.xhtml#ch7tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** Classifier Performance—Rooting Malware vs. Goodware'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature set** | **Best classifier** | **AUC** | **Precision** | **Recall**
    | **F1** | **FPR** | **FNR** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| API package | GBDT | 0.9939 | 0.9324 | 0.9009 | 0.9164 | 0.0676 | 0.0146
    |'
  prefs: []
  type: TYPE_TB
- en: '| Static (S) | XGBoost | 0.9811 | 0.8658 | 0.7783 | 0.8197 | 0.1342 | 0.0296
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic (D) | RF | 0.9065 | 0.8735 | 0.5271 | 0.6575 | 0.1265 | 0.0608 |'
  prefs: []
  type: TYPE_TB
- en: '| S + D | XGBoost | 0.9848 | 0.8889 | 0.8079 | 0.8465 | 0.1111 | 0.0257 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D | XGBoost | 0.9974 | 0.9564 | 0.9187 | 0.9372 | 0.0436 | 0.0109
    |'
  prefs: []
  type: TYPE_TB
- en: '| TSG | XGBoost | 0.9927 | 0.9018 | 0.8896 | 0.8957 | 0.0982 | 0.0163 |'
  prefs: []
  type: TYPE_TB
- en: '| LM | XGBoost | 0.9791 | 0.8375 | 0.7488 | 0.7906 | 0.1625 | 0.0335 |'
  prefs: []
  type: TYPE_TB
- en: '| FC | XGBoost | 0.9729 | 0.8507 | 0.7438 | 0.7937 | 0.1493 | 0.0341 |'
  prefs: []
  type: TYPE_TB
- en: '| CG | RF | 0.9571 | 0.8349 | 0.6724 | 0.7449 | 0.1651 | 0.0432 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + TSG | XGBoost | 0.9970 | 0.9337 | 0.9015 | 0.9173 | 0.0663
    | 0.0133 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + LM | XGBoost | 0.9972 | 0.9514 | 0.9163 | 0.9335 | 0.0486 |
    0.0113 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + FC | XGBoost | 0.9972 | 0.9540 | 0.9187 | 0.9360 | 0.0460 |
    0.0110 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + CG | XGBoost | 0.9971 | 0.9580 | 0.8990 | 0.9276 | 0.0420 |
    0.0136 |'
  prefs: []
  type: TYPE_TB
- en: '| All features | XGBoost | 0.9970 | 0.9482 | 0.9015 | 0.9242 | 0.0518 | 0.0133
    |'
  prefs: []
  type: TYPE_TB
- en: '| Best late fusion | XGBoost | 0.9994 | 0.9854 | 0.9828 | **0.9840** | 0.0146
    | 0.0023 |'
  prefs: []
  type: TYPE_TB
- en: We first used a set of basic features derived from API packages, static analysis,
    and dynamic analysis (API, S, and D), as well as two combinations of these (S
    + D and API + S + D). The “Best classifier” column records the classifier with
    the best F1 score. As you can see, gradient-boosted decision tree (GDBT), XGBoost,
    and random forest (RF) classifiers perform best.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table lists several performance metrics, all of which were introduced in
    [Chapter 5](ch05.xhtml): AUC, precision, recall, F1 score, false positive rate
    (FPR), and false negative rate (FNR). The F1 score is the most important of these,
    as it balances precision and recall. You can see that using API features alone
    already achieves a high F1 score (0.9164), outperforming the use of static features,
    dynamic features, or a combinations of these. Combining static, dynamic, and API
    features further improves the F1 score to 0.9372.'
  prefs: []
  type: TYPE_NORMAL
- en: For the advanced features, we tested triadic suspicion graph–based features,
    landmark-based features, feature clustering features, and correlation graph–based
    features (TSG, LM, FC, and CG). We also combined each of these with the basic
    features. The results show that using just one kind of advanced feature achieves
    an F1 score ranging from 0.7449 to 0.8957, with TSG ranked the highest. When we
    add the basic features to the advanced features, performance significantly improves,
    with the best F1 score achieved by combining FC features with the basic features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we combined all of the features using two methods: inputting all of
    them to each classifier and using late fusion to combine the predictions of seven
    classifiers, each using one kind of feature. *Late fusion* is a classification
    technique that combines the predictions made by multiple classifiers. Suppose,
    for instance, that we used three different classifiers to predict the probability
    that a given app is malicious. These three classifiers would each return a probability,
    *p*[1], *p*[2], and *p*[3], respectively. Late fusion tries to find weights *w*[1],
    *w*[2], and *w*[3] such that when their sum is greater than 0.5, the likelihood
    of the app being malicious is as high as possible. As the last two rows in [Table
    7-1](ch07.xhtml#ch7tab1) show, the best late fusion result outperforms all other
    methods, with an F1 score of 0.9840.'
  prefs: []
  type: TYPE_NORMAL
- en: We also tested the ability of each classifier to distinguish rooting malware
    from other kinds of malware. This ability can be advantageous; for instance, if
    a machine learning classifier flags an app as rooting malware, you can send it
    to a rooting malware specialist for analysis. You can see the inputs and their
    performance in [Table 7-2](ch07.xhtml#ch7tab2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** Classifier Performance—Rooting Malware vs. Other Malware'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature set** | **Best classifier** | **AUC** | **Precision** | **Recall**
    | **F1** | **FPR** | **FNR** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| API package | RF | 0.9801 | 0.9669 | 0.7883 | 0.8685 | 0.0331 | 0.0435 |'
  prefs: []
  type: TYPE_TB
- en: '| Static (S) | XGBoost | 0.9530 | 0.7890 | 0.6724 | 0.7261 | 0.2110 | 0.0621
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic (D) | RF | 0.8686 | 0.8444 | 0.4680 | 0.6022 | 0.1556 | 0.0955 |'
  prefs: []
  type: TYPE_TB
- en: '| S + D | RF | 0.9610 | 0.9085 | 0.6847 | 0.7809 | 0.0915 | 0.0587 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D | XGBoost | 0.9898 | 0.9472 | 0.8842 | 0.9146 | 0.0528 | 0.0223
    |'
  prefs: []
  type: TYPE_TB
- en: '| TSG | RF | 0.9717 | 0.9358 | 0.7883 | 0.8557 | 0.0642 | 0.0437 |'
  prefs: []
  type: TYPE_TB
- en: '| LM | XGBoost | 0.9466 | 0.7922 | 0.6010 | 0.6835 | 0.2078 | 0.0743 |'
  prefs: []
  type: TYPE_TB
- en: '| FC | RF | 0.9139 | 0.8796 | 0.5936 | 0.7088 | 0.1204 | 0.0746 |'
  prefs: []
  type: TYPE_TB
- en: '| CG | RF | 0.8452 | 0.7093 | 0.5049 | 0.5899 | 0.2907 | 0.0914 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + TSG | XGBoost | 0.9896 | 0.9395 | 0.8793 | 0.9084 | 0.0605
    | 0.0233 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + LM | XGBoost | 0.9897 | 0.9395 | 0.8793 | 0.9084 | 0.0605 |
    0.0233 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + FC | XGBoost | 0.9898 | 0.9446 | 0.8818 | 0.9121 | 0.0554 |
    0.0228 |'
  prefs: []
  type: TYPE_TB
- en: '| API + S + D + CG | XGBoost | 0.9896 | 0.9523 | 0.8842 | 0.9170 | 0.0477 |
    0.0223 |'
  prefs: []
  type: TYPE_TB
- en: '| All features | XGBoost | 0.9893 | 0.9333 | 0.8966 | 0.9146 | 0.0667 | 0.0200
    |'
  prefs: []
  type: TYPE_TB
- en: '| Best late fusion | XGBoost | 0.9988 | 0.9927 | 0.9409 | **0.9656** | 0.0073
    | 0.0114 |'
  prefs: []
  type: TYPE_TB
- en: Again, API features worked the best of any individual basic feature, but combining
    all of the basic features further improved the F1 score. Of the advanced features,
    TSG again had the highest F1 score, though adding basic features to each kind
    of advanced feature significantly improved performance. Specifically, combining
    CG features with the basic features achieved the best F1 score, a result that
    differs from the best way to distinguish rooting malware from goodware. When we
    combined all basic and advanced features, late fusion results again outperformed
    all classifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rooting Malware vs. Goodware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use a malware family called Rootnik to illustrate how the features of
    rooting malware differ from those of goodware apps. Rootnik delivers its rooting
    malware through a variety of apps, such as *com.web.sdfile* (v2, f214), that claim
    to manage documents, videos, pictures, music, and other files on a user’s device.
    Once installed, the app reaches out to a command-and-control server, where it
    downloads code at will to perform a veritable laundry list of malicious acts,
    from pushing pornography and ads to the device to silently installing new apps.
    It embeds itself into a wide variety of legitimate applications and, once a device
    is rooted, steals Wi-Fi information including passwords and keys, the user’s location,
    and the device’s MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Top 20 features that best distinguish Android rooting malware
    from goodware*'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will consider a set of 1,829 Rootnik hashes. Of these, 444
    are distinct, in the sense that they lead to different feature vectors of the
    type discussed in [Chapters 5](ch05.xhtml) and [6](ch06.xhtml). We’ll cover the
    20 features that best distinguish between rooting malware and goodware using the
    Extra-Trees classifier (short for extremely randomized trees, a variant of the
    random forest classifier), which randomly chooses multiple subsets of the training
    set, learns a decision tree for each subset, and then aggregates the decision
    trees. [Figure 7-1](ch07.xhtml#ch7fig1) shows these features.
  prefs: []
  type: TYPE_NORMAL
- en: They include nine static permission-related features, a static feature based
    on the `sendnet` method, a static API call feature, six suspicion score features,
    two suspicion rank features, and one correlation graph feature. We will explain
    `sendnet` in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***Permission-Related Features***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 7-1](ch07.xhtml#ch7lis1) shows every permission requested by Rootnik
    in the app’s manifest file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: All requested permissions in Rootnik*'
  prefs: []
  type: TYPE_NORMAL
- en: Apps seek the `INSTALL_PACKAGES` privileged permission when they want to install
    other packages or apps during runtime. Over the years, malware developers have
    tried to use this to sideload new packages. One big advantage of this permission
    is that it can be used to install apps without user consent, unlike its unprivileged
    counterpart `REQUEST_INSTALL_PACKAGES`. Sideloaded apps can then request arbitrary
    permissions and form the launchpad for even more malicious attacks. The classifier’s
    output shows that while 20.27 percent of rooting malware requests this permission,
    only 0.22 percent of goodware requests it. This is expected, as the privileged
    permission is only available to apps that have already successfully elevated their
    privilege level above that of regular apps.
  prefs: []
  type: TYPE_NORMAL
- en: The `GET_PACKAGE_SIZE` permission allows an app to get the package size of other
    apps. You can see from the classifier’s output that 30.75 percent of rooting malware
    requests this permission, compared to only 1.86 percent of goodware. Historically,
    Android used the `GET_PACKAGE_SIZE` permission to protect only a single Android
    API (`PackageManager.getPackageSizeInfo`), which was removed in Android 8.0 (Oreo).
    Spot-checking a few rooting apps showed that while they request this permission,
    they don’t seem to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The `KILL_BACKGROUND_PROCESSES` permission allows an Android app to kill processes
    running silently in the background. There are both legitimate and malicious reasons
    for apps to request this permission. For instance, a benign app may want this
    permission in order to free up system resources in cases when another app is running
    in the background but not being actively used. On the other hand, malicious apps
    may request this permission in order to kill security processes running in the
    background. You can see that 28.33 percent of rooting malware requests this permission,
    but only 2.04 percent of goodware does.
  prefs: []
  type: TYPE_NORMAL
- en: Another important permission is `GET_TASKS`. Although deprecated in 2014, it
    lets an app identify the running processes on a device. As you can see from the
    classifier’s output, 67.81 percent of rooting malware requests this permission,
    compared to a mere 13.57 percent of goodware. Thus, an app that requests it is
    almost five times more likely to be rooting malware than goodware. Android has
    severely restricted this feature to further improve sandboxing between apps.
  prefs: []
  type: TYPE_NORMAL
- en: Apps request the `MOUNT_UNMOUNT_FILESYSTEMS` permission to mount or unmount
    the device’s filesystems. This also enables them to add new files, delete files,
    or modify files on parts of the device that were previously restricted. This permission
    is frequently used to drop the BusyBox executable in the */system/bin* directory.
    As BusyBox makes many standard Linux commands available in one executable, it’s
    a nice way to get a lot of standard malware capabilities onto a rooted device
    without having to download, copy, and install too many individual executable files.
    The malware itself may then use these capabilities as needed. The probability
    of the `MOUNT_UNMOUNT_FILESYSTEMS` permission being requested by rooting malware
    is 42.65 percent, compared to 4.21 percent for goodware, as unprivileged apps
    can’t use the permission at all.
  prefs: []
  type: TYPE_NORMAL
- en: The `SYSTEM_ALERT_WINDOW` permission lets an app display pop-up alert windows
    even if the app isn’t currently being used, offering clear and ample opportunity
    for abuse via phishing. We haven’t seen cases of such misuse in rooting apps,
    but many rooting malware apps may bundle their code into benign apps that use
    this permission for their normal operation. Rooting malware is far more likely
    to request this feature than goodware (53.76 percent versus 11.13 percent).
  prefs: []
  type: TYPE_NORMAL
- en: The `RECEIVE_BOOT_COMPLETED` permission allows an app to know when the system
    has completed a boot or reboot. Both goodware and malware apps can use this broadcast
    message to start when the boot finishes. The classifier’s output shows that 66.41
    percent of rooting malware requests this permission, compared to 24.38 percent
    of goodware. Malware seems to be more likely to want to restart immediately after
    a reboot than goodware, which usually starts only when the user wants to interact
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Malicious apps also often request the `READ_PHONE_STATE` and `ACCESS_WIFI_STATE`
    permissions. Benign apps might use the first of these to get the phone’s IMEI
    number, as well as information about the kinds of networks the phone is connected
    to. For example, mobile payment apps may need this type of information to verify
    the identity of the device sending a payment request. Malware can use this permission
    to capture private information about a victim’s phone and is more than twice as
    likely to request it: 35.98 percent of goodware requests the `READ_PHONE_STATE`
    permission, compared to 83.01 percent of rooting malware. Similarly, hackers can
    use `ACCESS_WIFI_STATE` to capture Wi-Fi service set identifiers (SSIDs). While
    80.57 percent of rooting malware requests this permission, its probability of
    being requested by goodware is half this (40.02 percent).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Network-Based Features***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the permission-related features, features related to the app’s
    network communications can help machine learning algorithms identify rooting malware.
    For instance, the static `sendnet` feature is set to the number of times that
    the application’s code invokes the `sendnet` method to send data over the internet.
    We can collect this kind of information by running the Android app within an Android
    sandbox environment called DroidBox that enables us to run Android apps safely
    and gather dynamic features of the kind mentioned in [Chapter 6](ch06.xhtml).
    [Listing 7-2](ch07.xhtml#ch7lis2) shows the Rootnik malware calling `sendnet`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: The* sendnet *method, used to send data over the internet, in
    Rootnik*'
  prefs: []
  type: TYPE_NORMAL
- en: The DroidBox output shows Rootnik sending traffic to the external URL *abc.jxyxteam.com*,
    which likely belongs to a site operated by the malware developers.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `sendnet` feature is far more likely to be greater than zero
    for rooting malware than for goodware. The classifier’s output shows that 7.65
    percent of malware uses this method, compared to only 0.057 percent of goodware,
    meaning that a rooting malware app is about 134 times more likely than goodware
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Another feature used in distinguishing rooting malware from goodware is `org.apache.http.conn.scheme`,
    which captures the number of times the app’s code invokes the HTTP or HTTPS protocols.
    Rooting malware invokes this feature far more often than goodware (33.27 percent
    versus a mere 1.59 percent). In [Listing 7-3](ch07.xhtml#ch7lis3), you can see
    the Rootnik rooting malware calling the `org.apache.http.conn.scheme` API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: The org.apache.http.conn.scheme API called in Rootnik*'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that there is nothing inherently malicious about using this method,
    which can support both benign and malicious traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rooting Malware vs. Other Malware**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s discuss the features that best distinguish rooting malware from other
    forms of malware. [Figure 7-2](ch07.xhtml#ch7fig2) shows the strongest 20 features
    for this purpose identified by the Extra-Trees classifier.
  prefs: []
  type: TYPE_NORMAL
- en: These include 10 permission-related features, 8 suspicion score or suspicion
    rank features, 1 API-related feature, and 1 landmark-based feature. In this section,
    we’ll cover some of the highlights. Because rooting malware is much more similar
    to other forms of malware than to goodware, the differences discussed here are
    smaller.
  prefs: []
  type: TYPE_NORMAL
- en: '***Permission-Related Features***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ten permissions help the Extra-Trees classifier separate rooting malware from
    other malware. The first is `GET_PACKAGE_SIZE`. Apps that request this permission
    are far more likely to be rooting malware than other forms of malware; 30.15 percent
    of rooting malware requests it, compared to only 7.83 percent of other malware.
    However, the fact that some apps request this permission isn’t necessarily malicious.
  prefs: []
  type: TYPE_NORMAL
- en: The next four, `MOUNT_UNMOUNT_FILESYSTEMS`, `GET_TASKS`, `ACCESS_WIFI_STATE`,
    and `INSTALL_PACKAGES`, were also among the 20 features most useful for distinguishing
    rooting malware from goodware. Two additional permissions rooting malware requests
    slightly more often than other malware are `READ_LOGS` and `RESTART_PACKAGES`.
    The `READ_LOGS` permission grants access to all systems logs for privileged apps,
    but only an app’s own logs for unprivileged apps; `RESTART_PACKAGES` has been
    deprecated since API 15\. In all of these cases, the differences in the percentages
    of rooting malware versus other types of malware requesting the permissions aren’t
    huge, and using any one of these features individually to classify apps as rooting
    malware rather than some other kind malware will likely lead to errors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Top 20 features that best distinguish Android rooting malware
    from other forms of malware*'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have already seen that `READ_PHONE_STATE` and `RECEIVE_BOOT_COMPLETED`
    were important in distinguishing rooting malware from good-ware. Interestingly,
    [Figure 7-2](ch07.xhtml#ch7fig2) shows that rooting malware is slightly less likely
    to request these permissions than other forms of malware, which might use them
    to start whenever the system is rebooted or to capture IMSI and IMEI information
    about the device.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Features***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The suspicion score and suspicion rank features play a far more important role
    in distinguishing rooting malware from other forms of malware than they did in
    the case of separating rooting malware from goodware. These more technical features
    seem able to make fine-grained distinctions that the coarser permission-related
    features miss.
  prefs: []
  type: TYPE_NORMAL
- en: The API feature *org.apache.http.conn.scheme*, which captures the number of
    times in the code that the app invokes the HTTP or HTTPS protocols, is also helpful
    here. While 63.27 percent of rooting malware makes at least one call to one of
    these protocols in its code, other forms of malware don’t use the Apache libraries
    nearly as often (though they may use other libraries for the same purpose). This
    class represents a number of protocols and describes protocol properties like
    which socket to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**DroidDream: A Case Study**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DroidDream was the first known rooting malware on the Android platform. In this
    section, we’ll apply the detection strategies learned in the earlier part of this
    chapter to analyze it. [Listing 7-4](ch07.xhtml#ch7lis4) shows the permissions
    the app requests in *com.fall.down* (v1, 7d1d).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: The permissions used in the DroidDream malware*'
  prefs: []
  type: TYPE_NORMAL
- en: We see that DroidDream asks for only a few of the 20 permissions discussed earlier
    in this chapter. The ones that our analysis deemed significant for recognizing
    rooting malware are `READ_PHONE_STATE` and `ACCESS_WIFI_STATE`. In [Listing 7-5](ch07.xhtml#ch7lis5),
    you can see the app using `READ_PHONE_STATE` to request IMEI information from
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: IMEI access by the DroidDream malware*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-6](ch07.xhtml#ch7lis6) contains DroidBox output that shows the DroidDream
    app accessing IMSI information, another activity that requires the `READ_PHONE_STATE`
    permission. Later in the code, the app sends both the IMEI and IMSI to its command-and-control
    server.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6: IMSI access by the DroidDream malware*'
  prefs: []
  type: TYPE_NORMAL
- en: The app also collects information about the device hardware and operating system,
    which requires the `INTERNET` permission. DroidDream uses this permission to connect
    to various external URLs, too. [Listing 7-7](ch07.xhtml#ch7lis7) shows the list
    of URLs included in the DroidDream code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-7: External URLs accessed by the DroidDream malware*'
  prefs: []
  type: TYPE_NORMAL
- en: Individually, none of these features provides a smoking gun establishing that
    DroidDream is malicious. However, their collective presence is enough for our
    ensemble-based machine learning algorithm to label it as such. A security analyst
    could then examine the malware to find conclusive proof (for example, the `runExploid`
    method, shown in [Listing 7-6](ch07.xhtml#ch7lis6)). If they did so, they’d determine
    that DroidDream roots phones with the so-called Rage-Against-the-Cage exploit,
    then uses its root privileges to install another app with elevated privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '**Up Next**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we showed that it’s possible to achieve high levels of predictive
    efficacy in malware detection using ensemble late fusion, which has a significantly
    higher performance than any other classifier. We also showed that while all feature
    types help separate rooting malware from goodware, as well as from other forms
    of malware, the advanced features covered in [Chapter 6](ch06.xhtml) do especially
    well. In particular, the TSG suspicion scores and suspicion ranks make the biggest
    contribution to ensembles. Permissions also proved important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter introduces detection techniques for another widely prevalent
    form of Android malware: spyware, which gathers personal information and uses
    it for a variety of nefarious purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[*OceanofPDF.com*](https://oceanofpdf.com)'
  prefs: []
  type: TYPE_NORMAL
