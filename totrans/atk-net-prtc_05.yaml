- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**ANALYSIS FROM THE WIRE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自网络的分析**'
- en: In [Chapter 2](../Text/ch02.xhtml#ch02), I discussed how to capture network
    traffic for analysis. Now it’s time to put that knowledge to the test. In this
    chapter, we’ll examine how to analyze captured network protocol traffic from a
    chat application to understand the protocol in use. If you can determine which
    features a protocol supports, you can assess its security.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](../Text/ch02.xhtml#ch02)中，我讨论了如何捕获网络流量进行分析。现在是时候将这些知识付诸实践了。在本章中，我们将分析如何从聊天应用程序中捕获的网络协议流量，了解正在使用的协议。如果你能确定协议支持哪些功能，你就能评估它的安全性。
- en: Analysis of an unknown protocol is typically incremental. You begin by capturing
    network traffic, and then analyze it to try to understand what each part of the
    traffic represents. Throughout this chapter, I’ll show you how to use Wireshark
    and some custom code to inspect an unknown network protocol. Our approach will
    include extracting structures and state information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 分析一个未知协议通常是渐进的。你从捕获网络流量开始，然后分析它，尝试理解流量中的每个部分代表什么。在本章中，我将向你展示如何使用 Wireshark 和一些自定义代码来检查一个未知的网络协议。我们的方法将包括提取结构和状态信息。
- en: '**The Traffic-Producing Application: SuperFunkyChat**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**产生流量的应用程序：SuperFunkyChat**'
- en: The test subject for this chapter is a chat application I’ve written in C# called
    SuperFunkyChat, which will run on Windows, Linux, and macOS. Download the latest
    prebuild applications and source code from the GitHub page at *[https://github.com/tyranid/ExampleChatApplication/releases/](https://github.com/tyranid/ExampleChatApplication/releases/)*;
    be sure to choose the release binaries appropriate for your platform. (If you’re
    using Mono, choose the .NET version, and so on.) The example client and server
    console applications for SuperFunkyChat are called ChatClient and ChatServer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的测试对象是我用 C# 编写的一个聊天应用程序，名为 SuperFunkyChat，它将在 Windows、Linux 和 macOS 上运行。可以从
    GitHub 页面下载最新的预构建应用程序和源代码，网址是 *[https://github.com/tyranid/ExampleChatApplication/releases/](https://github.com/tyranid/ExampleChatApplication/releases/)*；请务必选择适合您平台的发布二进制文件。（如果您使用
    Mono，请选择 .NET 版本，依此类推。）SuperFunkyChat 的示例客户端和服务器控制台应用程序分别名为 ChatClient 和 ChatServer。
- en: After you’ve downloaded the application, unpack the release files to a directory
    on your machine so you can run each application. For the sake of simplicity, all
    example command lines will use the Windows executable binaries. If you’re running
    under Mono, prefix the command with the path to the main *mono* binary. When running
    files for .NET Core, prefix the command with the *dotnet* binary. The files for
    .NET will have a *.dll* extension instead of *.exe*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完应用程序后，将发布文件解压到你计算机上的一个目录，以便运行每个应用程序。为了简化起见，所有示例命令行将使用 Windows 可执行二进制文件。如果你在
    Mono 下运行，请在命令前加上主 *mono* 二进制文件的路径。当运行 .NET Core 的文件时，在命令前加上 *dotnet* 二进制文件。这些
    .NET 文件将以 *.dll* 扩展名而非 *.exe* 扩展名。
- en: '***Starting the Server***'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动服务器***'
- en: Start the server by running *ChatServer.exe* with no parameters. If successful,
    it should print some basic information, as shown in [Listing 5-1](../Text/ch05.xhtml#ch5list1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行*ChatServer.exe*（不带参数）来启动服务器。如果成功，应该会打印一些基本信息，如[清单 5-1](../Text/ch05.xhtml#ch5list1)所示。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: Example output from running ChatServer*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：运行 ChatServer 的示例输出*'
- en: '**NOTE**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Pay attention to the warning! This application has not been designed to be
    a secure chat system.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意警告！此应用程序并未设计为一个安全的聊天系统。*'
- en: Notice in [Listing 5-1](../Text/ch05.xhtml#ch5list1) that the final line prints
    the port the server is running on (12345 in this case) and whether the server
    has bound to all interfaces (global). You probably won’t need to change the port
    (`--port NUM`), but you might need to change whether the application is bound
    to all interfaces if you want clients and the server to exist on different computers.
    This is especially important on Windows. It’s not easy to capture traffic to the
    local loopback interface on Windows; if you encounter any difficulties, you may
    need to run the server on a separate computer or a virtual machine (VM). To bind
    to all interfaces, specify the `--global` parameter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[清单 5-1](../Text/ch05.xhtml#ch5list1)中，最后一行打印了服务器运行的端口（此处为 12345）以及服务器是否已绑定到所有接口（全局）。你可能不需要更改端口（`--port
    NUM`），但如果你希望客户端和服务器存在于不同的计算机上，可能需要更改应用程序是否绑定到所有接口。特别是在 Windows 上，这一点尤为重要。在 Windows
    上捕获本地回环接口的流量并不容易；如果遇到困难，你可能需要在另一台计算机或虚拟机（VM）上运行服务器。要绑定到所有接口，请指定`--global`参数。
- en: '***Starting Clients***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动客户端***'
- en: With the server running, we can start one or more clients. To start a client,
    run *ChatClient.exe* (see [Listing 5-2](../Text/ch05.xhtml#ch5list2)), specify
    the username you want to use on the server (the username can be anything you like),
    and specify the server hostname (for example, `localhost`). When you run the client,
    you should see output similar to that shown in [Listing 5-2](../Text/ch05.xhtml#ch5list2).
    If you see any errors, make sure you’ve set up the server correctly, including
    requiring binding to all interfaces or disabling the firewall on the server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器运行的情况下，我们可以启动一个或多个客户端。启动客户端时，运行 *ChatClient.exe*（见[清单 5-2](../Text/ch05.xhtml#ch5list2)），指定你在服务器上使用的用户名（用户名可以是你喜欢的任何名称），并指定服务器主机名（例如，`localhost`）。当你运行客户端时，你应该会看到类似于[清单
    5-2](../Text/ch05.xhtml#ch5list2)所示的输出。如果看到任何错误，确保服务器已正确设置，包括要求绑定到所有接口或禁用服务器上的防火墙。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: Example output from running ChatClient*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-2：运行 ChatClient 的示例输出*'
- en: 'As you start the client, look at the running server: you should see output
    on the console similar to [Listing 5-3](../Text/ch05.xhtml#ch5list3), indicating
    that the client has successfully sent a “Hello” packet.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 启动客户端时，查看正在运行的服务器：你应该能在控制台看到类似于[清单 5-3](../Text/ch05.xhtml#ch5list3)的输出，表示客户端已经成功发送了一个“Hello”数据包。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-3: The server output when a client connects*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：客户端连接时服务器的输出*'
- en: '***Communicating Between Clients***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***客户端之间的通信***'
- en: After you’ve completed the preceding steps successfully, you should be able
    to connect multiple clients so you can communicate between them. To send a message
    to all users with the ChatClient, enter the message on the command line and press
    ENTER.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述步骤后，你应该能够连接多个客户端，以便它们之间进行通信。要向所有用户发送消息，可以在命令行中输入消息并按 ENTER 键。
- en: The ChatClient also supports a few other commands, which all begin with a forward
    slash (`/`), as detailed in [Table 5-1](../Text/ch05.xhtml#ch5tab1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ChatClient 还支持一些其他命令，这些命令都以斜杠（`/`）开头，具体如下[表 5-1](../Text/ch05.xhtml#ch5tab1)所述。
- en: '**Table 5-1:** Commands for the ChatClient Application'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** ChatClient 应用程序的命令'
- en: '| **Command** | **Description** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/quit [message]` | Quit client with optional message |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `/quit [消息]` | 带可选消息退出客户端 |'
- en: '| `/msg user message` | Send a message to a specific user |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `/msg 用户消息` | 向特定用户发送消息 |'
- en: '| `/list` | List other users on the system |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `/list` | 列出系统中的其他用户 |'
- en: '| `/help` | Print help information |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `/help` | 打印帮助信息 |'
- en: You’re ready to generate traffic between the SuperFunkyChat clients and server.
    Let’s start our analysis by capturing and inspecting some traffic using Wireshark.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好在 SuperFunkyChat 客户端和服务器之间生成流量。让我们通过使用 Wireshark 捕获并检查一些流量来开始分析。
- en: '**A Crash Course in Analysis with Wireshark**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Wireshark 分析速成课程**'
- en: In [Chapter 2](../Text/ch02.xhtml#ch02), I introduced Wireshark but didn’t go
    into any detail on how to use Wireshark to analyze rather than simply capture
    traffic. Because Wireshark is a very powerful and comprehensive tool, I’ll only
    scratch the surface of its functionality here. When you first start Wireshark
    on Windows, you should see a window similar to the one shown in [Figure 5-1](../Text/ch05.xhtml#ch5fig1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](../Text/ch02.xhtml#ch02)中，我介绍了 Wireshark，但并没有详细讲解如何使用 Wireshark 进行分析，而不仅仅是捕获流量。由于
    Wireshark 是一个非常强大且全面的工具，这里我只会简单介绍它的一些功能。当你在 Windows 上第一次启动 Wireshark 时，你应该会看到一个类似于[图
    5-1](../Text/ch05.xhtml#ch5fig1)所示的窗口。
- en: '![image](../Images/f05-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-01.jpg)'
- en: '*Figure 5-1: The main Wireshark window on Windows*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：Windows 上的 Wireshark 主窗口*'
- en: The main window allows you to choose the interface to capture traffic from.
    To ensure we capture only the traffic we want to analyze, we need to configure
    some options on the interface. Select **Capture** ▸ **Options** from the menu.
    [Figure 5-2](../Text/ch05.xhtml#ch5fig2) shows the options dialog that opens.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主窗口允许你选择捕获流量的接口。为了确保我们只捕获想要分析的流量，我们需要在接口上配置一些选项。选择 **Capture** ▸ **Options**
    菜单项。[图 5-2](../Text/ch05.xhtml#ch5fig2) 显示了打开的选项对话框。
- en: '![image](../Images/f05-02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-02.jpg)'
- en: '*Figure 5-2: The Wireshark Capture Interfaces dialog*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：Wireshark 捕获接口对话框*'
- en: Select the network interface you want to capture traffic from, as shown at ➊.
    Because we’re using Windows, choose **Local Area Connection**, which is our main
    Ethernet connection; we can’t easily capture from Localhost. Then set a capture
    filter ➋. In this case, we specify the filter **ip host 192.168.10.102** to limit
    capture to traffic to or from the IP address 192.168.10.102\. (The IP address
    we’re using is the chat server’s address. Change the IP address as appropriate
    for your configuration.) Click the **Start** button to begin capturing traffic.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你希望捕获流量的网络接口，如图 ➊ 所示。因为我们使用的是 Windows 系统，选择 **本地连接**，这是我们的主要以太网连接；我们无法轻易地从本地主机捕获流量。然后设置一个捕获过滤器
    ➋。在这种情况下，我们指定过滤器 **ip host 192.168.10.102**，以限制只捕获到或来自 IP 地址 192.168.10.102 的流量。（我们使用的
    IP 地址是聊天服务器的地址。根据你的配置，适当更改 IP 地址。）点击 **开始** 按钮开始捕获流量。
- en: '***Generating Network Traffic and Capturing Packets***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成网络流量并捕获数据包***'
- en: The main approach to packet analysis is to generate as much traffic from the
    target application as possible to improve your chances of finding its various
    protocol structures. For example, [Listing 5-4](../Text/ch05.xhtml#ch5list4) shows
    a single session with ChatClient for `alice`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包分析的主要方法是尽可能多地生成来自目标应用程序的流量，以提高你找到其各种协议结构的机会。例如，[列表 5-4](../Text/ch05.xhtml#ch5list4)
    显示了 `alice` 的单个 ChatClient 会话。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-4: Single ChatClient session for `alice`.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：`alice` 的单个 ChatClient 会话。*'
- en: And [Listing 5-5](../Text/ch05.xhtml#ch5list5) and [Listing 5-6](../Text/ch05.xhtml#ch5list6)
    show two sessions for `bob`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](../Text/ch05.xhtml#ch5list5) 和 [列表 5-6](../Text/ch05.xhtml#ch5list6)
    显示了 `bob` 的两个会话。'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-5: First ChatClient session for `bob`*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：`bob` 的第一次 ChatClient 会话*'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-6: Second ChatClient session for `bob`*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：`bob` 的第二次 ChatClient 会话*'
- en: We run two sessions for `bob` so we can capture any connection or disconnection
    events that might only occur between sessions. In each session, a right angle
    bracket (`>`) indicates a command to enter into the ChatClient, and a left angle
    bracket (`<`) indicates responses from the server being written to the console.
    You can execute the commands to the client for each of these session captures
    to reproduce the rest of the results in this chapter for analysis.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `bob` 运行了两个会话，以便捕获可能仅发生在会话之间的连接或断开连接事件。在每个会话中，右尖括号（`>`）表示要输入 ChatClient
    的命令，左尖括号（`<`）表示从服务器写入控制台的响应。你可以执行这些会话捕获中的命令，重现本章中的其余结果以进行分析。
- en: Now turn to Wireshark. If you’ve configured Wireshark correctly and bound it
    to the correct interface, you should start seeing packets being captured, as shown
    in [Figure 5-3](../Text/ch05.xhtml#ch5fig3).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到 Wireshark。如果你已经正确配置了 Wireshark 并将其绑定到正确的接口，你应该开始看到捕获的数据包，如 [图 5-3](../Text/ch05.xhtml#ch5fig3)
    所示。
- en: '![image](../Images/f05-03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-03.jpg)'
- en: '*Figure 5-3: Captured traffic in Wireshark*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：Wireshark 中捕获的流量*'
- en: After running the example sessions, stop the capture by clicking the **Stop**
    button (highlighted) and save the packets for later use if you want.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行完示例会话后，点击 **停止** 按钮（高亮显示）停止捕获，并保存数据包以备后续使用（如果需要）。
- en: '***Basic Analysis***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基础分析***'
- en: Let’s look at the traffic we’ve captured. To get an overview of the communication
    that occurred during the capture period, choose among the options on the Statistics
    menu. For example, choose **Statistics** ▸ **Conversations**, and you should see
    a new window displaying high-level conversations such as TCP sessions, as shown
    in the Conversations window in [Figure 5-4](../Text/ch05.xhtml#ch5fig4).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们捕获的流量。要概览捕获期间发生的通信，可以在统计菜单中选择相应的选项。例如，选择 **统计** ▸ **会话**，你应该看到一个新窗口显示高层次的会话信息，如
    [图 5-4](../Text/ch05.xhtml#ch5fig4) 中会话窗口所示的 TCP 会话。
- en: '![image](../Images/f05-04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-04.jpg)'
- en: '*Figure 5-4: The Wireshark Conversations window*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：Wireshark 会话窗口*'
- en: The Conversations window shows three separate TCP conversations in the captured
    traffic. We know that the SuperFunkyChat client application uses port 12345, because
    we see three separate TCP sessions coming from port 12345\. These sessions should
    correspond to the three client sessions shown in [Listing 5-4](../Text/ch05.xhtml#ch5list4),
    [Listing 5-5](../Text/ch05.xhtml#ch5list5), and [Listing 5-6](../Text/ch05.xhtml#ch5list6).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 会话窗口显示了在捕获流量中三个独立的 TCP 会话。我们知道 SuperFunkyChat 客户端应用程序使用端口 12345，因为我们看到有三个独立的
    TCP 会话来自端口 12345。 这些会话应与 [列表 5-4](../Text/ch05.xhtml#ch5list4)、[列表 5-5](../Text/ch05.xhtml#ch5list5)
    和 [列表 5-6](../Text/ch05.xhtml#ch5list6) 中显示的三个客户端会话相对应。
- en: '***Reading the Contents of a TCP Session***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***读取 TCP 会话的内容***'
- en: To view the captured traffic for a single conversation, select one of the conversations
    in the Conversations window and click the **Follow Stream** button. A new window
    displaying the contents of the stream as ASCII text should appear, as shown in
    [Figure 5-5](../Text/ch05.xhtml#ch5fig5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看单个对话的捕获流量，请在“会话”窗口中选择一个对话并点击**跟踪流**按钮。此时应该会弹出一个新窗口，显示流的内容，内容以 ASCII 文本形式呈现，如[图
    5-5](../Text/ch05.xhtml#ch5fig5)所示。
- en: '![image](../Images/f05-05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-05.jpg)'
- en: '*Figure 5-5: Displaying the contents of a TCP session in Wireshark’s Follow
    TCP Stream view*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：在 Wireshark 的“跟踪 TCP 流”视图中显示 TCP 会话内容*'
- en: Wireshark replaces data that can’t be represented as ASCII characters with a
    single dot character, but even with that character replacement, it’s clear that
    much of the data is being sent in plaintext. That said, the network protocol is
    clearly not exclusively a text-based protocol because the control information
    for the data is nonprintable characters. The only reason we’re seeing text is
    that SuperFunkyChat’s primary purpose is to send text messages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 将无法表示为 ASCII 字符的数据替换为一个点字符，但即使进行字符替换，我们也能清楚地看到许多数据以明文形式发送。也就是说，网络协议显然不是纯文本协议，因为数据的控制信息是不可打印字符。我们之所以看到文本，是因为
    SuperFunkyChat 的主要目的是发送文本消息。
- en: 'Wireshark shows the inbound and outbound traffic in a session using different
    colors: pink for outbound traffic and blue for inbound. In a TCP session, outbound
    traffic is from the client that initiated the TCP session, and inbound traffic
    is from the TCP server. Because we’ve captured all traffic to the server, let’s
    look at another conversation. To change the conversation, change the Stream number
    ➊ in [Figure 5-5](../Text/ch05.xhtml#ch5fig5) to 1\. You should now see a different
    conversation, for example, like the one in [Figure 5-6](../Text/ch05.xhtml#ch5fig6).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark 使用不同的颜色显示会话中的进出流量：粉色表示出站流量，蓝色表示入站流量。在 TCP 会话中，出站流量来自发起 TCP 会话的客户端，而入站流量来自
    TCP 服务器。因为我们已经捕获了所有到服务器的流量，接下来让我们看一下另一段对话。要更改对话，请将[图 5-5](../Text/ch05.xhtml#ch5fig5)中的流号
    ➊更改为 1\. 现在你应该能看到一段不同的对话，比如[图 5-6](../Text/ch05.xhtml#ch5fig6)中的那一段。
- en: '![image](../Images/f05-06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-06.jpg)'
- en: '*Figure 5-6: A second TCP session from a different client*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：来自不同客户端的第二个 TCP 会话*'
- en: Compare [Figure 5-6](../Text/ch05.xhtml#ch5fig6) to [Figure 5-5](../Text/ch05.xhtml#ch5fig5);
    you’ll see the details of the two sessions are different. Some text sent by the
    client (in [Figure 5-6](../Text/ch05.xhtml#ch5fig6)), such as “How are you?”,
    is shown as received by the server in [Figure 5-5](../Text/ch05.xhtml#ch5fig5).
    Next, we’ll try to determine what those binary parts of the protocol represent.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将[图 5-6](../Text/ch05.xhtml#ch5fig6)与[图 5-5](../Text/ch05.xhtml#ch5fig5)进行比较，你会看到两个会话的详细信息不同。在[图
    5-6](../Text/ch05.xhtml#ch5fig6)中客户端发送的某些文本，比如“你好吗？”，会显示为服务器在[图 5-5](../Text/ch05.xhtml#ch5fig5)中接收到的内容。接下来，我们将尝试确定协议中的那些二进制部分表示什么。
- en: '**Identifying Packet Structure with Hex Dump**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过十六进制转储识别数据包结构**'
- en: At this point, we know that our subject protocol seems to be part binary and
    part text, which indicates that looking at just the printable text won’t be enough
    to determine all the various structures in the protocol.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们知道我们的协议似乎既包含二进制数据也包含文本，这表明仅查看可打印文本不足以确定协议中所有的各种结构。
- en: To dig in, we first return to Wireshark’s Follow TCP Stream view, as shown in
    [Figure 5-5](../Text/ch05.xhtml#ch5fig5), and change the Show and save data as
    drop-down menu to the **Hex Dump** option. The stream should now look similar
    to [Figure 5-7](../Text/ch05.xhtml#ch5fig7).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入分析，我们首先回到 Wireshark 的“跟踪 TCP 流”视图，如[图 5-5](../Text/ch05.xhtml#ch5fig5)所示，并将“显示并保存数据为”下拉菜单更改为**十六进制转储**选项。此时流应该看起来像[图
    5-7](../Text/ch05.xhtml#ch5fig7)中的样子。
- en: '![image](../Images/f05-07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-07.jpg)'
- en: '*Figure 5-7: The Hex Dump view of the stream*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：流的十六进制转储视图*'
- en: The Hex Dump view shows three columns of information. The column at the very
    left ➊ is the byte offset into the stream for a particular direction. For example,
    the byte at 0 is the first byte sent in that direction, the byte 4 is the fifth,
    and so on. The column in the center ➋ shows the bytes as a hex dump. The column
    at the right ➌ is the ASCII representation, which we saw previously in [Figure
    5-5](../Text/ch05.xhtml#ch5fig5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制转储视图显示了三列信息。最左边的列 ➊ 是特定方向上数据流的字节偏移。例如，偏移量为 0 的字节是该方向上发送的第一个字节，偏移量为 4 的字节是第五个字节，以此类推。中间的列
    ➋ 显示的是字节的十六进制转储。右边的列 ➌ 是 ASCII 表示形式，我们之前在 [图 5-5](../Text/ch05.xhtml#ch5fig5)
    中看到过。
- en: '***Viewing Individual Packets***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看单个数据包***'
- en: Notice how the blocks of bytes shown in the center column in [Figure 5-7](../Text/ch05.xhtml#ch5fig7)
    vary in length. Compare this again to [Figure 5-6](../Text/ch05.xhtml#ch5fig6);
    you’ll see that other than being separated by direction, all data in [Figure 5-6](../Text/ch05.xhtml#ch5fig6)
    appears as one contiguous block. In contrast, the data in [Figure 5-7](../Text/ch05.xhtml#ch5fig7)
    might appear as just a few blocks of 4 bytes, then a block of 1 byte, and finally
    a much longer block containing the main group of text data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 [图 5-7](../Text/ch05.xhtml#ch5fig7) 中，中间列显示的字节块长度是如何变化的。再次与 [图 5-6](../Text/ch05.xhtml#ch5fig6)
    进行比较，你会发现，除了按方向分隔外，[图 5-6](../Text/ch05.xhtml#ch5fig6) 中的所有数据都呈现为一个连续的块。相比之下，[图
    5-7](../Text/ch05.xhtml#ch5fig7) 中的数据可能仅显示为几个 4 字节的小块，然后是一个 1 字节的块，最后是一个包含主要文本数据的大块。
- en: 'What we’re seeing in Wireshark are individual packets: each block is a single
    TCP packet, or *segment*, containing perhaps only 4 bytes of data. TCP is a stream-based
    protocol, which means that there are no real boundaries between consecutive blocks
    of data when you’re reading and writing data to a TCP socket. However, from a
    physical perspective, there’s no such thing as a real stream-based network transport
    protocol. Instead, TCP sends individual packets consisting of a TCP header containing
    information, such as the source and destination port numbers as well as the data.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Wireshark 中看到的是单个数据包：每个块都是一个单独的 TCP 数据包，或称为 *段*，可能仅包含 4 字节的数据。TCP 是基于流的协议，这意味着在你读取和写入数据到
    TCP 套接字时，连续的数据块之间没有真正的边界。然而，从物理角度来看，实际上并不存在一个真正的基于流的网络传输协议。相反，TCP 发送的是由包含信息的 TCP
    头部组成的单个数据包，这些信息包括源端口和目标端口号以及数据内容。
- en: In fact, if we return to the main Wireshark window, we can find a packet to
    prove that Wireshark is displaying single TCP packets. Select **Edit** ▸ **Find
    Packet**, and an additional drop-down menu appears in the main window, as shown
    [Figure 5-8](../Text/ch05.xhtml#ch5fig8).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果我们返回到主 Wireshark 窗口，我们可以找到一个数据包来证明 Wireshark 正在显示单个 TCP 数据包。选择 **编辑**
    ▸ **查找数据包**，主窗口中将出现一个额外的下拉菜单，如图 [5-8](../Text/ch05.xhtml#ch5fig8) 所示。
- en: '![image](../Images/f05-08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-08.jpg)'
- en: '*Figure 5-8: Finding a packet in Wireshark’s main window*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：在 Wireshark 主窗口中查找数据包*'
- en: We’ll find the first value shown in [Figure 5-7](../Text/ch05.xhtml#ch5fig7),
    the string `BINX`. To do this, fill in the Find options as shown in [Figure 5-8](../Text/ch05.xhtml#ch5fig8).
    The first selection box indicates where in the packet capture to search. Specify
    that you want to search in the Packet bytes ➊. Leave the second selection box
    as Narrow & Wide, which indicates that you want to search for both ASCII and Unicode
    strings. Also leave the Case sensitive box unchecked and specify that you want
    to look for a String value ➋ in the third drop-down menu. Then enter the string
    value we want to find, in this case the string `BINX` ➌. Finally, click the **Find**
    button, and the main window should automatically scroll and highlight the first
    packet Wireshark finds that contains the `BINX` string ➍. In the middle window
    at ➎, you should see that the packet contains 4 bytes, and you can see the raw
    data in the bottom window, which shows that we’ve found the `BINX` string ➏. We
    now know that the Hex Dump view Wireshark displays in [Figure 5-8](../Text/ch05.xhtml#ch5fig8)
    represents packet boundaries because the `BINX` string is in a packet of its own.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[图5-7](../Text/ch05.xhtml#ch5fig7)中找到第一个显示的值，即字符串`BINX`。为此，请按照[图5-8](../Text/ch05.xhtml#ch5fig8)所示填写查找选项。第一个选择框表示要在数据包捕获中查找的位置。指定要在数据包字节➊中进行查找。第二个选择框保持为“Narrow
    & Wide”，这表示您要查找ASCII和Unicode字符串。还请保持“区分大小写”框未选中，并在第三个下拉菜单中指定要查找字符串值➋。然后输入我们要查找的字符串值，在本例中是字符串`BINX`
    ➌。最后，点击**查找**按钮，主窗口应该会自动滚动并高亮显示Wireshark找到的第一个包含`BINX`字符串的数据包➍。在位于➎的中间窗口中，您应该看到数据包包含4个字节，并且您可以在底部窗口看到原始数据，这表明我们找到了`BINX`字符串➏。现在我们知道，Wireshark在[图5-8](../Text/ch05.xhtml#ch5fig8)中显示的十六进制转储视图代表数据包边界，因为`BINX`字符串位于一个独立的数据包中。
- en: '***Determining the Protocol Structure***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***确定协议结构***'
- en: To simplify determining the protocol structure, it makes sense to look only
    at one direction of the network communication. For example, let’s just look at
    the outbound direction (from client to server) in Wireshark. Returning to the
    Follow TCP Stream view, select the **Hex Dump** option in the Show and save data
    as drop-down menu. Then select the traffic direction from the client to the server
    on port 12345 from the drop-down menu at ➊, as shown in [Figure 5-9](../Text/ch05.xhtml#ch5fig9).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化协议结构的确定，最好只观察网络通信的一个方向。例如，我们只看Wireshark中的出站方向（从客户端到服务器）。回到“跟踪TCP流”视图，在“显示并保存数据为”下拉菜单中选择**十六进制转储**选项。然后，从➊的下拉菜单中选择从客户端到服务器的流量方向，端口号为12345，如[图5-9](../Text/ch05.xhtml#ch5fig9)所示。
- en: '![image](../Images/f05-09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-09.jpg)'
- en: '*Figure 5-9: A hex dump showing only the outbound direction*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-9：仅显示出站方向的十六进制转储*'
- en: Click the **Save as . . .** button to copy the outbound traffic hex dump to
    a text file to make it easier to inspect. [Listing 5-7](../Text/ch05.xhtml#ch5list7)
    shows a small sample of that traffic saved as text.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**另存为 . . .**按钮，将出站流量的十六进制转储复制到文本文件中，方便检查。[列表5-7](../Text/ch05.xhtml#ch5list7)显示了保存为文本的小部分流量。
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-7: A snippet of outbound traffic*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表5-7：出站流量的片段*'
- en: The outbound stream begins with the four characters `BINX` ➊. These characters
    are never repeated in the rest of the data stream, and if you compare different
    sessions, you’ll always find the same four characters at the start of the stream.
    If I were unfamiliar with this protocol, my intuition at this point would be that
    this is a magic value sent from the client to the server to tell the server that
    it’s talking to a valid client rather than some other application that happens
    to have connected to the server’s TCP port.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 出站流开始时有四个字符`BINX` ➊。这些字符在数据流的其余部分中从未重复出现，如果您比较不同的会话，您会发现流的开头总是这四个字符。如果我对这个协议不熟悉，此时我的直觉是，这是一个从客户端发送到服务器的魔法值，用来告诉服务器它正在与一个有效的客户端通信，而不是与一个偶然连接到服务器TCP端口的其他应用程序通信。
- en: Following the stream, we see that a sequence of four blocks is sent. The blocks
    at ➋ and ➌ are 4 bytes, the block at ➍ is 1 byte, and the block at ➎ is larger
    and contains mostly readable text. Let’s consider the first block of 4 bytes at
    ➋. Might these represent a small number, say the integer value 0xD or 13 in decimal?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着数据流，我们看到发送了四个块。位于➋和➌的块是4字节，位于➍的块是1字节，而位于➎的块较大，包含大部分可读文本。我们来考虑位于➋的第一个4字节块。这些字节可能代表一个小数字，比如十六进制值0xD或十进制值13吗？
- en: Recall the discussion of the Tag, Length, Value (TLV) pattern in [Chapter 3](../Text/ch03.xhtml#ch03).
    TLV is a very simple pattern in which each block of data is delimited by a value
    representing the length of the data that follows. This pattern is especially important
    for stream-based protocols, such as those running over TCP, because otherwise
    the application doesn’t know how much data it needs to read from a connection
    to process the protocol. If we assume that this first value is the length of the
    data, does this length match the length of the rest of the packet? Let’s find
    out.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾在[第3章](../Text/ch03.xhtml#ch03)中讨论的标签、长度、值（TLV）模式。TLV是一种非常简单的模式，其中每个数据块都由一个表示后续数据长度的值进行分隔。这个模式对于基于流的协议尤其重要，比如那些运行在TCP上的协议，因为如果没有这个模式，应用程序就无法知道它需要从连接中读取多少数据来处理协议。如果我们假设第一个值是数据的长度，这个长度与数据包其余部分的长度是否匹配呢？让我们来验证一下。
- en: Count the total bytes of the blocks at ➋, ➌, ➍, and ➎, which seem to be a single
    packet, and the result is 21 bytes, which is eight more than the value of 13 we
    were expecting (the integer value 0xD). The value of the length block might not
    be counting its own length. If we remove the length block (which is 4 bytes),
    the result is 17, which is 4 bytes more than the target length but getting closer.
    We also have the other unknown 4-byte block at ➌ following the potential length,
    but perhaps that’s not counted either. Of course, it’s easy to speculate, but
    facts are more important, so let’s do some testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 统计➋、➌、➍和➎处数据块的总字节数，这些数据看起来是一个单独的数据包，结果为21字节，比我们预期的13字节多了8字节（即整数值0xD）。长度块的值可能没有计入它自己的长度。如果我们去掉长度块（4字节），结果是17字节，比目标长度多了4字节，但更接近了。我们还注意到在➌处有一个其他未知的4字节数据块，它可能紧跟在潜在的长度块之后，也许它没有被计算在内。当然，这只是猜测，事实更为重要，因此我们需要进行一些测试。
- en: '***Testing Our Assumptions***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试我们的假设***'
- en: At this point in such an analysis, I stop staring at a hex dump because it’s
    not the most efficient approach. One way to quickly test whether our assumptions
    are right is to export the data for the stream and write some simple code to parse
    the structure. Later in this chapter, we’ll write some code for Wireshark to do
    all of our testing within the GUI, but for now we’ll implement the code using
    Python on the command line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这样的分析时，我通常会停止盯着十六进制转储，因为这不是最有效的方法。验证我们的假设是否正确的一种快速方法是导出流的数据，并编写一些简单的代码来解析结构。在本章后面，我们将为Wireshark编写一些代码，在GUI内进行所有测试，但现在我们将使用Python在命令行中实现代码。
- en: 'To get our data into Python, we could add support for reading Wireshark capture
    files, but for now we’ll just export the packet bytes to a file. To export the
    packets from the dialog shown in [Figure 5-9](../Text/ch05.xhtml#ch5fig9), follow
    these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据导入Python，我们本可以添加对Wireshark捕获文件的支持，但现在我们只会将数据包字节导出到一个文件。要从[图5-9](../Text/ch05.xhtml#ch5fig9)中显示的对话框中导出数据包，请按照以下步骤操作：
- en: In the Show and save data as drop-down menu, choose the **Raw** option.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“显示和保存数据为”下拉菜单中，选择**原始**选项。
- en: Click **Save As** to export the outbound packets to a binary file called *bytes_outbound.bin*.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**另存为**，将出站数据包导出为名为*bytes_outbound.bin*的二进制文件。
- en: We also want to export the inbound packets, so change to and select the inbound
    conversation. Then save the raw inbound bytes using the preceding steps, but name
    the file *bytes_inbound.bin*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导出入站数据包，所以切换到并选择入站会话。然后，使用前面提到的步骤保存原始入站字节，并将文件命名为*bytes_inbound.bin*。
- en: Now use the XXD tool (or a similar tool) on the command line to be sure that
    we’ve successfully dumped the data, as shown in [Listing 5-8](../Text/ch05.xhtml#ch5list8).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在命令行中使用XXD工具（或类似工具）确保我们成功地导出了数据，如[清单5-8](../Text/ch05.xhtml#ch5list8)所示。
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 5-8: The exported packet bytes*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-8：导出的数据包字节*'
- en: '***Dissecting the Protocol with Python***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用Python解析协议***'
- en: Now we’ll write a simple Python script to dissect the protocol. Because we’re
    just extracting data from a file, we don’t need to write any network code; we
    just need to open the file and read the data. We’ll also need to read binary data
    from the file—specifically, a network byte order integer for the length and unknown
    4-byte block.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写一个简单的Python脚本来解析协议。因为我们只是从文件中提取数据，所以不需要编写任何网络代码；我们只需要打开文件并读取数据。我们还需要从文件中读取二进制数据——具体来说，是网络字节顺序的整数值，表示长度和未知的4字节数据块。
- en: '**Performing the Binary Conversion**'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**执行二进制转换**'
- en: We can use the built-in Python struct library to do the binary conversions.
    The script should fail immediately if something doesn’t seem right, such as not
    being able to read all the data we expect from the file. For example, if the length
    is 100 bytes and we can read only 20 bytes, the read should fail. If no errors
    occur while parsing the file, we can be more confident that our analysis is correct.
    [Listing 5-9](../Text/ch05.xhtml#ch5list9) shows the first implementation, written
    to work in both Python 2 and 3.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 5-9: An example Python script for parsing protocol data*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break down the important parts of the script. First, we define some helper
    functions to read data from the file. The function `read_bytes()` ➊ reads a fixed
    number of bytes from the file specified as a parameter. If not enough bytes are
    in the file to satisfy the read, an exception is thrown to indicate an error ➋.
    We also define a function `read_int()` ➌ to read a 4-byte integer from the file
    in network byte order where the most significant byte of the integer is first
    in the file, as well as define a function to read a single byte ➍. In the main
    body of the script, we open a file passed on the command line and first read a
    4-byte value ➎, which we expect is the magic value `BINX`. Then the code enters
    a loop ➏ while there’s still data to read, reading out the length, the two unknown
    values, and finally the data and then printing the values to the console.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: When you run the script in [Listing 5-9](../Text/ch05.xhtml#ch5list9) and pass
    it the name of a binary file to open, all data from the file should be parsed
    and no errors generated if our analysis that the first 4-byte block was the length
    of the data sent on the network is correct. [Listing 5-10](../Text/ch05.xhtml#ch5list10)
    shows example output in Python 3, which does a better job of displaying binary
    strings than Python 2.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 5-10: Example output from running [Listing 5-9](../Text/ch05.xhtml#ch5list9)
    against a binary file*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling Inbound Data**'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If you ran [Listing 5-9](../Text/ch05.xhtml#ch5list9) against an exported inbound
    data set, you would immediately get an error because there’s no magic string `BINX`
    in the inbound protocol, as shown in [Listing 5-11](../Text/ch05.xhtml#ch5list11).
    Of course, this is what we would expect if there were a mistake in our analysis
    and the length field wasn’t quite as simple as we thought.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 5-11 Error generated by [Listing 5-9](../Text/ch05.xhtml#ch5list9)
    on inbound data*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We can clear up this error by modifying the script slightly to include a check
    for the magic value and reset the file pointer if it’s not equal to the string
    `BINX`. Add the following line just after the file is opened in the original script
    to reset the file pointer to the start if the magic value is incorrect.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, with this small modification, the script will execute successfully on the
    inbound data and result in the output shown in [Listing 5-12](../Text/ch05.xhtml#ch5list12).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 5-12: Output of modified script on inbound data*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Digging into the Unknown Parts of the Protocol**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can use the output in [Listing 5-10](../Text/ch05.xhtml#ch5list10) and [Listing
    5-12](../Text/ch05.xhtml#ch5list12) to start delving into the unknown parts of
    the protocol. First, consider the field labeled `Unk1`. The values it takes seem
    to be different for every packet, but the values are low, ranging from 1 to 3146.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: But the most informative parts of the output are the following two entries,
    one from the outbound data and one from the inbound.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that in both entries the value of `Unk1` is the same as `Unk2`. That
    could be a coincidence, but the fact that both entries have the same value might
    indicate something important. Also notice that in the second entry the length
    is `2`, which includes the `Unk2` value and a `0` data value, whereas the length
    of the first entry is only `1` with no trailing data after the `Unk2` value. Perhaps
    `Unk1` is directly related to the data in the packet? Let’s find out.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculating the Checksum**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s common to add a checksum to a network protocol. The canonical example of
    a checksum is just the sum of all the bytes in the data you want to check for
    errors. If we assume that the unknown value is a *simple* checksum, we can sum
    all the bytes in the example outbound and inbound packets I highlighted in the
    preceding section, resulting in the calculated sum shown in [Table 5-2](../Text/ch05.xhtml#ch5tab2).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** Testing Checksum for Example Packets'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '| **Unknown value** | **Data bytes** | **Sum of data bytes** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| 6 | 6 | 6 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1, 0 | 1 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: Although [Table 5-2](../Text/ch05.xhtml#ch5tab2) seems to confirm that the unknown
    value matches our expectation of a simple checksum for very simple packets, we
    still need to verify that the checksum works for larger and more complex packets.
    There are two easy ways to determine whether we’ve guessed correctly that the
    unknown value is a checksum over the data. One way is to send simple, incrementing
    messages from a client (like *A*, then *B*, then *C*, and so on), capture the
    data, and analyze it. If the checksum is a simple addition, the value should increment
    by 1 for each incrementing message. The alternative would be to add a function
    to calculate the checksum to see whether the checksum matches between what was
    captured on the network and our calculated value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: To test our assumptions, add the code in [Listing 5-13](../Text/ch05.xhtml#ch5list13)
    to the script in Listing 5-7 and add a call to it after reading the data to calculate
    the checksum. Then just compare the value extracted from the network capture as
    `Unk1` and the calculated value to see whether our calculated checksum matches.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 5-13: Calculating the checksum of a packet*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: And it does! The numbers calculated match the value of `Unk1`. So, we’ve discovered
    the next part of the protocol structure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Discovering a Tag Value**'
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now we need to determine what `Unk2` might represent. Because the value of `Unk2`
    is considered part of the packet’s data, it’s presumably related to the meaning
    of what is being sent. However, as we saw at ➍ in [Listing 5-7](../Text/ch05.xhtml#ch5list7),
    the value of `Unk2` is being written to the network as a single byte value, which
    indicates that it’s actually separate from the data. Perhaps the value represents
    the Tag part of a TLV pattern, just as we suspect that Length is the Value part
    of that construction.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether `Unk2` is in fact the Tag value and a representation of
    how to interpret the rest of the data, we’ll exercise the ChatClient as much as
    possible, try all possible commands, and capture the results. We can then perform
    basic analysis comparing the value of `Unk2` when sending the same type of command
    to see whether the value of `Unk2` is always the same.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the client sessions in [Listing 5-4](../Text/ch05.xhtml#ch5list4),
    [Listing 5-5](../Text/ch05.xhtml#ch5list5), and [Listing 5-6](../Text/ch05.xhtml#ch5list6).
    In the session in [Listing 5-5](../Text/ch05.xhtml#ch5list5), we sent two messages,
    one after another. We’ve already analyzed this session using our Python script
    in [Listing 5-10](../Text/ch05.xhtml#ch5list10). For simplicity, [Listing 5-14](../Text/ch05.xhtml#ch5list14)
    shows only the first three capture packets (with the latest version of the script).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 5-14: The first three packets from the session represented by [Listing
    5-5](../Text/ch05.xhtml#ch5list5)*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The first packet ➊ doesn’t correspond to anything we typed into the client session
    in [Listing 5-5](../Text/ch05.xhtml#ch5list5). The unknown value is `0`. The two
    messages we then sent in [Listing 5-5](../Text/ch05.xhtml#ch5list5) are clearly
    visible as text in the `Data` part of the packets at ➋ and ➌. The `Unk2` values
    for both of those messages is `3`, which is different from the first packet’s
    value of `0`. Based on this observation, we can assume that the value of `3` might
    represent a packet that is sending a message, and if that’s the case, we’d expect
    to find a value of `3` used in every connection when sending a single value. In
    fact, if you now analyze a different session containing messages being sent, you’ll
    find the same value of `3` used whenever a message is sent.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '*At this stage in my analysis, I’d return to the various client sessions and
    try to correlate the action I performed in the client with the messages sent.
    Also, I’d correlate the messages I received from the server with the client’s
    output. Of course, this is easy when there’s likely to be a one-to-one match between
    the command we use in the client and the result on the network. However, more
    complex protocols and applications might not be that obvious, so you’ll have to
    do a lot of correlation and testing to try to discover all the possible values
    for particular parts of the protocol.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: We can assume that `Unk2` represents the Tag part of the TLV structure. Through
    further analysis, we can infer the possible Tag values, as shown in [Table 5-3](../Text/ch05.xhtml#ch5tab3).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-3:** Inferred Commands from Analysis of Captured Sessions'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command number** | **Direction** | **Description** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| 0 | Outbound | Sent when client connects to server. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| 1 | Inbound | Sent from server after client sends command `''0''` to the
    server. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| 2 | Both | Sent from client when `/quit` command is used. Sent by server
    in response. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| 3 | Both | Sent from client with a message for all users. Sent from server
    with the message from all users. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| 5 | Outbound | Sent from client when `/msg` command is used. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| 6 | Outbound | Sent from client when `/list` command is used. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| 7 | Inbound | Sent from server in response to `/list` command. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ve built a table of commands but we still don’t know how the data for each
    of these commands is represented. To further analyze that data, we’ll return to
    Wireshark and develop some code to dissect the protocol and display it in the
    GUI. It can be difficult to deal with simple binary files, and although we could
    use a tool to parse a capture file exported from Wireshark, it’s best to have
    Wireshark handle a lot of that work.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Developing Wireshark Dissectors in Lua**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s easy to analyze a known protocol like HTTP with Wireshark because the
    software can extract all the necessary information. But custom protocols are a
    bit more challenging: to analyze them, we’ll have to manually extract all the
    relevant information from a byte representation of the network traffic.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can use the Wireshark plug-in Protocol Dissectors to add additional
    protocol analysis to Wireshark. Doing so used to require building a dissector
    in C to work with your particular version of Wireshark, but modern versions of
    Wireshark support the Lua scripting language. The scripts you write in Lua will
    also work with the tshark command line tool.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: This section describes how to develop a simple Lua script dissector for the
    SuperFunkyChat protocol that we’ve been analyzing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '*Details about developing in Lua and the Wireshark APIs are beyond the scope
    of this book. For more information on how to develop in Lua, visit its official
    website at [https://www.lua.org/docs.html](https://www.lua.org/docs.html). The
    Wireshark website, and especially the Wiki, are the best places to visit for various
    tutorials and example code* ([https://wiki.wireshark.org/Lua/](https://wiki.wireshark.org/Lua/)).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Before developing the dissector, make sure your copy of Wireshark supports Lua
    by checking the About Wireshark dialog at **Help** ▸ **About Wireshark**. If you
    see the word *Lua* in the dialog, as shown in [Figure 5-10](../Text/ch05.xhtml#ch5fig10),
    you should be good to go.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f05-10.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-10: The Wireshark About dialog showing Lua support*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '*If you run Wireshark as root on a Unix-like system, Wireshark will typically
    disable Lua support for security reasons, and you’ll need to configure Wireshark
    to run as a nonprivileged user to capture and run Lua scripts. See the Wireshark
    documentation for your operating system to find out how to do so securely.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你以 root 用户身份在类 Unix 系统上运行 Wireshark，Wireshark 通常会出于安全原因禁用 Lua 支持，且你需要将 Wireshark
    配置为非特权用户来捕获并运行 Lua 脚本。请参阅你的操作系统的 Wireshark 文档，了解如何安全地进行配置。*'
- en: You can develop dissectors for almost any protocol that Wireshark will capture,
    including TCP and UDP. It’s much easier to develop dissectors for UDP protocols
    than it is for TCP, because each captured UDP packet typically has everything
    needed by the dissector. With TCP, you’ll need to deal with such problems as data
    that spans multiple packets (which is exactly why we needed to account for length
    block in our work on SuperFunkyChat using the Python script in [Listing 5-9](../Text/ch05.xhtml#ch5list9)).
    Because UDP is easier to work with, we’ll focus on developing UDP dissectors.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 Wireshark 捕获的几乎任何协议开发解码器，包括 TCP 和 UDP。开发 UDP 协议的解码器比 TCP 更容易，因为每个捕获的 UDP
    包通常包含了解码器所需的所有信息。而对于 TCP，你需要处理跨多个数据包的数据（这正是我们在使用 Python 脚本处理 SuperFunkyChat 时需要考虑数据长度块问题的原因，见[清单
    5-9](../Text/ch05.xhtml#ch5list9)）。由于 UDP 更易处理，我们将专注于开发 UDP 解码器。
- en: Conveniently enough, SuperFunkyChat supports a UDP mode by passing the `--udp`
    command line parameter to the client when starting. Send this flag while capturing,
    and you should see packets similar to those shown in [Figure 5-11](../Text/ch05.xhtml#ch5fig11).
    (Notice that Wireshark mistakenly tries to dissect the traffic as an unrelated
    GVSP protocol, as displayed in the Protocol column ➊. Implementing our own dissector
    will fix the mistaken protocol choice.)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，SuperFunkyChat 支持通过在启动客户端时传递 `--udp` 命令行参数来启用 UDP 模式。在捕获数据时发送此标志，你应该能看到类似于[图
    5-11](../Text/ch05.xhtml#ch5fig11)所示的包。（注意，Wireshark 错误地试图将流量解析为不相关的 GVSP 协议，如协议列
    ➊ 所示。实现我们自己的解码器将修正这一错误的协议选择。）
- en: '![image](../Images/f05-11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-11.jpg)'
- en: '*Figure 5-11: Wireshark showing captured UDP traffic*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11: Wireshark 显示捕获的 UDP 流量*'
- en: 'One way to load Lua files is to put your scripts in the *%APPDATA%\Wireshark\plugins*
    directory on Windows and in the *~/.config/wireshark/plugins* directory on Linux
    and macOS. You can also load a Lua script by specifying it on the command line
    as follows, replacing the path information with the location of your script:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 Lua 文件的一种方法是将脚本放置在 Windows 系统中的 *%APPDATA%\Wireshark\plugins* 目录下，或在 Linux
    和 macOS 系统中的 *~/.config/wireshark/plugins* 目录下。你也可以通过在命令行中指定 Lua 脚本来加载，方法如下，将路径信息替换为你脚本的存储位置：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If there’s an error in your script’s syntax, you should see a message dialog
    similar to [Figure 5-12](../Text/ch05.xhtml#ch5fig12). (Granted, this isn’t exactly
    the most efficient way to develop, but it’s fine as long as you’re just prototyping.)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的脚本语法有误，你应该会看到类似于[图 5-12](../Text/ch05.xhtml#ch5fig12)所示的消息对话框。（虽然这不是开发过程中最高效的方式，但只要你只是进行原型开发，这样也没问题。）
- en: '![image](../Images/f05-12.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/f05-12.jpg)'
- en: '*Figure 5-12: The Wireshark Lua error dialog*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-12: Wireshark Lua 错误对话框*'
- en: '***Creating the Dissector***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建解码器***'
- en: To create a protocol dissector for the SuperFunkyChat protocol, first create
    the basic shell of the dissector and register it in Wireshark’s list of dissectors
    for UDP port 12345\. Copy [Listing 5-15](../Text/ch05.xhtml#ch5list15) into a
    file called *dissector.lua* and load it into Wireshark along with an appropriate
    packet capture of the UDP traffic. It should run without errors.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 SuperFunkyChat 协议创建协议解码器，首先创建解码器的基本框架，并将其注册到 Wireshark 的 UDP 端口 12345 的解码器列表中。将[清单
    5-15](../Text/ch05.xhtml#ch5list15)复制到一个名为 *dissector.lua* 的文件中，并将其与相应的 UDP 流量数据包捕获一起加载到
    Wireshark 中。它应该能够无误地运行。
- en: dissector.lua
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: dissector.lua
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-15: A basic Lua Wireshark dissector*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-15: 基本的 Lua Wireshark 解码器*'
- en: When the script initially loads, it creates a new instance of the `Proto` class
    ➊, which represents an instance of a Wireshark protocol and assigns it the name
    `chat_proto`. Although you can build the dissected tree manually, I’ve chosen
    to define specific fields for the protocol at ➋ so the fields will be added to
    the display filter engine, and you’ll be able to set a display filter of `chat.command
    == 0` so Wireshark will only show packets with command `0`. (This technique is
    very useful for analysis because you can filter down to specific packets easily
    and analyze them separately.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➌, the script creates a `dissector()` function on the instance of the `Proto`
    class. This `dissector()` will be called to dissect a packet. The function takes
    three parameters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: • A buffer containing the packet data that is an instance of something Wireshark
    calls a Testy Virtual Buffer (TVB).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: • A packet information instance that represents the display information for
    the dissection.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: • The root tree object for the UI. You can attach subnodes to this tree to generate
    your display of the packet data.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: At ➍, we set the name of the protocol in the UI column (as shown in [Figure
    5-11](../Text/ch05.xhtml#ch5fig11)) to `CHAT`. Next, we build a tree of the protocol
    elements ➎ we’re dissecting. Because UDP doesn’t have an explicit length field,
    we don’t need to take that into account; we only need to extract the checksum
    field. We add to the subtree using the protocol fields and use the `buffer` parameter
    to create a range, which takes a start index into the buffer and an optional length.
    If no length is specified, the rest of the buffer is used.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Then we register the protocol dissector with Wireshark’s UDP dissector table.
    (Notice that the function we defined at ➌ hasn’t actually executed yet; we’ve
    simply defined it.) Finally, we get the UDP table and add our `chat_proto` object
    to the table with port 12345 ➏. Now we’re ready to start the dissection.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '***The Lua Dissection***'
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start Wireshark using the script in [Listing 5-15](../Text/ch05.xhtml#ch5list15)
    (for example, using the `–X` parameter) and then load a packet capture of the
    UDP traffic. You should see that the dissector has loaded and dissected the packets,
    as shown in [Figure 5-13](../Text/ch05.xhtml#ch5fig13).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, the Protocol column has changed to `CHAT`. This matches the first line
    of our dissector function in [Listing 5-15](../Text/ch05.xhtml#ch5list15) and
    makes it easier to see that we’re dealing with the correct protocol. At ➋, the
    resulting tree shows the different fields of the protocol with the checksum printed
    in hex, as we specified. If you click the Data field in the tree, the corresponding
    range of bytes should be highlighted in the raw packet display at the bottom of
    the window ➌.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f05-13.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-13: Dissected SuperFunkyChat protocol traffic*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '***Parsing a Message Packet***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s augment the dissector to parse a particular packet. We’ll use command
    `3` as our example because we’ve determined that it marks the sending or receiving
    of a message. Because a received message should show the ID of the sender as well
    as the message text, this packet data should contain both components; this makes
    it a perfect example for our purposes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-16](../Text/ch05.xhtml#ch5list16) shows a snippet from [Listing
    5-10](../Text/ch05.xhtml#ch5list10) when we dumped the traffic using our Python
    script.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 5-16: Example message data*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-16](../Text/ch05.xhtml#ch5list16) shows two examples of message
    packet data in a binary Python string format. The `\xXX` characters are actually
    nonprintable bytes, so `\x05` is really the byte 0x05 and `\x16` is 0x16 (or 22
    in decimal). Two printable strings are in each packet shown in the listing: the
    first is a username (in this case `bob`), and the second is the message. Each
    string is prefixed by a nonprintable character. Very simple analysis (counting
    characters, in this case) indicates that the nonprintable character is the length
    of the string that follows the character. For example, with the username string,
    the nonprintable character represents 0x03, and the string `bob` is three characters
    in length.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write a function to parse a single string from its binary representation.
    We’ll update [Listing 5-15](../Text/ch05.xhtml#ch5list15) to add support for parsing
    the message command in [Listing 5-17](../Text/ch05.xhtml#ch5list17).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: dissector_with
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: _commands.lua
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 5-17: The updated dissector script used to parse the `Message` command*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 5-17](../Text/ch05.xhtml#ch5list17), the added `read_string()` function
    ➊ takes a TVB object (`buffer`) and a starting offset (`start`), and it returns
    the length of the buffer and then the string.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '*What if the string is longer than the range of a byte value? Ah, that’s one
    of the challenges of protocol analysis. Just because something looks simple doesn’t
    mean it actually is simple. We’ll ignore issues such as the length because this
    is only meant as an example, and ignoring length works for any examples we’ve
    captured.*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: With a function to parse the binary strings, we can now add the `Message` command
    to the dissection tree. The code begins by adding the original data tree and creates
    a new TVB object ➋ that only contains the packet’s data. It then extracts the
    command field as an integer and checks whether it’s our `Message` command ➌. If
    it’s not, we leave the existing data tree, but if the field matches, we proceed
    to parse the two strings and add them to the data subtree ➍. However, instead
    of defining specific fields, we can add text nodes by specifying only the proto
    object rather than a field object. If you now reload this file into Wireshark,
    you should see that the username and message strings are parsed, as shown in [Figure
    5-14](../Text/ch05.xhtml#ch5fig14).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/f05-14.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-14: A parsed `Message` command*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Because the parsed data ends up as filterable values, we can select a `Message`
    command by specifying `chat.command == 3` as a display filter, as shown at ➊ in
    [Figure 5-14](../Text/ch05.xhtml#ch5fig14). We can see that the username and message
    strings have been parsed correctly in the tree, as shown at ➋.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our quick introduction to writing a Lua dissector for Wireshark.
    Obviously, there is still plenty you can do with this script, including adding
    support for more commands, but you have enough for prototyping.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '*Be sure to visit the Wireshark website for more on how to write parsers, including
    how to implement a TCP stream parser.*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a Proxy to Actively Analyze Traffic**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a tool such as Wireshark to passively capture network traffic for later
    analysis of network protocols has a number of advantages over active capture (as
    discussed in [Chapter 2](../Text/ch02.xhtml#ch02)). Passive capture doesn’t affect
    the network operation of the applications you’re trying to analyze and requires
    no modifications of the applications. On the other hand, passive capture doesn’t
    allow you to interact easily with live traffic, which means you can’t modify traffic
    easily on the fly to see how applications will respond.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, active capture allows you to manipulate live traffic but requires
    more setup than passive capture. It may require you to modify applications, or
    at the very least to redirect application traffic through a proxy. Your choice
    of approach will depend on your specific scenario, and you can certainly combine
    passive and active capture.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](../Text/ch02.xhtml#ch02), I included some example scripts to
    demonstrate capturing traffic. You can combine these scripts with the Canape Core
    libraries to generate a number of proxies, which you might want to use instead
    of passive capture.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of passive capture, I’ll spend the
    rest of this chapter describing techniques for implementing a proxy for the SuperFunkyChat
    protocol and focus on how best to use active network capture.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Up the Proxy***'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set up the proxy, we’ll begin by modifying one of the capture examples in
    [Chapter 2](../Text/ch02.xhtml#ch02), specifically [Listing 2-4](../Text/ch02.xhtml#ch2list4),
    so we can use it for active network protocol analysis. To simplify the development
    process and configuration of the SuperFunkyChat application, we’ll use a port-forwarding
    proxy rather than something like SOCKS.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Copy [Listing 5-18](../Text/ch05.xhtml#ch5list18) into the file `chapter5_proxy.csx`
    and run it using Canape Core by passing the script’s filename to the *CANAPE.Cli*
    executable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: chapter5
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: _proxy.csx
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 5-18: The active analysis proxy*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, we tell the proxy to listen locally on port 4444 and make a proxy connection
    to 127.0.0.1 port 12345\. This should be fine for testing the chat application,
    but if you want to reuse the script for another application protocol, you’ll need
    to change the port and IP address as appropriate.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➋, we make one of the major changes to the script in [Chapter 2](../Text/ch02.xhtml#ch02):
    we add an event handler that is called whenever a packet needs to be logged, which
    allows us to print the packet as soon it arrives. At ➌, we add some event handlers
    to print when a new connection is created and then closed.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we reconfigure the ChatClient application to communicate with local port
    4444 instead of the original port 12345\. In the case of ChatClient, we simply
    add the `--port NUM` parameter to the command line as shown here:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**NOTE**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '*Changing the destination in real-world applications may not be so simple.
    Review [Chapters 2](../Text/ch02.xhtml#ch02) and [4](../Text/ch04.xhtml#ch04)
    for ideas on how to redirect an arbitrary application into your proxy.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The client should successfully connect to the server via the proxy, and the
    proxy’s console should begin displaying packets, as shown in Listing 5-19.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-19: Example output from proxy when a client connects*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Output indicating that a new proxy connection has been made is shown at ➊. Each
    packet is displayed with a header containing information about its direction (outbound
    or inbound), using the descriptive tags `Out` ➋ and `In` ➍.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'If your terminal supports 24-bit color, as do most Linux, macOS, and even Windows
    10 terminals, you can enable color support in Canape Core using the `--color`
    parameter when starting a proxy script. The colors assigned to inbound packets
    are similar to those in Wireshark: pink for outbound and blue for inbound. The
    packet display also shows which proxy connection it came from ➌, matching up with
    the output at ➊. Multiple connections could occur at the same time, especially
    if you’re proxying a complex application.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Each packet is dumped in hex and ASCII format. As with capture in Wireshark,
    the traffic might be split between packets as in ➎. However, unlike with Wireshark,
    when using a proxy, we don’t need to deal with network effects such as retransmitted
    packets or fragmentation: we simply access the raw TCP stream data after the operating
    system has dealt with all the network effects for us.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: At ➏, the proxy prints that the connection is closed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '***Protocol Analysis Using a Proxy***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With our proxy set up, we can begin the basic analysis of the protocol. The
    packets shown in [Listing 5-19](../Text/ch05.xhtml#ch5list19) are simply the raw
    data, but we should ideally write code to parse the traffic as we did with the
    Python script we wrote for Wireshark. To that end, we’ll write a `Data Parser`
    class containing functions to read and write data to and from the network. Copy
    [Listing 5-20](../Text/ch05.xhtml#ch5list20) into a new file in the same directory
    as you copied *chapter5_proxy.csx* in Listing 5-18 and call it *parser.csx*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: parser.csx
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 5-20: A basic parser code for proxy*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The negotiation method ➊ is called before any other communication takes place
    and is passed to two C# stream objects: one connected to the Chat Server and the
    other to the Chat Client. We can use this negotiation method to handle the magic
    value the protocol uses, but we could also use it for more complex tasks, such
    as enabling encryption if the protocol supports it.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The first task for the negotiation method is to read the magic value from the
    client and pass it to the server. To simply read and write the 4-byte magic value,
    we first wrap the streams in `DataReader` and `DataWriter` classes ➋. We then
    read the magic value from the client, print it to the console, and write it to
    the server ➌.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Add the line `#load "parser.csx"` to the very top of *chapter5_proxy.csx*. Now
    when the main *chapter5_proxy.csx* script is parsed, the *parser.csx* file is
    automatically included and parsed with the main script. Using this loading feature
    allows you to write each component of your parser in a separate file to make the
    task of writing a complex proxy manageable. Then add the line `template.AddLayer<Parser>();`
    just after `template.Port = 12345;` to add the parsing layer to every new connection.
    This addition will instantiate a new instance of the `Parser` class in [Listing
    5-20](../Text/ch05.xhtml#ch5list20) with every connection so you can store any
    state you need as members of the class. If you start the proxy script and connect
    a client through the proxy, only important protocol data is logged; you’ll no
    longer see the magic value (other than in the console output).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Basic Protocol Parsing***'
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll reframe the network protocol to ensure that each packet contains only
    the data for a single packet. We’ll do this by adding functions to read the length
    and checksum fields from the network and leave only the data. At the same time,
    we’ll rewrite the length and checksum when sending the data to the original recipient
    to keep the connection open.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: By implementing this basic parsing and proxying of a client connection, all
    nonessential information, such as lengths and checksums, should be removed from
    the data. As an added bonus, if you modify data inside the proxy, the sent packet
    will have the correct checksum and length to match your modifications. Add [Listing
    5-21](../Text/ch05.xhtml#ch5list21) to the `Parser` class to implement these changes
    and restart the proxy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 5-21: Parser code for SuperFunkyChat protocol*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Although the code is a bit verbose (blame C# for that), it should be fairly
    simple to understand. At ➊, we implement the checksum calculator. We could check
    packets we read to verify their checksums, but we’ll only use this calculator
    to recalculate the checksum when sending the packet onward.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The `ReadData()` function at ➋ reads a packet from the network connection. It
    first reads a big endian 32-bit integer, which is the length, then the 32-bit
    checksum, and finally the data as bytes before calling a function to convert that
    byte array to a `DataFrame`. (A `DataFrame` is an object to contain network packets;
    you can convert a byte array or a string to a frame depending on what you need.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The `WriteData()` function at ➌ does the reverse of `ReadData()`. It uses the
    `ToArray()` method on the incoming `DataFrame` to convert the packet to bytes
    for writing. Once we have the byte array, we can recalculate the checksum and
    the length, and then write it all back to the `DataWriter` class. At ➍, we implement
    the various functions to read and write data from the inbound and outbound streams.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Put together all the different scripts for network proxy and parsing and start
    a client connection through the proxy, and all nonessential information, such
    as lengths and checksums, should be removed from the data. As an added bonus,
    if you modify data inside the proxy, the sent packet will have the correct checksum
    and length to match your modifications.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '***Changing Protocol Behavior***'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Protocols often include a number of optional components, such as encryption
    or compression. Unfortunately, it’s not easy to determine how that encryption
    or compression is implemented without doing a lot of reverse engineering. For
    basic analysis, it would be nice to be able to simply remove the component. Also,
    if the encryption or compression is optional, the protocol will almost certainly
    indicate support for it while negotiating the initial connection. So, if we can
    modify the traffic, we might be able to change that support setting and disable
    that additional feature. Although this is a trivial example, it demonstrates the
    power of using a proxy instead of passive analysis with a tool like Wireshark.
    We can modify the connection to make analysis easier.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the chat application. One of its optional features is
    XOR encryption (although see [Chapter 7](../Text/ch07.xhtml#ch07) on why it’s
    not really encryption). To enable this feature, you would pass the `--xor` parameter
    to the client. [Listing 5-22](../Text/ch05.xhtml#ch5list22) compares the first
    couple of packets for the connection without the XOR parameter and then with the
    XOR parameter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 5-22: Example packets with and without XOR encryption enabled*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: I’ve highlighted in bold two differences in [Listing 5-22](../Text/ch05.xhtml#ch5list22).
    Let’s draw some conclusions from this example. In the outbound packet (which is
    command 0 based on the first byte), the final byte is a 1 when XOR is enabled
    but 0x00 when it’s not enabled. My guess would be that this flag indicates that
    the client supports XOR encryption. For inbound traffic, the final byte of the
    first packet (command 1 in this case) is 0xE7 when XOR is enabled and 0x00 when
    it’s not. My guess would be that this is a key for the XOR encryption.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if you look at the client console when you’re enabling XOR encryption,
    you’ll see the line `ReKeying connection to key 0xE7`, which indicates it is indeed
    the key. Although the negotiation is valid traffic, if you now try to send a message
    with the client through the proxy, the connection will no longer work and may
    even be disconnected. The connection stops working because the proxy will try
    to parse fields, such as the length of the packet, from the connection but will
    get invalid values. For example, when reading a length, such as 0x10, the proxy
    will instead read 0x10 XOR 0xE7, which is 0xF7\. Because there are no 0xF7 bytes
    on the network connection, it will hang. The short explanation is that to continue
    the analysis in this situation, we need to do something about the XOR.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: While implementing the code to de-XOR the traffic when we read it and re-XOR
    it again when we write it wouldn’t be especially difficult, it might not be so
    simple to do if this feature were implemented to support some proprietary compression
    scheme. Therefore, we’ll simply disable XOR encryption in our proxy irrespective
    of the client’s setting. To do so, we read the first packet in the connection
    and ensure that the final byte is set to 0\. When we forward that packet onward,
    the server will not enable XOR and will return the value of 0 as the key. Because
    0 is a NO-OP in XOR encryption (as in A XOR 0 = A), this technique will effectively
    disable the XOR.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Change the `ReadOutbound()` method in the parser to the code in Listing 5-23
    to disable the XOR encryption.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 5-23: Disable XOR encryption*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: If you now create a connection through the proxy, you’ll find that regardless
    of whether the XOR setting is enabled or not, the client will not be able to enable
    XOR.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '**Final Words**'
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to perform basic protocol analysis on an unknown
    protocol using passive and active capture techniques. We started by doing basic
    protocol analysis using Wireshark to capture example traffic. Then, through manual
    inspection and a simple Python script, we were able to understand some parts of
    an example chat protocol.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: We discovered in the initial analysis that we were able to implement a basic
    Lua dissector for Wireshark to extract protocol information and display it directly
    in the Wireshark GUI. Using Lua is ideal for prototyping protocol analysis tools
    in Wireshark.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we implemented a man-in-the-middle proxy to analyze the protocol. Proxying
    the traffic allows demonstration of a few new analysis techniques, such as modifying
    protocol traffic to disable protocol features (such as encryption) that might
    hinder the analysis of the protocol using purely passive techniques.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The technique you choose will depend on many factors, such as the difficulty
    of capturing the network traffic and the complexity of the protocol. You’ll want
    to apply the most appropriate combination of techniques to fully analyze an unknown
    protocol.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
