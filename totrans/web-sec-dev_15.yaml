- en: '**13**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**13**'
- en: '**ENCRYPTION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密**'
- en: '![image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common01.jpg)'
- en: Encryption powers the modern internet. Without the ability to exchange data
    packets privately and securely, e-commerce would not exist, and users wouldn’t
    be able to safely authenticate themselves to internet sites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是现代互联网的核心。没有私密、安全地交换数据包的能力，电子商务将无法存在，用户也无法安全地验证自己与互联网网站的身份。
- en: The HyperText Transfer Protocol Secure is the most widely used form of encryption
    on the web. Web servers and web browsers universally support HTTPS, so the developer
    can divert all traffic to that protocol and guarantee secure communication for
    their users. A web developer who wants to use HTTPS on their site needs only to
    obtain a *certificate* from a *certificate authority* and install it with their
    hosting provider.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 安全超文本传输协议是目前网络上最广泛使用的加密形式。网页服务器和网页浏览器普遍支持HTTPS，因此开发者可以将所有流量重定向到该协议，确保用户之间的通信安全。想要在自己的网站上使用HTTPS的网页开发者，只需要从*证书授权机构*获得一个*证书*，并与其托管服务提供商一起安装它。
- en: The ease with which you can get started using encryption belies the complexity
    of what is happening when a website and user agent interact over HTTPS. Modern
    *cryptography*—the study of methods of encrypting and decrypting data—depends
    on techniques developed and actively researched by mathematicians and security
    professionals. Thankfully, the abstracted layers of the Internet Protocol mean
    you don’t need to know linear algebra or number theory to use their discoveries.
    But the more you understand about the underlying algorithms, the more you will
    be able to preempt potential risks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以轻松开始使用加密，但当网站与用户代理通过HTTPS进行交互时，发生的过程是非常复杂的。现代*密码学*——研究加密和解密数据的方法——依赖于由数学家和安全专业人员开发并积极研究的技术。幸运的是，互联网协议的抽象层意味着你不需要了解线性代数或数论就能使用它们的发现。但是，越是理解底层算法，你就越能预见潜在的风险。
- en: This chapter first gives a general overview of how encryption is used in the
    Internet Protocol and the mathematics that underpin it. Once you have a good grasp
    of how encryption works, you will review the practical steps a developer needs
    to undertake to get started using HTTPS. Finally, you will look at how hackers
    take advantage of unencrypted or weakly encrypted traffic, and how some attacks
    can circumvent encryption entirely.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先概述了加密如何在互联网协议中使用以及支撑它的数学原理。一旦你对加密的工作原理有了充分的理解，你将回顾开发者需要采取的实际步骤，以开始使用HTTPS。最后，你将了解黑客如何利用未加密或加密较弱的流量，以及一些攻击如何完全绕过加密。
- en: '**Encryption in the Internet Protocol**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**互联网协议中的加密**'
- en: Recall that messages sent over the internet are split into data packets and
    directed toward their eventual destination via the *Transmission Control Protocol
    (TCP)*. The recipient computer assembles these TCP packets back into the original
    message. TCP doesn’t dictate *how* the data being sent is meant to be interpreted.
    For that to happen, both computers need to agree on how to interpret the data
    being sent, using a higher-level protocol such as HTTP. TCP also does nothing
    to disguise the content of the packets being sent. Unsecured TCP conversations
    are vulnerable to *man-in-the-middle attacks*, whereby malicious third parties
    intercept and read the packets as they are transmitted.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，通过互联网发送的消息被分割成数据包，并通过*传输控制协议（TCP）*定向到最终目的地。接收方计算机将这些TCP数据包重新组装成原始消息。TCP并不规定数据发送的*如何*被解释。为了实现这一点，两个计算机需要就如何解释发送的数据达成一致，使用如HTTP这样的高级协议。TCP也不会掩盖发送的数据包内容。未加密的TCP对话容易受到*中间人攻击*，即恶意的第三方拦截并读取正在传输的数据包。
- en: To avoid this, HTTP conversations between a browser and a web server are secured
    by *Transport Layer Security (TLS)*, a method of encryption that provides both
    privacy (by ensuring data packets can’t be deciphered by a third party) and *data
    integrity* (by ensuring that any attempt to tamper with the packets in transit
    will be detectable). HTTP conversations conducted using TLS are called *HTTP Secure
    (HTTPS)* conversations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，浏览器和网页服务器之间的HTTP对话通过*传输层安全性（TLS）*来加密，这是一种提供隐私性（通过确保数据包不能被第三方解密）和*数据完整性*（通过确保任何试图篡改传输中的数据包都能被检测到）的方法。使用TLS进行的HTTP对话被称为*HTTP安全（HTTPS）*对话。
- en: When your web browser connects to an HTTPS website, the browser and web server
    negotiate which encryption algorithms to use as part of the *TLS handshake*—the
    exchange of data packets that occurs when a TLS conversation is initiated. To
    make sense of what happens during the TLS handshake, we need to take a brief detour
    into the various types of encryption algorithms. Time for some light mathematics!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的网页浏览器连接到一个HTTPS网站时，浏览器和Web服务器会协商使用哪些加密算法，这是*TLS握手*的一部分——TLS会话启动时发生的数据包交换。为了理解TLS握手过程中发生的事情，我们需要简要了解各种加密算法。现在是一些轻松的数学时刻！
- en: '***Encryption Algorithms, Hashing, and Message Authentication Codes***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***加密算法、哈希和消息认证码***'
- en: An *encryption algorithm* takes input data and scrambles it by using an *encryption
    key*—a secret shared between two parties wishing to initiate secure communication.
    The scrambled output is indecipherable to anyone without a *decryption key*—the
    corresponding key required to unscramble the data. The input data and keys are
    typically encoded as binary data, though the keys may be expressed as strings
    of text for readability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*加密算法*通过使用*加密密钥*（两个希望建立安全通信的方共享的秘密）对输入数据进行加扰处理——没有*解密密钥*（解密数据所需的相应密钥）的人无法解读加密后的输出。输入数据和密钥通常以二进制数据的形式编码，虽然为了可读性，密钥可能以文本字符串的形式表达。
- en: 'Many encryption algorithms exist, and more continue to be invented by mathematicians
    and security researchers. They can be classified into a few categories: symmetric
    and asymmetric encryption algorithms (for ciphering data), hash functions (for
    fingerprinting data and building other cryptographic algorithms), and message
    authentication codes (for ensuring data integrity).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多加密算法，且数学家和安全研究人员不断发明新的算法。它们可以分为几类：对称和非对称加密算法（用于加密数据）、哈希函数（用于数据指纹和构建其他密码学算法）、以及消息认证码（用于确保数据完整性）。
- en: '**Symmetric Encryption Algorithms**'
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**对称加密算法**'
- en: 'A *symmetric encryption algorithm* uses the same key to encrypt and decrypt
    data. Symmetric encryption algorithms usually operate as *block ciphers*: they
    break the input data into fixed-size blocks that can be individually encrypted.
    (If the last block of input data is undersized, it will be *padded* to fill out
    the block size.) This makes them suitable for processing streams of data, including
    TCP data packets.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*对称加密算法*使用相同的密钥来加密和解密数据。对称加密算法通常作为*分组密码*工作：它们将输入数据分解成固定大小的块，这些块可以单独加密。（如果最后一个输入数据块大小不足，则会*填充*以填满块大小。）这使得它们适合处理数据流，包括TCP数据包。
- en: 'Symmetric algorithms are designed for speed but have one major security flaw:
    the decryption key must be given to the receiving party before they decrypt the
    data stream. If the decryption key is shared over the internet, potential attackers
    will have an opportunity to steal the key, which allows them to decrypt any further
    messages. Not good.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对称算法的设计注重速度，但有一个主要的安全缺陷：解密密钥必须在接收方解密数据流之前提供给他们。如果解密密钥通过互联网共享，潜在的攻击者将有机会窃取该密钥，从而解密任何进一步的消息。这样不好。
- en: '**Asymmetric Encryption Algorithms**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**非对称加密算法**'
- en: In response to the threat of decryption keys being stolen, *asymmetric encryption
    algorithms* were developed. Asymmetric algorithms use different keys to encrypt
    and decrypt data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对解密密钥被盗的威胁，*非对称加密算法*应运而生。非对称算法使用不同的密钥来加密和解密数据。
- en: 'An asymmetric algorithm allows a piece of software such as a web server to
    publish its encryption key freely, while keeping its decryption key a secret.
    Any user agent looking to send secure messages to the server can encrypt those
    messages by using the server’s encryption key, secure in the knowledge that nobody
    (not even themselves!) will be able to decipher the data being sent, because the
    decryption key is kept secret. This is sometimes described as *public-key cryptography*:
    the encryption key (*the public key*) can be published; only the decryption key
    (the *private key*) needs to be kept secret.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称算法允许像Web服务器这样的软件公开其加密密钥，同时保留其解密密钥为秘密。任何希望向服务器发送安全消息的用户代理都可以使用服务器的加密密钥来加密这些消息，确保没有人（甚至是发送方自己！）能够解密所发送的数据，因为解密密钥是保密的。这有时被描述为*公钥密码学*：加密密钥（*公钥*）可以公开；只有解密密钥（*私钥*）需要保密。
- en: Asymmetric algorithms are significantly more complex and hence slower than symmetric
    algorithms. Encryption in the Internet Protocol uses a combination of both types,
    as you will see later in the chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称算法比对称算法复杂得多，因此也更慢。互联网协议中的加密使用了两种类型的算法的结合，正如你稍后在本章中将看到的那样。
- en: '**Hash Functions**'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**哈希函数**'
- en: 'Related to encryption algorithms are *cryptographic hash functions*, which
    can be thought of as encryption algorithms whose output *cannot* be decrypted.
    Hash functions also have a couple of other interesting properties: the output
    of the algorithm (the *hashed value*) is always a fixed size, regardless of the
    size of input data; and the chances of getting the same output value, given different
    input values, is astronomically small.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与加密算法相关的是*加密哈希函数*，可以将其视为一种输出*无法*被解密的加密算法。哈希函数还有一些其他有趣的属性：算法的输出（*哈希值*）始终是固定大小的，无论输入数据的大小如何；而且，给定不同的输入值，得到相同输出值的概率极其微小。
- en: Why on earth would you want to encrypt data you couldn’t subsequently decrypt?
    Well, it’s a neat way to generate a “fingerprint” for input data. If you need
    to check that two separate inputs are the same but don’t want to store the raw
    input values for security reasons, you can verify that both inputs produce the
    same hashed value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会想要加密一些你之后无法解密的数据呢？好吧，这是生成输入数据“指纹”的一种巧妙方式。如果你需要检查两个不同的输入是否相同，但出于安全原因不想存储原始输入值，你可以验证这两个输入是否生成相同的哈希值。
- en: 'This is how website passwords are typically stored, as we saw in [Chapter 9](ch09.xhtml#ch09).
    When a password is first set by a user, the web server will store the hashed value
    of the password in the database but will deliberately forget the actual password
    value. When the user later reenters their password on the site, the server will
    recalculate the hashed value and compare it with the stored hashed value. If the
    two hashed values differ, it indicates the user entered a different password,
    which means the credentials should be rejected. In this way, a site can check
    the correctness of passwords without explicitly knowing each user’s password.
    (Storing passwords in plaintext form is a security hazard: if an attacker compromises
    the database, they get every user’s password.)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是网站密码通常存储的方式，正如我们在[第9章](ch09.xhtml#ch09)中看到的那样。当用户首次设置密码时，网站服务器会将密码的哈希值存储在数据库中，并故意忘记实际的密码值。当用户稍后再次输入密码时，服务器会重新计算哈希值并与存储的哈希值进行比较。如果两个哈希值不同，则表示用户输入了不同的密码，意味着该凭证应被拒绝。通过这种方式，网站可以检查密码的正确性，而无需明确知道每个用户的密码。（以明文形式存储密码是一种安全隐患：如果攻击者入侵数据库，他们将获得每个用户的密码。）
- en: '**Message Authentication Codes**'
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**消息认证码**'
- en: '*Message authentication code (MAC)* algorithms are similar to (and generally
    built on top of) cryptographic hash functions, in that they map input data of
    an arbitrary length to a unique, fixed-sized output. This output is itself called
    a *message authentication code*. MAC algorithms are more specialized than hash
    functions, however, because recalculating a MAC requires a secret key. This means
    that only the parties in possession of the secret key can generate or check the
    validity of message authentication codes.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息认证码（MAC）*算法与加密哈希函数相似（通常是在加密哈希函数的基础上构建），它们将任意长度的输入数据映射到一个唯一且固定大小的输出。这个输出本身就是所谓的*消息认证码*。然而，MAC算法比哈希函数更加专业化，因为重新计算MAC需要一个秘密密钥。这意味着只有拥有秘密密钥的参与方才能生成或检查消息认证码的有效性。'
- en: MAC algorithms are used to ensure that the data packets transmitted on the internet
    cannot be forged or tampered with by an attacker. To use a MAC algorithm, the
    sending and receiving computers exchange a shared, secret key—usually as part
    of the TLS handshake. (The secret key will itself be encrypted before it is sent,
    to avoid the risk of it being stolen.) From that point onward, the sender will
    generate a MAC for each data packet being sent and attach the MAC to the packet.
    Because the recipient computer has the same key, it can recalculate the MAC from
    the message. If the calculated MAC differs from the value attached to the packet,
    this is evidence that the packet has been tampered with or corrupted in some form,
    or it was not sent by the original computer. Hence, the recipient rejects the
    data packet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MAC 算法用于确保通过互联网传输的数据包不会被攻击者伪造或篡改。要使用 MAC 算法，发送方和接收方计算机会交换一个共享的秘密密钥——通常是作为 TLS
    握手的一部分进行交换。（为了避免密钥被窃取，该秘密密钥会在发送前进行加密。）从此以后，发送方将为每个数据包生成一个 MAC，并将其附加到数据包上。由于接收方计算机拥有相同的密钥，它可以从消息中重新计算
    MAC。如果计算得到的 MAC 与附加在数据包上的值不一致，则说明该数据包已经被篡改、损坏，或它并非由原计算机发送。因此，接收方会拒绝该数据包。
- en: If you’ve gotten to this point and are still paying attention, congratulations!
    Cryptography is a large, complex subject that has its own particular jargon. Understanding
    how it fits into the Internet Protocol requires balancing multiple concepts in
    your head at once, so thank you for your patience. Let’s see how the various types
    of cryptographic algorithms we have discussed are used by TLS.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经看到这里并且仍在关注，恭喜你！密码学是一个庞大而复杂的主题，具有自己特有的术语。理解它如何融入互联网协议需要同时平衡多个概念，因此感谢你的耐心。接下来，我们来看一下我们讨论过的各种类型的加密算法是如何在
    TLS 中使用的。
- en: '***The TLS Handshake***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***TLS 握手***'
- en: TLS uses a combination of cryptographic algorithms to efficiently and safely
    pass information. For speed, most data packets passed over TLS will be encrypted
    using a symmetric encryption algorithm commonly referred to as the *block cipher*,
    since it encrypts “blocks” of streaming information. Recall that symmetric encryption
    algorithms are vulnerable to having their encryption keys stolen by malicious
    users eavesdropping on the conversation. To safely pass the encryption/decryption
    key for the block cipher, TLS will encrypt the key by using an *asymmetric* algorithm
    before passing it to the recipient. Finally, data packets passed using TLS will
    be tagged using a message authentication code, to detect if any data has been
    tampered with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 使用一组合适的加密算法来高效、安全地传输信息。为了提高速度，大多数通过 TLS 传输的数据包将使用常见的对称加密算法，也称为 *块加密算法*，因为它加密的是“块”状的流信息。回想一下，对称加密算法容易受到恶意用户监听会话并窃取加密密钥的威胁。为了安全地传递块加密的加密/解密密钥，TLS
    会先使用 *非对称* 算法对密钥进行加密，然后再将其传递给接收方。最后，通过 TLS 传输的数据包将使用消息认证码进行标记，以检测数据是否已被篡改。
- en: At the start of a TLS conversation, the browser and website perform a *TLS handshake*
    to determine how they should communicate. In the first stage of the handshake,
    the browser will list multiple cipher suites that it supports. Let’s drill down
    on what this means.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TLS 会话开始时，浏览器和网站会进行 *TLS 握手* 以确定它们应如何通信。在握手的第一阶段，浏览器将列出它支持的多个密码套件。让我们深入了解这是什么意思。
- en: '**Cipher Suites**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**密码套件**'
- en: 'A *cipher suite* is a set of algorithms used to secure communication. Under
    the TLS standard, a cipher suite consists of *three* separate algorithms. The
    first algorithm, the *key-exchange algorithm*, is an asymmetric encryption algorithm.
    This is used by communicating computers to exchange secret keys for the second
    encryption algorithm: the symmetric block cipher designed for encrypting the content
    of TCP packets. Finally, the cipher suite specifies a MAC algorithm for authenticating
    the encrypted messages.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码套件* 是一组用于保护通信的算法。根据 TLS 标准，密码套件由 *三个* 独立的算法组成。第一个算法是 *密钥交换算法*，它是一种非对称加密算法。通信计算机使用该算法交换秘密密钥，用于第二个加密算法：旨在加密
    TCP 数据包内容的对称块加密算法。最后，密码套件指定了一个 MAC 算法，用于验证加密消息的真实性。'
- en: Let’s make this more concrete. A modern web browser such as Google Chrome that
    supports TLS 1.3 offers numerous cipher suites. At the time of writing, one of
    these suites goes by the catchy name of ECDHE-ECDSA-AES128-GCM-SHA256\. This particular
    cipher suite includes ECDHE-RSA as the key-exchange algorithm, AES-128-GCM as
    the block cipher, and SHA-256 as the message authentication algorithm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个内容更具体化。像 Google Chrome 这样的现代 web 浏览器支持 TLS 1.3，并提供了许多密码套件。在撰写本文时，其中一个密码套件的名字非常有趣，叫做
    ECDHE-ECDSA-AES128-GCM-SHA256。这个特定的密码套件包括 ECDHE-RSA 作为密钥交换算法，AES-128-GCM 作为块密码，SHA-256
    作为消息认证算法。
- en: Want some more, entirely unnecessary, detail? Well, *ECDHE* stands for *Elliptic
    Curve Diffie–Hellman Exchange* (a modern method of establishing a shared secret
    over an insecure channel). *RSA* stands for the *Rivest–Shamir–Adleman* algorithm
    (the first practical asymmetric encryption algorithm, invented by three mathematicians
    in the 1970s after drinking a lot of Passover wine). *AES* stands for the *Advanced
    Encryption Standard* (an algorithm invented by two Belgian cryptographers and
    selected by the National Institute of Standards and Technology through a three-year
    review process). This particular variant uses a 128-bit key in Galois/Counter
    Mode, which is specified by *GCM* in the name. Finally, SHA-256 stands for the
    *Secure Hash Algorithm* (a hash function with a 256-bit word size).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想要更多完全不必要的细节吗？好吧，*ECDHE* 代表 *椭圆曲线 Diffie-Hellman 密钥交换*（一种在不安全通道上建立共享密钥的现代方法）。*RSA*
    代表 *Rivest–Shamir–Adleman* 算法（第一种实用的非对称加密算法，由三位数学家在 1970 年代发明，灵感来自他们喝了大量的逾越节酒）。*AES*
    代表 *高级加密标准*（由两位比利时密码学家发明，并通过国家标准与技术研究院的三年审查过程被选中）。这个特定变体使用了 128 位密钥，采用 Galois/计数器模式，这就是名称中所指定的
    *GCM*。最后，SHA-256 代表 *安全哈希算法*（一种具有 256 位字长的哈希函数）。
- en: See what I mean about the complexity of modern encryption standards? Modern
    browsers and web servers support a fair number of cipher suites, and more get
    added to the TLS standard all the time. As weaknesses are discovered in existing
    algorithms, and computing power gets cheaper, security researchers update the
    TLS standard to keep the internet secure. As a web developer, it’s not particularly
    important to understand how these algorithms work, but it *is* important to keep
    your web server software up-to-date so you can support the most modern, secure
    algorithms.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了现代加密标准的复杂性了吗？现代浏览器和 web 服务器支持相当多的密码套件，而且随着时间的推移，TLS 标准中不断增加新的套件。随着现有算法的弱点被发现，计算能力变得更加廉价，安全研究人员会更新
    TLS 标准，以保持互联网的安全。作为一名 web 开发者，了解这些算法如何工作并不是特别重要，但*保持你的 web 服务器软件最新*，以便能够支持最现代、最安全的算法，这一点非常重要。
- en: '**Session Initiation**'
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**会话初始化**'
- en: Let’s continue where we left off. In the second stage of the TLS handshake,
    the web server selects the most secure cipher suite it can support and then instructs
    the browser to use those algorithms for communication. At the same time, the server
    passes back a *digital certificate*, containing the server name, the trusted certificate
    authority that will vouch for the authenticity of the certificate, and the web
    server’s encryption key to be used in the key-exchange algorithm. (We will discuss
    what certificates are and why they are necessary for secure communication in the
    next section.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着上次的内容继续。在 TLS 握手的第二阶段，web 服务器选择它能够支持的最安全的密码套件，并指示浏览器使用这些算法进行通信。与此同时，服务器返回一个*数字证书*，其中包含服务器名称、将为证书的真实性担保的受信证书机构，以及在密钥交换算法中使用的
    web 服务器加密密钥。（我们将在下一节中讨论什么是证书以及它们为何对安全通信至关重要。）
- en: Once the browser verifies the authenticity of the certificate, the two computers
    generate a *session key* that will be used to encrypt the TLS conversation with
    the chosen block cipher. (Note that this session key is different from the HTTP
    *session identifier* discussed in previous chapters. TLS handshakes occur at a
    lower level of the Internet Protocol than the HTTP conversation, which has not
    begun yet.) The session key is a large random number generated by the browser,
    encrypted with the (public) encryption key attached to the digital certificate
    using the key-exchange algorithm, and transmitted to the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器验证了证书的真实性，两个计算机会生成一个*会话密钥*，该密钥将用于使用选择的块加密算法加密 TLS 会话。（请注意，这个会话密钥与前面章节讨论的
    HTTP *会话标识符*不同。TLS 握手发生在比 HTTP 会话更低级别的互联网协议中，而 HTTP 会话还未开始。）会话密钥是由浏览器生成的大随机数，用数字证书中附带的（公）加密密钥加密，采用密钥交换算法进行加密，并传输到服务器。
- en: Now, finally, the TLS conversation can begin. Everything past this point will
    be securely encrypted using the block cipher and the shared session identifier,
    so the data packets will be indecipherable to anyone snooping on the conversation.
    The browser and server use the agreed-upon encryption algorithm and session key
    to encrypt packets in both directions. Data packets are also authenticated and
    tamper-proof, using message authentication codes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，TLS 会话终于可以开始了。此后所有的数据都会使用块加密算法和共享会话标识符进行加密，因此任何窃听会话的人都无法解读数据包。浏览器和服务器使用商定的加密算法和会话密钥在双向加密数据包。数据包还会进行身份验证并防篡改，使用消息认证码。
- en: As you can see, a lot of complex mathematics underpin secure communication on
    the internet. Thankfully, the steps involved for enabling HTTPS as a web developer
    are much simpler. Now we have the theory out of the way, let’s take a look at
    the practical steps needed to secure your users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，支撑互联网安全通信的是大量复杂的数学原理。幸运的是，作为一名 web 开发者，启用 HTTPS 所涉及的步骤要简单得多。现在我们已经了解了理论部分，让我们来看一下确保用户安全所需的实际步骤。
- en: '**Enabling HTTPS**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**启用 HTTPS**'
- en: Securing traffic for your website is a lot easier than understanding the underlying
    encryption algorithms. Most modern web browsers are self-updating; the development
    teams for each major browser will be on the cutting edge of supporting modern
    TLS standards. The latest version of your web server software will support similarly
    modern TLS algorithms. That means that the only responsibility left to you as
    a developer is to obtain a digital certificate and install it on your web server.
    Let’s discuss how to do that and illuminate why certificates are necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的网站加密流量比理解底层加密算法要容易得多。大多数现代网页浏览器是自我更新的；每个主流浏览器的开发团队都会在支持现代 TLS 标准方面处于前沿地位。您网站服务器软件的最新版本也会支持类似的现代
    TLS 算法。这意味着，作为开发者，您唯一需要做的就是获取一个数字证书并将其安装到您的网站服务器上。让我们来讨论如何做，并阐明为什么证书是必要的。
- en: '***Digital Certificates***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字证书***'
- en: A *digital certificate* (also known as a *public-key certificate*) is an electronic
    document used to prove ownership of a public encryption key. Digital certificates
    are used in TLS to associate encryption keys with internet domains (such as *example.com*).
    They are issued by *certificate authorities*, which act as a trusted third party
    between a browser and a website, vouching that a given encryption key should be
    used to encrypt data being sent to the website’s domain. Browser software will
    trust a few hundred certificate authorities—for example, Comodo, DigiCert, and,
    more recently, the nonprofit Let’s Encrypt. When a trusted certificate authority
    vouches for a key and domain, it assures your browser that it’s communicating
    with the right website using the right encryption key, thereby blocking an attacker
    from presenting a malicious website or certificate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字证书*（也称为*公钥证书*）是一种电子文档，用于证明公钥的所有权。数字证书在 TLS 中用于将加密密钥与互联网域名（如*example.com*）关联。它们由*证书颁发机构*（CA）颁发，证书颁发机构作为浏览器和网站之间的受信第三方，保证使用指定的加密密钥来加密发送到网站域名的数据。浏览器软件会信任几百个证书颁发机构——例如，Comodo、DigiCert，最近还有非营利组织
    Let’s Encrypt。当一个受信的证书颁发机构担保某个密钥和域名时，它会确保您的浏览器正在与正确的网站进行通信，并且使用正确的加密密钥，从而阻止攻击者呈现恶意网站或证书。'
- en: 'You might ask: why is a third party required to exchange encryption keys on
    the internet? After all, isn’t the whole point of asymmetric encryption that the
    public key can be made available freely by the server itself? While this statement
    is true, the actual process of fetching an encryption key on the internet depends
    on the reliability of the internet’s *Domain Name System (DNS)* that maps domain
    names to IP addresses. Under some circumstances, DNS is vulnerable to *spoofing
    attacks* that can be used to direct internet traffic away from a legitimate server
    to an IP address controlled by an attacker. If an attacker can spoof an internet
    domain, they can issue their own encryption key, and victims would be none the
    wiser.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：为什么需要第三方来交换互联网中的加密密钥？毕竟，非对称加密的一个重点不是服务器自己可以自由提供公钥吗？虽然这个说法是对的，但实际上在互联网上获取加密密钥的过程依赖于互联网的*域名系统（DNS）*，它将域名映射到IP地址。在某些情况下，DNS容易受到*伪造攻击*，这些攻击可以将互联网流量引导到攻击者控制的IP地址，而不是合法的服务器。如果攻击者能够伪造互联网域名，他们可以颁发自己的加密密钥，受害者通常不会察觉。
- en: Certificate authorities exist to prevent encrypted traffic from being spoofed.
    Should an attacker find a way to divert traffic from a legitimate (secure) website
    to a malicious server under their control, that attacker will typically not possess
    the decryption key corresponding to the website’s certificate. This means they
    will be unable to decrypt intercepted traffic that was encrypted using the encryption
    key attached to the site’s digital certificate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 证书授权机构的存在是为了防止加密流量被伪造。如果攻击者找到方法将流量从合法（安全）网站转移到他们控制的恶意服务器，攻击者通常不会拥有与该网站证书对应的解密密钥。这意味着他们将无法解密使用与网站数字证书附带的加密密钥加密的拦截流量。
- en: On the other hand, if the attacker presents an *alternative* digital certificate
    corresponding to a decryption key that they *do* possess, that certificate will
    not have been verified by a trusted certificate authority. Any browser visiting
    the spoofed website will show a security warning to the user, strongly dissuading
    them from continuing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果攻击者提供一个*替代*的数字证书，该证书对应于他们*确实*拥有的解密密钥，那么该证书将不会经过受信任的证书授权机构验证。任何访问伪造网站的浏览器都会向用户显示安全警告，强烈劝阻用户继续访问。
- en: In this way, certificate authorities allow users to trust the websites they
    are visiting. You can view the certificate a website is using by clicking the
    padlock icon in the browser bar. The information described there won’t be particularly
    interesting, but browsers do a good job of warning you when a certificate is invalid.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，证书授权机构使用户能够信任他们访问的网站。你可以通过点击浏览器栏中的挂锁图标查看网站使用的证书。那里的信息可能不特别有趣，但浏览器能够很好地警告你当证书无效时。
- en: '***Obtaining a Digital Certificate***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取数字证书***'
- en: Obtaining a digital certificate for your website from a certificate authority
    requires a few steps, by which the authority verifies that you own your domain.
    The precise way you perform these steps differs depending on which certificate
    authority you choose.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从证书授权机构获取数字证书需要几个步骤，通过这些步骤，授权机构可以验证你对域名的所有权。你执行这些步骤的具体方式取决于你选择的证书授权机构。
- en: The first step is to generate a *key pair*, a small digital file containing
    randomly generated public and private encryption keys. Next, you use this key
    pair to generate a *certificate signing request (CSR)* that contains the public
    key and domain name of your website, and upload the request to a certificate authority.
    Before honoring the signing request and issuing the certificate, the certificate
    authority will require you to demonstrate to them that you have control of the
    internet domain contained in the CSR. Once domain ownership has been verified,
    you can download the certificate and install it on your web server along with
    the key pair.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是生成一个*密钥对*，这是一个包含随机生成的公钥和私钥的小型数字文件。接下来，使用这个密钥对生成一个*证书签名请求（CSR）*，该请求包含你网站的公钥和域名，并将请求上传到证书授权机构。在签署请求并颁发证书之前，证书授权机构将要求你证明你对CSR中包含的互联网域名具有控制权。一旦域名所有权得到验证，你就可以下载证书，并将其与密钥对一起安装到你的Web服务器上。
- en: '**Generating a Key Pair and Certificate Signing Request**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成密钥对和证书签名请求**'
- en: The key pair and CSR are typically generated using the command line tool, `openssl`.
    CSRs often contain other information about the applicant besides the domain name
    and public key, such as the organization’s legal name and physical location. These
    get included in the signed certificate, but are not mandatory unless the certificate
    authority chooses to validate them. During the generation of the signing request,
    the domain name is often referred to as the *distinguished name (DN)* or the *fully
    qualified domain name (FQDN)*, for historical reasons. [Listing 13-1](ch13.xhtml#ch13list1)
    shows how to generate a certificate signing request by using `openssl`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥对和CSR通常使用命令行工具`openssl`生成。CSR通常包含除了域名和公钥之外的其他信息，如组织的法律名称和实际位置。这些信息会被包含在签名证书中，但除非证书颁发机构选择验证它们，否则并不是强制性的。在生成签名请求时，域名通常被称为*区分名称（DN）*或*完全合格域名（FQDN）*，出于历史原因。[列表
    13-1](ch13.xhtml#ch13list1)展示了如何使用`openssl`通过命令行生成证书签名请求。
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Generating a certificate signing request by using openssl on
    the command line*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-1：通过命令行使用openssl生成证书签名请求*'
- en: The file *private.key* should contain a newly generated private key (which can
    also be generated with `openssl`). The tool `openssl` will ask for details to
    incorporate into the signing request, including the domain name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文件*private.key*应该包含一个新生成的私钥（也可以通过`openssl`生成）。工具`openssl`会要求提供一些信息，用于生成签名请求，包括域名。
- en: '**Domain Verification**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**域名验证**'
- en: '*Domain verification* is the process by which a certificate authority verifies
    that someone applying for a certificate for an internet domain does indeed have
    control of that domain. When applying for a digital certificate, you are stating
    that you need to be able to decrypt traffic sent to a particular internet domain.
    The certificate authority will insist on checking that you own that domain as
    part of its due diligence.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*域名验证*是证书颁发机构验证申请证书的人员是否确实拥有该域名控制权的过程。在申请数字证书时，您声明需要能够解密发送到特定互联网域名的流量。证书颁发机构会坚持检查您是否拥有该域名，作为尽职调查的一部分。'
- en: 'Domain verification generally requires you to make a temporary edit to the
    DNS entries for your domain, thus demonstrating that you have edit rights in the
    DNS. Domain verification is what protects against DNS spoofing attacks: an attacker
    cannot apply for a certificate unless they also have edit rights.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 域名验证通常需要您临时编辑域名的DNS记录，从而证明您拥有DNS的编辑权限。域名验证可以防止DNS欺骗攻击：攻击者无法申请证书，除非他们也有编辑权限。
- en: '**Extended Validation Certificates**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**扩展验证证书**'
- en: Some certificate authorities issue *extended validation (EV)* certificates.
    These require the certificate authority to collect and verify information about
    the legal entity applying for a certificate. That information will then be included
    in the digital certificate, and made available in the web browser to users visiting
    the website. EV certificates are popular with large organizations, because the
    name of the company is usually displayed alongside the padlock icon in the browser
    URL bar, encouraging a sense of trust in users.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些证书颁发机构会颁发*扩展验证（EV）*证书。这些证书要求证书颁发机构收集并验证申请证书的法律实体的信息。这些信息将被包含在数字证书中，并通过浏览器提供给访问网站的用户。EV证书在大型组织中非常受欢迎，因为公司的名称通常会与浏览器URL栏中的挂锁图标一起显示，增强用户的信任感。
- en: '**Expiring and Revoking Certificates**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**过期和撤销证书**'
- en: Digital certificates have a finite lifespan (typically in years or months) after
    which they must be reissued by the certificate authority. Certificate authorities
    also keep track of certificates that have been voluntarily *revoked* by certificate
    holders. If the private key corresponding to your digital certificate gets compromised,
    it’s important that you as a site owner apply for a new certificate and then revoke
    the prior certificate. Browsers will warn a user when visiting a website with
    an expired or revoked certificate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数字证书有一个有限的有效期（通常是几年或几个月），到期后必须由证书颁发机构重新颁发。证书颁发机构还会追踪被证书持有者自愿*撤销*的证书。如果与你的数字证书对应的私钥被泄露，作为站点所有者，您需要申请一个新证书，并撤销之前的证书。浏览器会在用户访问带有过期或已撤销证书的网站时发出警告。
- en: '**Self-Signed Certificates**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**自签名证书**'
- en: For some environments, particularly testing environments, acquiring a certificate
    from a certificate authority is unnecessary or impractical. Testing environments
    that are available on only an internal network, for example, can’t be verified
    by a certificate authority. You may still want to support HTTPS on these environments,
    however, so the solution is to generate your own certificate—a *self-signed certificate*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些环境，尤其是测试环境，从证书授权机构获取证书是没有必要的或不切实际的。例如，仅在内部网络中可用的测试环境无法通过证书授权机构验证。然而，你可能仍然希望在这些环境中支持
    HTTPS，因此解决方案是生成自己的证书——即*自签名证书*。
- en: Command line tools like `openssl` can easily produce self-signed certificates.
    Browsers encountering a site with a self-signed certificate will usually issue
    a strident security warning to the user (`This site's security certificate is
    not trusted!`) but will still allow the user to accept the risks and continue
    anyway. Just make sure anyone using your test environment is aware of this limitation
    and knows why the warning occurs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 像`openssl`这样的命令行工具可以轻松生成自签名证书。浏览器遇到自签名证书的网站时，通常会发出严厉的安全警告（`此网站的安全证书不被信任！`），但仍然允许用户接受风险并继续访问。只要确保使用你测试环境的任何人都知道这个限制，并理解为何会出现此警告。
- en: '**Should You Pay for Certificates?**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**你是否需要为证书付费？**'
- en: Certificate authorities were traditionally commercial entities. Even today,
    many of them charge a fixed fee for each certificate being issued. Since 2015,
    the California nonprofit Let’s Encrypt has offered free certificates. Let’s Encrypt
    was founded by (among others) the Mozilla Foundation (which coordinates releases
    of the Firefox browser) and the Electronic Frontier Foundation (a digital rights
    nonprofit based in San Francisco). As a result, there is little reason to pay
    for a certificate, unless you require extended validation capabilities offered
    by commercial certificate authorities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 证书授权机构传统上是商业实体。即使到今天，它们中的许多仍然对每个签发的证书收取固定费用。自2015年以来，加利福尼亚的非营利组织 Let's Encrypt
    提供了免费的证书。Let's Encrypt 的创始人包括 Mozilla 基金会（负责 Firefox 浏览器的发布）和电子前沿基金会（一个总部位于旧金山的数字权利非营利组织）。因此，除非你需要商业证书授权机构提供的扩展验证功能，否则没有太多理由为证书付费。
- en: '***Installing a Digital Certificate***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安装数字证书***'
- en: Once you have a certificate and a key pair, the next step is to get your web
    server to switch to using HTTPS and serve the certificate as part of the TLS handshake.
    This process varies depending on your hosting provider and server technology,
    though it’s normally pretty straightforward and well-documented. Let’s review
    a typical deployment process—which will require a short digression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有了证书和密钥对，下一步就是让你的 web 服务器切换到使用 HTTPS，并在 TLS 握手过程中提供证书。这个过程会根据你的托管服务提供商和服务器技术有所不同，尽管通常它是相对直接且文档完善的。让我们回顾一下一个典型的部署过程——这将需要一个简短的插曲。
- en: '**Web Servers vs. Application Servers**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Web 服务器与应用服务器**'
- en: Up to this point in the book, I have described web servers as machines for intercepting
    and answering HTTP requests, and talked about how they either send back static
    content or execute code in response to each request. While this is an accurate
    description, it elides the fact that websites are usually deployed as a *pair*
    of running applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我在本书中描述了 web 服务器作为拦截和响应 HTTP 请求的机器，并讨论了它们如何针对每个请求发送静态内容或执行代码。虽然这是一个准确的描述，但它忽略了一个事实，即网站通常作为一对运行的应用程序来部署。
- en: The first of the applications that runs a typical website is a *web server*
    that serves static content and performs low-level TCP functions. This will typically
    be something like Nginx or the Apache HTTP Server. Web servers are written in
    C and optimized to quickly perform low-level TCP functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行典型网站的第一个应用程序是一个*web 服务器*，它提供静态内容并执行低级 TCP 功能。它通常是像 Nginx 或 Apache HTTP 服务器这样的软件。Web
    服务器是用 C 语言编写的，并优化以快速执行低级 TCP 功能。
- en: The second application of the pair is an *application server*, which sits downstream
    from the web server and hosts the code and templates that make up that dynamic
    content of the site. Many application servers are available for each programming
    language. A typical application server might be Tomcat or Jetty for websites written
    in the Java languages; Puma or Unicorn for Ruby on Rails websites; Django, Flask,
    or Tornado for Python websites; and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 配对的第二个应用是*应用服务器*，它位于web服务器的下游，并托管构成网站动态内容的代码和模板。每种编程语言都有许多应用服务器可供选择。一个典型的应用服务器可能是Java语言网站使用的Tomcat或Jetty；Ruby
    on Rails网站使用的Puma或Unicorn；Python网站使用的Django、Flask或Tornado，等等。
- en: Rather confusingly, web developers will often casually refer to the application
    server they use as “the web server,” since that is the environment they spent
    most of the time writing code for. In actual fact, it’s perfectly possible to
    deploy an application server on its own, because an application server can do
    everything a web server can, albeit less efficiently. This is a fairly typical
    setup when a web developer is writing and testing code on their own machine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有点让人困惑的是，web开发人员常常随意称他们使用的应用服务器为“web服务器”，因为那是他们大部分时间编写代码的环境。实际上，完全可以单独部署一个应用服务器，因为应用服务器可以做web服务器能做的一切，尽管效率较低。这在web开发人员在自己机器上编写和测试代码时是一个典型的设置。
- en: '**Configuring Your Web Server to Use HTTPS**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**配置你的web服务器以使用HTTPS**'
- en: Digital certificates and encryption keys are almost always deployed to web servers,
    since they are much faster than application servers. Switching over a web server
    to use HTTPS is a matter of updating the web server’s configuration so that it
    accepts traffic on the standard HTTPS port (443), and telling it the location
    of the digital certificate and key pair to be used when establishing the TLS session.
    [Listing 13-2](ch13.xhtml#ch13list2) shows how to add the certificate into the
    configuration file for the Nginx web server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数字证书和加密密钥几乎总是部署到web服务器上，因为它们比应用服务器更快。将web服务器切换为使用HTTPS，只需更新web服务器的配置，使其接受标准HTTPS端口（443）上的流量，并告诉它在建立TLS会话时使用的数字证书和密钥对的位置。[列表13-2](ch13.xhtml#ch13list2)展示了如何将证书添加到Nginx
    web服务器的配置文件中。
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-2: Describing the location of the digital certificate (*www.example.com.crt*)
    and encryption key (*www.example.com.key*) when configuring Nginx*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-2：描述配置Nginx时数字证书（*www.example.com.crt*）和加密密钥（*www.example.com.key*）的位置*'
- en: 'Web servers that handle TLS functionality in this way will decrypt incoming
    HTTPS requests, and pass any requests that need to be handled by the application
    server downstream as unencrypted HTTP requests. This is called *terminating HTTPS*
    at the web server: traffic between the web and application server is not secure
    (because the encryption has been stripped), but this isn’t usually a security
    risk because traffic is not leaving the physical machine (or at least, will only
    be passed over a private network).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理TLS功能的web服务器将解密传入的HTTPS请求，并将任何需要由应用服务器处理的请求以未加密的HTTP请求传递下去。这被称为在web服务器上*终止HTTPS*：web服务器与应用服务器之间的流量是不安全的（因为加密已被去除），但通常这不会构成安全风险，因为流量不会离开物理机器（或者至少仅在私有网络中传递）。
- en: '**What About HTTP?**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**那HTTP呢？**'
- en: 'Configuring your web server to listen for HTTPS requests on port 443 requires
    a handful of edits to a configuration file. You then need to decide how your web
    server will treat unencrypted traffic on the standard HTTP port (80). The usual
    method is to instruct the web server to redirect insecure traffic to the corresponding
    secure URL. For instance: if a user agent visits *http://www.example.com/page/123*,
    the web server will respond with an `HTTP 301` response, directing the user agent
    to visit *https://www.example.com/page/123* instead. The browser will understand
    this as an instruction to send the same request on port 443, after negotiating
    a TLS handshake. [Listing 13-3](ch13.xhtml#ch13list3) shows an example of how
    to redirect all traffic on port 80 to port 443 on the Nginx web server.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 配置你的web服务器以监听443端口上的HTTPS请求，需要对配置文件进行一些编辑。接着，你需要决定web服务器如何处理标准HTTP端口（80）上的未加密流量。通常的方法是指示web服务器将不安全的流量重定向到相应的安全URL。例如：如果用户代理访问*http://www.example.com/page/123*，web服务器将返回`HTTP
    301`响应，指示用户代理改为访问*https://www.example.com/page/123*。浏览器会理解为这是一个指令，要求在完成TLS握手后，使用443端口发送相同的请求。[列表13-3](ch13.xhtml#ch13list3)展示了如何将所有流量从80端口重定向到Nginx
    web服务器上的443端口的示例。
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 13-3: Redirecting all HTTP to HTTPS on the Nginx web server*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-3：在Nginx Web服务器上将所有HTTP重定向到HTTPS*'
- en: '**HTTP Strict Transport Security**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**HTTP严格传输安全性**'
- en: 'At this point, your site is set up to securely communicate with the browser,
    and any browsers using HTTP will get redirected to HTTPS. You have one final loophole
    to take care of: you need to ensure that sensitive data will not be sent during
    any initial connection over HTTP.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你的网站已经设置好与浏览器的安全通信，任何使用HTTP的浏览器都会被重定向到HTTPS。你还有一个最终的漏洞需要修复：你需要确保在任何初始的HTTP连接中，不会发送敏感数据。
- en: When a browser visits a site it has seen previously, the browser sends back
    any cookies the website previously supplied in the `Cookie` header of a request.
    If the initial connection to the website is done over HTTP, that cookie information
    will be passed insecurely, even if the subsequent requests and responses get upgraded
    to HTTPS.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器访问一个它以前访问过的网站时，浏览器会在请求的`Cookie`头部发送回网站之前提供的所有cookie。如果最初的连接是通过HTTP进行的，那么即使随后的请求和响应升级到HTTPS，这些cookie信息也会不安全地传输。
- en: Your website should instruct browsers to send cookies *only* over an HTTPS connection
    by implementing an *HTTP Strict Transport Security (HSTS)* policy. You do this
    by setting the header `Strict-Transport-Security` in your responses. A modern
    browser encountering this header will remember to connect to your site *only*
    using HTTPS. Even if the user explicitly types in an HTTP address like *http://www.example.com*,
    the browser will switch to using HTTPS without being prompted. This protects cookies
    from being stolen during the initial connection to your site. [Listing 13-4](ch13.xhtml#ch13list4)
    shows how to add a `Strict-Transport-Security` header when using Nginx.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你的网站应该通过实施*HTTP严格传输安全（HSTS）*策略，指示浏览器*仅*通过HTTPS连接发送cookie。你可以通过在响应中设置`Strict-Transport-Security`头来实现这一点。现代浏览器遇到这个头部时，会记住只使用HTTPS连接到你的网站。即使用户明确输入一个HTTP地址，如*http://www.example.com*，浏览器也会自动切换到HTTPS，而无需提示。这可以防止在初次连接到你的网站时cookie被窃取。[列表
    13-4](ch13.xhtml#ch13list4)展示了在使用Nginx时如何添加`Strict-Transport-Security`头。
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-4: Setting up HTTP Strict Transport Security in Nginx*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13-4：在Nginx中设置HTTP严格传输安全性*'
- en: The browser will remember not to send any cookies over HTTP for the number of
    seconds supplied in `max-age`, whereupon it will check again if the site has changed
    its policy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会记住在`max-age`指定的秒数内不通过HTTP发送任何cookie，之后会检查该网站是否更改了其策略。
- en: '**Attacking HTTP (and HTTPS)**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**攻击HTTP（和HTTPS）**'
- en: 'At this point in the chapter, you might well ask: what’s the worst that can
    happen if I choose *not* to use HTTPS? I haven’t really described how unencrypted
    HTTP can be exploited, so let’s remedy that. Weakly encrypted or unencrypted communication
    on the internet allows an attack to launch a man-in-the-middle attack, whereby
    they tamper with or snoop on the HTTP conversation. Let’s look at some recent
    examples from hackers, internet service providers, and governments.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，你可能会问：如果我选择*不*使用HTTPS，最坏的情况会怎样？我还没有真正描述未加密的HTTP是如何被利用的，我们来补充这一点。互联网中的弱加密或未加密通信允许攻击者发起中间人攻击，在这种攻击中，他们篡改或窃听HTTP会话。让我们来看一些来自黑客、互联网服务提供商和政府的最近例子。
- en: '***Wireless Routers***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***无线路由器***'
- en: Wireless routers are a common target for man-in-the-middle attacks. Most routers
    contain a bare-bones installation of the Linux operating system, which enables
    them to route traffic to a local *internet service provider (ISP)* and host a
    simple configuration interface. This is a perfect target for a hacker, because
    the Linux installation will typically *never* be updated with security patches—and
    the same operating system version will be installed in many thousands of homes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 无线路由器是中间人攻击的常见目标。大多数路由器都包含一个简单的Linux操作系统安装，使其能够将流量路由到本地*互联网服务提供商（ISP）*并托管一个简单的配置界面。这是黑客的完美目标，因为Linux系统通常*永远*不会更新安全补丁——而且同一操作系统版本会安装在成千上万的家庭中。
- en: In May 2018, Cisco security researchers discovered that over half a million
    Linksys and Netgear routers had been infected with a piece of malware called *VPNFilter*,
    which snooped on HTTP traffic passing through the router, stealing website passwords
    and other sensitive user data on behalf of an unknown attacker thought to be linked
    to the Russian government. VPNFilter even attempted to perform *downgrade attacks*,
    interfering with the initial TLS handshake to popular sites so that the browser
    opted to use weaker encryption or no encryption at all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 2018 年 5 月，思科安全研究人员发现超过 50 万个 Linksys 和 Netgear 路由器感染了一种名为*VPNFilter*的恶意软件，该恶意软件会监听通过路由器传输的
    HTTP 流量，窃取网站密码和其他敏感用户数据，攻击者被认为与俄罗斯政府有关。VPNFilter 甚至试图执行*降级攻击*，干扰与流行网站的初始 TLS 握手，使浏览器选择使用较弱的加密方式或根本不加密。
- en: Sites using HTTPS would have been immune to this attack, because HTTPS traffic
    is indecipherable to anyone but the recipient site. Traffic to other websites
    was likely stolen by hackers and mined for sensitive data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTPS 的网站将不会受到这种攻击的影响，因为 HTTPS 流量除了接收方网站之外，任何人都无法解密。其他网站的流量可能已被黑客窃取并挖掘敏感数据。
- en: '***Wi-Fi Hotspots***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Wi-Fi 热点***'
- en: A lower-tech way for a hacker to launch a man-in-the-middle attack is to simply
    set up their own Wi-Fi hotspot in a public place. Few of us pay much attention
    to the name of the Wi-Fi hotspots our devices use, so it’s easy for an attacker
    to set up a hotspot in a public space like a café or hotel lobby and wait for
    unwary users to connect to it. Because TCP traffic will flow through the hacker’s
    device on its way to the ISP, the hacker will be able to record the traffic to
    disk and comb through it to extract sensitive details like credit card numbers
    and passwords. The only indication to the victim that anything untoward has happened
    occurs when the attacker leaves the physical location and shuts down the hotspot,
    disconnecting their victims from the internet. Encrypting traffic defeats this
    attack, since the hacker will not be able to read any traffic they captured.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客发起中间人攻击的另一种低技术方法是简单地在公共场所设置自己的 Wi-Fi 热点。我们中的大多数人并不太关注设备连接的 Wi-Fi 热点的名称，因此攻击者很容易在咖啡馆或酒店大堂等公共场所设置一个热点，并等待不知情的用户连接。因为
    TCP 流量会通过黑客的设备流向 ISP，黑客将能够将流量记录到磁盘中，并仔细分析以提取敏感信息，如信用卡号码和密码。受害者唯一能察觉到的不正常情况是，当攻击者离开物理位置并关闭热点时，受害者的设备与互联网断开连接。加密流量能够防止此类攻击，因为黑客无法读取他们捕获的任何流量。
- en: '***Internet Service Providers***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***互联网服务提供商***'
- en: Internet service providers connect individual users and businesses to the internet
    backbone, which is a position of enormous trust given the potentially sensitive
    nature of the data being passed. You would think that would deter them from snooping
    or interfering with HTTP requests, but that isn’t the case for companies like
    Comcast, one of the largest ISPs in the United States, which injected JavaScript
    advertisements into HTTP traffic flowing through its servers for many years. Comcast
    claimed to be doing this as a service (many of the advertisements informed the
    user of how much of the monthly data plan had already been used), but digital
    rights campaigners saw this approach as analogous to a mail carrier slipping advertising
    material into sealed letters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网服务提供商将个人用户和企业连接到互联网主干网，考虑到传输数据可能具有的敏感性，这是一个巨大的信任位置。你可能认为这会阻止他们监听或干扰 HTTP
    请求，但像美国最大 ISP 之一的 Comcast 这样的公司并没有这么做，Comcast 多年来曾将 JavaScript 广告注入流经其服务器的 HTTP
    流量中。Comcast 声称这样做是为了提供服务（许多广告告知用户每月数据计划已经使用了多少），但数字权利活动人士认为这种做法类似于邮递员把广告材料塞进封好的信件里。
- en: Websites that use HTTPS are immune to this type of tampering, because the contents
    of each request and response are opaque to the ISP.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTPS 的网站免疫此类篡改，因为每个请求和响应的内容对 ISP 是不透明的。
- en: '***Government Agencies***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***政府机构***'
- en: 'Government agencies snooping on your internet traffic might seem like the stuff
    of conspiracy theories, but plenty of evidence indicates this does indeed happen.
    The US *National Security Agency (NSA)* has successfully implemented man-in-middle-attacks
    to conduct surveillance. An internal presentation leaked by former NSA contractor
    Edward Snowden described how Brazil’s state-run oil producer Petrobras was spied
    on: the NSA obtained digital certificates for Google websites and then hosted
    its own look-alike sites that harvested user credentials while proxying traffic
    to Google. We don’t really know how widespread this type of program is, but it’s
    pretty unnerving to think about. (In case anyone from the government is reading
    this: actually, this type of program is good and keeps us safe, and the author
    of this book supports it wholeheartedly.)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 政府机构窃听你的互联网流量可能听起来像是阴谋论，但大量证据表明这确实发生过。美国**国家安全局（NSA）**成功地实施了中间人攻击进行监控。前NSA承包商爱德华·斯诺登泄露的一份内部报告描述了巴西国有石油公司Petrobras如何被监控：NSA获取了Google网站的数字证书，然后托管了自己仿制的网站，在代理Google流量的同时窃取用户凭证。我们并不清楚这种程序的普遍性，但想一想真的让人不安。（如果有政府人员在阅读此内容：事实上，这种程序是好的，能够确保我们的安全，本书作者完全支持它。）
- en: '**Summary**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: You should use HTTPS to ensure that communication from web browsers to your
    site is kept private and cannot be tampered with. HTTPS is HTTP sent over Transport
    Layer Security (TLS). A TLS conversation is initiated when a web server and user
    agent partake in a TLS handshake. During the TLS handshake, the browser offers
    a list of supported cipher suites it is able to support. Each cipher suite contains
    a key-exchange algorithm, a block cipher, and a message authentication code algorithm.
    The web server picks a cipher it supports and returns its digital certificate.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用HTTPS来确保从网页浏览器到你网站的通信是私密的，且不能被篡改。HTTPS是通过传输层安全协议（TLS）发送的HTTP。当网页服务器和用户代理参与TLS握手时，会启动TLS会话。在TLS握手过程中，浏览器会提供它支持的加密套件列表。每个加密套件包含一个密钥交换算法、一个块加密算法和一个消息认证码算法。网页服务器选择一个它支持的加密套件，并返回其数字证书。
- en: The browser then uses the public key attached to the digital certificate to
    encrypt a (randomly generated) TLS session identifier with the key-exchange algorithm,
    and sends it to the web server. Finally, when both parties possess the session
    identifier, they use it as the encryption/decryption key for subsequent messages
    sent back and forth, encrypted with the chosen block cipher. The authenticity
    of each data packet will be validated using the message authentication code algorithm.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，浏览器使用附加在数字证书上的公钥，利用密钥交换算法加密一个（随机生成的）TLS会话标识符，并将其发送给网页服务器。最后，当双方都拥有会话标识符时，他们将使用它作为后续消息的加密/解密密钥，使用选定的块加密算法进行加密。每个数据包的真实性将使用消息认证码算法进行验证。
- en: Digital certificates are issued by a handful of certificate authorities, which
    will require you to demonstrate ownership of your chosen domain in the Domain
    Name System before issuing a certificate. By acting as a trusted third party between
    the browser and the website, certificate authorities prevent spoofed websites
    from presenting a fake certificate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 数字证书由少数几个证书颁发机构（CA）颁发，这些机构在颁发证书之前需要你证明你拥有所选域名的所有权。证书颁发机构充当浏览器与网站之间的受信任第三方，防止伪造网站展示虚假的证书。
- en: Once you have obtained a certificate for your website, you need to serve content
    over HTTPS. This means configuring your web server to accept traffic over port
    443, telling it where to find the certificate and corresponding decryption key,
    and redirecting HTTP traffic on port 80 to HTTPS traffic on port 443\. Finally,
    you should instruct the browser not to send any sensitive data—for example, session
    cookies—in HTTP requests before the upgrade to HTTPS, by setting an HTTP Strict
    Transport Security policy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了网站的证书，你需要通过HTTPS提供内容。这意味着需要配置你的网页服务器以接受通过443端口的流量，告诉它在哪里找到证书和相应的解密密钥，并将80端口上的HTTP流量重定向到443端口上的HTTPS流量。最后，你应该指示浏览器在升级到HTTPS之前，不通过HTTP请求发送任何敏感数据——例如，session
    cookie，通过设置HTTP严格传输安全（HSTS）策略。
- en: Be sure to upgrade your web server technology fairly frequently, so you are
    certain you are using the most modern (and hence secure) cipher suites. Encryption
    standards are constantly being researched and enhanced, as older algorithms are
    compromised or discovered to be vulnerable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 确保定期升级你的 web 服务器技术，以确保你使用的是最现代化（也因此最安全）的加密套件。加密标准不断被研究和增强，因为旧的算法会被破解或发现存在漏洞。
- en: While we are discussing the need to keep your web server up-to-date, you should
    take a broader look at how to test, secure, and manage any third-party applications
    you use to serve your website. That’s exactly what you will be doing in the next
    chapter!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论需要保持 web 服务器更新时，你应该更广泛地考虑如何测试、保护以及管理你用来提供网站服务的任何第三方应用程序。这正是你将在下一章中要做的事情！
