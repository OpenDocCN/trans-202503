- en: '**13**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ENCRYPTION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Encryption powers the modern internet. Without the ability to exchange data
    packets privately and securely, e-commerce would not exist, and users wouldn’t
    be able to safely authenticate themselves to internet sites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The HyperText Transfer Protocol Secure is the most widely used form of encryption
    on the web. Web servers and web browsers universally support HTTPS, so the developer
    can divert all traffic to that protocol and guarantee secure communication for
    their users. A web developer who wants to use HTTPS on their site needs only to
    obtain a *certificate* from a *certificate authority* and install it with their
    hosting provider.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The ease with which you can get started using encryption belies the complexity
    of what is happening when a website and user agent interact over HTTPS. Modern
    *cryptography*—the study of methods of encrypting and decrypting data—depends
    on techniques developed and actively researched by mathematicians and security
    professionals. Thankfully, the abstracted layers of the Internet Protocol mean
    you don’t need to know linear algebra or number theory to use their discoveries.
    But the more you understand about the underlying algorithms, the more you will
    be able to preempt potential risks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This chapter first gives a general overview of how encryption is used in the
    Internet Protocol and the mathematics that underpin it. Once you have a good grasp
    of how encryption works, you will review the practical steps a developer needs
    to undertake to get started using HTTPS. Finally, you will look at how hackers
    take advantage of unencrypted or weakly encrypted traffic, and how some attacks
    can circumvent encryption entirely.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption in the Internet Protocol**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that messages sent over the internet are split into data packets and
    directed toward their eventual destination via the *Transmission Control Protocol
    (TCP)*. The recipient computer assembles these TCP packets back into the original
    message. TCP doesn’t dictate *how* the data being sent is meant to be interpreted.
    For that to happen, both computers need to agree on how to interpret the data
    being sent, using a higher-level protocol such as HTTP. TCP also does nothing
    to disguise the content of the packets being sent. Unsecured TCP conversations
    are vulnerable to *man-in-the-middle attacks*, whereby malicious third parties
    intercept and read the packets as they are transmitted.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, HTTP conversations between a browser and a web server are secured
    by *Transport Layer Security (TLS)*, a method of encryption that provides both
    privacy (by ensuring data packets can’t be deciphered by a third party) and *data
    integrity* (by ensuring that any attempt to tamper with the packets in transit
    will be detectable). HTTP conversations conducted using TLS are called *HTTP Secure
    (HTTPS)* conversations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: When your web browser connects to an HTTPS website, the browser and web server
    negotiate which encryption algorithms to use as part of the *TLS handshake*—the
    exchange of data packets that occurs when a TLS conversation is initiated. To
    make sense of what happens during the TLS handshake, we need to take a brief detour
    into the various types of encryption algorithms. Time for some light mathematics!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '***Encryption Algorithms, Hashing, and Message Authentication Codes***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *encryption algorithm* takes input data and scrambles it by using an *encryption
    key*—a secret shared between two parties wishing to initiate secure communication.
    The scrambled output is indecipherable to anyone without a *decryption key*—the
    corresponding key required to unscramble the data. The input data and keys are
    typically encoded as binary data, though the keys may be expressed as strings
    of text for readability.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Many encryption algorithms exist, and more continue to be invented by mathematicians
    and security researchers. They can be classified into a few categories: symmetric
    and asymmetric encryption algorithms (for ciphering data), hash functions (for
    fingerprinting data and building other cryptographic algorithms), and message
    authentication codes (for ensuring data integrity).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**Symmetric Encryption Algorithms**'
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *symmetric encryption algorithm* uses the same key to encrypt and decrypt
    data. Symmetric encryption algorithms usually operate as *block ciphers*: they
    break the input data into fixed-size blocks that can be individually encrypted.
    (If the last block of input data is undersized, it will be *padded* to fill out
    the block size.) This makes them suitable for processing streams of data, including
    TCP data packets.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Symmetric algorithms are designed for speed but have one major security flaw:
    the decryption key must be given to the receiving party before they decrypt the
    data stream. If the decryption key is shared over the internet, potential attackers
    will have an opportunity to steal the key, which allows them to decrypt any further
    messages. Not good.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Asymmetric Encryption Algorithms**'
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In response to the threat of decryption keys being stolen, *asymmetric encryption
    algorithms* were developed. Asymmetric algorithms use different keys to encrypt
    and decrypt data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'An asymmetric algorithm allows a piece of software such as a web server to
    publish its encryption key freely, while keeping its decryption key a secret.
    Any user agent looking to send secure messages to the server can encrypt those
    messages by using the server’s encryption key, secure in the knowledge that nobody
    (not even themselves!) will be able to decipher the data being sent, because the
    decryption key is kept secret. This is sometimes described as *public-key cryptography*:
    the encryption key (*the public key*) can be published; only the decryption key
    (the *private key*) needs to be kept secret.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric algorithms are significantly more complex and hence slower than symmetric
    algorithms. Encryption in the Internet Protocol uses a combination of both types,
    as you will see later in the chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称算法比对称算法复杂得多，因此也更慢。互联网协议中的加密使用了两种类型的算法的结合，正如你稍后在本章中将看到的那样。
- en: '**Hash Functions**'
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**哈希函数**'
- en: 'Related to encryption algorithms are *cryptographic hash functions*, which
    can be thought of as encryption algorithms whose output *cannot* be decrypted.
    Hash functions also have a couple of other interesting properties: the output
    of the algorithm (the *hashed value*) is always a fixed size, regardless of the
    size of input data; and the chances of getting the same output value, given different
    input values, is astronomically small.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与加密算法相关的是*加密哈希函数*，可以将其视为一种输出*无法*被解密的加密算法。哈希函数还有一些其他有趣的属性：算法的输出（*哈希值*）始终是固定大小的，无论输入数据的大小如何；而且，给定不同的输入值，得到相同输出值的概率极其微小。
- en: Why on earth would you want to encrypt data you couldn’t subsequently decrypt?
    Well, it’s a neat way to generate a “fingerprint” for input data. If you need
    to check that two separate inputs are the same but don’t want to store the raw
    input values for security reasons, you can verify that both inputs produce the
    same hashed value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你会想要加密一些你之后无法解密的数据呢？好吧，这是生成输入数据“指纹”的一种巧妙方式。如果你需要检查两个不同的输入是否相同，但出于安全原因不想存储原始输入值，你可以验证这两个输入是否生成相同的哈希值。
- en: 'This is how website passwords are typically stored, as we saw in [Chapter 9](ch09.xhtml#ch09).
    When a password is first set by a user, the web server will store the hashed value
    of the password in the database but will deliberately forget the actual password
    value. When the user later reenters their password on the site, the server will
    recalculate the hashed value and compare it with the stored hashed value. If the
    two hashed values differ, it indicates the user entered a different password,
    which means the credentials should be rejected. In this way, a site can check
    the correctness of passwords without explicitly knowing each user’s password.
    (Storing passwords in plaintext form is a security hazard: if an attacker compromises
    the database, they get every user’s password.)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是网站密码通常存储的方式，正如我们在[第9章](ch09.xhtml#ch09)中看到的那样。当用户首次设置密码时，网站服务器会将密码的哈希值存储在数据库中，并故意忘记实际的密码值。当用户稍后再次输入密码时，服务器会重新计算哈希值并与存储的哈希值进行比较。如果两个哈希值不同，则表示用户输入了不同的密码，意味着该凭证应被拒绝。通过这种方式，网站可以检查密码的正确性，而无需明确知道每个用户的密码。（以明文形式存储密码是一种安全隐患：如果攻击者入侵数据库，他们将获得每个用户的密码。）
- en: '**Message Authentication Codes**'
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**消息认证码**'
- en: '*Message authentication code (MAC)* algorithms are similar to (and generally
    built on top of) cryptographic hash functions, in that they map input data of
    an arbitrary length to a unique, fixed-sized output. This output is itself called
    a *message authentication code*. MAC algorithms are more specialized than hash
    functions, however, because recalculating a MAC requires a secret key. This means
    that only the parties in possession of the secret key can generate or check the
    validity of message authentication codes.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息认证码（MAC）*算法与加密哈希函数相似（通常是在加密哈希函数的基础上构建），它们将任意长度的输入数据映射到一个唯一且固定大小的输出。这个输出本身就是所谓的*消息认证码*。然而，MAC算法比哈希函数更加专业化，因为重新计算MAC需要一个秘密密钥。这意味着只有拥有秘密密钥的参与方才能生成或检查消息认证码的有效性。'
- en: MAC algorithms are used to ensure that the data packets transmitted on the internet
    cannot be forged or tampered with by an attacker. To use a MAC algorithm, the
    sending and receiving computers exchange a shared, secret key—usually as part
    of the TLS handshake. (The secret key will itself be encrypted before it is sent,
    to avoid the risk of it being stolen.) From that point onward, the sender will
    generate a MAC for each data packet being sent and attach the MAC to the packet.
    Because the recipient computer has the same key, it can recalculate the MAC from
    the message. If the calculated MAC differs from the value attached to the packet,
    this is evidence that the packet has been tampered with or corrupted in some form,
    or it was not sent by the original computer. Hence, the recipient rejects the
    data packet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve gotten to this point and are still paying attention, congratulations!
    Cryptography is a large, complex subject that has its own particular jargon. Understanding
    how it fits into the Internet Protocol requires balancing multiple concepts in
    your head at once, so thank you for your patience. Let’s see how the various types
    of cryptographic algorithms we have discussed are used by TLS.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '***The TLS Handshake***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS uses a combination of cryptographic algorithms to efficiently and safely
    pass information. For speed, most data packets passed over TLS will be encrypted
    using a symmetric encryption algorithm commonly referred to as the *block cipher*,
    since it encrypts “blocks” of streaming information. Recall that symmetric encryption
    algorithms are vulnerable to having their encryption keys stolen by malicious
    users eavesdropping on the conversation. To safely pass the encryption/decryption
    key for the block cipher, TLS will encrypt the key by using an *asymmetric* algorithm
    before passing it to the recipient. Finally, data packets passed using TLS will
    be tagged using a message authentication code, to detect if any data has been
    tampered with.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: At the start of a TLS conversation, the browser and website perform a *TLS handshake*
    to determine how they should communicate. In the first stage of the handshake,
    the browser will list multiple cipher suites that it supports. Let’s drill down
    on what this means.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '**Cipher Suites**'
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *cipher suite* is a set of algorithms used to secure communication. Under
    the TLS standard, a cipher suite consists of *three* separate algorithms. The
    first algorithm, the *key-exchange algorithm*, is an asymmetric encryption algorithm.
    This is used by communicating computers to exchange secret keys for the second
    encryption algorithm: the symmetric block cipher designed for encrypting the content
    of TCP packets. Finally, the cipher suite specifies a MAC algorithm for authenticating
    the encrypted messages.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make this more concrete. A modern web browser such as Google Chrome that
    supports TLS 1.3 offers numerous cipher suites. At the time of writing, one of
    these suites goes by the catchy name of ECDHE-ECDSA-AES128-GCM-SHA256\. This particular
    cipher suite includes ECDHE-RSA as the key-exchange algorithm, AES-128-GCM as
    the block cipher, and SHA-256 as the message authentication algorithm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个内容更具体化。像 Google Chrome 这样的现代 web 浏览器支持 TLS 1.3，并提供了许多密码套件。在撰写本文时，其中一个密码套件的名字非常有趣，叫做
    ECDHE-ECDSA-AES128-GCM-SHA256。这个特定的密码套件包括 ECDHE-RSA 作为密钥交换算法，AES-128-GCM 作为块密码，SHA-256
    作为消息认证算法。
- en: Want some more, entirely unnecessary, detail? Well, *ECDHE* stands for *Elliptic
    Curve Diffie–Hellman Exchange* (a modern method of establishing a shared secret
    over an insecure channel). *RSA* stands for the *Rivest–Shamir–Adleman* algorithm
    (the first practical asymmetric encryption algorithm, invented by three mathematicians
    in the 1970s after drinking a lot of Passover wine). *AES* stands for the *Advanced
    Encryption Standard* (an algorithm invented by two Belgian cryptographers and
    selected by the National Institute of Standards and Technology through a three-year
    review process). This particular variant uses a 128-bit key in Galois/Counter
    Mode, which is specified by *GCM* in the name. Finally, SHA-256 stands for the
    *Secure Hash Algorithm* (a hash function with a 256-bit word size).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想要更多完全不必要的细节吗？好吧，*ECDHE* 代表 *椭圆曲线 Diffie-Hellman 密钥交换*（一种在不安全通道上建立共享密钥的现代方法）。*RSA*
    代表 *Rivest–Shamir–Adleman* 算法（第一种实用的非对称加密算法，由三位数学家在 1970 年代发明，灵感来自他们喝了大量的逾越节酒）。*AES*
    代表 *高级加密标准*（由两位比利时密码学家发明，并通过国家标准与技术研究院的三年审查过程被选中）。这个特定变体使用了 128 位密钥，采用 Galois/计数器模式，这就是名称中所指定的
    *GCM*。最后，SHA-256 代表 *安全哈希算法*（一种具有 256 位字长的哈希函数）。
- en: See what I mean about the complexity of modern encryption standards? Modern
    browsers and web servers support a fair number of cipher suites, and more get
    added to the TLS standard all the time. As weaknesses are discovered in existing
    algorithms, and computing power gets cheaper, security researchers update the
    TLS standard to keep the internet secure. As a web developer, it’s not particularly
    important to understand how these algorithms work, but it *is* important to keep
    your web server software up-to-date so you can support the most modern, secure
    algorithms.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了现代加密标准的复杂性了吗？现代浏览器和 web 服务器支持相当多的密码套件，而且随着时间的推移，TLS 标准中不断增加新的套件。随着现有算法的弱点被发现，计算能力变得更加廉价，安全研究人员会更新
    TLS 标准，以保持互联网的安全。作为一名 web 开发者，了解这些算法如何工作并不是特别重要，但*保持你的 web 服务器软件最新*，以便能够支持最现代、最安全的算法，这一点非常重要。
- en: '**Session Initiation**'
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**会话初始化**'
- en: Let’s continue where we left off. In the second stage of the TLS handshake,
    the web server selects the most secure cipher suite it can support and then instructs
    the browser to use those algorithms for communication. At the same time, the server
    passes back a *digital certificate*, containing the server name, the trusted certificate
    authority that will vouch for the authenticity of the certificate, and the web
    server’s encryption key to be used in the key-exchange algorithm. (We will discuss
    what certificates are and why they are necessary for secure communication in the
    next section.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着上次的内容继续。在 TLS 握手的第二阶段，web 服务器选择它能够支持的最安全的密码套件，并指示浏览器使用这些算法进行通信。与此同时，服务器返回一个*数字证书*，其中包含服务器名称、将为证书的真实性担保的受信证书机构，以及在密钥交换算法中使用的
    web 服务器加密密钥。（我们将在下一节中讨论什么是证书以及它们为何对安全通信至关重要。）
- en: Once the browser verifies the authenticity of the certificate, the two computers
    generate a *session key* that will be used to encrypt the TLS conversation with
    the chosen block cipher. (Note that this session key is different from the HTTP
    *session identifier* discussed in previous chapters. TLS handshakes occur at a
    lower level of the Internet Protocol than the HTTP conversation, which has not
    begun yet.) The session key is a large random number generated by the browser,
    encrypted with the (public) encryption key attached to the digital certificate
    using the key-exchange algorithm, and transmitted to the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器验证了证书的真实性，两个计算机会生成一个*会话密钥*，该密钥将用于使用选择的块加密算法加密 TLS 会话。（请注意，这个会话密钥与前面章节讨论的
    HTTP *会话标识符*不同。TLS 握手发生在比 HTTP 会话更低级别的互联网协议中，而 HTTP 会话还未开始。）会话密钥是由浏览器生成的大随机数，用数字证书中附带的（公）加密密钥加密，采用密钥交换算法进行加密，并传输到服务器。
- en: Now, finally, the TLS conversation can begin. Everything past this point will
    be securely encrypted using the block cipher and the shared session identifier,
    so the data packets will be indecipherable to anyone snooping on the conversation.
    The browser and server use the agreed-upon encryption algorithm and session key
    to encrypt packets in both directions. Data packets are also authenticated and
    tamper-proof, using message authentication codes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，TLS 会话终于可以开始了。此后所有的数据都会使用块加密算法和共享会话标识符进行加密，因此任何窃听会话的人都无法解读数据包。浏览器和服务器使用商定的加密算法和会话密钥在双向加密数据包。数据包还会进行身份验证并防篡改，使用消息认证码。
- en: As you can see, a lot of complex mathematics underpin secure communication on
    the internet. Thankfully, the steps involved for enabling HTTPS as a web developer
    are much simpler. Now we have the theory out of the way, let’s take a look at
    the practical steps needed to secure your users.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，支撑互联网安全通信的是大量复杂的数学原理。幸运的是，作为一名 web 开发者，启用 HTTPS 所涉及的步骤要简单得多。现在我们已经了解了理论部分，让我们来看一下确保用户安全所需的实际步骤。
- en: '**Enabling HTTPS**'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**启用 HTTPS**'
- en: Securing traffic for your website is a lot easier than understanding the underlying
    encryption algorithms. Most modern web browsers are self-updating; the development
    teams for each major browser will be on the cutting edge of supporting modern
    TLS standards. The latest version of your web server software will support similarly
    modern TLS algorithms. That means that the only responsibility left to you as
    a developer is to obtain a digital certificate and install it on your web server.
    Let’s discuss how to do that and illuminate why certificates are necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的网站加密流量比理解底层加密算法要容易得多。大多数现代网页浏览器是自我更新的；每个主流浏览器的开发团队都会在支持现代 TLS 标准方面处于前沿地位。您网站服务器软件的最新版本也会支持类似的现代
    TLS 算法。这意味着，作为开发者，您唯一需要做的就是获取一个数字证书并将其安装到您的网站服务器上。让我们来讨论如何做，并阐明为什么证书是必要的。
- en: '***Digital Certificates***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数字证书***'
- en: A *digital certificate* (also known as a *public-key certificate*) is an electronic
    document used to prove ownership of a public encryption key. Digital certificates
    are used in TLS to associate encryption keys with internet domains (such as *example.com*).
    They are issued by *certificate authorities*, which act as a trusted third party
    between a browser and a website, vouching that a given encryption key should be
    used to encrypt data being sent to the website’s domain. Browser software will
    trust a few hundred certificate authorities—for example, Comodo, DigiCert, and,
    more recently, the nonprofit Let’s Encrypt. When a trusted certificate authority
    vouches for a key and domain, it assures your browser that it’s communicating
    with the right website using the right encryption key, thereby blocking an attacker
    from presenting a malicious website or certificate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字证书*（也称为*公钥证书*）是一种电子文档，用于证明公钥的所有权。数字证书在 TLS 中用于将加密密钥与互联网域名（如*example.com*）关联。它们由*证书颁发机构*（CA）颁发，证书颁发机构作为浏览器和网站之间的受信第三方，保证使用指定的加密密钥来加密发送到网站域名的数据。浏览器软件会信任几百个证书颁发机构——例如，Comodo、DigiCert，最近还有非营利组织
    Let’s Encrypt。当一个受信的证书颁发机构担保某个密钥和域名时，它会确保您的浏览器正在与正确的网站进行通信，并且使用正确的加密密钥，从而阻止攻击者呈现恶意网站或证书。'
- en: 'You might ask: why is a third party required to exchange encryption keys on
    the internet? After all, isn’t the whole point of asymmetric encryption that the
    public key can be made available freely by the server itself? While this statement
    is true, the actual process of fetching an encryption key on the internet depends
    on the reliability of the internet’s *Domain Name System (DNS)* that maps domain
    names to IP addresses. Under some circumstances, DNS is vulnerable to *spoofing
    attacks* that can be used to direct internet traffic away from a legitimate server
    to an IP address controlled by an attacker. If an attacker can spoof an internet
    domain, they can issue their own encryption key, and victims would be none the
    wiser.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：为什么需要第三方来交换互联网中的加密密钥？毕竟，非对称加密的一个重点不是服务器自己可以自由提供公钥吗？虽然这个说法是对的，但实际上在互联网上获取加密密钥的过程依赖于互联网的*域名系统（DNS）*，它将域名映射到IP地址。在某些情况下，DNS容易受到*伪造攻击*，这些攻击可以将互联网流量引导到攻击者控制的IP地址，而不是合法的服务器。如果攻击者能够伪造互联网域名，他们可以颁发自己的加密密钥，受害者通常不会察觉。
- en: Certificate authorities exist to prevent encrypted traffic from being spoofed.
    Should an attacker find a way to divert traffic from a legitimate (secure) website
    to a malicious server under their control, that attacker will typically not possess
    the decryption key corresponding to the website’s certificate. This means they
    will be unable to decrypt intercepted traffic that was encrypted using the encryption
    key attached to the site’s digital certificate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 证书授权机构的存在是为了防止加密流量被伪造。如果攻击者找到方法将流量从合法（安全）网站转移到他们控制的恶意服务器，攻击者通常不会拥有与该网站证书对应的解密密钥。这意味着他们将无法解密使用与网站数字证书附带的加密密钥加密的拦截流量。
- en: On the other hand, if the attacker presents an *alternative* digital certificate
    corresponding to a decryption key that they *do* possess, that certificate will
    not have been verified by a trusted certificate authority. Any browser visiting
    the spoofed website will show a security warning to the user, strongly dissuading
    them from continuing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果攻击者提供一个*替代*的数字证书，该证书对应于他们*确实*拥有的解密密钥，那么该证书将不会经过受信任的证书授权机构验证。任何访问伪造网站的浏览器都会向用户显示安全警告，强烈劝阻用户继续访问。
- en: In this way, certificate authorities allow users to trust the websites they
    are visiting. You can view the certificate a website is using by clicking the
    padlock icon in the browser bar. The information described there won’t be particularly
    interesting, but browsers do a good job of warning you when a certificate is invalid.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，证书授权机构使用户能够信任他们访问的网站。你可以通过点击浏览器栏中的挂锁图标查看网站使用的证书。那里的信息可能不特别有趣，但浏览器能够很好地警告你当证书无效时。
- en: '***Obtaining a Digital Certificate***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取数字证书***'
- en: Obtaining a digital certificate for your website from a certificate authority
    requires a few steps, by which the authority verifies that you own your domain.
    The precise way you perform these steps differs depending on which certificate
    authority you choose.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从证书授权机构获取数字证书需要几个步骤，通过这些步骤，授权机构可以验证你对域名的所有权。你执行这些步骤的具体方式取决于你选择的证书授权机构。
- en: The first step is to generate a *key pair*, a small digital file containing
    randomly generated public and private encryption keys. Next, you use this key
    pair to generate a *certificate signing request (CSR)* that contains the public
    key and domain name of your website, and upload the request to a certificate authority.
    Before honoring the signing request and issuing the certificate, the certificate
    authority will require you to demonstrate to them that you have control of the
    internet domain contained in the CSR. Once domain ownership has been verified,
    you can download the certificate and install it on your web server along with
    the key pair.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是生成一个*密钥对*，这是一个包含随机生成的公钥和私钥的小型数字文件。接下来，使用这个密钥对生成一个*证书签名请求（CSR）*，该请求包含你网站的公钥和域名，并将请求上传到证书授权机构。在签署请求并颁发证书之前，证书授权机构将要求你证明你对CSR中包含的互联网域名具有控制权。一旦域名所有权得到验证，你就可以下载证书，并将其与密钥对一起安装到你的Web服务器上。
- en: '**Generating a Key Pair and Certificate Signing Request**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成密钥对和证书签名请求**'
- en: The key pair and CSR are typically generated using the command line tool, `openssl`.
    CSRs often contain other information about the applicant besides the domain name
    and public key, such as the organization’s legal name and physical location. These
    get included in the signed certificate, but are not mandatory unless the certificate
    authority chooses to validate them. During the generation of the signing request,
    the domain name is often referred to as the *distinguished name (DN)* or the *fully
    qualified domain name (FQDN)*, for historical reasons. [Listing 13-1](ch13.xhtml#ch13list1)
    shows how to generate a certificate signing request by using `openssl`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Generating a certificate signing request by using openssl on
    the command line*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The file *private.key* should contain a newly generated private key (which can
    also be generated with `openssl`). The tool `openssl` will ask for details to
    incorporate into the signing request, including the domain name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain Verification**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Domain verification* is the process by which a certificate authority verifies
    that someone applying for a certificate for an internet domain does indeed have
    control of that domain. When applying for a digital certificate, you are stating
    that you need to be able to decrypt traffic sent to a particular internet domain.
    The certificate authority will insist on checking that you own that domain as
    part of its due diligence.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Domain verification generally requires you to make a temporary edit to the
    DNS entries for your domain, thus demonstrating that you have edit rights in the
    DNS. Domain verification is what protects against DNS spoofing attacks: an attacker
    cannot apply for a certificate unless they also have edit rights.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Extended Validation Certificates**'
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some certificate authorities issue *extended validation (EV)* certificates.
    These require the certificate authority to collect and verify information about
    the legal entity applying for a certificate. That information will then be included
    in the digital certificate, and made available in the web browser to users visiting
    the website. EV certificates are popular with large organizations, because the
    name of the company is usually displayed alongside the padlock icon in the browser
    URL bar, encouraging a sense of trust in users.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**Expiring and Revoking Certificates**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Digital certificates have a finite lifespan (typically in years or months) after
    which they must be reissued by the certificate authority. Certificate authorities
    also keep track of certificates that have been voluntarily *revoked* by certificate
    holders. If the private key corresponding to your digital certificate gets compromised,
    it’s important that you as a site owner apply for a new certificate and then revoke
    the prior certificate. Browsers will warn a user when visiting a website with
    an expired or revoked certificate.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-Signed Certificates**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For some environments, particularly testing environments, acquiring a certificate
    from a certificate authority is unnecessary or impractical. Testing environments
    that are available on only an internal network, for example, can’t be verified
    by a certificate authority. You may still want to support HTTPS on these environments,
    however, so the solution is to generate your own certificate—a *self-signed certificate*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Command line tools like `openssl` can easily produce self-signed certificates.
    Browsers encountering a site with a self-signed certificate will usually issue
    a strident security warning to the user (`This site's security certificate is
    not trusted!`) but will still allow the user to accept the risks and continue
    anyway. Just make sure anyone using your test environment is aware of this limitation
    and knows why the warning occurs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**Should You Pay for Certificates?**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Certificate authorities were traditionally commercial entities. Even today,
    many of them charge a fixed fee for each certificate being issued. Since 2015,
    the California nonprofit Let’s Encrypt has offered free certificates. Let’s Encrypt
    was founded by (among others) the Mozilla Foundation (which coordinates releases
    of the Firefox browser) and the Electronic Frontier Foundation (a digital rights
    nonprofit based in San Francisco). As a result, there is little reason to pay
    for a certificate, unless you require extended validation capabilities offered
    by commercial certificate authorities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing a Digital Certificate***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you have a certificate and a key pair, the next step is to get your web
    server to switch to using HTTPS and serve the certificate as part of the TLS handshake.
    This process varies depending on your hosting provider and server technology,
    though it’s normally pretty straightforward and well-documented. Let’s review
    a typical deployment process—which will require a short digression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**Web Servers vs. Application Servers**'
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Up to this point in the book, I have described web servers as machines for intercepting
    and answering HTTP requests, and talked about how they either send back static
    content or execute code in response to each request. While this is an accurate
    description, it elides the fact that websites are usually deployed as a *pair*
    of running applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The first of the applications that runs a typical website is a *web server*
    that serves static content and performs low-level TCP functions. This will typically
    be something like Nginx or the Apache HTTP Server. Web servers are written in
    C and optimized to quickly perform low-level TCP functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The second application of the pair is an *application server*, which sits downstream
    from the web server and hosts the code and templates that make up that dynamic
    content of the site. Many application servers are available for each programming
    language. A typical application server might be Tomcat or Jetty for websites written
    in the Java languages; Puma or Unicorn for Ruby on Rails websites; Django, Flask,
    or Tornado for Python websites; and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Rather confusingly, web developers will often casually refer to the application
    server they use as “the web server,” since that is the environment they spent
    most of the time writing code for. In actual fact, it’s perfectly possible to
    deploy an application server on its own, because an application server can do
    everything a web server can, albeit less efficiently. This is a fairly typical
    setup when a web developer is writing and testing code on their own machine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring Your Web Server to Use HTTPS**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Digital certificates and encryption keys are almost always deployed to web servers,
    since they are much faster than application servers. Switching over a web server
    to use HTTPS is a matter of updating the web server’s configuration so that it
    accepts traffic on the standard HTTPS port (443), and telling it the location
    of the digital certificate and key pair to be used when establishing the TLS session.
    [Listing 13-2](ch13.xhtml#ch13list2) shows how to add the certificate into the
    configuration file for the Nginx web server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-2: Describing the location of the digital certificate (*www.example.com.crt*)
    and encryption key (*www.example.com.key*) when configuring Nginx*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Web servers that handle TLS functionality in this way will decrypt incoming
    HTTPS requests, and pass any requests that need to be handled by the application
    server downstream as unencrypted HTTP requests. This is called *terminating HTTPS*
    at the web server: traffic between the web and application server is not secure
    (because the encryption has been stripped), but this isn’t usually a security
    risk because traffic is not leaving the physical machine (or at least, will only
    be passed over a private network).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '**What About HTTP?**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Configuring your web server to listen for HTTPS requests on port 443 requires
    a handful of edits to a configuration file. You then need to decide how your web
    server will treat unencrypted traffic on the standard HTTP port (80). The usual
    method is to instruct the web server to redirect insecure traffic to the corresponding
    secure URL. For instance: if a user agent visits *http://www.example.com/page/123*,
    the web server will respond with an `HTTP 301` response, directing the user agent
    to visit *https://www.example.com/page/123* instead. The browser will understand
    this as an instruction to send the same request on port 443, after negotiating
    a TLS handshake. [Listing 13-3](ch13.xhtml#ch13list3) shows an example of how
    to redirect all traffic on port 80 to port 443 on the Nginx web server.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 13-3: Redirecting all HTTP to HTTPS on the Nginx web server*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Strict Transport Security**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this point, your site is set up to securely communicate with the browser,
    and any browsers using HTTP will get redirected to HTTPS. You have one final loophole
    to take care of: you need to ensure that sensitive data will not be sent during
    any initial connection over HTTP.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: When a browser visits a site it has seen previously, the browser sends back
    any cookies the website previously supplied in the `Cookie` header of a request.
    If the initial connection to the website is done over HTTP, that cookie information
    will be passed insecurely, even if the subsequent requests and responses get upgraded
    to HTTPS.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Your website should instruct browsers to send cookies *only* over an HTTPS connection
    by implementing an *HTTP Strict Transport Security (HSTS)* policy. You do this
    by setting the header `Strict-Transport-Security` in your responses. A modern
    browser encountering this header will remember to connect to your site *only*
    using HTTPS. Even if the user explicitly types in an HTTP address like *http://www.example.com*,
    the browser will switch to using HTTPS without being prompted. This protects cookies
    from being stolen during the initial connection to your site. [Listing 13-4](ch13.xhtml#ch13list4)
    shows how to add a `Strict-Transport-Security` header when using Nginx.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 13-4: Setting up HTTP Strict Transport Security in Nginx*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The browser will remember not to send any cookies over HTTP for the number of
    seconds supplied in `max-age`, whereupon it will check again if the site has changed
    its policy.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacking HTTP (and HTTPS)**'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point in the chapter, you might well ask: what’s the worst that can
    happen if I choose *not* to use HTTPS? I haven’t really described how unencrypted
    HTTP can be exploited, so let’s remedy that. Weakly encrypted or unencrypted communication
    on the internet allows an attack to launch a man-in-the-middle attack, whereby
    they tamper with or snoop on the HTTP conversation. Let’s look at some recent
    examples from hackers, internet service providers, and governments.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '***Wireless Routers***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wireless routers are a common target for man-in-the-middle attacks. Most routers
    contain a bare-bones installation of the Linux operating system, which enables
    them to route traffic to a local *internet service provider (ISP)* and host a
    simple configuration interface. This is a perfect target for a hacker, because
    the Linux installation will typically *never* be updated with security patches—and
    the same operating system version will be installed in many thousands of homes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In May 2018, Cisco security researchers discovered that over half a million
    Linksys and Netgear routers had been infected with a piece of malware called *VPNFilter*,
    which snooped on HTTP traffic passing through the router, stealing website passwords
    and other sensitive user data on behalf of an unknown attacker thought to be linked
    to the Russian government. VPNFilter even attempted to perform *downgrade attacks*,
    interfering with the initial TLS handshake to popular sites so that the browser
    opted to use weaker encryption or no encryption at all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Sites using HTTPS would have been immune to this attack, because HTTPS traffic
    is indecipherable to anyone but the recipient site. Traffic to other websites
    was likely stolen by hackers and mined for sensitive data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '***Wi-Fi Hotspots***'
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A lower-tech way for a hacker to launch a man-in-the-middle attack is to simply
    set up their own Wi-Fi hotspot in a public place. Few of us pay much attention
    to the name of the Wi-Fi hotspots our devices use, so it’s easy for an attacker
    to set up a hotspot in a public space like a café or hotel lobby and wait for
    unwary users to connect to it. Because TCP traffic will flow through the hacker’s
    device on its way to the ISP, the hacker will be able to record the traffic to
    disk and comb through it to extract sensitive details like credit card numbers
    and passwords. The only indication to the victim that anything untoward has happened
    occurs when the attacker leaves the physical location and shuts down the hotspot,
    disconnecting their victims from the internet. Encrypting traffic defeats this
    attack, since the hacker will not be able to read any traffic they captured.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '***Internet Service Providers***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Internet service providers connect individual users and businesses to the internet
    backbone, which is a position of enormous trust given the potentially sensitive
    nature of the data being passed. You would think that would deter them from snooping
    or interfering with HTTP requests, but that isn’t the case for companies like
    Comcast, one of the largest ISPs in the United States, which injected JavaScript
    advertisements into HTTP traffic flowing through its servers for many years. Comcast
    claimed to be doing this as a service (many of the advertisements informed the
    user of how much of the monthly data plan had already been used), but digital
    rights campaigners saw this approach as analogous to a mail carrier slipping advertising
    material into sealed letters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Websites that use HTTPS are immune to this type of tampering, because the contents
    of each request and response are opaque to the ISP.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '***Government Agencies***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Government agencies snooping on your internet traffic might seem like the stuff
    of conspiracy theories, but plenty of evidence indicates this does indeed happen.
    The US *National Security Agency (NSA)* has successfully implemented man-in-middle-attacks
    to conduct surveillance. An internal presentation leaked by former NSA contractor
    Edward Snowden described how Brazil’s state-run oil producer Petrobras was spied
    on: the NSA obtained digital certificates for Google websites and then hosted
    its own look-alike sites that harvested user credentials while proxying traffic
    to Google. We don’t really know how widespread this type of program is, but it’s
    pretty unnerving to think about. (In case anyone from the government is reading
    this: actually, this type of program is good and keeps us safe, and the author
    of this book supports it wholeheartedly.)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should use HTTPS to ensure that communication from web browsers to your
    site is kept private and cannot be tampered with. HTTPS is HTTP sent over Transport
    Layer Security (TLS). A TLS conversation is initiated when a web server and user
    agent partake in a TLS handshake. During the TLS handshake, the browser offers
    a list of supported cipher suites it is able to support. Each cipher suite contains
    a key-exchange algorithm, a block cipher, and a message authentication code algorithm.
    The web server picks a cipher it supports and returns its digital certificate.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The browser then uses the public key attached to the digital certificate to
    encrypt a (randomly generated) TLS session identifier with the key-exchange algorithm,
    and sends it to the web server. Finally, when both parties possess the session
    identifier, they use it as the encryption/decryption key for subsequent messages
    sent back and forth, encrypted with the chosen block cipher. The authenticity
    of each data packet will be validated using the message authentication code algorithm.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Digital certificates are issued by a handful of certificate authorities, which
    will require you to demonstrate ownership of your chosen domain in the Domain
    Name System before issuing a certificate. By acting as a trusted third party between
    the browser and the website, certificate authorities prevent spoofed websites
    from presenting a fake certificate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Once you have obtained a certificate for your website, you need to serve content
    over HTTPS. This means configuring your web server to accept traffic over port
    443, telling it where to find the certificate and corresponding decryption key,
    and redirecting HTTP traffic on port 80 to HTTPS traffic on port 443\. Finally,
    you should instruct the browser not to send any sensitive data—for example, session
    cookies—in HTTP requests before the upgrade to HTTPS, by setting an HTTP Strict
    Transport Security policy.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to upgrade your web server technology fairly frequently, so you are
    certain you are using the most modern (and hence secure) cipher suites. Encryption
    standards are constantly being researched and enhanced, as older algorithms are
    compromised or discovered to be vulnerable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: While we are discussing the need to keep your web server up-to-date, you should
    take a broader look at how to test, secure, and manage any third-party applications
    you use to serve your website. That’s exactly what you will be doing in the next
    chapter!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
