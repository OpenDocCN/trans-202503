<html><head></head><body>
<div id="sbo-rt-content" class="calibre1">
 <div class="chapter" id="ch06">
  <div id="header0601" class="chapter">
   <h1 class="cn">
    <span class="page" id="p137">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rch06">
     6
    </a>
   </h1>
   <h1 class="ctfm">
    Using Hardware Timers
   </h1>
  </div>
  <div class="figure" id="ct06">
   <p class="fig">
    <img alt="" src="images/nsp-boxall502581-ct.jpg" class="calibre9"/>
   </p>
  </div>
  <p class="pf">
   <span>
   </span>
   We use timers to determine when we want a period of time to elapse before an action takes place, which can be incredibly useful. For example, you can set an interrupt to trigger when a timer reaches a certain value. Timers operate in the background; while the microcontroller runs your code, the timers are counting away.
  </p>
  <p class="calibre8">
   In this chapter, you’ll learn about:
  </p>
  <ul class="calibre10">
   <li class="blf">
    • Various timers in your ATmega328P-PU microcontroller
   </li>
   <li class="bl">
    • Timer overflow interrupts
   </li>
   <li class="bll">
    • Clear Timer on Compare Match interrupts
   </li>
  </ul>
  <p class="calibre8">
   I’ll show you how to run parts of code on a regular basis, create longer delays for repetitive actions, and examine the accuracy of internal timers. You’ll also learn a more efficient method of addressing individual bits inside a register.
  </p>
  <div class="chapter">
   <h2 class="ah" id="ah0801">
    <span class="page" id="p138">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0801">
     Introducing Timers
    </a>
   </h2>
   <p class="paft">
    Both our AVR microcontrollers have several timers, each of which contains an incrementing counting variable whose value is stored in a
    <i class="calibre5">
     counter register
    </i>
    . Once a counter reaches its maximum value, a bit in a register changes, and the counter resets to zero and starts over. Beyond using timers to trigger interrupts, you can use them to measure elapsed time with some clever arithmetic based on the incrementing variable’s progress.
   </p>
   <p class="calibre8">
    The ATmega328P-PU has three timers—TIMER0, TIMER1, and TIMER2—with their own counter registers. TIMER0 and TIMER2 are 8-bit counters with a maximum value of 255. TIMER1 is a 16-bit counter and has a maximum value of 65,535. The ATtiny85 also has timers, but as the ATmega is more versatile given its higher number of I/O pins, we’ll only discuss the latter in this chapter.
   </p>
   <p class="calibre8">
    Timers need a
    <i class="calibre5">
     clock source
    </i>
    to count accurate periods of time. A clock source is an oscillator circuit with an output that changes between high and low at a precise frequency. You can use either the internal or an external clock source. In this chapter we’ll use the microcontroller’s internal clock source, and I’ll show you how to use an external clock source when this is necessary in later chapters.
   </p>
   <p class="calibre8">
    Up to this point, our microcontrollers have been running at a speed of 1 MHz, and you can use their internal clock sources to drive the timers. We determine the period of time between each increment of the timer’s counter with this simple formula:
   </p>
   <div class="equation">
    <p class="eq">
     <i class="calibre5">
      T
     </i>
     = 1 /
     <i class="calibre5">
      f
     </i>
    </p>
   </div>
   <p class="pcon">
    where
    <i class="calibre5">
     f
    </i>
    is frequency in Hz and
    <i class="calibre5">
     T
    </i>
    is time in seconds. For example, we calculate the period at 1 MHz as
    <i class="calibre5">
     T
    </i>
    = 1 / 1,000,000, which results in a value of one millionth of a second, known as one microsecond.
   </p>
   <p class="calibre8">
    You can adjust the length of the period by using a
    <i class="calibre5">
     prescaler
    </i>
    , a number used to divide the frequency to increase the period time. You use the prescaler when you need to measure amounts of time that exceed the default duration of one of the timers. Five prescalers are available: 1, 8, 64, 256, and 1,024.
   </p>
   <p class="calibre8">
    To calculate a period altered by a prescaler, we use the following formula:
   </p>
   <div class="equation">
    <p class="eq">
     <i class="calibre5">
      T
     </i>
     = 1 / (1,000,000 /
     <i class="calibre5">
      p
     </i>
     )
    </p>
   </div>
   <p class="pcon">
    where
    <i class="calibre5">
     T
    </i>
    is time in seconds and
    <i class="calibre5">
     p
    </i>
    is the prescaler value. We can then determine the length of time before a given register resets. For example, to determine the length of time elapsed before reset for TIMER1, you would
    <span id="p139">
    </span>
    multiply the resulting value of
    <i class="calibre5">
     T
    </i>
    for your chosen prescaler by the maximum value of the TIMER1 counter (65,535). If your prescaler is 8, your time per period is 0.00008 seconds, so you’d multiply 65,535 by 0.00008 to get 0.52428 seconds. This means TIMER1 will reset after 0.52428 seconds.
   </p>
   <p class="calibre8">
    I’ve already calculated the values for the TIMER1 counter, for your convenience; they’re listed in
    <a class="url" href="nsp-boxall502581-0016.xhtml#tab0601">
     Table 6-1
    </a>
    .
   </p>
   <table id="tab0601" class="calibre13">
    <thead class="calibre14">
     <tr class="calibre15">
      <th colspan="5" class="calibre16">
       <p class="th1">
        <span class="calibre4">
         Table 6-1
        </span>
        : Prescaler Values for the TCCR1B Register at 1 MHz and Their Period Times
       </p>
      </th>
     </tr>
     <tr class="calibre15">
      <th scope="col" class="calibre16">
       <p class="tch">
        Prescaler type
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Period (s)
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Bit 2
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Bit 1
       </p>
      </th>
      <th scope="col" class="calibre16">
       <p class="tch">
        Bit 0
       </p>
      </th>
     </tr>
    </thead>
    <tbody class="calibre17">
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        /1 (none)
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0.000001
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        /8
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0.000008
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        1
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        /64
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0.000064
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        1
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        1
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        /256
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0.000256
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        1
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
     </tr>
     <tr class="calibre15">
      <td class="calibre18">
       <p class="td">
        /1024
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0.001024
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        1
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        0
       </p>
      </td>
      <td class="calibre18">
       <p class="td">
        1
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="calibre8">
    That’s enough theory for now. In the following projects we’ll put timers to work, to increase your understanding.
   </p>
   <p class="hd" id="pro27">
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro27">
     <span class="ccust1">
      Project 27: Experimenting with Timer Overflow and Interrupts
     </span>
    </a>
   </p>
   <p class="paft">
    In the first of our timer demonstrations, you’ll learn how to trigger an ISR once a timer counter overflows, using TIMER1. You’ll also experiment with prescalers to alter the length of time before the counter resets.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0801">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0801">
      The Hardware
     </a>
    </h3>
    <p class="paft">
     For this project, you’ll need the following hardware:
    </p>
    <ul class="calibre10">
     <li class="blf">
      • USBasp programmer
     </li>
     <li class="bl">
      • Solderless breadboard
     </li>
     <li class="bl">
      • ATmega328P-PU microcontroller
     </li>
     <li class="bl">
      • Jumper wires
     </li>
     <li class="bl">
      • Two LEDs
     </li>
     <li class="bll">
      • Two 560
      <span lang="el" xml:lang="el">
       Ω
      </span>
      resistors
     </li>
    </ul>
    <p class="calibre8">
     Assemble the circuit as shown in
     <a class="url" href="nsp-boxall502581-0016.xhtml#f06001">
      Figure 6-1
     </a>
     .
    </p>
    <div class="figure" id="f06001">
     <p class="fig">
      <span id="p140">
      </span>
      <img alt="Schematic diagram for Project 27" height="1200" src="images/nsp-boxall502581-f06001.jpg" width="1070" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 6-1:
       </span>
       Schematic for
       <a class="url" href="nsp-boxall502581-0016.xhtml#pro27">
        Project 27
       </a>
      </p>
     </div>
    </div>
    <p class="calibre8">
     With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard in the same way you have for the previous projects. Once completed, keep your circuit together, as you’ll use it for the
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro28">
      next project
     </a>
     as well.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0802">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0802">
      The Code
     </a>
    </h3>
    <p class="paft">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 27
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 6
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . The toolchain should compile the program file and upload the data to the microcontroller as usual. At this point the LED connected to PB0 should blink rapidly, and the LED connected to PB1 should quickly flicker on and off about every half-second (every 0.52428 seconds, to be exact!).
    </p>
    <p class="calibre8">
     Let’s see how this works. Open the
     <i class="calibre5">
      main.c
     </i>
     file for Project 27:
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 27 - Experimenting with Timer Overflows and Interrupts
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl2f">
      <span id="p141">
      </span>
      <!--<ccust1>1</ccust1>-->
      ❶ #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>2</ccust1>-->
      ❷ ISR(TIMER1_OVF_vect)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Code to be executed when an interrupt is triggered from TIMER1 overflow.
     </p>
     <p class="cl">
      // For this example, quickly blink LED on PB1.
     </p>
     <p class="cl">
      PORTB = 0b00000010;
     </p>
     <p class="cl">
      _delay_ms(5);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initOVI()
     </p>
     <p class="cl">
      // Set up overflow interrupt and TIMER1
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ TCCR1B = 0b00000010; // Set CS10 and CS11 for /8 prescaler
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ TIMSK1 = 0b00000001;  // Turn on TIMER1 interrupt on overflow
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ sei();                // Turn on global interrupts
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB = 0b11111111;    // Set PORTB register as outputs
     </p>
     <p class="cl">
      initOVI();            // Set up overflow interrupt and TIMER1
     </p>
     <p class="clf">
      for(;;)               // Do something (such as blink LED on PB0)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     This code includes the function
     <code class="calibre23">
      initOVI()
     </code>
     to initialize TIMER1 for use. First, we include the library for interrupts
     <!--<ccust1>1</ccust1>-->
     ❶ and define the timer operations
     <!--<ccust1>2</ccust1>-->
     ❷—this is the code that runs when the timer resets. We then set the prescaler to 8 by setting the second bit of the TCCR1B register
     <!--<ccust1>3</ccust1>-->
     ❸. This causes the TIMER1 register to reset every 0.52428 seconds. Next, we set the TIMSK1 register with 1 as the first bit
     <!--<ccust1>4</ccust1>-->
     ❹ to enable an interrupt to be called every time the TIMER1 counter overflows and resets to initialize the timer operations we defined earlier, and call
     <code class="calibre23">
      sei()
     </code>
     to enable interrupts
     <!--<ccust1>5</ccust1>-->
     ❺.
    </p>
    <p class="calibre8">
     Once operating, the LED should blink on and off as instructed in
     <code class="calibre23">
      int main(void)
     </code>
     , and the TIMER1 counter will count away at 125 kHz (remember, our clock speed is 1 MHz, and we’re using a prescaler of 8), so each counter increment takes 0.000008 seconds. With such a tiny length of time for each count, it only takes 0.52428 seconds to count from 0 to 65,535, at which point the TIMER1 counter overflows and the code calls the interrupt code
     <!--<ccust1>2</ccust1>-->
     ❷, which blinks the other LED briefly. TIMER1 resets to zero and starts counting again.
    </p>
    <p class="calibre8">
     <span id="p142">
     </span>
     Though this code sets the prescaler to 8 using the TCCR1B register, you can also select other prescalers by setting bits 2, 1, and 0 of the register using the values shown in
     <a class="url" href="nsp-boxall502581-0016.xhtml#tab0601">
      Table 6-1
     </a>
     . Spend some time changing the bits for the TCCR1B register with your
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro27">
      Project 27
     </a>
     hardware to experiment with the way this impacts the timing.
    </p>
    <p class="calibre8">
     In the
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro28">
      next project
     </a>
     , I’ll show you how to run a section of code on a recurring, regular basis.
    </p>
    <p class="hd" id="pro28">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro28">
      <span class="ccust1">
       Project 28: Using a CTC Timer for Repetitive Actions
      </span>
     </a>
    </p>
    <p class="paft">
     <i class="calibre5">
      Clear Timer on Compare Match (CTC)
     </i>
     is a different method of timing that calls an ISR once a timer’s counter has reached a certain value, then resets the timer to zero and starts it counting again. The CTC timing mode is useful when you want to run a section of code on a recurring basis.
    </p>
    <p class="calibre8">
     In this project, you’ll learn how to trigger an ISR every time a counter reaches 15 seconds, again using TIMER1. To determine the duration value, first calculate the number of elapsed periods per second for the timer, using the values in
     <a class="url" href="nsp-boxall502581-0016.xhtml#tab0601">
      Table 6-1
     </a>
     . We’ll use the 1,024 prescaler (if you need a longer duration, you can use an appropriate prescaler). This gives us 14,648 periods (rounded down), to which we add 1 to account for the time required for the timer to be reset back to zero. Our code should now check the TIMER1 counter value. Once it reaches 14,649, the code calls the ISR and then resets the counter to zero.
    </p>
    <p class="calibre8">
     Use the same hardware for this project as for
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro27">
      Project 27
     </a>
     . With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard in the same way you have for the previous projects. Again, keep the circuit together when you’re done so you can use it in the
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro29">
      next project
     </a>
     .
    </p>
    <p class="calibre8">
     Open a terminal window, navigate to the
     <i class="calibre5">
      Project 28
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 6
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once the project’s code has been uploaded to the microcontroller the LED connected to PB0 should start to blink rapidly, and the LED connected to PB1 should briefly turn on and off every 15 seconds.
    </p>
    <p class="calibre8">
     Let’s see how this works. Open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro28">
      Project 28
     </a>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 28 - Using a CTC Timer for Repetitive Actions
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ ISR(TIMER1_COMPA_vect)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Code to be executed when an interrupt is triggered from TIMER1 overflow.
     </p>
     <p class="cl">
      // For this example, quickly blink LED on PB1.
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ TCNT1 = 0;
     </p>
     <p class="cl">
      PORTB = 0b00000010;
     </p>
     <p class="cl">
      _delay_ms(10);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      <span id="p143">
      </span>
      // Reset TIMER1 to zero, so counting can start again.
     </p>
     <p class="cl">
      TCNT1 = 0;
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void initCTC()
     </p>
     <p class="cl">
      // Set up CTC interrupt and TIMER1
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ OCR1A = 14649;       // Number of periods to watch for: 14,649
     </p>
     <p class="cl">
      // Turn on CTC mode and set CS12 and CS10 for /1024 prescaler
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ TCCR1B = 0b00000101;
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ TIMSK1 = 0b00000010; // Turn on timer compare interrupt
     </p>
     <p class="cl">
      sei();               // Turn on global interrupts
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB = 0b11111111;   // Set PORTB register as outputs
     </p>
     <p class="cl">
      initCTC();           // Set up overflow interrupt and TIMER1
     </p>
     <p class="cl">
      for(;;)              // Do something (such as blink LED on PB0)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     This code includes an
     <code class="calibre23">
      initCTC()
     </code>
     function
     <!--<ccust1>3</ccust1>-->
     ❸, which we use to set up our timer. We tell the code to run the ISR when the timer reaches the value 14,649 by setting OCR1A to
     <code class="calibre23">
      14649
     </code>
     <!--<ccust1>4</ccust1>-->
     ❹. Then we set the prescaler to 1,024
     <!--<ccust1>5</ccust1>-->
     ❺ and turn on the timer compare interrupt feature
     <!--<ccust1>6</ccust1>-->
     ❻.
    </p>
    <p class="calibre8">
     The main code begins by running the
     <code class="calibre23">
      initCTC()
     </code>
     function, then merrily blinks the LED connected to PB0. Once the TIMER1 counter reaches 14,649 (our 15-second mark), the ISR code
     <!--<ccust1>1</ccust1>-->
     ❶ will run. Inside the ISR, the code first resets TIMER1 to zero
     <!--<ccust1>2</ccust1>-->
     ❷, then blinks the LED connected to PB1.
    </p>
    <p class="calibre8">
     You should now understand how to execute an ISR after a set period of time. Experiment with prescalers and values for some practice, then we’ll move on to using CTC for longer delays in code.
    </p>
    <p class="hd" id="pro29">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro29">
      <span class="ccust1">
       Project 29: Using CTC Timers for Repetitive Actions with Longer Delays
      </span>
     </a>
    </p>
    <p class="paft">
     Sometimes you’ll want to set up a recurring event over a longer period than the one in
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro28">
      Project 28
     </a>
     —perhaps every 15 minutes rather than every 15 seconds. Due to the size of the OCR1A register (65,535) we can’t just enter a very large number to count up to a long period of time and expect the CTC timer to work, so we need to use a small workaround. We set up a CTC timer as per
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro28">
      Project 28
     </a>
     that triggers the ISR once per second. We then count those seconds, and when the desired delay has elapsed, we call a function to execute the required code.
    </p>
    <p class="calibre8">
     <span id="p144">
     </span>
     In more detail, to set up a longer period between recurring events, we do the following:
    </p>
    <ol class="calibre10">
     <li class="blf">
      1. Use a global variable to store the target delay value we wish to use for our period (measured in seconds).
     </li>
     <li class="bl">
      2. Use another global variable to store the number of elapsed seconds in the delay.
     </li>
     <li class="bl">
      3. Set the CTC timer to watch for durations of one second.
     </li>
     <li class="bll">
      4. Have the ISR (called every second) add one to the elapsed seconds variable, then check that it has reached the target delay value—and if so, execute the required code.
     </li>
    </ol>
    <p class="calibre8">
     With this approach you can implement a variation of multitasking, as you’ll see in the following project.
    </p>
    <p class="calibre8">
     Use the same hardware as in
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro28">
      Project 28
     </a>
     . With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard in the same way you have for the previous projects.
    </p>
    <p class="calibre8">
     Next, open a terminal window, navigate to the
     <i class="calibre5">
      Project 29
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 6
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . The tool chain should compile the program file and then upload the data to the microcontroller. At this point the LED connected to PB0 should blink rapidly, and the LED connected to PB1 should briefly turn on and off every second.
    </p>
    <p class="calibre8">
     Let’s see how this works. Open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro29">
      Project 29
     </a>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 29 - Using CTC Timers for Repetitive Actions with Longer Delays
     </p>
     <p class="cl">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="cl2f">
      <!--<ccust1>1</ccust1>-->
      ❶ uint16_t target = 1;
     </p>
     <p class="cl">
      // Interval in seconds between running function "targetFunction"
     </p>
     <p class="cl2">
      <!--<ccust1>2</ccust1>-->
      ❷ uint16_t targetCount = 0;
     </p>
     <p class="cl">
      // Used to track number of seconds for CTC counter resets
     </p>
     <p class="cl2f">
      <!--<ccust1>3</ccust1>-->
      ❸ void targetFunction()
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Do something once target duration has elapsed
     </p>
     <p class="cl">
      PORTB = 0b00000010;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      ISR(TIMER1_COMPA_vect)
     </p>
     <p class="cl">
      { // Code to be executed when an interrupt is triggered from CTC
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ targetCount++;       // Add one to targetCount
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ if (targetCount == target)
     </p>
     <p class="cl">
      // If required period of time has elapsed
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ TCNT1 = 0;        // Reset TIMER1 to zero
     </p>
     <p class="cl">
      <!--<ccust1>7</ccust1>-->
      ❼ targetFunction(); // Do something
     </p>
     <p class="cl">
      <span id="p145">
      </span>
      <!--<ccust1>8</ccust1>-->
      ❽ targetCount = 0;  // Reset targetCount to zero
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initCTC()
     </p>
     <p class="cl">
      // Set up CTC interrupt and TIMER1
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      OCR1A = 15625;       // Number of periods to watch for - 15625 = 1 second
     </p>
     <p class="cl">
      // Turn on CTC mode and set CS10 and CS11 for /64 prescaler
     </p>
     <p class="cl">
      TCCR1B = 0b00000011;
     </p>
     <p class="cl">
      TIMSK1 = 0b00000010; // Turn on timer compare interrupt
     </p>
     <p class="cl">
      sei();               // Turn on global interrupts
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      DDRB = 0b11111111;   // Set PORTB register as outputs
     </p>
     <p class="cl">
      initCTC();           // Set up overflow interrupt and TIMER1
     </p>
     <p class="cl">
      for(;;)              // Do something (blink LED on PB0)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      PORTB = 0b00000001;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      PORTB = 0b00000000;
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     At this stage you should be quite familiar with most of this code, such as the
     <code class="calibre23">
      ISR()
     </code>
     function, but there are a few new components. First, there are two new global variables,
     <code class="calibre23">
      uint16_t target
     </code>
     <!--<ccust1>1</ccust1>-->
     ❶ and
     <code class="calibre23">
      uint16_t targetCount
     </code>
     <!--<ccust1>2</ccust1>-->
     ❷. We set
     <code class="calibre23">
      target
     </code>
     to the number of seconds to wait while the required code runs
     <!--<ccust1>3</ccust1>-->
     ❸. In this example
     <code class="calibre23">
      target
     </code>
     is set to 1, but you can set it to anything up to 32,767 (for 546.116 . . . minutes), as this is the highest value that can be stored in a 16-bit integer.
    </p>
    <p class="calibre8">
     The ISR uses the variable
     <code class="calibre23">
      targetCount
     </code>
     to accumulate elapsed seconds, as every time the code calls the ISR (once per second), it increments
     <code class="calibre23">
      targetCount
     </code>
     by 1
     <!--<ccust1>4</ccust1>-->
     ❹. When the code calls the ISR, it checks to see if
     <code class="calibre23">
      target Count
     </code>
     matches
     <code class="calibre23">
      target
     </code>
     <!--<ccust1>5</ccust1>-->
     ❺. If so, the code resets TIMER1 to zero
     <!--<ccust1>6</ccust1>-->
     ❻, then runs the required code via the function
     <code class="calibre23">
      targetFunction()
     </code>
     <!--<ccust1>7</ccust1>-->
     ❼, and finally resets
     <code class="calibre23">
      targetCount
     </code>
     back to zero
     <!--<ccust1>8</ccust1>-->
     ❽, allowing the process to start again.
    </p>
    <p class="calibre8">
     Although our example runs the
     <code class="calibre23">
      targetFunction()
     </code>
     code once per second, remember that you can easily increase the duration by changing the value for
     <code class="calibre23">
      target
     </code>
     . For example, to run
     <code class="calibre23">
      targetFunction()
     </code>
     every 5 minutes, change
     <code class="calibre23">
      target
     </code>
     to 300 (5 minutes × 60 seconds = 300 seconds).
    </p>
    <p class="calibre8">
     Now that you’ve had some opportunities to experiment with the AVR’s ATmega’s timers, I’d like to briefly discuss the accuracy of the internal timers themselves.
    </p>
   </div>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0802">
    <span class="page" id="p146">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0802">
     Examining the Accuracy of the Internal Timer
    </a>
   </h2>
   <p class="paft">
    You may be wondering how accurately the internal timer can keep time. You can easily check this by running the
    <a class="url" href="nsp-boxall502581-0016.xhtml#pro29">
     Project 29
    </a>
    code (with a one-second interval) and measuring the results with a digital storage oscilloscope, as shown in
    <a class="url" href="nsp-boxall502581-0016.xhtml#f06002">
     Figure 6-2
    </a>
    .
   </p>
   <div class="figure" id="f06002">
    <p class="fig">
     <img alt="Displaying the outputs from Project 29 in two channels of a digital storage oscilloscope" height="676" src="images/nsp-boxall502581-f06002.jpg" width="1200" class="calibre11"/>
    </p>
    <div class="chapter">
     <p class="figh">
      <span class="calibre4">
       Figure 6-2:
      </span>
      Measuring the outputs of
      <a class="url" href="nsp-boxall502581-0016.xhtml#pro29">
       Project 29
      </a>
      using a DSO
     </p>
    </div>
   </div>
   <p class="calibre8">
    The blinking LED on PB0 is connected to channel 1 (the upper signal) of the DSO, while the LED on PB2 that
    <code class="calibre23">
     targetFunction()
    </code>
    controls is connected to channel 2 (the lower signal). You should see the signal rise and fall as the LED on PB0 turns on then off every 100 milliseconds. The signal for the first LED stays low while the code controlling the second LED on PB1 operates, as the microcontroller cannot operate two things at the same time. After the one second has elapsed, the other LED on PB0 connected to channel 1 turns on and off as directed by
    <code class="calibre23">
     targetFunction()
    </code>
    , and the whole process repeats.
   </p>
   <p class="calibre8">
    In this case the DSO has measured the frequency for the second LED as 1.018 Hz, or 1.018 times per second—this is awfully close to the required 1 second. Considering we’re not using any external timing hardware on the circuit, this is a good outcome. However, if you’d like to run much longer delay periods, you’ll need to take such slight variances into account. For example, that 0.018 Hz imbalance from 1 second can equate to 5.4 seconds over a 5-minute period (the actual time of 5.4 seconds is calculated by multiplying 0.018 Hz by 300 seconds). Keep this in mind in your future timing projects.
   </p>
  </div>
  <div class="chapter">
   <h2 class="ah" id="ah0803">
    <span class="page" id="p147">
    </span>
    <a class="xref" href="nsp-boxall502581-0008.xhtml#rah0803">
     Addressing Registers with Bitwise Operations
    </a>
   </h2>
   <p class="paft">
    From the beginning of this book, we’ve been addressing various registers using the binary number format. For example, with an ATmega328P-PU, we use the following two lines of code to set pin PB0 as an output and turn it on:
   </p>
   <div class="codeline">
    <p class="clf">
     DDRB = 0b11111111;  // Set PORTB to outputs
    </p>
    <p class="cl">
     . . .
    </p>
    <p class="cll">
     PORTB = 0b00000001; // Set PB0 on
    </p>
   </div>
   <p class="calibre8">
    This method has worked well for us so far, but it requires us to consider every bit in the register every time we address one or more bits inside the entire register. In this section I’ll show you how to use bitwise operations, which allow us to change just a particular bit (or bits) in a register, leaving the others as they were. This will be useful for future projects in the book and beyond, as it allows you to easily set individual or multiple bits without worrying about changing all the bits in a register at once.
   </p>
   <div class="chapter">
    <h3 class="bh" id="bh0803">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0803">
      Addressing Individual Bits in a Register
     </a>
    </h3>
    <p class="paft">
     By default, all bits in a register are set to 0 (low, or off) when we reset or turn on the microcontroller. We then set bits to 1 (high, or on) or 0 when required, using the following operations:
    </p>
    <div class="list">
     <p class="ulh">
      Turning a bit to high
     </p>
     <ul class="calibre10">
      <li class="ul">
       Use the following code to turn a bit to high (on) by setting it to 1:
       <div class="codeline">
        <p class="cls">
         <code class="i1">
          registername
         </code>
         |= (1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         );
        </p>
       </div>
       <p class="pcust1">
        For example, to turn on the output from PORTB’s PB7, you would use the following line, since 7 is the bit number in the PORTB register matching pin PB7:
       </p>
       <div class="codeline">
        <p class="cls">
         PORTB |= (1 &lt;&lt; 7);
        </p>
       </div>
       <p class="pcust1">
        This allows you to turn on PB7 without needing to concern yourself with the status of the other bits in the register.
       </p>
      </li>
      <li class="ulh1">
       Toggling a bit between high and low
      </li>
      <li class="ul">
       To
       <i class="calibre5">
        toggle
       </i>
       a bit is to change it from its current state to the alternate state (from off to on, or vice versa). Use the following code to do so:
       <div class="codeline">
        <p class="cls">
         <code class="i1">
          registername
         </code>
         ^= (1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         ); // Toggle bit "bitname"
        </p>
       </div>
       <p class="pcust1">
        For example, to toggle the output from PORTB’s PB3 you would use the following line, as the bit number in the PORTB register matching pin PB3 is 3:
       </p>
       <div class="codeline">
        <p class="cls">
         <span id="p148">
         </span>
         PORTB ^= (1 &lt;&lt; 3); // Toggle bit PB3
        </p>
       </div>
       <p class="pcust1">
        To demonstrate this, you can blink an LED connected to PB3 with a 250 ms delay by using the following two lines in your code’s
        <code class="calibre23">
         for (;;)
        </code>
        loop:
       </p>
       <div class="codeline">
        <p class="cl3f">
         PORTB ^= (1 &lt;&lt; 3); // Toggle PB3
        </p>
        <p class="cl3l">
         _delay_ms(250);    // Wait 250 milliseconds
        </p>
       </div>
       <p class="pcust1">
        By using bitwise operations you also save space, as the LED blinking example only requires two lines of code instead of four.
       </p>
      </li>
      <li class="ulh1">
       Turning a bit to low
      </li>
      <li class="ul">
       Use the following code to turn a bit to low (off) by setting it to 0:
       <div class="codeline">
        <p class="cls">
         <code class="i1">
          registername
         </code>
         &amp;= ~(1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         ); // Set bit "bitname" to 0
        </p>
       </div>
       <p class="pcust1">
        For example, to turn off the output from PORTB’s PB7 you would use the following line, as 7 is the bit number in the PORTB register matching pin PB7:
       </p>
       <div class="codeline">
        <p class="cls">
         PORTB &amp;= ~(1 &lt;&lt; 7);
        </p>
       </div>
      </li>
     </ul>
    </div>
    <p class="calibre8">
     Using bitwise operations in this way is more efficient than the binary number format we used to work with register bits earlier. However, you can improve on this method even further by using the name of the register bit instead of the number, which makes it easier to determine which bit is being altered. For example, say you want to set bit 0 of TIMSK1 on to enable the TIMER1 overflow interrupt used in
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro27">
      Project 27
     </a>
     . Instead of using
     <code class="calibre23">
      TIMSK1 = 0b00000001
     </code>
     , you can use
     <code class="calibre23">
      TIMSK1 |= (1 &lt;&lt; TOIE1)
     </code>
     .
    </p>
    <p class="calibre8">
     To determine which register bit name to use for the corresponding bit number (
     <code class="calibre23">
      TOIE1
     </code>
     rather than
     <code class="calibre23">
      0b00000001
     </code>
     in the previous example), check the data sheets for your microcontrollers. If you have not already done so, you can download the full data sheets in Adobe PDF format from the Microchip website:
    </p>
    <p class="pcust1">
     <span class="hemb">
      ATtiny85 data sheet
     </span>
     <a class="url-i" href="https://www.microchip.com/wwwproducts/en/ATtiny85/">
      https://www.microchip.com/wwwproducts/en/ATtiny85/
     </a>
    </p>
    <p class="pcust1">
     <span class="hemb">
      ATmega data sheet
     </span>
     <a class="url-i" href="https://www.microchip.com/wwwproducts/en/ATmega328p/">
      https://www.microchip.com/wwwproducts/en/ATmega328p/
     </a>
    </p>
    <p class="calibre8">
     You can then learn the bit names to match a given register, such as the TIMSK1 register, which appears in section 16.11.8 of the ATmega328P-PU’s data sheet, as shown in
     <a class="url" href="nsp-boxall502581-0016.xhtml#f06003">
      Figure 6-3
     </a>
     .
    </p>
    <div class="figure" id="f06003">
     <p class="fig">
      <img alt="Image of the TIMSK1 register with bit labels included" height="142" src="images/nsp-boxall502581-f06003.jpg" width="1200" class="calibre11"/>
     </p>
     <div class="chapter">
      <p class="figh">
       <span class="calibre4">
        Figure 6-3:
       </span>
       The ATmega328P-PU TIMSK1 register
      </p>
     </div>
    </div>
    <p class="calibre8">
     <span id="p149">
     </span>
     Now that you can address a single bit inside a register, next I’ll show you how to address two or more bits in the same register without affecting other bits.
    </p>
   </div>
   <div class="chapter">
    <h3 class="bh" id="bh0804">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rbh0804">
      Addressing Multiple Bits in a Register
     </a>
    </h3>
    <p class="paft">
     You can also change more than one bit in a single register at the same time (again, without worrying about the bits that you’re not changing) using bitwise operations. Note, however, that you have to perform the same operation on all the bits—for example, you can turn three bits on in one line, but you can’t turn two on and one off in one line. If you need to do the latter, use the binary number method instead. Here’s how this works:
    </p>
    <div class="list">
     <p class="ulh">
      Turning multiple bits high
     </p>
     <ul class="calibre10">
      <li class="ul">
       To turn two bits on at once, use the following code:
       <div class="codeline">
        <p class="cls">
         <code class="i1">
          registername
         </code>
         |= (1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         )|(1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         );
        </p>
       </div>
       <p class="pcust1">
        For example, to turn on the output from PORTB’s PB0 and PB7, you could use:
       </p>
       <div class="codeline">
        <p class="cls">
         PORTB |= (1 &lt;&lt; PORTB7)|(1 &lt;&lt; PORTB0);
        </p>
       </div>
       <p class="pcust1">
        You can add additional addressing to the same line. For example, you could turn on PB0, PB3, and PB7 as follows:
       </p>
       <div class="codeline">
        <p class="cls">
         PORTB |= (1 &lt;&lt; PORTB7)|(1 &lt;&lt; PORTB3)|(1 &lt;&lt; PORTB0);
        </p>
       </div>
       <p class="pcust1">
        You could use this method to address up to seven bits. If you want to change all bits, then use the usual
        <code class="calibre23">
         PORT
        </code>
        <code class="i1">
         x
        </code>
        function.
       </p>
      </li>
      <li class="ulh1">
       Toggling multiple bits between high and low
      </li>
      <li class="ul">
       To toggle multiple bits high or low at once, use the following code:
       <div class="codeline">
        <p class="cls">
         <code class="i1">
          registername
         </code>
         ^= (1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         )|(1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         );
        </p>
       </div>
       <p class="pcust1">
        For example, to toggle the output from PORTB’s PB0 and PB3 you could use:
       </p>
       <div class="codeline">
        <p class="cls">
         PORTB ^= (1 &lt;&lt; PORTB3)|(1 &lt;&lt; PORTB0);
        </p>
       </div>
       <p class="pcust1">
        Again, you can add additional addressing to the same line. For example, to toggle PB0, PB3, and PB7, you could use:
       </p>
       <div class="codeline">
        <p class="cl3f">
         PORTB ^= (1 &lt;&lt; PORTB7)|(1 &lt;&lt; PORTB3)|(1 &lt;&lt; PORTB0);
        </p>
       </div>
      </li>
      <li class="ulh1">
       Turning multiple bits low
      </li>
      <li class="ul">
       To turn multiple bits off at once, use the following code.
       <div class="codeline">
        <p class="cls">
         <span id="p150">
         </span>
         <code class="i1">
          registername
         </code>
         &amp;= ~(1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         )&amp;~(1 &lt;&lt;
         <code class="i1">
          bitname
         </code>
         );
        </p>
       </div>
       <p class="pcust1">
        In this case we use the
        <code class="calibre23">
         &amp;~
        </code>
        characters between the bracketed operations, rather than the pipe (
        <code class="calibre23">
         |
        </code>
        ) character. For example, to turn off the output from PORTB’s PB7 and PB0, you could use:
       </p>
       <div class="codeline">
        <p class="cls">
         PORTB &amp;= ~(1 &lt;&lt; PORTB7)&amp;~(1 &lt;&lt; PORTB0);
        </p>
       </div>
       <p class="ulpl">
        And to turn off PB0, PB3, and PB7 all at once you could use:
       </p>
       <div class="codeline">
        <p class="cl3l">
         PORTB &amp;= ~(1 &lt;&lt; PORTB7)&amp;~(1 &lt;&lt; PORTB3)&amp;~(1 &lt;&lt; PORTB0);
        </p>
       </div>
      </li>
     </ul>
    </div>
    <p class="calibre8">
     Now that we’ve reviewed all these bitwise operations for addressing registers, let’s see how we could use them to improve some of our earlier code.
    </p>
    <p class="hd" id="pro30">
     <a class="xref" href="nsp-boxall502581-0008.xhtml#rpro30">
      <span class="ccust1">
       Project 30: Experimenting with Overflow Timers Using Bitwise Operations
      </span>
     </a>
    </p>
    <p class="paft">
     This project has the same results as
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro27">
      Project 27
     </a>
     , but I’ve rewritten the code to take advantage of bitwise operations for addressing registers.
    </p>
    <p class="calibre8">
     Use the same hardware used in
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro27">
      Project 27
     </a>
     . With your circuit assembled, connect the USBasp to your microcontroller via the solderless breadboard in the usual way. Open a terminal window, navigate to the
     <i class="calibre5">
      Project 30
     </i>
     subfolder of this book’s
     <i class="calibre5">
      Chapter 6
     </i>
     folder, and enter the command
     <code class="b">
      make flash
     </code>
     . Once the code has been uploaded to the microcontroller the LED connected to PB0 should start to blink rapidly, and the LED connected to PB1 should quickly flicker on and off every 0.52428 seconds.
    </p>
    <p class="calibre8">
     To see how the updated code works, open the
     <i class="calibre5">
      main.c
     </i>
     file for
     <a class="url" href="nsp-boxall502581-0016.xhtml#pro30">
      Project 30
     </a>
     :
    </p>
    <div class="codeline">
     <p class="clf">
      // Project 30 - Experimenting with Overflow Timers Using Bitwise Operations
     </p>
     <p class="clf">
      #include &lt;avr/io.h&gt;
     </p>
     <p class="cl">
      #include &lt;avr/interrupt.h&gt;
     </p>
     <p class="cl">
      #include &lt;util/delay.h&gt;
     </p>
     <p class="clf">
      ISR(TIMER1_OVF_vect)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      // Code to be executed when an interrupt is triggered from TIMER1 overflow.
     </p>
     <p class="cl">
      // For this example, quickly blink LED on PB1.
     </p>
     <p class="cl">
      <!--<ccust1>1</ccust1>-->
      ❶ PORTB |= (1 &lt;&lt; PORTB1);          // PB1 on
     </p>
     <p class="cl">
      _delay_ms(5);
     </p>
     <p class="cl">
      <!--<ccust1>2</ccust1>-->
      ❷ PORTB &amp;= ~(1 &lt;&lt; PORTB1);         // PB1 off
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      void initOVI()
     </p>
     <p class="cl">
      // Set up overflow interrupt and TIMER1
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>3</ccust1>-->
      ❸ TCCR1B |= (1 &lt;&lt; CS11);           // Set prescaler to /8
     </p>
     <p class="cl">
      <!--<ccust1>4</ccust1>-->
      ❹ TIMSK1 |= (1 &lt;&lt; TOIE1);          // Enable TIMER1 overflow interrupts
     </p>
     <p class="cl">
      sei();                           // Turn on global interrupts
     </p>
     <p class="cl">
      }
     </p>
     <p class="clf">
      <span id="p151">
      </span>
      int main(void)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>5</ccust1>-->
      ❺ DDRB |= (1 &lt;&lt; DDB0)|(1 &lt;&lt; DDB1); // Set PORTB pins 0 and 1 as outputs
     </p>
     <p class="cl">
      initOVI();                       // Set up overflow interrupt and TIMER1
     </p>
     <p class="clf">
      for(;;)                          // Do something (blink LED on PB0)
     </p>
     <p class="cl">
      {
     </p>
     <p class="cl">
      <!--<ccust1>6</ccust1>-->
      ❻ PORTB ^=(1 &lt;&lt; PORTB0);        // Toggle PB0
     </p>
     <p class="cl">
      _delay_ms(100);
     </p>
     <p class="cl">
      }
     </p>
     <p class="cl">
      return 0;
     </p>
     <p class="cll">
      }
     </p>
    </div>
    <p class="calibre8">
     In this code, the LED blinks on and off in turn when the code calls the ISR
     <!--<ccust1>1</ccust1><ccust1>2</ccust1>-->
     ❶❷. When setting the prescaler, we only need to set
     <code class="calibre23">
      CS11
     </code>
     to 1
     <!--<ccust1>3</ccust1>-->
     ❸, as
     <code class="calibre23">
      CS10
     </code>
     remains 0 for a prescaler of 8, as you’ll recall from
     <a class="url" href="nsp-boxall502581-0016.xhtml#tab0601">
      Table 6-1
     </a>
     . (Remember, bits are 0 by default.)
    </p>
    <p class="calibre8">
     We enable the TIMER1 overflow interrupts by setting bit
     <code class="calibre23">
      TOIE1
     </code>
     of the TIMSK1 register to 1
     <!--<ccust1>4</ccust1>-->
     ❹, then set the PB0 and PB1 pins of PORTB to outputs for our LEDs
     <!--<ccust1>5</ccust1>-->
     ❺. Finally, we toggle PB0 on and off in order to flash the LED
     <!--<ccust1>6</ccust1>-->
     ❻.
    </p>
    <p class="calibre8">
     I encourage you to spend some time getting comfortable with the registers we have used so far in the book—PORTB, DDRB, and so on—and experimenting with previous projects to familiarize yourself with bitwise methods of addressing registers. These methods will come in handy in the
     <a class="url" href="nsp-boxall502581-0017.xhtml#ch07">
      next chapter
     </a>
     , as we begin using pulse-width modulation to experiment with LEDs, motors, and more.
    </p>
   </div>
  </div>
 </div>
</div></body></html>