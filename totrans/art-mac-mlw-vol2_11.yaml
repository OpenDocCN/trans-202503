- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 9 MUTING AND AUTHORIZATION EVENTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9 静音与授权事件
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In the previous chapter, I introduced Apple’s Endpoint Security and its notification
    events. In this chapter, I move into more advanced topics, such as muting, mute
    inversion, and authorization events.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我介绍了 Apple 的 Endpoint Security 及其通知事件。在本章中，我将深入探讨更高级的主题，例如静音、静音反转和授权事件。
- en: '*Muting* instructs Endpoint Security to withhold the delivery of certain events,
    such as those generated from chatty system processes. Conversely, *mute inversion*
    gives us the ability to create focused tools that, for example, subscribe solely
    to events from a specific process or only those related to the access of a few
    directories. Lastly, Endpoint Security’s authorization capabilities offer a mechanism
    to prevent undesirable actions altogether.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*静音* 指示 Endpoint Security 阻止某些事件的传递，例如那些由嘈杂的系统进程生成的事件。相反，*静音反转* 使我们能够创建专注的工具，例如仅订阅来自特定进程的事件或仅订阅与少数几个目录访问相关的事件。最后，Endpoint
    Security 的授权功能提供了一种机制，可以完全防止不希望发生的操作。'
- en: You’ll find the majority of the code snippets presented in this chapter in the
    *ESPlayground* project introduced in [Chapter 8](chapter8.xhtml). For each topic
    covered here, I’ll point to the part of this project where the relevant code resides,
    as well as how to execute it via command line arguments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的大多数代码片段都可以在 [第 8 章](chapter8.xhtml) 中介绍的 *ESPlayground* 项目中找到。对于这里涵盖的每个主题，我将指出该项目中相关代码所在的部分，以及如何通过命令行参数执行它。
- en: '### Muting'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### 静音'
- en: All event monitoring implementations risk facing an overwhelming deluge of events.
    For example, file I/O events occur constantly as part of normal system activity,
    and file monitors may generate so much data that finding events tied to malicious
    processes becomes quite difficult. One solution is to mute irrelevant processes
    or paths. For example, you’ll likely want to ignore file I/O events involving
    the temporary directory or originating from certain chatty, legitimate operating
    system processes (such as the Spotlight indexing service), as these events occur
    almost constantly and are rarely useful for malware detection.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件监控实现都面临着大量事件涌入的风险。例如，文件 I/O 事件在正常的系统活动中不断发生，文件监控程序可能会生成大量数据，导致很难找出与恶意进程相关的事件。一种解决方案是静音不相关的进程或路径。例如，您可能希望忽略涉及临时目录的文件
    I/O 事件，或来自某些嘈杂的合法操作系统进程（如 Spotlight 索引服务）的事件，因为这些事件几乎不断发生，并且很少对恶意软件检测有用。
- en: 'Luckily for us, Endpoint Security provides a flexible and robust muting mechanism.
    Its es_mute_path function will suppress events either from a specified process
    or that match a specified path. The function takes three parameters—a client;
    a path to a process, directory, or file; and a type:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Endpoint Security 提供了一个灵活且强大的静音机制。它的 es_mute_path 函数将抑制来自指定进程或与指定路径匹配的事件。该函数有三个参数——一个客户端；一个指向进程、目录或文件的路径；以及一个类型：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The mute path type can be one of the four values found in the enumeration of
    type es_mute_path_type_t in *ESTypes.h*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 静音路径类型可以是 *ESTypes.h* 中 es_mute_path_type_t 枚举类型中的四个值之一：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The types ending in PREFIX tell Endpoint Security that the path provided to
    es_mute_path is a prefix to a longer path. For example, you could use the ES_MUTE_PATH_TYPE_TARGET_PREFIX
    option to mute all file I/O events originating from a certain directory. On the
    other hand, if the mute path type ends in LITERAL, the path has to match exactly
    for events to be muted.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以 PREFIX 结尾的类型告诉 Endpoint Security 提供的路径是一个较长路径的前缀。例如，您可以使用 ES_MUTE_PATH_TYPE_TARGET_PREFIX
    选项来静音来自某个目录的所有文件 I/O 事件。另一方面，如果静音路径类型以 LITERAL 结尾，则路径必须完全匹配，才能静音事件。
- en: Use the initial two values of the enumeration, ES_MUTE_PATH_TYPE_PREFIX and
    ES_MUTE_PATH_TYPE_LITERAL, when you want to mute the path of the process responsible
    for triggering the Endpoint Security event. For example, [Listing 9-1](chapter9.xhtml#Lis9-1)
    shows a snippet from the mute function (in the *ESPlayground* project’s *mute.m*
    file) that instructs Endpoint Security to mute all events originating from *mds_stores*,
    a very noisy Spotlight daemon responsible for managing macOS’s metadata indexes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要静音负责触发 Endpoint Security 事件的进程路径时，请使用枚举中的前两个值，ES_MUTE_PATH_TYPE_PREFIX 和
    ES_MUTE_PATH_TYPE_LITERAL。例如，[清单 9-1](chapter9.xhtml#Lis9-1) 显示了来自静音功能的代码片段（位于
    *ESPlayground* 项目的 *mute.m* 文件中），该代码指示 Endpoint Security 静音所有来源于 *mds_stores*
    的事件，*mds_stores* 是一个非常嘈杂的 Spotlight 守护进程，负责管理 macOS 的元数据索引。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 9-1: Muting events from the Spotlight service'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-1：静音来自 Spotlight 服务的事件
- en: After defining the path to the *mds_store* binary ❶, we invoke the es_mute_path
    API ❷, passing it an endpoint client (created previously via a call to es_new_client),
    the path to the *mds_stores* binary, and the ES_MUTE_PATH_TYPE_LITERAL enumeration
    value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了*mds_store*二进制文件的路径❶之后，我们调用`es_mute_path` API❷，传递给它一个端点客户端（之前通过调用`es_new_client`创建的），*mds_stores*二进制文件的路径，以及`ES_MUTE_PATH_TYPE_LITERAL`枚举值。
- en: If you instead (or also) want to mute the targets of the events (for example,
    in a file monitor, the paths to files being created or deleted), use either ES_MUTE_PATH_TYPE_TARGET_PREFIX
    or ES_MUTE_PATH_TYPE_TARGET_LITERAL. For instance, if we wanted a file monitor
    to mute all file events involving the temporary directory associated with the
    user context under which the monitor process is running, we’d use the code in
    [Listing 9-2](chapter9.xhtml#Lis9-2).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望（或同时）将事件的目标静音（例如，在文件监控中，静音被创建或删除的文件路径），可以使用 `ES_MUTE_PATH_TYPE_TARGET_PREFIX`
    或 `ES_MUTE_PATH_TYPE_TARGET_LITERAL`。例如，如果我们希望文件监控静音所有涉及到与监控进程运行的用户上下文关联的临时目录的文件事件，我们可以在[示例
    9-2](chapter9.xhtml#Lis9-2)中使用以下代码。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-2: Muting all events in the current user’s temporary directory'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-2：静音当前用户的临时目录中的所有事件
- en: We retrieve the temporary directory with the NSTemporaryDirectory function and
    then resolve any symbolic links in this path (for example, resolving */var* to
    */private/var*) with the realpath function ❶. Next, we mute all file I/O events
    whose target paths fall within this directory ❷.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`NSTemporaryDirectory`函数获取临时目录，然后使用`realpath`函数❶解析该路径中的任何符号链接（例如，将*/var*解析为*/private/var*）。接下来，我们静音所有目标路径位于该目录内的文件I/O事件❷。
- en: 'Let’s compile and run the *ESPlayground* project from the terminal with root
    privileges. When we launch the Calculator app via Spotlight, it should print out
    various Endpoint Security events, such as file open and close events:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从终端以根权限编译并运行*ESPlayground*项目。当我们通过Spotlight启动计算器应用程序时，它应该会打印出各种Endpoint Security事件，例如文件打开和关闭事件：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But because we specified the -mute flag, we won’t receive any events originating
    from the *mds_stores* daemon or from within the root user’s temporary directory.
    We can confirm this fact by simultaneously running a file monitor that implements
    no muting. Notice that this time, we receive such events:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但是由于我们指定了`-mute`标志，我们不会接收到任何来自*mds_stores*守护进程或来自根用户临时目录中的事件。我们可以通过同时运行一个没有静音实现的文件监控来确认这一点。请注意，这次我们收到了这样的事件：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Endpoint Security has several other muting-related APIs worth mentioning. The
    es_mute_process function provides another way to mute events from a specific process:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Endpoint Security还有一些其他与静音相关的API值得一提。`es_mute_process`函数提供了另一种静音特定进程事件的方法：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the definition shows, the function expects a client and an audit token of
    the process to mute. Because it takes an audit token instead of a path (as with
    the es_mute_path function), you can mute a specific instance of a running process.
    For example, you most likely want to mute events that originate from your own
    Endpoint Security tool. Using the getAuditToken function covered in [Chapter 1](chapter1.xhtml),
    [Listing 9-3](chapter9.xhtml#Lis9-3) performs such a muting.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如定义所示，该函数期望传入一个客户端和需要静音的进程的审计令牌。因为它接受的是审计令牌而不是路径（像`es_mute_path`函数那样），所以你可以静音一个正在运行的进程的特定实例。例如，你很可能希望静音来自你自己Endpoint
    Security工具的事件。使用在[第1章](chapter1.xhtml)中介绍的`getAuditToken`函数，[示例 9-3](chapter9.xhtml#Lis9-3)实现了这样的静音。
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-3: An ES client muting itself'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-3：一个ES客户端自我静音
- en: 'Besides muting a process entirely, you can also mute just a subset of its events
    via the es_mute_process_events API:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了完全静音一个进程，你还可以通过`es_mute_process_events` API只静音其部分事件：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After passing a client and an audit token of the process whose events you intend
    to mute, you should pass an array of events containing the events to mute, as
    well as the size of the array.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递一个客户端和你打算静音的进程的审计令牌之后，应该传递一个包含需要静音事件的事件数组，以及该数组的大小。
- en: 'For each muting API, you’ll find a corresponding unmuting function, such as
    es_unmute_path and es_unmute_process. Moreover, Endpoint Security provides several
    global unmuting functions. For example, es_unmute_all_paths unmutes all muted
    paths. You can find more details about these functions in Apple’s Endpoint Security
    developer documentation.^([1](#chapter9-1))  ### Mute Inversion'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '对于每个静音 API，你会找到一个对应的取消静音函数，例如 es_unmute_path 和 es_unmute_process。此外，Endpoint
    Security 提供了多个全局取消静音函数。例如，es_unmute_all_paths 取消所有路径的静音。你可以在 Apple 的 Endpoint
    Security 开发文档中找到关于这些函数的更多细节。^([1](#chapter9-1))  ### 静音反转'
- en: '*Mute inversion*, a capability added to Endpoint Security in macOS 13, inverts
    the logic for for muting, both for processes triggering the events and the events
    themselves. This allows you, for example, to subscribe to events for a very specific
    set of processes, directories, or files. You’ll find it useful for tasks such
    as the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*静音反转*，这是 macOS 13 中向 Endpoint Security 添加的功能，反转了静音的逻辑，包括触发事件的进程和事件本身。这使得你可以，例如，订阅非常特定的一组进程、目录或文件的事件。你会发现它对于以下任务非常有用：'
- en: Detecting unauthorized access to user directories, perhaps by ransomware attempting
    to encrypt user files or stealers attempting to access authentication tokens or
    cookies^([2](#chapter9-2))
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测未经授权访问用户目录的行为，可能是勒索软件试图加密用户文件，或窃取者试图访问身份验证令牌或 cookies^([2](#chapter9-2))
- en: Implementing tamper-resistant mechanisms to protect your security tool^([3](#chapter9-3))
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施防篡改机制来保护你的安全工具^([3](#chapter9-3))
- en: Capturing events triggered by the actions of a malware specimen during analysis
    or profiling
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获由恶意软件样本在分析或分析过程中触发的事件
- en: 'For example, consider MacStealer, a malware specimen that goes after user cookies.^([4](#chapter9-4))
    If we decompile its compiled Python code, we can see that it contains a list of
    common browsers, such as Chrome and Brave, as well as logic to extract their cookies:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 MacStealer，这是一种恶意软件样本，专门针对用户 cookies。^([4](#chapter9-4)) 如果我们反编译它的已编译
    Python 代码，我们可以看到它包含一个常见浏览器的列表，例如 Chrome 和 Brave，并且有提取这些浏览器 cookies 的逻辑：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code exfiltrates the collected cookies, giving the malware authors access
    to a user’s logged-in accounts. By leveraging mute inversion, we can subscribe
    to file events covering the locations of browser cookies. Any process that attempts
    to access browser cookies will trigger these events, including MacStealer, providing
    a mechanism to detect and thwart its unauthorized actions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将收集到的 cookies 外泄，允许恶意软件作者访问用户已登录的帐户。通过利用静音反转，我们可以订阅覆盖浏览器 cookies 所在位置的文件事件。任何试图访问浏览器
    cookies 的进程都会触发这些事件，包括 MacStealer，从而提供了一种检测并阻止其未经授权行为的机制。
- en: Beginning Mute Inversion
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始静音反转
- en: 'To invert muting, invoke the es_invert_muting function, which takes an Endpoint
    Security client as well as the mute inversion type:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行静音反转，调用 es_invert_muting 函数，该函数需要一个 Endpoint Security 客户端以及静音反转类型：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can find the mute inversion types in the *ESTypes.h* header file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *ESTypes.h* 头文件中找到静音反转类型：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first two types allow you to mute-invert a process. The first type should
    be used when you’re looking to mute-invert a process via its audit token, for
    example, via the es_mute_process API. On the other hand, the second type, ES_MUTE_INVERSION_TYPE_PATH,
    provides the means to identify the process to mute-invert by its path. Finally,
    ES_MUTE_INVERSION_TYPE_TARGET_PATH should be used when instead you’re looking
    to mute-invert events related to the target path, such as a directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种类型允许你进行进程的静音反转。第一种类型应在你想通过其审计令牌进行进程的静音反转时使用，例如，通过 es_mute_process API。另一方面，第二种类型，ES_MUTE_INVERSION_TYPE_PATH，提供了通过路径识别要静音反转的进程的方式。最后，当你想要静音反转与目标路径相关的事件（例如目录）时，应使用
    ES_MUTE_INVERSION_TYPE_TARGET_PATH。
- en: Mute inversion applies globally across the specified mute inversion type; that
    is to say, if you invoked es_invert_muting with the ES_MUTE_INVERSION_TYPE_PATH
    type, all muted process paths would unmute. For this reason, it often makes sense
    to create a new Endpoint Security client specifically for mute inversion. (While
    the system imposes a limit on the number of clients, your program can create at
    least several dozen of them before causing an ES_NEW_CLIENT_RESULT_ERR_TOO_MANY_CLIENTS
    error.) Also worth nothing is that since muting inversion will only occur for
    the specified mute inversion type, you can mix and match mute and mute inversions.
    For example, you could mute processes while mute-inverting paths found in the
    events. This would be useful in a scenario where you are perhaps building a directory
    monitor leveraging mute inversion but want to ignore (mute) events from trusted
    system processes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 静音反转在指定的静音反转类型上全局应用；也就是说，如果您调用了带有 ES_MUTE_INVERSION_TYPE_PATH 类型的 es_invert_muting，那么所有被静音的进程路径将被取消静音。因此，通常会建议为静音反转创建一个新的
    Endpoint Security 客户端。（虽然系统对客户端数量有限制，但您的程序可以创建至少几十个客户端，而不会导致 ES_NEW_CLIENT_RESULT_ERR_TOO_MANY_CLIENTS
    错误。）还需要注意的是，由于静音反转仅会发生在指定的静音反转类型上，因此您可以混合使用静音和静音反转。例如，您可以静音进程，同时反转事件中找到的路径的静音。这在构建一个利用静音反转的目录监控器时非常有用，但您可能希望忽略（静音）来自受信任系统进程的事件。
- en: Mute inversions also impact the *default mute set*, a handful of paths to system-critical
    platform binaries that get muted by default. You can invoke the es_muted_paths_events
    function to retrieve a list of all muted paths, including the default ones. The
    default mute set aims to protect clients from deadlocks and timeout panics, so
    you likely won’t want to generate events for its paths. To avoid doing so, consider
    invoking es_unmute_all_paths before any process-path mute inversions or es_unmute_all_target_paths
    before any target-path mute inversions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 静音反转还会影响*默认静音集*，即一些系统关键平台二进制文件的路径，这些路径默认会被静音。您可以调用 es_muted_paths_events 函数来检索所有静音路径的列表，包括默认路径。默认静音集的目的是保护客户端免受死锁和超时恐慌，因此您可能不希望为其路径生成事件。为了避免这样做，请考虑在任何进程路径静音反转之前调用
    es_unmute_all_paths，或者在任何目标路径静音反转之前调用 es_unmute_all_target_paths。
- en: Now that you have inverted muting (for example, via the es_invert_muting API),
    you can invoke any of the corresponding, previously mentioned muting APIs, whose
    muting logic will now be inverted. This is clearly illustrated in the next section,
    which makes use of mute inversion to monitor file access within a single directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经启用了反向静音（例如，通过 es_invert_muting API），您可以调用之前提到的任何对应的静音 API，其静音逻辑现在将被反转。下一个部分清楚地说明了这一点，其中利用静音反转来监控单个目录中的文件访问。
- en: Monitoring Directory Access
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 监控目录访问
- en: '[Listing 9-4](chapter9.xhtml#Lis9-4) is a snippet of mute inversion code that
    monitors the opening of files in the logged-in user’s *Documents* directory. You
    can find the full implementation in the muteInvert function, in the *ESPlayground*
    project’s *muteInvert.m* file.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-4](chapter9.xhtml#Lis9-4) 是一个静音反转代码片段，监控已登录用户的 *Documents* 目录中打开的文件。您可以在
    *ESPlayground* 项目的 *muteInvert.m* 文件中的 muteInvert 函数找到完整实现。'
- en: In “Authorization Events” on [page 213](chapter9.xhtml#pg_213), we’ll combine
    this approach with authorization access, a useful protection mechanism that could,
    for example, block ransomware or malware attempting to access sensitive user files.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第213页](chapter9.xhtml#pg_213)的“授权事件”中，我们将结合这种方法与授权访问，这是一个有用的保护机制，能够阻止例如勒索软件或恶意软件尝试访问敏感的用户文件。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 9-4: Monitoring file-open events in the user’s Documents directory'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-4：监控用户的 Documents 目录中的文件打开事件
- en: First, we dynamically build the path to the logged-in user’s *Documents* directory.
    Because Endpoint Security code always runs with root privileges, most APIs that
    return the current user would simply return the root. Instead, we make use of
    the SCDynamicStoreCopyConsoleUser API to get the name of the user currently logged
    in to the system ❶. Note that the API isn’t aware of the automatic reference counting
    (ARC) memory management feature, so we add __bridge_transfer, which saves us from
    having to manually free the memory containing the user’s name. Next, we invoke
    the NSHomeDirectoryForUser function to get the home directory, to which we then
    append the path component *Documents*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们动态构建登录用户的 *Documents* 目录路径。由于 Endpoint Security 代码始终以 root 权限运行，大多数返回当前用户的
    API 会直接返回 root。相反，我们使用 SCDynamicStoreCopyConsoleUser API 来获取当前登录到系统的用户名 ❶。请注意，该
    API 并不支持自动引用计数（ARC）内存管理功能，因此我们添加了 __bridge_transfer，这样就无需手动释放包含用户名的内存。接下来，我们调用
    NSHomeDirectoryForUser 函数获取主目录，并将路径组件 *Documents* 附加到该目录上。
- en: After defining the events of interest and creating a new Endpoint Security client,
    the code unmutes all target paths ❷. Then it invokes es_invert_muting with the
    ES_MUTE_INVERSION_TYPE_TARGET_PATH value to invert muting ❸. Next, the code invokes
    es_mute_path, passing in the document’s directory ❹. Since we’ve inverted muting,
    this API instructs Endpoint Security to deliver only events that occur in this
    directory and ignore all others. Finally, we invoke es_subscribe with the events
    of interest to commence the delivery of such events.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义感兴趣的事件并创建新的 Endpoint Security 客户端之后，代码取消静音所有目标路径 ❷。然后，它调用 es_invert_muting，并传入
    ES_MUTE_INVERSION_TYPE_TARGET_PATH 值来反转静音状态 ❸。接下来，代码调用 es_mute_path，传入文档的目录 ❹。由于我们已反转静音，
    此 API 指示 Endpoint Security 只传送该目录中发生的事件并忽略其他所有事件。最后，我们调用 es_subscribe 并传入感兴趣的事件，开始接收这些事件的传送。
- en: To complete this example, print out the event, which you’ll recall gets delivered
    to the es_handler_block_t callback block specified in the last parameter to the
    es_new_client. [Listing 9-5](chapter9.xhtml#Lis9-5) shows an inline implementation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成此示例，打印出事件内容，正如你会记得的，这些事件会被传送到在 es_new_client 的最后一个参数中指定的 es_handler_block_t
    回调块中。[列表 9-5](chapter9.xhtml#Lis9-5) 展示了一个内联实现。
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-5: Printing out a file-open Endpoint Security event'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-5：打印出文件打开的 Endpoint Security 事件
- en: We extract the path to the responsible process. We can always find this process
    in the message structure passed by reference to the handler block. To get its
    path, we check the process structure’s executable member ❶. Next, we extract the
    path of the file that the process has attempted to open. For ES_EVENT_TYPE_NOTIFY_OPEN
    events, we find this path in an es_event_open_t structure, located in the message
    structure’s event member ❷. After extracting the paths for the responsible process
    and file, we print them out ❸.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取负责进程的路径。我们始终可以在通过引用传递给处理程序块的消息结构中找到这个进程。为了获取其路径，我们检查进程结构的可执行成员 ❶。接下来，我们提取进程尝试打开的文件的路径。对于
    ES_EVENT_TYPE_NOTIFY_OPEN 事件，我们在消息结构的 event 成员 ❷ 中找到这个路径。在提取了负责进程和文件的路径后，我们将其打印出来
    ❸。
- en: 'The tool should now detect any access to files in the *Documents* directory.
    You can test this by running *ESPlayground* with the -muteinvert flag. You’ll
    see that it displays no Endpoint Security events unless they originate within
    *Documents*. You can trigger such events by either browsing to the directory via
    Finder or using the terminal (for example, to list the directory’s contents via
    ls):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 工具现在应该能检测到对 *Documents* 目录中文件的任何访问。你可以通过带有 -muteinvert 标志的 *ESPlayground* 来进行测试。你会看到，除非事件发生在
    *Documents* 中，否则不会显示任何 Endpoint Security 事件。你可以通过在 Finder 中浏览该目录或使用终端（例如，通过 ls
    列出目录内容）来触发这些事件：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we extended the example code to also monitor other directories, such as
    those where browsers store their cookies, we’d easily detect stealers such as
    MacStealer! In the next section, I’ll cover the powerful authorization event type.  ###
    Authorization Events'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展示例代码来监控其他目录，例如浏览器存储其 cookie 的目录，我们就能轻松检测到如 MacStealer 之类的窃取工具！在下一节，我将介绍强大的授权事件类型。###
    授权事件
- en: Unlike notification-based events, which an Endpoint Security client receives
    after some activity occurs on the system, authorization events allow a client
    to examine and then allow or deny events *before* they’ve completed. This feature
    provides a mechanism for building security tools capable of proactively detecting
    and thwarting malicious activity. Although working with authorization events involves
    similar concepts as working with notification events, there are some important
    differences. To explore these, let’s dive into the code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于通知的事件不同，后者是 Endpoint Security 客户端在系统上发生某些活动后接收到的，授权事件允许客户端在事件完成之前进行检查并决定是否允许或拒绝事件。这一功能提供了一种机制，帮助构建能够主动检测并阻止恶意活动的安全工具。尽管与授权事件的工作方式与通知事件相似，但也存在一些重要的差异。为了探讨这些差异，我们来深入了解代码。
- en: 'Conceptually, our goal is simple: design a tool capable of blocking the execution
    of non-notarized programs originating from the internet. As we’ve seen, the overwhelming
    majority of macOS malware isn’t notarized, while legitimate software almost always
    is, making this a powerful approach to stopping malware. When a user attempts
    to launch an item downloaded from the internet, we’ll intercept this execution
    before it’s allowed, then check its notarization status. We’ll allow validly notarized
    items and block all others.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们的目标很简单：设计一个工具，能够阻止来自互联网的未经过公证的程序执行。正如我们所见，绝大多数的 macOS 恶意软件并未经过公证，而合法软件几乎总是经过公证的，这使得这一方法在阻止恶意软件方面非常有效。当用户尝试启动从互联网下载的项目时，我们将在允许执行之前拦截该操作，并检查其公证状态。我们将允许有效公证的项目，并阻止所有其他项目。
- en: At the time of this writing, recent versions of macOS attempt to implement this
    same check, but they do so less rigorously. First, up until macOS 15, if the user
    right-clicks a download item, the operating system still provides the option to
    run non-notarized items. Malware authors are, of course, well aware of this loophole
    and often leverage it to get their untrusted malware to execute. The prolific
    macOS adware Shlayer and many macOS stealers are fond of this trick. Moreover,
    Apple’s implementation to prevent non-notarized code on macOS has been rife with
    exploitable bugs (such as CVE-2021-30657 and CVE-2021-30853), rendering it essentially
    useless.^([5](#chapter9-5))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，macOS 的最新版本试图实现相同的检查，但其执行不够严格。首先，直到 macOS 15，如果用户右键点击下载项，操作系统仍然提供运行未公证项目的选项。恶意软件作者当然非常清楚这个漏洞，并经常利用它来执行未经信任的恶意软件。广泛存在的
    macOS 广告软件 Shlayer 和许多 macOS 木马都喜欢使用这个技巧。此外，Apple 在 macOS 上防止未公证代码的实现存在许多可被利用的漏洞（如
    CVE-2021-30657 和 CVE-2021-30853），使其实际上无效。^([5](#chapter9-5))
- en: I implemented a notarization check in one of Objective-See’s most popular tools,
    BlockBlock, discussed in detail in [Chapter 11](chapter11.xhtml). When run in
    notarization mode, this tool blocks any downloaded binary that isn’t notarized,
    including malware that attempts to exploit CVE-2021-30657 and CVE-2021-30853,
    well before patches from Apple were available.^([6](#chapter9-6)) We’ll roughly
    follow BlockBlock’s approach here. Note that in your own implementation, you might
    take a less draconian approach; for example, rather than blocking all non-notarized
    items, you might block only those that users may have been tricked into running.
    (In macOS 15, Apple introduced the ES_EVENT_TYPE_NOTIFY_GATEKEEPER_USER_OVERRIDE
    event you may be able to leverage to detect this.) Or you might collect non-notarized
    binaries for external analysis or subject them to other heuristics mentioned in
    this book before deciding whether to prevent their execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Objective-See 最受欢迎的工具之一 BlockBlock 中实现了一个公证检查，详细讨论请参见[第 11 章](chapter11.xhtml)。在公证模式下运行时，该工具会阻止任何未经过公证的下载二进制文件，包括试图利用
    CVE-2021-30657 和 CVE-2021-30853 的恶意软件，远在 Apple 发布补丁之前。^([6](#chapter9-6)) 我们将在这里大致遵循
    BlockBlock 的方法。请注意，在您自己的实现中，您可能采取一种不那么严格的方法；例如，您可能只会阻止那些用户可能被欺骗执行的未公证项目，而不是阻止所有未公证项目。（在
    macOS 15 中，Apple 引入了 ES_EVENT_TYPE_NOTIFY_GATEKEEPER_USER_OVERRIDE 事件，您或许可以利用它来检测这一点。）或者，您可能会收集未公证的二进制文件进行外部分析，或对它们应用本书中提到的其他启发式方法，再决定是否阻止其执行。
- en: Creating a Client and Subscribing to Events
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建客户端并订阅事件
- en: In this section, we subscribe to Endpoint Security authorization events before
    discussing how to respond to such events in a timely manner. You can find a full
    implementation of the code mentioned in this section in the authorization function,
    found in the *ESPlayground* project’s *authorization.m* file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们订阅 Endpoint Security 授权事件，然后讨论如何及时响应这些事件。您可以在 *ESPlayground* 项目的 *authorization.m*
    文件中找到本节中提到的代码的完整实现。
- en: As when working with notification events, we start by creating an Endpoint Security
    client, specify an es_handler_block_t block, and subscribe to events of interest
    ([Listing 9-6](chapter9.xhtml#Lis9-6)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与处理通知事件时一样，我们首先创建一个 Endpoint Security 客户端，指定一个 es_handler_block_t 块，并订阅感兴趣的事件（[列表
    9-6](chapter9.xhtml#Lis9-6)）。
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 9-6: Subscribing to authorization events for process executions'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-6：订阅进程执行的授权事件
- en: 'To block non-notarized processes, we need to subscribe to only a single authorization
    event: ES_EVENT_TYPE_AUTH_EXEC ❶. Apple’s developer documentation succinctly describes
    it as the event type for any process that “requests permission from the operating
    system to execute another image.”^([7](#chapter9-7)) Once the call to es_subscribe
    returns, Endpoint Security will invoke our code anytime a new process is about
    to be executed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阻止未授权的进程，我们只需要订阅一个授权事件：ES_EVENT_TYPE_AUTH_EXEC ❶。苹果的开发者文档简洁地描述了它作为任何“请求操作系统授权以执行另一个映像”的进程的事件类型。^([7](#chapter9-7))
    一旦调用 es_subscribe 返回，Endpoint Security 将在任何新进程即将执行时调用我们的代码。
- en: 'Next, we must respond to the operating system with a decision to either authorize
    or deny the delivered event. To respond, we use the es_respond_auth_result API,
    defined as follows in *ESClient.h*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须向操作系统响应，决定是授权还是拒绝传递的事件。为了响应，我们使用 es_respond_auth_result API，该 API 在
    *ESClient.h* 中定义如下：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The function takes the client that received the message, the delivered message,
    the authorization result, and a flag indicating whether the results should be
    cached. To allow a message, invoke this function with an es_auth_result_t value
    of ES_AUTH_RESULT_ALLOW. To deny the message, specify a value of ES_AUTH_RESULT_DENY.
    If you pass in true for the cache flag, Endpoint Security will cache the authorization
    decision, meaning future events from the same process may not trigger additional
    authorization events. This, of course, has performance benefits, though some important
    nuances to be aware of. First, imagine that you’ve cached an authorization decision
    for a process execution event. Even if that process is executed with different
    arguments, no additional authorization event will be generated, which could be
    problematic if a detection heuristic makes use of process arguments. Second, be
    aware that the cache is global for the system, meaning if any other Endpoint Security
    client does not cache an event, you’ll still receive it (even if you’ve previously
    cached it).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受接收到消息的客户端、传递的消息、授权结果以及一个标志，指示是否应该缓存结果。要允许消息，调用此函数并传入 es_auth_result_t 类型的
    ES_AUTH_RESULT_ALLOW 值。要拒绝消息，指定 ES_AUTH_RESULT_DENY 值。如果将缓存标志设置为 true，Endpoint
    Security 将缓存授权决策，意味着来自同一进程的未来事件可能不会触发额外的授权事件。当然，这样做有性能优势，但也有一些重要的细节需要注意。首先，假设你已经缓存了一个进程执行事件的授权决策。即使该进程使用不同的参数执行，也不会生成额外的授权事件，这可能会导致问题，特别是当检测启发式方法依赖于进程参数时。其次，请注意缓存是全局的，意味着如果任何其他
    Endpoint Security 客户端没有缓存该事件，你仍然会收到该事件（即使你之前已经缓存了它）。
- en: Let’s build upon the code in [Listing 9-6](chapter9.xhtml#Lis9-6) to extract
    the path of the process about to be spawned and then determine how to respond.
    For simplicity, we’ll just allow all processes in this example ([Listing 9-7](chapter9.xhtml#Lis9-7)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在[列表 9-6](chapter9.xhtml#Lis9-6)的代码基础上，提取即将启动的进程路径，然后确定如何响应。为了简单起见，在本示例中我们将允许所有进程（[列表
    9-7](chapter9.xhtml#Lis9-7)）。
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 9-7: Handling process authorization events'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-7：处理进程授权事件
- en: Within the callback block, we extract information about the process that is
    about to be spawned. First, we get a pointer to its es_process_t structure, found
    with the es_event_exec_t structure in the Endpoint Security message ❶. From this,
    we extract just its path ❷ and print it out. Finally, we invoke the es_respond_auth_result
    API with ES_AUTH_RESULT_ALLOW to tell the Endpoint Security subsystem to authorize
    that process’s execution ❸.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调块中，我们提取有关即将启动的进程的信息。首先，我们获取指向其 es_process_t 结构体的指针，该结构体与 Endpoint Security
    消息中的 es_event_exec_t 结构体一起找到 ❶。从中，我们提取其路径 ❷ 并打印出来。最后，我们调用 es_respond_auth_result
    API，并使用 ES_AUTH_RESULT_ALLOW 告诉 Endpoint Security 子系统授权该进程的执行 ❸。
- en: NOTE
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In* ESTypes.h*, Apple specifies an important but easy-to-overlook nuance:
    for file authorization events (ES_EVENT_TYPE_AUTH_OPEN) only, your code must provide
    an authorization response via the es_respond_flags_result function, not via the
    es_respond_auth_result function. The same header file notes that when invoking
    the es_respond_flags_result function, you should pass a value of 0 to deny the
    event and UINT32_MAX to allow it.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*在* ESTypes.h* 中，Apple 指定了一个重要但容易忽视的细节：仅对于文件授权事件（ES_EVENT_TYPE_AUTH_OPEN），你的代码必须通过
    es_respond_flags_result 函数提供授权响应，而不是通过 es_respond_auth_result 函数。相同的头文件还指出，在调用
    es_respond_flags_result 函数时，应传递 0 来拒绝事件，传递 UINT32_MAX 来允许它。*'
- en: 'Let’s run *ESPlayground* with the -authorization flag and then launch the Calculator
    application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 *ESPlayground* 并加上 -authorization 标志，然后启动计算器应用程序：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We see the authorization event, and because we’re allowing all processes, Endpoint
    Security doesn’t block it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了授权事件，由于我们允许所有进程，Endpoint Security 并不会阻止它。
- en: Meeting Message Deadlines
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遵守消息截止时间
- en: 'There is one very important caveat to responding to authorization events: if
    we miss the response deadline, Endpoint Security will allow the event and forcefully
    kill our client.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 响应授权事件时有一个非常重要的注意事项：如果我们错过了响应截止时间，Endpoint Security 将允许事件发生并强制关闭我们的客户端。
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From a system and usability point of view, this approach makes sense. If the
    program takes too long to respond, the entire system could lag or, worse, hang.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从系统和可用性角度来看，这种方法是有道理的。如果程序响应时间过长，整个系统可能会出现延迟，或者更糟糕的是，系统可能会挂起。
- en: The es_message_t structure has a field named deadline that tells us exactly
    how long we have to respond to the message. The header file also notes that the
    deadline can vary substantially between each message; thus, our code should inspect
    each message’s deadline accordingly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: es_message_t 结构体中有一个名为 deadline 的字段，告诉我们响应消息的具体时间。头文件中还指出，每个消息的截止时间可能会有所不同，因此我们的代码应该相应地检查每个消息的截止时间。
- en: Let’s look at how BlockBlock’s process monitoring logic handles deadlines.^([8](#chapter9-8))
    Deadlines are especially important for this tool, as it waits for the user’s input
    before authorizing or denying the non-notarized process, meaning it faces a very
    real possibility of hitting the deadline ([Listing 9-8](chapter9.xhtml#Lis9-8)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 BlockBlock 的进程监控逻辑是如何处理截止时间的。^([8](#chapter9-8)) 截止时间对于该工具尤其重要，因为它在授权或拒绝未认证的进程之前等待用户的输入，这意味着它面临着可能错过截止时间的实际风险
    ([Listing 9-8](chapter9.xhtml#Lis9-8))。
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-8: BlockBlock’s handling of Endpoint Security message deadlines'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-8：BlockBlock 处理 Endpoint Security 消息截止时间的方式
- en: First, the code creates a semaphore ❶ and computes the deadline ❷. Because Endpoint
    Security reports the message deadline in absolute time, the code subtracts the
    current time from it to figure out how long it has left. Next, the code submits
    a block to execute asynchronously in a background queue ❸, where it delivers the
    message to the user and, in another asynchronous block, waits for the response.
    I’ve omitted this part of the code to keep things concise, as its specifics aren’t
    relevant.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码创建一个信号量 ❶ 并计算截止时间 ❷。由于 Endpoint Security 以绝对时间报告消息截止时间，代码通过将当前时间从截止时间中减去，来计算剩余的时间。接下来，代码提交一个块，在后台队列中异步执行
    ❸，该块将消息传递给用户，并在另一个异步块中等待响应。我省略了这部分代码以保持简洁，因为其具体内容不相关。
- en: 'Performing time-consuming processing in another asynchronous queue allows the
    code to signal the semaphore once the processing is complete and avoid the timeout,
    which the code sets up next ❹. Once BlockBlock has delivered the message to the
    user and is awaiting a response, it invokes the dispatch_semaphore_wait function
    to wait on the semaphore until a certain time. You probably guessed it: the function
    waits until right before the message’s deadline is hit. If a timeout occurs (meaning
    a user response didn’t signal the semaphore and the message deadline is about
    to be hit), the code has no choice but to respond, which it does by defaulting
    to authorizing the event ❺.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个异步队列中执行耗时的处理操作使得代码可以在处理完成后发出信号量，从而避免超时，接下来代码会设置超时 ❹。一旦 BlockBlock 向用户发送消息并等待响应，它会调用
    dispatch_semaphore_wait 函数，直到某个特定时间前等待信号量。你可能猜到了：该函数会等待直到消息的截止时间前。如果发生超时（意味着用户响应没有发出信号量，而消息截止时间即将到达），代码别无选择，只能响应，默认情况下通过授权该事件
    ❺。
- en: 'Note that the Mach absolute time value returned by a function can vary between
    processes, depending on whether they’re native or translated. To maintain consistency,
    you should apply a timebase, which you can retrieve using the mach_timebase_info
    function. Apple documentation illustrates this in the following code, which converts
    a mach time value to nanoseconds using timebase information:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数返回的 Mach 绝对时间值可能因进程而异，具体取决于它们是本地进程还是被翻译的进程。为了保持一致性，你应该应用时间基准，可以使用 mach_timebase_info
    函数来获取。Apple 文档通过以下代码演示了这一点，该代码使用时间基准信息将 Mach 时间值转换为纳秒：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You might have noticed that the code in [Listing 9-8](chapter9.xhtml#Lis9-8)
    leveraged this function when computing the wait time for the dispatch semaphore.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，[列表 9-8](chapter9.xhtml#Lis9-8) 中的代码在计算调度信号量的等待时间时使用了这个函数。
- en: NOTE
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you’re asynchronously processing Endpoint Security messages, such as when
    asking a user for input and awaiting their response, you must retain the message
    via the es_retain_message API. Once you’re done with the message, you must release
    it with a call to es_release_message.*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你异步处理 Endpoint Security 消息，比如向用户请求输入并等待其响应，你必须通过 es_retain_message API 保留消息。完成消息处理后，你必须通过调用
    es_release_message 来释放它。*'
- en: Now that you’ve seen how to respond to Endpoint Security authorization events
    while taking deadlines into account, you’re ready to look at the last piece of
    the “blocking non-notarized processes” puzzle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何在考虑时间限制的情况下响应 Endpoint Security 授权事件，你已经准备好查看“阻止非公证进程”难题的最后一块拼图。
- en: Checking Binary Origins
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查二进制文件来源
- en: Once we’ve registered for ES_EVENT_TYPE_AUTH_EXEC events, the system will invoke
    the es_handler_block_t block passed to the es_new_client function before each
    new process is spawned. In this block, we’ll add logic to deny non-notarized processes
    from remote locations only. That last part is important, as local platform binaries
    aren’t notarized but should, of course, be allowed. Along the same lines, you
    may want to consider allowing applications from the official Mac App Store. Though
    not notarized, they’ve passed a similar and (hopefully) stringent Apple review
    process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为 ES_EVENT_TYPE_AUTH_EXEC 事件注册，系统将在每个新进程生成之前调用传递给 es_new_client 函数的 es_handler_block_t
    块。在这个块中，我们将添加逻辑，只拒绝来自远程位置的非公证进程。最后这一部分很重要，因为本地平台的二进制文件虽然没有经过公证，但当然应该允许。按照这个思路，你可能还希望考虑允许来自官方
    Mac App Store 的应用程序。尽管这些应用没有经过公证，但它们已经通过了类似的且（希望）严格的 Apple 审核流程。
- en: To determine if a process’s binary originated from a remote location, we’ll
    defer to macOS by checking whether the binary has been translocated or has the
    com.apple.quarantine extended attribute. If either condition is true, the operating
    system has marked the item as originating from a remote source. *Translocation*
    is a security mitigation built into recent versions of macOS designed to thwart
    relative dynamic library hijacking attacks.^([9](#chapter9-9))
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定进程的二进制文件是否来自远程位置，我们将依赖 macOS 来检查二进制文件是否被转移或具有 com.apple.quarantine 扩展属性。如果其中任一条件为真，操作系统已将该项目标记为来自远程来源。*转移*是
    macOS 最近版本中内置的安全缓解措施，旨在防止相对动态库劫持攻击。^([9](#chapter9-9))
- en: In short, when a user attempts to open an executable item from a downloaded
    disk image or ZIP file, macOS will first create a random read-only mount containing
    a copy of the item, then launch this copy. If we can programmatically determine
    that a process about to be executed has been translocated, we know we should subject
    it to a notarization check.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当用户尝试从下载的磁盘映像或ZIP文件中打开可执行项目时，macOS 会首先创建一个包含该项目副本的随机只读挂载点，然后启动这个副本。如果我们能够编程确定一个即将执行的进程已经被迁移，我们就知道需要对其进行公证检查。
- en: To check if an item has been translocated, we can invoke the private SecTranslocateIsTranslocatedURL
    API. This function takes several parameters, including the path of the item to
    check and a pointer to a Boolean flag that macOS will set to true if it has translocated
    the item. Because the API is private, we must dynamically resolve it before we
    can invoke it. The code in [Listing 9-9](chapter9.xhtml#Lis9-9) does both tasks.^([10](#chapter9-10))
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个项目是否已被迁移，我们可以调用私有的 `SecTranslocateIsTranslocatedURL` API。此函数接受多个参数，包括要检查的项目路径和一个布尔标志指针，如果
    macOS 已经迁移该项目，它会将该标志设置为 `true`。因为这个API是私有的，所以我们必须在调用它之前动态解析它。[列表9-9](chapter9.xhtml#Lis9-9)
    中的代码完成了这两个任务。^([10](#chapter9-10))
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-9: A helper function that uses private APIs to determine whether
    an item has been translocated'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-9：一个辅助函数，使用私有API来判断一个项目是否已被迁移
- en: The code loads the *Security* framework, which contains the SecTranslocateIsTranslocatedURL
    API ❶. Once it’s loaded, the code resolves the API via dlsym ❷, then invokes the
    function with the path of the item to check ❸. When the API returns, it will set
    the second parameter to the result of the translocation check.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码加载了 *Security* 框架，框架中包含 `SecTranslocateIsTranslocatedURL` API ❶。加载后，代码通过
    `dlsym` ❷ 解析该API，然后使用检查项目路径的方式调用该函数 ❸。当API返回时，它会将第二个参数设置为迁移检查的结果。
- en: 'Another way to check whether an item has a remote origin is via the com.apple.quarantine
    extended attribute, added either by the application responsible for downloading
    the item or by the operating system directly, if the application has set LSFileQuarantineEnabled
    = 1 in its *Info.plist* file. You can programmatically retrieve the value of an
    item’s extended attribute using various private qtn_file_* APIs found in */usr/lib/system/libquarantine.dylib*,
    though you must first dynamically resolve these functions. Invoke them in the
    following manner:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个项目是否具有远程来源的另一种方法是通过 `com.apple.quarantine` 扩展属性，这个属性由负责下载该项目的应用程序或操作系统直接添加（如果应用程序在其*Info.plist*文件中设置了LSFileQuarantineEnabled
    = 1）。你可以通过各种私有的 `qtn_file_*` API 来编程获取项目的扩展属性值，这些API位于 */usr/lib/system/libquarantine.dylib*，但你必须先动态解析这些函数。调用它们的方式如下：
- en: 1.  Invoke qtn_file_alloc to allocate a _qtn_file structure.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  调用 `qtn_file_alloc` 来分配一个 _qtn_file 结构。
- en: 2.  Invoke the qtn_file_init_with_path API with the _qtn_file pointer and the
    path of the item whose quarantine attributes you wish to retrieve. If this function
    returns QTN_NOT_QUARANTINED (-1), the item isn’t quarantined.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  使用 _qtn_file 指针和你希望获取其隔离属性的项目路径调用 `qtn_file_init_with_path` API。如果此函数返回
    `QTN_NOT_QUARANTINED` (-1)，则表示该项目没有被隔离。
- en: 3.  Invoke the qtn_file_get_flags API with the _qtn_file pointer to retrieve
    the actual value of the com.apple.quarantine extended attribute.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  使用 _qtn_file 指针调用 `qtn_file_get_flags` API 来获取 `com.apple.quarantine` 扩展属性的实际值。
- en: 4.  If the qtn_file_init_with_path function didn’t return QTN_NOT_QUARANTINED,
    you’ll know that the item is quarantined, but you may want to check whether a
    user previously approved the file. You can determine this by checking the value
    returned by qtn_file_get_flags, where the QTN_FLAG_USER_APPROVED (0x0040) bit
    may be set.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  如果 `qtn_file_init_with_path` 函数未返回 `QTN_NOT_QUARANTINED`，你就知道该项目已被隔离，但你可能还想检查用户是否之前批准了该文件。你可以通过检查
    `qtn_file_get_flags` 返回的值来确定这一点，其中可能会设置 `QTN_FLAG_USER_APPROVED (0x0040)` 位。
- en: 5.  Make sure to free the _qtn_file structure by calling qtn_file_free.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  确保通过调用 `qtn_file_free` 释放 _qtn_file 结构。
- en: In several cases, macOS didn’t appropriately classify nonlocal items as having
    originated from a remote source. For example, in CVE-2023-27951, the operating
    system failed to apply the com.apple.quarantine extended attribute. In production
    code, you might therefore want to take a more comprehensive approach to determining
    a binary’s origins. For instance, you could create a file monitor to detect binary
    downloads and then subject these binaries to the notarization checks, or just
    block any nonplatform binary that isn’t notarized. And, yes, malware (once it’s
    off and running) may remove the quarantine extended attribute from other components
    it has downloaded prior to their execution to potentially bypass macOS or BlockBlock
    checks. As such, you may also want to subscribe to the ES_EVENT _TYPE_AUTH_DELETEEXTATTR
    Endpoint Security event, which will be able to detect and prevent the removal
    of the quarantine attribute.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，macOS 没有正确地将非本地项目归类为来自远程源。例如，在 CVE-2023-27951 中，操作系统未能应用 com.apple.quarantine
    扩展属性。在生产代码中，因此你可能希望采取更全面的方法来确定二进制文件的来源。例如，你可以创建一个文件监视器来检测二进制文件下载，并将这些二进制文件提交给认证检查，或者直接阻止任何未经过认证的非平台二进制文件。并且，是的，恶意软件（在启动后）可能会删除它已经下载的其他组件的隔离扩展属性，从而绕过
    macOS 或 BlockBlock 的检查。因此，你也可能希望订阅 ES_EVENT_TYPE_AUTH_DELETEEXTATTR Endpoint Security
    事件，它能够检测并阻止隔离属性的删除。
- en: Now that we can determine whether a process originated from a remote source,
    we must check whether the binary backing the process is notarized. As you saw
    in [Chapter 1](chapter1.xhtml), this is as easy as invoking the SecStaticCodeCheckValidity
    API with the appropriate requirement string.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以确定一个进程是否来自远程来源，接下来我们必须检查支撑该进程的二进制文件是否已进行认证。正如你在 [第 1 章](chapter1.xhtml)
    中看到的，这和调用 SecStaticCodeCheckValidity API 并传入适当的要求字符串一样简单。
- en: If BlockBlock ascertains that the process about to be executed is from a remote
    source and not notarized, it will alert the user to request their input. If the
    user decides that the process is, for example, untrustworthy or unrecognized,
    BlockBlock will invoke the function in [Listing 9-10](chapter9.xhtml#Lis9-10)
    to block it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 BlockBlock 确认即将执行的进程来自远程来源且未经过认证，它将提示用户输入意见。如果用户决定该进程是，例如，不可信或未被识别，BlockBlock
    将调用 [Listing 9-10](chapter9.xhtml#Lis9-10) 中的功能来阻止它。
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 9-10: Blocking untrustworthy processes'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-10：阻止不可信进程
- en: 'It invokes the respond:action: method with the ES_AUTH_RESULT_DENY constant.
    If we look at this method, we see that, at its core, it just invokes es_respond_auth_result,
    passing along the specified allow or deny action to the Endpoint Security subsystem.
    Also, as true is passed in for the cache flag, subsequent executions of the same
    process will not generate additional authorization events, thus providing a noticeable
    performance boost ([Listing 9-11](chapter9.xhtml#Lis9-11)).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '它调用了 respond:action: 方法，并使用了 ES_AUTH_RESULT_DENY 常量。如果我们查看这个方法，会发现其核心其实只是调用了
    es_respond_auth_result，将指定的允许或拒绝动作传递给 Endpoint Security 子系统。而且，由于传入了 true 作为缓存标志，后续执行相同的进程时不会生成额外的授权事件，从而显著提高性能（[Listing
    9-11](chapter9.xhtml#Lis9-11)）。'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-11: Passing Endpoint Security the action to take'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-11：将操作传递给 Endpoint Security
- en: For a full implementation that blocks non-notarized processes via Endpoint Security,
    see BlockBlock’s process plug-in.^([11](#chapter9-11))
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现通过 Endpoint Security 阻止未经过认证的进程，参见 BlockBlock 的进程插件。^([11](#chapter9-11))
- en: Blocking Background Task Management Bypasses
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阻止后台任务管理绕过
- en: Let’s consider another example that uses Endpoint Security authorization events
    to detect malware, this time by focusing on attempts to leverage exploits that
    bypass built-in macOS security mechanisms. While the use of these exploits isn’t
    yet widespread, the inclusion of new security mechanisms in macOS has increasingly
    forced malware to employ new techniques to achieve their malicious objectives,
    so monitoring for these exploits may aid your detections.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，这次使用 Endpoint Security 授权事件来检测恶意软件，重点是尝试利用绕过内置 macOS 安全机制的漏洞。虽然这些漏洞的使用尚未广泛传播，但
    macOS 中新安全机制的引入迫使恶意软件采用新的技术来实现其恶意目标，因此监控这些漏洞可能有助于你的检测。
- en: In [Chapter 5](chapter5.xhtml), I discussed macOS’s new Background Task Management
    (BTM) database, which monitors for persistent items, generates alerts for them,
    and globally tracks their behavior. BTM is problematic for malware hoping to persist,
    because users will now receive an alert when the malware gets installed. For example,
    [Figure 9-1](chapter9.xhtml#fig9-1) shows the BTM alert that users receive when
    malware known as DazzleSpy persistently installs itself as a binary named *softwareupdate*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](chapter5.xhtml)中，我讨论了 macOS 新的后台任务管理（BTM）数据库，它用于监控持久化项目，生成警告并全局跟踪其行为。对于希望持久化的恶意软件来说，BTM
    是一个问题，因为用户在恶意软件安装时会收到警告。例如，[图 9-1](chapter9.xhtml#fig9-1)展示了用户在 DazzleSpy 恶意软件作为名为
    *softwareupdate* 的二进制文件持久安装时收到的 BTM 警告。
- en: '![](../images/Figure9-1.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure9-1.jpg)'
- en: 'Figure 9-1: A BTM alert showing that a binary named softwareupdate has been
    persistently installed'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：BTM 警告，显示名为 softwareupdate 的二进制文件已被持久安装
- en: Luckily for the malware, my research into BTM revealed that Apple’s original
    implementation was easy to subvert in several ways, preventing this alert. This
    section details two such bypasses and shows how to leverage Endpoint Security
    to detect and block these subversions. Note that I informed Apple about these
    issues, and, at least in macOS 15 (and perhaps on earlier versions of macOS),
    they appear to have been fixed. Even so, you could adapt the code in this section
    to detect other local exploits.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过我的研究，我发现 Apple 原始实现的 BTM 容易通过多种方式被绕过，从而阻止了这个警告。本节将详细介绍两种绕过方法，并展示如何利用
    Endpoint Security 检测和阻止这些绕过。请注意，我已将这些问题反馈给 Apple，至少在 macOS 15（可能早期版本的 macOS 也已修复）中，似乎已得到修复。即便如此，您仍然可以根据本节中的代码检测其他本地漏洞。
- en: Manual Database Resets
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 手动重置数据库
- en: The first method of bypassing BTM was incredibly simple. Recall that [Chapter
    5](chapter5.xhtml) discussed sfltool, which ships with macOS and allows users
    to interface with the BTM database. One of its command line options, resetbtm,
    will clear the database, causing it to be rebuilt. Once this command is run, however,
    the system won’t deliver subsequent BTM alerts until it reboots, even though items
    can still persist.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过 BTM 的第一个方法非常简单。回想一下，[第 5 章](chapter5.xhtml)讨论了与 macOS 一起发布的 sfltool，用户可以通过它与
    BTM 数据库进行交互。它的一个命令行选项 resetbtm 会清空数据库，并导致其重建。然而，一旦运行此命令，系统不会发送后续的 BTM 警告，直到系统重启，尽管某些项目仍然可能存在。
- en: 'Thus, malware wanting to avoid generating BTM alerts could simply execute sfltool
    with the resetbtm command before executing its persistence code. The technique
    has yet to be observed in the wild but is easy to exploit, as shown in the following
    log message, generated after a manual database reset. These message shows that
    while the BTM daemon detected DazzleSpy’s persistent install, it decided not to
    post an advisory alert:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，恶意软件如果想避免触发 BTM 警告，可以在执行其持久化代码之前，简单地执行带有 resetbtm 参数的 sfltool 命令。虽然这个技术在实际中尚未被观察到，但它非常容易被利用，如以下日志信息所示，这些信息是在手动重置数据库后生成的。日志显示，尽管
    BTM 守护进程检测到 DazzleSpy 的持久化安装，但它决定不发布警告：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Under normal circumstances, users have no reason to reset the BTM database.
    So, we can thwart this exploit by subscribing to Endpoint Security process events
    and blocking the spawning of sfltool when it is executed with the resetbtm argument.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，用户没有理由重置 BTM 数据库。因此，我们可以通过订阅 Endpoint Security 进程事件，并阻止在执行带有 resetbtm
    参数的 sfltool 时启动它，从而防止此漏洞的利用。
- en: To detect the execution of processes, including sfltool, we can register for
    the ES_EVENT_TYPE_NOTIFY_EXEC event discussed in [Chapter 8](chapter8.xhtml).
    We can access the process’s path via the es_process_t process structure and extract
    its arguments with the es_exec_arg_count and es_exec_arg helper functions. Once
    you’ve extracted the path and arguments, simple string comparisons should tell
    you if the reported process event is a result of sfltool spawned with the resetbtm
    argument.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测进程的执行，包括 sfltool，我们可以注册 [第 8 章](chapter8.xhtml)中讨论的 ES_EVENT_TYPE_NOTIFY_EXEC
    事件。我们可以通过 es_process_t 进程结构访问进程路径，并通过 es_exec_arg_count 和 es_exec_arg 辅助函数提取其参数。一旦提取了路径和参数，简单的字符串比较应该能告诉我们，报告的进程事件是否是由带有
    resetbtm 参数的 sfltool 引发的。
- en: Of course, you’ll likely want to block these events, which you can do by registering
    for ES_EVENT_TYPE_AUTH_EXEC. This event’s callback will be invoked with an Endpoint
    Security message containing a pointer to an es_process_t structure. From this,
    you can extract both the path and the arguments of the process about to be spawned,
    then block the spawning by invoking the es_respond_auth_result function with a
    value of ES_AUTH_RESULT_DENY.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你很可能想要阻止这些事件，你可以通过注册ES_EVENT_TYPE_AUTH_EXEC来做到这一点。此事件的回调将被调用，并携带一个包含指向es_process_t结构的Endpoint
    Security消息。从中，你可以提取即将生成的进程的路径和参数，然后通过调用es_respond_auth_result函数，并传递ES_AUTH_RESULT_DENY的值来阻止进程的生成。
- en: Stop Signals
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 停止信号
- en: While researching the BTM subsystem, I came across another trivial way to bypass
    its alerts.^([12](#chapter9-12)) In short, malware could easily send a stop (SIGSTOP)
    signal to the BTM agent responsible for displaying the persistence advisory message
    to the user. Once this component halted, the malware could persist without the
    user being alerted. To detect and block this bypass, we can lean on Endpoint Security
    once again. As it’s extremely unlikely that a user would send a SIGSTOP signal
    to the BTM agent under normal circumstances, we can assume this event is malware
    attempting to subset the subsystem.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究BTM子系统时，我遇到了另一种轻微的绕过其警报的方式^([12](#chapter9-12))。简而言之，恶意软件可以轻松地向负责向用户显示持久性提示消息的BTM代理发送一个停止（SIGSTOP）信号。一旦该组件停止，恶意软件便可以在不引起用户警觉的情况下持久存在。为了检测并阻止这种绕过，我们可以再次依靠Endpoint
    Security。由于在正常情况下用户不太可能向BTM代理发送SIGSTOP信号，我们可以假设这个事件是恶意软件试图对该子系统进行攻击。
- en: The year following my presentation, researchers at Sentinel One uncovered malware
    taking a similar (albeit less elegant) approach. In their report,^([13](#chapter9-13))
    the researchers noted that the malicious code would continually send a kill signal
    to macOS’s Notification Center process to block the BTM’s persistence advisory
    message, which the system would normally display when the malware persisted.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我演讲后的第二年，Sentinel One的研究人员发现了恶意软件采取了类似（但不那么优雅）的方法。在他们的报告中^([13](#chapter9-13))，研究人员指出，恶意代码会不断向macOS的通知中心进程发送杀死信号，以阻止BTM的持久性提示消息，而该消息通常会在恶意软件持久存在时显示。
- en: We can detect signals with the ES_EVENT_TYPE_NOTIFY_SIGNAL event or, better
    yet, block signals altogether with the corresponding authorization event, ES_EVENT_TYPE_AUTH_SIGNAL.
    In [Listing 9-12](chapter9.xhtml#Lis9-12), we focus on the latter task.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过ES_EVENT_TYPE_NOTIFY_SIGNAL事件来检测信号，或者更好的是，通过相应的授权事件ES_EVENT_TYPE_AUTH_SIGNAL来完全阻止信号。在[Listing
    9-12](chapter9.xhtml#Lis9-12)中，我们将重点关注后者的任务。
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 9-12: Subscribing to authorization events for signal deliveries'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-12：订阅信号传递的授权事件
- en: Whenever a process attempts to send a signal, Endpoint Security will invoke
    the callback with a message containing an es_event_signal_t structure. The code
    extracts the type of signal ❶, as well as the source ❷ and target processes ❸.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个进程尝试发送信号时，Endpoint Security将调用回调，并带有一个包含es_event_signal_t结构的消息。代码将提取信号的类型❶，以及源进程❷和目标进程❸。
- en: We can check whether the signal is a SIGSTOP or SIGKILL and whether the process
    that would receive the signal is either the BTM agent or the Notification Center.
    If so, we simply deny the signal delivery by invoking es_respond_auth_result with
    the ES_AUTH_RESULT_DENY value ([Listing 9-13](chapter9.xhtml#Lis9-13)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查信号是否为SIGSTOP或SIGKILL，且接收信号的进程是否为BTM代理或通知中心。如果是，我们只需通过调用es_respond_auth_result并传递ES_AUTH_RESULT_DENY值来拒绝信号传递（参见[Listing
    9-13](chapter9.xhtml#Lis9-13)）。
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-13: Denying suspicious SIGSTOP or SIGKILL signals'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-13：拒绝可疑的SIGSTOP或SIGKILL信号
- en: Note that elsewhere in your code, you should probably look up and save the process
    ID for the BTM agent and Notification Center process, as you wouldn’t want to
    look it up each time a signal is delivered. You’d also likely want to log a message
    that includes information about the source process attempting to send the suspicious
    signal or else collect it for further examination.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在代码的其他地方，你可能需要查找并保存BTM代理和通知中心进程的进程ID，因为你不希望每次信号传递时都查找它。你还可能想要记录一条消息，其中包含有关试图发送可疑信号的源进程的信息，或者收集这些信息以便进一步检查。
- en: 'If you implement this code, compile it, run it, and then manually attempt to
    subvert the notifications from the BTM subsystem by stopping the agent, your actions
    should now fail:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实现了这段代码，编译并运行它，然后手动尝试通过停止代理来破坏BTM子系统的通知，你的操作应该会失败：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the terminal, we get the process ID of the BTM agent (590, in this instance).
    Then we use the kill command to send a SIGSTOP signal to the agent. This will
    trigger the delivery of an ES_EVENT_TYPE_AUTH_SIGNAL event to our program, which
    will deny it, resulting in the “operation not permitted” message.  ### Building
    a File Protector'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们获取BTM代理的进程ID（本例中为590）。然后，我们使用kill命令向该代理发送SIGSTOP信号。这将触发一个ES_EVENT_TYPE_AUTH_SIGNAL事件传递给我们的程序，我们会拒绝它，导致“操作不允许”的消息显示。###
    构建文件保护器
- en: I’ll wrap up the discussion of the Endpoint Security framework by developing
    a proof-of-concept file protector. You can find its full implementation in the
    protect function, in the *ESPlayground* project’s *protect.m* file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过开发一个概念验证的文件保护器来结束对端点安全框架的讨论。您可以在*ESPlayground*项目的*protect.m*文件中的保护函数中找到它的完整实现。
- en: Our code will monitor a specific directory (for example, the user’s home directory
    or the directory containing browser cookies) and allow only authorized processes
    to access it. Whenever a process attempts to access a file in the directory, Endpoint
    Security will trigger an authorization event, giving our code an opportunity to
    closely examine the process and decide whether to allow it. In this example, we’ll
    allow only platform and notarized binaries and block the rest.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将监控一个特定目录（例如，用户的主目录或包含浏览器cookie的目录），并仅允许授权的进程访问该目录。每当一个进程试图访问该目录中的文件时，端点安全会触发一个授权事件，给予我们的代码机会来仔细检查该进程并决定是否允许它。在这个例子中，我们只会允许平台和已验证的二进制文件，其他的则被阻止。
- en: This file protector is conceptually similar to Apple’s Transparency, Consent,
    and Control (TCC), but it adds another level of protection. After all, users may
    naively grant TCC permissions to malware, making previously protected files accessible,
    and malware often exploits or bypasses TCC itself, as in the case of the XCSSET
    malware.^([14](#chapter9-14)) Finally, you may want to provide authorized access
    (and detect unauthorized access) to files located outside TCC’s protected directories,
    such as the cookies files for certain third-party browsers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件保护器在概念上类似于苹果的透明度、同意与控制（TCC），但它增加了另一层保护。毕竟，用户可能天真地将TCC权限授予恶意软件，使得先前受保护的文件变得可访问，而恶意软件通常会利用或绕过TCC本身，就像XCSSET恶意软件的情况一样。^([14](#chapter9-14))
    最后，您可能希望为位于TCC保护目录之外的文件提供授权访问（并检测未经授权的访问），例如某些第三方浏览器的cookie文件。
- en: Earlier in this chapter, I discussed monitoring the logged-in user’s *Documents*
    directory via a notify event. The code in this section is similar, except it covers
    the user’s entire home directory and extends the list of events of interest to
    also include those related to attempted file deletions. Most notably, this code
    leverages Endpoint Security authorization events to proactively block untrusted
    access. As usual, we’ll start by specifying the Endpoint Security events of interest,
    creating an Endpoint Security client, setting up muting inversion, and finally
    subscribing to the events ([Listing 9-14](chapter9.xhtml#Lis9-14)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之前，我讨论了通过通知事件监控已登录用户的*Documents*目录。本节中的代码类似，只不过它覆盖了用户的整个主目录，并将感兴趣的事件列表扩展到包括与文件删除尝试相关的事件。最显著的是，这段代码利用了端点安全授权事件来主动阻止不受信任的访问。像往常一样，我们将首先指定感兴趣的端点安全事件，创建端点安全客户端，设置静音反转，最后订阅这些事件（[示例9-14](chapter9.xhtml#Lis9-14)）。
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 9-14: Setting up an Endpoint Security client to authorize file access'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 示例9-14：设置端点安全客户端以授权文件访问
- en: Several Endpoint Security authorization events relate to file access. Here,
    we use ES_EVENT_TYPE_AUTH_OPEN and ES_EVENT_TYPE_AUTH_UNLINK ❶, which give us
    the ability to authorize programs that attempt to open or delete files. The former
    event can detect a range of malware with either ransomware or stealer capabilities,
    while the latter event could perhaps detect and prevent malware with wiper capabilities
    that might try to delete or wipe important files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 几个端点安全授权事件与文件访问相关。在这里，我们使用ES_EVENT_TYPE_AUTH_OPEN和ES_EVENT_TYPE_AUTH_UNLINK
    ❶，它们使我们能够授权试图打开或删除文件的程序。前者事件可以检测到具有勒索软件或盗窃者能力的多种恶意软件，而后者事件则可能检测并防止具有擦除功能的恶意软件，它们可能试图删除或清除重要文件。
- en: After creating a new Endpoint Security client (whose handler block we’ll write
    shortly) ❷, the code sets up muting inversion ❸, given that we’re interested only
    in events related to the directory we’re about to specify. It dynamically builds
    a path to the logged-in user’s home directory, then invokes the es_mute_path API.
    Because we’ve inverted muting, this API tells the Endpoint Security subsystem
    to deliver events that occur within the specified path only. After the code calls
    es_subscribe, Endpoint Security will start delivering events by executing the
    handler block specified in the call to the es_new_client function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的 Endpoint Security 客户端（我们稍后将编写其处理块）❷之后，代码设置了静音反转 ❸，因为我们只对即将指定的目录中的事件感兴趣。它动态构建了一个指向登录用户主目录的路径，然后调用
    es_mute_path API。因为我们已经反转了静音，这个 API 会告诉 Endpoint Security 子系统只传递发生在指定路径中的事件。代码调用
    es_subscribe 后，Endpoint Security 将开始通过执行在 es_new_client 函数中指定的处理块来传递事件。
- en: How might we implement such a block? To keep things simple, let’s first assume
    we’ll allow any access ([Listing 9-15](chapter9.xhtml#Lis9-15)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何实现这样的处理块？为了简单起见，假设我们将允许任何访问（[清单 9-15](chapter9.xhtml#Lis9-15)）。
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 9-15: Allowing all file accesses'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-15：允许所有文件访问
- en: Recall that for ES_EVENT_TYPE_AUTH_OPEN events, Apple documentation states that
    we have to respond with the es_respond_flags_result function ❶. To tell the Endpoint
    Security subsystem to allow the event, we invoke this function with UINT32_MAX.
    For the ES_EVENT_TYPE_AUTH_UNLINK event, we respond using es_respond_auth_result,
    as usual ❷.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，对于 ES_EVENT_TYPE_AUTH_OPEN 事件，Apple 文档中指出我们必须使用 es_respond_flags_result
    函数 ❶ 来响应。为了告诉 Endpoint Security 子系统允许该事件，我们使用 UINT32_MAX 调用这个函数。对于 ES_EVENT_TYPE_AUTH_UNLINK
    事件，我们像往常一样使用 es_respond_auth_result 进行响应 ❷。
- en: On the flip side, [Listing 9-16](chapter9.xhtml#Lis9-16) shows the code to deny
    all file opens or deletions in the directory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，[清单 9-16](chapter9.xhtml#Lis9-16)展示了拒绝在目录中打开或删除文件的代码。
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 9-16: Denying all file accesses'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-16：拒绝所有文件访问
- en: The only changes from the code to allow all events is that we now call the es_respond_flags_result
    function ❶ with 0 as its third parameter and pass es_respond_auth_result the value
    ES_AUTH_RESULT_DENY ❷.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 允许所有事件的代码唯一的变化是，我们现在调用 es_respond_flags_result 函数 ❶，将其第三个参数设置为 0，并将 es_respond_auth_result
    的值传递为 ES_AUTH_RESULT_DENY ❷。
- en: Let’s expand this code to extract the path of the process responsible for the
    event, as well as the path of the file the process is trying to open or delete
    ([Listing 9-17](chapter9.xhtml#Lis9-17)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展这段代码，提取负责该事件的进程路径，以及进程尝试打开或删除的文件路径（[清单 9-17](chapter9.xhtml#Lis9-17)）。
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 9-17: Extracting process paths and filepaths'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-17：提取进程路径和文件路径
- en: We can find the responsible process’s path in the process member of the message
    structure for any Endpoint Security event ❶, but other information is event specific.
    Thus, we extract the file in the handler for each event type. For ES_EVENT_TYPE_AUTH_OPEN
    events, we find it in an es_event_open_t structure ❷, and for ES_EVENT_TYPE_AUTH_UNLINK
    events, it lives in an es_event_unlink_t structure ❸.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何 Endpoint Security 事件的消息结构中的进程成员中找到负责的进程路径 ❶，但其他信息是特定于事件的。因此，我们在每种事件类型的处理块中提取文件。对于
    ES_EVENT_TYPE_AUTH_OPEN 事件，我们在 es_event_open_t 结构体中找到它 ❷，而对于 ES_EVENT_TYPE_AUTH_UNLINK
    事件，它位于 es_event_unlink_t 结构体中 ❸。
- en: Now we should allow or deny file openings and deletions based on some rules,
    depending on what we’re attempting to protect. Recall that the MacStealer malware
    attempts to steal browser cookies. Generally speaking, no third-party process
    other than the browser should access its cookies. Thus, you may simply want to
    implement a deny rule with an exception to allow the browser itself. Via the process
    ID, path, or, better yet, code signing information, it should be easy to identify
    whether the browser is the responsible process.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该根据某些规则来允许或拒绝文件的打开和删除，具体取决于我们要保护的内容。回想一下，MacStealer 恶意软件试图窃取浏览器的 Cookie。一般来说，除了浏览器，任何第三方进程都不应该访问浏览器的
    Cookie。因此，您可能只是想实现一个拒绝规则，并设置一个例外，允许浏览器本身访问。通过进程 ID、路径，或者更好的是，代码签名信息，应该很容易识别是否是浏览器在执行该进程。
- en: If you’re protecting files in the user’s home directory, this kind of “deny
    all with exceptions” approach would likely impact the usability of the system.
    Thus, you may want to use heuristics, such as authorizing only notarized applications,
    those from the App Store, or platform binaries. However, malware sometimes delegates
    actions to shell commands, which are platform binaries, so you’ll likely want
    to examine the process hierarchy of the responsible process to make sure it’s
    not being abused in malicious ways.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在保护用户主目录中的文件，这种“拒绝所有但有例外”方法可能会影响系统的可用性。因此，你可能需要使用启发式方法，比如仅授权公证的应用程序、来自App
    Store的应用程序或平台二进制文件。然而，恶意软件有时会将操作委托给Shell命令，而这些命令是平台二进制文件，因此你可能需要检查相关进程的进程层级，以确保它没有被恶意滥用。
- en: In this example, we’ll keep things simple by allowing only platform or notarized
    binaries to access the current user’s home directory ([Listing 9-18](chapter9.xhtml#Lis9-18)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过只允许平台或公证二进制文件访问当前用户的主目录来简化处理（见[列表9-18](chapter9.xhtml#Lis9-18)）。
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 9-18: Granting file access for platform and notarized processes only'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9-18：仅授予平台和公证进程的文件访问权限
- en: We check whether the responsible process either is a platform binary or has
    been notarized. Checking whether a process is a platform binary is as easy as
    checking the is_platform_binary member of the process structure found in the delivered
    Endpoint Security message. In [Chapter 3](chapter3.xhtml), we used Apple’s code
    signing APIs to figure out whether a process is notarized; we won’t cover this
    process again here, except to note that we’ve created a simple helper function
    named isNotarized that uses the responsible process’s audit token to check its
    notarization status. (If you’re interested in seeing the full implementation of
    this function, see the *protect.m* file in the *ESPlayground* project.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查相关进程是否是平台二进制文件或已经过公证。检查一个进程是否是平台二进制文件，就像检查传递的Endpoint Security消息中进程结构的is_platform_binary成员一样简单。在[第3章](chapter3.xhtml)中，我们使用了Apple的代码签名API来判断一个进程是否经过公证；这里我们不再重复这个过程，除了提到我们创建了一个简单的辅助函数isNotarized，它使用相关进程的审计令牌来检查其公证状态。（如果你有兴趣查看这个函数的完整实现，可以查看*ESPlayground*项目中的*protect.m*文件。）
- en: It’s also worth pointing out that the logical OR operator will short-circuit
    if the first condition is true, so we put the platform binary check first. Because
    it’s a simple check against a Boolean value in a structure, it’s less computationally
    intensive than a full notarization check, so we perform the more efficient check
    first and perform the second check only if needed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 同时值得指出的是，逻辑“或”运算符如果第一个条件为真，会短路，因此我们将平台二进制检查放在前面。因为它只是对结构中的布尔值进行简单检查，这比完整的公证检查计算量要小，所以我们先执行更高效的检查，仅在需要时才执行第二个检查。
- en: 'Let’s compile the *ESPlayground* project and run it with the -protect flag
    to trigger this logic. The tool detects the use of built-in macOS commands to
    examine the home directory and delete a file within the *Documents* directory
    but still allows the actions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译*ESPlayground*项目并使用-protect标志运行它，以触发这一逻辑。该工具检测到使用内置的macOS命令来检查用户主目录并删除*Documents*目录中的文件，但仍然允许这些操作：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now consider WindTail, a persistent cyber-espionage implant that seeks to enumerate
    and exfiltrate files in the user’s *Documents* directory. If we install it in
    a virtual machine, we can see the malware (called *Final_Presentation.app*) attempts
    to enumerate the files in the user’s documents directory. We detect this access,
    and because WindTail’s binary (called *usrnode* in this example) isn’t trusted,
    we block access to the directory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下WindTail，这是一个持久的网络间谍植入程序，旨在枚举并外泄用户*Documents*目录中的文件。如果我们将它安装在虚拟机中，我们可以看到恶意软件（名为*Final_Presentation.app*）试图枚举用户文档目录中的文件。我们检测到这种访问行为，并且因为WindTail的二进制文件（在这个例子中叫做*usrnode*）不被信任，我们阻止了对该目录的访问：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s hard to overstate the importance of Endpoint Security for building tools
    capable of detecting and protecting against Mac malware. In recent years, Apple
    has added more events (such as ES_EVENT_TYPE_NOTIFY_XP_MALWARE _DETECTED in macOS
    13 and ES_EVENT_TYPE_NOTIFY_GATEKEEPER_USER_OVERRIDE in macOS 15), and powerful
    capabilities to the framework, so when building any security tool, using Endpoint
    Security should be your first consideration.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 无法过分强调端点安全对于构建能够检测和防护 Mac 恶意软件的工具的重要性。近年来，苹果在该框架中添加了更多事件（如 macOS 13 中的 ES_EVENT_TYPE_NOTIFY_XP_MALWARE_DETECTED
    和 macOS 15 中的 ES_EVENT_TYPE_NOTIFY_GATEKEEPER_USER_OVERRIDE），并且增强了强大的功能，因此，在构建任何安全工具时，使用端点安全应该是你首先考虑的事项。
- en: Conclusion
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, I covered advanced Endpoint Security topics, including muting,
    inverted muting, and authorization events. The examples showed you how to use
    these capabilities to build tools capable of detecting malware when it performs
    unauthorized actions, as well as proactively thwarting the action in the first
    place.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了高级端点安全主题，包括静音、反向静音和授权事件。示例展示了如何使用这些功能构建能够检测恶意软件在执行未授权操作时的工具，并且主动阻止这些行为。
- en: This chapter wraps up [Part II](part2.xhtml) of this book, dedicated to topics
    of real-time monitoring capabilities. [Part III](part3.xhtml) will put together
    the many topics covered in [Parts I](part1.xhtml) and [II](part2.xhtml) as we
    explore the internals of Objective-See’s most popular macOS malware detection
    tools.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了本书的[第二部分](part2.xhtml)，专注于实时监控能力的主题。[第三部分](part3.xhtml)将结合[第一部分](part1.xhtml)和[第二部分](part2.xhtml)中涉及的多个主题，探索
    Objective-See 最受欢迎的 macOS 恶意软件检测工具的内部工作原理。
- en: Notes
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[  1](#chapter9_1).  See “Client,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/endpointsecurity<wbr>/client*](https://developer.apple.com/documentation/endpointsecurity/client).'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter9_1).  请参阅 “Client”，Apple 开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/endpointsecurity<wbr>/client*](https://developer.apple.com/documentation/endpointsecurity/client).'
- en: '[  2](#chapter9_2).  Pete Markowsky (@PeteMarkowsky), “A small list of things
    you can do with this. 1\. lockdown access to your SAAS bearer tokens to specific
    apps . . . ,” X, May 2, 2023, [*https://<wbr>x<wbr>.com<wbr>/PeteMarkowsky<wbr>/status<wbr>/1653453951839109133*](https://x.com/PeteMarkowsky/status/1653453951839109133).'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter9_2).  Pete Markowsky (@PeteMarkowsky), “你可以用这个做的一小部分事情。1\. 将对你的
    SAAS 承载令牌的访问锁定到特定应用程序……”，X，2023年5月2日，[*https://<wbr>x<wbr>.com<wbr>/PeteMarkowsky<wbr>/status<wbr>/1653453951839109133*](https://x.com/PeteMarkowsky/status/1653453951839109133)。'
- en: '[  3](#chapter9_3).  See [*https://<wbr>github<wbr>.com<wbr>/google<wbr>/santa<wbr>/blob<wbr>/8a7f1142a87a48a48271c78c94f830d8efe9afa9<wbr>/Source<wbr>/santad<wbr>/EventProviders<wbr>/SNTEndpointSecurityTamperResistance<wbr>.mm#L15*](https://github.com/google/santa/blob/8a7f1142a87a48a48271c78c94f830d8efe9afa9/Source/santad/EventProviders/SNTEndpointSecurityTamperResistance.mm#L15).'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter9_3).  请参阅 [*https://<wbr>github<wbr>.com<wbr>/google<wbr>/santa<wbr>/blob<wbr>/8a7f1142a87a48a48271c78c94f830d8efe9afa9<wbr>/Source<wbr>/santad<wbr>/EventProviders<wbr>/SNTEndpointSecurityTamperResistance<wbr>.mm#L15*](https://github.com/google/santa/blob/8a7f1142a87a48a48271c78c94f830d8efe9afa9/Source/santad/EventProviders/SNTEndpointSecurityTamperResistance.mm#L15).'
- en: '[  4](#chapter9_4).  Shilpesh Trivedi, “MacStealer: Unveiling a Newly Identified
    MacOS-Based Stealer Malware,” *Uptycs*, March 24, 2023, [*https://<wbr>www<wbr>.uptycs<wbr>.com<wbr>/blog<wbr>/macstealer<wbr>-command<wbr>-and<wbr>-control<wbr>-c2<wbr>-malware*](https://www.uptycs.com/blog/macstealer-command-and-control-c2-malware).'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter9_4).  Shilpesh Trivedi, “MacStealer: 揭示一款新识别的基于 MacOS 的窃取恶意软件，”
    *Uptycs*，2023年3月24日，[*https://<wbr>www<wbr>.uptycs<wbr>.com<wbr>/blog<wbr>/macstealer<wbr>-command<wbr>-and<wbr>-control<wbr>-c2<wbr>-malware*](https://www.uptycs.com/blog/macstealer-command-and-control-c2-malware)。'
- en: '[  5](#chapter9_5).  You can read more about these notarization bypass flaws
    in Patrick Wardle, “All Your Macs Are Belong to Us,” Objective-See, April 26,
    2021, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x64<wbr>.html*](https://objective-see.org/blog/blog_0x64.html),
    and in Patrick Wardle, “Where’s the Interpreter!?,” Objective-See, December 22,
    2021, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x6A<wbr>.html*](https://objective-see.org/blog/blog_0x6A.html).'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter9_5).  你可以在 Patrick Wardle 的文章《All Your Macs Are Belong to Us》中阅读更多关于这些认证绕过漏洞的内容，Objective-See，2021年4月26日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x64<wbr>.html*](https://objective-see.org/blog/blog_0x64.html)，以及在
    Patrick Wardle 的另一篇文章《Where’s the Interpreter!?》，Objective-See，2021年12月22日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x6A<wbr>.html*](https://objective-see.org/blog/blog_0x6A.html)。'
- en: '[  6](#chapter9_6).  Objective-See Foundation (@objective_see), “Did you know
    BlockBlock . . . ,” X, March 2, 2022, [*https://<wbr>x<wbr>.com<wbr>/objective<wbr>_see<wbr>/status<wbr>/1499172783502204929*](https://x.com/objective_see/status/1499172783502204929).'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[6](#chapter9_6).  Objective-See基金会（@objective_see），“你知道BlockBlock . . . 吗？”，X，2022年3月2日，[*https://<wbr>x<wbr>.com<wbr>/objective<wbr>_see<wbr>/status<wbr>/1499172783502204929*](https://x.com/objective_see/status/1499172783502204929)。'
- en: '[  7](#chapter9_7).  “ES_EVENT_TYPE_AUTH_EXEC,” Apple Developer Documentation,
    [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/endpointsecurity<wbr>/es<wbr>_event<wbr>_type<wbr>_t<wbr>/es<wbr>_event<wbr>_type<wbr>_auth<wbr>_exec*](https://developer.apple.com/documentation/endpointsecurity/es_event_type_t/es_event_type_auth_exec).'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[7](#chapter9_7).  “ES_EVENT_TYPE_AUTH_EXEC”，苹果开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/endpointsecurity<wbr>/es<wbr>_event<wbr>_type<wbr>_t<wbr>/es<wbr>_event<wbr>_type<wbr>_auth<wbr>_exec*](https://developer.apple.com/documentation/endpointsecurity/es_event_type_t/es_event_type_auth_exec)。'
- en: '[  8](#chapter9_8).  See [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/BlockBlock*](https://github.com/objective-see/BlockBlock).'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[8](#chapter9_8).  参见 [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/BlockBlock*](https://github.com/objective-see/BlockBlock)。'
- en: '[  9](#chapter9_9).  You can read about such attacks uncovered by yours truly
    in Patrick Wardle, “Dylib Hijacking on OS X,” VirusBulletin, March 19, 2015, [*https://<wbr>www<wbr>.virusbulletin<wbr>.com<wbr>/blog<wbr>/2015<wbr>/03<wbr>/paper<wbr>-dylib<wbr>-hijacking<wbr>-os<wbr>-x*](https://www.virusbulletin.com/blog/2015/03/paper-dylib-hijacking-os-x).'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[9](#chapter9_9).  你可以阅读由我揭示的这些攻击，参见Patrick Wardle，“OS X上的Dylib劫持”，病毒公报，2015年3月19日，[*https://<wbr>www<wbr>.virusbulletin<wbr>.com<wbr>/blog<wbr>/2015<wbr>/03<wbr>/paper<wbr>-dylib<wbr>-hijacking<wbr>-os<wbr>-x*](https://www.virusbulletin.com/blog/2015/03/paper-dylib-hijacking-os-x)。'
- en: '[10](#chapter9_10).  The code in [Listing 9-9](chapter9.xhtml#Lis9-9) is inspired
    by Jeff Johnson, “Detect App Translocation,” Lapcat Software, July 26, 2016, [*https://<wbr>lapcatsoftware<wbr>.com<wbr>/articles<wbr>/detect<wbr>-app<wbr>-translocation<wbr>.html*](https://lapcatsoftware.com/articles/detect-app-translocation.html).'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[10](#chapter9_10).  [列表9-9](chapter9.xhtml#Lis9-9)中的代码灵感来自Jeff Johnson， “检测应用程序转移”，Lapcat软件公司，2016年7月26日，[*https://<wbr>lapcatsoftware<wbr>.com<wbr>/articles<wbr>/detect<wbr>-app<wbr>-translocation<wbr>.html*](https://lapcatsoftware.com/articles/detect-app-translocation.html)。'
- en: '[11](#chapter9_11).  See [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/BlockBlock<wbr>/blob<wbr>/master<wbr>/Daemon<wbr>/Daemon<wbr>/Plugins<wbr>/Processes<wbr>.m*](https://github.com/objective-see/BlockBlock/blob/master/Daemon/Daemon/Plugins/Processes.m).'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[11](#chapter9_11).  参见 [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/BlockBlock<wbr>/blob<wbr>/master<wbr>/Daemon<wbr>/Daemon<wbr>/Plugins<wbr>/Processes<wbr>.m*](https://github.com/objective-see/BlockBlock/blob/master/Daemon/Daemon/Plugins/Processes.m)。'
- en: '[12](#chapter9_12).  Patrick Wardle, “Demystifying (& Bypassing) macOS’s Background
    Task Management,” presented at DefCon, Las Vegas, August 12, 2023, [*https://<wbr>speakerdeck<wbr>.com<wbr>/patrickwardle<wbr>/demystifying<wbr>-and<wbr>-bypassing<wbr>-macoss<wbr>-background<wbr>-task<wbr>-management*](https://speakerdeck.com/patrickwardle/demystifying-and-bypassing-macoss-background-task-management).'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[12](#chapter9_12).  Patrick Wardle，“揭开macOS后台任务管理的神秘面纱（及绕过方法）”，在DefCon大会上展示，拉斯维加斯，2023年8月12日，[*https://<wbr>speakerdeck<wbr>.com<wbr>/patrickwardle<wbr>/demystifying<wbr>-and<wbr>-bypassing<wbr>-macoss<wbr>-background<wbr>-task<wbr>-management*](https://speakerdeck.com/patrickwardle/demystifying-and-bypassing-macoss-background-task-management)。'
- en: '[13](#chapter9_13).  Phil Stokes, “Backdoor Activator Malware Running Rife
    Through Torrents of macOS Apps,” Sentinel One, February 1, 2024, [*https://<wbr>www<wbr>.sentinelone<wbr>.com<wbr>/blog<wbr>/backdoor<wbr>-activator<wbr>-malware<wbr>-running<wbr>-rife<wbr>-through<wbr>-torrents<wbr>-of<wbr>-macos<wbr>-apps<wbr>/*](https://www.sentinelone.com/blog/backdoor-activator-malware-running-rife-through-torrents-of-macos-apps/).'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[13](#chapter9_13).  Phil Stokes，“后门激活器恶意软件在macOS应用程序的种子中广泛传播”，Sentinel One，2024年2月1日，[*https://<wbr>www<wbr>.sentinelone<wbr>.com<wbr>/blog<wbr>/backdoor<wbr>-activator<wbr>-malware<wbr>-running<wbr>-rife<wbr>-through<wbr>-torrents<wbr>-of<wbr>-macos<wbr>-apps<wbr>/*](https://www.sentinelone.com/blog/backdoor-activator-malware-running-rife-through-torrents-of-macos-apps/)。'
- en: '[14](#chapter9_14).  Jaron Bradley, “Zero-Day TCC Bypass Discovered in XCSSET
    Malware,” Jamf, May 24, 2021, [*https://<wbr>www<wbr>.jamf<wbr>.com<wbr>/blog<wbr>/zero<wbr>-day<wbr>-tcc<wbr>-bypass<wbr>-discovered<wbr>-in<wbr>-xcsset<wbr>-malware<wbr>/*](https://www.jamf.com/blog/zero-day-tcc-bypass-discovered-in-xcsset-malware/).'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14](#chapter9_14).  Jaron Bradley，“XCSSET恶意软件中发现的零日TCC绕过”，Jamf，2021年5月24日，[*https://<wbr>www<wbr>.jamf<wbr>.com<wbr>/blog<wbr>/zero<wbr>-day<wbr>-tcc<wbr>-bypass<wbr>-discovered<wbr>-in<wbr>-xcsset<wbr>-malware<wbr>/*](https://www.jamf.com/blog/zero-day-tcc-bypass-discovered-in-xcsset-malware/)。'
