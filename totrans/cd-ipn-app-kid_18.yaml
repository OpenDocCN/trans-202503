- en: '15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MAKING SCHOOLHOUSE SKATEBOARDER A REAL GAME
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we’ll add our hero, the skateboarder. We’ll use a little trick
    to make it look like she’s moving: we’ll move the ground beneath her. Then we’ll
    add jumping to the game so that when the player taps on the screen, the skater
    jumps. To do all of this, we’ll create our own custom sprite subclass, and we’ll
    add a game loop where all the action happens.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OUR HERO, THE SKATEBOARDER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to add the skater to our game. As we did with the background image,
    we’ll create a sprite, position it on the screen, and then add it to the scene.
    To make a sprite, we use the SKSpriteNode class.
  prefs: []
  type: TYPE_NORMAL
- en: Our skater will need some additional properties to keep track of things, such
    as her current velocity (speed) and whether she is on the ground. Since SKSpriteNode
    doesn’t have these properties, we’ll create our own subclass of SKSpriteNode called
    Skater . This will allow us to add whatever extra properties we want to this sprite,
    in addition to all of the built-in SKSpriteNode properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A SKATER SPRITE CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: MAKING SCHOOLHOUSE SKATEBOARDER A REAL GAME
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we’ll add our hero, the skateboarder. We’ll use a little trick
    to make it look like she’s moving: we’ll move the ground beneath her. Then we’ll
    add jumping to the game so that when the player taps on the screen, the skater
    jumps. To do all of this, we’ll create our own custom sprite subclass, and we’ll
    add a game loop where all the action happens.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OUR HERO, THE SKATEBOARDER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to add the skater to our game. As we did with the background image,
    we’ll create a sprite, position it on the screen, and then add it to the scene.
    To make a sprite, we use the SKSpriteNode class.
  prefs: []
  type: TYPE_NORMAL
- en: Our skater will need some additional properties to keep track of things, such
    as her current velocity (speed) and whether she is on the ground. Since SKSpriteNode
    doesn’t have these properties, we’ll create our own subclass of SKSpriteNode called
    Skater . This will allow us to add whatever extra properties we want to this sprite,
    in addition to all of the built-in SKSpriteNode properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A SKATER SPRITE CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, we’ll add our hero, the skateboarder. We’ll use a little trick
    to make it look like she’s moving: we’ll move the ground beneath her. Then we’ll
    add jumping to the game so that when the player taps on the screen, the skater
    jumps. To do all of this, we’ll create our own custom sprite subclass, and we’ll
    add a game loop where all the action happens.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OUR HERO, THE SKATEBOARDER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to add the skater to our game. As we did with the background image,
    we’ll create a sprite, position it on the screen, and then add it to the scene.
    To make a sprite, we use the SKSpriteNode class.
  prefs: []
  type: TYPE_NORMAL
- en: Our skater will need some additional properties to keep track of things, such
    as her current velocity (speed) and whether she is on the ground. Since SKSpriteNode
    doesn’t have these properties, we’ll create our own subclass of SKSpriteNode called
    Skater . This will allow us to add whatever extra properties we want to this sprite,
    in addition to all of the built-in SKSpriteNode properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A SKATER SPRITE CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll add our hero, the skateboarder. We’ll use a little trick
    to make it look like she’s moving: we’ll move the ground beneath her. Then we’ll
    add jumping to the game so that when the player taps on the screen, the skater
    jumps. To do all of this, we’ll create our own custom sprite subclass, and we’ll
    add a game loop where all the action happens.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OUR HERO, THE SKATEBOARDER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to add the skater to our game. As we did with the background image,
    we’ll create a sprite, position it on the screen, and then add it to the scene.
    To make a sprite, we use the SKSpriteNode class.
  prefs: []
  type: TYPE_NORMAL
- en: Our skater will need some additional properties to keep track of things, such
    as her current velocity (speed) and whether she is on the ground. Since SKSpriteNode
    doesn’t have these properties, we’ll create our own subclass of SKSpriteNode called
    Skater . This will allow us to add whatever extra properties we want to this sprite,
    in addition to all of the built-in SKSpriteNode properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A SKATER SPRITE CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**OUR HERO, THE SKATEBOARDER**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to add the skater to our game. As we did with the background image,
    we’ll create a sprite, position it on the screen, and then add it to the scene.
    To make a sprite, we use the SKSpriteNode class.
  prefs: []
  type: TYPE_NORMAL
- en: Our skater will need some additional properties to keep track of things, such
    as her current velocity (speed) and whether she is on the ground. Since SKSpriteNode
    doesn’t have these properties, we’ll create our own subclass of SKSpriteNode called
    Skater . This will allow us to add whatever extra properties we want to this sprite,
    in addition to all of the built-in SKSpriteNode properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A SKATER SPRITE CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to add the skater to our game. As we did with the background image,
    we’ll create a sprite, position it on the screen, and then add it to the scene.
    To make a sprite, we use the SKSpriteNode class.
  prefs: []
  type: TYPE_NORMAL
- en: Our skater will need some additional properties to keep track of things, such
    as her current velocity (speed) and whether she is on the ground. Since SKSpriteNode
    doesn’t have these properties, we’ll create our own subclass of SKSpriteNode called
    Skater . This will allow us to add whatever extra properties we want to this sprite,
    in addition to all of the built-in SKSpriteNode properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A SKATER SPRITE CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Our skater will need some additional properties to keep track of things, such
    as her current velocity (speed) and whether she is on the ground. Since SKSpriteNode
    doesn’t have these properties, we’ll create our own subclass of SKSpriteNode called
    Skater . This will allow us to add whatever extra properties we want to this sprite,
    in addition to all of the built-in SKSpriteNode properties.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A SKATER SPRITE CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING A SKATER SPRITE CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: To create the Skater class, right-click the *SchoolhouseSkateboarder* folder
    in the Project navigator and choose **New File…** . On the next screen, choose
    the template called **Cocoa Touch Class** in the Source section of the iOS templates,
    and then click **Next** . Type Skater for the class name and SKSpriteNode for
    the class we want to subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** , and then on the final screen, click **Create** to confirm the
    file location. Now you’ll see your new Skater class has appeared in both the Project
    navigator and the Editor pane.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING SPRITEKIT**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a subclass of a SpriteKit class, such as SKSpriteNode , you
    need to add a statement at the top of your code to import SpriteKit for this class
    instead of UIKit. To import the SpriteKit library, change the line at the top
    of your new Skater class (*Skater.swift* ) from this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing SpriteKit makes all the SpriteKit classes and methods available within
    the *Skater.swift* file. If you try to use SpriteKit classes or methods in a file
    without first importing SpriteKit, you’ll see errors like “Use of undeclared type.”
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING CUSTOM PROPERTIES TO THE SKATER CLASS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve imported the SpriteKit library, let’s add some properties to
    our new Skater class inside the existing braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Skater.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Soon we’ll be adding code to our game scene to make the skater jump, so we need
    these properties to keep track of the skater’s movements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable named velocity , a CGPoint , is initialized with CGPoint.zero
    at ➊ . This is a shortcut to specify a point with x and y values both equal to
    0.0 . It’s the same as using CGPoint(x: 0.0, y: 0.0) . Velocity means speed, so
    this variable will keep track of the skater’s speed in both the x-direction (right-left)
    and y-direction (up-down). For example, when the skater jumps up, the velocity’s
    y value will determine how fast she is moving upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable minimumY is a CGFloat that we’ll use to specify the y-position
    of the ground ➋ . So when the skater jumps, we know what y-position she should
    stop at when coming back down.
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable jumpSpeed is a CGFloat that we’ll use to specify how fast the skater
    can jump ➌ . We’ve given it an initial value of 20.0 . This is just a guess for
    now. We may have to change this value later if we find that the skater jumps too
    quickly or too slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that we specified the type CGFloat when we wrote var minimumY: CGFloat
    = 0.0 and var jumpSpeed: CGFloat = 20.0 . You will always need to do this when
    creating a CGFloat variable or constant, or else Xcode will infer that the type
    is Double* .'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the variable isOnGround is a Bool that we’ll use to keep track of whether
    the skater is currently on the ground ➍ . If she’s on the ground, she can jump.
    If she’s not on the ground (that is, if she’s already jumping), she can’t jump
    again until she comes back down.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING AN INSTANCE OF THE SKATER IN THE SCENE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to switch back to our *GameScene.swift* file and add a skater
    sprite. Add the following code just inside the GameScene class’s braces, above
    the didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: This line creates a new class property named skater , which is an instance of
    our new class Skater . It uses the image *skater.png* , which you should have
    already downloaded and added to your asset catalog in [Chapter 14](text00026.html#ch14)
    . Since skater is a class property (created inside the class declaration but outside
    of any function), it will be available to use inside any method within the GameScene
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that creating a sprite doesn’t make it show up on the screen. You’ll always
    need to add the sprite as a child of the scene or as a child of another sprite,
    which we’ll do soon. You’ll see this common pattern with sprites: 1) create the
    sprite, 2) position the sprite and set any initial values, and 3) call the addChild()
    method to add the sprite to the scene. So far we’ve just created the sprite. Next,
    we’ll set the sprite’s position and values before calling the addChild() method
    to add the skater to our scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SETTING UP THE SKATER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: To set our skater sprite’s position and other initial values, we’ll create a
    separate method called resetSkater() . We want to have this setup code in a separate
    method so that any time we need to reset the skater to her initial position (such
    as when the game has to restart), we can reuse this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following method below the existing didMove(to:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE904]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE905]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE906]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE907]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE908]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE909]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE910]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE911]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE912]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE913]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE914]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE915]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE916]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE917]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE918]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE919]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE920]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE921]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE922]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE923]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE924]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE925]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE926]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE927]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE928]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE929]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE930]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE931]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE932]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE933]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE934]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE935]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE936]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE937]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE938]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE939]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE940]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE941]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE942]'
  prefs: []
  type: TYPE_PRE
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE943]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE944]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE945]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE946]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE947]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE948]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE949]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE950]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE951]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE952]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE953]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE954]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE955]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE956]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE957]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE958]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE959]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE960]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE961]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE962]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE963]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE964]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE965]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: This method performs some basic setup for the skater sprite. First, we determine
    the skater’s x-position, skaterX , by finding the x value at the middle of the
    scene’s frame with frame.midX and dividing that by two ➊ . This will put the skater
    in the left side of the scene, which will give the player time to respond to obstacles
    that come from the right side. If we position the skater exactly in the middle
    of the screen, the player might not have enough time to see the obstacles before
    they have to jump over them. Remember, the skater will stay in the same x-position
    on the screen since we will be animating the ground beneath her to make it look
    like she’s moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE966]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE967]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE968]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE969]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE970]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE971]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE972]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE973]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE974]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE975]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE976]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE977]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE978]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE979]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE980]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE981]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE982]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE983]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE984]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE985]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE986]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE987]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE988]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE989]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE990]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE991]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE992]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE993]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE994]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE995]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE996]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE997]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE998]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE999]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1000]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1001]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1002]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1003]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1004]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1005]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1006]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1007]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1008]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1009]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1010]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1011]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we calculate the y-position for our skater by adding half of the skater
    sprite’s height to 64\. In SpriteKit, y-positions increase as you go up the screen
    (unlike in UIKit apps, where a y-position of 0.0 represents the top of the screen).
    Also, when we set a sprite’s position, we’re actually setting where the *center*
    of that sprite should be. Therefore, if we place a sprite at a y-position of 0.0
    , half of it would be on the screen, and half would be off. So to place an object
    at the bottom of the screen (but not hanging off the screen), we need to set its
    y-position to half of its height. Finally, to account for the height of our sidewalk,
    which will be 64, we add 64 to the y-position of the skater. [Figure 15-1](text00027.html#ch15fig1)
    shows how y-positions work in SpriteKit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1012]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1013]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1014]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1015]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1016]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1017]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1018]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1019]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1020]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1021]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1022]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1023]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1024]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1025]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1026]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1027]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1028]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1029]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1030]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1031]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1032]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1033]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1034]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1035]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1036]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1037]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1038]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1039]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1040]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1041]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1042]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1043]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1044]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1045]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1046]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1047]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1048]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1049]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1050]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1051]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1052]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1053]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1054]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1055]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1056]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1057]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-1: Setting the y-position of a sprite*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1058]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1059]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1060]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1061]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1062]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1063]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1064]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1065]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1066]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1067]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1068]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1069]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1070]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1071]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1072]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1073]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1074]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1075]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1076]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1077]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1078]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1079]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1080]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the skater’s x- and y-positions, we set our skater’s
    starting position by creating a CGPoint that uses these values ➌ .
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1081]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1082]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1083]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1084]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1085]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1086]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1087]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1088]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1089]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1090]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1091]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1092]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1093]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1094]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1095]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1096]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1097]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1098]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1099]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1100]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1101]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1102]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1103]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The zPosition of the skater sprite is set to 10 ➍ . To understand zPosition
    , imagine you’re assembling a stack of papers. Papers that are higher up in the
    stack have a higher zPosition and will be *on top* of anything that has a lower
    zPosition . It’s possible for two or more sprites to have the same zPosition ,
    in which case the sprite that was added later would be on top.
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1104]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1105]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1106]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1107]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1108]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1109]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1110]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1111]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1112]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1113]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1114]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1115]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1116]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1117]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1118]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1119]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1120]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1121]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1122]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1123]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1124]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1125]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1126]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: When we added our background sprite, we didn’t set a zPosition , so it’s at
    the default zPosition of 0 (the bottom of the stack). Since we want our skater
    to be on top of the background image, we’re setting a zPosition of 10 . This way,
    we still have some room to put other objects in between the skater and the background
    (unlike if we’d set the skater’s ZPosition to just 1 ). If we wanted to add a
    dog walking around the scene, we could put it at a zPosition of 5 , and it would
    be behind the skater but in front of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1127]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1128]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1129]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1130]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1131]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1132]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1133]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1134]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1135]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1136]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1137]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1138]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1139]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1140]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1141]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1142]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1143]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1144]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1145]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1146]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1147]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1148]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1149]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1150]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1151]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1152]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1153]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1154]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1155]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1156]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1157]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1158]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1159]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1160]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1161]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1162]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1163]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1164]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1165]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1166]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1167]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1168]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1169]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1170]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1171]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1172]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at ➎ , we set the skater sprite’s minimumY variable to be the same
    as her y-position. Over the course of playing the game, the skater will jump,
    so her y-position will change, but now we’ll always have this minimumY variable
    to indicate what the skater’s y-position should be when she’s on the ground.
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1173]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1174]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1175]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1176]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1177]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1178]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1179]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1180]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1181]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1182]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1183]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1184]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1185]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1186]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1187]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1188]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1189]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1190]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1191]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1192]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1193]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1194]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1195]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SEEING THE SKATER ON THE SCREEN**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1196]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1197]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1198]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1199]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1200]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1201]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1202]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1203]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1204]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1205]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1206]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1207]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1208]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1209]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1210]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1211]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1212]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1213]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1214]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1215]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1216]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1217]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1218]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready to add the skater to the scene! Add these lines inside the
    didMove(to:) method, below the existing code in that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1219]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1220]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1221]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1222]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1223]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1224]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1225]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1226]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1227]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1228]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1229]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1230]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1231]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1232]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1233]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1234]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1235]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1236]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1237]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1238]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1239]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1240]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1241]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1242]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1243]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1244]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1245]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1246]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1247]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1248]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1249]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1250]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1251]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1252]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1253]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1254]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1255]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1256]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1257]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1258]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1259]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1260]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1261]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1262]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1263]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1264]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when the game scene is first presented, our skater sprite will be set up
    and added as a child of the scene. Your entire GameScene class should now look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1265]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1266]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1267]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1268]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1269]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1270]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1271]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1272]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1273]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1274]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1275]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1276]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1277]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1278]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1279]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1280]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1281]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1282]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1283]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1284]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1285]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1286]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1287]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1288]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1289]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1290]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1291]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1292]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1293]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1294]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1295]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1296]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1297]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1298]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1299]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1300]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1301]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1302]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1303]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1304]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1305]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1306]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1307]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1308]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1309]'
  prefs: []
  type: TYPE_PRE
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1310]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1311]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1312]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1313]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1314]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1315]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1316]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1317]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1318]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1319]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1320]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1321]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1322]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1323]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1324]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1325]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1326]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1327]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1328]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1329]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1330]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, using the iPhone 7 simulator, run the game by pressing ⌘ -R. You should
    see something like [Figure 15-2](text00027.html#ch15fig2) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1331]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1332]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1333]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1334]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1335]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1336]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1337]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1338]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1339]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1340]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1341]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1342]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1343]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1344]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1345]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1346]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1347]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1348]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1349]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1350]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1351]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1352]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1353]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1354]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1355]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1356]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1357]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1358]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1359]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1360]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1361]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1362]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1363]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1364]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1365]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1366]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1367]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1368]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1369]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1370]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1371]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1372]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-2: Our hero makes her first appearance!*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1373]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1374]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1375]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1376]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1377]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1378]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1379]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1380]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1381]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1382]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1383]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1384]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1385]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1386]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1387]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1388]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1389]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1390]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1391]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1392]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1393]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have set up the skater sprite and the skater’s starting
    position. Looks great, right? We’ll add the sidewalk and make her skate along
    it pretty soon, too, but first let’s talk about SpriteKit’s debugging tool.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1394]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1395]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1396]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1397]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1398]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1399]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1400]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1401]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1402]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1403]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1404]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1405]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1406]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1407]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1408]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1409]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1410]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1411]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1412]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1413]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1414]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**UNDERSTANDING SPRITEKIT’S DEBUGGING INFORMATION**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1415]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1416]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1417]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1418]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1419]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1420]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1421]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1422]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1423]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1424]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1425]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1426]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1427]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1428]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1429]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1430]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1431]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1432]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1433]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1434]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1435]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the small text in the bottom-right corner of your simulator? It should
    say something like nodes:3 25.0 fps . This is helpful information about what’s
    happening in your game. In SpriteKit, most things that are displayed on the screen
    are called *nodes* . This display is telling us there are currently three SpriteKit
    nodes being displayed. This makes sense, since we have our GameScene itself, the
    background image, and the skater sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1436]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1437]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1438]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1439]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1440]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1441]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1442]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1443]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1444]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1445]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1446]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1447]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1448]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1449]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1450]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1451]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1452]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1453]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1454]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1455]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1456]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how many nodes are currently displayed can help you debug problems with
    your code. For example, if your game is slowing down, you might look at the debugging
    info and see that the number of nodes keeps going up. This would tell you that
    perhaps you’re adding too many sprites and not removing them when you’re done
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1457]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1458]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1459]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1460]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1461]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1462]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1463]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1464]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1465]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1466]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1467]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1468]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1469]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1470]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1471]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1472]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1473]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1474]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1475]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1476]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1477]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The display is also telling us that the game is currently running at 25 frames
    per second (your actual number may differ depending on your computer’s speed).
    Movies are made up of many *frames* , or images, that give the appearance of animation
    or movement when they are played back quickly. The same is true of games! Our
    game is updating the scene and its nodes 25 times per second. None of our nodes
    are moving, so you can’t actually tell, but every second the screen is being completely
    redrawn 25 times. When we add our sidewalk bricks and make them move in the next
    section, the magic of animation will make this very clear.
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1478]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1479]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1480]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1481]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1482]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1483]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1484]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1485]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1486]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1487]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1488]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1489]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1490]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1491]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1492]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1493]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1494]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1495]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1496]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1497]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1498]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HITTIN’ THE BRICKS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1499]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1500]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1501]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1502]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1503]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1504]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1505]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1506]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1507]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1508]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1509]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1510]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1511]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1512]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1513]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1514]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1515]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1516]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1517]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1518]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1519]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: As the skater skates along the sidewalk, she won’t actually move to the right.
    Rather, we’ll keep adding bricks onto the right side of the screen that move to
    the left side. This is a nice trick to create the illusion that the skater is
    moving to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1520]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1521]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1522]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1523]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1524]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1525]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1526]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1527]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1528]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1529]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1530]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1531]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1532]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1533]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1534]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1535]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1536]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1537]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1538]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1539]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1540]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1541]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1542]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1543]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1544]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1545]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1546]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1547]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1548]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1549]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1550]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1551]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1552]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1553]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1554]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1555]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1556]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1557]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1558]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1559]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1560]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1561]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Each time we add a brick into the scene, we’ll also add it into an array that
    we’ll be using to keep track of all our bricks. Once a brick moves off the left
    edge of the screen, we’ll remove it from the array and also remove it from the
    scene. It’s important to remove sprites that you no longer need, or your node
    count will keep going up and up. Your game will slow down because the game engine
    is still keeping track of every node in the scene!
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1562]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1563]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1564]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1565]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1566]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1567]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1568]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1569]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1570]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1571]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1572]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1573]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1574]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1575]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1576]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1577]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1578]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1579]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1580]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1581]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1582]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code to create this class property at the top of GameScene , just above
    where we created the skater :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1583]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1584]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1585]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1586]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1587]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1588]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1589]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1590]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1591]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1592]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1593]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1594]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1595]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1596]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1597]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1598]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1599]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1600]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1601]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1602]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1603]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1604]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1605]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1606]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1607]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1608]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1609]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1610]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1611]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1612]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1613]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1614]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1615]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1616]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1617]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1618]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1619]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1620]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1621]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1622]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1623]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1624]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1625]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1626]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1627]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1628]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1629]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1630]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1631]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1632]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1633]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1634]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1635]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1636]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1637]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1638]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1639]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1640]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1641]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1642]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1643]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1644]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1645]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a class variable named bricks and assigns to it an empty array
    of sprites (since our bricks will be sprites). Just below that, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1646]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1647]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1648]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1649]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1650]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1651]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1652]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1653]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1654]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1655]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1656]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1657]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1658]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1659]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1660]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1661]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1662]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1663]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1664]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1665]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1666]'
  prefs: []
  type: TYPE_PRE
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1667]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1668]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1669]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1670]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1671]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1672]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1673]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1674]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1675]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1676]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1677]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1678]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1679]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1680]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1681]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1682]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1683]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1684]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1685]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: This brickSize variable does exactly what its name says and sets up each brick’s
    size. It will come in handy later when we’re moving our bricks around. We set
    brickSize to CGSize.zero now, since we don’t know yet what the actual brick size
    will be. Once we create the brick sprites, we’ll set the brickSize to the actual
    size of those sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1686]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1687]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1688]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1689]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1690]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1691]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1692]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1693]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1694]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1695]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1696]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1697]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1698]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1699]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1700]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1701]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1702]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1703]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1704]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need one more class property, scrollSpeed , to keep track of how fast the
    bricks are moving. Add the following code below the brickSize declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1705]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1706]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1707]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1708]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1709]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1710]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1711]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1712]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1713]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1714]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1715]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1716]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1717]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1718]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1719]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1720]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1721]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1722]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1723]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1724]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1725]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1726]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1727]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1728]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1729]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1730]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1731]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1732]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1733]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1734]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1735]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1736]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1737]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1738]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1739]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1740]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1741]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1742]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, remember that you need to specify the CGFloat data type. Otherwise, Xcode
    will infer that the variable is a Double .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1743]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1744]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1745]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1746]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1747]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1748]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1749]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1750]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1751]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1752]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1753]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1754]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1755]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1756]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1757]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1758]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1759]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1760]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re going to add a method that will create a new sidewalk brick. Since
    we’ll be displaying a lot of sidewalk bricks, this method will be a timesaver.
    In games, when something new comes on the screen, it is said to have *spawned*
    , so we’ll use that word to refer to our method. Just below the resetSkater()
    method, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1761]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1762]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1763]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1764]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1765]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1766]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1767]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1768]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1769]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1770]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1771]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1772]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1773]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1774]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1775]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1776]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1777]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1778]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1779]'
  prefs: []
  type: TYPE_PRE
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1780]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1781]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1782]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1783]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1784]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1785]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1786]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1787]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1788]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1789]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1790]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1791]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1792]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1793]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1794]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1795]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1796]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , our spawnBrick(atPosition:) method takes a CGPoint for input (so it knows
    where to place the brick ) and returns the newly created brick sprite. Note that
    we are using a custom parameter label of atPosition for the position parameter.
    This is so when we call the method, it’s more readable—we can see that we’re asking
    for a brick to be spawned at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1797]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1798]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1799]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1800]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1801]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1802]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1803]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1804]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1805]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1806]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1807]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1808]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1809]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1810]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1811]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1812]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1813]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: We create the brick sprite as an SKSpriteNode using an image named *sidewalk.png*
    ➋ . At ➌ , the new brick sprite is placed at the position that was passed in to
    the method. At ➍ , the brick sprite is given a zPosition of 8 . Remember that
    we put our background image at a zPosition of 0 and our skater sprite at a zPosition
    of 10 , so these sidewalk bricks will always be on top of the background image
    but behind the skater.
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1814]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1815]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1816]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1817]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1818]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1819]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1820]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1821]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1822]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1823]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1824]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1825]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1826]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1827]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1828]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1829]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1830]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, our brick is added to the scene ➎ (or it won’t show up). The line
    at ➏ sets our brickSize class property equal to this new brick’s size based on
    the actual size of *sidewalk.png* , which will be helpful to have a bit later
    in our code. At ➐ , our brick sprite is added to the array of bricks we created
    earlier. Finally, at ➑ , the new brick sprite is returned to the code that called
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1831]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1832]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1833]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1834]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1835]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1836]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1837]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1838]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1839]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1840]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1841]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1842]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1843]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1844]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1845]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1846]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1847]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING SIDEWALK BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1848]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1849]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1850]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1851]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1852]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1853]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1854]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1855]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1856]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1857]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1858]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1859]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1860]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1861]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1862]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1863]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1864]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have some code to create bricks, we need a method that will go
    through all the onscreen bricks and move them to the left. This method will be
    called a lot (25 times per second or more), so it only needs to move the bricks
    by a tiny bit each time. We’ll pass in the amount the bricks move as a parameter
    so it can be adjusted as the skater speeds up. (This is how we’ll make the game
    harder over time!) Add the following method declaration below the spawnBrick(atPosition:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1865]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1866]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1867]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1868]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1869]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1870]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1871]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1872]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1873]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1874]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1875]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1876]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1877]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1878]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1879]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1880]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1881]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1882]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1883]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1884]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1885]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1886]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1887]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1888]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1889]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1890]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1891]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1892]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1893]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1894]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1895]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1896]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1897]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1898]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1899]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1900]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1901]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1902]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1903]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1904]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1905]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1906]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1907]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1908]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1909]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1910]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1911]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1912]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1913]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1914]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1915]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method will be our largest yet, so we’ll walk through it one chunk at
    a time. Inside the method’s braces, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1916]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1917]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1918]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1919]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1920]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1921]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1922]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1923]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1924]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1925]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1926]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1927]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1928]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1929]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1930]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1931]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1932]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1933]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1934]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1935]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1936]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1937]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1938]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1939]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1940]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1941]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1942]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1943]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1944]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1945]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1946]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1947]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a variable we’ll use to keep track of the x-position of the brick that
    is farthest to the right. That way we’ll know when it’s time to add another brick
    on the right edge, and where to position that new brick. Below that, add the following
    block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1948]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1949]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1950]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1951]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1952]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1953]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1954]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1955]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1956]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1957]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1958]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1959]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1960]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1961]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1962]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1963]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1964]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1965]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1966]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1967]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1968]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1969]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1970]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1971]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1972]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1973]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1974]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1975]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1976]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1977]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: This code loops through our array of bricks at ➊ using a for-in loop. The line
    at ➋ calculates a new x-position for the brick sprite by subtracting the passed-in
    currentScrollAmount from its x-position. This newX represents a new spot that’s
    a little to the left of where this brick is currently positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1978]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1979]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1980]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1981]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1982]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1983]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1984]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1985]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1986]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1987]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1988]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1989]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1990]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1991]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, at ➌ , we use an if statement to see if this newX position would move
    the brick offscreen by checking if it is less than the negative of the brick’s
    width (-brickSize.width ). Why not just check if the newX is less than 0.0 ? Remember
    that when you set a sprite’s position, you’re telling the computer where to put
    the *center* of the sprite. So at an x-position of 0.0 , the brick is still partially
    on the screen. Checking that the brick’s position is less than -brickSize.width
    ensures that the brick is fully offscreen before we remove it. [Figure 15-3](text00027.html#ch15fig3)
    illustrates how the bricks are moving.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1992]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1993]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1994]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1995]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1996]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1997]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1998]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1999]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2000]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2001]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2002]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2003]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2004]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2005]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2006]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2007]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2008]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2009]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2010]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2011]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2012]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2013]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2014]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2015]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2016]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2017]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2018]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2019]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-3: The bricks are moved to the left until they are off the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2020]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2021]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2022]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2023]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2024]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2025]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2026]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2027]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2028]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2029]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2030]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2031]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2032]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2033]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites that are no longer needed should be removed so the app won’t have to
    waste resources keeping track of extra nodes. Line ➍ does just that. To remove
    any sprite from the scene, we call the removeFromParent() method on the sprite.
    When removed from the scene, the sprite will disappear. That’s why we want to
    be sure it’s completely offscreen before removing it, or it would look like it
    just vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2034]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2035]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2036]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2037]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2038]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2039]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2040]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2041]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2042]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2043]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2044]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2045]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2046]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2047]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more bit of cleanup we need to do when removing a brick sprite:
    we need to remove it from our bricks array, because we want this array to contain
    only onscreen bricks. The line at ➎ checks if this brick sprite is in our bricks
    array by testing if its index in the array is found. Then, the line at ➏ uses
    this index to remove the sprite from the bricks array.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2048]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2049]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2050]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2051]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2052]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2053]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2054]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2055]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2056]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2057]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2058]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2059]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2060]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2061]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve taken care of bricks that have moved offscreen, we can use an
    else block at ➐ to deal with bricks that are still onscreen. The line at ➑ sets
    a new x-position for the brick sprite by creating a CGPoint using the newX that
    we calculated. We want the bricks to move only to the left, not up or down, so
    we won’t be changing their y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2062]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2063]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2064]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2065]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2066]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2067]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2068]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2069]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2070]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2071]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2072]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2073]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2074]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2075]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do inside the else block is to update our farthestRightBrickX
    variable. To do this, we check if the current brick sprite’s new x-position is
    greater than the value of farthestRightBrickX at ➒ . If it is, we set farthestRightBrickX
    equal to this brick sprite’s x-position at ➓ . This way, when the for-in loop
    is finished and we’ve iterated through all the bricks in our array, the value
    of farthestRightBrickX will be equal to the x-position of whichever brick was
    found to be farthest to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2076]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2077]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2078]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2079]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2080]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2081]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2082]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2083]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2084]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2085]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2086]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2087]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2088]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2089]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FILLING THE SCREEN WITH BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2090]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2091]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2092]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2093]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2094]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2095]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2096]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2097]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2098]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2099]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2100]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2101]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2102]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2103]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: After repositioning all the bricks, we need to see if it’s time to add any new
    bricks. Since our bricks scroll from right to left, we’ll continually have bricks
    that go offscreen to the left and are removed, and new bricks that need to spawn
    on the right side of the screen. If we didn’t keep spawning new bricks, our skater
    would quickly run out of sidewalk!
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2104]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2105]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2106]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2107]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2108]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2109]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2110]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2111]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2112]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2113]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2114]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2115]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2116]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2117]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To spawn new bricks on the right, we need to add one more chunk of code to
    our method update Bricks(withScrollAmount:) . Add the following below the for-in
    loop you just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2118]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2119]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2120]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2121]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2122]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2123]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2124]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2125]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2126]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2127]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2128]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2129]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2130]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2131]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2132]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2133]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2134]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2135]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2136]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2137]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2138]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2139]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2140]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2141]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2142]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2143]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2144]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2145]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2146]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2147]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2148]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2149]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2150]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2151]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2152]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2153]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2154]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2155]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2156]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2157]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2158]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2159]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2160]'
  prefs: []
  type: TYPE_PRE
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2161]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2162]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2163]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2164]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2165]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2166]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2167]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2168]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2169]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2170]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2171]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2172]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2173]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: We already know the x-position of the farthest-right brick from our previous
    chunk of code. Now we use a while loop at ➊ to spawn a brick any time we find
    that our farthest-right brick position is less than the scene’s width. This loop
    will keep executing until we have sidewalk bricks that fill the screen, all the
    way to the right edge. Inside the while loop, we need to create a new brick sprite
    and add it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2174]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2175]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2176]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2177]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2178]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2179]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2180]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2181]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2182]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2183]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2184]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2185]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2186]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we calculate the new sprite’s position. The line at ➋ determines the
    new brick sprite’s x-position by adding one full brick’s width to the current
    farthest-right position, plus an extra one-point gap. This extra one-point gap
    will leave a tiny space between each brick, which makes the movement of the bricks
    easier to see. (Later, try seeing how the sidewalk looks without the + 1.0 gap.)
    The line at ➌ calculates the new brick sprite’s y-position by dividing the brick’s
    height in half. This will place the brick at the bottom edge of the screen. Later
    on, we’ll vary this y-position so the player has to jump up to reach higher sidewalks.
    For now, we’re just going to place all the bricks on the bottom edge, like a normal
    sidewalk.
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2187]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2188]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2189]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2190]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2191]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2192]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2193]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2194]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2195]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2196]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2197]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2198]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2199]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LEAVING GAPS TO JUMP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2200]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2201]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2202]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2203]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2204]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2205]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2206]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2207]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2208]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2209]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2210]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2211]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2212]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’re positioning the bricks, let’s make the game more fun for the player.
    The next bit of code adds some random gaps in the sidewalk that the player will
    have to jump over. Add this code inside the while loop, below the let brickY line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2213]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2214]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2215]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2216]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2217]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2218]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2219]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2220]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2221]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2222]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2223]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2224]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2225]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2226]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2227]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2228]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2229]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2230]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2231]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2232]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2233]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2234]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2235]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2236]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2237]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2238]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2239]'
  prefs: []
  type: TYPE_PRE
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2240]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2241]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2242]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2243]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2244]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2245]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2246]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2247]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2248]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2249]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2250]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2251]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding random elements to games is important to keep the gameplay from being
    predictable. We achieve randomness by asking the computer to generate a random
    number, which is like rolling a die. The function arc4random_uniform() is a good
    way to create random integers by simply passing in an integer representing the
    maximum value for your random number. The line at ➊ creates a random integer between
    0 and 99 using this function. This is like rolling a 100-sided die because there
    are 100 possible numbers between 0 and 99\. Next we use an if statement at ➋ to
    check if this number is less than 5\. This means the code inside the if statement
    will have a 5 percent chance of executing.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2252]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2253]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2254]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2255]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2256]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2257]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2258]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2259]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2260]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2261]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2262]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2263]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➌ calculates how large of a gap to create. As the skater’s speed
    increases, we want the gaps to get bigger and bigger, so this gap amount is set
    to 20.0 times the scroll speed. As the speed increases, the gaps will get larger.
    Finally, the line at ➍ adds this gap to our brickX variable. Now when we set the
    brick’s position, instead of being right next to the previous brick, it will be
    placed a good amount farther to the right, creating a gap.
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2264]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2265]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2266]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2267]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2268]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2269]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2270]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2271]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2272]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2273]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2274]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2275]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: After determining the x- and y-positions of the new brick, we spawn a new brick
    at ➎ . Since we’ve added this new brick to the right of any existing bricks, we
    set farthestRightBrickX at ➏ to this new brick’s x-position. This will create
    our exit condition for the while loop. [Figure 15-4](text00027.html#ch15fig4)
    shows how the while loop works.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2276]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2277]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2278]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2279]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2280]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2281]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2282]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2283]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2284]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2285]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2286]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2287]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2288]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2289]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2290]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2291]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2292]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2293]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2294]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2295]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2296]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2297]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2298]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2299]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-4: The while loop keeps adding bricks until the width of the screen
    is filled.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2300]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2301]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2302]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2303]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2304]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2305]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2306]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2307]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2308]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2309]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2310]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2311]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Once enough bricks have been added and the farthestRightBrickX is greater than
    or equal to the scene’s width, the while loop will stop executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2312]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2313]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2314]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2315]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2316]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2317]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2318]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2319]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2320]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2321]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2322]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2323]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**THE GAME LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2324]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2325]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2326]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2327]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2328]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2329]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2330]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2331]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2332]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2333]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2334]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2335]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to bring it all together by writing the main game loop. The game loop
    is a block of code that the game engine (SpriteKit) will execute over and over
    whenever the game is running. It’s where we’ll update all of our sprite’s positions,
    creating the actual animation in our game. All SpriteKit scenes have a method
    called update(_:) , which we must override to update our sprite positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2336]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2337]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2338]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2339]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2340]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2341]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2342]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2343]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2344]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2345]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2346]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2347]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TRACKING THE UPDATE TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2348]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2349]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2350]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2351]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2352]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2353]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2354]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2355]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2356]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2357]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2358]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2359]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write the main game loop code, however, we need to add a class property
    to keep track of when the last update happened. Add an optional lastUpdateTime
    property to GameScene , right below scrollSpeed :'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2360]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2361]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2362]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2363]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2364]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2365]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2366]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2367]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2368]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2369]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2370]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2371]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2372]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2373]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2374]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2375]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2376]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2377]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2378]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2379]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2380]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2381]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2382]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2383]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2384]'
  prefs: []
  type: TYPE_PRE
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2385]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2386]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2387]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2388]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2389]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2390]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2391]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2392]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2393]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2394]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2395]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Our update(_:) method will be called very often, about 30 times per second.
    Notice I didn’t say *exactly* 30 times per second. The game engine will attempt
    to call the update(_:) method 30 times per second, but it’s not guaranteed to
    run exactly that number of times. And on some devices it will actually be targeting
    60 times per second. So we need to keep track of how much time has *actually*
    passed between each update in order to make sure everything animates smoothly.
    We don’t want our skater to look like she’s constantly speeding up and slowing
    down just because this method isn’t called at an exact time interval. By keeping
    track of how much time has passed, we can adjust how much we move our sprites
    in each update and keep them moving smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2396]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2397]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2398]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2399]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2400]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2401]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2402]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2403]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2404]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2405]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2406]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CALCULATING ELAPSED TIME FOR EACH UPDATE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2407]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2408]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2409]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2410]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2411]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2412]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2413]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2414]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2415]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2416]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2417]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first created this project using the Game template, an empty update(_:)
    method was added automatically. Inside this method, add the following code to
    calculate how much time has passed since the last update:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2418]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2419]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2420]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2421]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2422]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2423]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2424]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2425]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2426]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2427]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2428]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2429]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2430]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2431]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2432]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2433]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2434]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2435]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2436]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2437]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2438]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2439]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2440]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2441]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2442]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2443]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2444]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2445]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2446]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2447]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2448]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2449]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2450]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ creates an elapsedTime variable of the TimeInterval data type.
    TimeInterval is a Double data type used to track time intervals in seconds. Just
    like when we create a CGFloat , we need to specify that this is a TimeInterval
    , or Xcode will use type inference to assume this is a plain Double . The line
    at ➋ unwraps the lastUpdateTime , if it exists. It is an optional because at the
    start of the game there will be no last update. So, the first time the update(_:)
    method is called, lastUpdateTime will be nil . If we’re able to unwrap it, then
    the line at ➌ calculates the elapsedTime , which is how much time has passed since
    the last update call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2451]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2452]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2453]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2454]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2455]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2456]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2457]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2458]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2459]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2460]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following line to the update(_:) method, to set lastUpdateTime
    equal to the currentTime :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2461]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2462]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2463]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2464]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2465]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2466]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2467]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2468]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2469]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2470]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2471]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2472]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2473]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2474]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2475]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2476]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2477]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2478]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2479]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2480]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: This ensures that the next time the update(_:) method is called, our lastUpdateTime
    variable will be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2481]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2482]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2483]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2484]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2485]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2486]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2487]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2488]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2489]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ADJUSTING SCROLL SPEED USING THE ELAPSED TIME**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2490]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2491]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2492]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2493]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2494]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2495]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2496]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2497]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2498]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will calculate our scroll speed. Add the following to your update(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2499]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2500]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2501]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2502]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2503]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2504]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2505]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2506]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2507]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2508]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2509]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2510]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2511]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2512]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2513]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2514]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2515]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2516]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2517]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2518]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2519]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2520]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2521]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2522]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2523]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2524]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2525]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ calculates the expected time lapse. About 1/60 of a second should
    pass between each call to update(_:) since the app will probably run at 60 frames
    per second on an actual iOS device (though it will probably run at less than 60
    frames per second in the iOS simulator). The code we’re adding here will ensure
    that the skater appears to move at the same speed, regardless of which device
    (or simulator) is used.
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2526]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2527]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2528]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2529]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2530]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2531]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2532]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2533]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➋ calculates a scroll adjustment factor by dividing the actual elapsed
    time by the expected elapsed time. If more time has passed than expected (greater
    than 1/60 of a second), this factor will be greater than 1.0 . If less time has
    passed than expected, this factor will be less than 1.0 . The line at ➌ determines
    what our scroll speed should be for this update by multiplying scrollSpeed by
    this adjustment factor.
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2534]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2535]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2536]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2537]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2538]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2539]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2540]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2541]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**UPDATING THE BRICKS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2542]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2543]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2544]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2545]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2546]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2547]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2548]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2549]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line of code to finish the update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2550]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2551]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2552]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2553]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2554]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2555]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2556]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2557]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2558]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2559]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2560]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2561]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2562]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2563]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2564]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2565]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2566]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2567]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2568]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2569]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2570]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2571]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2572]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2573]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve calculated the correct scroll amount for this update, we call
    our udpateBricks(_:) method and pass in the calculated scroll amount.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2574]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2575]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2576]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2577]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2578]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2579]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2580]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now reached a good time to test out the app. Press ⌘ -R to run the app
    and see what happens! Your screen should look something like [Figure 15-5](text00027.html#ch15fig5)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2581]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2582]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2583]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2584]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2585]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2586]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2587]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2588]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2589]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2590]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2591]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2592]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2593]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2594]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-5: Our skater is now skating along the sidewalk!*'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2595]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2596]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2597]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2598]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2599]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2600]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2601]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: It should now look like the skater is skating along the sidewalk. You can see
    the sidewalk bricks moving from right to left, and every now and then (a 5 percent
    chance every time a brick is spawned) a gap appears. Notice that the count of
    nodes in the lower right should stay fairly consistent. This tells us that we
    are properly removing the bricks that went offscreen. If this number kept going
    up, we’d know that we forgot to remove them. It’s starting to look more like a
    game, but the skater just slides right over the gaps. Let’s give her the ability
    to jump.
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2602]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2603]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2604]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2605]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2606]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2607]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2608]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**UP, UP, AND AWAY—MAKING THE SKATER JUMP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2609]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2610]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2611]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2612]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2613]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2614]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2615]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to add code so that when the player taps on the screen, the skater
    jumps. To know when the player taps, we’ll use a *tap gesture recognizer* . [Table
    15-1](text00027.html#ch15tab1) shows some common types of gesture recognizers
    you can use to know when the user has performed certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2616]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2617]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2618]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2619]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2620]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2621]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2622]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 15-1:** Common Gesture Recognizers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2623]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2624]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2625]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2626]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2627]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2628]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2629]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Gesture** | **Gesture recognizer** | **What it detects** |'
  prefs: []
  type: TYPE_TB
- en: '| Tap | UITapGestureRecognizer | One or more fingers tapping on the screen
    one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| Pinch | UIPinchGestureRecognizer | Pinches with two fingers, typically used
    for zooming in or out |'
  prefs: []
  type: TYPE_TB
- en: '| Swipe | UISwipeGestureRecognizer | Swipes across the screen with one or more
    fingers |'
  prefs: []
  type: TYPE_TB
- en: '| Pan | UIPanGestureRecognizer | One or more fingers moving across the screen
    in any direction |'
  prefs: []
  type: TYPE_TB
- en: '| Long press | UILongPressGestureRecognizer | One or more fingers being held
    down on the screen for a certain amount of time |'
  prefs: []
  type: TYPE_TB
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2630]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2631]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2632]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2633]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2634]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2635]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2636]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to know about taps, so we’ll use the UITapGestureRecognizer . The tap
    gesture recognizer will call a method of our choosing any time the user taps a
    finger anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2637]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2638]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2639]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2640]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2641]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2642]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2643]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A TAP GESTURE RECOGNIZER**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2644]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2645]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2646]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2647]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2648]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2649]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2650]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a gesture recognizer, you simply create it and then add it to the view.
    Add this code at the bottom of the didMove(to:) method to create and add the tap
    gesture recognizer:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2651]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2652]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2653]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2654]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2655]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2656]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2657]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2658]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2659]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2660]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2661]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2662]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2663]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2664]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2665]'
  prefs: []
  type: TYPE_PRE
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2666]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2667]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2668]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2669]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2670]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2671]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: With this code, any time the user taps on the screen, the handleTap(_:) method
    will be called on our game scene. First, we create a *selector* called tapMethod
    ➊ . A selector is a reference to the name of a method. Soon we’re going to add
    a new method called handleTap(_:) , and this constant, tapMethod , is just a reference
    to that method. This will allow us to tell the tap gesture recognizer which method
    it should call when the user taps on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2672]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2673]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2674]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2675]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2676]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2677]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: At ➋ , we create the tap gesture recognizer. Its initializer takes a target
    and a selector. The target tells the gesture recognizer what class the selector
    will be in, and the selector is the method to call. Since we’re going to add the
    handleTap(_:) method to the GameScene class that we’re already in, we use self
    to refer to this class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2678]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2679]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2680]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2681]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2682]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2683]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the line at ➌ adds the new gesture recognizer to the scene’s view.
    A gesture recognizer must be added to the view, or it won’t do anything. We put
    this code inside the didMove(to:) method because a gesture recognizer only needs
    to be added to a view once and it will keep handling gestures until you remove
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2684]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2685]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2686]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2687]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2688]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2689]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to add this handleTap(_:) method! Add this new method just
    below the existing update(_:) method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2690]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2691]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2692]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2693]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2694]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2695]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2696]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2697]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2698]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2699]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2700]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2701]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: When the user taps on the screen, we need to make sure the skater is on the
    ground, so we check for this using an if statement at ➊ . If the skater is already
    in the air, she can’t jump again (without a jetpack, anyway). The line at ➋ sets
    the velocity of the skater sprite so that the x velocity is still 0.0 and the
    y velocity is equal to the sprite’s jumpSpeed (which we defined in the Skater
    class). This allows us to make the skater jump straight up. Next, we set the skater
    sprite’s isOnGround property to false at ➌ because once she starts a jump, she
    is no longer on the ground and shouldn’t be allowed to jump again until she lands.
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2702]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2703]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2704]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2705]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2706]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIMULATING GRAVITY IN A SIMPLE WAY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2707]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2708]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2709]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2710]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2711]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the skater’s velocity doesn’t make her jump, though. We need to use
    this velocity, in the update(_:) method, to update the skater’s y-position. First,
    we need to add one more class property, gravitySpeed , right under the declaration
    of var scrollSpeed at the top of the class, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2712]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2713]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2714]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2715]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2716]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2717]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2718]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2719]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2720]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2721]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2722]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2723]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2724]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2725]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2726]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use this constant to determine how fast the skater should come back down
    when jumping. Now add the following method declaration just below the updateBricks(_:)
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2727]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2728]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2729]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2730]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2731]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2732]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2733]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2734]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use this method to update the skater’s position when she jumps. Add the
    following code inside this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2735]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2736]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2737]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2738]'
  prefs: []
  type: TYPE_PRE
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2739]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2740]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: First, at ➊ , we use an if statement to make sure we’re moving the skater up
    or down only if she’s not already on the ground. If she’s not on the ground, then
    she must be jumping. So we need to move her up (if she’s jumping up) or down (if
    gravity is pulling her back down).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2741]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2742]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2743]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2744]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line at ➋ calculates a new y velocity by subtracting gravitySpeed from
    the current y velocity. When she jumps, she’ll start at a fast, positive velocity.
    Then gravity will slowly decrease that velocity until she reaches the peak of
    her jump. After that, the velocity will become negative as she falls back to Earth.
    Picture throwing a ball straight up into the air: it will have a positive speed
    as it rises, slowing down until it comes to a complete standstill, for an instant,
    at the top of its arc. Then it will fall back to you, gaining speed until you
    catch it or it hits the ground. This one line of code simulates that effect of
    gravity.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2745]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2746]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the line at ➌ updates the skater’s velocity with this new value (but keeps
    her x velocity unchanged, as this sprite doesn’t actually move left or right).
    Now that we have the skater’s velocity updated, we can calculate her new y-position
    by using this velocity ➍ . We add the skater’s velocity to her current y-position,
    and this gives us what her new y-position should be. The line at ➎ sets the skater’s
    new position.
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2747]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2748]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING FOR LANDINGS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2749]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2750]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do in the updateSkater() method is to check if the
    skater has landed. Add the following code to the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2751]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2752]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2753]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2754]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2755]'
  prefs: []
  type: TYPE_PRE
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2756]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➊ checks if the skater’s y-position is less than her minimumY ,
    which we already gave a value for in the resetSkater() method. If it is true ,
    then she is on the ground (or below it).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2757]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the skater lands back on the ground, we need to do three things. At
    ➋ , we set her y-position equal to her minimumY position to make sure she doesn’t
    fall through the sidewalk. At ➌ , we set her velocity to zero since the ground
    should stop her from falling any farther. Finally, at ➍ , we set her isOnGround
    property to true so she can jump again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2758]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we have to do is add a method call for our new updateSkater() method.
    Inside the update(_:) method, at the very end, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2759]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2760]'
  prefs: []
  type: TYPE_PRE
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, run your game by pressing ⌘ -R, and try tapping the screen to jump
    (when using the iOS simulator, clicking the mouse on the screen is the same as
    tapping). Your skater will jump, as shown in [Figure 15-6](text00027.html#ch15fig6)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-6: Like any self-respecting skateboarder, our hero can finally ollie!*'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: Now when you tap on the screen, the skater jumps! Tapping the screen triggers
    a call to handleTap(_:) , thanks to our tap gesture recognizer. In that method,
    we set a positive y-velocity. Then in the ensuing calls to our game loop, or update(_:)
    method, the skater sprite’s velocity is used to update her y-position until gravity
    pulls her back to Earth.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you made the Schoolhouse Skateboarder app feel more like a
    game. You created a subclass of SKSpriteNode so that it could be a specialized
    Skater sprite, and then you added a skater to the game scene. Next, you added
    a whole bunch of sidewalk bricks and had them spawn, move, and then go away, all
    to give the appearance that our skater is skating along the sidewalk. Finally,
    you learned how to use velocity and position updates to make the skater jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that when the skater gets to a gap in the bricks, she
    just glides right over them. To make her fall in the gap, we would have to detect
    when the skater is moving over it and adjust her y-position accordingly. This
    approach can start to get complicated, but there’s a better way: SpriteKit comes
    with a built-in physics engine that can do the hard work of velocity and position
    updates for you. In [Chapter 16](text00028.html#ch16) , we’ll use SpriteKit’s
    physics engine to bring the Schoolhouse Skateboarder game to life.'
  prefs: []
  type: TYPE_NORMAL
