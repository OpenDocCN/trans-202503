- en: '12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '12'
- en: PRINCIPLES OF SYMBOLIC EXECUTION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 符号执行的原理
- en: '*Symbolic execution* tracks metadata about the program state, just as taint
    analysis does. But unlike taint information, which only lets you infer *that*
    part of the program state affects another, symbolic execution allows you to reason
    about *how* the program state came to be and how to reach different program states.
    As you’ll see, symbolic execution enables many powerful analyses not possible
    with other techniques.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号执行*跟踪程序状态的元数据，就像污点分析一样。但与污点信息不同，污点信息仅让你推测*哪一部分*程序状态影响了另一部分，而符号执行让你推理*程序状态是如何变化的*，以及如何到达不同的程序状态。正如你将看到的，符号执行使得许多其他技术无法实现的强大分析成为可能。'
- en: I’ll start this chapter with an overview of the basics of symbolic execution.
    Then, you’ll learn more about *constraint solving* (specifically, *SMT solving*
    ), which is a fundamental building block of symbolic execution. In [Chapter 13](ch13.xhtml#ch13),
    you’ll use Triton, a binary-level symbolic execution library, to build practical
    tools that demonstrate what symbolic execution can do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以符号执行的基础知识概述开始这一章节。接着，你将深入了解*约束求解*（特别是*SMT 求解*），它是符号执行的一个基本构建块。在[第13章](ch13.xhtml#ch13)中，你将使用Triton，一个二进制级别的符号执行库，构建实际工具，展示符号执行的能力。
- en: 12.1 An Overview of Symbolic Execution
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1 符号执行概述
- en: Symbolic execution, or *symbex* for short, is a software analysis technique
    that expresses program state in terms of logical formulas that you can automatically
    reason about to answer complex questions about a program’s behavior. For example,
    NASA uses symbolic execution to generate test cases for mission-critical code,
    and hardware manufacturers use it to test code written in hardware description
    languages like Verilog and VHDL. You can also use symbolic execution to automatically
    increase the *code coverage* of dynamic analyses by generating new inputs that
    lead to unexplored program paths, which is useful for software testing and malware
    analysis. In [Chapter 13](ch13.xhtml#ch13), you’ll see practical examples that
    use symbex to implement code coverage, implement backward slicing, and even automatically
    generate exploits for vulnerabilities!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 符号执行，简称*symbex*，是一种软件分析技术，它通过逻辑公式表达程序状态，你可以自动推理这些公式，以回答关于程序行为的复杂问题。例如，NASA使用符号执行生成任务关键代码的测试用例，硬件制造商使用它测试用硬件描述语言（如Verilog和VHDL）编写的代码。你也可以使用符号执行通过生成新的输入来自动增加动态分析的*代码覆盖率*，这些输入可以引导程序走向未探索的路径，这对于软件测试和恶意软件分析非常有用。在[第13章](ch13.xhtml#ch13)中，你将看到使用symbex的实际例子，演示如何实现代码覆盖、实现逆向切片，甚至自动生成漏洞的利用代码！
- en: Unfortunately, although symbolic execution is a powerful technique, you have
    to apply it sparingly and carefully because of scalability issues. For example,
    depending on the type of symbolic execution problem you’re solving, the complexity
    may increase exponentially to the point where computing a solution becomes completely
    intractable. You’ll learn how to minimize these scalability issues in [Section
    12.1.3](ch12.xhtml#ch12_2_3), but first let’s review the basic workings of symbolic
    execution.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管符号执行是一项强大的技术，但由于可扩展性问题，你必须谨慎且有选择地应用它。例如，根据你解决的符号执行问题的类型，复杂度可能会呈指数级增长，甚至导致计算解决方案变得完全无法处理。你将在[第12.1.3节](ch12.xhtml#ch12_2_3)中学习如何最小化这些可扩展性问题，但首先让我们回顾一下符号执行的基本工作原理。
- en: '*12.1.1 Symbolic vs. Concrete Execution*'
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.1.1 符号执行与具体执行*'
- en: Symbex executes (or emulates) an application with *symbolic values* instead
    of the concrete values used when you normally run a program. This means that variables
    don’t contain specific values like `42` or `foobar` as they would in a normal
    execution. Instead, some or all variables (or in the context of binary analysis,
    registers or memory locations) are represented by a symbol that stands in for
    any possible value the variable could take. As the execution proceeds, symbolic
    execution computes logical formulas over these symbols. These formulas represent
    the operations performed on the symbols during execution and describe limits for
    the range of values the symbols can represent.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Symbex使用*符号值*执行（或模拟）应用程序，而不是在正常运行程序时使用的具体值。这意味着变量不会像在正常执行中那样包含特定值，比如`42`或`foobar`。相反，某些或所有变量（在二进制分析的上下文中，是寄存器或内存位置）由一个符号表示，该符号代表变量可能取的任何值。当执行进行时，符号执行会对这些符号计算逻辑公式。这些公式表示在执行过程中对符号执行的操作，并描述符号能够表示的值的范围。
- en: As I’ll explain, many symbex engines maintain the symbols and formulas as metadata
    *in addition to* concrete values rather than replacing the concrete values, similar
    to how taint analysis tracks taint metadata. The collection of symbolic values
    and formulas that a symbex engine maintains is called the *symbolic state*. Let’s
    look at how the symbolic state is organized and then look at a concrete example
    of how the state evolves in a symbolic execution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我将解释的那样，许多 symbex 引擎保持符号和公式作为元数据 *除了* 具体值之外，而不是替换具体值，这类似于污点分析如何跟踪污点元数据。Symbex
    引擎维护的符号值和公式集合称为 *符号状态*。让我们先看看符号状态是如何组织的，然后看一个符号执行过程中符号状态如何变化的具体示例。
- en: The Symbolic State
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 符号状态
- en: 'Symbolic execution operates on symbolic values that represent any possible
    concrete value. I’ll denote symbolic values as *α*[i], where *i* is an integer
    (*i* ∈ *N*). The symbex engine computes two different kinds of formulas over these
    symbolic values: a set of *symbolic expressions* and a *path constraint*. In addition,
    it maintains a mapping of variables (or in the case of binary symbex, registers
    and memory locations) to symbolic expressions. I refer to the combination of the
    path constraint and all symbolic expressions and mappings as the *symbolic state*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 符号执行操作在符号值上，这些符号值代表任何可能的具体值。我将符号值表示为 *α*[i]，其中 *i* 是整数 (*i* ∈ *N*)。Symbex 引擎在这些符号值上计算两种不同类型的公式：一组
    *符号表达式* 和 *路径约束*。此外，它还维护一个变量的映射（或在二进制 symbex 的情况下，寄存器和内存位置）到符号表达式。我将路径约束和所有符号表达式及映射的组合称为
    *符号状态*。
- en: '**Symbolic expressions** A symbolic expression *ϕ*[j], with *j* ∈ *N*, corresponds
    either to a symbolic value *α*[i] or to some mathematical combination of symbolic
    expressions, such as *ϕ*[3] = *ϕ*[1] + *ϕ*[2]. I’ll use σ to denote the *symbolic
    expression store*, which is the set of all the symbolic expressions used in the
    symbolic execution. As I mentioned, binary-level symbex maps all or some of the
    registers and memory locations to an expression in σ.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号表达式** 一个符号表达式 *ϕ*[j]，其中 *j* ∈ *N*，要么对应一个符号值 *α*[i]，要么是某些符号表达式的数学组合，例如 *ϕ*[3]
    = *ϕ*[1] + *ϕ*[2]。我将用 σ 表示 *符号表达式存储*，它是符号执行中使用的所有符号表达式的集合。正如我之前提到的，二进制级别的 symbex
    将所有或部分寄存器和内存位置映射到 σ 中的一个表达式。'
- en: '**Path constraint** The path constraint encodes the limitations imposed on
    the symbolic expressions by the branches taken during execution. For instance,
    if the symbolic execution takes a branch `if(x < 5)` and then another branch `if(y
    >= 4)`, where *x* and *y* are mapped to the symbolic expressions *ϕ*[1] and *ϕ*[2],
    respectively, the path constraint formula becomes *ϕ*[1] < 5 ∧ *ϕ*[2] ≥ 4\. I’ll
    denote the path constraint as the symbol *π*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径约束** 路径约束编码了在执行过程中，由所采取的分支对符号表达式施加的限制。例如，如果符号执行先走分支 `if(x < 5)`，然后又走分支
    `if(y >= 4)`，其中 *x* 和 *y* 分别映射到符号表达式 *ϕ*[1] 和 *ϕ*[2]，则路径约束公式变为 *ϕ*[1] < 5 ∧ *ϕ*[2]
    ≥ 4。我将路径约束表示为符号 *π*。'
- en: In the literature on symbolic execution, path constraints are sometimes referred
    to as *branch constraints*. In this book, I’ll use the term *branch constraint*
    to refer to the constraint imposed by an individual branch and the term *path
    constraint* to refer to the conjunction of all the branch constraints accumulated
    along a program path.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在符号执行的文献中，路径约束有时被称为 *分支约束*。在本书中，我将使用术语 *分支约束* 来指代由单个分支施加的约束，使用 *路径约束* 来指代沿着程序路径累积的所有分支约束的结合。
- en: Symbolically Executing an Example Program
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 符号执行一个示例程序
- en: Let’s make the concept of symbolic execution more concrete using the pseudocode
    in [Listing 12-1](ch12.xhtml#ch12list1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 [Listing 12-1](ch12.xhtml#ch12list1) 中的伪代码来具体化符号执行的概念。
- en: '*Listing 12-1: Pseudocode example to illustrate symbolic execution*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-1：用伪代码示例说明符号执行*'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This pseudocode program takes two integers called *x* and *y* from user input.
    The example explored in this section uses symbolic execution to find user inputs
    that would cover paths through the code leading to the `foo` and `bar` functions,
    respectively. To achieve this, you represent *x* and *y* as symbolic values and
    then symbolically execute the program to compute the path constraint and symbolic
    expressions imposed on *x* and *y* by the program’s operations. Finally, you solve
    these formulas to find concrete values (if they exist) for *x* and *y* that lead
    the program to traverse each path. [Figure 12-1](ch12.xhtml#ch12fig1) shows how
    the symbolic state evolves for all possible paths through the example function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪代码程序从用户输入中获取两个整数，分别为 *x* 和 *y*。本节中探索的示例使用符号执行来查找覆盖代码路径的用户输入，这些路径分别指向 `foo`
    和 `bar` 函数。为了实现这一点，你将 *x* 和 *y* 表示为符号值，然后通过符号执行程序来计算路径约束和程序操作对 *x* 和 *y* 施加的符号表达式。最后，你通过求解这些公式来找到具体的值（如果它们存在）以使得
    *x* 和 *y* 使程序遍历每个路径。[图 12-1](ch12.xhtml#ch12fig1) 展示了符号状态如何在所有可能的路径中发展。
- en: '![image](Images/f312-01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f312-01.jpg)'
- en: '*Figure 12-1: Path constraints and symbolic state for all paths in the example
    function*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：示例函数中所有路径的路径约束和符号状态*'
- en: '[Listing 12-1](ch12.xhtml#ch12list1) starts by reading *x* and *y* from user
    input ➊. As you can see in [Figure 12-1](ch12.xhtml#ch12fig1), the path constraint
    *π* is initially set to ┬, the tautology symbol. This shows that no branches have
    yet been executed, so no constraints are imposed. Similarly, the symbolic expression
    store is initially the empty set. After reading *x*, the symbex engine creates
    a new symbolic expression *ϕ*[1] = *α*[1], which corresponds to an *unconstrained*
    symbolic value that can represent any concrete value, and maps *x* to that expression.
    Reading *y* causes an analogous effect, mapping *y* to *ϕ*[2] = *α*[2]. Next,
    the operation *z* = *x* + *y* ➋ causes the symbex engine to map *z* to a new symbolic
    expression, *ϕ*[3] = *ϕ*[1] + *ϕ*[2].'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-1](ch12.xhtml#ch12list1) 从读取用户输入的 *x* 和 *y* 开始 ➊。正如在 [图 12-1](ch12.xhtml#ch12fig1)
    中所看到的，路径约束 *π* 初始时设置为 ┬，即恒真符号。这表示尚未执行任何分支，因此没有施加约束。类似地，符号表达式存储最初为空集。读取 *x* 后，符号执行引擎创建了一个新的符号表达式
    *ϕ*[1] = *α*[1]，这对应于一个*无约束*的符号值，可以表示任何具体值，并将 *x* 映射到该表达式。读取 *y* 时，发生类似的效果，将 *y*
    映射到 *ϕ*[2] = *α*[2]。接着，操作 *z* = *x* + *y* ➋ 使得符号执行引擎将 *z* 映射到一个新的符号表达式 *ϕ*[3]
    = *ϕ*[1] + *ϕ*[2]。'
- en: Let’s assume the symbolic execution engine first explores the `true` branch
    of the conditional `if(x >= 5)` ➌. To do that, the engine adds the branch constraint
    *ϕ*[1] ≥ 5 to *π* and continues the symbolic execution at the branch target, which
    is the call to `foo`. Recall that the goal was to find concrete user inputs that
    lead to the `foo` or `bar` function. Because you’ve now reached a call to `foo`,
    you can solve the expressions and branch constraints to find concrete values for
    *x* and *y* that lead to this `foo` invocation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设符号执行引擎首先探索条件 `if(x >= 5)` ➌ 的 `true` 分支。为了实现这一点，引擎将分支约束 *ϕ*[1] ≥ 5 添加到 *π*
    中，并继续在分支目标处进行符号执行，这就是调用 `foo`。回想一下，目标是找到能导致程序到达 `foo` 或 `bar` 函数的具体用户输入。因为你现在已经到达了
    `foo` 的调用点，所以你可以求解表达式和分支约束，从而找到使得程序到达该 `foo` 调用的具体 *x* 和 *y* 值。
- en: 'At this point in the execution, *x* and *y* map to the symbolic expressions
    *ϕ*[1] = *α*[1] and *ϕ*[2] = *α*[2], respectively, and *α*[1] and *α*[2] are the
    only symbolic values. Moreover, you have only one branch constraint: *ϕ*[1] ≥
    5\. Thus, one possible solution to reach this call to `foo` is *α*[1] = 5 ∧ *α*[2]
    = 0\. This means that if you run the program normally (a concrete execution) with
    user inputs *x* = 5 and *y* = 0, you’ll reach the call to `foo`. Note that *α*[2]
    could take any value because it doesn’t occur in any of the symbolic expressions
    that appear in the path constraint.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行的这一点，*x* 和 *y* 映射到符号表达式 *ϕ*[1] = *α*[1] 和 *ϕ*[2] = *α*[2]，分别，*α*[1] 和 *α*[2]
    是唯一的符号值。而且，你只有一个分支约束条件：*ϕ*[1] ≥ 5\. 因此，达到 `foo` 调用的一个可能解决方案是 *α*[1] = 5 ∧ *α*[2]
    = 0\. 这意味着，如果你正常运行程序（即具体执行），并且用户输入 *x* = 5 和 *y* = 0，你将会到达 `foo` 的调用。请注意，*α*[2]
    可以取任何值，因为它没有出现在路径约束中的任何符号表达式里。
- en: A solution like the one you just saw is called a *model*. You usually compute
    models automatically with a special program called a *constraint solver*, which
    is capable of solving for the symbolic values such that all constraints and symbolic
    expressions are satisfied, as you’ll learn shortly in [Section 12.2](ch12.xhtml#ch12_2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 像你刚才看到的那种解决方案叫做*模型*。通常，你会通过一个叫做*约束求解器*的特殊程序自动计算模型，该程序能够求解符号值，以满足所有的约束和符号表达式，正如你在[第
    12.2 节](ch12.xhtml#ch12_2)中将要学习的那样。
- en: Now let’s say you want to find out how to reach the call to `bar` instead. To
    do this, you have to avoid the `if(x >= 5)` branch and take the `else` branch
    instead ➍. So you change the old path constraint *ϕ*[1] ≥ 5 to *ϕ*[1] < 5 and
    ask the constraint solver for a new model. In this case, a possible model would
    be *α*[1] = 4 ∧ *α*[2] = 0\. In some cases, the solver might also report that
    no solution exists, meaning that the path is unreachable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想知道如何到达对 `bar` 的调用。为此，你必须避开 `if(x >= 5)` 分支，改走 `else` 分支 ➍。因此，你将旧的路径约束
    *ϕ*[1] ≥ 5 改为 *ϕ*[1] < 5，并请求约束求解器提供一个新的模型。在这种情况下，一个可能的模型是 *α*[1] = 4 ∧ *α*[2]
    = 0。在某些情况下，求解器可能还会报告没有解决方案，意味着该路径是不可达的。
- en: In general, it’s not feasible to cover all paths through a nontrivial program
    since the number of possible paths increases exponentially with the number of
    branches. In [Section 12.1.3](ch12.xhtml#ch12_1_3), you’ll learn how to use heuristics
    to decide which paths to explore.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，无法覆盖一个复杂程序的所有路径，因为随着分支数量的增加，可能路径的数量呈指数增长。在[第 12.1.3 节](ch12.xhtml#ch12_1_3)中，你将学习如何使用启发式方法来决定探索哪些路径。
- en: As I mentioned, there are several variants of symbolic execution, some of which
    work slightly differently from the example just covered. Let’s take a look at
    these other variants of symbolic execution and explore their trade-offs.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，符号执行有几个变种，其中一些与刚才讨论的示例略有不同。让我们来看看这些符号执行的其他变种，并探讨它们的权衡。
- en: '*12.1.2 Variants and Limitations of Symbolic Execution*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.1.2 符号执行的变种和局限性*'
- en: Like taint analysis engines, symbex engines are often designed as a framework
    that you can use to build your own symbex tools. Many symbex engines implement
    aspects from multiple symbolic execution variants and allow you to choose between
    them. Therefore, it’s important to be familiar with the trade-offs of these design
    decisions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 像污点分析引擎一样，symbex 引擎通常被设计为一个框架，你可以用它来构建自己的 symbex 工具。许多 symbex 引擎实现了来自多个符号执行变种的方面，并允许你在它们之间进行选择。因此，熟悉这些设计决策的权衡是非常重要的。
- en: '[Figure 12-2](ch12.xhtml#ch12fig2) illustrates the most important design dimensions
    for symbex implementations, showing one dimension per level of the tree.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-2](ch12.xhtml#ch12fig2) 展示了 symbex 实现的最重要的设计维度，每个维度在树的每一层中都有体现。'
- en: '**Static vs. dynamic** Is the symbex implementation based on static or dynamic
    analysis?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态与动态** 该 symbex 实现是基于静态分析还是动态分析？'
- en: '**Online vs. offline** Does the symbex engine explore multiple paths in parallel
    (*online*) or not (*offline*)?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**在线与离线** symbex 引擎是否并行探索多条路径（*在线*）或不探索（*离线*）？'
- en: '**Symbolic state** Which parts of the program state are represented symbolically,
    and which are concrete? How are symbolic memory accesses handled?'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号状态** 程序状态的哪些部分是符号表示的，哪些是具体的？符号内存访问是如何处理的？'
- en: '**Path coverage** Which (and how many) program paths does the symbolic analysis
    explore?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径覆盖** 符号分析探索了哪些（以及多少）程序路径？'
- en: '![image](Images/f314-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f314-01.jpg)'
- en: '*Figure 12-2: Symbolic execution design dimensions*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-2：符号执行设计维度*'
- en: Let’s discuss each of these design decisions and their trade-offs in performance,
    limitations, and completeness.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这些设计决策及其在性能、局限性和完整性方面的权衡。
- en: Static Symbolic Execution (SSE)
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态符号执行（SSE）
- en: Like most software and binary analysis techniques, symbolic execution exists
    in static and dynamic variants with different trade-offs in scalability and completeness.
    Traditionally, symbolic execution is a static analysis technique that emulates
    part of a program, propagating symbolic state with each emulated instruction.
    This type of symbolic execution is also known as *static symbolic execution (SSE)*.
    It either analyzes all possible paths exhaustively or uses heuristics to decide
    which paths to traverse.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数软件和二进制分析技术一样，符号执行存在静态和动态两种变体，在可扩展性和完整性方面有不同的权衡。传统上，符号执行是一种静态分析技术，通过模拟程序的一部分，在每个模拟的指令中传播符号状态。这种类型的符号执行也称为*静态符号执行（SSE）*。它要么穷尽所有可能的路径，要么使用启发式方法决定遍历哪些路径。
- en: An advantage of SSE is that it enables you to analyze programs that can’t run
    on your CPU. For example, you can analyze ARM binaries on an x86 machine. Another
    benefit is that it’s easy to emulate only part of a binary (for instance, just
    one function) instead of the whole program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SSE的一个优点是，它使您能够分析在您的CPU上无法运行的程序。例如，您可以在x86机器上分析ARM二进制文件。另一个好处是，您可以仅模拟二进制的一部分（例如，单个函数），而不是整个程序。
- en: The disadvantage is that exploring both directions at every branch isn’t always
    possible because of scalability issues. While you can use heuristics to limit
    the number of explored branches, it’s far from trivial to come up with effective
    heuristics that capture all the interesting paths.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，由于可扩展性问题，在每个分支探索两个方向并不总是可能的。虽然您可以使用启发式方法限制探索的分支数量，但提出有效的启发式方法来捕获所有有趣的路径并非易事。
- en: 'Moreover, some parts of an application’s behavior are hard to model correctly
    with SSE, specifically when control flows outside the application to software
    components that the symbolic execution engine doesn’t control, such as the kernel
    or a library. This happens when a program issues a system call or library call,
    receives a signal, tries to read an environment variable, and so on. To get around
    this problem, you can use the following solutions, although each comes with its
    own disadvantages:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，某些应用程序行为的部分内容很难通过SSE正确建模，特别是当控制流流出应用程序，进入符号执行引擎无法控制的软件组件时，例如内核或库。这种情况通常发生在程序发出系统调用或库调用、接收信号、尝试读取环境变量等操作时。为了解决这个问题，您可以使用以下解决方案，尽管每个方案都有其自身的缺点：
- en: '**Effect modeling** A common approach is for the SSE engine to model the effects
    of external interactions like system calls and library calls. These models are
    a sort of “summary” of the effects that a system or library call has on the symbolic
    state. (Note that the word *model* in this sense has nothing to do with the models
    returned by the constraint solver.)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**效果建模** 一种常见的方法是，SSE引擎模拟外部交互的效果，例如系统调用和库调用。这些模型是系统或库调用对符号状态产生的效果的“总结”。（请注意，*model*这个词在此处与约束求解器返回的模型无关。）'
- en: Performance-wise, effect modeling is a relatively cheap solution. However, creating
    accurate models for all possible environment interactions—including with the network,
    the filesystem, and other processes—is a monumental task, which may involve creating
    a simulated symbolic filesystem, symbolic network stack, and so on. To make matters
    worse, the models have to be rewritten if you want to simulate a different operating
    system or kernel. Models are therefore often incomplete or inaccurate in practice.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能方面，效果建模是一种相对廉价的解决方案。然而，创建适用于所有可能环境交互的准确模型——包括与网络、文件系统和其他进程的交互——是一项巨大的任务，可能涉及创建模拟的符号文件系统、符号网络栈等。更糟糕的是，如果要模拟不同的操作系统或内核，模型必须重新编写。因此，模型在实际应用中往往是不完整或不准确的。
- en: '**Direct external interactions** Alternatively, the symbolic execution engine
    may directly perform external interactions. For instance, instead of modeling
    the effects of a system call, the symbex engine may actually make the system call
    and incorporate the concrete return value and side effects into the symbolic state.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接外部交互** 另外，符号执行引擎可以直接执行外部交互。例如，符号执行引擎可以直接进行系统调用，而不是仅模拟系统调用的效果，并将实际的返回值和副作用并入符号状态。'
- en: Although this approach is simple, it leads to problems when multiple paths that
    perform competing external interactions are explored in parallel. For instance,
    if multiple paths operate on the same physical file in parallel, this may lead
    to consistency issues if the changes conflict.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法简单，但当多个路径并行探索并执行竞争性外部交互时，会导致问题。例如，如果多个路径并行操作同一个物理文件，如果更改冲突，可能会导致一致性问题。
- en: You can get around this by cloning the complete system state for each explored
    path, but that solution is extremely memory intensive. Moreover, because external
    software components cannot handle symbolic state, interacting directly with the
    environment means an expensive call to the constraint solver to compute suitable
    concrete values that you can pass to the system or library call you want to invoke.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过为每个探索的路径克隆完整的系统状态来规避这个问题，但这个解决方案会极度消耗内存。此外，由于外部软件组件无法处理符号状态，直接与环境交互意味着需要昂贵地调用约束求解器，以计算合适的具体值，这些值可以传递给你想调用的系统或库函数。
- en: Because of these difficulties with static symbolic execution, more recent research
    has explored alternative symbex implementations based on dynamic analysis.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于静态符号执行存在这些困难，最近的研究探索了基于动态分析的替代符号执行实现。
- en: Dynamic Symbolic Execution (Concolic Execution)
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态符号执行（并行符号执行）
- en: '*Dynamic symbolic execution (DSE)* runs the application with concrete inputs
    and keeps the symbolic state *in addition to* the concrete state, rather than
    replacing it completely. In other words, this approach uses concrete state to
    drive the execution while maintaining symbolic state as metadata, just like how
    taint analysis engines maintain taint information. Because of this, dynamic symbolic
    execution is also known as *concolic execution*, as in “con-crete symbolic execution.”'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态符号执行 (DSE)* 在应用程序中运行具体输入，并保持符号状态*此外*具体状态，而不是完全替代它。换句话说，这种方法使用具体状态来驱动执行，同时将符号状态作为元数据保持，就像污点分析引擎保持污点信息一样。因此，动态符号执行也被称为*并行符号执行*，即“具体符号执行”（con-crete
    symbolic execution）。'
- en: In contrast to traditional static symbolic execution, which explores many program
    paths in parallel, concolic execution runs only one path at once, as determined
    by the concrete inputs. To explore different paths, concolic execution “flips”
    path constraints, as you saw in the example of [Listing 12-1](ch12.xhtml#ch12list1),
    and then uses the constraint solver to compute concrete inputs that lead to the
    alternative branch. You can then use these concrete inputs to start a new concolic
    execution that explores the alternative path.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的静态符号执行不同，后者并行探索多个程序路径，并行符号执行一次仅运行一个路径，这由具体输入决定。为了探索不同的路径，并行符号执行“翻转”路径约束，就像你在[列表
    12-1](ch12.xhtml#ch12list1)的示例中看到的那样，然后使用约束求解器计算出能够导致另一个分支的具体输入。然后你可以使用这些具体输入开始新的并行符号执行，探索替代路径。
- en: Concolic execution has many advantages. It’s much more scalable since you don’t
    need to maintain multiple parallel execution states. You can also solve SSE’s
    problems with external interactions by simply running these interactions concretely.
    This doesn’t lead to consistency issues because concolic execution doesn’t run
    different paths in parallel. Because concolic execution symbolizes only “interesting”
    parts of the program state, such as user inputs, the constraints it computes tend
    to involve fewer variables than those computed by classic SSE engines, making
    the constraints easier and far faster to solve.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 并行符号执行有许多优点。它的可扩展性更强，因为你不需要维护多个并行执行状态。你还可以通过简单地具体执行这些外部交互来解决静态符号执行在外部交互中的问题。这不会导致一致性问题，因为并行符号执行不会并行运行不同的路径。由于并行符号执行仅符号化程序状态中“有趣”的部分，如用户输入，它计算的约束通常涉及的变量比传统的静态符号执行引擎计算的要少，从而使得约束更容易且更快速地求解。
- en: The main downside is that the code coverage achieved by concolic execution depends
    on the initial concrete inputs. Since concolic execution “flips” only a small
    number of branch constraints at once, it can take a long time to reach interesting
    paths if these are separated by many flips from the initial path. It’s also less
    trivial to symbolically execute only part of a program, although it can be implemented
    by dynamically enabling or disabling the symbolic engine at runtime.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的缺点是通过混合执行（concolic execution）实现的代码覆盖率依赖于初始的具体输入。由于混合执行一次只“翻转”少量分支约束，如果这些路径与初始路径之间有许多翻转，那么到达有趣的路径可能需要很长时间。仅对程序的一部分进行符号执行也不那么简单，尽管可以通过在运行时动态启用或禁用符号引擎来实现。
- en: Online vs. Offline Symbolic Execution
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在线 vs 离线符号执行
- en: Another important consideration is whether the symbex engine explores multiple
    paths in parallel. Symbex engines that explore multiple program paths in parallel
    are called *online*, while engines that explore only one path at a time are called
    *offline*. For example, classic static symbolic execution is online because it
    forks off a new symbex instance at each branch and explores both directions in
    parallel. In contrast, concolic execution is usually offline, exploring only a
    single concrete run at once. However, offline SSE and online concolic execution
    implementations do exist.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的考虑因素是符号执行引擎是否会并行探索多个路径。并行探索多个程序路径的符号执行引擎被称为*在线*（online），而一次只探索一个路径的引擎被称为*离线*（offline）。例如，经典的静态符号执行是在线的，因为它会在每个分支处分叉出一个新的符号执行实例，并并行探索两个方向。相比之下，混合执行通常是离线的，一次只探索单个具体执行路径。然而，也存在离线符号执行和在线混合执行的实现。
- en: The advantage of online symbex is that it doesn’t require you to execute the
    same instruction multiple times. In contrast, offline implementations often analyze
    the same chunk of code multiple times, having to run the entire program from the
    start for every program path. In this sense, online symbolic implementations are
    more efficient, but keeping track of all those states in parallel can cost a lot
    of memory, which you don’t have to worry about with offline symbolic execution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在线符号执行的优势在于它不需要多次执行相同的指令。相比之下，离线实现通常会多次分析相同的代码块，必须从头开始运行整个程序来处理每个程序路径。从这个意义上说，在线符号实现更高效，但同时要并行跟踪所有这些状态可能会消耗大量内存，而离线符号执行则不必担心这个问题。
- en: Online symbex implementations attempt to keep the memory overhead to a minimum
    by merging identical parts of program states together, splitting them only when
    they diverge. This optimization is known as *copy on write* because it copies
    merged states when a write causes them to diverge, creating a fresh private copy
    of the state for the path issuing the write.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在线符号执行实现试图通过将相同的程序状态部分合并在一起，从而将内存开销保持在最低限度，仅在它们分歧时才会分开。这种优化被称为*写时复制*（copy on
    write），因为它在写操作导致状态分歧时会复制合并的状态，为执行写操作的路径创建一个新的私有状态副本。
- en: Symbolic State
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 符号状态
- en: The next consideration is determining which parts of the program state are represented
    symbolically and which are concrete, as well as figuring out how symbolic memory
    accesses are handled. Many SSE and concolic execution engines provide the option
    of omitting symbolic state for some registers and memory locations. By tracking
    symbolic information only for the selected state while keeping the rest of the
    state concrete, you can reduce the size of the state and the complexity of the
    path constraints and symbolic expressions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的考虑因素是确定程序状态的哪些部分是符号化的，哪些部分是具体的，以及如何处理符号化的内存访问。许多符号执行和混合执行引擎提供了忽略某些寄存器和内存位置符号状态的选项。通过仅跟踪选定状态的符号信息，同时保持其余状态为具体状态，可以减少状态的大小及路径约束和符号表达式的复杂度。
- en: This approach is more memory efficient and faster because the constraints are
    easier to solve. The trade-off is that you have to choose which state to make
    symbolic and which to make concrete only, and this decision is not always trivial.
    If you choose incorrectly, your symbex tool may report unexpected results.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在内存使用上更高效，速度也更快，因为约束更容易解决。权衡之处在于，你必须选择哪些状态进行符号化，哪些状态仅保持具体化，这一决策并非总是简单的。如果选择错误，你的符号执行工具可能会报告出乎意料的结果。
- en: Another important aspect of how symbex engines maintain symbolic state is how
    they represent symbolic memory accesses. Like other variables, pointers can be
    symbolic, meaning that their value is not concrete but partly undetermined. This
    introduces a difficult problem when memory loads or stores use a symbolic address.
    For instance, if a value is written to an array using a symbolic index, how should
    the symbolic state be updated? Let’s discuss several ways to approach this issue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于符号执行引擎如何保持符号状态的重要方面是它们如何表示符号内存访问。像其他变量一样，指针可以是符号的，意味着它们的值不是具体的，而是部分未确定的。当内存加载或存储使用符号地址时，这就引入了一个难题。例如，如果使用符号索引向数组写入一个值，应该如何更新符号状态？我们来讨论几种解决这个问题的方法。
- en: '**Fully symbolic memory** Solutions based on fully symbolic memory attempt
    to model all the possible outcomes of a memory load or store operation. One way
    to achieve this is to fork the state into multiple copies, one to reflect each
    possible outcome of the memory operation. For instance, let’s suppose we’re reading
    from an array *a* using a symbolic index *ϕ*[i], with the constraint that *ϕ*[i]
    < 5\. The state-forking approach would then fork the state into five copies: one
    for the situation where *ϕ*[i] = 0 (so that *a*[0] is read), another one for *ϕ*[i]
    = 1, and so on.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**完全符号内存** 基于完全符号内存的解决方案试图模拟内存加载或存储操作的所有可能结果。实现这一点的一种方法是将状态分叉成多个副本，每个副本反映内存操作的一个可能结果。例如，假设我们正在使用符号索引*ϕ*[i]从数组*a*中读取数据，并且约束条件是*ϕ*[i]
    < 5。状态分叉方法将把状态分叉成五个副本：一个表示*ϕ*[i] = 0（此时读取*a*[0]），另一个表示*ϕ*[i] = 1，依此类推。'
- en: Another way to achieve the same effect is to use constraints with *if-then-else*
    expressions supported by some constraint solvers. These expressions are analogous
    to if-then-else conditionals used in programming languages. In this approach,
    the same array read is modeled as a conditional constraint that evaluates to the
    symbolic expression of *a*[*i*] if *ϕ*[i] = *i*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同效果的另一种方法是使用一些约束求解器支持的*if-then-else*表达式。这些表达式类似于编程语言中使用的if-then-else条件语句。在这种方法中，相同的数组读取被建模为一个条件约束，如果*ϕ*[i]
    = *i*，则该约束求值为符号表达式*a*[*i*]。
- en: While fully symbolic memory solutions accurately model program behavior, they
    suffer from state explosion or extremely complicated constraints if any memory
    accesses use unbounded addresses. These problems are more prevalent in binary-level
    symbex than source-level symbex because bounds information is not readily available
    in binaries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完全符号内存解决方案能准确地模拟程序行为，但如果任何内存访问使用无界地址，它们会遭遇状态爆炸或极其复杂的约束。这些问题在二进制级符号执行中比源代码级符号执行更为常见，因为在二进制中边界信息并不容易获得。
- en: '**Address concretization** To avoid the state explosion of fully symbolic memory,
    you can replace unbounded symbolic addresses with concrete ones. In concolic execution,
    the symbex engine can simply use the real concrete address. In static symbolic
    execution, the engine will have to use a heuristic to decide on a suitable concrete
    address. The advantage of this approach is that it reduces the state space and
    complexity of constraints considerably, but the downside is that it doesn’t fully
    capture all possible program behaviors, which may lead the symbex engine to miss
    some possible outcomes.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址具体化** 为了避免完全符号内存的状态爆炸，可以用具体地址替换无界符号地址。在混合符号执行中，符号执行引擎可以简单地使用真实的具体地址。在静态符号执行中，符号执行引擎需要使用启发式方法来决定合适的具体地址。这种方法的优点是大大减少了状态空间和约束的复杂性，但缺点是它没有完全捕捉所有可能的程序行为，这可能导致符号执行引擎错过一些可能的结果。'
- en: In practice, many symbex engines employ a combination of these solutions. For
    instance, they may symbolically model memory accesses if the access is limited
    to a sufficiently small range by the constraints, while concretizing unbounded
    accesses.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，许多符号执行引擎会采用这些解决方案的组合。例如，当访问范围被约束限制在足够小的范围内时，它们可能会符号化建模内存访问，同时具体化无界访问。
- en: Path Coverage
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路径覆盖
- en: Finally, you will need to know which program paths the symbolic analysis explores.
    Classic symbolic execution explores *all* program paths, forking off a new symbolic
    state at every branch. This approach doesn’t scale because the number of possible
    paths increases exponentially with the number of branches in the program; this
    is the well-known *path explosion problem*. In fact, the number of paths may be
    infinite if there are unbounded loops or recursive calls. For nontrivial programs,
    you need a different approach to make symbolic execution more practical.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要了解符号分析所探索的程序路径。经典的符号执行会探索*所有*程序路径，每当遇到分支时就会分叉出一个新的符号状态。由于程序中分支的数量会指数级地增加，路径的数量也会急剧增长，这种方法无法扩展；这就是著名的*路径爆炸问题*。事实上，如果存在无限循环或递归调用，路径的数量可能是无限的。对于复杂程序，你需要一种不同的方法来使符号执行更具实践性。
- en: An alternative approach for SSE is using heuristics to decide which paths to
    explore. For instance, in an automatic bug discovery tool, you might focus on
    analyzing loops that index arrays, as these are relatively likely to contain bugs
    like buffer overflows.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SSE的另一种替代方法是使用启发式方法来决定探索哪些路径。例如，在自动化漏洞发现工具中，你可能会集中分析索引数组的循环，因为这些循环相对更可能包含像缓冲区溢出这样的漏洞。
- en: Another common heuristic is *depth-first search (DFS)*, which explores one complete
    program path entirely before moving on to another path, under the assumption that
    deeply nested code is likely more “interesting” than superficial code. *Breadth-first
    search (BFS)* does the opposite, exploring all paths in parallel but taking longer
    to reach deeply nested code. Which heuristics to use depends on the goal of your
    symbex tool, and finding suitable heuristics can be a major challenge.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的启发式方法是*深度优先搜索（DFS）*，它在转到另一路径之前，首先完整探索一个程序路径，假设深度嵌套的代码比表面上的代码更“有趣”。*广度优先搜索（BFS）*则相反，它并行探索所有路径，但需要更长时间才能达到深度嵌套的代码。使用哪种启发式方法取决于你的符号执行工具的目标，找到合适的启发式方法可能是一个重大挑战。
- en: Concolic execution explores only one path at a time, as driven by concrete inputs.
    But you can also combine it with the heuristic path exploration approach or even
    with the approach of exploring all paths. For concolic execution, the easiest
    way to explore multiple paths is to run the application repeatedly, each time
    with new inputs discovered by “flipping” branch constraints in the previous run.
    A more sophisticated approach is to take snapshots of the program state so that
    after you’re done exploring one path, you can restore the snapshot to an earlier
    point in the execution and explore another path from there.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 并发执行每次只探索一条路径，路径由具体输入驱动。但你也可以将其与启发式路径探索方法或甚至是探索所有路径的方法结合使用。对于并发执行，探索多条路径的最简单方法是反复运行应用程序，每次使用通过“翻转”上次运行中的分支约束发现的新输入。一个更复杂的方法是拍摄程序状态的快照，这样在完成一个路径的探索后，你可以恢复到先前的快照并从那里探索另一条路径。
- en: In sum, symbolic execution has many parameters that you can tweak to balance
    the performance and limitations of the analysis. The optimal configuration will
    depend on your goals, and different symbex engines make different configuration
    choices.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，符号执行有许多参数可以调整，以平衡分析的性能和局限性。最佳配置将取决于你的目标，不同的符号执行引擎会做出不同的配置选择。
- en: For example, Triton (which you’ll see again in [Chapter 13](ch13.xhtml#ch13))
    and angr^([1](footnote.xhtml#ch12fn_1)) are binary-level symbex engines that support
    application-level SSE and concolic execution. S2E^([2](footnote.xhtml#ch12fn_2))
    also operates on binaries but uses a system-wide virtual machine–based approach
    that can apply symbex not only to applications but also to the kernel, libraries,
    and drivers running in the VM. In contrast, KLEE^([3](footnote.xhtml#ch12fn_3))
    does classic online SSE on LLVM bitcode rather than directly on binary, supporting
    multiple search heuristics to optimize path coverage. There are even higher-level
    symbex engines that run directly on C, Java, or Python code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Triton（你将在[第13章](ch13.xhtml#ch13)中再次看到）和angr^([1](footnote.xhtml#ch12fn_1))是支持应用层SSE和并发执行的二进制级符号执行引擎。S2E^([2](footnote.xhtml#ch12fn_2))也在二进制上运行，但采用基于系统虚拟机的方法，不仅可以对应用程序，还可以对虚拟机中的内核、库和驱动程序应用符号执行。相比之下，KLEE^([3](footnote.xhtml#ch12fn_3))对LLVM位码进行经典的在线SSE，而不是直接对二进制进行，支持多种搜索启发式方法来优化路径覆盖率。还有更高级别的符号执行引擎，直接在C、Java或Python代码上运行。
- en: Now that you’re familiar with the workings of various symbex techniques, let’s
    discuss some common optimizations you can use to increase the scalability of your
    symbex tools.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经熟悉了各种符号执行技术的工作原理，那么我们来讨论一些常见的优化方法，这些方法可以帮助你提高符号执行工具的可扩展性。
- en: '*12.1.3 Increasing the Scalability of Symbolic Execution*'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.1.3 提高符号执行的可扩展性*'
- en: As you’ve seen, symbolic execution suffers from two major factors of performance
    and memory overhead that undermine its scalability. These are the infeasibility
    of covering all possible program paths as well as the computational complexity
    of solving huge constraints covering hundreds or even thousands of symbolic variables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，符号执行受到性能和内存开销两个主要因素的影响，这些因素削弱了其可扩展性。这些因素包括覆盖所有可能程序路径的不可行性，以及求解覆盖数百甚至数千个符号变量的巨大约束的计算复杂性。
- en: You’ve already seen ways to reduce the impact of the path explosion problem,
    such as heuristically selecting which paths to execute, merging symbolic states
    to reduce memory usage, and using program snapshots to avoid repeated analysis
    of the same instructions. Next I’ll discuss several ways to minimize the cost
    of constraint solving.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些减少路径爆炸问题影响的方法，例如通过启发式选择要执行的路径、合并符号状态以减少内存使用，以及使用程序快照来避免对相同指令的重复分析。接下来，我将讨论几种最小化约束求解成本的方法。
- en: Simplifying Constraints
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简化约束条件
- en: Because constraint solving is one of the most computationally expensive aspects
    of symbex, it makes sense to simplify constraints as much as possible and to keep
    usage of the constraint solver to an absolute minimum. First, let’s look at some
    ways to simplify the path constraints and symbolic expressions. By simplifying
    these formulas, you can reduce the complexity of the constraint solver’s task,
    thereby speeding up the symbolic execution. Of course, the trick is to do this
    without significantly affecting the accuracy of the analysis.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于约束求解是符号执行中计算开销最大的一部分，因此尽量简化约束条件，并将约束求解器的使用保持在最低限度是有意义的。首先，我们来看一些简化路径约束和符号表达式的方法。通过简化这些公式，你可以减少约束求解器的任务复杂度，从而加速符号执行。当然，诀窍是做到这一点时不会显著影响分析的准确性。
- en: '**Limiting the number of symbolic variables** An obvious way to simplify constraints
    is to reduce the number of symbolic variables and make the rest of the program
    state concrete only. However, you can’t just randomly concretize state because
    if you concretize the wrong state, your symbex tool may miss possible solutions
    to the problem you’re trying to solve.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制符号变量的数量** 简化约束的一个明显方法是减少符号变量的数量，并使程序的其他状态保持具体化。然而，你不能随便将状态具体化，因为如果你具体化了错误的状态，你的符号执行工具可能会错过解决你正在尝试解决的问题的潜在方案。'
- en: For example, if you’re using symbex to find network inputs that allow you to
    exploit a program but you concretize all the network inputs, your tool will consider
    only those concrete inputs and therefore fail to find an exploit. On the other
    hand, if you symbolize every byte received from the network, the constraints and
    symbolic expressions may become too complex to solve in a reasonable amount of
    time. The key is to symbolize only those parts of the input that stand a chance
    of being useful in an exploit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用符号执行来查找可以利用程序的网络输入，但你将所有网络输入具体化，那么你的工具只会考虑那些具体的输入，因此无法找到漏洞。另一方面，如果你将从网络接收到的每一个字节都符号化，那么约束条件和符号表达式可能会变得过于复杂，无法在合理的时间内解决。关键是只符号化那些有可能在漏洞利用中起作用的输入部分。
- en: One way to achieve this for concolic execution tools is to use a preprocessing
    pass that employs taint analysis and fuzzing to find inputs that cause dangerous
    effects, such as a corrupted return address, and then use symbex to find out whether
    there are any inputs that corrupt that return address such that it allows exploitation.
    This way, you can use relatively cheap techniques such as DTA and fuzzing to find
    out *whether* there’s a potential vulnerability and use symbolic execution only
    in potentially vulnerable program paths to find out *how* to exploit that vulnerability
    in practice. Not only does this approach allow you to focus the symbex on the
    most promising paths, but it also reduces the complexity of the constraints by
    symbolizing only those inputs that the taint analysis shows to be relevant.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于符号执行工具来说，一种实现这一点的方法是使用预处理步骤，通过污点分析和模糊测试来查找会导致危险后果的输入，比如损坏的返回地址，然后使用符号执行来查找是否有输入会破坏该返回地址，使其允许攻击利用。通过这种方式，你可以使用像DTA和模糊测试这样的相对便宜的技术来判断*是否*存在潜在的漏洞，并仅在可能的漏洞程序路径中使用符号执行来找出*如何*在实践中利用这个漏洞。这种方法不仅可以让你将符号执行集中在最有潜力的路径上，还可以通过只对污点分析显示相关的输入进行符号化，从而减少约束的复杂性。
- en: '**Limiting the number of symbolic operations** Another way to simplify constraints
    is to symbolically execute only those instructions that are relevant. For instance,
    if you’re trying to exploit an indirect call through the `rax` register, then
    you’re interested only in the instructions that contribute to `rax`’s value. Thus,
    you could first compute a backward slice to find the instructions contributing
    to `rax` and then symbolically emulate the instructions in the slice. Alternatively,
    some symbex engines (including Triton, which I use for the examples in [Chapter
    13](ch13.xhtml#ch13)) offer the possibility of symbolically executing only instructions
    that operate on tainted data or on symbolized expressions.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制符号操作的数量** 另一种简化约束的方法是仅符号执行那些相关的指令。例如，如果你正在尝试通过`rax`寄存器利用间接调用，那么你只关心那些对`rax`值有贡献的指令。因此，你可以首先计算一个向后切片，找出贡献给`rax`的指令，然后符号模拟切片中的指令。或者，一些符号执行引擎（包括我在[第13章](ch13.xhtml#ch13)中使用的Triton）提供了仅符号执行操作符号数据或符号化表达式的指令的可能性。'
- en: '**Simplifying symbolic memory** As I explained previously, full symbolic memory
    can cause an explosion in the number of states or the size of the constraints
    if there are any unbounded symbolic memory accesses. You can reduce the impact
    of such memory accesses on constraint complexity by concretizing them. Alternatively,
    symbex engines like Triton allow you to make simplifying assumptions on memory
    accesses, such as that they can only access word-aligned addresses.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**简化符号内存** 正如我之前解释的那样，如果存在任何不受限的符号内存访问，完整的符号内存可能会导致状态数或约束大小的爆炸。你可以通过将其具体化来减少此类内存访问对约束复杂度的影响。或者，像Triton这样的符号执行引擎允许你对内存访问做出简化假设，例如它们只能访问按字对齐的地址。'
- en: Avoiding the Constraint Solver
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 避免约束求解器
- en: The most effective way to get around the complexity of constraint solving is
    to avoid the need for a constraint solver altogether. Although this may sound
    like an unhelpful statement, there are practical ways to limit the need for constraint
    solving in your symbex tools.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用约束求解器是绕过约束求解复杂性最有效的方法。虽然这听起来可能像是一个无用的说法，但实际上有一些方法可以在你的符号执行工具中限制对约束求解的需求。
- en: First, you can use the preprocessing passes I discussed to find potentially
    interesting paths and inputs to explore with symbex and pinpoint the instructions
    affected by these inputs. This helps you to avoid needless constraint solver invocations
    for uninteresting paths or instructions. Symbex engines and constraint solvers
    may also cache the results of previously evaluated (sub)formulas, thereby avoiding
    the need to solve the same formula twice.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以使用我讨论的预处理步骤来查找潜在的有趣路径和输入，并使用符号执行来探索这些路径，并找出这些输入影响的指令。这可以帮助你避免对无趣路径或指令进行不必要的约束求解器调用。符号执行引擎和约束求解器也可能缓存之前评估过的（子）公式的结果，从而避免再次求解相同的公式。
- en: Because constraint solving is a crucial part of symbolic execution, let’s explore
    how it works in more detail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为约束求解是符号执行的关键部分，让我们更详细地探讨它是如何工作的。
- en: 12.2 Constraint Solving with Z3
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2 使用Z3求解约束
- en: Symbolic execution describes a program’s operations in terms of symbolic formulas
    and uses a constraint solver to automatically solve these formulas and answer
    questions about the program. To understand symbolic execution and its limitations,
    you’ll need to be familiar with the process of constraint solving.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 符号执行通过符号公式描述程序的操作，并使用约束求解器自动求解这些公式并回答关于程序的问题。为了理解符号执行及其局限性，您需要熟悉约束求解的过程。
- en: In this section, I’ll explain the most important aspects of constraint solving
    using a popular constraint solver called *Z3*. Z3 is developed by Microsoft Research
    and is freely available at *[https://github.com/Z3Prover/z3/](https://github.com/Z3Prover/z3/)*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释使用一种名为*Z3*的流行约束求解器进行约束求解的最重要方面。Z3由微软研究院开发，并且可以在* [https://github.com/Z3Prover/z3/](https://github.com/Z3Prover/z3/)*
    上免费获得。
- en: Z3 is a so-called *satisfiability modulo theories (SMT)* solver, which means
    it’s specialized to solve satisfiability problems for formulas with respect to
    specific mathematical theories, such as the theory of integer arithmetic.^([4](footnote.xhtml#ch12fn_4))
    This is in contrast to solvers for pure *Boolean satisfiability (SAT)* problems,
    which have no built-in knowledge of theory-specific operations such as integer
    operations like + or <. Z3 has built-in knowledge of how to solve formulas involving
    integer operations and operations on *bitvectors* (representations of binary-level
    data), among others. This domain-specific knowledge is useful when solving formulas
    produced by symbex, which involve exactly such operations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Z3是一种所谓的*满足性模理论（SMT）*求解器，这意味着它专门用于解决关于特定数学理论（如整数算术理论）公式的满足性问题。^([4](footnote.xhtml#ch12fn_4))
    这与纯粹的*布尔满足性（SAT）*问题的求解器有所不同，后者没有内建的理论特定操作知识，如整数操作（例如+或<）。Z3内建了如何求解涉及整数操作和*位向量*（二进制数据表示）等操作的公式的知识。这种特定领域的知识在解决由符号执行产生的公式时非常有用，因为这些公式正是涉及这些操作。
- en: Note that constraint solvers like Z3 are separate programs from symbolic execution
    engines, and their purpose isn’t limited to symbex alone. Some symbex engines
    even offer you the possibility of plugging in multiple different constraint solvers,
    depending on which one you prefer. Z3 is a popular choice because its features
    are ideally suited to symbex and it offers easy-touse APIs in C/C++ and Python,
    among others. It also comes with a command line tool that you can use to solve
    formulas, which you’ll see shortly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像Z3这样的约束求解器与符号执行引擎是分开的程序，其目的不仅仅限于符号执行。一些符号执行引擎甚至允许你根据个人喜好插入多个不同的约束求解器。Z3是一个受欢迎的选择，因为它的特性非常适合符号执行，并且提供了易于使用的C/C++和Python等语言的API。它还附带一个命令行工具，你可以使用它来求解公式，稍后你将看到这一点。
- en: It’s also important to realize that Z3 is not a magic cure-all. Although Z3
    and other similar solvers are useful for solving certain classes of decidable
    formulas, they may not be able to solve formulas outside those classes. And even
    formulas in the supported classes may take a long time to solve, especially if
    they contain lots of variables. This is why it’s important to keep your constraints
    as simple as possible.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也需要认识到，Z3并不是一种万能的灵丹妙药。尽管Z3和其他类似的求解器在解决某些可判定公式类别时非常有用，但它们可能无法解决这些类别之外的公式。即便是支持的公式类别中的公式，也可能需要较长时间来解决，尤其是当公式包含大量变量时。这就是为什么将约束保持尽可能简单非常重要的原因。
- en: I’ll only cover Z3’s most important features here, but if you’re interested,
    check out more comprehensive tutorials online.^([5](footnote.xhtml#ch12fn_5))
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里仅介绍Z3的最重要特性，但如果您有兴趣，可以查阅网上更为全面的教程。^([5](footnote.xhtml#ch12fn_5))
- en: '*12.2.1 Proving Reachability of an Instruction*'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.2.1 证明指令的可达性*'
- en: Let’s begin by using the Z3 command line tool, which is preinstalled on the
    VM, to express and solve a simple set of formulas. Start the command line tool
    with the `z3 -in` command to read from standard input or `z3` *file* to read from
    a script file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用Z3命令行工具，该工具已经预安装在虚拟机上，来表示并求解一组简单的公式。使用`z3 -in`命令启动命令行工具以从标准输入读取，或者使用`z3`
    *file*来从脚本文件读取。
- en: Z3’s input format is an extension of *SMT-LIB 2.0*, a language standard for
    SMT solvers. In the next examples, you’ll learn the most important commands supported
    by this language; these will help you debug your symbex tools because you can
    use them to make sense of the input your symbex tool is passing to the constraint
    solver. For more details on a particular command, type `(help)` into the `z3`
    tool.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Z3的输入格式是*SMT-LIB 2.0*的扩展，这是一个用于SMT求解器的语言标准。在接下来的示例中，你将学习Z3语言支持的最重要命令；这些命令将帮助你调试你的symbex工具，因为你可以使用它们来理解你的symbex工具传递给约束求解器的输入。有关特定命令的更多详细信息，输入`(help)`到`z3`工具中。
- en: Internally, Z3 maintains a *stack* of the formulas and declarations you provide.
    In Z3-speak, a formula is called an *assertion*. Z3 allows you to check whether
    the set of assertions you’ve provided is *satisfiable*, which means there’s a
    way to make all the assertions simultaneously true.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Z3维护了你提供的公式和声明的*堆栈*。在Z3术语中，公式称为*断言*。Z3允许你检查你提供的断言集是否是*可满足的*，这意味着有一种方法可以使所有断言同时成立。
- en: Let’s clarify this by returning to the pseudocode from [Listing 12-1](ch12.xhtml#ch12list1).
    The following example will use Z3 to prove that the call to function `baz` is
    reachable. [Listing 12-2](ch12.xhtml#ch12list2) repeats the example code, with
    the call to `baz` marked ➊.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回到[示例 12-1](ch12.xhtml#ch12list1)中的伪代码来澄清这一点。以下示例将使用Z3证明对函数`baz`的调用是可达的。[示例
    12-2](ch12.xhtml#ch12list2)重复了示例代码，并标记了对`baz`的调用 ➊。
- en: '*Listing 12-2: Pseudocode example to illustrate constraint solving*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-2：伪代码示例，演示约束求解*'
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Listing 12-3](ch12.xhtml#ch12list3) shows how to model the symbolic expressions
    and path constraints, similarly to how a symbex engine would do it, to prove that
    `baz` is reachable. For simplicity, I assume that the call to `foo` has no side
    effects, so you can ignore what happens in `foo` when modeling the path to `baz`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-3](ch12.xhtml#ch12list3)展示了如何模拟符号表达式和路径约束，类似于symbex引擎的做法，以证明`baz`是可达的。为了简化，我假设对`foo`的调用没有副作用，因此在模拟通往`baz`的路径时可以忽略`foo`中的内容。'
- en: '*Listing 12-3: Using Z3 to prove that* baz *is reachable*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-3：使用Z3证明* baz *是可达的*'
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Two things immediately stand out in [Listing 12-3](ch12.xhtml#ch12list3): all
    commands are enclosed in parentheses, and all operations are written in Polish
    notation, with the operator first and then the operands (+ *x* *y* instead of
    *x* + *y*).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 12-3](ch12.xhtml#ch12list3)中，有两点立即引人注目：所有命令都被括号括起来，且所有操作都采用波兰表示法，先是操作符，后是操作数（+
    *x* *y* 而不是 *x* + *y*）。
- en: Declaring Variables
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 声明变量
- en: '[Listing 12-3](ch12.xhtml#ch12list3) starts by declaring the variables (`x`,
    `y`, and `z`) that occur on the path to `baz` ➊. From Z3’s perspective, these
    are modeled as *constants* rather than variables. To declare a constant, you use
    the command `declare-const`, giving the name and type of the constant. In this
    case, all constants are of type `Int`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-3](ch12.xhtml#ch12list3)首先声明了路径上出现的变量（`x`、`y`和`z`）到`baz` ➊。从Z3的角度来看，这些被模拟为*常量*而非变量。要声明常量，你需要使用`declare-const`命令，指定常量的名称和类型。在这种情况下，所有常量的类型都是`Int`。'
- en: The reason for modeling `x`, `y`, and `z` as constants is that there’s a fundamental
    difference between executing a program path and modeling it in Z3\. When you execute
    a program, all operations are executed one by one, but when you model a program
    path in Z3, you represent those same operations as a system of formulas to be
    solved simultaneously. When Z3 solves these formulas, it assigns concrete values
    to `x`, `y`, and `z`, effectively finding the appropriate constants to satisfy
    the formulas.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将`x`、`y`和`z`建模为常量的原因是执行程序路径和在Z3中建模程序路径之间存在根本的区别。当你执行程序时，所有操作都是逐个执行的，但在Z3中建模程序路径时，你将这些相同的操作表示为一个方程组，要求同时求解。当Z3求解这些公式时，它会为`x`、`y`和`z`分配具体值，实际上是找到合适的常量来满足这些公式。
- en: In addition to `Int`, Z3 supports other common data types like `Real` (for floating-point
    numbers) and `Bool`, as well as more complex types like `Array`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Int`，Z3还支持其他常见数据类型，如`Real`（浮动点数）和`Bool`，以及更复杂的类型，如`Array`。
- en: '`Int` and `Real` both support arbitrary precision, which is not representative
    of machine code operations that operate on fixed-width numbers. That’s why Z3
    also offers special bitvector types, which I’ll cover in [Section 12.2.5](ch12.xhtml#ch12_2_5).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int`和`Real`都支持任意精度，这与机器代码操作的固定宽度数字不同。因此，Z3还提供了特殊的位向量类型，我将在[第12.2.5节](ch12.xhtml#ch12_2_5)中讲解。'
- en: Static Single Assignment Form
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态单一赋值形式（Static Single Assignment Form）
- en: The fact that Z3 solves all formulas in unison without regard for the order
    of operations in the program path has another important implication. Suppose that
    the same variable, say *y*, is assigned multiple times in the same program path,
    once as *y* = 5 and then later as *y* = 10\. When solving, Z3 then sees two conflicting
    constraints stating that *y* must be simultaneously equal to 5 and 10, which is
    of course impossible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Z3以不考虑程序路径操作顺序的方式同步求解所有公式，这一点有着另一个重要的含义。假设在同一程序路径中，某个变量，比如*y*，被多次赋值，一次为*y* =
    5，之后再为*y* = 10。当求解时，Z3会看到两个冲突的约束，声明*y*必须同时等于5和10，这显然是不可能的。
- en: 'Many symbex engines solve this problem by emitting symbolic expressions in
    *static single assignment (SSA)* form, which mandates that each variable be assigned
    exactly once. That means that on *y*’s second assignment, it’s split into two
    versions, *y*[1] and *y*[2], removing any ambiguity and resolving the contradicting
    constraints from Z3’s perspective. This is exactly why there’s an additional declaration
    of a constant named `y2` in [Listing 12-3](ch12.xhtml#ch12list3) ➋: the variable
    `y` in [Listing 12-2](ch12.xhtml#ch12list2) is assigned twice on the path to `baz`,
    so it must be split up using the SSA trick. You can also observe this in [Figure
    12-1](ch12.xhtml#ch12fig1), where you can see `y` being mapped to a new symbolic
    expression *ϕ*[4], representing the new version of `y`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 许多符号执行引擎通过以*静态单一赋值（SSA）*形式发出符号表达式来解决这个问题，这要求每个变量只能被赋值一次。这意味着在*y*的第二次赋值时，它会被拆分为两个版本，*y*[1]和*y*[2]，从而消除了任何歧义，并解决了Z3视角中的相互矛盾的约束条件。这正是为什么在[列表
    12-3](ch12.xhtml#ch12list3)中会额外声明一个名为`y2`的常量 ➋：在[列表 12-2](ch12.xhtml#ch12list2)中，变量`y`在到达`baz`的路径上被赋值两次，因此必须通过SSA技巧将其拆分。你还可以在[图
    12-1](ch12.xhtml#ch12fig1)中观察到这一点，那里可以看到`y`被映射到一个新的符号表达式*ϕ*[4]，表示`y`的新版本。
- en: Adding Constraints
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加约束条件
- en: After declaring all the constants, you can add constraint formulas (assertions)
    to Z3’s formula stack using the `assert` command. As I mentioned, you express
    formulas in Polish notation with operators before their operands. Z3 supports
    common mathematical operators like +, −, =, <, and so on, with their usual meanings.
    As you’ll see in later examples, Z3 also supports logical operators and operators
    that deal with bitvectors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明所有常量之后，可以使用`assert`命令将约束公式（断言）添加到Z3的公式堆栈中。如我所提到的，您需要使用波兰表示法来表达公式，其中操作符位于操作数之前。Z3支持常见的数学运算符，如+、−、=、<等，并且具有其通常的含义。正如你在后面的例子中看到的，Z3还支持逻辑运算符和处理位向量的运算符。
- en: The first assertion in [Listing 12-3](ch12.xhtml#ch12list3) is a symbolic expression
    for `z` stating that it must equal `x + y` ➌, modeling the assignment `z = x +
    y` in the pseudocode program from [Listing 12-2](ch12.xhtml#ch12list2). Next,
    there’s an assertion that adds the branch constraint `x >= 5` ➍ (to model the
    branch `if(x >= 5)`), followed by a symbolic expression `y2 = y + z` ➎. Note that
    `y2` depends on the original `y` assigned from user input, clearly showing the
    need for SSA form to disambiguate the assertions and prevent circular dependencies.
    The final assertion adds the second branch constraint, `y2 < x` ➏. Note that I’ve
    omitted modeling the call to `foo` because it has no side effects and therefore
    doesn’t affect the reachability of `baz`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12-3](ch12.xhtml#ch12list3)中的第一个断言是关于`z`的符号表达式，声明它必须等于`x + y` ➌，模拟[列表 12-2](ch12.xhtml#ch12list2)中的伪代码程序`z
    = x + y`。接下来，有一个断言添加了分支约束`x >= 5` ➍（用于模拟分支`if(x >= 5)`），然后是一个符号表达式`y2 = y + z`
    ➎。请注意，`y2`依赖于从用户输入分配的原始`y`，这清楚地显示了需要使用SSA形式来消除断言的歧义并防止循环依赖。最后的断言添加了第二个分支约束`y2
    < x` ➏。注意，我省略了对`foo`的调用建模，因为它没有副作用，因此不会影响`baz`的可达性。'
- en: Checking Satisfiability and Getting a Model
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查可满足性并获取模型
- en: After adding all the assertions needed to model the path to `baz`, you can check
    the stack of assertions for satisfiability using Z3’s `check-sat` command ➐. In
    this case, `check-sat` prints `sat`, meaning that the system of assertions is
    satisfiable. This tells you that `baz` is reachable along the modeled program
    path. If a system of assertions is not satisfiable, `check-sat` prints `unsat`
    instead.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了所有建模`baz`路径所需的断言后，可以使用Z3的`check-sat`命令➐检查断言堆栈的可满足性。在这种情况下，`check-sat`打印`sat`，表示断言系统是可满足的。这告诉你，`baz`可以沿着建模的程序路径到达。如果断言系统不可满足，`check-sat`则会打印`unsat`。
- en: 'Once you know that the assertions are satisfiable, you can ask Z3 for a *model*:
    a concrete assignment of all the constants that satisfies all the assertions.
    To ask for a model, you use the command `get-model` ➑. The returned model expresses
    each constant assignment as a *function* (defined with the command `define-fun`)
    that returns a constant value. That’s because in Z3, constants are really just
    functions that take no arguments, and the command `declare-const` is just syntactic
    sugar that `get-model` omits. For instance, the line `define-fun y () Int (-1)`
    in the model in [Listing 12-3](ch12.xhtml#ch12list3) defines a function called
    `y` that takes no parameters and returns an `Int` with the value `-1`. This just
    means that in this model, the constant `y` has the value `-1`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道断言是可满足的，你可以向Z3请求一个*模型*：一个满足所有断言的常量的具体赋值。要请求一个模型，你使用命令`get-model` ➑。返回的模型通过*函数*（使用命令`define-fun`定义）来表达每个常量的赋值，这些函数返回一个常量值。这是因为在Z3中，常量实际上就是不带参数的函数，命令`declare-const`只是语法糖，而`get-model`会省略它。例如，模型中[列表
    12-3](ch12.xhtml#ch12list3)的这一行`define-fun y () Int (-1)`定义了一个名为`y`的函数，它不带参数，并返回一个值为`-1`的`Int`。这意味着，在这个模型中，常量`y`的值是`-1`。
- en: As you can see, in the case of [Listing 12-3](ch12.xhtml#ch12list3), Z3 finds
    the solution `x = 5`, `y = -1`, `z = 4` (since `z = x + y = 5 - 1`), and `y2 =
    3` (since `y2 = y + z = -1 + 4`). This means that if you use the input values
    `x = 5` and `y = -1` for the pseudo-code program in [Listing 12-2](ch12.xhtml#ch12list2),
    you’ll reach the call to `baz`. Note that there are often multiple possible models,
    and the specific one that `get-model` returns here is chosen arbitrarily.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在[列表 12-3](ch12.xhtml#ch12list3)的情况下，Z3找到了`x = 5`，`y = -1`，`z = 4`（因为`z
    = x + y = 5 - 1`），和`y2 = 3`（因为`y2 = y + z = -1 + 4`）的解。这意味着，如果你在[列表 12-2](ch12.xhtml#ch12list2)中的伪代码程序中使用输入值`x
    = 5`和`y = -1`，你将到达对`baz`的调用。请注意，通常有多个可能的模型，`get-model`返回的具体模型是随机选择的。
- en: '*12.2.2 Proving Unreachability of an Instruction*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.2.2 证明指令的不可达性*'
- en: Note that in the model from [Listing 12-3](ch12.xhtml#ch12list3), the value
    assigned for `y` is negative. As it happens, `baz` is reachable if `x` and `y`
    are signed, but not if they’re unsigned. Let’s prove this so that you can see
    an example of an unsatisfiable system of assertions. [Listing 12-4](ch12.xhtml#ch12list4)
    models the path to `baz` again, this time with the added constraint that `x` and
    `y` must both be non-negative.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[列表 12-3](ch12.xhtml#ch12list3)的模型中，赋给`y`的值是负数。实际上，如果`x`和`y`是有符号的，`baz`是可以到达的，但如果它们是无符号的，则不能到达。让我们来证明这一点，这样你就可以看到一个不可满足的断言系统示例。[列表
    12-4](ch12.xhtml#ch12list4)再次模拟了通往`baz`的路径，这次增加了限制条件：`x`和`y`必须都为非负值。
- en: '*Listing 12-4: Proving that* baz *is unreachable if the inputs are unsigned*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-4：证明如果输入是无符号的，baz* 是不可到达的 *'
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, [Listing 12-4](ch12.xhtml#ch12list4) is exactly the same as
    [Listing 12-3](ch12.xhtml#ch12list3) except for the added assertions that `x >=
    0` ➊ and `y >= 0` ➋. This time, `check-sat` returns `unsat` ➌, proving that `baz`
    is unreachable if `x` and `y` are unsigned. For an unsatisfiable problem, you
    cannot get a model, as none exists.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，[列表 12-4](ch12.xhtml#ch12list4)与[列表 12-3](ch12.xhtml#ch12list3)完全相同，唯一的区别是添加了断言`x
    >= 0` ➊和`y >= 0` ➋。这次，`check-sat`返回`unsat` ➌，证明了如果`x`和`y`是无符号的，`baz`是无法到达的。对于一个不可满足的问题，你无法得到模型，因为不存在这样的模型。
- en: '*12.2.3 Proving Validity of a Formula*'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.2.3 证明公式的有效性*'
- en: You can also use Z3 to prove that a set of assertions is not only satisfiable
    but *valid*, which means that it’s always true regardless of the concrete values
    you plug into it. Proving that a formula or set of formulas is valid is equivalent
    to proving that its negation is unsatisfiable, which you already know how to do
    with Z3\. If the negation turns out to be satisfiable, that means the set of formulas
    is not valid, and you can ask Z3 for a model as a counterexample.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用Z3证明一组断言不仅是可满足的，而且是*有效的*，这意味着无论你将什么具体值代入，它始终为真。证明一个公式或一组公式是有效的，相当于证明其否定是不可满足的，你已经知道如何使用Z3做到这一点。如果否定是可满足的，那就意味着这组公式不是有效的，你可以向Z3请求一个模型作为反例。
- en: Let’s use this idea to prove the validity of the *bidirectional lemma*, a well-known
    valid formula in propositional logic. This will also allow you to see Z3’s propositional
    logic operators in action, as well as Z3’s Boolean data type `Bool`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个思路来证明*双向引理*的有效性，这是命题逻辑中一个著名的有效公式。这也让你可以看到Z3的命题逻辑操作符的实际应用，以及Z3的布尔数据类型`Bool`。
- en: The bidirectional lemma states that ((*p* → *q*) ∧ (*r* → *s*) ∧ (*p* ∨ ¬ *s*))
    ├ (*q* ∨ ¬ *r*). [Listing 12-5](ch12.xhtml#ch12list5) models the lemma in Z3 and
    proves its validity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 双向引理声明为 ((*p* → *q*) ∧ (*r* → *s*) ∧ (*p* ∨ ¬ *s*)) ├ (*q* ∨ ¬ *r*)。[示例 12-5](ch12.xhtml#ch12list5)
    在 Z3 中建模该引理并证明其有效性。
- en: '*Listing 12-5: Proving the bidirectional lemma with Z3*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-5：使用 Z3 证明双向引理*'
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Listing 12-5](ch12.xhtml#ch12list5) declares four `Bool` constants named `p`,
    `q`, `r`, and `s` ➊, one for each variable in the bidirectional lemma. It then
    asserts the bidirectional lemma itself using Z3’s logical operators ➋. As you
    can see, Z3 supports all the usual logical operators, including `and` (∧), `or`
    (∨), `xor` (⊕), `not` (¬), and the logical implication operator `=>` (→). Z3 expresses
    bi-implication (↔) using the equality symbol (`=`). Moreover, Z3 supports an *if-then-else*
    operator called `ite`, with the syntax `ite` *condition value-if-true value-if-false*.
    I’ve modeled the “entails” symbol ⊢ as an implication (`=>`) in the listing.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-5](ch12.xhtml#ch12list5) 声明了四个名为 `p`、`q`、`r` 和 `s` 的 `Bool` 常量 ➊，每个常量对应双向引理中的一个变量。然后，它使用
    Z3 的逻辑运算符断言双向引理 ➋。正如你所看到的，Z3 支持所有常见的逻辑运算符，包括 `and` (∧)、`or` (∨)、`xor` (⊕)、`not`
    (¬)，以及逻辑蕴含运算符 `=>` (→)。Z3 使用等号符号 (`=`) 来表示双向蕴含 (↔)。此外，Z3 还支持一个名为 `ite` 的 *if-then-else*
    运算符，其语法为 `ite` *条件 值-为-真 值-为-假*。我在示例中将“蕴含”符号 ⊢ 表示为蕴含 (`=>`) 运算符。'
- en: First, let’s prove that the bidirectional lemma is satisfiable. You can easily
    confirm that with `check-sat` ➌ and use `get-model` to get a model ➍. In this
    case, the model only assigns the value `true` to `r` since that’s enough to make
    the assertion true regardless of the values of `p`, `q`, and `s`. This tells you
    the bidirectional lemma is satisfiable but doesn’t prove that it’s valid.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们证明双向引理是可满足的。你可以轻松地通过 `check-sat` ➌ 来确认这一点，并使用 `get-model` 获取一个模型 ➍。在这个例子中，模型只将
    `true` 赋给 `r`，因为这足以使断言为真，而不管 `p`、`q` 和 `s` 的值是什么。这告诉你双向引理是可满足的，但并不能证明它是有效的。
- en: To prove that the lemma is valid, you reset Z3’s stack of assertions ➎, declare
    the same constants as before ➏, and then assert the negation of the bidirectional
    lemma ➐. Using `check-sat`, you confirm that the negation of the lemma is unsatisfiable
    ➑, proving that the bidirectional lemma is valid.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明引理是有效的，你需要重置 Z3 的断言栈 ➎，声明与之前相同的常量 ➏，然后断言双向引理的否定 ➐。通过使用 `check-sat`，你可以确认引理的否定是不可满足的
    ➑，从而证明双向引理是有效的。
- en: In addition to propositional logic, Z3 can also solve *effectively propositional*
    formulas, which are a decidable subset of formulas from predicate logic. I won’t
    go over the details of effectively propositional formulas here since you won’t
    need to use predicate logic for the symbex purposes in this book.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命题逻辑外，Z3 还可以解决 *有效命题* 公式，它是谓词逻辑中的一个可判定子集。在这里我不会详细讨论有效命题公式，因为在本书的符号执行目的中，你不需要使用谓词逻辑。
- en: '*12.2.4 Simplifying Expressions*'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.2.4 简化表达式*'
- en: Z3 can also simplify expressions, as shown in [Listing 12-6](ch12.xhtml#ch12list6).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Z3 也可以简化表达式，如在[示例 12-6](ch12.xhtml#ch12list6)中所示。
- en: '*Listing 12-6: Simplifying a formula with Z3*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 12-6：使用 Z3 简化公式*'
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example declares two integers called `x` and `y` ➊ and then calls Z3’s
    `simplify` command to simplify the formula `3x + 2y + 5 + x + y` ➋. Z3 simplifies
    this to `5 + 4x + 3y`. Note that in this example, I’ve used Z3’s ability to take
    more than two operands for the + operator and add them all together in one go.
    In simple examples like this, Z3’s `simplify` command works well, but it may not
    work as well in more complex cases. Z3’s simplification is primarily meant to
    benefit programs like symbex engines that process formulas automatically, not
    to improve human readability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子声明了两个整数，分别为 `x` 和 `y` ➊，然后调用 Z3 的 `simplify` 命令来简化公式 `3x + 2y + 5 + x +
    y` ➋。Z3 将其简化为 `5 + 4x + 3y`。请注意，在这个例子中，我利用了 Z3 的能力，使其能够对 + 运算符使用两个以上的操作数，并一次性将它们相加。在像这样的简单示例中，Z3
    的 `simplify` 命令效果很好，但在更复杂的情况下，可能效果不佳。Z3 的简化主要是为了使像符号执行引擎这样的程序能够自动处理公式，而不是为了提高人类的可读性。
- en: '*12.2.5 Modeling Constraints for Machine Code with Bitvectors*'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.2.5 使用位向量建模机器码的约束*'
- en: So far, all the examples have used Z3’s arbitrary precision `Int` data type.
    If you use arbitrary precision data types to model a binary, the result may not
    be representative of reality because binaries operate on fixed-width integers
    that offer only limited precision. That’s why Z3 also offers *bitvectors*, which
    are fixed-width integers perfectly suited for use in symbolic execution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有示例都使用了 Z3 的任意精度 `Int` 数据类型。如果你使用任意精度数据类型来建模二进制数，结果可能并不能准确反映现实情况，因为二进制操作是在固定宽度的整数上进行的，这些整数的精度有限。这就是为什么
    Z3 还提供了 *位向量*，它们是固定宽度的整数，特别适合用于符号执行。
- en: To manipulate bitvectors, you use dedicated operators like `bvadd`, `bvsub`,
    and `bvmul` instead of the usual integers operators like +, −, and ×. [Table 12-1](ch12.xhtml#ch12tab1)
    shows an overview of the most common bitvector operators. You’ll see a lot of
    these if you inspect the constraints and symbolic expressions that symbex engines
    like Triton pass to the constraint solver. Moreover, knowledge of these operators
    comes in handy when building your own symbex tools, as you’ll do in [Chapter 13](ch13.xhtml#ch13).
    Let’s discuss how to use the operators listed in [Table 12-1](ch12.xhtml#ch12tab1)
    in practice.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要操作位向量，你需要使用专门的运算符，如 `bvadd`、`bvsub` 和 `bvmul`，而不是通常的整数运算符如 +、− 和 ×。[表 12-1](ch12.xhtml#ch12tab1)
    显示了最常见的位向量运算符的概览。如果你检查像 Triton 这样的符号执行引擎传递给约束求解器的约束和符号表达式，你会看到很多这些运算符。此外，了解这些运算符在构建你自己的符号执行工具时非常有用，正如你将在[第
    13 章](ch13.xhtml#ch13)中学习的那样。让我们讨论如何在实践中使用[表 12-1](ch12.xhtml#ch12tab1)中列出的运算符。
- en: Z3 allows you to create bitvectors of any desired bit width. There are several
    ways to achieve this, as you can see in the first part of [Table 12-1](ch12.xhtml#ch12tab1)
    ➊. First, you can create a 4-bit-wide bitvector constant containing the bits `1101`
    using the notation `#b1101`. Similarly, the notation `#xda` creates an 8-bit-wide
    bitvector containing the value `0xda`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Z3 允许你创建任意位宽的位向量。你可以通过多种方式实现这一点，如[表 12-1](ch12.xhtml#ch12tab1)的第一部分 ➊ 所示。首先，你可以使用符号
    `#b1101` 创建一个 4 位宽的位向量常量，包含位值 `1101`。类似地，符号 `#xda` 创建一个 8 位宽的位向量，包含值 `0xda`。
- en: As you can see, for binary or hexadecimal constants, Z3 automatically infers
    the minimum size the bitvector needs to have. To declare decimal constants, you
    need to state both the bitvector’s value and its width explicitly. For instance,
    the notation `(_ bv10 32)` creates a 32-bit-wide bitvector containing the value
    10\. You can also declare bitvector constants with an undetermined value using
    the notation `(declare-const x (_ BitVec 32))`, where `x` is the constant’s name
    and `32` is its bit width.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于二进制或十六进制常量，Z3 会自动推断出位向量需要的最小大小。为了声明十进制常量，你需要明确声明位向量的值和位宽。例如，符号 `(_
    bv10 32)` 创建了一个 32 位宽的位向量，包含值 10。你还可以使用符号 `(declare-const x (_ BitVec 32))` 声明一个未确定值的位向量常量，其中
    `x` 是常量的名称，`32` 是它的位宽。
- en: '**Table 12-1:** Common Z3 Bitvector Operators'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 12-1：** 常见 Z3 位向量运算符'
- en: '| **Operation** | **Description** | **Example** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** | **示例** |'
- en: '| ➊ **Bitvector creation** |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| ➊ **位向量创建** |'
- en: '| `#b<value>` | Binary bitvector constant | `#b1101        ; 1101` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `#b<value>` | 二进制位向量常量 | `#b1101        ; 1101` |'
- en: '| `#x<value>` | Hexadecimal bitvector constant | `#xda           ; 0xda` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `#x<value>` | 十六进制位向量常量 | `#xda           ; 0xda` |'
- en: '| `(_ bv<value> <width>)` | Decimal bitvector constant | `(_ bv10 32) ; 10
    (32 bits wide)` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `(_ bv<value> <width>)` | 十进制位向量常量 | `(_ bv10 32) ; 10 (32 位宽)` |'
- en: '| `(_ BitVec <width>)` | Type for `<width>`-bit bitvector | `(declare-const
    x (_ BitVec 32))` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `(_ BitVec <width>)` | `<width>` 位位向量类型 | `(declare-const x (_ BitVec 32))`
    |'
- en: '| ➋ **Arithmetic operators** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| ➋ **算术运算符** |'
- en: '| `bvadd` | Addition | `(bvadd x #x10)          ; x + 0x10` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `bvadd` | 加法 | `(bvadd x #x10)          ; x + 0x10` |'
- en: '| `bvsub` | Subtraction | `(bvsub #x20 y)          ; 0x20 - y` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `bvsub` | 减法 | `(bvsub #x20 y)          ; 0x20 - y` |'
- en: '| `bvmul` | Multiplication | `(bvmul #x2 #x3)         ; 6` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `bvmul` | 乘法 | `(bvmul #x2 #x3)         ; 6` |'
- en: '| `bvsdiv` | Signed division | `(bvsdiv x y)            ; x/y` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `bvsdiv` | 有符号除法 | `(bvsdiv x y)            ; x/y` |'
- en: '| `bvudiv` | Unsigned division | `(bvudiv y x)            ; y/x` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `bvudiv` | 无符号除法 | `(bvudiv y x)            ; y/x` |'
- en: '| `bvsmod` | Signed modulo | `(bvsmod x y)            ; x % y` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `bvsmod` | 有符号模运算 | `(bvsmod x y)            ; x % y` |'
- en: '| `bvneg` | Two''s complement | `(bvneg #b1101)          ; 0011` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `bvneg` | 二补码 | `(bvneg #b1101)          ; 0011` |'
- en: '| `bvshl` | Left shift | `(bvshl #b0011 #x1)      ; 0110` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `bvshl` | 左移 | `(bvshl #b0011 #x1)      ; 0110` |'
- en: '| `bvlshr` | Logical (unsigned) right shift | `(bvlshr #b1000 #x1)     ; 0100`
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `bvlshr` | 逻辑（无符号）右移 | `(bvlshr #b1000 #x1)     ; 0100` |'
- en: '| `bvashr` | Arithmetic (signed) right shift | `(bvashr #b1000 #x1)     ; 1100`
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `bvashr` | 算术（带符号）右移 | `(bvashr #b1000 #x1)     ; 1100` |'
- en: '| ➌ **Bitwise operators** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| ➌ **按位操作符** |'
- en: '| `bvor` | Bitwise OR | `(bvor #x1 #x2)              ; 3` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `bvor` | 按位 OR | `(bvor #x1 #x2)              ; 3` |'
- en: '| `bvand` | Bitwise AND | `(bvand #xffff #x0001)       ; 1` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `bvand` | 按位 AND | `(bvand #xffff #x0001)       ; 1` |'
- en: '| `bvxor` | Bitwise XOR | `(bvxor #x3 #x5)             ; 6` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `bvxor` | 按位 XOR | `(bvxor #x3 #x5)             ; 6` |'
- en: '| `bvnot` | Bitwise NOT (one''s complement) | `(bvnot x);                 
    ∼x` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `bvnot` | 按位取反（补码） | `(bvnot x);                  ∼x` |'
- en: '| ➍ **Comparison operators** |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| ➍ **比较操作符** |'
- en: '| `=` | Equality | `(= x y)           ; x == y` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 相等 | `(= x y)           ; x == y` |'
- en: '| `bvult` | Unsigned less than | `(bvult x #x1a) ; x < 0x1a` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `bvult` | 无符号小于 | `(bvult x #x1a) ; x < 0x1a` |'
- en: '| `bvslt` | Signed less than | `(bvslt x #x1a) ; x < 0x1a` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `bvslt` | 带符号小于 | `(bvslt x #x1a) ; x < 0x1a` |'
- en: '| `bvugt` | Unsigned greater than | `(bvugt x y)       ; x > y` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `bvugt` | 无符号大于 | `(bvugt x y)       ; x > y` |'
- en: '| `bvsgt` | Signed greater than | `(bvsgt x y)       ; x > y` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `bvsgt` | 带符号大于 | `(bvsgt x y)       ; x > y` |'
- en: '| `bvule` | Unsigned less than or equal | `(bvule x #x55) ; x <= 0x55` |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `bvule` | 无符号小于或等于 | `(bvule x #x55) ; x <= 0x55` |'
- en: '| `bvsle` | Signed less than or equal | `(bvsle x #x55) ; x <= 0x55` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `bvsle` | 带符号小于或等于 | `(bvsle x #x55) ; x <= 0x55` |'
- en: '| `bvuge` | Unsigned greater than or equal | `(bvuge x y)       ; x >= y` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `bvuge` | 无符号大于或等于 | `(bvuge x y)       ; x >= y` |'
- en: '| `bvsge` | Signed greater than or equal | `(bvsge x y)       ; x >= y` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `bvsge` | 带符号大于或等于 | `(bvsge x y)       ; x >= y` |'
- en: '| ➎ **Bitvector concatenation and extraction** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| ➎ **按位向量连接与提取** |'
- en: '| `concat` | Concatenate bitvectors | `(concat #x4 #x8)       ; 0x48` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `concat` | 连接按位向量 | `(concat #x4 #x8)       ; 0x48` |'
- en: '| `(_ extract <hi> <lo>)` | Extract bits <lo> through <hi> | `((_ extract 3
    0) #x48) ; 0x8` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `(_ extract <hi> <lo>)` | 提取从 <lo> 到 <hi> 的位 | `((_ extract 3 0) #x48) ;
    0x8` |'
- en: 'Z3 also supports arithmetic bitvector operators to mirror all the primitive
    operations supported in languages like C/C++ and instruction sets like x86 ➋.
    For instance, the Z3 command `(assert (= y (bvadd x #x10)))` asserts that the
    bitvector `y` must be equal to the bitvector `x + 0x10`. For many operations,
    Z3 includes both signed and unsigned variants. For example, `(bvsdiv x y)` performs
    a signed division `x/y`, while `(bvudiv x y)` does an unsigned division. Also
    note that Z3 demands that both operands in an arithmetic bitvector operation have
    the same bit width.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'Z3 还支持算术按位向量操作符，镜像了 C/C++ 等语言和 x86 等指令集所支持的所有基本操作 ➋。例如，Z3 命令 `(assert (= y
    (bvadd x #x10)))` 表示按位向量 `y` 必须等于按位向量 `x + 0x10`。对于许多操作，Z3 提供了带符号和无符号的变体。例如，`(bvsdiv
    x y)` 执行带符号除法 `x/y`，而 `(bvudiv x y)` 执行无符号除法。还要注意，Z3 要求算术按位向量操作中的两个操作数具有相同的位宽。'
- en: In the “Example” column of [Table 12-1](ch12.xhtml#ch12tab1), I’ve listed examples
    of all of Z3’s common bitvector operations. The semicolons denote comments that
    show the C/C++ equivalent or arithmetic outcome of the Z3 operation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [表 12-1](ch12.xhtml#ch12tab1) 的“示例”列中，我列出了所有 Z3 常见按位向量操作的示例。分号后是注释，显示了 Z3
    操作的 C/C++ 等效或算术结果。
- en: In addition to arithmetic operators, Z3 also implements common bitwise operators
    such as OR (equivalent to C’s `|`), AND (`&`), XOR (`^`), and NOT (`~`) ➌. It
    also implements comparisons like `=` to check for equality between bitvectors,
    `bvult` to perform an unsigned “less than” comparison, and so on ➍. The supported
    comparisons are quite similar to those supported by x86’s conditional jumps and
    are especially useful in combination with Z3’s `ite` operator. For instance, `(ite
    (bvsge x y) 22 44)` evaluates to `22` if `x >= y`, or `44` otherwise.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 除了算术操作符，Z3 还实现了常见的按位操作符，如 OR（相当于 C 的 `|`）、AND（`&`）、XOR（`^`）和 NOT（`~`） ➌。它还实现了比较操作符，如
    `=` 用于检查按位向量的相等性，`bvult` 用于执行无符号“小于”比较，等等 ➍。支持的比较操作符与 x86 的条件跳转指令非常相似，特别是在与 Z3
    的 `ite` 操作符结合使用时非常有用。例如，`(ite (bvsge x y) 22 44)` 如果 `x >= y`，结果为 `22`，否则为 `44`。
- en: You can also concatenate two bitvectors or extract part of a bitvector ➎. This
    is useful when you have to equalize the size of two bitvectors to allow a certain
    operation or when you’re interested in only part of the bitvector.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以连接两个按位向量或提取一个按位向量的一部分 ➎。这在你需要使两个按位向量的大小一致以进行某些操作，或者你只关心按位向量的一部分时非常有用。
- en: Now that you’re familiar with Z3’s bitvector operators, let’s take a look at
    a practical example that uses these operators.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 Z3 的按位向量操作符，让我们来看一个实际示例，展示如何使用这些操作符。
- en: '*12.2.6 Solving an Opaque Predicate Over Bitvectors*'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*12.2.6 解决一个不透明的按位向量谓词*'
- en: Let’s solve an opaque predicate with Z3 to see how to use bitvector operations
    in practice. Opaque predicates are branch conditions that always evaluate to true
    or false, without this being obvious to a reverse engineer. They’re used as code
    obfuscations to make code harder for reverse engineers to understand, for instance
    by inserting dead code that’s never reached in practice.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Z3来解决一个不透明谓词，看看如何在实践中使用位向量操作。不透明谓词是总是被评估为真或假的分支条件，但对逆向工程师来说并不明显。它们作为代码混淆手段，使逆向工程师更难理解代码，例如通过插入在实践中从未被执行的死代码。
- en: In some cases, you can use a constraint solver like Z3 to prove that a branch
    is opaquely true or false. For example, consider an opaquely false branch that
    makes use of the fact that ∀*x* ∈ ℤ,2 | (*x* + *x*²). In other words, for any
    integer *x*, the result of *x* + *x*² is zero modulo two. You can use this to
    construct a branch `if((x + x*x) % 2 != 0)` that will never be taken, no matter
    the value of `x`, without that being immediately obvious. You can then insert
    confusing bogus code in the “taken” path of the branch to lead reverse engineers
    astray.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可以使用像Z3这样的约束求解器来证明某个分支是透明地为真或假的。例如，考虑一个透明为假的分支，它利用了∀*x* ∈ ℤ，2 | (*x*
    + *x*²)这一事实。换句话说，对于任何整数*x*，*x* + *x*²的结果对2取模为零。你可以利用这一点构造一个分支`if((x + x*x) % 2
    != 0)`，无论`x`的值为何，它都永远不会被执行，而这一点并不立刻显现出来。然后，你可以在分支的“执行”路径中插入混淆的虚假代码，误导逆向工程师。
- en: '[Listing 12-7](ch12.xhtml#ch12list7) shows how to model this branch in Z3 and
    prove that it can never be taken.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 12-7](ch12.xhtml#ch12list7)展示了如何在Z3中建模这个分支并证明它永远不会被执行。'
- en: '*Listing 12-7: Solving an opaque predicate with Z3*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 12-7: 使用Z3解决不透明谓词*'
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, you declare a 64-bit bitvector called `x` ➊ to use in the branch condition.
    You then assert the branch condition itself ➋, and finally you check its satisfiability
    with `check-sat` ➌. Because `check-sat` returns `unsat`, you know the branch condition
    can never be true, so you can safely ignore any code inside the branch when reverse
    engineering.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明一个64位的位向量`x` ➊用于分支条件。然后你断言分支条件本身 ➋，最后你通过`check-sat` ➌来检查它的可满足性。因为`check-sat`返回`unsat`，你知道这个分支条件永远不可能为真，因此在进行逆向工程时，你可以安全地忽略分支内部的任何代码。
- en: As you can see, manually modeling and proving even a simple opaque predicate
    like this is tedious. But with symbolic execution, you can solve problems like
    this automatically.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，手动建模并证明像这样的简单不透明谓词是非常繁琐的。但是，通过符号执行，你可以自动解决像这样的难题。
- en: 12.3 Summary
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3 小结
- en: In this chapter, you learned the principles of symbolic execution and constraint
    solving. Symbolic execution is a powerful but unscalable technique that should
    be used with care. For that reason, there are several ways of optimizing symbex
    tools, most of which rely on minimizing the amount of code to analyze and the
    load on the constraint solver. In [Chapter 13](ch13.xhtml#ch13), you’ll learn
    how to use symbex in practice by building practical symbex tools with Triton.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了符号执行和约束求解的原理。符号执行是一项强大的技术，但由于其不可扩展性，应谨慎使用。因此，有几种优化符号执行工具的方法，其中大多数依赖于最小化需要分析的代码量以及约束求解器的负载。在[第13章](ch13.xhtml#ch13)中，你将通过使用Triton构建实用的符号执行工具，了解如何在实践中使用符号执行。
- en: Exercises
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 习题
- en: 1\. Tracking Symbolic State
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 跟踪符号状态
- en: 'Consider the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE7]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a tree diagram that shows how the symbolic state evolves for every path
    through this code (similar to [Figure 12-1](ch12.xhtml#ch12fig1)). The statement
    `2**z` stands for 2^z.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一棵树状图，展示每条路径上符号状态如何变化（类似于[图12-1](ch12.xhtml#ch12fig1)）。语句`2**z`代表2^z。
- en: 'Note that the last two statements in this code are executed at the end of each
    code path, regardless of which branches were taken. However, the value of `z`
    in these last statements depends on which path was taken before. To capture this
    behavior in the tree, you have these two options:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中的最后两条语句在每条代码路径的末尾都会执行，无论哪些分支被执行。然而，这些最后语句中`z`的值取决于之前执行的是哪条路径。为了在树状图中捕捉到这一行为，你有以下两种选择：
- en: 1\. Create a private copy of the last two statements for each path in your diagram.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 为你图中的每条路径创建前两条语句的私有副本。
- en: 2\. Merge all paths back together at these last statements and model the symbolic
    value of `z` with a conditional *if-then-else* expression that depends on the
    taken path.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 在这些最后的语句处将所有路径合并，并使用一个条件的*if-then-else*表达式来建模`z`的符号值，该表达式依赖于执行的路径。
- en: 2\. Proving Reachability
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 证明可达性
- en: Use Z3 to figure out which of the calls to `foo`, `bar`, and `baz` are reachable
    in the listing from the previous exercise. Model the relevant operations and branches
    using bitvectors.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Z3 确定在之前练习中的列表中，哪些对 `foo`、`bar` 和 `baz` 的调用是可达的。使用位向量建模相关的操作和分支。
- en: 3\. Finding Opaque Predicates
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 查找不透明谓词
- en: Use Z3 to check whether any of the conditionals in the previous listing are
    opaque predicates. If so, are they opaquely true or false? Which code is unreachable
    and therefore safe to eliminate from the listing?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Z3 检查之前列表中的任何条件语句是否为不透明谓词。如果是，它们是永远为真还是永远为假？哪些代码是不可达的，因此可以安全地从列表中删除？
