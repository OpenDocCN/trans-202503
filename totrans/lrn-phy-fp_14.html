<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_187"/><span class="big">13</span><br/>CREATING 2D AND 3D ANIMATIONS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">A picture that changes over time can be a good way to visualize many situations. The Haskell Prelude itself does not have any support for animation, but some good library packages are available at <a href="https://hackage.haskell.org">https://hackage.haskell.org</a>. For two-dimensional pictures and animations, we’ll use the <code>gloss</code> package. For three-dimensional pictures and animations, we’ll use a package named <code>not-gloss</code>.</p>&#13;
<h3 class="h3" id="ch13lev1">2D Animation</h3>&#13;
<p class="noindent">The <code>gloss</code> package supplies the <code>Graphics.Gloss</code> module, which provides four main functions: display, animate, simulate, and play. The first is for still pictures, the second and third are for pictures that change with time, and the fourth is for pictures that change with time and user input. We are interested primarily in the first three functions. We’ll describe these functions in the next few sections.</p>&#13;
<h4 class="h4" id="ch13lev2"><span epub:type="pagebreak" id="page_188"/>Displaying a 2D Picture</h4>&#13;
<p class="noindent">The function <code>display</code> produces a static picture. Let’s ask GHCi for the type of <code>display</code>. Since <code>display</code> is not part of the Prelude, we must first load the module.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gloss</span>&#13;
Prelude Graphics.Gloss&gt; <span class="codestrong1">:t display</span>&#13;
display :: Display -&gt; Color -&gt; Picture -&gt; IO ()</pre>&#13;
<p class="indent">The types <code>Display</code>, <code>Color</code>, and <code>Picture</code> are defined by the <code>Graphics.Gloss</code> module, or perhaps by another module in the <code>gloss</code> package that is imported by <code>Graphics.Gloss</code>. The types <code>Display</code> and <code>Color</code> are for display mode and background color, respectively. The most interesting type is <code>Picture</code>, which represents the type of things that can be displayed. The <code>gloss</code> documentation on <code>Picture</code> describes the pictures we can make (lines, circles, polygons, and so on). You can find the documentation at <a href="https://hackage.haskell.org/package/gloss">https://hackage.haskell.org/package/gloss</a> by clicking on <code>Graphics.Gloss</code>.</p>&#13;
<p class="indent">GHCi is not so good at showing the pictures that <code>gloss</code> creates, so it’s better to make a stand-alone program. Let’s write a program to get us familiar with the default coordinate system the <code>Graphics.Gloss</code> module uses. We’ll draw a red line segment from the origin to the point (100,0) and a green line segment from the origin to the point (0,100). Because <code>gloss</code> measures distance in pixels, we’ll use 100 so that the lines we produce will be long enough to see on the screen.</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "Axes" (1000, 700) (10, 10)&#13;
&#13;
axes :: Picture&#13;
axes = Pictures [Color red   $ Line [(0,0),(100,  0)]&#13;
                ,Color green $ Line [(0,0),(  0,100)]&#13;
                ]&#13;
&#13;
main :: IO ()&#13;
main = display displayMode black axes</pre>&#13;
<p class="indent">As usual, we turn on warnings. Then we import the <code>Graphics.Gloss</code> module. We need to do this because the code that follows uses the types <code>Display</code> and <code>Picture</code>; the data constructors <code>InWindow</code>, <code>Pictures</code>, <code>Color</code>, and <code>Line</code>; the constants <code>red</code>, <code>green</code>, and <code>black</code>; and the function <code>display</code>. These names are all defined in the <code>Graphics.Gloss</code> module. Without the <code>import</code> statement, we would get “Variable not in scope” errors every time we used each of those names.</p>&#13;
<p class="indent">We define a constant <code>displayMode</code> to hold the value of type <code>Display</code> that the function <code>display</code> requires. We give the name “Axes” to the window that <span epub:type="pagebreak" id="page_189"/>will be opened by the <code>display</code> function. We ask for the window to be 1,000 pixels wide and 700 pixels high, and we ask for it to be placed 10 pixels up and 10 pixels over from whatever the window system thinks is the origin.</p>&#13;
<p class="indent">We define a constant called <code>axes</code> to hold the <code>Picture</code> we want to make. We produce the picture using the data constructor <code>Pictures</code>, which gives a way to combine a list of pictures into a single picture. We can ask GHCi for the types of some of the things that didn’t get explicit types in our code.</p>&#13;
<pre>Prelude Graphics.Gloss&gt; <span class="codestrong1">:t Line [(0,0),(100,0)]</span>&#13;
Line [(0,0),(100,0)] :: Picture&#13;
Prelude Graphics.Gloss&gt; <span class="codestrong1">:t Color green $ Line [(0,0),(0,100)]</span>&#13;
Color green $ Line [(0,0),(0,100)] :: Picture</pre>&#13;
<p class="indent">The <code>main</code> function here uses the function <code>display</code> to make the picture. We pass <code>display</code> our <code>displayMode</code>, the background color <code>black</code>, and our picture <code>axes</code>.</p>&#13;
<p class="indent">When we compile and run the program above using one of the three methods described in <a href="ch12.xhtml">Chapter 12</a>, we should see a red horizontal line and a green vertical line. The default <code>gloss</code> orientation has the x-axis going toward the right and the y-axis going upward. Depending on your operating system, you might need to hit CTRL-C twice to close the graphics window.</p>&#13;
<p class="indent">The <code>gloss</code> package does not have a primitive disk, or filled circle, picture. As a second example of the <code>display</code> function, let’s make a picture of a blue circle and a red disk, side by side.</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "My Window" (1000, 700) (10, 10)&#13;
&#13;
blueCircle :: Picture&#13;
blueCircle = Color blue (Circle 100)&#13;
&#13;
disk :: Float -&gt; Picture&#13;
disk radius = ThickCircle (radius / 2) radius&#13;
&#13;
redDisk :: Picture&#13;
redDisk = Color red (disk 100)&#13;
&#13;
wholePicture :: Picture&#13;
wholePicture = Pictures [Translate (-120) 0 blueCircle&#13;
                        ,Translate   120  0 redDisk&#13;
                        ]&#13;
&#13;
main :: IO ()&#13;
main = display displayMode black wholePicture</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_190"/>Here we used the same warnings, import, and <code>displayMode</code> lines as before. The constant <code>blueCircle</code> is a blue circle with a radius of 100 pixels.</p>&#13;
<p class="indent">Since <code>gloss</code> does not provide a function to make a disk, we’ll write our own. Our <code>disk</code> function uses <code>gloss</code>’s built-in <code>ThickCircle</code> function to make a disk. <code>ThickCircle</code> takes a radius and a thickness as inputs. Here we choose the radius of the thick circle to be half of the desired radius of the disk, and we choose the thickness to be the full desired radius of the disk. This circle is so thick that there is no hole left in the middle, making a disk.</p>&#13;
<p class="indent">The constant <code>redDisk</code> is a red disk with a radius of 100 pixels. The constant <code>wholePicture</code> uses the <code>Translate</code> data constructor of the <code>Picture</code> type to shift the circle to the left and the disk to the right. The <code>main</code> function is very similar to that of the last program, except now we are displaying <code>wholePicture</code>.</p>&#13;
<p class="indent">When we run the program, we should see a blue circle to the left of a red disk of the same size.</p>&#13;
<h4 class="h4" id="ch13lev3">Making a 2D Animation</h4>&#13;
<p class="noindent">Given a picture as a function of time, the function <code>animate</code> produces an animation. Let’s ask GHCi the type of <code>animate</code>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gloss</span>&#13;
Prelude Graphics.Gloss&gt; <span class="codestrong1">:t animate</span>&#13;
animate :: Display -&gt; Color -&gt; (Float -&gt; Picture) -&gt; IO ()</pre>&#13;
<p class="indent">The difference in type compared to <code>display</code> is that <code>Picture</code> in <code>display</code> has been replaced by <code>Float -&gt; Picture</code> in <code>animate</code>. The <code>animate</code> function uses a <code>Float</code> to describe time, so an expression of type <code>Float -&gt; Picture</code> is a function from time to a picture, or a picture as a function of time.</p>&#13;
<p class="indent">Here is an example of how to use <code>animate</code>:</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "My Window" (1000, 700) (10, 10)&#13;
&#13;
disk :: Float -&gt; Picture&#13;
disk radius = ThickCircle (radius / 2) radius&#13;
&#13;
redDisk :: Picture&#13;
redDisk = Color red (disk 25)&#13;
&#13;
projectileMotion :: Float -&gt; Picture&#13;
projectileMotion t = Translate (xDisk t) (yDisk t) redDisk&#13;
&#13;
xDisk :: Float -&gt; Float&#13;
xDisk t = 40 * t&#13;
&#13;
<span epub:type="pagebreak" id="page_191"/>yDisk :: Float -&gt; Float&#13;
yDisk t = 80 * t - 4.9 * t**2&#13;
&#13;
main :: IO ()&#13;
main = animate displayMode black projectileMotion</pre>&#13;
<p class="indent">The function <code>projectileMotion</code> takes a <code>Float</code> (the time) as input and produces a <code>Picture</code> by translating the red disk to the right by <code>xDisk t</code> and upward by <code>yDisk t</code>. The functions <code>xDisk</code> and <code>yDisk</code> are given explicitly as functions of time.</p>&#13;
<p class="indent">When we compile and run this code, we’ll see a red disk experiencing projectile motion. One meter is represented by one pixel, and one second of time in the real world is one second of time in the animation. The projectile starts with an initial x-component of velocity of 40 m/s and an initial y-component of velocity of 80 m/s.</p>&#13;
<h4 class="h4" id="ch13lev4">Making a 2D Simulation</h4>&#13;
<p class="noindent">The <code>gloss</code> package’s <code>simulate</code> function allows the user to make an animation when an explicit function describing a picture as a function of time is not available. Let’s ask GHCi the type of <code>simulate</code>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gloss</span>&#13;
Prelude Graphics.Gloss&gt; <span class="codestrong1">:t simulate</span>&#13;
simulate&#13;
  :: Display&#13;
     -&gt; Color&#13;
     -&gt; Int&#13;
     -&gt; model&#13;
     -&gt; (model -&gt; Picture)&#13;
     -&gt; (Graphics.Gloss.Data.ViewPort.ViewPort&#13;
         -&gt; Float -&gt; model -&gt; model)&#13;
     -&gt; IO ()</pre>&#13;
<p class="indent">The <code>simulate</code> function asks for six pieces of information. The first two, display mode (type <code>Display</code>) and background color (type <code>Color</code>), are the same as in <code>display</code> and <code>animate</code>. The third piece of information (an <code>Int</code>) is the rate, in updates per second, at which the simulation should run. The fourth piece of information has the type variable <code>model</code> instead of a concrete type. We can tell that <code>model</code> is a type variable because it starts with a lowercase letter; it cannot be a constant or a function because it sits in a type signature in the place where a type needs to sit. We, the users of the <code>simulate</code> function, get to decide what type to use for <code>model</code>. We need a type that can hold the <em>state</em> of the system we are simulating, which is the collection of information necessary to (1) produce a picture at any given moment of time and (2) determine what will happen next as time evolves. This notion of state will play a large role in the physics we describe in <a href="part02.xhtml">Parts II</a> and <a href="part03.xhtml">III</a> of the book. The value of type <code>model</code> that <code>simulate</code> needs is the initial state of the situation to be displayed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_192"/>The fifth piece of information (type <code>model -&gt; Picture</code>) is a function that describes what picture to produce given a value of type <code>model</code>. The sixth piece of information <code>simulate</code> needs is a function (type <code>Viewport -&gt; Float -&gt;</code> <code>model -&gt; model</code>) that describes how the state of the system should advance in time. The <code>Float</code> represents a time step here, and we will not use the <code>Viewport</code>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list1">Listing 13-1</a> gives a complete program that shows how to use the <code>simulate</code> function.</p>&#13;
<pre id="ch13list1">{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "My Window" (1000, 700) (10, 10)&#13;
&#13;
-- updates per second of real time&#13;
rate :: Int&#13;
rate = 2&#13;
&#13;
disk :: Float -&gt; Picture&#13;
disk radius = ThickCircle (radius / 2) radius&#13;
&#13;
redDisk :: Picture&#13;
redDisk = Color red (disk 25)&#13;
&#13;
type State = (Float,Float)&#13;
&#13;
initialState :: State&#13;
initialState = (0,0)&#13;
&#13;
displayFunc :: State -&gt; Picture&#13;
displayFunc (x,y) = Translate x y redDisk&#13;
&#13;
updateFunc :: Float -&gt; State -&gt; State&#13;
updateFunc dt (x,y) = (x + 10 * dt, y - 5 * dt)&#13;
&#13;
main :: IO ()&#13;
main = simulate displayMode black rate initialState displayFunc&#13;
       (\_ -&gt; updateFunc)</pre>&#13;
<p class="listing"><em>Listing 13-1: Sample use of the <span class="codeitalic1">simulate</span> function from the <span class="codeitalic1">gloss</span> package</em></p>&#13;
<p class="indent">The display mode and background color are the same as before. We define a constant <code>rate</code> to hold the simulation rate. For the type variable <code>model</code>, we’ve chosen <code>(Float,Float)</code> and given it the type synonym <code>State</code>. This state is meant to represent the (x, y) coordinates of the current location of the red disk. The initial value of the state is defined in <code>initialState</code>.</p>&#13;
<p class="indent">The heart of the simulation is contained in the two functions <code>displayFunc</code> and <code>updateFunc</code>. The first tells how to make a picture from a state. In this <span epub:type="pagebreak" id="page_193"/>case, we use the (x, y) coordinates in the state to translate the red disk over <em>x</em> and up <em>y</em>. The display function only cares about the current state of affairs (the current values of <em>x</em> and <em>y</em>). It has nothing to do with how the picture changes with time.</p>&#13;
<p class="indent">The update function <code>updateFunc</code> explains how the state changes with time. We need to give a rule for what the new state will be in terms of the old state and a time step <code>dt</code>. In this case, we add 10 pixels/second to the x-value and subtract 5 pixels/second from the y-value.</p>&#13;
<p class="indent">When we run the program, we should see the red disk move to the right and downward as the simulation evolves. The simulation will be jerky because we chose a rate of 2 updates/second, so you see each update as a discrete motion. Try increasing the rate to get a smoother animation. High definition TV uses 24–60 frames per second, so you shouldn’t need to go higher than that. If the lights in your building dim, you’ve picked a frame rate that’s too high.</p>&#13;
<p class="indent">For one more example of the <code>simulate</code> function, let’s see how the projectile motion we did before with <code>animate</code> would look when done with <code>simulate</code>. The difference between constant velocity motion and projectile motion is that the velocity changes in projectile motion. To allow the velocity to change, we need to expand the information in the state to include velocity as well as the position of the red disk. For this purpose, we define the type synonyms <code>Position</code>, <code>Velocity</code>, and <code>State</code> in the code in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>.</p>&#13;
<p class="indent">Our <code>initialState</code> now needs to contain both the initial position <code>(0,0)</code> and an initial velocity <code>(40,80)</code>. The initial x-component of velocity is 40 m/s, and the initial y-component is 80 m/s.</p>&#13;
<p class="indent">Our display function doesn’t need to change in meaning from the previous simulation. The display of the red disk still depends only on the position of the disk and not on the current velocity. However, the <code>displayFunc</code> function needs a little bit of syntactic revision since the type of the state has changed. The syntactic revision entails replacing the argument <code>(x,y)</code> with <code>((x,y),_)</code> to reflect the new type of state. If we left the function entirely unchanged, the compiler would think that the argument <code>(x,y)</code> meant x for position and y for velocity. We would get a type error complaining that the expected type of x is <code>Float</code> but its actual type is <code>Position</code>. The “actual type” of <code>Position</code> comes from the type signature of <code>displayFunc</code>, while the “expected type” of <code>Float</code> comes from the way x is used, as an argument to <code>Translate</code>, in the definition of <code>displayFunc</code>.</p>&#13;
<p class="indent">Let’s implement these changes; the result is in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>.</p>&#13;
<pre id="ch13list2">{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "My Window" (1000, 700) (10, 10)&#13;
&#13;
-- updates per second of real time&#13;
rate :: Int<span epub:type="pagebreak" id="page_194"/>&#13;
rate = 24&#13;
&#13;
disk :: Float -&gt; Picture&#13;
disk radius = ThickCircle (radius / 2) radius&#13;
&#13;
redDisk :: Picture&#13;
redDisk = Color red (disk 25)&#13;
&#13;
type Position = (Float,Float)&#13;
type Velocity = (Float,Float)&#13;
type State = (Position,Velocity)&#13;
&#13;
initialState :: State&#13;
initialState = ((0,0),(40,80))&#13;
&#13;
displayFunc :: State -&gt; Picture&#13;
displayFunc ((x,y),_) = Translate x y redDisk&#13;
&#13;
updateFunc :: Float -&gt; State -&gt; State&#13;
updateFunc dt ((x,y),(vx,vy))&#13;
   = (( x + vx * dt, y +  vy * dt)&#13;
     ,(vx         ,vy - 9.8 * dt))&#13;
&#13;
main :: IO ()&#13;
main = simulate displayMode black rate initialState displayFunc&#13;
       (\_ -&gt; updateFunc)</pre>&#13;
<p class="listing"><em>Listing 13-2: Sample use of the <code>simulate</code> function to produce projectile motion</em></p>&#13;
<p class="indent">The update function is where all of the action happens. The components x and y of position get updated based on the current velocity. The velocity components vx and vy get updated based on the components of acceleration. The x-component of acceleration is 0, so the x-component of velocity stays the same. The y-component of acceleration is – 9.8 m/s<sup>2</sup>, so we update the y-component of velocity using that, assuming that 1 meter represents 1 pixel in our simulation.</p>&#13;
<p class="indent">When we run this program, the results should be the same as the projectile program we wrote with <code>animate</code>.</p>&#13;
<p class="indent">Notice the difference in the information required to produce the projectile motion animation using <code>animate</code> compared to <code>simulate</code>. To use <code>animate</code>, we need to have explicit expressions for the position as a function of time. To use <code>simulate</code>, we provide equivalent information, but it seems like we’re providing less. The state update procedure is a powerful tool in numerically solving equations of motion. We’ll exploit this tool much more in <a href="part02.xhtml">Parts II</a> and <a href="part03.xhtml">III</a> of the book.</p>&#13;
<h3 class="h3" id="ch13lev5"><span epub:type="pagebreak" id="page_195"/>3D Animation</h3>&#13;
<p class="noindent">The <code>not-gloss</code> package provides four main functions whose names are identical to those in <code>gloss</code>: <code>display</code>, <code>animate</code>, <code>simulate</code>, and <code>play</code>. As in <code>gloss</code>, the first is for still pictures, the second and third are for pictures that change with time, and the fourth is for pictures that change with time and user input. We’re interested primarily in the first three functions. The types of these functions are different from those of the corresponding <code>gloss</code> functions, in part because the <code>not-gloss</code> package has a different author from the <code>gloss</code> package. There are similarities between the two packages, but there are also differences that we will point out.</p>&#13;
<h4 class="h4" id="ch13lev6">Displaying a 3D Picture</h4>&#13;
<p class="noindent">Let’s check the type of <code>display</code>. Just as the <code>gloss</code> package has a module named <code>Graphics.Gloss</code> that must be imported before its functions can be used, the <code>not-gloss</code> package has a module named <code>Vis</code> that we must import.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Vis</span>&#13;
Prelude Vis&gt; <span class="codestrong1">:t display</span>&#13;
display :: Real b =&gt; Options -&gt; VisObject b -&gt; IO ()</pre>&#13;
<p class="indent">If we ask about the type class <code>Real</code>, we learn that <code>Real</code> is for numeric types that can be converted to rational numbers:</p>&#13;
<pre>Prelude Vis&gt; <span class="codestrong1">:i Real</span>&#13;
class (Num a, Ord a) =&gt; Real a where&#13;
  toRational :: a -&gt; Rational&#13;
  {-# MINIMAL toRational #-}&#13;
   -- Defined in 'GHC.Real'&#13;
instance Real Word -- Defined in 'GHC.Real'&#13;
instance Real Integer -- Defined in 'GHC.Real'&#13;
instance Real Int -- Defined in 'GHC.Real'&#13;
instance Real Float -- Defined in 'GHC.Float'&#13;
instance Real Double -- Defined in 'GHC.Float'</pre>&#13;
<p class="indent">Our favorite instance of the <code>Real</code> type class is <code>R</code> (or <code>Double</code>). This will be our default choice unless there is a reason to choose something else. If the type variable <code>b</code> in the type of <code>display</code> is <code>R</code>, the type of <code>display</code> is the following:</p>&#13;
<pre>display :: Options -&gt; VisObject R -&gt; IO ()</pre>&#13;
<p class="indent">The display function is asking us to provide two things: a thing with type <code>Options</code>, and the object to be displayed (type <code>VisObject R</code>). The return type <code>IO ()</code> means that the computer will <em>do</em> something (in this case display the object).</p>&#13;
<p class="indent">What kinds of things are there that have type <code>VisObject R</code>? The <code>not-gloss</code> package provides a long list of possibilities, including spheres, cubes, lines, text, and more. You can find documentation at the <a href="https://hackage.haskell.org">https://hackage.haskell.org</a> site by searching for <code>not-gloss</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_196"/>Here is an example that produces a blue cube:</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
&#13;
type R = Double&#13;
&#13;
blueCube :: VisObject R&#13;
blueCube = Cube 1 Solid blue&#13;
&#13;
main :: IO ()&#13;
main = display defaultOpts blueCube</pre>&#13;
<p class="indent">The constant <code>defaultOpts</code> is provided by the <code>Vis</code> module as a set of default options. You can compile this code into a stand-alone program as before. When you run the program, a display window containing a blue cube will open. After the display window opens, press <span class="codestrong1">e</span> to zoom in and <span class="codestrong1">q</span> to zoom out. You can also use the mouse to rotate the cube. These are standard features of <code>not-gloss</code> that we don’t need to program.</p>&#13;
<p class="indent">The next program will get us familiar with the default coordinate system the <code>Vis</code> module uses. We’ll draw a red line segment from the origin to the point (1, 0, 0), a green line segment from the origin to the point (0, 1, 0), and a blue line segment from the origin to the point (0, 0, 1).</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
import Linear&#13;
&#13;
type R = Double&#13;
&#13;
axes :: VisObject R&#13;
axes = VisObjects [Line Nothing [V3 0 0 0, V3 1 0 0] red&#13;
                  ,Line Nothing [V3 0 0 0, V3 0 1 0] green&#13;
                  ,Line Nothing [V3 0 0 0, V3 0 0 1] blue&#13;
                  ]&#13;
&#13;
main :: IO ()&#13;
main = display defaultOpts axes</pre>&#13;
<p class="indent">Here we import the <code>Linear</code> module to have access to the <code>V3</code> constructor. The <code>Linear</code> module defines several kinds of vector; <code>V3</code> is the one used by the <code>Vis</code> module. The <code>Nothing</code> means to use the default line width (try (Just 5) in place of <code>Nothing</code> to get a thicker line width).</p>&#13;
<p class="indent">When we compile and run the program just shown, we see axes for a three-dimensional coordinate system. We see that <code>not-gloss</code>’s default orientation has the x-axis going toward the right and toward the viewer, the y-axis going toward the left and toward the viewer, and the z-axis going downward.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_197"/>Personally, I think having the positive z-axis point downward is disturbing and abhorrent. I like to think of myself as a flexible person, but this crosses a line. (Greg Horn, the author of <code>not-gloss</code>, tells me that the z-down convention is standard in much of the aerospace industry.) Fortunately, <code>not-gloss</code> has tools that allow us to rotate things the way we want. I like to have the x-axis coming mostly out of the page, the y-axis pointing toward the right, and the z-axis pointing upward. Here is a program that will do just that:</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
import Linear&#13;
import SpatialMath&#13;
&#13;
type R = Double&#13;
&#13;
axes :: VisObject R&#13;
axes = VisObjects [Line Nothing [V3 0 0 0, V3 1 0 0] red&#13;
                  ,Line Nothing [V3 0 0 0, V3 0 1 0] green&#13;
                  ,Line Nothing [V3 0 0 0, V3 0 0 1] blue&#13;
                  ]&#13;
&#13;
orient :: VisObject R -&gt; VisObject R&#13;
orient pict = RotEulerDeg (Euler 270 180 0) $ pict&#13;
&#13;
main :: IO ()&#13;
main = display defaultOpts (orient axes)</pre>&#13;
<p class="indent">We import <code>Vis</code> and <code>Linear</code> as before, but here we also import <code>SpatialMath</code> so we can use <code>Euler</code> to perform three-dimensional rotations using Euler angles. The <code>axes</code> picture has not changed. We define a function <code>orient</code> that takes a picture as input and gives back a reoriented picture as output. To do this, we perform a rotation specified by Euler angles using the <code>RotEulerDeg</code> data constructor of the <code>VisObject</code> type. In this case, the Euler angles mean we rotate first by 0<sup>∘</sup> about the x-axis, then by 180<sup>∘</sup> about the y-axis, and then by 270<sup>∘</sup> about the z-axis. Equivalently, we can view this as a rotation first about the z-axis by 270<sup>∘</sup>, then about the <em>rotated</em> y-axis by 180<sup>∘</sup>, and then about the rotated x-axis by 0<sup>∘</sup>.</p>&#13;
<p class="indent">Finally, we pass <code>orient axes</code> to <code>display</code> as the picture to be displayed. If you like this way of orienting the coordinate system, you could pass any picture to the function <code>orient</code> before displaying it as a way of using this coordinate system. You could even define your own display function that does the reorientation for you.</p>&#13;
<pre>myDisplay :: VisObject R -&gt; IO ()&#13;
myDisplay pict = display defaultOpts (orient pict)</pre>&#13;
<h4 class="h4" id="ch13lev7"><span epub:type="pagebreak" id="page_198"/>Making a 3D Animation</h4>&#13;
<p class="noindent">Let’s look at the type of <code>animate</code>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Vis</span>&#13;
Prelude Vis&gt; <span class="codestrong1">:t animate</span>&#13;
animate :: Real b =&gt; Options -&gt; (Float -&gt; VisObject b) -&gt; IO ()</pre>&#13;
<p class="indent">The type of <code>animate</code> is the same as the type of <code>display</code>, except that the <code>VisObject b</code> of <code>display</code> is replaced by <code>Float -&gt; VisObject b</code> in <code>animate</code>. Instead of asking us to provide a picture, <code>animate</code> is asking us to provide a function from time to a picture. The <code>animate</code> function demands that we use <code>Float</code> for the real number representing time.</p>&#13;
<p class="indent">The following animation of a rotating blue cube has the cube rotating counterclockwise about the x-axis in my favorite coordinate system (x-axis out of the screen, y-axis to the right, and z-axis up the screen):</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
import SpatialMath&#13;
&#13;
rotatingCube :: Float -&gt; VisObject Float&#13;
rotatingCube t = RotEulerRad (Euler 0 0 t) (Cube 1 Solid blue)&#13;
&#13;
orient :: VisObject Float -&gt; VisObject Float&#13;
orient pict = RotEulerDeg (Euler 270 180 0) $ pict&#13;
&#13;
main :: IO ()&#13;
main = animate defaultOpts (orient . rotatingCube)</pre>&#13;
<p class="indent">Note the use of function composition between <code>rotatingCube</code> and <code>orient</code>. The function <code>rotatingCube</code> takes a number as input and produces a picture as output. The function <code>orient</code> takes a picture as input and produces a (reoriented) picture as output. The composition <code>orient . rotatingCube</code> takes a number as input and produces a picture as output, which is just the type of function that <code>animate</code> wants.</p>&#13;
<h4 class="h4" id="ch13lev8">Making a 3D Simulation</h4>&#13;
<p class="noindent">The <code>not-gloss</code> function <code>simulate</code> allows the user to make an animation when an explicit function describing a picture as a function of time is not available. Let’s ask GHCi the type of <code>simulate</code>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Vis</span>&#13;
Prelude Vis&gt; <span class="codestrong1">:t simulate</span>&#13;
simulate&#13;
  :: Real b =&gt;&#13;
     Options&#13;
     -&gt; Double&#13;
     -&gt; world&#13;
     -&gt; (world -&gt; VisObject b)&#13;
     -&gt; (Float -&gt; world -&gt; world)&#13;
     -&gt; IO ()</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_199"/>The <code>simulate</code> function asks for five pieces of information. The first one (type <code>Options</code>) is the same as in <code>display</code> and <code>animate</code>. The second piece of information (a <code>Double</code>) is the time step, in seconds per update, between successive frames of the animated display. Note the difference with the <code>gloss</code> library: <code>gloss</code> asks for a rate in updates per second, but <code>not-gloss</code> asks for a time step in seconds per update.</p>&#13;
<p class="indent">The third piece of information is the initial state of the situation to be displayed. The type variable <code>world</code> stands for a type that the user chooses to describe the state of the situation, very much like the type variable <code>model</code> used in the <code>gloss</code> function <code>simulate</code>.</p>&#13;
<p class="indent">The fourth piece of information (type <code>world -&gt; VisObject b</code>) is a display function that describes what picture to produce given a value of type <code>world</code>. This display function is very much like the display function of <code>gloss</code>.</p>&#13;
<p class="indent">Finally, the fifth piece of information needed by <code>simulate</code> is a function (type <code>Float -&gt; world -&gt; world</code>) that describes how the state of the system should advance in time. The <code>Float</code> in this type represents the total time elapsed since the beginning of the simulation. This is different from <code>gloss</code>, where the <code>Float</code> in the analogous term describes the time step since the previous frame.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list3">Listing 13-3</a> demonstrates how the <code>simulate</code> function uses the update function that we provide as the fifth piece of information. The purpose of the code is to determine, experimentally, what the <code>simulate</code> function does with the function of type <code>Float -&gt; world -&gt; world</code> that we provide. If you’re not used to working with higher-order functions, this can seem like a weird question. Normally, we write functions for our own use, or we use functions that others have written. But when someone else writes a higher-order function for us to use, and that higher-order function takes a user-defined function as input, we might well wonder how the higher-order function intends to use the user-defined function that we provide. (We might read the code or the documentation of the higher-order function, but here we’re going to figure it out experimentally.)</p>&#13;
<p class="indent">What’s weird is that we’re writing a function, <code>updateFunc</code> in <a href="ch13.xhtml#ch13list3">Listing 13-3</a>, but we are not going to use that function directly. We don’t decide what <code>Float</code> to send to <code>updateFunc</code>; another function, <code>simulate</code>, decides that.</p>&#13;
<pre id="ch13list3">{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
&#13;
type State = (Int,[Float])&#13;
&#13;
-- seconds / update&#13;
dt :: Double<span epub:type="pagebreak" id="page_200"/>&#13;
dt = 0.5&#13;
&#13;
displayFunc :: State -&gt; VisObject Double&#13;
displayFunc (n,ts) = Text2d (show n ++ " " ++ show (take 4 ts))&#13;
                     (100,100) Fixed9By15 orange&#13;
&#13;
updateFunc :: Float -&gt; State -&gt; State&#13;
updateFunc t (n,ts) = (n+1,t:ts)&#13;
&#13;
main :: IO ()&#13;
main = simulate defaultOpts dt (0,[]) displayFunc updateFunc</pre>&#13;
<p class="listing"><em>Listing 13-3: Use of the <code>simulate</code> function from the <code>not-gloss</code> library. The purpose of this code is to experimentally determine what <code>simulate</code> is doing with <code>updateFunc</code>.</em></p>&#13;
<p class="indent">We begin the code by importing the <code>Vis</code> module. For the type variable <code>world</code>, we choose a pair <code>(Int,[Float])</code> in which the <code>Int</code> is designed to hold the number of updates performed since the beginning of the simulation and the list of floats is intended to be a list of the time values passed to the update function <code>updateFunc</code>. We don’t choose those time values; <code>simulate</code> does.</p>&#13;
<p class="indent">We set a time step called dt to be half of a second. The <code>displayFunc</code> tells how to produce a picture from a <code>State</code>. It uses the <code>Text2d</code> data constructor of the <code>VisObject</code> type, which you will find if you check out the documentation on <code>not-gloss</code>’s <code>simulate</code> function.</p>&#13;
<p class="indent">The update function <code>updateFunc</code> keeps track of two things: the number of times it has been called and the <code>Float</code> values it has been called with. Each time <code>updateFunc</code> is called, it increases the call count by one and tacks the most recent <code>Float</code> onto the front of the list.</p>&#13;
<p class="indent">When we run this program, we can watch the number of updates increase at the rate of two per second and see that the times being passed in are increasing, confirming the assertion that the update function takes the time since simulation start as input.</p>&#13;
<h3 class="h3" id="ch13lev9">Summary</h3>&#13;
<p class="noindent">In this chapter, we explored several ways to produce two-dimensional and three-dimensional graphics and animation. We gave code for programs exhibiting each of the graphics functions that we will use later in the book to provide visual support to our thinking and writing about physics.</p>&#13;
<p class="indent">With this chapter, we have completed <a href="part01.xhtml">Part I</a> of the book—an introduction to functional programming ideas in general and to the Haskell programming language in particular. In <a href="part02.xhtml">Part II</a>, we explore Newtonian mechanics, in which our goal is to predict the motion of one or more objects experiencing forces. The central principle of Newtonian mechanics is Newton’s second law, which is the subject of the next chapter.</p>&#13;
<h3 class="h3" id="ch13lev10"><span epub:type="pagebreak" id="page_201"/>Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 13.1.</strong> Consult the <code>gloss</code> documentation on the <code>Picture</code> type and make an interesting picture using the <code>display</code> function. Combine lines, circles, text, colors, and whatever you like. Be creative.</p>&#13;
<p class="noindentts"><strong>Exercise 13.2.</strong> Use <code>animate</code> to make a simple animation. Be creative.</p>&#13;
<p class="noindentts"><strong>Exercise 13.3.</strong> Use <code>animate</code> to make the red disk oscillate left and right. Then, change your code a little bit to make the red disk orbit in a circle. Can you make the red disk move in an ellipse?</p>&#13;
<p class="noindentts"><strong>Exercise 13.4.</strong> Use <code>animate</code> to produce the same motion of the red disk that we achieved with <code>simulate</code> in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>.</p>&#13;
<p class="noindentts"><strong>Exercise 13.5.</strong> Use <code>simulate</code> to do something you think is interesting. Be creative.</p>&#13;
<p class="noindentts"><strong>Exercise 13.6.</strong> In the 2D projectile motion example of <a href="ch13.xhtml#ch13list2">Listing 13-2</a>, one meter in the real world is represented by one pixel in the animation. Modify the code so that one meter is represented by 10 pixels. Feel free to change the initial velocity components so the projectile doesn’t speed off the screen right away.</p>&#13;
<p class="noindentts"><strong>Exercise 13.7.</strong> Challenging exercise: Try to use <code>simulate</code> to make the red disk oscillate left and right without explicitly giving it an oscillating function like sin or cos. We will show how to do this in <a href="part02.xhtml">Part II</a> of the book.</p>&#13;
<p class="noindentts"><strong>Exercise 13.8.</strong> Rewrite the 3D axes code so that the x-axis points to the right, the y-axis points upward, and the z-axis points out of the page. This is my second-favorite coordinate system.</p>&#13;
<p class="noindentts"><strong>Exercise 13.9.</strong> Modify the rotating cube animation to make the rotation occur clockwise about the x-axis instead of counterclockwise.</p>&#13;
<p class="noindentts"><strong>Exercise 13.10.</strong> Write an experimental program, similar to <a href="ch13.xhtml#ch13list3">Listing 13-3</a>, using the <code>gloss</code> function <code>simulate</code> to understand how <code>gloss</code>’s <code>simulate</code> uses the update function. Use the same expressions for <code>updateFunc</code> and <code>State</code> that we used in <a href="ch13.xhtml#ch13list3">Listing 13-3</a>. You will need to change the values of <code>displayFunc</code> and <code>main</code>. Use a <code>rate</code> of 2 instead of a <code>dt</code> of 0.5. When you run this, you should see that the times passed in by <code>gloss</code>’s <code>simulate</code> are time steps that are all close to 0.5.<span epub:type="pagebreak" id="page_202"/></p>&#13;
</div></body></html>