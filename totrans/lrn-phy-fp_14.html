<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_187"/><span class="big">13</span><br/>CREATING 2D AND 3D ANIMATIONS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">A picture that changes over time can be a good way to visualize many situations. The Haskell Prelude itself does not have any support for animation, but some good library packages are available at <a href="https://hackage.haskell.org">https://hackage.haskell.org</a>. For two-dimensional pictures and animations, we’ll use the <span class="literal">gloss</span> package. For three-dimensional pictures and animations, we’ll use a package named <span class="literal">not-gloss</span>.</p>&#13;
<h3 class="h3" id="ch13lev1">2D Animation</h3>&#13;
<p class="noindent">The <span class="literal">gloss</span> package supplies the <span class="literal">Graphics.Gloss</span> module, which provides four main functions: display, animate, simulate, and play. The first is for still pictures, the second and third are for pictures that change with time, and the fourth is for pictures that change with time and user input. We are interested primarily in the first three functions. We’ll describe these functions in the next few sections.</p>&#13;
<h4 class="h4" id="ch13lev2"><span epub:type="pagebreak" id="page_188"/>Displaying a 2D Picture</h4>&#13;
<p class="noindent">The function <span class="literal">display</span> produces a static picture. Let’s ask GHCi for the type of <span class="literal">display</span>. Since <span class="literal">display</span> is not part of the Prelude, we must first load the module.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gloss</span>&#13;
Prelude Graphics.Gloss&gt; <span class="codestrong1">:t display</span>&#13;
display :: Display -&gt; Color -&gt; Picture -&gt; IO ()</pre>&#13;
<p class="indent">The types <span class="literal">Display</span>, <span class="literal">Color</span>, and <span class="literal">Picture</span> are defined by the <span class="literal">Graphics.Gloss</span> module, or perhaps by another module in the <span class="literal">gloss</span> package that is imported by <span class="literal">Graphics.Gloss</span>. The types <span class="literal">Display</span> and <span class="literal">Color</span> are for display mode and background color, respectively. The most interesting type is <span class="literal">Picture</span>, which represents the type of things that can be displayed. The <span class="literal">gloss</span> documentation on <span class="literal">Picture</span> describes the pictures we can make (lines, circles, polygons, and so on). You can find the documentation at <a href="https://hackage.haskell.org/package/gloss">https://hackage.haskell.org/package/gloss</a> by clicking on <span class="literal">Graphics.Gloss</span>.</p>&#13;
<p class="indent">GHCi is not so good at showing the pictures that <span class="literal">gloss</span> creates, so it’s better to make a stand-alone program. Let’s write a program to get us familiar with the default coordinate system the <span class="literal">Graphics.Gloss</span> module uses. We’ll draw a red line segment from the origin to the point (100,0) and a green line segment from the origin to the point (0,100). Because <span class="literal">gloss</span> measures distance in pixels, we’ll use 100 so that the lines we produce will be long enough to see on the screen.</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "Axes" (1000, 700) (10, 10)&#13;
&#13;
axes :: Picture&#13;
axes = Pictures [Color red   $ Line [(0,0),(100,  0)]&#13;
                ,Color green $ Line [(0,0),(  0,100)]&#13;
                ]&#13;
&#13;
main :: IO ()&#13;
main = display displayMode black axes</pre>&#13;
<p class="indent">As usual, we turn on warnings. Then we import the <span class="literal">Graphics.Gloss</span> module. We need to do this because the code that follows uses the types <span class="literal">Display</span> and <span class="literal">Picture</span>; the data constructors <span class="literal">InWindow</span>, <span class="literal">Pictures</span>, <span class="literal">Color</span>, and <span class="literal">Line</span>; the constants <span class="literal">red</span>, <span class="literal">green</span>, and <span class="literal">black</span>; and the function <span class="literal">display</span>. These names are all defined in the <span class="literal">Graphics.Gloss</span> module. Without the <span class="literal">import</span> statement, we would get “Variable not in scope” errors every time we used each of those names.</p>&#13;
<p class="indent">We define a constant <span class="literal">displayMode</span> to hold the value of type <span class="literal">Display</span> that the function <span class="literal">display</span> requires. We give the name “Axes” to the window that <span epub:type="pagebreak" id="page_189"/>will be opened by the <span class="literal">display</span> function. We ask for the window to be 1,000 pixels wide and 700 pixels high, and we ask for it to be placed 10 pixels up and 10 pixels over from whatever the window system thinks is the origin.</p>&#13;
<p class="indent">We define a constant called <span class="literal">axes</span> to hold the <span class="literal">Picture</span> we want to make. We produce the picture using the data constructor <span class="literal">Pictures</span>, which gives a way to combine a list of pictures into a single picture. We can ask GHCi for the types of some of the things that didn’t get explicit types in our code.</p>&#13;
<pre>Prelude Graphics.Gloss&gt; <span class="codestrong1">:t Line [(0,0),(100,0)]</span>&#13;
Line [(0,0),(100,0)] :: Picture&#13;
Prelude Graphics.Gloss&gt; <span class="codestrong1">:t Color green $ Line [(0,0),(0,100)]</span>&#13;
Color green $ Line [(0,0),(0,100)] :: Picture</pre>&#13;
<p class="indent">The <span class="literal">main</span> function here uses the function <span class="literal">display</span> to make the picture. We pass <span class="literal">display</span> our <span class="literal">displayMode</span>, the background color <span class="literal">black</span>, and our picture <span class="literal">axes</span>.</p>&#13;
<p class="indent">When we compile and run the program above using one of the three methods described in <a href="ch12.xhtml">Chapter 12</a>, we should see a red horizontal line and a green vertical line. The default <span class="literal">gloss</span> orientation has the x-axis going toward the right and the y-axis going upward. Depending on your operating system, you might need to hit CTRL-C twice to close the graphics window.</p>&#13;
<p class="indent">The <span class="literal">gloss</span> package does not have a primitive disk, or filled circle, picture. As a second example of the <span class="literal">display</span> function, let’s make a picture of a blue circle and a red disk, side by side.</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "My Window" (1000, 700) (10, 10)&#13;
&#13;
blueCircle :: Picture&#13;
blueCircle = Color blue (Circle 100)&#13;
&#13;
disk :: Float -&gt; Picture&#13;
disk radius = ThickCircle (radius / 2) radius&#13;
&#13;
redDisk :: Picture&#13;
redDisk = Color red (disk 100)&#13;
&#13;
wholePicture :: Picture&#13;
wholePicture = Pictures [Translate (-120) 0 blueCircle&#13;
                        ,Translate   120  0 redDisk&#13;
                        ]&#13;
&#13;
main :: IO ()&#13;
main = display displayMode black wholePicture</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_190"/>Here we used the same warnings, import, and <span class="literal">displayMode</span> lines as before. The constant <span class="literal">blueCircle</span> is a blue circle with a radius of 100 pixels.</p>&#13;
<p class="indent">Since <span class="literal">gloss</span> does not provide a function to make a disk, we’ll write our own. Our <span class="literal">disk</span> function uses <span class="literal">gloss</span>’s built-in <span class="literal">ThickCircle</span> function to make a disk. <span class="literal">ThickCircle</span> takes a radius and a thickness as inputs. Here we choose the radius of the thick circle to be half of the desired radius of the disk, and we choose the thickness to be the full desired radius of the disk. This circle is so thick that there is no hole left in the middle, making a disk.</p>&#13;
<p class="indent">The constant <span class="literal">redDisk</span> is a red disk with a radius of 100 pixels. The constant <span class="literal">wholePicture</span> uses the <span class="literal">Translate</span> data constructor of the <span class="literal">Picture</span> type to shift the circle to the left and the disk to the right. The <span class="literal">main</span> function is very similar to that of the last program, except now we are displaying <span class="literal">wholePicture</span>.</p>&#13;
<p class="indent">When we run the program, we should see a blue circle to the left of a red disk of the same size.</p>&#13;
<h4 class="h4" id="ch13lev3">Making a 2D Animation</h4>&#13;
<p class="noindent">Given a picture as a function of time, the function <span class="literal">animate</span> produces an animation. Let’s ask GHCi the type of <span class="literal">animate</span>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gloss</span>&#13;
Prelude Graphics.Gloss&gt; <span class="codestrong1">:t animate</span>&#13;
animate :: Display -&gt; Color -&gt; (Float -&gt; Picture) -&gt; IO ()</pre>&#13;
<p class="indent">The difference in type compared to <span class="literal">display</span> is that <span class="literal">Picture</span> in <span class="literal">display</span> has been replaced by <span class="literal">Float -&gt; Picture</span> in <span class="literal">animate</span>. The <span class="literal">animate</span> function uses a <span class="literal">Float</span> to describe time, so an expression of type <span class="literal">Float -&gt; Picture</span> is a function from time to a picture, or a picture as a function of time.</p>&#13;
<p class="indent">Here is an example of how to use <span class="literal">animate</span>:</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "My Window" (1000, 700) (10, 10)&#13;
&#13;
disk :: Float -&gt; Picture&#13;
disk radius = ThickCircle (radius / 2) radius&#13;
&#13;
redDisk :: Picture&#13;
redDisk = Color red (disk 25)&#13;
&#13;
projectileMotion :: Float -&gt; Picture&#13;
projectileMotion t = Translate (xDisk t) (yDisk t) redDisk&#13;
&#13;
xDisk :: Float -&gt; Float&#13;
xDisk t = 40 * t&#13;
&#13;
<span epub:type="pagebreak" id="page_191"/>yDisk :: Float -&gt; Float&#13;
yDisk t = 80 * t - 4.9 * t**2&#13;
&#13;
main :: IO ()&#13;
main = animate displayMode black projectileMotion</pre>&#13;
<p class="indent">The function <span class="literal">projectileMotion</span> takes a <span class="literal">Float</span> (the time) as input and produces a <span class="literal">Picture</span> by translating the red disk to the right by <span class="literal">xDisk t</span> and upward by <span class="literal">yDisk t</span>. The functions <span class="literal">xDisk</span> and <span class="literal">yDisk</span> are given explicitly as functions of time.</p>&#13;
<p class="indent">When we compile and run this code, we’ll see a red disk experiencing projectile motion. One meter is represented by one pixel, and one second of time in the real world is one second of time in the animation. The projectile starts with an initial x-component of velocity of 40 m/s and an initial y-component of velocity of 80 m/s.</p>&#13;
<h4 class="h4" id="ch13lev4">Making a 2D Simulation</h4>&#13;
<p class="noindent">The <span class="literal">gloss</span> package’s <span class="literal">simulate</span> function allows the user to make an animation when an explicit function describing a picture as a function of time is not available. Let’s ask GHCi the type of <span class="literal">simulate</span>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Graphics.Gloss</span>&#13;
Prelude Graphics.Gloss&gt; <span class="codestrong1">:t simulate</span>&#13;
simulate&#13;
  :: Display&#13;
     -&gt; Color&#13;
     -&gt; Int&#13;
     -&gt; model&#13;
     -&gt; (model -&gt; Picture)&#13;
     -&gt; (Graphics.Gloss.Data.ViewPort.ViewPort&#13;
         -&gt; Float -&gt; model -&gt; model)&#13;
     -&gt; IO ()</pre>&#13;
<p class="indent">The <span class="literal">simulate</span> function asks for six pieces of information. The first two, display mode (type <span class="literal">Display</span>) and background color (type <span class="literal">Color</span>), are the same as in <span class="literal">display</span> and <span class="literal">animate</span>. The third piece of information (an <span class="literal">Int</span>) is the rate, in updates per second, at which the simulation should run. The fourth piece of information has the type variable <span class="literal">model</span> instead of a concrete type. We can tell that <span class="literal">model</span> is a type variable because it starts with a lowercase letter; it cannot be a constant or a function because it sits in a type signature in the place where a type needs to sit. We, the users of the <span class="literal">simulate</span> function, get to decide what type to use for <span class="literal">model</span>. We need a type that can hold the <em>state</em> of the system we are simulating, which is the collection of information necessary to (1) produce a picture at any given moment of time and (2) determine what will happen next as time evolves. This notion of state will play a large role in the physics we describe in <a href="part02.xhtml">Parts II</a> and <a href="part03.xhtml">III</a> of the book. The value of type <span class="literal">model</span> that <span class="literal">simulate</span> needs is the initial state of the situation to be displayed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_192"/>The fifth piece of information (type <span class="literal">model -&gt; Picture</span>) is a function that describes what picture to produce given a value of type <span class="literal">model</span>. The sixth piece of information <span class="literal">simulate</span> needs is a function (type <span class="literal">Viewport -&gt; Float -&gt;</span> <span class="literal">model -&gt; model</span>) that describes how the state of the system should advance in time. The <span class="literal">Float</span> represents a time step here, and we will not use the <span class="literal">Viewport</span>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list1">Listing 13-1</a> gives a complete program that shows how to use the <span class="literal">simulate</span> function.</p>&#13;
<pre id="ch13list1">{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "My Window" (1000, 700) (10, 10)&#13;
&#13;
-- updates per second of real time&#13;
rate :: Int&#13;
rate = 2&#13;
&#13;
disk :: Float -&gt; Picture&#13;
disk radius = ThickCircle (radius / 2) radius&#13;
&#13;
redDisk :: Picture&#13;
redDisk = Color red (disk 25)&#13;
&#13;
type State = (Float,Float)&#13;
&#13;
initialState :: State&#13;
initialState = (0,0)&#13;
&#13;
displayFunc :: State -&gt; Picture&#13;
displayFunc (x,y) = Translate x y redDisk&#13;
&#13;
updateFunc :: Float -&gt; State -&gt; State&#13;
updateFunc dt (x,y) = (x + 10 * dt, y - 5 * dt)&#13;
&#13;
main :: IO ()&#13;
main = simulate displayMode black rate initialState displayFunc&#13;
       (\_ -&gt; updateFunc)</pre>&#13;
<p class="listing"><em>Listing 13-1: Sample use of the <span class="codeitalic1">simulate</span> function from the <span class="codeitalic1">gloss</span> package</em></p>&#13;
<p class="indent">The display mode and background color are the same as before. We define a constant <span class="literal">rate</span> to hold the simulation rate. For the type variable <span class="literal">model</span>, we’ve chosen <span class="literal">(Float,Float)</span> and given it the type synonym <span class="literal">State</span>. This state is meant to represent the (x, y) coordinates of the current location of the red disk. The initial value of the state is defined in <span class="literal">initialState</span>.</p>&#13;
<p class="indent">The heart of the simulation is contained in the two functions <span class="literal">displayFunc</span> and <span class="literal">updateFunc</span>. The first tells how to make a picture from a state. In this <span epub:type="pagebreak" id="page_193"/>case, we use the (x, y) coordinates in the state to translate the red disk over <em>x</em> and up <em>y</em>. The display function only cares about the current state of affairs (the current values of <em>x</em> and <em>y</em>). It has nothing to do with how the picture changes with time.</p>&#13;
<p class="indent">The update function <span class="literal">updateFunc</span> explains how the state changes with time. We need to give a rule for what the new state will be in terms of the old state and a time step <span class="literal">dt</span>. In this case, we add 10 pixels/second to the x-value and subtract 5 pixels/second from the y-value.</p>&#13;
<p class="indent">When we run the program, we should see the red disk move to the right and downward as the simulation evolves. The simulation will be jerky because we chose a rate of 2 updates/second, so you see each update as a discrete motion. Try increasing the rate to get a smoother animation. High definition TV uses 24–60 frames per second, so you shouldn’t need to go higher than that. If the lights in your building dim, you’ve picked a frame rate that’s too high.</p>&#13;
<p class="indent">For one more example of the <span class="literal">simulate</span> function, let’s see how the projectile motion we did before with <span class="literal">animate</span> would look when done with <span class="literal">simulate</span>. The difference between constant velocity motion and projectile motion is that the velocity changes in projectile motion. To allow the velocity to change, we need to expand the information in the state to include velocity as well as the position of the red disk. For this purpose, we define the type synonyms <span class="literal">Position</span>, <span class="literal">Velocity</span>, and <span class="literal">State</span> in the code in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>.</p>&#13;
<p class="indent">Our <span class="literal">initialState</span> now needs to contain both the initial position <span class="literal">(0,0)</span> and an initial velocity <span class="literal">(40,80)</span>. The initial x-component of velocity is 40 m/s, and the initial y-component is 80 m/s.</p>&#13;
<p class="indent">Our display function doesn’t need to change in meaning from the previous simulation. The display of the red disk still depends only on the position of the disk and not on the current velocity. However, the <span class="literal">displayFunc</span> function needs a little bit of syntactic revision since the type of the state has changed. The syntactic revision entails replacing the argument <span class="literal">(x,y)</span> with <span class="literal">((x,y),_)</span> to reflect the new type of state. If we left the function entirely unchanged, the compiler would think that the argument <span class="literal">(x,y)</span> meant x for position and y for velocity. We would get a type error complaining that the expected type of x is <span class="literal">Float</span> but its actual type is <span class="literal">Position</span>. The “actual type” of <span class="literal">Position</span> comes from the type signature of <span class="literal">displayFunc</span>, while the “expected type” of <span class="literal">Float</span> comes from the way x is used, as an argument to <span class="literal">Translate</span>, in the definition of <span class="literal">displayFunc</span>.</p>&#13;
<p class="indent">Let’s implement these changes; the result is in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>.</p>&#13;
<pre id="ch13list2">{-# OPTIONS -Wall #-}&#13;
&#13;
import Graphics.Gloss&#13;
&#13;
displayMode :: Display&#13;
displayMode = InWindow "My Window" (1000, 700) (10, 10)&#13;
&#13;
-- updates per second of real time&#13;
rate :: Int<span epub:type="pagebreak" id="page_194"/>&#13;
rate = 24&#13;
&#13;
disk :: Float -&gt; Picture&#13;
disk radius = ThickCircle (radius / 2) radius&#13;
&#13;
redDisk :: Picture&#13;
redDisk = Color red (disk 25)&#13;
&#13;
type Position = (Float,Float)&#13;
type Velocity = (Float,Float)&#13;
type State = (Position,Velocity)&#13;
&#13;
initialState :: State&#13;
initialState = ((0,0),(40,80))&#13;
&#13;
displayFunc :: State -&gt; Picture&#13;
displayFunc ((x,y),_) = Translate x y redDisk&#13;
&#13;
updateFunc :: Float -&gt; State -&gt; State&#13;
updateFunc dt ((x,y),(vx,vy))&#13;
   = (( x + vx * dt, y +  vy * dt)&#13;
     ,(vx         ,vy - 9.8 * dt))&#13;
&#13;
main :: IO ()&#13;
main = simulate displayMode black rate initialState displayFunc&#13;
       (\_ -&gt; updateFunc)</pre>&#13;
<p class="listing"><em>Listing 13-2: Sample use of the <span class="literal">simulate</span> function to produce projectile motion</em></p>&#13;
<p class="indent">The update function is where all of the action happens. The components x and y of position get updated based on the current velocity. The velocity components vx and vy get updated based on the components of acceleration. The x-component of acceleration is 0, so the x-component of velocity stays the same. The y-component of acceleration is – 9.8 m/s<sup>2</sup>, so we update the y-component of velocity using that, assuming that 1 meter represents 1 pixel in our simulation.</p>&#13;
<p class="indent">When we run this program, the results should be the same as the projectile program we wrote with <span class="literal">animate</span>.</p>&#13;
<p class="indent">Notice the difference in the information required to produce the projectile motion animation using <span class="literal">animate</span> compared to <span class="literal">simulate</span>. To use <span class="literal">animate</span>, we need to have explicit expressions for the position as a function of time. To use <span class="literal">simulate</span>, we provide equivalent information, but it seems like we’re providing less. The state update procedure is a powerful tool in numerically solving equations of motion. We’ll exploit this tool much more in <a href="part02.xhtml">Parts II</a> and <a href="part03.xhtml">III</a> of the book.</p>&#13;
<h3 class="h3" id="ch13lev5"><span epub:type="pagebreak" id="page_195"/>3D Animation</h3>&#13;
<p class="noindent">The <span class="literal">not-gloss</span> package provides four main functions whose names are identical to those in <span class="literal">gloss</span>: <span class="literal">display</span>, <span class="literal">animate</span>, <span class="literal">simulate</span>, and <span class="literal">play</span>. As in <span class="literal">gloss</span>, the first is for still pictures, the second and third are for pictures that change with time, and the fourth is for pictures that change with time and user input. We’re interested primarily in the first three functions. The types of these functions are different from those of the corresponding <span class="literal">gloss</span> functions, in part because the <span class="literal">not-gloss</span> package has a different author from the <span class="literal">gloss</span> package. There are similarities between the two packages, but there are also differences that we will point out.</p>&#13;
<h4 class="h4" id="ch13lev6">Displaying a 3D Picture</h4>&#13;
<p class="noindent">Let’s check the type of <span class="literal">display</span>. Just as the <span class="literal">gloss</span> package has a module named <span class="literal">Graphics.Gloss</span> that must be imported before its functions can be used, the <span class="literal">not-gloss</span> package has a module named <span class="literal">Vis</span> that we must import.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Vis</span>&#13;
Prelude Vis&gt; <span class="codestrong1">:t display</span>&#13;
display :: Real b =&gt; Options -&gt; VisObject b -&gt; IO ()</pre>&#13;
<p class="indent">If we ask about the type class <span class="literal">Real</span>, we learn that <span class="literal">Real</span> is for numeric types that can be converted to rational numbers:</p>&#13;
<pre>Prelude Vis&gt; <span class="codestrong1">:i Real</span>&#13;
class (Num a, Ord a) =&gt; Real a where&#13;
  toRational :: a -&gt; Rational&#13;
  {-# MINIMAL toRational #-}&#13;
   -- Defined in 'GHC.Real'&#13;
instance Real Word -- Defined in 'GHC.Real'&#13;
instance Real Integer -- Defined in 'GHC.Real'&#13;
instance Real Int -- Defined in 'GHC.Real'&#13;
instance Real Float -- Defined in 'GHC.Float'&#13;
instance Real Double -- Defined in 'GHC.Float'</pre>&#13;
<p class="indent">Our favorite instance of the <span class="literal">Real</span> type class is <span class="literal">R</span> (or <span class="literal">Double</span>). This will be our default choice unless there is a reason to choose something else. If the type variable <span class="literal">b</span> in the type of <span class="literal">display</span> is <span class="literal">R</span>, the type of <span class="literal">display</span> is the following:</p>&#13;
<pre>display :: Options -&gt; VisObject R -&gt; IO ()</pre>&#13;
<p class="indent">The display function is asking us to provide two things: a thing with type <span class="literal">Options</span>, and the object to be displayed (type <span class="literal">VisObject R</span>). The return type <span class="literal">IO ()</span> means that the computer will <em>do</em> something (in this case display the object).</p>&#13;
<p class="indent">What kinds of things are there that have type <span class="literal">VisObject R</span>? The <span class="literal">not-gloss</span> package provides a long list of possibilities, including spheres, cubes, lines, text, and more. You can find documentation at the <a href="https://hackage.haskell.org">https://hackage.haskell.org</a> site by searching for <span class="literal">not-gloss</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_196"/>Here is an example that produces a blue cube:</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
&#13;
type R = Double&#13;
&#13;
blueCube :: VisObject R&#13;
blueCube = Cube 1 Solid blue&#13;
&#13;
main :: IO ()&#13;
main = display defaultOpts blueCube</pre>&#13;
<p class="indent">The constant <span class="literal">defaultOpts</span> is provided by the <span class="literal">Vis</span> module as a set of default options. You can compile this code into a stand-alone program as before. When you run the program, a display window containing a blue cube will open. After the display window opens, press <span class="codestrong1">e</span> to zoom in and <span class="codestrong1">q</span> to zoom out. You can also use the mouse to rotate the cube. These are standard features of <span class="literal">not-gloss</span> that we don’t need to program.</p>&#13;
<p class="indent">The next program will get us familiar with the default coordinate system the <span class="literal">Vis</span> module uses. We’ll draw a red line segment from the origin to the point (1, 0, 0), a green line segment from the origin to the point (0, 1, 0), and a blue line segment from the origin to the point (0, 0, 1).</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
import Linear&#13;
&#13;
type R = Double&#13;
&#13;
axes :: VisObject R&#13;
axes = VisObjects [Line Nothing [V3 0 0 0, V3 1 0 0] red&#13;
                  ,Line Nothing [V3 0 0 0, V3 0 1 0] green&#13;
                  ,Line Nothing [V3 0 0 0, V3 0 0 1] blue&#13;
                  ]&#13;
&#13;
main :: IO ()&#13;
main = display defaultOpts axes</pre>&#13;
<p class="indent">Here we import the <span class="literal">Linear</span> module to have access to the <span class="literal">V3</span> constructor. The <span class="literal">Linear</span> module defines several kinds of vector; <span class="literal">V3</span> is the one used by the <span class="literal">Vis</span> module. The <span class="literal">Nothing</span> means to use the default line width (try (Just 5) in place of <span class="literal">Nothing</span> to get a thicker line width).</p>&#13;
<p class="indent">When we compile and run the program just shown, we see axes for a three-dimensional coordinate system. We see that <span class="literal">not-gloss</span>’s default orientation has the x-axis going toward the right and toward the viewer, the y-axis going toward the left and toward the viewer, and the z-axis going downward.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_197"/>Personally, I think having the positive z-axis point downward is disturbing and abhorrent. I like to think of myself as a flexible person, but this crosses a line. (Greg Horn, the author of <span class="literal">not-gloss</span>, tells me that the z-down convention is standard in much of the aerospace industry.) Fortunately, <span class="literal">not-gloss</span> has tools that allow us to rotate things the way we want. I like to have the x-axis coming mostly out of the page, the y-axis pointing toward the right, and the z-axis pointing upward. Here is a program that will do just that:</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
import Linear&#13;
import SpatialMath&#13;
&#13;
type R = Double&#13;
&#13;
axes :: VisObject R&#13;
axes = VisObjects [Line Nothing [V3 0 0 0, V3 1 0 0] red&#13;
                  ,Line Nothing [V3 0 0 0, V3 0 1 0] green&#13;
                  ,Line Nothing [V3 0 0 0, V3 0 0 1] blue&#13;
                  ]&#13;
&#13;
orient :: VisObject R -&gt; VisObject R&#13;
orient pict = RotEulerDeg (Euler 270 180 0) $ pict&#13;
&#13;
main :: IO ()&#13;
main = display defaultOpts (orient axes)</pre>&#13;
<p class="indent">We import <span class="literal">Vis</span> and <span class="literal">Linear</span> as before, but here we also import <span class="literal">SpatialMath</span> so we can use <span class="literal">Euler</span> to perform three-dimensional rotations using Euler angles. The <span class="literal">axes</span> picture has not changed. We define a function <span class="literal">orient</span> that takes a picture as input and gives back a reoriented picture as output. To do this, we perform a rotation specified by Euler angles using the <span class="literal">RotEulerDeg</span> data constructor of the <span class="literal">VisObject</span> type. In this case, the Euler angles mean we rotate first by 0<sup>∘</sup> about the x-axis, then by 180<sup>∘</sup> about the y-axis, and then by 270<sup>∘</sup> about the z-axis. Equivalently, we can view this as a rotation first about the z-axis by 270<sup>∘</sup>, then about the <em>rotated</em> y-axis by 180<sup>∘</sup>, and then about the rotated x-axis by 0<sup>∘</sup>.</p>&#13;
<p class="indent">Finally, we pass <span class="literal">orient axes</span> to <span class="literal">display</span> as the picture to be displayed. If you like this way of orienting the coordinate system, you could pass any picture to the function <span class="literal">orient</span> before displaying it as a way of using this coordinate system. You could even define your own display function that does the reorientation for you.</p>&#13;
<pre>myDisplay :: VisObject R -&gt; IO ()&#13;
myDisplay pict = display defaultOpts (orient pict)</pre>&#13;
<h4 class="h4" id="ch13lev7"><span epub:type="pagebreak" id="page_198"/>Making a 3D Animation</h4>&#13;
<p class="noindent">Let’s look at the type of <span class="literal">animate</span>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Vis</span>&#13;
Prelude Vis&gt; <span class="codestrong1">:t animate</span>&#13;
animate :: Real b =&gt; Options -&gt; (Float -&gt; VisObject b) -&gt; IO ()</pre>&#13;
<p class="indent">The type of <span class="literal">animate</span> is the same as the type of <span class="literal">display</span>, except that the <span class="literal">VisObject b</span> of <span class="literal">display</span> is replaced by <span class="literal">Float -&gt; VisObject b</span> in <span class="literal">animate</span>. Instead of asking us to provide a picture, <span class="literal">animate</span> is asking us to provide a function from time to a picture. The <span class="literal">animate</span> function demands that we use <span class="literal">Float</span> for the real number representing time.</p>&#13;
<p class="indent">The following animation of a rotating blue cube has the cube rotating counterclockwise about the x-axis in my favorite coordinate system (x-axis out of the screen, y-axis to the right, and z-axis up the screen):</p>&#13;
<pre>{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
import SpatialMath&#13;
&#13;
rotatingCube :: Float -&gt; VisObject Float&#13;
rotatingCube t = RotEulerRad (Euler 0 0 t) (Cube 1 Solid blue)&#13;
&#13;
orient :: VisObject Float -&gt; VisObject Float&#13;
orient pict = RotEulerDeg (Euler 270 180 0) $ pict&#13;
&#13;
main :: IO ()&#13;
main = animate defaultOpts (orient . rotatingCube)</pre>&#13;
<p class="indent">Note the use of function composition between <span class="literal">rotatingCube</span> and <span class="literal">orient</span>. The function <span class="literal">rotatingCube</span> takes a number as input and produces a picture as output. The function <span class="literal">orient</span> takes a picture as input and produces a (reoriented) picture as output. The composition <span class="literal">orient . rotatingCube</span> takes a number as input and produces a picture as output, which is just the type of function that <span class="literal">animate</span> wants.</p>&#13;
<h4 class="h4" id="ch13lev8">Making a 3D Simulation</h4>&#13;
<p class="noindent">The <span class="literal">not-gloss</span> function <span class="literal">simulate</span> allows the user to make an animation when an explicit function describing a picture as a function of time is not available. Let’s ask GHCi the type of <span class="literal">simulate</span>.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:m Vis</span>&#13;
Prelude Vis&gt; <span class="codestrong1">:t simulate</span>&#13;
simulate&#13;
  :: Real b =&gt;&#13;
     Options&#13;
     -&gt; Double&#13;
     -&gt; world&#13;
     -&gt; (world -&gt; VisObject b)&#13;
     -&gt; (Float -&gt; world -&gt; world)&#13;
     -&gt; IO ()</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_199"/>The <span class="literal">simulate</span> function asks for five pieces of information. The first one (type <span class="literal">Options</span>) is the same as in <span class="literal">display</span> and <span class="literal">animate</span>. The second piece of information (a <span class="literal">Double</span>) is the time step, in seconds per update, between successive frames of the animated display. Note the difference with the <span class="literal">gloss</span> library: <span class="literal">gloss</span> asks for a rate in updates per second, but <span class="literal">not-gloss</span> asks for a time step in seconds per update.</p>&#13;
<p class="indent">The third piece of information is the initial state of the situation to be displayed. The type variable <span class="literal">world</span> stands for a type that the user chooses to describe the state of the situation, very much like the type variable <span class="literal">model</span> used in the <span class="literal">gloss</span> function <span class="literal">simulate</span>.</p>&#13;
<p class="indent">The fourth piece of information (type <span class="literal">world -&gt; VisObject b</span>) is a display function that describes what picture to produce given a value of type <span class="literal">world</span>. This display function is very much like the display function of <span class="literal">gloss</span>.</p>&#13;
<p class="indent">Finally, the fifth piece of information needed by <span class="literal">simulate</span> is a function (type <span class="literal">Float -&gt; world -&gt; world</span>) that describes how the state of the system should advance in time. The <span class="literal">Float</span> in this type represents the total time elapsed since the beginning of the simulation. This is different from <span class="literal">gloss</span>, where the <span class="literal">Float</span> in the analogous term describes the time step since the previous frame.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list3">Listing 13-3</a> demonstrates how the <span class="literal">simulate</span> function uses the update function that we provide as the fifth piece of information. The purpose of the code is to determine, experimentally, what the <span class="literal">simulate</span> function does with the function of type <span class="literal">Float -&gt; world -&gt; world</span> that we provide. If you’re not used to working with higher-order functions, this can seem like a weird question. Normally, we write functions for our own use, or we use functions that others have written. But when someone else writes a higher-order function for us to use, and that higher-order function takes a user-defined function as input, we might well wonder how the higher-order function intends to use the user-defined function that we provide. (We might read the code or the documentation of the higher-order function, but here we’re going to figure it out experimentally.)</p>&#13;
<p class="indent">What’s weird is that we’re writing a function, <span class="literal">updateFunc</span> in <a href="ch13.xhtml#ch13list3">Listing 13-3</a>, but we are not going to use that function directly. We don’t decide what <span class="literal">Float</span> to send to <span class="literal">updateFunc</span>; another function, <span class="literal">simulate</span>, decides that.</p>&#13;
<pre id="ch13list3">{-# OPTIONS -Wall #-}&#13;
&#13;
import Vis&#13;
&#13;
type State = (Int,[Float])&#13;
&#13;
-- seconds / update&#13;
dt :: Double<span epub:type="pagebreak" id="page_200"/>&#13;
dt = 0.5&#13;
&#13;
displayFunc :: State -&gt; VisObject Double&#13;
displayFunc (n,ts) = Text2d (show n ++ " " ++ show (take 4 ts))&#13;
                     (100,100) Fixed9By15 orange&#13;
&#13;
updateFunc :: Float -&gt; State -&gt; State&#13;
updateFunc t (n,ts) = (n+1,t:ts)&#13;
&#13;
main :: IO ()&#13;
main = simulate defaultOpts dt (0,[]) displayFunc updateFunc</pre>&#13;
<p class="listing"><em>Listing 13-3: Use of the <span class="literal">simulate</span> function from the <span class="literal">not-gloss</span> library. The purpose of this code is to experimentally determine what <span class="literal">simulate</span> is doing with <span class="literal">updateFunc</span>.</em></p>&#13;
<p class="indent">We begin the code by importing the <span class="literal">Vis</span> module. For the type variable <span class="literal">world</span>, we choose a pair <span class="literal">(Int,[Float])</span> in which the <span class="literal">Int</span> is designed to hold the number of updates performed since the beginning of the simulation and the list of floats is intended to be a list of the time values passed to the update function <span class="literal">updateFunc</span>. We don’t choose those time values; <span class="literal">simulate</span> does.</p>&#13;
<p class="indent">We set a time step called dt to be half of a second. The <span class="literal">displayFunc</span> tells how to produce a picture from a <span class="literal">State</span>. It uses the <span class="literal">Text2d</span> data constructor of the <span class="literal">VisObject</span> type, which you will find if you check out the documentation on <span class="literal">not-gloss</span>’s <span class="literal">simulate</span> function.</p>&#13;
<p class="indent">The update function <span class="literal">updateFunc</span> keeps track of two things: the number of times it has been called and the <span class="literal">Float</span> values it has been called with. Each time <span class="literal">updateFunc</span> is called, it increases the call count by one and tacks the most recent <span class="literal">Float</span> onto the front of the list.</p>&#13;
<p class="indent">When we run this program, we can watch the number of updates increase at the rate of two per second and see that the times being passed in are increasing, confirming the assertion that the update function takes the time since simulation start as input.</p>&#13;
<h3 class="h3" id="ch13lev9">Summary</h3>&#13;
<p class="noindent">In this chapter, we explored several ways to produce two-dimensional and three-dimensional graphics and animation. We gave code for programs exhibiting each of the graphics functions that we will use later in the book to provide visual support to our thinking and writing about physics.</p>&#13;
<p class="indent">With this chapter, we have completed <a href="part01.xhtml">Part I</a> of the book—an introduction to functional programming ideas in general and to the Haskell programming language in particular. In <a href="part02.xhtml">Part II</a>, we explore Newtonian mechanics, in which our goal is to predict the motion of one or more objects experiencing forces. The central principle of Newtonian mechanics is Newton’s second law, which is the subject of the next chapter.</p>&#13;
<h3 class="h3" id="ch13lev10"><span epub:type="pagebreak" id="page_201"/>Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 13.1.</strong> Consult the <span class="literal">gloss</span> documentation on the <span class="literal">Picture</span> type and make an interesting picture using the <span class="literal">display</span> function. Combine lines, circles, text, colors, and whatever you like. Be creative.</p>&#13;
<p class="noindentts"><strong>Exercise 13.2.</strong> Use <span class="literal">animate</span> to make a simple animation. Be creative.</p>&#13;
<p class="noindentts"><strong>Exercise 13.3.</strong> Use <span class="literal">animate</span> to make the red disk oscillate left and right. Then, change your code a little bit to make the red disk orbit in a circle. Can you make the red disk move in an ellipse?</p>&#13;
<p class="noindentts"><strong>Exercise 13.4.</strong> Use <span class="literal">animate</span> to produce the same motion of the red disk that we achieved with <span class="literal">simulate</span> in <a href="ch13.xhtml#ch13list1">Listing 13-1</a>.</p>&#13;
<p class="noindentts"><strong>Exercise 13.5.</strong> Use <span class="literal">simulate</span> to do something you think is interesting. Be creative.</p>&#13;
<p class="noindentts"><strong>Exercise 13.6.</strong> In the 2D projectile motion example of <a href="ch13.xhtml#ch13list2">Listing 13-2</a>, one meter in the real world is represented by one pixel in the animation. Modify the code so that one meter is represented by 10 pixels. Feel free to change the initial velocity components so the projectile doesn’t speed off the screen right away.</p>&#13;
<p class="noindentts"><strong>Exercise 13.7.</strong> Challenging exercise: Try to use <span class="literal">simulate</span> to make the red disk oscillate left and right without explicitly giving it an oscillating function like sin or cos. We will show how to do this in <a href="part02.xhtml">Part II</a> of the book.</p>&#13;
<p class="noindentts"><strong>Exercise 13.8.</strong> Rewrite the 3D axes code so that the x-axis points to the right, the y-axis points upward, and the z-axis points out of the page. This is my second-favorite coordinate system.</p>&#13;
<p class="noindentts"><strong>Exercise 13.9.</strong> Modify the rotating cube animation to make the rotation occur clockwise about the x-axis instead of counterclockwise.</p>&#13;
<p class="noindentts"><strong>Exercise 13.10.</strong> Write an experimental program, similar to <a href="ch13.xhtml#ch13list3">Listing 13-3</a>, using the <span class="literal">gloss</span> function <span class="literal">simulate</span> to understand how <span class="literal">gloss</span>’s <span class="literal">simulate</span> uses the update function. Use the same expressions for <span class="literal">updateFunc</span> and <span class="literal">State</span> that we used in <a href="ch13.xhtml#ch13list3">Listing 13-3</a>. You will need to change the values of <span class="literal">displayFunc</span> and <span class="literal">main</span>. Use a <span class="literal">rate</span> of 2 instead of a <span class="literal">dt</span> of 0.5. When you run this, you should see that the times passed in by <span class="literal">gloss</span>’s <span class="literal">simulate</span> are time steps that are all close to 0.5.<span epub:type="pagebreak" id="page_202"/></p>&#13;
</div></body></html>