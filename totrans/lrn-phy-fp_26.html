<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch23"><span epub:type="pagebreak" id="page_449"/><span class="big">23</span><br/>CURVES, SURFACES, AND VOLUMES</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Electrodynamics is a geometric subject. Curves, surfaces, and volumes play a dual role in electromagnetic theory. They serve as the places where electric charge and current can reside, and they play an essential role in the formulation of the Maxwell equations, the modern expression of how electric and magnetic fields are created and how they evolve in time.</p>&#13;
<p class="indent">Before we can explore the Maxwell equations, we’ll need data types for curves, surfaces, and volumes—we’ll build them in this chapter. A curve can be specified by giving a function from a single real parameter to a position in space. A surface can be specified as a function from a pair of real numbers to a position in space. A volume can be specified as a function from a triple of numbers to a position in space. These mathematical parameterizations lead naturally to data type definitions. We’ll package the parameterizations with appropriate boundaries to form the types <span class="literal">Curve</span>, <span class="literal">Surface</span>, and <span class="literal">Volume</span>.</p>&#13;
<p class="indent">Let’s start with some introductory code.</p>&#13;
<h3 class="h3" id="ch23lev1"><span epub:type="pagebreak" id="page_450"/>Introductory Code</h3>&#13;
<p class="noindent"><a href="ch23.xhtml#ch23list1">Listing 23-1</a> shows the introductory code for the <span class="literal">Geometry</span> module we’ll develop in this chapter.</p>&#13;
<pre id="ch23list1">{-# OPTIONS -Wall #-}&#13;
&#13;
module Geometry where&#13;
&#13;
import SimpleVec ( R, Vec, (*^) )&#13;
import CoordinateSystems ( Position, cylindrical, spherical, cart, cyl, sph&#13;
                         , shiftPosition, displacement )</pre>&#13;
<p class="listing"><em>Listing 23-1: Opening lines of code for the <span class="codeitalic1">Geometry</span> module</em></p>&#13;
<p class="indent">We’ll use the type <span class="literal">Position</span> and the related functions we defined in the <span class="literal">CoordinateSystems</span> module in <a href="ch22.xhtml">Chapter 22</a>, so we’ve imported these and a few types and functions from the <span class="literal">SimpleVec</span> module of <a href="ch10.xhtml">Chapter 10</a>.</p>&#13;
<p class="indent">Our first geometric objects are one-dimensional curves embedded in three-dimensional space.</p>&#13;
<h3 class="h3" id="ch23lev2">Curves</h3>&#13;
<p class="noindent">Curves have two distinct uses in electromagnetic theory. First, we use them to describe the place that electric charge and current live. Current in a wire can flow along a curve. Static charge can also be placed along a curve.</p>&#13;
<p class="indent">The second place we use them is in Ampere’s law, which asserts a relationship between the magnetic field along a closed curve in space (a loop) and the electric current that flows through a surface with the closed curve as its boundary. This second use of curves is more abstract since the curve doesn’t need to be the location of any actual material, but it’s also more important for a deep understanding of modern electromagnetic theory.</p>&#13;
<h4 class="h4" id="ch23lev3">Parameterizing Curves</h4>&#13;
<p class="noindent">How can we describe a curve in space? We can parameterize the curve so there’s a real number associated with each point on the curve and then give (by way of a function) the position in space associated with each value of the parameter. For example, a line along the y-axis could be parameterized with the following function:</p>&#13;
<div class="imagec"><img src="Images/450equ01.jpg" alt="Image" width="98" height="20"/></div>&#13;
<p class="indent">A circle with radius 2 in the xy-plane centered at the origin could be parameterized with the following function:</p>&#13;
<div class="imagec"><img src="Images/450equ02.jpg" alt="Image" width="438" height="20"/></div>&#13;
<p class="indent">In these functions, <em>t</em> serves only as the name of a parameter (we could have chosen <em>s</em> or any convenient symbol) and has nothing to do with time.</p>&#13;
<p class="indent">A parameterized curve therefore requires a function with type <span class="literal">R -&gt;</span> <span class="literal">Position</span> sending a parameter <span class="literal">t :: R</span> along the curve to a point <span class="literal">r :: Position</span> <span epub:type="pagebreak" id="page_451"/>in space. But we also need starting and ending points for our curve. For example, the circle in the xy-plane with radius 2 centered at the origin can be specified with the function</p>&#13;
<div class="imagec"><img src="Images/451equ01.jpg" alt="Image" width="184" height="20"/></div>&#13;
<p class="noindent">as well as the starting parameter <em>t<sub>a</sub></em> = 0 and the ending parameter <em>t<sub>b</sub></em> = 2<em>π</em>. If we use the same function and starting parameter but change the ending parameter to <em>t<sub>b</sub></em> = <em>π</em>, we get a semicircle (the half circle above the x-axis).</p>&#13;
<p class="indent">The starting and ending points can be specified by a starting parameter <span class="literal">startingCurveParam :: R</span> (which we called <em>t<sub>a</sub></em> earlier) and an ending parameter <span class="literal">endingCurveParam :: R</span> (which we called <em>t<sub>b</sub></em>). Thus, we specify a curve with three pieces of data: a function, a starting parameter, and an ending parameter.</p>&#13;
<p class="indent">A data type can be used to combine pieces of data that really belong together. For the curve, it will be very convenient to have a single type <span class="literal">Curve</span> that contains the function, the starting point, and the ending point.</p>&#13;
<pre>data Curve = Curve { curveFunc          :: R -&gt; Position&#13;
                   , startingCurveParam :: R  -- t_a&#13;
                   , endingCurveParam   :: R  -- t_b&#13;
                   }</pre>&#13;
<p class="indent">The data type <span class="literal">Curve</span> has a single data constructor that is also called <span class="literal">Curve</span>.</p>&#13;
<h4 class="h4" id="ch23lev4">Examples of Curves</h4>&#13;
<p class="noindent">Let’s encode the example of the circle with radius 2 in the xy-plane centered at the origin.</p>&#13;
<pre>circle2 :: Curve&#13;
circle2 = Curve (\t -&gt; cart (2 * cos t) (2 * sin t) 0) 0 (2*pi)</pre>&#13;
<p class="indent">We’re naming our curve circle2 to remind us of the radius 2. The parameterization 23.1 is given as the first argument to the data constructor <span class="literal">Curve</span>, followed by the starting and ending curve parameters.</p>&#13;
<p class="indent">A circle in the xy-plane centered at the origin is easier to express in cylindrical coordinates than in Cartesian. In cylindrical coordinates, our circle has the constant values <em>s</em> = 2 and <em>z</em> = 0. Only the <em>ϕ</em> coordinate changes from 0 to 2<em>π</em>. This suggests that we use the <em>ϕ</em> coordinate as our parameter for the curve.</p>&#13;
<pre>circle2' :: Curve&#13;
circle2' = Curve (\phi -&gt; cyl 2 phi 0) 0 (2*pi)</pre>&#13;
<p class="indent">We use the cyl function to specify the curve in cylindrical coordinates. The curve <span class="literal">circle2'</span> is the same as the curve circle2.</p>&#13;
<p class="indent">Here’s the definition for a unit circle:</p>&#13;
<pre>unitCircle :: Curve&#13;
unitCircle = Curve (\t -&gt; cyl 1 t 0) 0 (2 * pi)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_452"/>There are families of curves for which we need to provide additional information before we’ve defined a specific curve. A straight line segment is such a curve. We need to provide both a starting position and an ending position, which is the perfect job for a higher-order function.</p>&#13;
<pre>straightLine :: Position  -- starting position&#13;
             -&gt; Position  -- ending position&#13;
             -&gt; Curve     -- straight-line curve&#13;
straightLine r1 r2 = let d = displacement r1 r2&#13;
                         f t = shiftPosition (t *^ d) r1&#13;
                     in Curve f 0 1</pre>&#13;
<p class="indent">We define the local name <span class="literal">d</span> to be the displacement vector pointing from position <span class="literal">r1</span> to position <span class="literal">r2</span>. We also define a local function <span class="literal">f</span> as our curve function by using the <span class="literal">shiftPosition</span> function to pick out the position that is shifted from <span class="literal">r1</span> by the displacement vector <span class="literal">t *^ d</span>. The curve parameter <span class="literal">t</span> runs from <span class="literal">0</span> to <span class="literal">1</span>, so <span class="literal">t *^ d</span> is a scaled version of the displacement vector <span class="literal">d</span> that runs from length 0 to the full length of <span class="literal">d</span>.</p>&#13;
<p class="indent">We’ve seen how to talk about one-dimensional curves in Haskell. Now let’s move up a dimension and talk about surfaces.</p>&#13;
<h3 class="h3" id="ch23lev5">Surfaces</h3>&#13;
<p class="noindent">Surfaces have two distinct uses in electromagnetic theory. We use them to describe the place that electric charge and current live. Current can flow along a surface. Static charge can also be placed on a surface.</p>&#13;
<p class="indent">We also use them in Gauss’s law, which asserts a relationship between the electric field on a closed surface in space and the electric charge inside that surface. This second use of surfaces is more abstract since the surface need not be the location of any actual material, but it’s also more important for a deep understanding of modern electromagnetic theory.</p>&#13;
<h4 class="h4" id="ch23lev6">Parameterizing Surfaces</h4>&#13;
<p class="noindent">A surface is a parameterized function from two parameters to space. For example, we can parameterize the unit sphere with two parameters, <em>θ</em> and <em>ϕ</em>, as the function</p>&#13;
<div class="imagec"><img src="Images/452equ01.jpg" alt="Image" width="326" height="20"/></div>&#13;
<p class="noindent">and the ranges 0 ≤ <em>θ</em> ≤ <em>π</em> and 0 ≤ <em>ϕ</em> ≤ 2<em>π</em>.</p>&#13;
<p class="indent">For a second example, suppose we want to parameterize the surface that lies in the xy-plane, bounded by the parabola <em>y</em> = <em>x</em><sup>2</sup> and the line <em>y</em> = 4. This surface is shown in <a href="ch23.xhtml#ch23fig1">Figure 23-1</a>.</p>&#13;
<div class="imagel" id="ch23fig1"><img src="Images/453fig01.jpg" alt="Image" width="397" height="372"/></div>&#13;
<p class="figcap"><em>Figure 23-1: A parameterized surface</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_453"/>In this case, it makes sense to use <em>x</em> and <em>y</em> as the parameters. The parameterized function for the surface is not very exciting:</p>&#13;
<div class="imagec"><img src="Images/453equ01.jpg" alt="Image" width="132" height="21"/></div>&#13;
<p class="indent">The interesting part about this surface is the specification of the boundary. There’s a lower curve of <em>y</em> = <em>x</em><sup>2</sup> that gives the bottom boundary, an upper curve of <em>y</em> = 4 that gives the top boundary, a lower limit of <em>x</em> = –2 that specifies the left boundary, and an upper limit of <em>x</em> = 2 that specifies the right boundary.</p>&#13;
<p class="indent">For a general surface, we will call our two parameters <em>s</em> and <em>t</em>. (This parameter <em>s</em> is unrelated to the <em>s</em> of cylindrical coordinates discussed in <a href="ch22.xhtml">Chapter 22</a>.) To specify a general surface, we must give five pieces of data: a parameterizing function of two variables, a lower curve, an upper curve, a lower limit, and an upper limit. Here’s the data type definition for a general surface:</p>&#13;
<pre>data Surface = Surface { surfaceFunc :: (R,R) -&gt; Position&#13;
                       , lowerLimit  :: R       -- s_l&#13;
                       , upperLimit  :: R       -- s_u&#13;
                       , lowerCurve  :: R -&gt; R  -- t_l(s)&#13;
                       , upperCurve  :: R -&gt; R  -- t_u(s)&#13;
                       }</pre>&#13;
<p class="indent">The function surfaceFunc is the parameterizing function that maps (<em>s</em>,<em>t</em>) into a <span class="literal">Position</span>. The lower curve is given as a function <em>t<sub>l</sub></em>(<em>s</em>) that gives the lowest value of <em>t</em> on the surface for each value of the parameter <em>s</em>. The upper curve is given as a function <em>t<sub>u</sub></em>(<em>s</em>) that gives the highest value of <em>t</em> on the surface for each value of the parameter <em>s</em>. The lower limit <em>s<sub>l</sub></em> is the lowest value of <em>s</em> on the surface, and the upper limit <em>s<sub>u</sub></em> is the largest value of <em>s</em> on the surface.</p>&#13;
<h4 class="h4" id="ch23lev7"><span epub:type="pagebreak" id="page_454"/>Examples of Surfaces</h4>&#13;
<p class="noindent">To encode the unit sphere we discussed earlier, we can write the following:</p>&#13;
<pre>unitSphere :: Surface&#13;
unitSphere = Surface (\(th,phi) -&gt; cart (sin th * cos phi)&#13;
                                        (sin th * sin phi)&#13;
                                        (cos th))&#13;
                     0 pi (const 0) (const $ 2*pi)</pre>&#13;
<p class="indent">In this case, we want constant functions for the lower and upper curves, so we use the const function to turn a number into a constant function and the <span class="literal">$</span> operator to avoid the need for parentheses around <span class="literal">2*pi</span>.</p>&#13;
<p class="indent">Unsurprisingly, it’s easier to specify a unit sphere in spherical coordinates.</p>&#13;
<pre>unitSphere' :: Surface&#13;
unitSphere' = Surface (\(th,phi) -&gt; sph 1 th phi)&#13;
                      0 pi (const 0) (const $ 2*pi)</pre>&#13;
<p class="indent">In spherical coordinates, we use the same parameters (<em>θ</em>,<em>ϕ</em>), the same lower and upper curves, and the same limits. Only the parameterizing function changes. The surface <span class="literal">unitSphere'</span> is the same surface as unitSphere.</p>&#13;
<p class="indent">Let’s encode our parabolic surface from <a href="ch23.xhtml#ch23fig1">Figure 23-1</a>.</p>&#13;
<pre>parabolaSurface :: Surface&#13;
parabolaSurface = Surface (\(x,y) -&gt; cart x y 0)&#13;
                          (-2) 2 (\x -&gt; x*x) (const 4)</pre>&#13;
<p class="indent">We use anonymous functions to specify both the surface parameterization and the parabolic lower boundary curve.</p>&#13;
<p class="indent">What about a sphere centered at an arbitrary position with an arbitrary radius? We could parameterize it by hand, but instead let’s define a function that shifts the location of any surface. That seems like a useful function to have around.</p>&#13;
<pre>shiftSurface :: Vec -&gt; Surface -&gt; Surface&#13;
shiftSurface d (Surface g sl su tl tu)&#13;
    = Surface (shiftPosition d . g) sl su tl tu</pre>&#13;
<p class="indent">The <span class="literal">shiftSurface</span> function doesn’t change the limits of the parameters being used. Instead, it shifts the positions that the parameterizing function <span class="literal">g</span> was providing by the displacement vector <span class="literal">d</span>.</p>&#13;
<p class="indent">Next, we define a centered sphere with an arbitrary radius.</p>&#13;
<pre>centeredSphere :: R -&gt; Surface&#13;
centeredSphere r = Surface (\(th,phi) -&gt; sph r th phi)&#13;
                           0 pi (const 0) (const $ 2*pi)</pre>&#13;
<p class="indent">Finally, we define a sphere with an arbitrary center and arbitrary radius.</p>&#13;
<span epub:type="pagebreak" id="page_455"/>&#13;
<pre>sphere :: R -&gt; Position -&gt; Surface&#13;
sphere radius center&#13;
    = shiftSurface (displacement (cart 0 0 0) center)&#13;
      (centeredSphere radius)</pre>&#13;
<p class="indent">Here’s the northern hemisphere of the unit sphere:</p>&#13;
<pre>northernHemisphere :: Surface&#13;
northernHemisphere = Surface (\(th,phi) -&gt; sph 1 th phi)&#13;
                             0 (pi/2) (const 0) (const $ 2*pi)</pre>&#13;
<p class="indent">Here’s a disk in the xy-plane, centered at the origin:</p>&#13;
<pre>disk :: R -&gt; Surface&#13;
disk radius = Surface (\(s,phi) -&gt; cyl s phi 0)&#13;
                      0 radius (const 0) (const (2*pi))</pre>&#13;
<p class="indent">I don’t think the term “unit cone” is standard terminology, but here is a cone in which the circular boundary of the base lies on a unit sphere, with the vertex of the cone at the center of the sphere:</p>&#13;
<pre>unitCone :: R -&gt; Surface&#13;
unitCone theta = Surface (\(r,phi) -&gt; sph r theta phi)&#13;
                         0 1 (const 0) (const (2*pi))</pre>&#13;
<p class="indent">These surfaces, or ones you write, can be used in <a href="ch24.xhtml">Chapter 24</a> to form a charge distribution in which charge is distributed across a surface, or in <a href="ch26.xhtml">Chapter 26</a> to form a current distribution in which current flows across a surface. Closed surfaces, such as spheres, can be used with Gauss’s law.</p>&#13;
<h4 class="h4" id="ch23lev8">Orientation</h4>&#13;
<p class="noindent">Our surfaces are oriented surfaces. An <em>orientation</em> is a choice of which direction (perpendicular to the surface) to consider “positive.” If <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> is a unit vector pointing in the direction of increasing <em>s</em>, and <img class="inline" src="Images/tcap.jpg" alt="Image" width="7" height="19"/> is a unit vector pointing in the direction of increasing <em>t</em>, then the positive direction for orientation is <img class="inline" src="Images/455equ01.jpg" alt="Image" width="44" height="19"/>. (The parameter <em>s</em> used in specifying a surface and its associated unit vector <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> are unrelated to the cylindrical coordinate <em>s</em> and its associated unit vector <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/>. Context should make clear which is meant.) The orientation of a surface is important in a flux integral, which is used to calculate electric flux, magnetic flux, and current flowing through a surface.</p>&#13;
<p class="indent">Let’s determine the orientation for the <span class="literal">unitSphere</span>. We used spherical coordinates to parameterize this surface, with the first parameter (in general called <em>s</em>) being <em>θ</em> for the unit sphere and the second parameter (in general called <em>t</em>) being <em>ϕ</em> for the unit sphere. Therefore, as shown in <a href="ch23.xhtml#ch23fig2">Figure 23-2</a>, the orientation of the unit sphere is positive in the <img class="inline" src="Images/455equ04.jpg" alt="Image" width="52" height="25"/> direction. In spherical coordinates, <img class="inline" src="Images/455equ03.jpg" alt="Image" width="87" height="25"/>, meaning that “outward” is the positive direction of orientation for the unit sphere.</p>&#13;
<div class="imagel" id="ch23fig2"><img src="Images/456fig01.jpg" alt="Image" width="316" height="319"/></div>&#13;
<p class="figcap"><em>Figure 23-2: When the first parameter s is <em>θ</em> and the second parameter t is <em>ϕ</em>, the direction of orientation is <img class="inline" src="Images/455equ04.jpg" alt="Image" width="52" height="25"/>, which is the same as <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/>, so the orientation is outward.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_456"/>We could make a unit sphere with “inward” as the orientation, but we would need to parameterize it differently from the <span class="literal">unitSphere</span>. If we take <em>ϕ</em> as the first parameter and <em>θ</em> as the second, the orientation is inward.</p>&#13;
<h3 class="h3" id="ch23lev9">Volumes</h3>&#13;
<p class="noindent">When we have a charge that’s distributed throughout a volume, we’ll use a volume charge density to describe it; therefore, we’ll need a new data type to describe a volume. We need to specify seven pieces of data to describe a volume:</p>&#13;
<p class="numberlistr">1. A parameterizing function from three parameters (<em>s</em>,<em>t</em>,<em>u</em>) into space</p>&#13;
<p class="numberlistr">2. A lower surface <em>u<sub>l</sub></em>(<em>s</em>,<em>t</em>) describing the lowest value of <em>u</em> for each (<em>s</em>,<em>t</em>)</p>&#13;
<p class="numberlistr">3. An upper surface <em>u<sub>u</sub></em>(<em>s</em>,<em>t</em>) describing the highest value of <em>u</em> for each (<em>s</em>,<em>t</em>)</p>&#13;
<p class="numberlistr">4. A lower curve <em>t<sub>l</sub></em>(<em>s</em>) describing the lowest value of <em>t</em> for each value of <em>s</em></p>&#13;
<p class="numberlistr">5. An upper curve <em>t<sub>u</sub></em>(<em>s</em>) describing the highest value of <em>t</em> for each value of <em>s</em></p>&#13;
<p class="numberlistr">6. A lower limit <em>s<sub>l</sub></em> describing the lowest value of <em>s</em></p>&#13;
<p class="numberlistr">7. An upper limit <em>s<sub>u</sub></em> describing the highest value of <em>s</em></p>&#13;
<p class="indent">Here’s the definition of the <span class="literal">Volume</span> data type:</p>&#13;
<pre>data Volume = Volume { volumeFunc :: (R,R,R) -&gt; Position&#13;
                     , loLimit    :: R            -- s_l&#13;
                     , upLimit    :: R            -- s_u&#13;
                     , loCurve    :: R -&gt; R       -- t_l(s)&#13;
                     , upCurve    :: R -&gt; R       -- t_u(s)&#13;
                     , loSurf     :: R -&gt; R -&gt; R  -- u_l(s,t)&#13;
                     , upSurf     :: R -&gt; R -&gt; R  -- u_u(s,t)&#13;
                     }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_457"/>The volumeFunc for a given <span class="literal">Volume</span> has type <span class="literal">(R,R,R) -&gt; Position</span>. Recall from <a href="ch22.xhtml">Chapter 22</a> that this type is the same as <span class="literal">CoordinateSystem</span>. We’ll often want to use cartesian, cylindrical, or spherical as our volumeFunc, although it’s possible to invent your own coordinate system.</p>&#13;
<p class="indent">Here’s a unit ball, centered at the origin:</p>&#13;
<pre>unitBall :: Volume&#13;
unitBall = Volume spherical 0 1 (const 0) (const pi)&#13;
                  (\_ _ -&gt; 0) (\_ _ -&gt; 2*pi)</pre>&#13;
<p class="indent">For the volumeFunc, we use spherical, which means that the parameters (<em>s</em>,<em>t</em>,<em>u</em>) are the spherical coordinates (<em>r</em>,<em>θ</em>,<em>ϕ</em>). We must provide a lower limit <em>r<sub>l</sub></em>, an upper limit <em>r<sub>u</sub></em>, a lower curve <em>θ<sub>l</sub></em>(<em>r</em>), an upper curve <em>θ<sub>u</sub></em>(<em>r</em>), a lower surface <em>ϕ<sub>l</sub></em>(<em>r</em>,<em>θ</em>), and an upper surface <em>ϕ<sub>u</sub></em>(<em>r</em>,<em>θ</em>). For a ball, we should pick the following:</p>&#13;
<div class="imagec"><img src="Images/457equ01.jpg" alt="Image" width="108" height="175"/></div>&#13;
<p class="indent">Notice that <em>θ<sub>l</sub></em> is the function <em>r</em> ↦ 0 (in Haskell notation <span class="literal">\r -&gt; 0</span> or <span class="literal">\_ -&gt; 0</span>). This the same as the constant function that returns 0 for any input (in Haskell notation const 0). The function <em>ϕ<sub>l</sub></em> takes <em>two</em> inputs and returns 0 (in Haskell notation <span class="literal">\_ _ -&gt; 0</span>).</p>&#13;
<p class="indent">Here’s a cylinder with a circular base centered at the origin and circular top in the plane <em>z</em> = <em>h</em>. We give the radius and height of the cylinder as inputs to the function <span class="literal">centeredCylinder</span>.</p>&#13;
<pre>centeredCylinder :: R       -- radius&#13;
                 -&gt; R       -- height&#13;
                 -&gt; Volume  -- cylinder&#13;
centeredCylinder radius height&#13;
  = Volume cylindrical 0 radius (const 0) (const (2*pi))&#13;
           (\_ _ -&gt; 0) (\_ _ -&gt; height)</pre>&#13;
<p class="indent">These volumes, or ones you write, can be used in <a href="ch24.xhtml">Chapter 24</a> to form a charge distribution in which charge is distributed throughout a volume, or in <a href="ch26.xhtml">Chapter 26</a> to form a current distribution in which current flows throughout a volume.</p>&#13;
<h3 class="h3" id="ch23lev10">Summary</h3>&#13;
<p class="noindent">In this chapter, we developed the data types <span class="literal">Curve</span>, <span class="literal">Surface</span>, and <span class="literal">Volume</span> for describing geometric objects. We defined some particular geometric objects, such as <span class="literal">unitCircle</span>, <span class="literal">sphere</span>, and <span class="literal">unitBall</span>. These curves, surfaces, and volumes will become objects we integrate over to calculate electric fields, and they <span epub:type="pagebreak" id="page_458"/>will also serve as the abstract settings for Gauss’s law and Ampere’s law. The next chapter discusses charge distributions in preparation for the following chapter on electric fields.</p>&#13;
<h3 class="h3" id="ch23lev11">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 23.1.</strong> Replace the undefined r radius below with a definition that will take a center position and radius and produce a circle parallel to the xy-plane.</p>&#13;
<pre>circle :: Position  -- center position&#13;
       -&gt; R         -- radius&#13;
       -&gt; Curve&#13;
circle r radius = undefined r radius</pre>&#13;
<p class="noindentts"><strong>Exercise 23.2.</strong> A helix can be parameterized most easily in cylindrical coordinates. In cylindrical coordinates (<em>s</em>,<em>ϕ</em>,<em>z</em>), a helix with radius 1 can be parameterized as</p>&#13;
<div class="imagec"><img src="Images/458equ01.jpg" alt="Image" width="134" height="20"/></div>&#13;
<p class="indent">Define a <span class="literal">Curve</span> for this helix. Choose end points so that the helix makes five loops around.</p>&#13;
<p class="noindentts"><strong>Exercise 23.3.</strong> A square has four sides. Let’s make a <span class="literal">Curve</span> to represent a square with vertices (–1,–1,0), (1,–1,0), (1,1,0), and (–1,1,0). Make the orientation of the curve counterclockwise. Fill in the parts that are <span class="literal">undefined</span>.</p>&#13;
<pre>square :: Curve&#13;
square = Curve squareFunc 0 4&#13;
&#13;
squareFunc :: R -&gt; Position&#13;
squareFunc t&#13;
    |           t &lt; 1  = cart undefined   (-1)   0&#13;
    | 1 &lt;= t &amp;&amp; t &lt; 2  = cart     1    undefined 0&#13;
    | 2 &lt;= t &amp;&amp; t &lt; 3  = cart undefined     1    0&#13;
    | otherwise        = cart   (-1)   undefined 0</pre>&#13;
<p class="noindentts"><strong>Exercise 23.4.</strong> Define a <span class="literal">Surface</span> for a cone with height <em>h</em> and radius <em>r</em>. Do not include the surface of the base of the cone. Position and orient the cone however it’s convenient.</p>&#13;
<p class="noindentts"><strong>Exercise 23.5.</strong> Replace the undefined that follows with a definition of an upper-half ball (<em>z</em> ≥ 0) with unit radius, centered at the origin.</p>&#13;
<pre>northernHalfBall :: Volume&#13;
northernHalfBall = undefined</pre>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_459"/><strong>Exercise 23.6.</strong> Replace the <span class="literal">undefined</span> that follows with a definition of a ball with given a radius centered at the origin. (The <span class="literal">R</span> is the type of the radius, and you may want to put a variable for the radius on the left of the equal sign.)</p>&#13;
<pre>centeredBall :: R -&gt; Volume&#13;
centeredBall = undefined</pre>&#13;
<p class="noindentts"><strong>Exercise 23.7.</strong> What is the type of <span class="literal">shiftPosition d</span> in the definition of <span class="literal">shift</span> <span class="literal">Surface</span> given earlier?</p>&#13;
<p class="noindentts"><strong>Exercise 23.8.</strong> Define a function</p>&#13;
<pre>shiftVolume :: Vec -&gt; Volume -&gt; Volume&#13;
shiftVolume = undefined</pre>&#13;
<p class="noindentts">that takes a displacement vector and a volume as input and returns a shifted volume as output.</p>&#13;
<p class="noindentts"><strong>Exercise 23.9.</strong> Define a function</p>&#13;
<pre>quarterDiskBoundary :: R -&gt; Curve&#13;
quarterDiskBoundary = undefined</pre>&#13;
<p class="noindentts">that takes a radius as input and gives a <span class="literal">Curve</span> as output corresponding to <a href="ch23.xhtml#ch23fig3">Figure 23-3</a>.</p>&#13;
<div class="imagel" id="ch23fig3"><img src="Images/459fig01.jpg" alt="Image" width="330" height="339"/></div>&#13;
<p class="figcap"><em>Figure 23-3: A curve representing the boundary of a quarter disk</em></p>&#13;
<p class="noindentts"><strong>Exercise 23.10.</strong> Define a <span class="literal">Surface</span> for the rectangular region that is shown in <a href="ch23.xhtml#ch23fig4">Figure 23-4</a>. Choose your parameterization so that the orientation is in the <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/> direction (the positive x-direction).</p>&#13;
<div class="imagel" id="ch23fig4"><img src="Images/460fig01.jpg" alt="Image" width="467" height="468"/></div>&#13;
<p class="figcap"><em>Figure 23-4: A surface in the yz-plane</em></p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_460"/><strong>Exercise 23.11.</strong> Define a function</p>&#13;
<pre>quarterCylinder :: R -&gt; R -&gt; Volume&#13;
quarterCylinder = undefined</pre>&#13;
<p class="noindentts">that takes a height <em>h</em> and radius <em>R</em> as input and gives a <span class="literal">Volume</span> as output corresponding to <a href="ch23.xhtml#ch23fig5">Figure 23-5</a>.</p>&#13;
<div class="imagel" id="ch23fig5"><img src="Images/460fig02.jpg" alt="Image" width="304" height="297"/></div>&#13;
<p class="figcap"><em>Figure 23-5: A volume representing a quarter cylinder</em></p>&#13;
<p class="noindentts"><strong>Exercise 23.12.</strong></p>&#13;
<p class="alphats">(a) Define a <span class="literal">Surface</span> for a torus with major radius 3 and minor radius 0.5.</p>&#13;
<p class="alphats">(b) Define a <span class="literal">Volume</span> for the space inside the torus of part (a).</p>&#13;
</div></body></html>