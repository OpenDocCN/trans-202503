- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BLUELEAKS,
    BLACK LIVES MATTER, AND THE CSV FILE FORMAT</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: The BlueLeaks dataset is full of an overwhelming number of documents, but it’s
    not immediately obvious where to start or how to make sense of the data they contain.
    Before beginning an investigation, I needed a way to efficiently determine the
    significance of these documents. After manually digging through many files, I
    discovered that the context I needed was in the hundreds of CSV spreadsheets in
    each BlueLeaks folder. In this chapter, you’ll learn how to investigate CSV files
    like these yourself.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll view CSVs in both graphical spreadsheet and text editing software, write
    Python code to loop through the rows of a CSV, and save CSVs of your own. You’ll
    then put this knowledge into practice by digging through the CSVs in the BlueLeaks
    dataset, focusing on data from the NCRIC fusion center. This is the data I myself
    have primarily focused on since BlueLeaks was published years ago, but there are
    over a hundred other folders in the dataset full of newsworthy revelations. By
    the end of this chapter, you’ll have the tools to continue investigating these
    folders, as well as similar datasets loaded with CSVs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Installing Spreadsheet Software</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most user-friendly way to view the contents of a CSV file is to open it
    using spreadsheet software such as LibreOffice Calc, Microsoft Excel, Apple Numbers,
    or Google Sheets. Spreadsheet software is a great option to see the data you’re
    dealing with in an organized way, and it can also be a powerful tool to analyze
    CSVs. However, in many cases, depending on the data you’re working with, you’ll
    need to go beyond such software and write custom code to work with CSVs.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have a favorite spreadsheet program, you can use that for the
    projects in this book. If not, I suggest using LibreOffice Calc since it’s free,
    open source, and available for Windows, macOS, and Linux; it’s also what I’ve
    used for the examples in this chapter. Installing LibreOffice ([*https://<wbr>www<wbr>.libreoffice<wbr>.org*](https://www.libreoffice.org))
    installs a whole suite of office software, including Calc.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, Microsoft Excel is a good option, but it costs money and isn’t
    available for Linux. If you have a Mac, you can also use Apple’s free spreadsheet
    software, Numbers. Finally, you can consider using Google Sheets, the spreadsheet
    feature of Google Docs. Google Docs is free and works in Windows, macOS, and Linux,
    since it’s web-based. The problem with Google Sheets and any other cloud-based
    spreadsheet software (like the web-based version of Microsoft Excel) is that you
    have to upload a copy of your CSV file to a third-party service before you can
    view it. For public datasets like BlueLeaks, this is okay. However, it’s better
    to use desktop spreadsheet software when you’re dealing with more sensitive datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Spreadsheet software, when used with more complicated spreadsheet formats such
    as Microsoft Excel files (*.xlsx*) or ODF Spreadsheet files (*.ods*), is powerful
    and feature-rich. It can do math, like summing all of the values in a column,
    and visualize data, like creating pie charts or line graphs. None of these features
    are supported in CSV files, though, so I won’t discuss them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your spreadsheet software installed, you’re ready to learn more
    about the structure of CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Introducing the CSV File Format</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can think of spreadsheets as tables of data. The top row normally has headers
    for each column, and the rest of the rows represent data that matches those headers.
    CSV is the simplest spreadsheet format. You can open CSV files using software
    like Microsoft Excel or LibreOffice Calc, or you can view them in a text editor
    and use CLI tools like <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>
    to search them.
  prefs: []
  type: TYPE_NORMAL
- en: BlueLeaks is full of CSV files, but the original data from the fusion center
    websites wasn’t in that format. The BlueLeaks dataset includes source code for
    those websites, and by reviewing that, I discovered that each site had actually
    stored its data in a Microsoft Access database file. The BlueLeaks hacker exported
    tables from the Access databases and saved that data in CSV format before leaking
    it to DDoSecrets.
  prefs: []
  type: TYPE_NORMAL
- en: CSV files are simply text files made up of multiple lines representing rows
    in a table. Each line contains a list of values, usually separated by commas (hence
    the name *comma-separated values*), with each value representing a *cell* in the
    spreadsheet. Sometimes a spreadsheet row is referred to as a *record*, with each
    cell in that row referred to as a *field* in that record. Typically, each row
    contains the same number of cells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example CSV file called *city-populations.csv*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find a copy of this file in the book’s GitHub repository at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-9<wbr>/city<wbr>-populations<wbr>.csv*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-9/city-populations.csv).
    I’ll use this file as an example CSV later in this chapter, so download it now
    (or re-enter it) and save it in a folder for this chapter’s exercises.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-1](#tab9-1) shows the data from the *city-populations.csv* file organized
    into rows and columns.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-1:</samp> <samp class="SANS_Futura_Std_Book_11">City
    Populations</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">City</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Country</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Population</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">T</samp><samp class="SANS_FuturaStd_AN-Book_Book_11">ō</samp><samp
    class="SANS_Futura_Std_Book_11">ky</samp><samp class="SANS_FuturaStd_AN-Book_Book_11">ō</samp>
    | <samp class="SANS_Futura_Std_Book_11">Japan</samp> | <samp class="SANS_Futura_Std_Book_11">37,400,000</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Delhi</samp> | <samp class="SANS_Futura_Std_Book_11">India</samp>
    | <samp class="SANS_Futura_Std_Book_11">28,514,000</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Shanghai</samp> | <samp class="SANS_Futura_Std_Book_11">China</samp>
    | <samp class="SANS_Futura_Std_Book_11">25,582,000</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">S</samp><samp class="SANS_FuturaStd_AN-Book_Book_11">ã</samp><samp
    class="SANS_Futura_Std_Book_11">o Paulo</samp> | <samp class="SANS_Futura_Std_Book_11">Brazil</samp>
    | <samp class="SANS_Futura_Std_Book_11">21,650,000</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Mexico City</samp> | <samp class="SANS_Futura_Std_Book_11">Mexico</samp>
    | <samp class="SANS_Futura_Std_Book_11">21,581,000</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Cairo</samp> | <samp class="SANS_Futura_Std_Book_11">Egypt</samp>
    | <samp class="SANS_Futura_Std_Book_11">20,076,000</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'When a value includes commas, it must be surrounded by quotation marks. For
    example, the values “Hello, World” and “Hola, Mundo” both contain commas. Here’s
    how they look in a CSV file along with fields for their respective languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 9-2](#tab9-2) shows this data organized into rows and columns.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-2:</samp> <samp class="SANS_Futura_Std_Book_11">Translations
    of “Hello, World”</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Language</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Greeting</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">English</samp> | <samp class="SANS_Futura_Std_Book_11">Hello,
    World</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Espa</samp><samp class="SANS_FuturaStd_AN-Book_Book_11">ñ</samp><samp
    class="SANS_Futura_Std_Book_11">ol</samp> | <samp class="SANS_Futura_Std_Book_11">Hola,
    Mundo</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'It’s common to enclose every value in quotes, regardless of whether it includes
    commas. Here’s another version of the previous spreadsheet, now with every value
    in quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As with shell scripting and Python programming, you can escape quotes in CSVs
    by using a backslash and double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">\"</samp>).
    For example, the value <samp class="SANS_TheSansMonoCd_W5Regular_11">"Not I,"
    said the cow</samp> contains both quotes and commas, so to add it to a CSV file
    you would surround the entire value in quotes and escape the inner quotes, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because the CSV file format is so simple, it’s one of the most commonly used
    spreadsheet formats, especially for anyone working with spreadsheets using code.
    Like CSVs, SQL databases also store *tabular data* (data that can be represented
    in a table), so CSVs are a convenient format for exporting tables from them. In
    fact, all of the CSVs in BlueLeaks are exported SQL tables from the databases
    that power law enforcement and fusion center websites. (You’ll learn about SQL
    databases in [Chapter 12](chapter12.xhtml); for now, you’ll work with the exported
    CSVs.)
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand a bit about the CSV file format, let’s take a look at
    some real CSV data from BlueLeaks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Exploring CSV Files with Spreadsheet
    Software and Text Editors</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In your graphical file browser (such as Explorer in Windows or Finder in macOS),
    browse to the *BlueLeaks-extracted* folder on your USB disk. You’ll start by examining
    the *dediac* subfolder, which contains data from the Delaware Information Analysis
    Center. Scroll through the files in this folder—nearly all of them are CSVs—and
    open *Documents.csv* in your graphical spreadsheet software.
  prefs: []
  type: TYPE_NORMAL
- en: When you open a file in LibreOffice Calc or other spreadsheet software, you’ll
    likely be presented with a window asking you to confirm the settings for this
    CSV. [Figure 9-1](#fig9-1) shows the window that pops up when I open *Documents.csv*
    in LibreOffice Calc on my Mac.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the LibreOffice Calc “Text Import” dialog after opening Documents.csv.
    This dialog allows you to choose the separator character, which in this case is
    a comma.](Images/Figure9-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The LibreOffice
    Calc Text Import settings</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The most important setting to select is the correct separator character, which
    is, in this and most cases, a comma (<samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp>).
    Some CSVs separate values with characters other than commas, like semicolons (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">;</samp>) or tabs (<samp class="SANS_TheSansMonoCd_W5Regular_11">\t</samp>),
    though this is rare. In the future if you aren’t sure which character your CSV
    uses, you can open the CSV in a text editor first to check.
  prefs: []
  type: TYPE_NORMAL
- en: Click **OK** to open the spreadsheet. This one should open quickly, but sometimes
    CSVs are huge—hundreds of mega- or gigabytes—so you may need to wait several seconds,
    or even minutes, for a large CSV to finish loading.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-2](#fig9-2) shows part of the *Documents.csv* spreadsheet in LibreOffice
    Calc.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of Documents.csv opened in LibreOffice. The column headers include
    DocumentID, DocFilename, and DocTitle. This is a list of documents hosted by the
    fusion center.](Images/Figure9-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: Viewing</samp>
    <samp class="SANS_Futura_Std_Book_11">Documents.csv</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    LibreOffice Calc</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This spreadsheet has 23 columns and 6,934 rows (one of which is the header row).
    At the top of the file, the dates in the DateEntered column are from 2011\. You
    can find the most recent data in a spreadsheet by *sorting* it, either in ascending
    (from smaller to bigger) or descending (bigger to smaller) order. I’ll show you
    how to sort this spreadsheet in LibreOffice Calc, but the instructions should
    be similar for other spreadsheet software and apply to any spreadsheet you want
    to sort.
  prefs: []
  type: TYPE_NORMAL
- en: First, since you don’t want to sort the header row, click **View**▸**Freeze
    Cells**▸**Freeze First Row**. This should freeze the header row, so now when you
    scroll up and down, the headers will remain at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to pick which column you want to sort by. To see the most recent
    documents at the top, sort by DateEntered descending. Before sorting this column,
    you must tell the spreadsheet software that those fields are dates with times
    and specify how they’re formatted (otherwise, the software might assume they’re
    strings and sort them alphabetically). Click column D to select all of the cells
    in that column and then click **Data**▸**Text to Columns**. This pops up a window
    that lets you define what type of data is in each column. At the bottom of the
    window, click the DateEntered column and choose **Date (MDY)** from the Column
    Type drop-down, because the dates in this data are formatted with month, then
    date, then year. Click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the spreadsheet software knows the correct format for the DateEntered
    cells, you can sort it by this column. Click the DateEntered header cell to select
    it (make sure not to select the whole column, just the header cell) and then click
    **Data**▸**Sort Descending**. This should reorder all of the rows so that the
    row with the most recent DateEntered is at the top and the one with oldest is
    at the bottom. In *Documents.csv*, the most recent documents are from June 6,
    2020, during the Black Lives Matter protests. Some of the most recent document
    titles include “Special Bulletin Planned Protests 060620 1800 UPDATE,” “ANTIFA
    Sub Groups and Indicators – LES,” and “ANTIFA - Fighting in the Streets.”
  prefs: []
  type: TYPE_NORMAL
- en: I often use graphical spreadsheet programs to search CSVs. In LibreOffice, as
    well as in other spreadsheet programs, you can find specific cells using the Find
    feature. Press CTRL-F (or, in macOS, -F), enter your search term, and press ENTER.
    This should search every cell in the spreadsheet for your term. You can use this
    method to find a row containing, for example, a specific ID number or email address.
  prefs: []
  type: TYPE_NORMAL
- en: When you close the spreadsheet, don’t save your changes. It’s good practice
    to avoid changing original documents in a dataset. If you want to keep a record
    of your changes, save the file as a copy in either the ODF Spreadsheet (*.ods*)
    or Excel (*.xlsx*) format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the same CSV in a text editor instead of spreadsheet software.
    Here are the first few lines of the *Documents.csv* file, as viewed in a text
    editor like VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Because text editors show you only the text when you view a CSV file, without
    lining up the columns like spreadsheet software does, it’s less clear which value
    matches to which header for each row. There’s no simple way to manipulate the
    data, either—you can’t sort it by DateEntered like you can in LibreOffice Calc
    or Microsoft Excel. However, it’s simple to write code that loads the data from
    CSVs into dictionaries, allowing you to manipulate it in any way you choose, as
    you’ll do later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with the structure of CSVs, you’re ready to see how
    I began my investigation into the BlueLeaks dataset.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">My BlueLeaks Investigation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I didn’t even realize that my local police intelligence agency, the Northern
    California Regional Intelligence Center (NCRIC, pronounced “nick-rick”), existed
    until I discovered it in the BlueLeaks dataset in June 2020\. In this section
    I describe how I went about my investigation into BlueLeaks, what I discovered
    in the NCRIC portion of the dataset, and a specific revelation I found in one
    of the NCRIC CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Focusing on a Fusion
    Center</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After downloading BlueLeaks, I indexed it in The Intercept’s Intella server
    to make it easier to search. This allowed me and journalists I worked with to
    quickly search it for keywords and find interesting documents. However, I could
    tell that searching for keywords would only get me so far. There was so much data
    that if I only searched terms like *Black Lives Matter*, I was bound to miss a
    lot of it. Moreover, the searches I did make often led me to CSVs, which would
    take more work to untangle.
  prefs: []
  type: TYPE_NORMAL
- en: BlueLeaks was split into hundreds of folders, each one belonging to a different
    law enforcement organization. Since almost all of these organizations were unfamiliar
    to me, though, I couldn’t tell from the names which folder belonged to which organization.
    I started my own spreadsheet to keep track of this, manually adding rows for each
    folder as I matched organizations and their websites to it. Eventually, I realized
    that I could automate this with a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: I also used shell scripting to figure out which folders had the most data, because
    I guessed they were the largest or most active fusion centers. I quickly discovered
    that the *ncric* folder, one of the largest in the dataset, held documents for
    NCRIC, so that’s where I decided to focus my digging.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Introducing NCRIC</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: NCRIC, based in San Francisco, shares information between federal agencies,
    local police departments across Northern California, and private industry partners,
    including tech companies. As I discovered by combing through the CSVs in this
    dataset, it also provides services to local cops, like monitoring social media
    or helping break into locked smartphones, and it hosts events and classes for
    law enforcement officers.
  prefs: []
  type: TYPE_NORMAL
- en: Using a custom tool I developed called BlueLeaks Explorer, which I’ll discuss
    in detail in [Chapter 10](chapter10.xhtml), I examined everything I could find
    in the *ncric* folder dated within the 13 days between George Floyd’s murder and
    when NCRIC was hacked. I discovered that twice a day, NCRIC emailed over 14,000
    cops an updated list of Black Lives Matter protests. Local police and other partners
    could also log in to NCRIC’s website and submit suspicious activity reports (SARs)
    to distribute to the fusion center’s partners. Local police also requested NCRIC’s
    help with monitoring the social media accounts of protest organizers and, in two
    instances, with identifying threats against white female teenagers who were facing
    harassment after making racist statements and using anti-Black slurs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Investigating a SAR</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By investigating a row from a CSV file, I found a PDF of a scanned letter that
    turned out to be newsworthy. The letter, written by an unhinged San Francisco–area
    lawyer to a local district attorney’s office, called a polite student from Oregon
    an “antifa terrorist.” In this section, I describe how I found this revelation
    in BlueLeaks, what it contains, and how the BlueLeaks CSVs reference other documents
    in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I grepped the CSV files in the *ncric* folder for the word *antifa*, I
    found that there were only a handful of references in the files *EmailBuilder
    .csv*, *Requests.csv*, *SARs.csv*, and *Survey.csv*. In particular, this row in
    *SARs.csv* stood out because it referenced a student protester, allegedly a member
    of an antifa group, and mentioned “Radicalization/Extremism”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Looking into the *SARs.csv* file, I found that it lists one month of SARs submitted
    to NCRIC. The earliest report was May 6, 2020, and the latest was June 6, 2020,
    so my guess is that NCRIC retains SARs only for a month.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try opening this file, *ncric/SARs.csv*, in your spreadsheet software, and
    you’ll see that it’s difficult to parse. There are 91 different columns, and some
    of the cells are filled with so much text that even with a large monitor, you
    can see only part of a row at a time. To make it easier to read, I copied the
    content of the BriefSummary cell from the spreadsheet and pasted it into my text
    editor, something that I frequently needed to do with the CSVs in this dataset
    before I developed BlueLeaks Explorer. Here are the relevant fields from the row
    that caught my eye:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SARSid** 14277'
  prefs: []
  type: TYPE_NORMAL
- en: '**FormTimeStamp** 06/05/20 14:20:09'
  prefs: []
  type: TYPE_NORMAL
- en: '**IncidentDate** 6/5/2020'
  prefs: []
  type: TYPE_NORMAL
- en: '**ThreatActivity** Radicalization/Extremism,Suspicious Incident'
  prefs: []
  type: TYPE_NORMAL
- en: '**BriefSummary** The attached letter was received via US Postal Service this
    morning. The letter was passed on from an anonymous party claiming to be a lawyer
    who was contacted by *[redacted name]* who is a University of Oregon student.
    *[Redacted name]* appears to be a member of the Antifa group and is assisting
    in planning protesting efforts in the Bay Area despite living in Oregon.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subjects** *[redacted name]*'
  prefs: []
  type: TYPE_NORMAL
- en: '**AgencyOrganizationNameOther** Marin County District Attorney’s Office'
  prefs: []
  type: TYPE_NORMAL
- en: '**File1** SARF100014\277.pdf'
  prefs: []
  type: TYPE_NORMAL
- en: '**File1Name** Letter.pdf'
  prefs: []
  type: TYPE_NORMAL
- en: '**EmailAddress** *[redacted]*@marincounty.org'
  prefs: []
  type: TYPE_NORMAL
- en: '**PhoneNumber** *[redacted phone number]*'
  prefs: []
  type: TYPE_NORMAL
- en: The SAR listed the full name, email address, and phone number of the person
    who had submitted it. I looked them up online and discovered that they worked
    as an investigator for the district attorney’s office in Marin County (just north
    of San Francisco). On June 5 at 2:20 PM (per the FormTimestamp field), the day
    before NCRIC was hacked, they logged in to the NCRIC website and submitted the
    SAR form. They included a PDF called *Letter.pdf* (per the File1Name field), though
    the website saved it in the *SARF100014* folder as *277.pdf* (per the File1 field).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The server that hosted NCRIC’s website and all of the other BlueLeaks sites
    was running Windows, which is why folders in paths are separated by backslashes
    (\), like* SARF100014\277.pdf*, instead of forward slashes (/).*'
  prefs: []
  type: TYPE_NORMAL
- en: Each BlueLeaks folder has a subfolder called *files*, where you can find the
    files referenced in the CSV. See if you can find the PDF referenced in the File1
    field in the *ncric* folder. It should be at the path *ncric/files/SARF100014/277.pdf*
    (see [Figure 9-3](#fig9-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the letter in 277.pdf, which was written and sent to the
    Marin County DA office by a Bay Area attorney.](Images/Figure9-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: A PDF attachment
    in the SAR submitted by an investigator from the Marin County DA’s office</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PDF shows a letter in all caps mailed to the Marin County DA’s office by
    a Bay Area attorney: “PLEASE SEE THE ATTACHED SOLICITATION I RECEIVED FROM AN
    ANTIFA TERRORIST WANTING MY HELP TO BAIL HER AND HER FRIENDS OUT OF JAIL, IF ARRESTED
    FOR RIOTING.” He explained that he was remaining anonymous because he “CANNOT
    RISK THIS PIECE OF SHIT ANTIFA […] FILING A BAR COMPLAINT AGAINST ME,” and warned
    that “THE SAN FRANCISCO PUBLIC DEFENDERS WILL VIGOROUSLY DEFEND THESE TERRORISTS.”
    He ended his letter, “HAPPY HUNTING.”'
  prefs: []
  type: TYPE_NORMAL
- en: Further down in the PDF, the attorney included the solicitation from the “antifa
    terrorist,” shown in [Figure 9-4](#fig9-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![The email written by the Oregon student and sent to the Bay Area attorney.](Images/Figure9-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: The letter that
    the Oregon student sent to the California lawyer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: “I am a long time activist and ally of the Black Lives Matter movement,” the
    Oregon student wrote. “… Is there anyway [*sic*] that I could add your firm, or
    consenting lawyers under your firm, to a list of resources who will represent
    protesters pro bono if they were/are to be arrested? Thank you very much for your
    time.” The Marin County DA investigator apparently believed that this was useful
    enough intelligence that they logged in to their account on NCRIC’s website and
    submitted it as “suspicious activity” for other law enforcement officers around
    Northern California to access. Under threat activity, they chose Radicalization/Extremism.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can read more about my findings from this SAR in the first article I wrote
    about BlueLeaks, at* [https://theintercept.com/2020/07/15/blueleaks-anonymous-ddos-law-enforcement-hack/](https://theintercept.com/2020/07/15/blueleaks-anonymous-ddos-law-enforcement-hack/)*.*
    *To learn more about what I discovered while researching NCRIC in general, check
    out my in-depth article at* [https://theintercept.com/2020/08/17/blueleaks-california-ncric-black-lives-matter-protesters/](https://theintercept.com/2020/08/17/blueleaks-california-ncric-black-lives-matter-protesters/)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: In theory, I could have stumbled upon the PDF in [Figure 9-3](#fig9-3) on its
    own; I might have just randomly clicked through documents and happened to open
    *ncric/files/SARF100014/277.pdf*, the path to the PDF in question. I could also
    have indexed the *ncric* folder in Aleph, OCRing all of the documents, and searched
    for *antifa*. However, the PDF alone doesn’t explain who uploaded it to the NCRIC
    website, when and why they uploaded it, and how they described the document. Moreover,
    if you’re interested in focusing on activity in the fusion center from a specific
    time period, it’s easier to find which documents are relevant by their timestamps
    in the CSV files. If you’re researching BlueLeaks yourself, you can quickly find
    all of the documents associated with a time period by sorting the spreadsheets
    by date, reading all the rows in the CSVs for that time period, and looking at
    the documents that those rows reference.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you find an interesting document in BlueLeaks, search the CSVs for
    its filename to figure out why that document is there to begin with. It could
    be an attachment in a SAR, part of a bulk-email message the fusion center sent
    to thousands of local police, or included for other reasons. In the case of *277.pdf*,
    now you know this document was uploaded as an attachment to a SAR by an investigator
    in a DA’s office. The CSV provides the investigator’s summary of the document’s
    contents, along with their contact information, which you can use to reach out
    to them for comment before publishing your findings.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen the type of data *SARs.csv* contains, you need a way to
    easily read the long blocks of text in those CSV cells without having to copy
    and paste them into a text editor. We’ll cover that in Exercise 9-1, but first,
    let’s have a quick tutorial on how to write code that works with CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading and Writing CSV Files in Python</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you learned in [Chapter 8](chapter8.xhtml), Python modules bring extra functionality
    into the script that you’re writing. It’s easy to load CSVs and turn each row
    into a Python dictionary using Python’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    module. You’ll need <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp> for
    this chapter’s exercises, so import it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After importing it, you can take advantage of its functionality. The <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    features I use the most are <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictReader()</samp>,
    which lets you parse rows of a CSV as dictionaries, and <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictWriter()</samp>,
    which lets you save your own CSVs from data stored in dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code loads a CSV file and loops through its rows by using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">csv.DictReader()</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code assumes the path to the CSV filename is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>
    variable, which could be a string that you hardcoded or a CLI argument you passed
    into your program. After opening the CSV file with <samp class="SANS_TheSansMonoCd_W5Regular_11">open(csv
    _path)</samp> and storing the file objects as <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>,
    the code defines a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">reader</samp>
    and sets its value to <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictReader(f)</samp>,
    which prepares you to read rows from this CSV. The <samp class="SANS_TheSansMonoCd_W5Regular_11">reader</samp>
    object acts a little like a list of dictionaries, where each dictionary represents
    a row. Although it’s not actually a list, you can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop to loop through it as if it were. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp> is a dictionary
    that represents the data in a row from the spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of saving new CSVs is similar to loading them, except you use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">csv.DictWriter()</samp>. For example,
    the following code uses Python to save the *city-populations.csv* file discussed
    in the “Introducing the CSV File Format” section earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code first defines the headers of the spreadsheet in the list <samp class="SANS_TheSansMonoCd_W5Regular_11">headers</samp>,
    then opens the output file (<samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>)
    for writing. Creating a <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictWriter()</samp>
    object allows you to save data into the CSV. You must pass the headers in as a
    keyword argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">fieldnames</samp>.
    You must also run <samp class="SANS_TheSansMonoCd_W5Regular_11">writer .writeheader()</samp>,
    which saves the header row to the CSV file, before writing any of the data rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then add rows to the spreadsheet by running <samp class="SANS_TheSansMonoCd_W5Regular_11">writer.writerow()</samp>,
    passing in a dictionary whose keys match your headers. For example, the first
    call of <samp class="SANS_TheSansMonoCd_W5Regular_11">writer.writerow()</samp>
    passes in the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">{"City":
    "Tōkyō", "Country": "Japan", "Population": 37400000}</samp>. The keys for this
    dictionary are the same as the headers for the CSV: <samp class="SANS_TheSansMonoCd_W5Regular_11">City</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Country</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Population</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercises, you’ll use your new CSV programming skills to write
    scripts that make the data hidden in BlueLeaks CSVs easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To learn more about the* <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">csv</samp>
    *module, you can find the full documentation, including plenty of example code,
    at* [https://docs.python.org/3/library/csv.html](https://docs.python.org/3/library/csv.html)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 9-1: Make BlueLeaks CSVs
    More Readable</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it’s easier to read *SARs.csv* in a spreadsheet program than in a text
    editor, it’s still quite difficult. As mentioned earlier, there are 91 columns
    (though most of their values are blank), and some of the text fields, like BriefSummary,
    contain way too much text to see at one time in a spreadsheet cell. In this exercise,
    you’ll write a script that makes *SARs.csv* (or any CSV with similar content)
    easier to read by showing you the data a single row at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is designed not just to show you how to work with the *SARs.csv*
    file, but to give you practice looping through the rows and fields in a CSV. These
    skills will come in handy whenever you write code that reads data from CSVs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a challenge, you could try programming your own script to meet the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Make this script accept an argument called <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>
    using Click, which you first learned to use in Exercise 8-3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp> module and
    loop through all of the rows in the CSV located at <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>,
    loading each row as a dictionary, as discussed in the previous section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each row, display all of the *non-empty* values for its columns. If a value
    is empty, meaning it’s an empty string (<samp class="SANS_TheSansMonoCd_W5Regular_11">""</samp>),
    skip it. There’s no reason to display all of the columns when so many of them
    have blank values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Display each field on its own line. For example, one line could show <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SARSid: 14277</samp> and the next line
    could show <samp class="SANS_TheSansMonoCd_W5Regular_11">FormTimeStamp: 06/05/20
    14:20:09</samp>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output a separator line like <samp class="SANS_TheSansMonoCd_W5Regular_11">===</samp>
    between each row so that you can tell rows apart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, follow along with the rest of this exercise and I’ll walk you
    through the programming process. Start with the usual Python script template in
    a file called *exercise-9-1.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll modify your script to accept the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accept the CSV Path
    as an Argument</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of hardcoding the path to a specific CSV, let’s use Click to accept
    the path as an argument. Here’s the code that does that (with modifications shown
    in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in Exercise 8-4, this code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, adds Click decorators before the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function to turn it into a command that accepts the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>
    argument, and adds a docstring. For now, it also displays the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>
    so you can test if the program works. Run the code to test it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The script just displays the CSV path that was passed in. So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Through the
    CSV Rows</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, you’ll modify the code to open the CSV in <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>,
    and, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp> module,
    create a <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictReader()</samp>
    object to loop through the rows of that CSV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code now imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    module at the top. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function runs, the code opens the file at <samp class="SANS_TheSansMonoCd_W5Regular_11">csv_path</samp>
    for reading, creating a file object variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>.
    As noted in “Reading and Writing CSV Files in Python,” you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictReader()</samp>
    to loop through a CSV file, getting access to each row as a dictionary. The code
    does this next, creating a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">reader</samp>
    and setting it equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictReader(f)</samp>.
    Using <samp class="SANS_TheSansMonoCd_W5Regular_11">reader</samp>, the code then
    loops through each row and displays the dictionary containing its data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the code again, this time passing in the path to *SARs.csv* as the CLI
    argument. Make sure you use the correct path for your copy of the BlueLeaks dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that during each loop, the <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp>
    variable is a dictionary containing the values for that row. So far, the code
    is simply displaying this whole dictionary. This is a good start, but it still
    doesn’t make the text much easier to read. To do that, you’ll display each field
    on its own row.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Display CSV Fields
    on Separate Lines</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following modified code displays each row separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Rather than just displaying the <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp>
    dictionary, this code loops through all of its keys, storing each in the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>
    is the key to the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp>,
    you can look up its value by using <samp class="SANS_TheSansMonoCd_W5Regular_11">row[key]</samp>.
    You only want to display fields that aren’t blank, so after making sure that this
    key doesn’t have a blank value, the code displays both it and the value. Finally,
    after it has finished looping through all of the keys in each row, the code displays
    the separator <samp class="SANS_TheSansMonoCd_W5Regular_11">===</samp> between
    the rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a copy of the complete script at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-9<wbr>/exercise<wbr>-9<wbr>-1<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-9/exercise-9-1.py).
    Run the final script like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This time, the output should display <samp class="SANS_TheSansMonoCd_W5Regular_11">===</samp>
    between the rows and display each field of a row on its own line. If there are
    any blank fields, the program skips them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the command line skills you learned in [Chapters 3](chapter3.xhtml) and
    [4](chapter4.xhtml), redirect the output into a file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This should run your script again, this time saving the output into *SARs.txt*
    instead of displaying it in your terminal. Now you can easily scroll through the
    saved output in a text editor like VS Code and search it for keywords to learn
    about the “suspicious activity” that occurred in Northern California from May
    6 to June 6, 2020.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we’ll move on from SARs to explore another important spreadsheet in NCRIC:
    *EmailBuilder.csv*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Read Bulk Email from Fusion Centers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary purpose of fusion centers is to share information between local,
    state, and federal law enforcement agencies. They do this, essentially, by sending
    bulk email to a large list of local police officers. You can find the content
    of this email for all sites in BlueLeaks, including NCRIC, in the *EmailBuilder.csv*
    file located in each site’s folder. These files include the content of all of
    the bulk-email messages each fusion center sent until June 6, 2020, when it was
    hacked.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these messages are security bulletins from federal agencies like the
    FBI or the Department of Homeland Security (DHS). Others contain content directly
    created by the fusion center—for example, NCRIC and other fusion centers around
    the US generated detailed daily lists of protests against police brutality during
    the summer of 2020\. For the 13 days of NCRIC data that I looked at in detail,
    over half of the bulk email contained information about largely peaceful protests.
  prefs: []
  type: TYPE_NORMAL
- en: The SARs spreadsheet contains plaintext data, so it’s easy to read in a text
    editor. But the bulk-email spreadsheet contains data in HyperText Markup Language
    (HTML) format, making it difficult to read unless you use a web browser. In this
    section, you’ll learn to more easily read the HTML content of NCRIC’s bulk email,
    find the recipients of each email, and find the documents attached to the email
    messages. Open *ncric/EmailBuilder.csv* in your spreadsheet software to follow
    along.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Lists of Black Lives
    Matter Demonstrations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the intelligence on Black Lives Matter protests flowed through NCRIC’s
    Terrorism Liaison Officer (TLO) program, whose purpose is to keep the intelligence
    center’s members “engaged & knowledgeable about current terrorist tactics, techniques
    & trends, regional crime trends & threats, and Officer safety information,” according
    to the TLO page on NCRIC’s website. During the summer of 2020, this counterterrorism
    program didn’t focus on terrorism so much as upcoming racial justice protests.
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the twice-daily lists of upcoming protests that TLO sent
    to thousands of local cops. Not only is this incredibly newsworthy—a counterterrorism
    program abused to monitor racial justice protests—but these were the most common
    bulk-email messages that NCRIC sent during the 13-day period I examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are the most interesting fields from the most recent row
    in *ncric/EmailBuilder.csv* (this CSV has 81 columns in total, most of which didn’t
    contain any relevant information):'
  prefs: []
  type: TYPE_NORMAL
- en: '**EmailBuilderID** 6170'
  prefs: []
  type: TYPE_NORMAL
- en: '**EmailFrom** NCRIC <info@ncric.net>'
  prefs: []
  type: TYPE_NORMAL
- en: '**EmailSubject** NCRIC TLO Bulletin LES'
  prefs: []
  type: TYPE_NORMAL
- en: '**EmailBody** <base href="https://ncric.ca.gov/"><div style= "font-family:
    times; text-align: center;"><font face="Calibri, Times"> UNCLASSIFIED//<font color="#ee0000">LAW
    ENFORCEMENT SENSITIVE</font></font></div> […]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attachment1** EBAT1\Events_060620_1800.pdf'
  prefs: []
  type: TYPE_NORMAL
- en: '**DateSent** 06/06/20 20:25:06'
  prefs: []
  type: TYPE_NORMAL
- en: '**EmailTable** Registrations'
  prefs: []
  type: TYPE_NORMAL
- en: '**SentEmailList** EBSE00006\170.csv'
  prefs: []
  type: TYPE_NORMAL
- en: This row tells us that on the evening of June 6, 2020, NCRIC sent an email with
    the subject line “NCRIC TLO Bulletin LES” to the list of people described in *EBSE00006\170.csv*
    (LES stands for Law Enforcement Sensitive). The email included the PDF attachment
    located at *EBAT1\Events_060620_1800.pdf*.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the email is the HTML in the EmailBody column. HTML is the markup
    language that describes web pages, so it can be hard to make sense of when you’re
    not viewing it in a web browser. To read this email body, in your text editor,
    create a new file called *EmailBuilder-6170.html* (since 6170 is the EmailBuilderID).
    Copy the content of the EmailBody field from your spreadsheet software for this
    row, paste it into this file, and save it. You can now open this file in a web
    browser to view it, but before you do that, you may want to read the “Covering
    Your Tracks with a VPN Service” box to consider mitigating what information you
    might leak by opening it.
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not you’ve connected to a VPN service (the choice is yours), open
    *EmailBuilder-6170.html* using a web browser by double-clicking on it in your
    file manager. [Figure 9-5](#fig9-5) shows what it looks like in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of an HTML bulk email viewed in the Firefox web browser, complete
    with images and formatting.](Images/Figure9-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: HTML from the EmailBody
    field in a row of</samp> <samp class="SANS_Futura_Std_Book_11">EmailBuilder.csv,</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">viewed in a web browser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the screenshot, this email body is a template, not the email
    itself. The HTML files stored inside CSVs for BlueLeaks sites are all templates.
    When sending the email, the NCRIC site would replace [AttachmentLinks] with the
    actual links to the email attachments as well as replacing other placeholders
    in the template. The attachments themselves are listed as fields in the CSV.
  prefs: []
  type: TYPE_NORMAL
- en: 'This email contained one attachment, as noted in the Attachment1 field of the
    most recent row in *EmailBuilder.csv*: the PDF file *EBAT1\Events_060620_1800.pdf*.
    [Figure 9-6](#fig9-6) shows the first page of that document.'
  prefs: []
  type: TYPE_NORMAL
- en: The NCRIC Terrorism Liaison Officer program distributed this list to local police
    across Northern California. The events included Novato Peaceful Car Caravan, Taking
    a Knee for Change, and the Noe Valley Police Violence Protest with Social Distancing
    (the protests took place during the COVID-19 pandemic, after all).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a NCRIC document showing details about upcoming Black Lives
    Matter protests in Northern California.](Images/Figure9-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: A list of upcoming
    Black Lives Matter protests in the file</samp> <samp class="SANS_Futura_Std_Book_11">Events_060620_1800.pdf</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the SentEmailList and EmailTable values to discover how many, and
    exactly which, local police officers received these daily bulletins. The value
    of SentEmailList is the path to a CSV file itself: *EBSE00006\170.csv*. When you
    open that CSV file (it’s in *ncric/files*), you can see that it has 14,459 rows
    (one of which is the header) and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In short, this CSV contains a huge list of ID numbers. The value of EmailTable
    in the *EmailBuilder.csv* row is <samp class="SANS_TheSansMonoCd_W5Regular_11">Registrations</samp>,
    which is a good hint. Since I knew that these IDs must match up to rows in some
    other table, I decided to check the file *Registrations.csv*.
  prefs: []
  type: TYPE_NORMAL
- en: Open that spreadsheet yourself at *ncric/Registrations.csv*. It has 185 columns
    and over 29,000 rows, apparently listing everyone who had an account on NCRIC’s
    website. It includes each user’s full name; the agency they work for and whether
    it’s local, state, federal, or military; their email address, physical address,
    and cell phone number; their supervisor’s name and contact information; their
    password hash; and other details.
  prefs: []
  type: TYPE_NORMAL
- en: The first column of *Registrations.csv* is called RegistrationsID. Each ID in
    the *EBSE00006\170.csv* file can be cross-referenced with one of these registrations.
    For example, the person in *Registrations.csv* with the RegistrationsID 63861
    works at the Santa Clara County Sheriff’s Office, lives in San Jose, has an email
    address at the domain pro.sccgov.org, and has a phone number with a 408 area code.
    In other words, NCRIC sent the email to this list of 14,458 contacts, whose contact
    details can be found in the *Registrations.csv* file. The BlueLeaks dataset includes
    this information about everyone who received bulk email through any of the websites.
    In Exercise 9-3, when you read through bulk email found in BlueLeaks, you’ll be
    able to look up exactly who received these email messages.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">“Intelligence” Memos
    from the FBI and DHS</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, in addition to detailed lists of upcoming protests, NCRIC
    also frequently forwarded memos from its federal partners—agencies like the FBI
    and DHS—to its list of over 14,000 local cops. These memos largely contained internet
    rumors, hoaxes that had already been debunked but that federal agencies apparently
    fell for, and warnings about violence from protesters that didn’t materialize.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the row in *EmailBuilder.csv* with the EmailBuilderID of 6169,
    the email body says, “The NCRIC is disseminating this (U//LES) Update on behalf
    of the FBI.” The Attachment1 value in that row is *EBAT1\SITREP-6-JUN-1300_OPE.pdf*,
    an unclassified FBI document dated June 6, 2020\. The document is full of cherry-picked
    quotes from social media posts threatening violence, but without any context.
    There was no way of knowing how many followers an account had, how much engagement
    their post had, or even if they were parodies.
  prefs: []
  type: TYPE_NORMAL
- en: The “Social Media Exploitation (SOMEX)” section of this FBI document describes
    people using Facebook, Snapchat, and Instagram to post “flyers seeking to hire
    ‘professional anarchists.’ ” This appears to reference an internet hoax from late
    May 2020\. In fact, I found multiple articles debunking this hoax on fact-checking
    sites, including Snopes, PolitiFact, and *Reuters*, dated a week before the FBI
    distributed this memo. The fake recruitment flyer offers to compensate “professional
    anarchists” with $200 per direct action, and includes the text “Funded by George
    Soros.” (Antisemitic right-wing Americans frequently and falsely claim that Soros,
    a Jewish billionaire, funds left-wing protesters.) The flyer also included the
    phone number for a local branch of the Democratic Party. Both this local Democratic
    Party branch and Soros’s Open Society Foundations confirmed that the flyer was
    a fake, but this didn’t stop the FBI from distributing it to NCRIC, which disseminated
    it to 14,458 local police across Northern California.
  prefs: []
  type: TYPE_NORMAL
- en: The DHS also sent several memos to NCRIC to distribute to the center’s list.
    For example, take a look at the row in *EmailBuilder.csv* with the EmailBuilderID
    of 6144\. The email body says, “The NCRIC is disseminating the Intelligence Note
    ‘(U//FOUO) Some Violent Opportunists Probably Engaging in Organized Activities’
    on behalf of DHS,” and the attached document is *EBAT1\(U—FOUO) IN - Some Violent
    Opportunists Probably Engaging in Organized Activities 06012020.pdf*.
  prefs: []
  type: TYPE_NORMAL
- en: The attached PDF declares, “As the protests persist, we assess that the organized
    violent opportunists—including suspected anarchist extremists—could increasingly
    perpetrate nationwide targeting of law enforcement and critical infrastructure.”
    (This didn’t happen.) The memo goes on to say that an NYPD official “had strong
    evidence that suspected anarchist groups had planned to incite violence at protests,
    including by using encrypted communications.” Incidentally, if you completed Exercise
    2-2 and installed Signal, you too are now a user of encrypted communications.
  prefs: []
  type: TYPE_NORMAL
- en: As noted in [Chapter 1](chapter1.xhtml), it’s important to reach out to the
    people you’re investigating to get their side of the story. Mike Sena, NCRIC’s
    executive director, told me that his intelligence agency was monitoring Black
    Lives Matters protests in order to make sure that they remained safe. “We weren’t
    keeping track of the protests themselves, but we were identifying where we were
    gonna have gatherings of people,” he said. “That’s our concern; we want to make
    sure the events are safe—and if there are any threats that come up that may be
    associated with any of those events that we’re able to get that threat data to
    whatever agency may have protection responsibilities.”
  prefs: []
  type: TYPE_NORMAL
- en: It’s also good practice to contact outside experts—those who know more about
    the subject matter than you do—for comment. Vasudha Talla, a senior staff attorney
    with the American Civil Liberties Union of Northern California, told me, “Really
    what we have here is overbroad collection and dissemination of people’s protected
    First Amendment activity, and it’s untethered to any basis in the law.”
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are a lot of newsworthy details in *EmailBuilder.csv*.
    However, it’s still somewhat difficult to work with, especially because of the
    HTML email bodies. Soon you’ll write some code to make all of the bulk email easier
    to read. To do that, first you will need to learn the basics of HTML.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">A Brief HTML Primer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following exercise, you’ll write some Python code that in turn writes
    some HTML code. This section covers just enough HTML syntax to get you through
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML is made up of components called *tags*. For example, consider the following
    HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code opens a <samp class="SANS_TheSansMonoCd_W5Regular_11"><p></samp> tag
    (which represents a paragraph), includes some content (the text <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello
    world</samp>), and then closes the <samp class="SANS_TheSansMonoCd_W5Regular_11"><p></samp>
    tag with <samp class="SANS_TheSansMonoCd_W5Regular_11"></p></samp>. You open a
    tag with <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tag-name</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp> and close it with <samp class="SANS_TheSansMonoCd_W5Regular_11"></</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">tag-name</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML typically includes tags inside of tags inside of tags. It’s common to
    indent HTML code for legibility, but unlike in Python, indenting is completely
    optional. Here’s an example of a simple web page in HTML, indented to make it
    easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The whole page is wrapped in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><html></samp>
    tag. Inside that, there’s a <samp class="SANS_TheSansMonoCd_W5Regular_11"><head></samp>
    tag, which includes metadata about the web page, and then a <samp class="SANS_TheSansMonoCd_W5Regular_11"><body></samp>
    tag, which includes the content of the web page. The <samp class="SANS_TheSansMonoCd_W5Regular_11"><title></samp>
    tag is a metadata tag that describes the title of the web page, which is what’s
    displayed in the browser tab itself. Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11"><body></samp>,
    the biggest heading is <samp class="SANS_TheSansMonoCd_W5Regular_11"><h1></samp>,
    followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11"><p></samp> paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are plenty of other tags in HTML, but in the following exercise, you’ll
    use just two more: <samp class="SANS_TheSansMonoCd_W5Regular_11"><ul></samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><li></samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11"><ul></samp>
    tag stands for “unordered list,” and it’s how you make bulleted lists in HTML.
    Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11"><ul></samp> tag are <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><li></samp> tags, which stand for “list
    item.” For example, here’s some HTML for a simple bulleted list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When displayed in a web browser, that HTML code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The less-than and greater-than characters (<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>) are used to open and
    close tags in HTML. If you want to display literal less-than or greater-than characters
    in HTML, you have to *HTML escape* them. This is similar to escaping in shell
    scripts and Python code, but the syntax is different. Escape <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    by replacing it with <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp>
    and escape <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> by replacing
    it with <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>. For example,
    here’s some HTML code that displays the text <samp class="SANS_TheSansMonoCd_W5Regular_11">I</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><3 you</samp> in a paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are a few other special characters in HTML that are each escaped in their
    own way. For example, you’d use <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>
    to escape an ampersand (<samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you’ll make the email messages in *EmailBuilder.csv* easier
    to read by writing a script that automatically saves an HTML file for each one.
    This will also make it much simpler for you to find the newsworthy ones.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 9-2: Make Bulk Email Readable</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this exercise, you’ll write a script similar to the one you wrote in Exercise
    9-1, but instead of displaying text output to the screen, you’ll save HTML output
    to files. This allows you to look through a folder full of HTML files, each one
    a different bulk email, open these files in a web browser, and read them in a
    more legible format. While this particular exercise is designed specifically for
    the *EmailBuilder.csv* files in BlueLeaks, it’s common to find HTML in datasets,
    so being able to write a similar script could help you in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a challenge, you can try programming your own script to meet the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Make this script accept two arguments called <samp class="SANS_TheSansMonoCd_W5Regular_11">emailbuilder_csv_path</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder_path</samp> using
    Click. The <samp class="SANS_TheSansMonoCd_W5Regular_11">emailbuilder_csv_path</samp>
    argument should be the path to an *EmailBuilder.csv* file, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder_path</samp>
    argument should be the path to a folder in which to save the HTML files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the folder at <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder_path</samp>
    exists by importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module and running <samp class="SANS_TheSansMonoCd_W5Regular_11">os.makedirs(output_folder_path,
    exist_ok=True)</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp> module and
    loop through all of the rows in the CSV located at <samp class="SANS_TheSansMonoCd_W5Regular_11">emailbuilder_csv_path</samp>,
    loading each row as a dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each row, save a new HTML file. This file should include information from
    the bulk-email fields most relevant for your purposes: EmailBuilderID, EmailFrom,
    EmailSubject, DateSent, Attachment1, and SentEmailList. It should also include
    the HTML body of the email itself, EmailBody.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, follow along with the rest of this exercise and I’ll walk you through
    the programming process. Start with the usual Python script template in a file
    called *exercise-9-2.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll modify your script to make the script accept command line arguments
    using Click.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accept the Command
    Line Arguments</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code has been modified to import the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module and accept some command line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, the code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp>
    module, and then it uses Click decorators to make the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function a Click command that accepts two arguments, <samp class="SANS_TheSansMonoCd_W5Regular_11">emailbuilder_csv_path</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder_path</samp>. The
    code also has two <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp>
    statements that display the values of the two arguments. The <samp class="SANS_TheSansMonoCd_W5Regular_11">emailbuilder_csv_path</samp>
    argument should point to the path of a BlueLeaks *EmailBuilder.csv*, which you’ll
    load and loop through, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder
    _path</samp> argument should be the path to a folder in which you’ll store the
    HTML files for the bulk-email messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test your code and make sure it’s working as expected so far, replacing the
    path to *EmailBuilder.csv* with the appropriate path for your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the script displays the values of the two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create the Output
    Folder</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, use Python to create the folder in <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder_path</samp>
    where you’ll save the HTML files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To be able to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.makedirs()</samp>
    function, first the script imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module. Then it uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.makedirs()</samp>
    function to create a new folder in Python, passing in the path to the folder to
    create, <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder_path</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">exists_ok=True</samp> keyword
    argument tells this function that it’s fine if that folder already exists; otherwise,
    if the folder already existed, the script would crash with an error message. This
    way, the first time you run this script with a specific output folder, it will
    create that folder and use it to store the HTML files. If you run the script again
    in the future with that same output folder, it will use the folder that’s already
    there.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the complete script at the end of this exercise, you’ll be able
    to browse the files in this folder to read through the bulk-email messages sent
    by a fusion center.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Define the Filename
    for Each Row</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The goal of this script is to save an HTML file for each row in the spreadsheet.
    To do this, you’ll need to load the CSV, loop through its rows, and figure out
    the filename for each HTML file that you’re going to save. Next, define the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> variable, naming each
    HTML file based on data that you found in that row. To do so, make the following
    modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The script starts by importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    module. As in the previous exercise, the code then opens the CSV file and creates
    a CSV reader using <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictReader()</samp>.
    Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the code
    loops through each row in the CSV.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than just displaying information, you ultimately want to save each row
    as an HTML file. To prepare to write the code that actually generates those files
    in the next section, this code defines a <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    variable with the name of the unique HTML file to be generated for each row. In
    order to make it unique, the code defines <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    using the current row’s EmailBuilderID, DateSent, and EmailSubject fields, and
    ends it with the.<samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp> file
    extension. For example, according to this format, the filename for the bulk email
    described in the previous section would be *6170_06/06/20 20:25:06_NCRIC TLO Bulletin
    LES.html*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code defines <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    as an f-string surrounded in double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>).
    The variables inside it, like <samp class="SANS_TheSansMonoCd_W5Regular_11">row["EmailSubject"]</samp>,
    have quotes of their own, but you can’t use the double-quote character inside
    a double-quoted f-string without Python mistakenly thinking you’re closing the
    f-string. Instead, this code uses single quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">''</samp>)
    for the variables within the f-string: <samp class="SANS_TheSansMonoCd_W5Regular_11">row[''EmailSubject'']</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The slash characters (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>)
    contained in the DateSent column are invalid characters for filenames because
    slashes separate folders in a path. To address this, the line <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">filename.replace("/",
    "-")</samp> replaces any slashes it finds in the filename with dash characters
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>). This generates the valid
    filename *6170_06-06-20 20:25:06_NCRIC TLO Bulletin LES.html*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp>,
    discussed in [Chapter 8](chapter8.xhtml), to append <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    to the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder_path</samp>,
    giving you the complete path to the file you’re going to write. You’ll ultimately
    save the HTML file in this path. For example, if the filename <samp class="SANS_TheSansMonoCd_W5Regular_11">output_folder_path</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">output</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">6170_06-06-20 20:25:06_NCRIC
    TLO Bulletin LES.html</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp>
    updates <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> to be <samp
    class="SANS_TheSansMonoCd_W5Regular_11">output/6170_06-06-20 20:25:06_NCRIC TLO
    Bulletin LES.html</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure everything is working so far, the code displays this final filename.
    Pause and test your code, using the correct filepath for your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The output should show a unique filename for each row in the *EmailBuilder.csv*
    spreadsheet. All you need to do now is actually write those HTML files.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Write the HTML Version
    of Each Bulk Email</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The purpose of saving each row of *EmailBuilder.csv* as an HTML file is to
    more easily read these bulk-email messages by loading the HTML in a web browser.
    You’ll obviously want to see the email body, but it would also be helpful to display
    some basic metadata about the email: the date it was sent, the subject, and so
    on. The following code writes the HTML files, automatically filling in both the
    metadata and the email body with data from the CSV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, the code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">html</samp>
    module, which will be used later on to escape HTML code. The code starts by defining
    a list, called <samp class="SANS_TheSansMonoCd_W5Regular_11">important_keys</samp>,
    of all of the important keys to include in the final HTML file. This code is positioned
    near the top of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>
    function, before the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, so that this variable will be available inside each loop, and therefore
    every HTML file will include these same fields.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the
    code stores each row of the spreadsheet in the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">row</samp>,
    so you can access its fields using keys. Then, the code opens the HTML file for
    writing with the command <samp class="SANS_TheSansMonoCd_W5Regular_11">with open(filename,
    "w") as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">html_f:</samp> (as
    you saw in “Reading and Writing Files” in [Chapter 8](chapter8.xhtml)). The file
    object for the HTML file is the <samp class="SANS_TheSansMonoCd_W5Regular_11">html_f</samp>
    variable. Inside this <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    statement, the code then starts writing the HTML file by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">html_f.write()</samp>
    and passing in a string containing HTML, first for <samp class="SANS_TheSansMonoCd_W5Regular_11"><html></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><body></samp> tags and then
    for a <samp class="SANS_TheSansMonoCd_W5Regular_11"><ul></samp> tag to represent
    a bulleted list.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code fills in the bulleted list with the important metadata. Using
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, it loops through
    the keys in <samp class="SANS_TheSansMonoCd_W5Regular_11">important_keys</samp>,
    writing each piece of metadata to the HTML file in its own <samp class="SANS_TheSansMonoCd_W5Regular_11"><li</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp> tag, in the format
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">metadata_item</samp>
    is the name of an important piece of metadata in <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">metadata_value</samp>
    is the value of that piece of metadata in <samp class="SANS_TheSansMonoCd_W5Regular_11">row[key]</samp>.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">metadata_item</samp>
    might be <samp class="SANS_TheSansMonoCd_W5Regular_11">EmailBuilderID</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">metadata_value</samp>
    might be <samp class="SANS_TheSansMonoCd_W5Regular_11">6170</samp>, as in the
    example CSV row in the “Lists of Black Lives Matter Demonstrations” section.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of displaying the value with <samp class="SANS_TheSansMonoCd_W5Regular_11">row[key]</samp>,
    though, this line of code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">html.escape(row[key])</samp>.
    This is necessary because some of the fields you want to include use angle brackets
    (<samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>),
    which indicate tags in HTML. For example, if the value of the FromEmail field
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">NCRIC</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><info@ncric.net></samp>,
    your web browser will interpret <samp class="SANS_TheSansMonoCd_W5Regular_11"><info@ncric.net></samp>
    as an HTML tag called <samp class="SANS_TheSansMonoCd_W5Regular_11">info@ncric.net</samp>,
    which isn’t a real tag, so nothing will display. In Python, the <samp class="SANS_TheSansMonoCd_W5Regular_11">html.escape()</samp>
    function lets you HTML escape a string. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">html.escape("NCRIC</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><info@ncric.net>")</samp> returns
    the string <samp class="SANS_TheSansMonoCd_W5Regular_11">NCRIC &lt;info@ncric.net&gt;</samp>
    and that’s what gets saved to the HTML file, so that when you later view that
    file, the string displays correctly as <samp class="SANS_TheSansMonoCd_W5Regular_11">NCRIC</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><info@ncric.net></samp>.
  prefs: []
  type: TYPE_NORMAL
- en: When the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop finishes
    running, all of the important metadata will have been written to the HTML file.
    The code then writes <samp class="SANS_TheSansMonoCd_W5Regular_11"></ul></samp>
    to close the bulleted list tag. After displaying the bulleted list of important
    fields, the code displays the EmailBody field in a <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">div></samp> tag. This time, it doesn’t
    HTML escape this field, because you want to load the email’s HTML in a browser.
    Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11"><body></samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><html></samp> tags are closed with <samp
    class="SANS_TheSansMonoCd_W5Regular_11"></body></html></samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete script at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-9<wbr>/exercise<wbr>-9<wbr>-2<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-9/exercise-9-2.py).
    This is the most complicated Python script you’ve written so far in this book,
    but it’s about to pay off. Run it on the NCRIC data, using the filepath appropriate
    for your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This output looks similar to the last time you ran the script, except now it
    also creates a folder full of 5,213 new HTML files—one for every row of NCRIC’s
    *EmailBuilder.csv* file—in the output folder you specified. The information now
    included in the filenames allows you to browse through the files in your file
    manager, exploring those that look most interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-7](#fig9-7) shows the list of files generated when I ran this script.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a graphical file manager showing the folder full of HTML
    files that we just generated.](Images/Figure9-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: Viewing the HTML
    files generated by the Python script in macOS Finder</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This folder contains the thousands of HTML files that your Python script just
    created. The first part of the filename is the EmailBuilderID, followed by DateSent,
    followed by EmailSubject. To read one of these bulk emails, just double-click
    the HTML file to open it in a web browser. If you want more information about
    a specific bulk email, you can always look it up by EmailBuilderID in the original
    spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what the final HTML output looks like, open one of these files in your
    text editor. For example, here’s the final HTML output from the *6098_05-18-20
    12/45/12_Chasing Cell Phones presented via Zoom Webinar.html* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All of the bolded parts have been filled in automatically by the Python code.
    In the bulleted list at the top, <samp class="SANS_TheSansMonoCd_W5Regular_11">EmailBuilderID</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EmailFrom</samp>, and so on are
    keys from the <samp class="SANS_TheSansMonoCd_W5Regular_11">important_keys</samp>
    list, and <samp class="SANS_TheSansMonoCd_W5Regular_11">6098</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">NCRIC
    &lt;info@ncric.net&gt</samp>, and so on are HTML-escaped values from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">row</samp> dictionary. Below the bulleted
    list, inside the <samp class="SANS_TheSansMonoCd_W5Regular_11"><div></samp> tag,
    is the email body—the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">row["EmailBody"]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-8](#fig9-8) shows what these bulk email messages look like in a web
    browser. In this case, I opened a bulk email sent out on May 18, 2020, advertising
    a course called Chasing Cell Phones hosted by the Northern California High Intensity
    Drug Tracking Area. The class was designed to teach police how to get valuable
    evidence directly off of suspects’ cell phones or from third-party sources like
    cell phone providers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot for a course called “Chasing Cell Phones,” to be held on Zoom
    on June 4, 2020\. The description starts with: “This class will explore the methods
    of exploiting a suspect’s cellular phone, phone company records, and third-party
    data sources records to assist investigations . . .”](Images/Figure9-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-8: Viewing a NCRIC
    bulk email in a web browser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the script from this exercise to make the bulk email from any BlueLeaks
    folder more readable; just run the script on the appropriate *EmailBuilder.csv*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The BlueLeaks folder names alone don’t immediately make clear which folders
    belong to which organizations. Let’s fix that by creating a spreadsheet that associates
    each BlueLeaks folder with its organization name, website title, and URL.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Discovering the Names and URLs of BlueLeaks
    Sites</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s obvious what organization some BlueLeaks folders belong to based on the
    folder name. You can reasonably guess that the *alabamafusioncenter* folder has
    data from the Alabama Fusion Center. But most aren’t so clear. Can you guess what
    *ciacco* is? How about *nvhidta* or *snorca*?
  prefs: []
  type: TYPE_NORMAL
- en: After manually looking through the CSV files in various BlueLeaks folders, I
    discovered that the file *Company.csv* contains, hidden among its 108 columns,
    the name and URL of each site. Some BlueLeaks folders, it turns out, host more
    than one site. For example, in [Table 9-3](#tab9-3), which shows these columns
    from NCRIC’s *Company.csv* file, you can see that the *ncric* folder hosts 18
    different sites at different URLs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 9-3:</samp> <samp class="SANS_Futura_Std_Book_11">Data
    from</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ncric/Company.csv</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">CompanyID</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">CompanyName</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">WebsiteTitle</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">URL</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">1</samp> | <samp class="SANS_Futura_Std_Book_11">NCRIC.net</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">ncric.net</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">2</samp> | <samp class="SANS_Futura_Std_Book_11">NCRIC
    New</samp> | <samp class="SANS_Futura_Std_Book_11">Northern California Regional
    Intelligence Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">upinsmoke.ncric.net</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">3</samp> | <samp class="SANS_Futura_Std_Book_11">NCRIC</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">ncric.org</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">4</samp> | <samp class="SANS_Futura_Std_Book_11">NCHIDTA</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">nchidta.org</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">7</samp> | <samp class="SANS_Futura_Std_Book_11">NCHIDTA.net</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">nchidta.net</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">8</samp> | <samp class="SANS_Futura_Std_Book_11">NCRTTAC.org</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">ncrttac.org</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">10</samp> | <samp class="SANS_Futura_Std_Book_11">NCRTTAC.org</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">www.ncrttac.org</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">11</samp> | <samp class="SANS_Futura_Std_Book_11">Northern
    California Most Wanted</samp> | <samp class="SANS_Futura_Std_Book_11">Northern
    California Most Wanted - Serving The Bay Area and Surrounding Counties</samp>
    | <samp class="SANS_Futura_Std_Book_11">northerncaliforniamostwanted.org</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">12</samp> | <samp class="SANS_Futura_Std_Book_11">Northern
    California Most Wanted</samp> | <samp class="SANS_Futura_Std_Book_11">Northern
    California Most Wanted</samp> | <samp class="SANS_Futura_Std_Book_11">northerncaliforniamostwanted.com</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">14</samp> | <samp class="SANS_Futura_Std_Book_11">Northern
    California Most Wanted</samp> | <samp class="SANS_Futura_Std_Book_11">Northern
    California Most Wanted</samp> | <samp class="SANS_Futura_Std_Book_11">ncmostwanted.org</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">15</samp> | <samp class="SANS_Futura_Std_Book_11">NCRIC
    Private Sector Mobile Registration</samp> | <samp class="SANS_Futura_Std_Book_11">Northern
    California Regional Intelligence Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">psp.ncric.net</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">16</samp> | <samp class="SANS_Futura_Std_Book_11">NCHIDTA.com</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">nchidta.com</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">17</samp> | <samp class="SANS_Futura_Std_Book_11">NCRIC</samp>
    | <samp class="SANS_Futura_Std_Book_11">NCRIC Mobile</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">19</samp> | <samp class="SANS_Futura_Std_Book_11">NCRIC</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">passwordreset.ncric.ca.gov</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">20</samp> | <samp class="SANS_Futura_Std_Book_11">NCHIDTA</samp>
    | <samp class="SANS_Futura_Std_Book_11">NCHIDTA Mobile</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">21</samp> | <samp class="SANS_Futura_Std_Book_11">NCHIDTA
    (New)</samp> | <samp class="SANS_Futura_Std_Book_11">Northern California Regional
    Intelligence Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">new.nchidta.org</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">22</samp> | <samp class="SANS_Futura_Std_Book_11">NCRIC</samp>
    | <samp class="SANS_Futura_Std_Book_11">Northern California Regional Intelligence
    Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">ncric.ca.gov</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">23</samp> | <samp class="SANS_Futura_Std_Book_11">NCRIC
    NEW</samp> | <samp class="SANS_Futura_Std_Book_11">Northern California Regional
    Intelligence Center - NCRIC</samp> | <samp class="SANS_Futura_Std_Book_11">new.ncric.ca.gov</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: As you can see here, the *ncric* folder hosts not only the NCRIC site but also
    the sites for the Northern California High Intensity Drug Trafficking Area (NCHIDTA);
    the Northern California Most Wanted, which lists wanted fugitives; and others.
    However, all these websites share the same code and databases.
  prefs: []
  type: TYPE_NORMAL
- en: Since almost every BlueLeaks folder contains a *Company.csv* file listing all
    of the sites associated with that folder, we can write a script to automatically
    extract this information and format it as a CSV file. This will open the door
    for you to pick which fusion center you want to research—perhaps there’s one in
    a city near you.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 9-3: Make a CSV of BlueLeaks
    Sites</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The script you write in this exercise will loop through each BlueLeaks folder,
    open its *Company.csv* file, and save information about the organizations whose
    websites are hosted in that folder into a CSV file that you create. For a challenge,
    you can try programming your own script to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept two arguments: <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>,
    the path to your extracted BlueLeaks data, and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_csv_path</samp>,
    the path to the new CSV file that the script will create.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Include these headers: <samp class="SANS_TheSansMonoCd_W5Regular_11">BlueLeaksFolder</samp>
    (the BlueLeaks folder name), <samp class="SANS_TheSansMonoCd_W5Regular_11">CompanyID</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CompanyName</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">WebsiteTitle</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">URL</samp> (you’ll find these
    latter fields in the various *Company.csv* files).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open <samp class="SANS_TheSansMonoCd_W5Regular_11">output_csv_path</samp> for
    writing and create a <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictWriter()</samp>
    object (see “Reading and Writing CSV Files in Python” on page 248), passing in
    the file object and the headers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop through each folder in BlueLeaks. You can get a list of all the filenames
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir(blueleaks_path)</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside each BlueLeaks folder, open the *Company.csv* file if it exists, and
    loop through all of the rows in that CSV. For each row, select the information
    you want to save and then write it to your CSV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map out exactly what websites each BlueLeaks folder hosts in your output CSV.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, the rest of this exercise will walk you through the programming
    process. Start with the usual Python script template in a file called *exercise-9-3.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify your script to accept the <samp class="SANS_TheSansMonoCd_W5Regular_11">blueleaks_path</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">output_csv_path</samp> command
    line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You’ve done this enough times at this point that you can safely assume the arguments
    are working properly without testing the script.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Open a CSV for Writing</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simplest way to program this script is to first open a CSV file for writing
    and then loop through each folder in BlueLeaks, adding rows to this CSV. Start
    by just opening the CSV file for writing, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First, the code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">csv</samp>
    module. It then defines what the headers of the output CSV will be in the variable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">headers</samp>. As noted in “Reading
    and Writing CSV Files in Python,” in order to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">csv.DictWriter()</samp>
    object, you’ll need to pass in this list of headers for your CSV file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the code opens the output CSV file for writing, this time calling it <samp
    class="SANS_TheSansMonoCd_W5Regular_11">output_f</samp>, and creates the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">csv.DictWriter()</samp> object, saving
    it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">writer</samp> variable.
    Finally, the program writes the header row to the CSV. To write the remaining
    rows, you’ll need to run <samp class="SANS_TheSansMonoCd_W5Regular_11">writer.writerow()</samp>,
    passing in a dictionary that represents the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running the script so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The script itself shouldn’t display any output; it should just create an output
    CSV file, *sites.csv*. Try displaying its contents using <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You should see that the file currently contains only header rows.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Find All the Company.csv
    Files</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you can write rows to your CSV, the next step is to loop through the
    BlueLeaks sites, looking for *Company.csv* files, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp>
    module. After creating the CSV writer, it loops through the return value of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp> function, which
    returns a list of all the files inside the BlueLeaks folder. It then defines a
    new <samp class="SANS_TheSansMonoCd_W5Regular_11">company_csv _path</samp> variable
    as the path to the *Company.csv* file inside that BlueLeaks folder. Finally, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.exists()</samp> function
    makes sure that this specific *Company.csv* file actually exists, and if so, the
    code displays its path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running the code so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script displays paths for all of the *Company.csv* files
    in BlueLeaks. (Yours might display them in a different order than mine.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Add BlueLeaks Sites
    to the CSV</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The final step is to open all the *Company.csv* files whose paths you’ve just
    listed, loop through their rows, and add new rows to your output CSV file based
    on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The added code opens the <samp class="SANS_TheSansMonoCd_W5Regular_11">company_csv_path</samp>,
    this time for reading instead of writing, and now calling the file object <samp
    class="SANS_TheSansMonoCd_W5Regular_11">input_f</samp>. It then creates a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">csv.DictReader()</samp> object to read
    the data from this CSV and loops through its rows.
  prefs: []
  type: TYPE_NORMAL
- en: For each row, the code creates a new dictionary called <samp class="SANS_TheSansMonoCd_W5Regular_11">output_row</samp>
    that contains the name of the BlueLeaks folder you’re currently working in, as
    well as CompanyID, CompanyName, WebsiteTitle, and URL from *Company.csv*. It then
    uses the CSV writer you created in the previous section to save that row to your
    output CSV file. When the code finishes looping through all of the rows in a *Company.csv*
    file, it displays a message to show it’s done with that folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete script at [*https://<wbr>github<wbr>.com<wbr>/micahflee<wbr>/hacks<wbr>-leaks<wbr>-and<wbr>-revelations<wbr>/blob<wbr>/main<wbr>/chapter<wbr>-9<wbr>/exercise<wbr>-9<wbr>-3<wbr>.py*](https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-9/exercise-9-3.py).
    Run your final script like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When you run this script, the output displays a line for each BlueLeaks folder
    showing that it has finished running. But more importantly, it creates the file
    *sites.csv*. [Figure 9-9](#fig9-9) shows what that file looks like in LibreOffice
    Calc.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of sites.csv in LibreOffice Calc. You can see the names, website
    titles, and URLs for the sites hosted in each BlueLeaks folder.](Images/Figure9-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-9: The CSV output
    created by the final Exercise 9-3 script</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created the CSV, you can use your graphical spreadsheet software
    to freeze the header row at the top and sort the columns however you’d like. If
    you live in the US, try finding the fusion center that covers your region; that
    might be a good place to start digging. You can use the skills you’ve learned
    in this chapter and the Python scripts you’ve written to make the files for your
    chosen fusion center easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Before you get too deep into your BlueLeaks investigations, though, I recommend
    reading [Chapter 10](chapter10.xhtml), where I’ll introduce you to software that
    might save you time and allow you to uncover more interesting revelations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started investigating CSV spreadsheets. You’ve learned
    how to open and examine them using spreadsheet software, as well as how to read
    and write them using Python code, sharpening your programming skills along the
    way. You’ve also learned more about the BlueLeaks dataset structure and how to
    find hidden details, such as who posted which SARs and what documents were sent
    out as part of which bulk email messages, in the spreadsheets.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve explored just a few CSVs in BlueLeaks so far, including *SARs.csv* and
    *EmailBuilder.csv* in NCRIC and *Company.csv* in all of the folders, but there’s
    still much more to investigate. In the next chapter, you’ll learn how to research
    the BlueLeaks dataset in depth using my custom-built software, BlueLeaks Explorer.
  prefs: []
  type: TYPE_NORMAL
