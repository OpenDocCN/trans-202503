- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 15 IMPLEMENTING A SHOPPING CART
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When browsing an online store, you expect to add items to a shopping cart and
    for them to be remembered until you’re ready to check out and pay. This is an
    extremely common requirement, so in this chapter we’ll focus on building an application
    with a shopping cart. In the process, you’ll learn how to work with sessions in
    a more sophisticated way, storing and updating whole arrays within the $_SESSION
    superglobal. We’ll also continue our efforts to encapsulate the core logic for
    user actions into separate functions coordinated by a front-controller script,
    yielding a well-organized, easy-to-maintain application structure.
  prefs: []
  type: TYPE_NORMAL
- en: A *shopping cart* is basically a way to record which products and what quantities
    a user has selected. Our website therefore needs to show a list of products as
    well as enable the user to add items to their shopping cart and view its contents.
    We should also offer a way to edit the shopping cart, allowing the user to change
    quantities, remove items, or empty the cart altogether. As an example, [Figure
    15-1](#fig15-1) shows an Amazon shopping cart with a few items.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure15-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-1: An e-commerce shopping cart'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the cart displays the cost of the individual items as well as a
    total cost of the entire order. The Amazon shopping cart page also offers ways
    to change the quantity of each item and to delete items from the cart. We’ll emulate
    all these features in our own shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: The Shopping Cart File Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our shopping cart web application will span several files, including an *index.php*
    front-controller script, a *functions.php* file declaring various useful functions,
    a collection of template scripts, and other supporting files. The complete structure
    for the project will ultimately be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For now, start a new PHP project, create the necessary folders, and copy the
    image files (*banana.png*, *pineapple.png*, and so on) from the book’s provided
    resource files into the *public/images* folder. With that, we’re ready to start
    building the application. The book resource files and exercise solutions can be
    found at *[https://github.com/dr-matt-smith/php-crash-course](https://github.com/dr-matt-smith/php-crash-course)*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Product List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we create the shopping cart itself, we’ll begin by building a list of
    products for the user to choose from. We’ll use an array to store the products
    available in our online shop. (Normally, product information would be stored in
    a database instead, but we won’t be covering these until [Part VI](part6.xhtml).)
    In addition to the product array, we’ll use a second array stored in the session
    to keep track of the contents of each user’s shopping cart. You learned to loop
    through an array of products to automatically generate links featuring the product
    IDs in [Chapter 11](chapter11.xhtml) (see Listing 11-11 on [page 214](chapter11.xhtml#pg_214)).
    We’ll do something similar here.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-2](#fig15-2) shows the product list page we’ll create. As usual,
    we can use a little Bootstrap to help produce a professional-looking page with
    minimal CSS.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure15-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-2: A page showing the list of products'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll have five products on our site. [Table 15-1](#tab15-1) lists the data
    values we need to store for each product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 15-1: Product Details'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Value of attribute per product |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ID | 010 | 025 | 005 | 021 | 002 |'
  prefs: []
  type: TYPE_TB
- en: '| Name | Sandwich | Slice of cheesecake | Pineapple | Jelly donut | Banana
    |'
  prefs: []
  type: TYPE_TB
- en: '| Description | A filling, savory snack of peanut butter and jelly. | Treat
    yourself to a chocolate-covered cheesecake slice. | A piece of exotic fruit. |
    The best type of donut — filled with sweet jam. | The basis for a good smoothie
    and high in potassium. |'
  prefs: []
  type: TYPE_TB
- en: '| Price | 1.00 | 2.00 | 3.00 | 2.50 | 0.50 |'
  prefs: []
  type: TYPE_TB
- en: '| Stars | 4 | 5 | 2 | 3 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| Image | peanut _butter.png | chocolate_cheese _cake.png | pineapple.png |
    jellydonut.png | banana.png |'
  prefs: []
  type: TYPE_TB
- en: Notice that each product has a unique ID, name, description, price, star rating
    (from 1 to 5), and associated image filename. To implement all of this, we’ll
    create a $products array that contains an element for each product, using the
    product IDs as keys. Each product in the array is itself an array with keys for
    each attribute, such as 'name', 'description', 'price', and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Products Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Listing 15-1 shows how to declare each product array element to store its data
    values, creating elements for the first two products. Enter this code into *public/index.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-1: Declaring the first two products in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new, empty array called $products. Then we use $products['010']
    to append a new element to the end of $products, indexed with the key '010'. This
    new element is set to an array containing the properties for the peanut butter
    and jelly sandwich. We then append another element to $products with the key '025',
    containing an array with the properties for the cheesecake slice.
  prefs: []
  type: TYPE_NORMAL
- en: Using these first two products as a model, add the code declaring array elements
    for the remaining three products from [Table 15-1](#tab15-1). Be sure to use strings
    containing the products’ IDs as array keys.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CSS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll need a little CSS to style the product list page, so create the *public/css/products.css*
    file containing the contents of [Listing 15-2](#lis15-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-2: The CSS to style the product list in css/products.css'
  prefs: []
  type: TYPE_NORMAL
- en: We first style the stars that represent the product’s ratings. We use Bootstrap
    Glyphicon stars. Filled stars will be gold ❶, and disabled stars will be gray
    ❷. Then we set the product images to fill (100%) the available horizontal spaces
    (for dynamically flexed blocks) ❸. I’ve used an image editor to make all images
    the same size for a consistent, professional look and feel. We also set the prices
    to be larger than normal text (1.5) and bold ❹. This will apply to prices both
    on the product list page and in the shopping cart itself.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Star Ratings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll write a PHP function that will return a string containing the HTML
    and CSS classes for a given number of stars. Create and complete the PHP script
    *src/functions.php*, based on the contents of [Listing 15-3](#lis15-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-3: A function to output gold and gray stars'
  prefs: []
  type: TYPE_NORMAL
- en: To keep our code simple, we’ve created a reusable function to return the HTML
    needed to display a given number of filled gold stars (set with the function’s
    $stars parameter) while displaying the remaining (disabled) stars as gray. We
    use a switch statement to handle each possible star rating from 0 to 5. (I’ve
    shown cases 0 through 2; you can fill in the remaining cases.) We display each
    Bootstrap Glyphicon star character by using an HTML <span> element, with the CSS
    class glyphicon glyphicon-star for a filled gold star or glyphicon glyphicon-star-empty
    for a gray star. We could also implement this starsHtml() function by using some
    kind of loop, but the switch statement is more straightforward to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Template Script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now need to write the template script for the product list page. It will
    loop through the $products array, decorating the data for each product with the
    appropriate HTML. (For this to work, the $products array must already have been
    created in the calling script before the template script itself is executed; we’ve
    done this in [Listing 15-1](#lis15-1).) Create *templates/list.php* and enter
    the contents of [Listing 15-4](#lis15-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-4: The list.php template'
  prefs: []
  type: TYPE_NORMAL
- en: We use three <link> elements to load the Bootstrap CSS styles and glyphs, plus
    our custom *products.css* stylesheet in the *css* folder. Then we declare a PHP
    foreach loop to iterate through the $products array, one product at a time ❶.
    On each iteration, the loop extracts the array containing details about the current
    product (with elements indexed by 'name', 'price', 'stars', and 'image'), and
    names that array $product. The foreach syntax $products as $id => $product also
    means that the key for the current array element (a string containing the current
    product ID) will be available in the $id variable. This will become important
    because our shopping cart logic needs to know the ID of each product so it can
    display and modify the cart contents.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, we create a $price variable containing the value of the 'price'
    element of the current product array, formatted to two decimal places with the
    number_format() function ❷. Next, we create an HTML <img> element that uses the
    image filename stored in $product['image'] to create the path to the appropriate
    image file in the public *images* folder (for example, *images/banana.png*) ❸.
    We then pass the integer number of stars ($product['stars']) to the starsHtml()
    function so the appropriate HTML for the five gold and gray stars will be output
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the foreach loop, we set the name of the product as a level 1 heading
    styled with the fs-5 Bootstrap CSS class for smaller text. We then create a <div>
    styled with the price CSS class (defined in our *css/products.css* file). This
    <div> displays the price of the current product, along with a form containing
    a button labeled Add to Cart. Once we’ve added shopping functionality, clicking
    this button will add the ID of the current product to the shopping cart via a
    POST HTTP request. The form passes two query-string parameters: action with a
    value of addToCart and id with a value of the current product ID ❺. Finally, we
    display the product’s text description in its own <div> styled with the fs-6 Bootstrap
    CSS class for small text ❻, before closing the foreach loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Index Script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To complete our product list, we need to add require_once statements to the
    *index.php* script so it can access code from other parts of the project. Update
    *public/index.php* as shown in [Listing 15-5](#lis15-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-5: Reading the function declarations and template script into index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We use require_once to read in the function declaration file, which gives the
    page template access to the starsHtml() function. Then, at the end of the script,
    we read in the template script to display the product list page. Because we declare
    the $products array in between, the template will have access to this too. At
    this point, if you run the PHP web server (php -S localhost:8000 -t public) and
    visit the home page in a web browser, you should see the list of products, as
    shown earlier in [Figure 15-2](#fig15-2).
  prefs: []
  type: TYPE_NORMAL
- en: Designing the Shopping Cart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s create a shopping cart display page, so users will have a way to view
    their cart. In “Implementing Cart-Manipulation Functions” on [page 293](#pg_293),
    we’ll implement the logic for adding to, deleting from, and changing the quantities
    of the shopping cart contents. [Figure 15-3](#fig15-3) shows the shopping cart
    page we’ll create.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure15-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-3: The shopping cart page'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need to display a row for each product in the cart, along with the unit
    price, the quantity in the cart, and the subtotal for each product. Each item
    also needs + and - buttons to incrementally change the quantity of the product
    by plus or minus 1, and a red Remove button to completely remove that product
    from the cart. We’ll have a final row beneath the products displaying the total
    cost of all items in the cart.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Creating the Front Controller'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the shopping cart will be our second display page, we need to introduce
    front-controller logic to *public/index.php* to select the appropriate template
    to display. We’re going to offer two navigation links at the top of each page:
    List of Products (href="/") and Shopping Cart (href="/?action=cart"). The front
    controller can therefore check for an action query-string variable with a value
    of cart to determine which page the user is requesting. Delete the require_once
    statement currently at the end of *public/index.php* and replace it with the code
    in [Listing 15-6](#lis15-6).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-6: Deciding which template to display at the end of index.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code creates a $page variable whose value is the name of a template file.
    We incorporate whatever value $page has into the require_once statement at the
    end of the script to display the appropriate template ❶. We have just two templates
    to choose from: the product list (*list.php*) and the shopping cart (*cart.php*,
    which we’ll write shortly). By default, we first set $page to the product list
    template. Then we retrieve a value for the action variable from the query-string
    parameters, and if it’s found to be cart, we change $page to the shopping cart
    template.'
  prefs: []
  type: TYPE_NORMAL
- en: In “Writing the switch Statement” on [page 297](#pg_297), we’ll expand on the
    front- controller logic to account for all the actions users can take on the shopping
    cart page. For now, though, [Listing 15-6](#lis15-6) has all the front-controller
    logic we need in order to view the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Product and Cart Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll represent the contents of the shopping cart by using a $cartItems array
    whose keys are product IDs and whose values are the quantities of those products
    in the cart. We don’t need to store additional product information, such as prices,
    in this array, since we can use the product IDs to retrieve the other details
    from the source of our product data, the $products array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, we’ll be reading the contents of the shopping cart array from the
    session, but for now, we’ll hardcode an array of cart items for testing purposes.
    This is a common approach when developing a new feature: you hardcode initial
    data so you can write scripts to work with data for the new feature, and then
    once that’s all working, you make the source of the data dynamic (for example,
    coming from the session or a database).'
  prefs: []
  type: TYPE_NORMAL
- en: To keep our *index.php* script from getting too complicated, we’ll write a separate
    function that returns the array of items currently in the shopping cart. Add the
    getShoppingCart() function shown in [Listing 15-7](#lis15-7) to the end of the
    *src/functions.php* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-7: The getShoppingCart() function'
  prefs: []
  type: TYPE_NORMAL
- en: The getShoppingCart() function creates and returns the contents of the $cartItems
    array. Each element in the array has a product ID string that acts as its key
    (in this hardcoded example, '010' and '005' for the sandwich and pineapple products,
    respectively). The value of each element is the quantity of that product in the
    cart (two sandwiches and four pineapples).
  prefs: []
  type: TYPE_NORMAL
- en: While we’re at it, let’s also move all the code declaring the $products array
    from *index.php* into a getAllProducts() function. Again, this will help keep
    the index script from becoming too complex. Copy the code you created in [Listing
    15-1](#lis15-1) from *public/index.php* and paste it at the end of the *src/functions.php*
    script, as shown in [Listing 15-8](#lis15-8). To embed the code within a function,
    you’ll also need to add the lines shown in black.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-8: The getAllProducts() function'
  prefs: []
  type: TYPE_NORMAL
- en: This function builds up the $products array and then returns it, allowing the
    array to be used in *public/index.php*.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlining the Index Script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can now update our *index.php* script to make use of the new getAllProducts()
    and getShoppingCart() functions. If you haven’t already, delete the code building
    the $products array from the *index.php* script. Then update the file by adding
    the statements shown in [Listing 15-9](#lis15-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-9: The simplified index.php script'
  prefs: []
  type: TYPE_NORMAL
- en: We now use the getAllProducts() and getShoppingCart() functions declared in
    *src/functions.php* to create the $products and $cartItems arrays. The arrays
    are therefore available to whichever template script is invoked in the final require_once
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Header Template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we write a display template for the shopping cart, much of its page header
    content will be the same as that of the product list page. To simplify both the
    cart and product display templates, we’ll put all the common HTML content into
    a separate template file named *templates/_header.php*.
  prefs: []
  type: TYPE_NORMAL
- en: This name follows the common convention of using an underscore to prefix the
    name of a *partial template* (a file that renders only part of a page and is shared
    by several other templates). This convention enables you to quickly identify partial
    templates within a folder, so you can ignore them when you’re looking for a particular
    full template file.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the code from *templates/list.php*, paste it into a new *templates/_header.php*
    file, and update the code as shown in [Listing 15-10](#lis15-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-10: The common page header content in _header.php'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header template uses a $pageTitle variable, which will need to be defined
    in each script that requires this header template. The variable appears twice:
    in the required HTML title in the <head> element ❶ and as a level 1 HTML heading
    in the body of every page ❷. In between, we add a simple navigation list with
    two links, one to show the product list and one to display the shopping cart.'
  prefs: []
  type: TYPE_NORMAL
- en: We can now remove all that common header content from our product list page
    (*templates/list.php*). [Listing 15-11](#lis15-11) shows the updated, simplified
    contents of the template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-11: The simplified list.php template'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a PHP code block to set a value for $pageTitle and read in the *_header.php*
    template to create the page header. The remainder of the file is just as before:
    a single <div> styled as a Bootstrap row, and a foreach loop to add column divs
    for each product.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Cart Display Template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re now ready to write the template for displaying the items in the shopping
    cart. This script will loop through and display each product in the $cartItems
    array, calculate a subtotal for each product, and find the overall total for the
    complete shopping cart. The script is quite long, so we’ll discuss it in sections.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the script accesses the common HTML page header code and sets
    up headings for each column in the cart display. Create a new *templates/cart.php*
    file and enter the code in [Listing 15-12](#lis15-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-12: The first part of the cart.php template: setting up the cart
    display'
  prefs: []
  type: TYPE_NORMAL
- en: First, we zero the $total variable; this will eventually hold the grand total
    of all items in the shopping cart. Then we set the $pageTitle variable and read
    in the header template, just as we did on the product list page. We then create
    a row of column headers ❶ identifying the Image, Item, Price, Quantity, Subtotal,
    and Action columns. We use the Bootstrap 12-column layout, making the image (col-2),
    item (col-4), and quantity (col-3) columns wider than the price, subtotal, and
    action columns (which default to 1/12 page-width columns).
  prefs: []
  type: TYPE_NORMAL
- en: The workhorse section of the shopping cart display script is a loop through
    the $cartItems array. For each product in the array, we’ll display the product’s
    image, name, description, unit price, quantity, and subtotal. Within the loop,
    we’ll also create form buttons for changing the quantity and removing the product
    completely from the shopping cart. [Listing 15-13](#lis15-13) shows the main PHP
    code block at the beginning of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-13: The second part of the cart.php template: the item loop'
  prefs: []
  type: TYPE_NORMAL
- en: The loop will continue in [Listing 15-14](#lis15-14) with all the HTML column
    <div> elements needed to display each cart item.
  prefs: []
  type: TYPE_NORMAL
- en: Within a PHP code block, we start a foreach loop through the $cartItems array,
    setting $id to equal the current array element key and $quantity to equal the
    current element value. Since $id also corresponds to a key in the $products array,
    we use it to retrieve all product details for the current shopping cart item,
    storing them in the $product variable ❶. We then extract the price of the product
    into $price and multiply it by $quantity to get the subtotal for the cart item
    ❷. Next, we add the subtotal for the current cart item to the grand total ($total)
    ❸. This grand total will accumulate over the course of the loop. Finally, we format
    both $price and $subtotal to be numbers with two decimal places, since they represent
    currency values.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-14 shows the rest of the foreach loop, where we lay out the HTML
    needed to display each cart item.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-14: The third part of the cart.php template: the item <div> elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start a new <div>, which will be a row for the current shopping cart item
    in the foreach loop ❶. Then we display a <div> containing an HTML image tag for
    the current product’s image, getting the image filename from the value of $product[''image'']
    ❷. The image is centered and also styled with the product CSS class (from our
    *products.css*) so that the image is sized to fit the <div> (size: 100%). For
    cart product display, we have a different (smaller) image with the same name,
    so the URL for the image references the *cart* subfolder of the *images* folder:
    /images/cart/<?= $product[''image''] ?>.'
  prefs: []
  type: TYPE_NORMAL
- en: We next create a <div> displaying the product name ($product['name']) as a level
    1 heading, along with the text description of the product ($product['description'])
    ❸. Then we display the two-decimal-place value stored in $price in a <div> styled
    with the Bootstrap align-self-center class to vertically center the content in
    the row, with text aligned to the right (text-end) and with the price CSS class
    (bold and larger text) from our *products.css* stylesheet ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next <div> displays the quantity for the current cart item ❺. This is actually
    an HTML form, with two buttons (a minus and a plus) and the $quantity variable
    displayed. The form uses the POST method (since we’re changing content on the
    server) and passes two query-string parameters: action=changeCartQuantity and
    the ID of the product (id=<?= $id ?>). Later in the chapter, we’ll add more logic
    to our *index.php* script to recognize this new value of the action parameter
    and process a change of quantity. For the buttons, we use a minus-sign Glyphicon
    symbol (Bootstrap CSS class glyphicon-minus) with the name changeDirection and
    the value reduce, and a plus-sign Glyphicon, also with the name changeDirection
    but with the value increase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we display the value of $subtotal. Once again we format its <div> with
    our price CSS class because it is a currency value, and we align the text to the
    right (text-end) ❻. Then we output another vertically centered <div> with text
    aligned to the right (text-end) that presents a button for the user to remove
    the item completely from the shopping cart ❼. This is another form submitting
    with the POST method. It sends two query-string variables: action=removeFromCart
    and the ID of the current item (id=<?= $id ?>). The form offers the user a button
    consisting of a cross Glyphicon followed by the word Remove. Again, later in the
    chapter, we’ll add more logic to our *index.php* script to handle removing an
    item from the shopping cart. And with that, we end our foreach loop ❽.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-15 shows the final part of the *templates/cart.php* script. This
    section of the code displays the grand total.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-15: The final part of the cart.php template: showing the total'
  prefs: []
  type: TYPE_NORMAL
- en: This code outputs a final row, displaying two <div> elements. One gives the
    cart total ($total), formatted to two decimal places. The other outputs just the
    word Total. The div to display the total is made wide enough to cover all the
    missing columns to its left by using the Bootstrap class col-11, and since the
    value is a currency, it’s again styled with the price CSS class defined in the
    *products.css* stylesheet file.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now achieved a two-page website. One page displays a list of products
    from data stored in the $products array. The second page displays the contents
    of a shopping cart by using the $cartItems array.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to this point, we’ve used a hardcoded function to always return the same
    shopping cart contents. Now we’ll modify the application to work with a dynamic,
    interactive shopping cart stored in the $_SESSION array so that the cart contents
    can be remembered over the course of the browser session. In the process, we’ll
    implement functions to modify the contents of the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Cart-Retrieval Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To work with dynamic shopping cart data, we must first update the getShoppingCart()
    function to retrieve the shopping cart contents from the session. As we explored
    in [Chapter 14](chapter14.xhtml), before we attempt to retrieve a value from the
    session, we should set a default value in case nothing is found. Our default case
    will be an empty shopping cart array.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-16 shows the updated getShoppingCart() code. This function replaces
    the previous one in *src/functions.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-16: A function to retrieve the cart array from the session'
  prefs: []
  type: TYPE_NORMAL
- en: We set $cartItems to the default value of an empty array. Then we use isset()
    to test whether a value can be found in the $_SESSION array for the 'cart' key.
    If an element exists for this key, its value is copied into the $cartItems variable.
    Finally, the function returns the contents of $cartItems.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Cart-Manipulation Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll implement functions to manipulate the contents of the cart. First,
    to add an item to the shopping cart stored in the $_SESSION array, we need a function
    that will add a new element to the array with the product ID as the key and a
    quantity of 1 as the value. If $_SESSION doesn’t contain a current shopping cart
    array, this same function should create a new one containing one element. We’ll
    achieve this by adding a new function to *src/functions.php*, as shown in [Listing
    15-17](#lis15-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-17: A function to add a new product to the cart'
  prefs: []
  type: TYPE_NORMAL
- en: The function takes an $id parameter representing the ID of the item being added
    to the cart. We first store the current shopping cart array in the $cartItems
    variable by calling our getShoppingCart() function. Then we add a new element
    to $cartItems, with the key of the $id parameter and a value of 1 (the quantity
    of this product in the cart). Finally, we store the updated $cartItems array in
    $_SESSION, overwriting the previous $_SESSION['cart'] array if one existed.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a product completely from the shopping cart is similar to adding an
    item. We’ll add a new removeItemFromCart() function to *src/functions.php*, as
    shown in [Listing 15-18](#lis15-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-18: A function to remove a product from the cart'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the function takes in an $id parameter and starts by getting the
    array of items in the shopping cart. Then we use unset() to remove the element
    with the specified ID from the $cartItems array. As before, we finish by storing
    the updated array in the session, overwriting the previous array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll write a getQuantity() function to look up the current quantity of
    a given product in the shopping cart array. This function, shown in [Listing 15-19](#lis15-19),
    will help us write other functions for increasing and decreasing the quantity
    of a product in the cart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-19: A function to check the quantity of a product'
  prefs: []
  type: TYPE_NORMAL
- en: This function takes in the desired product ID and the shopping cart array as
    parameters. We use isset() to test whether an element can be found in the cart
    for the given ID. If it’s found, we return the value for that array element, representing
    the current quantity for that item. If no element is found indexed by $id, the
    item isn’t in the cart, so we return a quantity of 0.
  prefs: []
  type: TYPE_NORMAL
- en: To increase the quantity of a product in the cart by 1, we need to retrieve
    the existing quantity, add 1 to it, and save the updated array back to the session.
    We’ll encode this logic in an increaseCartQuantity() function, as shown in [Listing
    15-20](#lis15-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-20: A function to increase the quantity of a cart item'
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving the $cartItems array, we use our getQuantity() function to
    determine the quantity of the product with the given $id. Next, we add 1 to this
    quantity and assign the new quantity to the $id key in the $cartItems array. Then
    we store the updated array in $_SESSION['cart'], overwriting the previous array.
  prefs: []
  type: TYPE_NORMAL
- en: Decreasing the quantity by 1 is a little more complicated than increasing it,
    since this may reduce the quantity to 0, in which case we should remove the product
    completely from the shopping cart. We need to retrieve the existing quantity,
    subtract 1 from it, test whether the quantity is now 0, update the cart array
    appropriately, and save the updated array back to the session. We’ll encode this
    logic in a reduceCartQuantity() function, as shown in [Listing 15-21](#lis15-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-21: A function to reduce the quantity of a cart item in file src/functions.php'
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve the shopping cart from the session and look up the quantity of the
    product with the given $id, just as we did in the previous function. Then we subtract
    1 from this quantity. Next, we test whether the reduced quantity is less than
    1 (that is, 0), and if so, we remove the entire element from the shopping cart
    by using unset(). Otherwise, we store the reduced quantity in the shopping cart.
    Finally, we store the updated $cartItems array in the session, overwriting the
    previous values.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When easy to do so, I always recommend using strong tests, such as less-than
    or greater-than, as we do for [Listing 15-21](#lis15-21)’s* if *statement, rather
    than testing for equality with a value like 0.*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Empty Cart Template
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we’re making the shopping cart dynamic, we need to account for the
    possibility that the user will try to view their cart when it’s empty. We’ll create
    a separate empty cart template to display when this happens. [Figure 15-4](#fig15-4)
    shows how it should look.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure15-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-4: The empty shopping cart page'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-22 shows the code for the empty cart template. Enter this code in
    a new file called *templates/emptyCart.php*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-22: The emptyCart.php template'
  prefs: []
  type: TYPE_NORMAL
- en: This template is very short since, like our other display templates, it uses
    all the common content in *_header.php* (after first setting the required $pageTitle
    variable). Besides the header, it contains a single row of text informing the
    user that the cart is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing the Front Controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our website now has three possible pages the user can see: the list of products,
    the empty cart, and the cart containing items. The application needs to identify
    and perform a range of actions, such as adding items to the cart and changing
    quantities. To finalize our shopping cart application, we therefore need to expand
    the front-controller script in *index.php* to choose from all these pages and
    actions.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Adding Display Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we’ll be expanding the front controller, we still want to keep it
    as simple and concise as possible. Therefore, we’ll declare two final helper functions:
    one to display the list of products and one to display the shopping cart (either
    empty or full). Add the code shown in [Listing 15-23](#lis15-23) to the *src/functions.php*
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-23: Functions to display the products and the shopping cart'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare the displayProducts() function. It invokes getAllProducts()
    to obtain an array of all the products, then reads in and executes the *list.php*
    template. Then we declare the displayCart() function. It retrieves the $products
    and $cartItems arrays, then tests whether $cartItems is empty ❶. Depending on
    the result, the function displays the appropriate template, either *cart.php*
    or *emptyCart.php*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the switch Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’re ready to bring everything together with updated front-controller code.
    We’ll follow the pattern we discussed in [Chapter 13](chapter13.xhtml) of using
    a switch statement to detect the required action and respond appropriately. Our
    front controller needs to handle six queries from the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Display all products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a product to the shopping cart (given a product ID)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a product from the shopping cart (given a product ID)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the quantity of a product by 1 (given a product ID)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrease the quantity of a product by 1 (given a product ID), and remove it
    if the quantity is now 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the existing contents of *public/index.php* with the code in [Listing
    15-24](#lis15-24). This is a well-organized script, since all the complex logic
    has been relegated to separate functions. The front-controller script simply focuses
    on retrieving query-string and POST values, deciding which function to call, and
    choosing whether to display the product list or shopping cart after executing
    the appropriate function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-24: The final version of the front-controller logic in index.php'
  prefs: []
  type: TYPE_NORMAL
- en: We use PHP’s session_start() function to start a new session if none currently
    exists or to renew the existing session. Calling this function is one of the first
    tasks you must do when processing a request to the server involving data stored
    in the $_SESSION array. Next, after reading in the function declarations from
    *src/functions.php*, we try to find a value for the $action variable from the
    query-string parameters and use it to begin a switch() statement.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of $action is 'cart' ❶, we display the shopping cart by using the
    displayCart() function. If the value is 'addToCart' ❷ or 'removeFromCart' ❸, we
    retrieve the value of the id query-string variable, pass it to the appropriate
    function to add or remove a cart item, and then display the shopping cart. If
    $action is 'changeCartQuantity' ❹, we retrieve the product ID from the query string
    and get the value of changeDirection from the POST variables. If the latter is
    'increase', we call increaseCartQuantity(); otherwise, we call decreaseCartQuantity().
    In either case, we then display the shopping cart. Finally, if no value of the
    action query-string variable is found, we use the default case to display the
    list of products ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we explored a real-world application of working with sessions:
    an interactive shopping cart. Our work with the shopping cart stored in the $_SESSION
    array followed the same approach as in the preceding chapter: we set a default,
    attempt to read a value from the $_SESSION array, do something with the value,
    then save the updated data back into the session. The core logic for the project
    in this chapter revolves around two arrays, a product list and a shopping cart,
    both of which are keyed with product IDs. While in this chapter our list of products
    is fixed in an array, it would be straightforward to refactor this code to read
    the list of products from a database, which is how most real-world e-commerce
    websites operate.'
  prefs: []
  type: TYPE_NORMAL
- en: By identifying the operations we wanted to apply to our shopping cart array
    and then encoding this logic as individual functions in *src/functions.php*, our
    final *public/index.php* front controller was simple to write. The listings for
    *templates/list.php* and *templates/cart.php* are relatively long, but this is
    mostly because we incorporated some Bootstrap CSS to make the list of products
    and shopping cart look more professional. In fact, the display templates would
    have been even longer had we not used a *templates/_header.php* file to store
    information common to all three pages of the site.
  prefs: []
  type: TYPE_NORMAL
- en: Many software systems are designed around the relationship between *data structures*
    (the way information is stored) and *algorithms* (the programming of the application
    logic). In this case, we structured both our product details and our shopping
    cart arrays around unique product IDs. This decision made creating the site logic
    and display templates straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw that not all information about a session needs to be stored to the
    session. For example, the shopping cart subtotals and grand total can be calculated
    dynamically each time the cart page is loaded; they don’t need to be stored. Likewise,
    we don’t store product details within the shopping cart array, just the product
    ID, since we can retrieve all the other attributes of each product in the cart
    from the array of product items. To sum up, we created two data structures (the
    arrays for product details and shopping cart contents) and then designed algorithms
    (our front-controller logic and display templates) to efficiently interact with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Add a new 'category' attribute for the products in the shopping cart application,
    with possible values 'savory' (the sandwich), 'sweet' (the cheesecake and the
    donut), or 'fruit' (the pineapple and banana). You’ll need to add this element
    to each product in the getAllProducts() function, and add a new <div> in the *list.php*
    template to display it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Add a button labeled Empty Cart to the shopping cart display page that
    results in a POST request sending the query-string parameter action=emptyCart.
    Then add an emptyShoppingCart() function to the *src/functions.php* file and a
    new case to the front controller’s switch statement to invoke this function and
    clear the shopping cart’s contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Since nothing else is being stored in the session for this project, you
    could either use the killSession() function approach from [Chapter 14](chapter14.xhtml)
    or simply replace the existing contents of $_SESSION[''cart''] with an empty array.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Our code doesn’t have any validation checking for missing or invalid data.
    For example, when the action query-string variable is addToCart, we would have
    a problem if the ID is missing or invalid or if no product exists in the $products
    array matching the received ID. Add some simple validation so that if any problem
    arises with the ID when one is required, the product list page is displayed and
    no change is made to the shopping cart.
  prefs: []
  type: TYPE_NORMAL
