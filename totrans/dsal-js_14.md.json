["```\n❶ const mySet = {};\n❷ mySet.one = 1;\nmySet.two = 2;\n```", "```\n\"two\" in mySet;   // true\n\"three\" in mySet; // false\n```", "```\ndelete mySet.two;\n```", "```\n❶ const mySet = new Set();\n❷ mySet.add(\"one\");\nmySet.add(\"two\");\n```", "```\nmySet.add(\"one\").add(\"two\");\n```", "```\nmySet.has(\"two\");   // true\nmySet.has(\"three\"); // false\n```", "```\nmySet.delete(\"two\");\n```", "```\nconst find = (list, valueToFind) => {\n❶ if (isEmpty(list) || valueToFind < list.value) {\n   return false;\n❷} else if (valueToFind === list.value) {\n   return true;\n❸} else {\n   // valueToRemove > list.value\n   return find(list.next, valueToFind);\n }\n};\n```", "```\nconst add = (list, valueToAdd) => {\n❶ if (isEmpty(list) || valueToAdd < list.value) {\n   list = {value: valueToAdd, next: list};\n❷} else {\n ❸ list.next = add(list.next, valueToAdd);\n }\n return list;\n};\n```", "```\nconst remove = (list, valueToRemove) => {\n❶ if (isEmpty(list) || valueToRemove < list.value) {\n   return list;\n❷} else if (valueToRemove === list.value) {\n   return list.next;\n❸} else {\n   // valueToRemove > list.value\n   list.next = remove(list.next, valueToRemove);\n   return list;\n }\n};\n```", "```\nconst newSkipList = () => ({\n  value: -Infinity,\n  next: [{value: Infinity, next: [null]}]\n});\n```", "```\nconst isEmpty = (sl) => sl.next[0].next[0] === null;\n```", "```\nconst _level = (sl) => sl.next.length - 1;\n```", "```\n❶ const _find = (node, currLevel, valueToFind) => {\n❷ if (currLevel < 0) {\n   return false;\n❸} else if (valueToFind === node.value) {\n   return true;\n❹} else if (valueToFind >= node.next[currLevel].value) {\n   return _find(node.next[currLevel], currLevel, valueToFind);\n❺} else {\n   return _find(node, currLevel - 1, valueToFind);\n }\n};\n\n❻ const find = (sl, valueToFind) => _find(sl, _level(sl), valueToFind);\n```", "```\nconst _add = (currNode, currLevel, newNode, newLevel) => {\n❶ if (newNode.value > currNode.next[currLevel].value) {\n    _add(currNode.next[currLevel], currLevel, newNode, newLevel);\n  } else {\n  ❷ if (currLevel <= newLevel) {\n    ❸ newNode.next[currLevel] = currNode.next[currLevel];\n      currNode.next[currLevel] = newNode;\n    }\n  ❹ if (currLevel > 0) {\n    ❺ _add(currNode, currLevel - 1, newNode, newLevel);\n    }\n  }\n};\n```", "```\nconst add = (sl, valueToAdd) => {\n❶ let newLevel = 0;\n  while (newLevel < MAX_LEVEL && Math.random() > 0.5) {\n    newLevel++;\n  }\n❷ const newNode = {value: valueToAdd, next: new Array(newLevel)};\n\n  let currLevel = _level(sl);\n❸ while (newLevel >= currLevel) {\n  ❹ sl.next[currLevel].next.push(null);\n    sl.next.push(sl.next[currLevel]);\n    currLevel++;\n  }\n❺ _add(sl, currLevel, newNode, newLevel);\n  return sl;\n};\n```", "```\nconst _remove = (currNode, currLevel, valueToRemove) => {\n❶ if (valueToRemove > currNode.next[currLevel].value) {\n    _remove(currNode.next[currLevel], currLevel, valueToRemove);\n  } else {\n  ❷ if (valueToRemove === currNode.next[currLevel].value) {\n    ❸ currNode.next[currLevel] = currNode.next[currLevel].next[currLevel];\n    }\n  ❹ if (currLevel > 0) {\n      _remove(currNode, currLevel - 1, valueToRemove);\n    }\n  }\n};\n```", "```\nconst remove = (sl, valueToRemove) => {\n❶ _remove(sl, _level(sl), valueToRemove);\n  for (\n  ❷ let level = _level(sl) – 1;\n  ❸ level > 0 && sl.next[level].next[level] === null;\n    level--\n  ) {\n  ❹ sl.next[level].next.splice(level, 1);\n    sl.next.splice(level, 1);\n  }\n  return sl;\n};\n```", "```\nconst findMTF = (list, keyToFind) => {\n❶ if (isEmpty(list)) {\n    return [list, false];\n❷} else if (list.value === keyToFind) {\n    return [list, true];\n  } else {\n ❸ let [prev, curr] = [list, list.next];\n ❹ while (!isEmpty(curr) && curr.value !== keyToFind) {\n     [prev, curr] = [curr, curr.next];\n   }\n\n ❺ if (isEmpty(curr)) {\n     return [list, false];\n ❻} else {\n     [prev.next, curr.next] = [curr.next, list];\n     return [curr, true];\n   }\n }\n};\n```", "```\nconst add = (list, valueToAdd) => {\n❶ list = {value: valueToAdd, next: list};\n  return list;\n};\n```", "```\nconst remove = (list, valueToRemove) => {\n❶ if (isEmpty(list)) {\n   return list;\n❷} else if (valueToRemove === list.value) {\n   return list.next;\n } else {\n ❸ list.next = remove(list.next, valueToRemove);\n   return list;\n }\n};\n```", "```\nconst hash = (ht, value) => value % ht.slots.length;\n```", "```\nconst newHashTable = (n = 100) => ({\n  slots: new Array(n).fill(0).map(() => newList())\n});\n```", "```\nconst add = (ht, value) => {\n❶ const i = hash(ht, value);\n❷ ht.slots[i] = addToList(ht.slots[i], value);\n  return ht;\n};\n```", "```\nconst find = (ht, value) => {\n❶ const i = hash(ht, value);\n❷ return findInList(ht.slots[i], value);\n};\n```", "```\nconst remove = (ht, value) => {\n❶ const i = hash(ht, value);\n❷ ht.slots[i] = removeFromList(ht.slots[i], value);\n  return ht;\n};\n```", "```\nconst load = (ht) => ht.used / ht.slots.length;\n```", "```\nconst EMPTY = undefined;\nconst AVAILABLE = null;\n```", "```\nconst newHashTable = (n = 100) => ({\n❶ slots: new Array(n).fill(EMPTY),\n❷ used: 0\n});\n```", "```\nconst add = (ht, value) => {\n❶ let i = hash(ht, value);\n❷ while (ht.slots[i] !== EMPTY && ht.slots[i] !== AVAILABLE) {\n  ❸ i = (i + 1) % ht.slots.length;\n  }\n\n❹ if (ht.slots[i] === EMPTY) {\n    ht.used++;\n  }\n  ht.slots[i] = value;\n  return ht;\n};\n```", "```\nconst find = (ht, value) => {\n❶ let i = hash(ht, value);\n❷ while (ht.slots[i] !== EMPTY && ht.slots[i] !== value) {\n    i = (i + 1) % ht.slots.length;\n  }\n\n❸ return ht.slots[i] === value;\n};\n```", "```\nconst remove = (ht, value) => {\n❶ let i = hash(ht, value);\n  while (ht.slots[i] !== EMPTY && ht.slots[i] !== value) {\n    i = (i + 1) % ht.slots.length;\n  }\n\n❷ if (ht.slots[i] === value) {\n    ht.slots[i] = AVAILABLE;\n  }\n  return ht;\n};\n```", "```\n❶ if (load(ht) > 0.75) {\n  ❷ let newHT = newHashTable(ht.slots.length * 2);\n  ❸ ht.slots.forEach((v) => {\n    ❹ if (v !== EMPTY && v !== AVAILABLE) {\n      ❺ newHT = add(newHT, v);\n      }\n    });\n  ❻ return newHT;\n  } else {\n  ❼ return ht;\n  }\n};\n```", "```\nconst EMPTY = undefined;\nconst AVAILABLE = null;\n\nconst newHashTable = (n = 100) => ({\n  slots: new Array(n).fill(EMPTY),\n  used: 0\n});\n```", "```\nconst hash1 = (ht, value) => value % ht.slots.length;\nconst hash2 = (ht, value) => 1 + (value % (ht.slots.length - 1));\n```", "```\nconst add = (ht, value) => {\n❶ let i = hash1(ht, value);\n❷ if (ht.slots[i] !== EMPTY && ht.slots[i] !== AVAILABLE) {\n  ❸ const step = hash2(ht, value);\n  ❹ let i0 = i;\n  ❺ while (ht.slots[i] !== EMPTY && ht.slots[i] !== AVAILABLE) {\n    ❻ i = (i + step) % ht.slots.length;\n    ❼ if (i === i0) {\n        i = (i + 1) % ht.slots.length;\n        i0 = i;\n      }\n    }\n  }\n\n❽ if (ht.slots[i] === EMPTY) {\n    ht.used++;\n  }\n  ht.slots[i] = value;\n  return ht;\n};\n```", "```\nconst find = (ht, value) => {\n❶ let i = hash1(ht, value);\n❷ const step = hash2(ht, value);\n❸ let i0 = i;\n❹ while (ht.slots[i] !== EMPTY && ht.slots[i] !== value) {\n    i = (i + step) % ht.slots.length;\n  ❺ if (i0 === i) {\n      i = (i + 1) % ht.slots.length;\n      i0 = i;\n    }\n  }\n\n❻ return ht.slots[i] === value;\n};\n```", "```\nconst remove = (ht, value) => {\n  let i = hash1(ht, value);\n  let i0 = i;\n  const step = hash2(ht, value);\n  while (ht.slots[i] !== EMPTY && ht.slots[i] !== value) {\n    i = (i + step) % ht.slots.length;\n    if (i0 === i) {\n      i = (i + 1) % ht.slots.length;\n      i0 = i;\n    }\n  }\n\n❶ if (ht.slots[i] === value) {\n    ht.slots[i] = AVAILABLE;\n  }\n  return ht;\n};\n```", "```\nconst isPrime = (n) => {\n❶ if (n <= 3) {\n   return true;\n❷} else if (n % 2 === 0) {\n   return false;\n }\n\n❸ for (let d = 3, q = n; d < q; d += 2) {\n   q = n / d;\n ❹ if (Math.floor(q) === q) {\n     return false;\n   }\n }\n❺ return true;\n};\n```", "```\nconst findNextPrime = (n) => {\n❶ while (!isPrime(n)) {\n  ❷ n++;\n  }\n  return n;\n};\n```", "```\nconst newHashTable = (n = 100) => ({\n  slots: new Array(findNextPrime(n)).fill(EMPTY),\n  used: 0\n});\n```", "```\nconst add = (ht, value) => {\n  let i = hash1(ht, value);\n  if (ht.slots[i] !== EMPTY) {\n    const step = hash2(ht, value);\n    while (ht.slots[i] !== EMPTY && ht.slots[i] !== AVAILABLE) {\n      i = (i + step) % ht.slots.length;\n    }\n  }\n\n  if (ht.slots[i] === EMPTY) {\n    ht.used++;\n  }\n  ht.slots[i] = value;\n  return ht;\n};\n```", "```\nconst find = (ht, value) => {\n  let i = hash1(ht, value);\n  const step = hash2(ht, value);\n  while (ht.slots[i] !== EMPTY && ht.slots[i] !== value) {\n    i = (i + step) % ht.slots.length;\n  }\n\n  return ht.slots[i] === value;\n};\n```", "```\nconst remove = (ht, value) => {\n  let i = hash1(ht, value);\n  const step = hash2(ht, value);\n  while (ht.slots[i] !== EMPTY && ht.slots[i] !== value) {\n    i = (i + step) % ht.slots.length;\n  }\n\n  if (ht.slots[i] === value) {\n    ht.slots[i] = AVAILABLE;\n  }\n  return ht;\n};\n```", "```\nconst newHashTable = (n = 100) => ({\n  slots: new Array(n).fill(newList())\n});\n```"]