<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch4" epub:type="chapter" role="doc-chapter">
<span aria-label="127" epub:type="pagebreak" id="pg_127" role="doc-pagebreak"/>
<hgroup>
<h2 class="title" id="ch4">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">4</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">SOLVING MATHEMATICAL PROBLEMS WITH CODE</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="380" src="../images/icon.jpg" width="381"/>
</figure>
<p class="chapterintro">After our thorough overview of the fundamentals of the Kotlin programming language and the JavaFX graphics tools adapted for use in Kotlin, we’re now prepared to tackle a series of math problems in the form of mini projects. The projects will grow in complexity over the chapter, but they require only high school math skills. Our journey will take us from the ancient civilizations of Babylon, Greece, and Egypt to the modern-day world of cryptography.</p>
<p class="tx">The main goal of these projects is to enhance your Kotlin programming skills. We’ll discuss the context and mathematics behind each problem in detail, but the heart of each project will be developing an appropriate algorithm or problem-solving strategy and then implementing it in well-organized code. In doing so, you’ll gain a deeper understanding <span aria-label="128" epub:type="pagebreak" id="pg_128" role="doc-pagebreak"/>of both programming and math, preparing you to solve the more sophisticated problems introduced later in this book.</p>
<p class="headaexercise" id="pre-9"><span class="sans_dogma_ot_bold_b_15-n">Project 9: Find the Square Root with the Babylonian Algorithm</span></p>
<p class="tni">We have several methods of finding the square root of a number. In this project, I’ll focus on the Babylonian square root algorithm, one of the most widely used methods today.</p>
<p class="tx">The Babylonian square root algorithm dates back to around 1800 <small class="calibre12">BCE</small>. It’s believed the Babylonians used it for practical purposes, such as land surveying. The algorithm was later refined by the Greeks, who used it to calculate square roots to a high degree of accuracy. The Greek mathematician Heron of Alexandria described the algorithm in his work <i class="calibre9">Metrica</i>, written in the first century <small class="calibre12">CE</small>.</p>
<p class="tx">Despite its ancient origins, the Babylonian square root algorithm remains a valuable tool for understanding the history of mathematics and the development of numerical methods. The algorithm’s enduring usefulness is a testament to the ingenuity of ancient mathematicians and the power of mathematical techniques.</p>
<aside aria-label="box-21" class="box">
<p class="boxtitle" id="box-21"><span class="sans_futura_std_bold_b_">THE ORIGIN OF THE BABYLONIAN ALGORITHM</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">The Yale Babylonian Collection, part of the Yale University Library in New Haven, Connecticut, houses a Babylonian clay tablet called YBC 7289, which contains the earliest known description of the Babylonian square root algorithm. This tablet has been a significant object of study for scholars of ancient mathematics and the history of science since it was acquired in the early 20th century. The Yale Babylonian Collection also includes a number of other important artifacts, including cuneiform tablets, cylinder seals, and other objects that provide insight into the culture, society, and technology of ancient Mesopotamia.</span></p>
</aside>
<p class="tx">We can use the Babylonian algorithm to approximate the square root of a positive number in a few simple and iterative steps. The algorithm starts with an initial guess and then refines that guess until it’s close enough to the actual square root. Here’s how the algorithm works:</p>
<p class="listnumber">  1.  Start with an initial estimate, <span class="sans_thesansmonocd_w5regular_">guess</span>, for the square root of a positive number, <span class="sans_thesansmonocd_w5regular_">N</span>. This is customarily set to <span class="sans_thesansmonocd_w5regular_">N / 2</span>.</p>
<p class="listnumber1">  2.  Check to see if the absolute value of <span class="sans_thesansmonocd_w5regular_">(guess * guess - N)</span> is less than the tolerance value. If yes, then terminate the loop and return the estimated square root.</p>
<p class="listnumber1">  3.  Otherwise, update the guess using the formula <span class="sans_thesansmonocd_w5regular_">guess</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">(guess</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">N / guess) / 2.0</span>.</p>
<p class="listnumber2">  4.  Repeat steps 2 and 3 until the stopping condition is met.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="129" epub:type="pagebreak" id="pg_129" role="doc-pagebreak"/>
<h3 class="h1"><span id="sec1"/><span id="h2-62"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h3>
<p class="tni">The Babylonian algorithm is simple enough that we can write a concise code segment to find a square root. However, it’s a good practice to create a separate function for a process like this and then call that function from <span class="sans_thesansmonocd_w5regular_">main()</span>. This makes the code more reusable and easier to read.</p>
<p class="tx">Here’s an example Kotlin function for calculating the square root of a positive number using the Babylonian algorithm:</p>
<pre class="calibre10"><code class="calibre11">fun babylonianSquareRoot(num: Double): Double {
    val TOL = 0.000001
    var iter = 1
    var guess = num / 2.0

    while(Math.abs(guess * guess - num) &gt; TOL) {
        println("iter: $iter  guess=$guess")
        guess = (guess + num / guess) / 2.0
        iter ++
    }
    return guess
}</code></pre>
<p class="tx">This <span class="sans_thesansmonocd_w5regular_">babylonianSquareRoot()</span> function takes a positive double-precision number <span class="sans_thesansmonocd_w5regular_">num</span> as its single argument. It sets the tolerance value <span class="sans_thesansmonocd_w5regular_">TOL</span> to <span class="sans_thesansmonocd_w5regular_">0.000001</span>, initializes a variable <span class="sans_thesansmonocd_w5regular_">iter</span> to <span class="sans_thesansmonocd_w5regular_">1</span> to track the number of iterations, and makes a starting <span class="sans_thesansmonocd_w5regular_">guess</span> of <span class="sans_thesansmonocd_w5regular_">num / 2.0</span>. The function then follows the Babylonian algorithm I described, using a <span class="sans_thesansmonocd_w5regular_">while</span> loop to refine the value of <span class="sans_thesansmonocd_w5regular_">guess</span> until the result is within the tolerance. To help visualize the convergence process, the intermediate values of <span class="sans_thesansmonocd_w5regular_">iter</span> and <span class="sans_thesansmonocd_w5regular_">guess</span> are printed at each iteration.</p>
<p class="tx">To use this function, call it from the <span class="sans_thesansmonocd_w5regular_">main()</span> function and provide the value of the number you want to find the square root of, like so:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    println("\n*** Finding Square Root Using Babylonian Algorithm ***\n")
    println("Enter a number (&gt;=1) to find its square root:")
    val num = readln().toDouble()
    println("You have entered: $num\n")
    val squareRoot = babylonianSquareRoot(num)
    println("\nThe estimated square root of $num is: $squareRoot\n")
}</code></pre>
<p class="tx">In this case, the user is asked to enter the value of a positive number, which is read as a string and converted into a number of type <span class="sans_thesansmonocd_w5regular_">Double</span> before its square root is estimated. We’re assuming that the user will enter a valid number, which is greater than or equal to 1. If the user enters characters that cannot be converted into a number of type <span class="sans_thesansmonocd_w5regular_">Double</span>, the program is terminated with an error message. Also, if the user enters a valid negative number, the algorithm will not converge to a real solution.</p>
<p class="tx">In <span><a href="chapter1.xhtml" class="calibre2">Chapter 1</a></span>, you learned how to handle such errors or exceptions. Feel free to experiment with this code and to make it error-proof by using a <span class="sans_thesansmonocd_w5regular_">try...catch</span> block.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<span aria-label="130" epub:type="pagebreak" id="pg_130" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec2"/><span id="h2-63"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">Without further ado, let’s try running the algorithm! If <span class="sans_thesansmonocd_w5regular_">N</span> is set to <span class="sans_thesansmonocd_w5regular_">25</span>, the code should output the following:</p>
<pre class="calibre10"><code class="calibre11">*** Finding Square Root Using Babylonian Algorithm ***

Enter a number (&gt;=1) to find its square root:
<b class="calibre6">25</b>
You have entered: 25.0

iter: 1  guess=12.5
iter: 2  guess=7.25
iter: 3  guess=5.349137931034482
iter: 4  guess=5.011394106532552
iter: 5  guess=5.000012953048684

The estimated square root of 25.0 is: 5.000000000016778</code></pre>
<p class="tx">Of course, the exact value of the square root of 25 is 5. The Babylonian algorithm, like any other numerical algorithm, provides only an approximation. The accuracy of this approximation is determined by the value of tolerance (<span class="sans_thesansmonocd_w5regular_">TOL</span>), which can be adjusted to make the approximation more or less precise.</p>
<p class="tx">Keep in mind that a more accurate square root approximation will take longer to compute since the algorithm needs to go through more iterations. This sort of trade-off between accuracy and computational time is common.</p>
<p class="headaexercise" id="pre-10"><span class="sans_dogma_ot_bold_b_15-n">Project 10: Create Pythagorean Triples with Euclid’s Formula</span></p>
<p class="tni">Pythagoras was a Greek philosopher and mathematician who lived in the sixth century <small class="calibre12">BCE</small>. He believed in the idea of a harmonious universe and saw numbers, mathematics, and geometry as key elements in revealing the universe’s mysteries. He’s best known for the Pythagorean theorem, which states that in a right-angled triangle, the square of the length of the hypotenuse is equal to the sum of the squares of the other two sides (see <a href="chapter4.xhtml#fig4-1" class="calibre2">Figure 4-1</a>). Perhaps you’ve seen this theorem summarized as <i class="calibre9">a</i><sup class="calibre8">2</sup> + <i class="calibre9">b</i><sup class="calibre8">2</sup> = <i class="calibre9">c</i><sup class="calibre8">2</sup>.</p>
<p class="tx"><i class="calibre9">Pythagorean triples</i> are sets of three positive integers (<i class="calibre9">a</i>, <i class="calibre9">b</i>, <i class="calibre9">c</i>) that satisfy the Pythagorean theorem. A familiar example is (3, 4, 5): 3<sup class="calibre8">2</sup> + 4<sup class="calibre8">2</sup> equals 9 + 16, which equals 25, or 5<sup class="calibre8">2</sup>. Pythagorean triples are used in many areas of mathematics, science, and engineering, including geometry, number theory, cryptography, physics, and computer graphics. Throughout history, mathematicians have come up with different ways of generating Pythagorean triples. In this project, we’ll check out one of the earliest methods, Euclid’s formula, and use it to create Pythagorean triples. Here are the steps involved:</p>
<p class="listnumber">  1.  Choose an arbitrary positive integer <span class="copyright_italic">k</span>.</p>
<p class="listnumber1">  2.  Choose a pair of positive integers <span class="copyright_italic">m</span> and <span class="copyright_italic">n</span>, such that <span class="copyright_italic">m</span> &gt; <span class="copyright_italic">n</span> &gt; 0.</p>
<p class="listnumber1">  3.  Calculate <span class="copyright_italic">a</span> = <span class="copyright_italic">k</span>(<span class="copyright_italic">m</span><sup class="calibre8">2</sup> – <span class="copyright_italic">n</span><sup class="calibre8">2</sup>), <span class="copyright_italic">b</span> = 2<span class="copyright_italic">kmn</span>, and <span class="copyright_italic">c</span> = <span class="copyright_italic">k</span>(<span class="copyright_italic">m</span><sup class="calibre8">2</sup> + <span class="copyright_italic">n</span><sup class="calibre8">2</sup>).</p>
<p class="listnumber2">  4.  The values <span class="copyright_italic">a</span>, <span class="copyright_italic">b</span>, and <span class="copyright_italic">c</span> form a Pythagorean triple (<span class="copyright_italic">a</span>, <span class="copyright_italic">b</span>, <span class="copyright_italic">c</span>).</p>
<span aria-label="131" epub:type="pagebreak" id="pg_131" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img3" height="615" id="fig4-1" src="../images/Figure4-1.jpg" width="940"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 4-1: The Pythagorean theorem</span></p></figcaption>
</figure>
<p class="tx">A Pythagorean triple is considered <i class="calibre9">primitive</i> if its members are all coprime, meaning they share no common factors other than 1. For example, (3, 4, 5) and (6, 8, 10) are both Pythagorean triples, but only (3, 4, 5) is primitive, since 6, 8, and 10 have a common factor of 2. Euclid’s formula will generate a primitive Pythagorean triple if and only if the two integers <i class="calibre9">m</i> and <i class="calibre9">n</i> are coprime, and one of them is even. If both <i class="calibre9">m</i> and <i class="calibre9">n</i> are odd, then the values of <i class="calibre9">a</i>, <i class="calibre9">b</i>, and <i class="calibre9">c</i> will all be even, and the triple won’t be primitive. However, as long as <i class="calibre9">m</i> and <i class="calibre9">n</i> are coprime, dividing the values of <i class="calibre9">a</i>, <i class="calibre9">b</i>, and <i class="calibre9">c</i> by 2 will result in a primitive Pythagorean triple.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1"><span id="sec3"/><span id="h2-64"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Here’s a Kotlin function that generates a Pythagorean triple using Euclid’s formula:</p>
<pre class="calibre10"><code class="calibre11">fun generatePythagoreanTriple(m: Int, n: Int):
    Triple&lt;Int, Int, Int&gt; {
    val a = m * m - n * n
    val b = 2 * m * n
    val c = m * m + n * n
    return Triple(a, b, c)
}</code></pre>
<p class="tx">The function takes in two integers <i class="calibre9">m</i> and <i class="calibre9">n</i>, then uses them to calculate and return <i class="calibre9">a</i>, <i class="calibre9">b</i>, and <i class="calibre9">c</i>. By not explicitly including a value for <i class="calibre9">k</i> here, we’re implicitly assuming <i class="calibre9">k</i> = 1.</p>
<p class="tx">We can call this function repeatedly from the <span class="sans_thesansmonocd_w5regular_">main()</span> function, using a <span class="sans_thesansmonocd_w5regular_">for</span> loop to generate Pythagorean triples for an arbitrary number of pairs of successive integers, as shown in the following code:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    var m = 2               // value of m
    var n = 1               // value of n
    val numTriples = 10     // number of triples

<span aria-label="132" epub:type="pagebreak" id="pg_132" role="doc-pagebreak"/>    println("\n*** Pythagorean Triples Using Euclid's Formula ***\n")
    println("Number of Pythagorean triples: $numTriples\n")

    // Generate the first "numTriples" triples.
    for (i in 1..numTriples) {
        val pythagoreanTriple =
            generatePythagoreanTriple(m, n)
        print("i=${"%2d".format(i)}    " +
              "m=${"%2d".format(m)}    n=${"%2d".format(n)}  ")
        println("Pythagorean triple: $pythagoreanTriple")
        n++
        m++
    }
}</code></pre>
<p class="tx">Notice that the first triple is generated using an <span class="sans_thesansmonocd_w5regular_">m</span> of <span class="sans_thesansmonocd_w5regular_">2</span> and an <span class="sans_thesansmonocd_w5regular_">n</span> of <span class="sans_thesansmonocd_w5regular_">1</span>. These are the smallest possible values of <span class="sans_thesansmonocd_w5regular_">m</span> and <span class="sans_thesansmonocd_w5regular_">n</span>. (Recall the stipulation in Euclid’s formula that <i class="calibre9">m</i> and <i class="calibre9">n</i> must be positive integers such that <i class="calibre9">m</i> &gt; <i class="calibre9">n</i> &gt; 0.) These values are passed on as arguments to the <span class="sans_thesansmonocd_w5regular_">generatePythagoreanTriple()</span> function, which returns the elements of the Pythagorean triple as a <span class="sans_thesansmonocd_w5regular_">Triple</span> object in Kotlin. Successive inputs are generated by incrementing both <span class="sans_thesansmonocd_w5regular_">m</span> and <span class="sans_thesansmonocd_w5regular_">n</span> inside the <span class="sans_thesansmonocd_w5regular_">for</span> loop that repeats <span class="sans_thesansmonocd_w5regular_">numTriples</span> times. Since <span class="sans_thesansmonocd_w5regular_">m</span> and <span class="sans_thesansmonocd_w5regular_">n</span> are consecutive, one of them will always be even, and they can’t possibly share any factors, so every triple will be primitive.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1"><span id="sec4"/><span id="h2-65"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">If you don’t change any of the program parameters, the program will produce the following output that shows the first 10 Pythagorean triples:</p>
<pre class="calibre10"><code class="calibre11">*** Pythagorean Triples Using Euclid's Formula ***

Number of Pythagorean triples: 10

i= 1    m= 2    n= 1  Pythagorean triple: (3, 4, 5)
i= 2    m= 3    n= 2  Pythagorean triple: (5, 12, 13)
i= 3    m= 4    n= 3  Pythagorean triple: (7, 24, 25)
i= 4    m= 5    n= 4  Pythagorean triple: (9, 40, 41)
i= 5    m= 6    n= 5  Pythagorean triple: (11, 60, 61)
i= 6    m= 7    n= 6  Pythagorean triple: (13, 84, 85)
i= 7    m= 8    n= 7  Pythagorean triple: (15, 112, 113)
i= 8    m= 9    n= 8  Pythagorean triple: (17, 144, 145)
i= 9    m=10    n= 9  Pythagorean triple: (19, 180, 181)
i=10    m=11    n=10  Pythagorean triple: (21, 220, 221)</code></pre>
<p class="tx">In this example, the starting values of <span class="sans_thesansmonocd_w5regular_">m</span> and <span class="sans_thesansmonocd_w5regular_">n</span> were hardcoded in the <span class="sans_thesansmonocd_w5regular_">main()</span> function. You might modify the code to allow the user to input values of <span class="sans_thesansmonocd_w5regular_">m</span> and <span class="sans_thesansmonocd_w5regular_">n</span> (ensuring <i class="calibre9">m</i> &gt; <i class="calibre9">n</i> &gt; 0). That would allow the user to generate a wider range of Pythagorean triples based on their requirements.</p>
<p class="headaexercise" id="pre-11"><span aria-label="133" epub:type="pagebreak" id="pg_133" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_15-n">Project 11: Identify Prime Numbers with the Sieve of Eratosthenes</span></p>
<p class="tni">Eratosthenes was an ancient Greek scholar who lived in the third century <small class="calibre12">BCE</small>. He was an accomplished mathematician, astronomer, geographer, and poet. In this project, we’ll explore one of Eratosthenes’s many mathematical discoveries: the <i class="calibre9">sieve of Eratosthenes</i>, an intuitive algorithm for identifying all the prime numbers up to a given limit. (We’ll explore another of his ingenious discoveries in the next project.) It’s remarkable to think that Eratosthenes conceived this strategy more than two millennia ago, during a time when few individuals could read or write, let alone think about algorithms and solve abstract mathematical problems.</p>
<aside aria-label="box-22" class="box">
<p class="boxtitle" id="box-22"><span class="sans_futura_std_bold_b_">WHAT IS A PRIME NUMBER?</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">A</span> <span class="sans_futura_std_book_oblique_">prime number</span> <span class="sans_futura_std_book_">is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself. In other words, the number can be divided evenly only by 1 and itself. For example, 5 is a prime number because it can be divided evenly only by 1 and 5. It has no other positive integer divisors. On the other hand, 6 isn’t a prime number, because it can be divided evenly by 1, 2, 3, and 6. Instead, we call it a</span> <span class="sans_futura_std_book_oblique_">composite number</span><span class="sans_futura_std_book_">. The first several prime numbers are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, and so on. Prime numbers have many interesting properties and play a central role in number theory and cryptography, among other fields.</span></p>
</aside>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h1"><span id="sec5"/><span id="h2-66"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">To sieve for primes like Eratosthenes, start by creating a list of all integers from 2 up to some limit. Then, starting from 2, iteratively mark off all multiples of each prime number as composite. The unmarked numbers that remain at the end of the process are all prime numbers. Here are the steps to implement this algorithm:</p>
<p class="listnumber">  1.  Create a list of consecutive integers from 2 through the given limit.</p>
<p class="listnumber1">  2.  Starting with 2 (the first prime number), mark all its multiples as composite.</p>
<p class="listnumber1">  3.  Find the next number in the list that isn’t marked as composite. This will be the next prime number.</p>
<p class="listnumber1">  4.  Mark all multiples of the prime number found in step 3 as composite.</p>
<p class="listnumber1">  5.  Repeat steps 3 and 4 until the square of the next prime number exceeds the given limit.</p>
<p class="listnumber2">  6.  The unmarked numbers in the list are all prime numbers.</p>
<p class="tx"><span aria-label="134" epub:type="pagebreak" id="pg_134" role="doc-pagebreak"/>We can optimize the sieve algorithm by marking multiples of each prime number, starting from its square. For example, when marking multiples of 3, we can start at 3<sup class="calibre8">2</sup> = 9, since all multiples of 3 less than 9 will already have been marked as composite. In this case, 6 will have been marked while going through the multiples of 2. Similarly, when we get to multiples of 5, we can skip 10, 15, and 20 as being multiples of either 2 or 3 and start marking off composites from 25.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="h1"><span id="sec6"/><span id="h2-67"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">As before, we’ll start by writing a function to implement the algorithm and then use the <span class="sans_thesansmonocd_w5regular_">main()</span> function to call this function and list the prime numbers. Here’s the Kotlin code for the <span class="sans_thesansmonocd_w5regular_">sieveOfEratosthenes()</span> function:</p>
<pre class="calibre10"><code class="calibre11">fun sieveOfEratosthenes(n: Int): List&lt;Int&gt; {
    // Create a Boolean array with all values set to true.
    val primes = BooleanArray(n + 1) {true}
    // Create a mutable list of integers to save prime numbers.
    val primeNumbers = mutableListOf&lt;Int&gt;()

    // Set 0 and 1 to not be prime.
    primes[0] = false
    primes[1] = false

    // Iterate over all numbers until i^2 &gt; N.
    var i = 2
  <span aria-label="annotation1" class="code_codeannotation">❶</span> while (i*i &lt;= n) {
        // If i is prime, mark all multiples of i as not prime.
      <span aria-label="annotation2" class="code_codeannotation">❷</span> if (primes[i]) {
          <span aria-label="annotation3" class="code_codeannotation">❸</span> for (j in i * i..n step i) {
                primes[j] = false
            }
        }
        i++
    }

    // Collect all prime numbers into a list and return it.
  <span aria-label="annotation4" class="code_codeannotation">❹</span> for ((index, value) in primes.withIndex())
        if (value) primeNumbers.add(index)

  <span aria-label="annotation5" class="code_codeannotation">❺</span> return primeNumbers
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">sieveOfEratosthenes()</span> function takes an integer <span class="sans_thesansmonocd_w5regular_">n</span> as input and returns a list of prime numbers up to <span class="sans_thesansmonocd_w5regular_">n</span>. For that, the function creates a Boolean array <span class="sans_thesansmonocd_w5regular_">primes</span> with a length of <span class="sans_thesansmonocd_w5regular_">n</span> <span class="sans_thesansmonocd_w5regular_">+</span> <span class="sans_thesansmonocd_w5regular_">1</span> and initializes each element’s value to <span class="sans_thesansmonocd_w5regular_">true</span>. Over the course of the function, we’ll change elements to <span class="sans_thesansmonocd_w5regular_">false</span> if their indices aren’t prime. The function also creates a mutable list <span class="sans_thesansmonocd_w5regular_">primeNumbers</span> of type <span class="sans_thesansmonocd_w5regular_">Int</span> to save the prime numbers.</p>
<p class="tx"><span aria-label="135" epub:type="pagebreak" id="pg_135" role="doc-pagebreak"/>To begin, we set the first two values of the <span class="sans_thesansmonocd_w5regular_">primes</span> array to <span class="sans_thesansmonocd_w5regular_">false</span> because 0 and 1 aren’t prime. We then iterate over the numbers from <span class="sans_thesansmonocd_w5regular_">2</span> to the square root of <span class="sans_thesansmonocd_w5regular_">n</span> (we do this by ensuring <span class="sans_thesansmonocd_w5regular_">i*i &lt;=</span> <span class="sans_thesansmonocd_w5regular_">n</span>) <span aria-label="annotation1" class="codeannotation">❶</span>. For each number <span class="sans_thesansmonocd_w5regular_">i</span> in this range, if <span class="sans_thesansmonocd_w5regular_">i</span> is marked as prime (that is, <span class="sans_thesansmonocd_w5regular_">true</span>) in the <span class="sans_thesansmonocd_w5regular_">primes</span> array <span aria-label="annotation2" class="codeannotation">❷</span>, the function marks all multiples of <span class="sans_thesansmonocd_w5regular_">i</span> in the <span class="sans_thesansmonocd_w5regular_">primes</span> array as composite (<span class="sans_thesansmonocd_w5regular_">false</span>). To reach all the multiples of <span class="sans_thesansmonocd_w5regular_">i</span>, we use a <span class="sans_thesansmonocd_w5regular_">for</span> loop with a step size of <span class="sans_thesansmonocd_w5regular_">i</span> <span aria-label="annotation3" class="codeannotation">❸</span>.</p>
<p class="tx">To collect the prime numbers, we use a <span class="sans_thesansmonocd_w5regular_">for</span> loop <span aria-label="annotation4" class="codeannotation">❹</span> to go over all <span class="sans_thesansmonocd_w5regular_">primes</span> elements and add the corresponding index to <span class="sans_thesansmonocd_w5regular_">primeNumbers</span> when the value of the element is <span class="sans_thesansmonocd_w5regular_">true</span>. Finally, we return the prime numbers to <span class="sans_thesansmonocd_w5regular_">main()</span> as a list of integers for postprocessing <span aria-label="annotation5" class="codeannotation">❺</span>.</p>
<p class="tx">Now that our sieving function is good to go, we can use the <span class="sans_thesansmonocd_w5regular_">main()</span> function to retrieve a list of prime numbers up to <span class="sans_thesansmonocd_w5regular_">n</span> and print it out. We’ll also create a <span class="sans_thesansmonocd_w5regular_">printPrimes()</span> helper function to manage the printing.</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    println("\n*** Find All Prime Numbers Up to 'n' ***\n")
    println("Enter a number &gt; 2 to generate the list of primes:")
    val num = readln().toInt()
    println("You have entered: $num")

    val primeNumbers = sieveOfEratosthenes(num)
    println("\nThe prime numbers &lt;= $num are:")
    printPrimes(primeNumbers)
}

fun printPrimes(primeNumbers: List&lt;Int&gt;) {
    for (i in primeNumbers.indices) {
        if (i != 0 &amp;&amp; i % 6 == 0) println()
        print("${"%8d".format(primeNumbers[i])} ")
    }
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">main()</span> function is similar to the one we used for the Babylonian square root algorithm in <span><a href="chapter4.xhtml#pre-9" class="calibre2">Project 9</a></span>. It takes a user input for the limit <span class="sans_thesansmonocd_w5regular_">num</span>, uses it to create a list of prime numbers with the <span class="sans_thesansmonocd_w5regular_">sieveOfEratosthenes()</span> function, and then calls <span class="sans_thesansmonocd_w5regular_">printPrimes()</span> to print the list. To make the output look nice, <span class="sans_thesansmonocd_w5regular_">printPrimes()</span> organizes the numbers into rows of six and uses string formatting to create neatly aligned columns.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="h1"><span id="sec7"/><span id="h2-68"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">Here’s a look at the program output up to an arbitrary limit <span class="sans_thesansmonocd_w5regular_">num</span> of <span class="sans_thesansmonocd_w5regular_">251</span>:</p>
<pre class="calibre10"><code class="calibre11">*** Find All Prime Numbers Up to 'n' ***

Enter a number &gt; 2 to generate the list of primes:
<b class="calibre6">251</b>
You have entered: 251

<span aria-label="136" epub:type="pagebreak" id="pg_136" role="doc-pagebreak"/>The prime numbers &lt;= 251 are:
       2        3        5        7       11       13
      17       19       23       29       31       37
      41       43       47       53       59       61
      67       71       73       79       83       89
      97      101      103      107      109      113
     127      131      137      139      149      151
     157      163      167      173      179      181
     191      193      197      199      211      223
     227      229      233      239      241      251</code></pre>
<p class="tx">Other methods for generating prime numbers include the sieve of Sundaram, the sieve of Atkin, and trial division. I encourage you to do some online research and experiment with these methods to enhance your Kotlin coding skills and gain additional insight into prime number generation.</p>
<p class="headaexercise" id="pre-12"><span class="sans_dogma_ot_bold_b_15-n">Project 12: Calculate Earth’s Circumference the Ancient Way</span></p>
<p class="tni">One of Eratosthenes’s most famous achievements was calculating Earth’s circumference. He accomplished this by measuring the angle of the sun’s rays at noon on the summer solstice at two locations, Alexandria and Syene (modern-day Aswan), which were known to be on the same meridian, or longitude. <a href="chapter4.xhtml#fig4-2" class="calibre2">Figure 4-2</a> shows an abstraction of some of the geometry involved in this brilliant experiment.</p>
<figure class="img"><img alt="" class="img3" height="637" id="fig4-2" src="../images/Figure4-2.jpg" width="673"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 4-2: Measuring Earth’s circumference</span></p></figcaption>
</figure>
<p class="tx">In this diagram, we can think of points E and B as two locations on Earth’s surface (for example, Alexandria and Syene). We’ll assume for the sake of simplicity that Earth is a perfect sphere and that both of these locations are on the same meridian. Let’s also assume that <i class="calibre9">AB</i> and <i class="calibre9">DE</i> are two tall poles or towers that are sufficiently far apart that when extended to Earth’s center (C), they create a small but measurable angle <i class="calibre9"><span lang="el" xml:lang="el">α</span></i>. Two parallel rays coming from the sun just miss the tops of the poles and will hit the ground at slightly different angles. Because Earth’s surface is curved, <span aria-label="137" epub:type="pagebreak" id="pg_137" role="doc-pagebreak"/>the angle <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><sub class="calibre19">2</sub> between ray 2 and <i class="calibre9">DE</i> will be slightly greater than the angle <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><sub class="calibre19">1</sub> between ray 1 and <i class="calibre9">AB</i>. As a result, the shadow of <i class="calibre9">DE</i> on the ground will be longer than that of <i class="calibre9">AB</i>, even if the poles themselves have the same height.</p>
<p class="tx">We also assume that at both locations the poles are positioned vertically relative to the ground surface, which can be thought of as flat in the vicinity of the poles. This last assumption allows us to measure the angle of a ray of light relative to a pole. Assuming that the length of the shadow is <i class="calibre9">s</i> and the height of the pole is <i class="calibre9">h</i>, the angle <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> between the ray and the pole can be expressed as follows:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>θ</mi><mo>=</mo><msup><mrow><mi>tan</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mfenced><mrow><mfrac><mi>s</mi><mi>h</mi></mfrac></mrow></mfenced></mrow></math> (4.1)</span>
<span class="mobi"><img alt="" class="img1" height="64" src="../images/eq4-1.jpg" width="1389"/></span></figure>
<p class="tx">Finally, consider triangle <i class="calibre9">ACF</i> in <a href="chapter4.xhtml#fig4-2" class="calibre2">Figure 4-2</a>. According to the <i class="calibre9">exterior angle theorem</i>, the triangle’s exterior angle <i class="calibre9">AFE</i> must be equal to the sum of the two interior opposite angles, <i class="calibre9">ACF</i> and <i class="calibre9">CAF</i>. Meanwhile, <i class="calibre9">AFE</i> and <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><sub class="calibre19">2</sub> are equal because these are the <i class="calibre9">alternate interior angles</i> of the line <i class="calibre9">DF</i> that intersects the two parallel solar rays. Therefore, the following must be true:</p>
<p class="equation"><span class="copyright_accent">  ∠</span><i class="calibre9">AFE</i> = <span class="copyright_accent">∠</span><i class="calibre9">ACF</i> + <span class="copyright_accent">∠</span><i class="calibre9">CAF</i></p>
<p class="equation"><i class="calibre9">  <span lang="el" xml:lang="el">θ</span></i><sub class="calibre19">2</sub> = <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><sub class="calibre19">1</sub> + <i class="calibre9"><span lang="el" xml:lang="el">α</span></i></p>
<p class="tni">Rearranging the latter, we get:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>α</mi><mtext> </mtext><mtext/><mtext/><mtext> </mtext><mo>=</mo><msub><mi>θ</mi><mn>2</mn></msub><mo>−</mo><msub><mi>θ</mi><mn>1</mn></msub></mrow></math> (4.2)</span>
<span class="mobi"><img alt="" class="img1" height="45" src="../images/eq4-2.jpg" width="1389"/></span></figure>
<p class="tx">This final equation is what we need to estimate Earth’s circumference. We’ll achieve that by using another geometric relationship that connects the length <i class="calibre9">d</i> of an arc of a circle to the angle <i class="calibre9"><span lang="el" xml:lang="el">α</span></i> (in radians) that the arc creates at the center of the circle:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mfrac><mi>α</mi><mi>d</mi></mfrac><mo>=</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow><mrow><mtext>Circumference</mtext></mrow></mfrac></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="72" src="../images/pg137-1.jpg" width="1389"/></span></figure>
<p class="tni">Solving for the circumference gives us this equation:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mtext>Circumference</mtext><mtext> </mtext><mtext>=</mtext><mtext> </mtext><mfrac><mrow><mn>2</mn><mtext>π</mtext><mi>d</mi></mrow><mi>α</mi></mfrac></mrow></math> (4.3)</span>
<span class="mobi"><img alt="" class="img1" height="72" src="../images/eq4-3.jpg" width="1389"/></span></figure>
<p class="tx">What Eratosthenes did was quite ingenious. He knew that at noon on the summer solstice, the sun would be directly overhead at Syene (point B in <a href="chapter4.xhtml#fig4-2" class="calibre2">Figure 4-2</a>), so a vertical pole there would cast no shadow, meaning <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><sub class="calibre19">1</sub> = 0, and therefore <i class="calibre9"><span lang="el" xml:lang="el">α</span></i> = <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><sub class="calibre19">2</sub> per Equation 4.2. In Alexandria (point E), however, the sun would be at an angle, so a pole would cast a shadow on the ground. By measuring the length of this shadow, Eratosthenes was able to calculate the angle between the sun’s ray (ray 2) and the pole (<i class="calibre9">DE</i>) using Equation 4.1. He found this angle to be about 7.2 degrees, or 0.12566370614 radians.</p>
<p class="tx">Eratosthenes was aware of the distance between Alexandria and Syene—he estimated it to be 5,000 stadia (about 800 kilometers). With this information and the angle of the shadow, he calculated Earth’s circumference (using Equation 4.3) and arrived at a value of approximately 40,000 kilometers. Once <span aria-label="138" epub:type="pagebreak" id="pg_138" role="doc-pagebreak"/>he determined the circumference, he could also calculate Earth’s radius. For any circle, the radius <i class="calibre9">r</i> can be calculated from the circumference as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>r</mi><mo>=</mo><mfrac><mrow><mtext>Circumference</mtext></mrow><mrow><mn>2</mn><mi>π</mi></mrow></mfrac></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="73" src="../images/pg138-1.jpg" width="1388"/></span></figure>
<p class="tni">Filling in the circumference formula from Equation 4.3, Earth’s radius <i class="calibre9">R</i> is:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>R</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mfrac><mi>d</mi><mi>α</mi></mfrac></mrow></math> (4.4)</span>
<span class="mobi"><img alt="" class="img1" height="73" src="../images/eq4-4.jpg" width="1388"/></span></figure>
<p class="tx">This calculation gave Eratosthenes a value of 6,370 kilometers, which is remarkably close to the actual value of approximately 6,371 kilometers.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h1"><span id="sec8"/><span id="h2-69"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Let’s write some code to imitate the method Eratosthenes used to calculate Earth’s circumference and radius. We’ll make our program more flexible by allowing the sun to not be directly overhead at the first location. To do this, we’ll use Equation 4.1 to figure out the shadow angles, Equation 4.2 to get the arc angle, Equation 4.3 to calculate the circumference, and finally, Equation 4.4 to calculate the radius.</p>
<pre class="calibre10"><code class="calibre11">import kotlin.math.atan

data class Earth(
    val alpha: Double,
    val circumference: Int,
    val radius: Int
)

fun calculateEarthMetrics(s1: Double, h1: Double,
                          s2: Double, h2: Double, d: Double): Earth {
    // Calculate the angles of the shadows.
    val theta1 = atan(s1 / h1)
    val theta2 = atan(s2 / h2)

    // Calculate the angle at the center of Earth.
    val alpha = theta2 - theta1

    // Calculate the circumference and radius.
    val circumference = (2 * Math.PI * d / alpha).toInt()
    val radius = (d / alpha).toInt()

    return Earth(alpha, circumference, radius)
}

fun main() {
    // known values
    val shadow1 = 0.0    // m
    val height1 = 7.0    // m
    val shadow2 = 0.884  // m
    val height2 = 7.0    // m
    val distanceBetweenCities = 800.0 // in km
    val (alpha, circumference, radius) =
<span aria-label="139" epub:type="pagebreak" id="pg_139" role="doc-pagebreak"/>        calculateEarthMetrics(s1=shadow1, h1=height1,
            s2=shadow2, h2=height2,
            d=distanceBetweenCities)

    // Output the estimated circumference and radius.
    println("\n*** Measuring Earth's Circumference and Radius ***\n")
    println("Angle (alpha): ${"%7.5f".format(alpha)} radian")
    println("Circumference: $circumference kilometers")
    println("Radius: $radius kilometers")
}</code></pre>
<p class="tx">The code segment starts by importing the required math function and defining a data class <span class="sans_thesansmonocd_w5regular_">Earth</span> with three properties: <span class="sans_thesansmonocd_w5regular_">alpha</span>, <span class="sans_thesansmonocd_w5regular_">circumference</span>, and <span class="sans_thesansmonocd_w5regular_">radius</span>. This data class allows us to conveniently package up the values estimated inside the <span class="sans_thesansmonocd_w5regular_">calculateEarthMetrics()</span> function and return them via a single <span class="sans_thesansmonocd_w5regular_">Earth</span> object.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">calculateEarthMetrics()</span> function has five named parameters that represent the shadow lengths (<span class="sans_thesansmonocd_w5regular_">s1</span> and <span class="sans_thesansmonocd_w5regular_">s2</span>) and heights (<span class="sans_thesansmonocd_w5regular_">h1</span> and <span class="sans_thesansmonocd_w5regular_">h2</span>) for the two locations, and the distance (<span class="sans_thesansmonocd_w5regular_">d</span>) between these two locations. Then the function follows the steps described on <span><a href="#pg_137" class="calibre2">page 137</a></span>: calculating <span class="sans_thesansmonocd_w5regular_">theta1</span> and <span class="sans_thesansmonocd_w5regular_">theta2</span>, using them to calculate <span class="sans_thesansmonocd_w5regular_">alpha</span>, and using <span class="sans_thesansmonocd_w5regular_">alpha</span> to estimate <span class="sans_thesansmonocd_w5regular_">circumference</span> and <span class="sans_thesansmonocd_w5regular_">radius</span>. Since these are large numbers (when expressed in kilometers), we convert both <span class="sans_thesansmonocd_w5regular_">circumference</span> and <span class="sans_thesansmonocd_w5regular_">radius</span> into integers (which is how they were defined in the <span class="sans_thesansmonocd_w5regular_">Earth</span> class).</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">main()</span> function’s job is quite simple: call the <span class="sans_thesansmonocd_w5regular_">calculateEarthMetrics()</span> function; receive the values of <span class="sans_thesansmonocd_w5regular_">alpha</span>, <span class="sans_thesansmonocd_w5regular_">circumference</span>, and <span class="sans_thesansmonocd_w5regular_">radius</span> by deconstructing the returned object; and print them with appropriate annotations and format.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="h1"><span id="sec9"/><span id="h2-70"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">For the given parameter values in this example—the same ones Eratosthenes used—the output of our program looks like this:</p>
<pre class="calibre10"><code class="calibre11">*** Measuring Earth's Circumference and Radius ***

Angle (alpha): 0.12562 radian
Circumference: 40013 kilometers
Radius: 6368 kilometers</code></pre>
<p class="tx">Feel free to use this tool to experiment with different parameter values. For example, you could try using shadow lengths and angles measured on an exoplanet and find out how large or small the planet is!</p>
<p class="headaexercise" id="pre-13"><span class="sans_dogma_ot_bold_b_15-n">Project 13: Code the Fibonacci Sequence</span></p>
<p class="tni">Leonardo of Pisa, commonly known as Fibonacci, was an Italian mathematician born c. 1170. From an early age, he showed a keen interest in mathematics, and his travels to North Africa and the Middle East exposed <span aria-label="140" epub:type="pagebreak" id="pg_140" role="doc-pagebreak"/>him to advanced mathematical concepts that weren’t yet known in Europe. Fibonacci’s most significant contribution to mathematics was the introduction of the Indo-Arabic numeral system to the Western world, which included the use of zero. This system replaced the previously used Roman numerals and revolutionized arithmetic calculations, making them significantly more efficient.</p>
<p class="tx">Fibonacci is widely recognized for introducing the Fibonacci sequence, a series of numbers where each number is the sum of the two preceding numbers. To explain this concept in his book <i class="calibre9">Liber Abaci</i>, Fibonacci used a colorful analogy involving a pair of rabbits. Imagine placing a pair of rabbits in an enclosed area. The rabbits can mate when they’re one month old and can produce a new pair of rabbits when they’re two months old. Therefore, it takes one month for each new pair to mature and an additional month to give birth to a new pair. If the rabbits never die and the mating continues, how many pairs of rabbits will there be after each month?</p>
<p class="tx">The solution to this problem forms the Fibonacci sequence. If we start with (1, 1) representing the starting pair over the first two months, the sequence will look like this: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so on. These numbers can be linked to Fibonacci’s rabbit example as explained in <a href="chapter4.xhtml#tab4-1" class="calibre2">Table 4-1</a>.</p>
<p class="tt" id="tab4-1"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 4-1:</span></span> <span class="sans_futura_std_book_">Fibonacci’s Rabbits</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Month</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Young pairs</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Mature pairs</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Total pairs</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Explanation</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">0</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">0</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Start with a newborn pair, no mature pair, and no offspring.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">0</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">The first pair becomes mature and will reproduce at the end of this period.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">The first pair of offspring is born. One mature pair will reproduce again at the end of this period.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">The second pair of offspring is born. Two mature pairs will reproduce at the end of this period.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">4</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Two new pairs are born. Three mature pairs will reproduce at the end of this period.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">8</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Three new pairs are born. Five mature pairs will reproduce at the end of this period.</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">Say we want to determine how many rabbit pairs will exist after a certain number of generations. Here are the steps we can take, using the Fibonacci sequence:</p>
<p class="listnumber">  1.  Set the first two numbers in the sequence. By convention, these are usually 0 and 1 rather than 1 and 1.</p>
<p class="listnumber1">  2.  Add the first two numbers to get the third number in the sequence.</p>
<p class="listnumber1">  3.  Generate the next number by adding the two preceding numbers. This step can be mathematically expressed as <span class="copyright_italic">F</span><span class="epub-i-sub">n</span> = <span class="copyright_italic">F</span><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> + <span class="copyright_italic">F</span><span class="epub-i-sub">n</span> <sub class="calibre19">– 2</sub>, where <span class="copyright_italic">n</span> ≥ 2.</p>
<p class="listnumber2">  4.  Repeat step 3 until the stopping condition is met.</p>
<p class="tx"><span aria-label="141" epub:type="pagebreak" id="pg_141" role="doc-pagebreak"/>The Fibonacci sequence has become a classic example of recursive sequences and is used to illustrate many mathematical concepts in various fields. Before getting into how to code this sequence, I’ll introduce you to two other related concepts: the golden ratio and the Fibonacci spiral. These concepts will be illustrated in our Fibonacci code.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1"><span id="sec10"/><span id="h2-71"/><span class="sans_futura_std_bold_condensed_oblique_">The Golden Ratio</span></h4>
<p class="tni">The <i class="calibre9">golden ratio</i>, also known as the golden mean, is a mathematical ratio commonly found in nature, art, and architecture. The ratio is approximately 1.61803398875 and is denoted by the Greek letter <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i>.</p>
<p class="tx">The golden ratio is linked to the Fibonacci sequence: as the sequence continues, the ratio between each successive pair of numbers approaches the golden ratio. Starting with 1 (we can’t start with 0, as the ratio of 1 over 0 is infinity), if we calculate and plot this ratio for each successive pair, it will rapidly converge on <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i>, as shown in <a href="chapter4.xhtml#fig4-3" class="calibre2">Figure 4-3</a>.</p>
<figure class="img"><img alt="" class="img2" height="792" id="fig4-3" src="../images/Figure4-3.jpg" width="1157"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 4-3: Convergence to the golden ratio</span></p></figcaption>
</figure>
<p class="tx">Well-known manifestations of the golden ratio in nature include nautilus shells, the arrangements of seeds in a sunflower and scales on a pine cone, and the proportions of the human body (for example, the ratio of the length of the forearm to the hand, and the ratio of the overall height to the height of the navel). The ratio has also been extensively exploited by artists, musicians, photographers, product designers, and architects in their work. In architecture, for example, it might determine the ratio of width to height for a building’s facade.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1"><span id="sec11"/><span id="h2-72"/><span class="sans_futura_std_bold_condensed_oblique_">The Fibonacci Spiral</span></h4>
<p class="tni">The Fibonacci spiral is a geometric pattern derived from the Fibonacci sequence. It’s created by drawing a series of quarter circles inside squares <span aria-label="142" epub:type="pagebreak" id="pg_142" role="doc-pagebreak"/>that are based on the numbers in the Fibonacci sequence. To draw the Fibonacci spiral, follow these steps:</p>
<p class="listnumber">  1.  Draw a small square with a side length of 1.</p>
<p class="listnumber1">  2.  Draw another square of side length 1 adjacent to the first square, sharing a side.</p>
<p class="listnumber1">  3.  Draw a third square of side length 2 adjacent to the second square, sharing a side.</p>
<p class="listnumber1">  4.  Draw a fourth square of side length 3 adjacent to the third square, sharing a side.</p>
<p class="listnumber1">  5.  Continue this process, drawing squares with side lengths equal to the sum of the two preceding squares, adjacent to the last drawn square, sharing a side.</p>
<p class="listnumber2">  6.  Draw a quarter circle inside each of the squares, connecting the opposite corners of each square. The quarter circles will form a smooth curve: the Fibonacci spiral.</p>
<p class="tx">If you follow these steps and draw the spiral for the first eight numbers (starting from 1), the result will look like <a href="chapter4.xhtml#fig4-4" class="calibre2">Figure 4-4</a>.</p>
<figure class="img"><img alt="" class="img1" height="849" id="fig4-4" src="../images/Figure4-4.jpg" width="1559"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 4-4: A Fibonacci spiral for the first eight numbers</span></p></figcaption>
</figure>
<p class="tx">The Fibonacci spiral, often associated with the golden ratio, is a recurring pattern in nature, appearing in various forms such as seashells, leaf arrangements, and even the spirals of distant galaxies! While the golden ratio is not an absolute prerequisite for beauty or efficiency in design, it undeniably holds an enduring charm as a mathematical concept that continues to capture our imagination.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<span aria-label="143" epub:type="pagebreak" id="pg_143" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec12"/><span id="h2-73"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Generating and printing the Fibonacci sequence up to a certain limit can be accomplished with just a few lines of code. Let’s take this project a step further: along with generating the sequence itself, we’ll also draw the Fibonacci spiral. This way, we’ll be able to practice some of the data visualization techniques covered in the previous chapter and anticipate future projects where we’ll gain deeper insight into a problem by visualizing the program output.</p>
<section aria-labelledby="sec13" epub:type="division">
<h5 class="h2"><span id="sec13"/><span id="h3-25"/><span class="sans_futura_std_bold_b_">Setting Up</span></h5>
<p class="tni">To begin, we’ll write the global components of the code, including the import block needed for the visualization, the <span class="sans_thesansmonocd_w5regular_">FibonacciSpiral</span> application class, and the <span class="sans_thesansmonocd_w5regular_">main()</span> function.</p>
<pre class="calibre10"><code class="calibre11">import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.canvas.Canvas
import javafx.scene.canvas.GraphicsContext
import javafx.scene.layout.Pane
import javafx.scene.paint.Color
import javafx.scene.shape.ArcType
import javafx.scene.text.Font
import javafx.stage.Stage

// number of Fibonacci numbers in the list
val N = 9
val fibs = mutableListOf&lt;Int&gt;()

// canvas-related parameters
val canvasW = 1000.0
val canvasH = 750.0

// Scaling parameters: adjust as needed.
val xOffset = 150
val yOffset = 50
val amplify = 25.0

class FibonacciSpiral : Application() {
    override fun start(stage: Stage) {
        val root = Pane()
        val canvas = Canvas(canvasW, canvasH)
        val gc = canvas.graphicsContext2D
        gc.translate(canvas.width / 2 + xOffset,
            canvas.height / 2 + yOffset)
        root.children.add(canvas)

        val scene1 = Scene(root, canvasW, canvasH)
        scene1.fill = Color.WHITE
        with(stage) {
            title = "Fibonacci Spiral"
<span aria-label="144" epub:type="pagebreak" id="pg_144" role="doc-pagebreak"/>            scene = scene1
            show()
        }

        // code for Fibonacci sequence and spiral
        generateFibonacciNumbers()
        drawFibonacciSpiral(gc)
        printFibonacciSequenceAndRatios()
    }
}

fun main() {
    Application.launch(FibonacciSpiral::class.java)
}</code></pre>
<p class="tx">The code segment starts with an import block that provides access to a number of JavaFX graphics features that we’ll use to draw the Fibonacci spiral on a <span class="sans_thesansmonocd_w5regular_">canvas</span> object. See <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span> for a review of these features. Coding in IntelliJ IDEA means you don’t need to memorize which library features you need to import; as you use the default template and add code that may require additional graphics elements, the IDE will import those features automatically.</p>
<p class="tx">Following the import block, we set up some global parameters. First, we create a variable called <span class="sans_thesansmonocd_w5regular_">N</span> to set how far into the Fibonacci sequence we’ll go (starting from 0). Then, we create a mutable list of type <span class="sans_thesansmonocd_w5regular_">Int</span> named <span class="sans_thesansmonocd_w5regular_">fibs</span>, which will store the Fibonacci sequence as we calculate it. We also set several parameters to create a canvas where we’ll draw the Fibonacci spiral. To define the size of the canvas, we use the values <span class="sans_thesansmonocd_w5regular_">canvasW</span> and <span class="sans_thesansmonocd_w5regular_">canvasH</span>, and to set the starting location of the origin of the coordinate system, we use <span class="sans_thesansmonocd_w5regular_">xOffset</span> and <span class="sans_thesansmonocd_w5regular_">yOffset</span>. For this particular project, I’ve set the canvas size to 1,000 pixels wide and 750 pixels high, which should be suitable for most screen sizes and resolutions.</p>
<p class="tx">It’s important to note that the length of a line or the side of a rectangle on the canvas is measured in pixels. To plot the Fibonacci spiral, we’ll start with a square of size 1. However, drawing a square of 1 pixel would result in a tiny dot on the screen, which we don’t want. To avoid this, we’ll use an amplification factor called <span class="sans_thesansmonocd_w5regular_">amplify</span> and set it to <span class="sans_thesansmonocd_w5regular_">25</span>. Therefore, the first square will be 25 pixels in size, and all subsequent squares will be amplified by the same factor. This ensures that the end result is a Fibonacci spiral that fills the canvas nicely.</p>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">FibonacciSpiral</span> application class, we first create a layout container called <span class="sans_thesansmonocd_w5regular_">root</span> of type <span class="sans_thesansmonocd_w5regular_">Pane()</span>, which is the most basic layout container in JavaFX to hold and position nodes (user interface components) in a scene. We use <span class="sans_thesansmonocd_w5regular_">root</span> to hold the <span class="sans_thesansmonocd_w5regular_">canvas</span> on which the spiral will be drawn. Notice how we use the <span class="sans_thesansmonocd_w5regular_">translate</span> property of the graphics context <span class="sans_thesansmonocd_w5regular_">gc</span> to shift the initial position of the origin from the top-left corner (the default) to a position offset a bit from the middle of the canvas, where we’ll draw the first Fibonacci square (see <a href="chapter4.xhtml#fig4-4" class="calibre2">Figure 4-4</a> to get a sense of where that is). The rest of the class is routine JavaFX: we assign <span class="sans_thesansmonocd_w5regular_">canvas</span> to <span class="sans_thesansmonocd_w5regular_">root</span>, which is assigned to <span class="sans_thesansmonocd_w5regular_">scene1</span>, which connects to <span class="sans_thesansmonocd_w5regular_">stage</span>, the primary display window for this application.</p>
<p class="tx"><span aria-label="145" epub:type="pagebreak" id="pg_145" role="doc-pagebreak"/>Next, we move to the problem-specific segment of the application class, which consists of calls to three separate functions: <span class="sans_thesansmonocd_w5regular_">generateFibonacciNumbers()</span>, <span class="sans_thesansmonocd_w5regular_">drawFibonacciSpiral()</span>, and <span class="sans_thesansmonocd_w5regular_">printFibonacciSequenceAndRatios()</span>. These functions do exactly what their names suggest, and we’ll discuss them in detail shortly.</p>
<p class="tx">Finally, the <span class="sans_thesansmonocd_w5regular_">main()</span> function contains a single line of code that launches a JavaFX application by calling the <span class="sans_thesansmonocd_w5regular_">launch()</span> method of the <span class="sans_thesansmonocd_w5regular_">Application</span> class, passing it the <span class="sans_thesansmonocd_w5regular_">FibonacciSpiral</span> class as an argument.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h5 class="h2"><span id="sec14"/><span id="h3-26"/><span class="sans_futura_std_bold_b_">Generating the Fibonacci Sequence</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">generateFibonacciNumbers()</span> function generates the Fibonacci sequence as discussed earlier.</p>
<pre class="calibre10"><code class="calibre11">fun generateFibonacciNumbers() {
    // Add the starting pair.
    fibs.add(0)
    fibs.add(1)

    // Generate the sequence.
    for (i in 2 until N) {
        fibs.add(fibs[i-1] + fibs[i-2])
    }
}</code></pre>
<p class="tx">First, <i class="calibre9">F</i>(0) and <i class="calibre9">F</i>(1) are set to 0 and 1, respectively, and then the rest of the sequence is generated using <i class="calibre9">F</i><span class="epub-i-sub">n</span> = <i class="calibre9">F</i><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> + <i class="calibre9">F</i><span class="epub-i-sub">n</span> <sub class="calibre19">– 2</sub>, where <i class="calibre9">n</i> ≥ 2. We add all generated numbers to the mutable list <span class="sans_thesansmonocd_w5regular_">fibs</span> using its <span class="sans_thesansmonocd_w5regular_">fibs.add()</span> method.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h5 class="h2"><span id="sec15"/><span id="h3-27"/><span class="sans_futura_std_bold_b_">Drawing the Fibonacci Spiral</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">drawFibonacciSpiral()</span> function drives the process of drawing the Fibonacci spiral using the generated sequence of Fibonacci numbers, with support from two other helper functions that label each square with its corresponding Fibonacci number and draw the quarter circles.</p>
<pre class="calibre10"><code class="calibre11">fun drawFibonacciSpiral(gc: GraphicsContext) {
    for (i in 1 until N) {
      <span aria-label="annotation1" class="code_codeannotation">❶</span> val side = fibs[i] * amplify
      <span aria-label="annotation2" class="code_codeannotation">❷</span> with(gc) {
            strokeRect(0.0, 0.0, side, side)
            drawText(i, gc, side)
            drawArc(gc, side)
            // Move to the opposite corner by adding
            // side to both x- and y-coordinates.
            translate(side, side)
            // Rotate the axes counterclockwise.
            rotate(-90.0)
        }
    }
}

<span aria-label="146" epub:type="pagebreak" id="pg_146" role="doc-pagebreak"/>fun drawText(i: Int, gc: GraphicsContext, side: Double) {
    gc.fill = Color.BLACK
    with(gc) {
      <span aria-label="annotation3" class="code_codeannotation">❸</span> font = when {
            i &lt;= 2 -&gt; Font.font(12.0)
            else -&gt; Font.font(24.0)
        }
        fillText(fibs[i].toString(), side/2, side/2)
    }
}

fun drawArc(gc: GraphicsContext, side: Double) {
    val x = 0.0
    val y = -side
    with(gc) {
        lineWidth = 3.0
        strokeArc(x, y, 2*side, 2*side,
            -90.0, -90.0, ArcType.OPEN)
    }
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">drawFibonacciSpiral()</span> function uses a <span class="sans_thesansmonocd_w5regular_">for</span> loop that starts with <span class="sans_thesansmonocd_w5regular_">1</span> (we cannot draw a square of size <span class="sans_thesansmonocd_w5regular_">0</span>) to iterate over the sequence of numbers. In the loop, we retrieve the current number and multiply it by <span class="sans_thesansmonocd_w5regular_">amplify</span> to properly scale the squares on the screen <span aria-label="annotation1" class="codeannotation">❶</span>. Then we implement the rest of the process inside a <span class="sans_thesansmonocd_w5regular_">with(gc)</span> block <span aria-label="annotation2" class="codeannotation">❷</span> where we draw a square, annotate it, and draw an arc. At the end of each cycle, we move the canvas’s origin to the next location and rotate the coordinate system counterclockwise by 90 degrees. This way, the squares will spiral outward, as shown in <a href="chapter4.xhtml#fig4-4" class="calibre2">Figure 4-4</a>, but we’ll still be able to draw each one with the same <span class="sans_thesansmonocd_w5regular_">strokeRect(0.0, 0.0, side, side)</span> call.</p>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">drawText()</span> function, we use the argument <span class="sans_thesansmonocd_w5regular_">i</span>, which represents the index of the current Fibonacci number, to set the font size of the text used for annotation <span aria-label="annotation3" class="codeannotation">❸</span>. This ensures that the first two numbers fit inside a square of size 25 pixels. We then use the <span class="sans_thesansmonocd_w5regular_">fillText()</span> method of the graphics context <span class="sans_thesansmonocd_w5regular_">gc</span> to draw the number in the middle of its corresponding square.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">drawArc()</span> function sets up the parameter values needed by the <span class="sans_thesansmonocd_w5regular_">strokeArc()</span> method of the graphics context. These parameters include the top-left corner of the rectangle, its width and height, the starting angle with respect to the x-axis in degrees, and the length of the arc in degrees. We also specify the arc type as <span class="sans_thesansmonocd_w5regular_">OPEN</span>, which means the two endpoints won’t be connected with a line.</p>
<p class="tx">For drawing the arc, think of the imaginary box inside which the arc will be drawn as a stand-alone object that has its own coordinate system whose origin is at the center of the box. Inside this box, the positive x-axis points east and the positive y-axis points north. (Note that this isn’t the same as the default convention used by the JavaFX canvas.) Taking this into account, drawing an arc counterclockwise is considered the positive direction, and this is how the starting angle and arc length are specified. For example, we’ve specified the start angle as –90 degress and the arc length as –90 degrees (both in the clockwise direction relative to the positive x-axis). Alternatively, <span aria-label="147" epub:type="pagebreak" id="pg_147" role="doc-pagebreak"/>we could have specified the start angle as +180 degress and the arc angle as +90 degrees (both counterclockwise) to produce the same result.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h5 class="h2"><span id="sec16"/><span id="h3-28"/><span class="sans_futura_std_bold_b_">Printing the Sequence</span></h5>
<p class="tni">We have one more function that prints the Fibonacci sequence, as well as the ratios between successive terms in the sequence, to illustrate how these values converge on the golden ratio.</p>
<pre class="calibre10"><code class="calibre11">private fun printFibonacciSequenceAndRatios() {
    println("\n*** Fibonacci sequence and ratios ***\n")
    println("Length of Fibonacci sequence=${fibs.size}")
    println("Generated sequence:")
  <span aria-label="annotation1" class="code_codeannotation">❶</span> println(fibs)
    println("\nRatio F(n+1)/F(n) [starting from (1,1) pair]:")
    for (i in 2 until fibs.size) {
        println("%5d".format(fibs[i-1]) +
                "%5d".format(fibs[i]) +
                "%12.6f".format(fibs[i].toDouble()/fibs[i-1])
        )
    }
}</code></pre>
<p class="tx">The function first prints a header message and the length of the generated Fibonacci sequence. Next, it prints the generated sequence itself using <span class="sans_thesansmonocd_w5regular_">println()</span> <span aria-label="annotation1" class="codeannotation">❶</span>. Finally, a <span class="sans_thesansmonocd_w5regular_">for</span> loop calculates and prints the ratios of adjacent numbers in the sequence, using <span class="sans_thesansmonocd_w5regular_">format()</span> to show the values with appropriate spacing and precision.</p>
</section>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="h1"><span id="sec17"/><span id="h2-74"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">When you run the code, the text portion of the output should appear as follows:</p>
<pre class="calibre10"><code class="calibre11">*** Fibonacci sequence and ratios ***

Length of Fibonacci sequence=9
Generated sequence:
[0, 1, 1, 2, 3, 5, 8, 13, 21]

Ratio F(n+1)/F(n) [starting from (1,1) pair]:
    1    1    1.000000
    1    2    2.000000
    2    3    1.500000
    3    5    1.666667
    5    8    1.600000
    8   13    1.625000
   13   21    1.615385</code></pre>
<p class="tx">Notice how the ratios initially zigzag around the value of 1.61803398875 but quickly approach the golden ratio once we reach the 10th pair in the sequence.</p>
<p class="tx"><span aria-label="148" epub:type="pagebreak" id="pg_148" role="doc-pagebreak"/>Of course, the app also displays a beautiful Fibonacci spiral drawn on the canvas using JavaFX. It should look exactly like <a href="chapter4.xhtml#fig4-4" class="calibre2">Figure 4-4</a>—that figure was generated with this very code!</p>
<aside aria-label="box-23" class="box2">
<p class="boxtitle" id="box-23"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">A concept related to the Fibonacci sequence and the golden ratio is Pascal’s triangle, named after the French mathematician Blaise Pascal (although it was known to Chinese mathematicians over 500 years earlier). It has many interesting properties and applications in mathematics, including its use in calculating binomial coefficients, which arise in probability theory and other fields.</span></p>
<p class="box1"><span class="sans_futura_std_book_">Pascal’s triangle starts with a row containing a single number 1. Each subsequent row has one more number than the row above it. Each number is determined by adding the adjacent pair of numbers directly above it (except for a 1 on either end of each row). The first seven rows of Pascal’s triangle are shown here:</span></p>
<figure class="img4"><img alt="" class="img3" height="319" src="../images/pg148-1.jpg" width="484"/></figure>
<p class="box1"><span class="sans_futura_std_book_">Try writing the Kotlin code to generate Pascal’s triangle up to some arbitrary length (say, 10 rows). Display the result as text output formatted to look like a triangle.</span></p>
</aside>
<p class="headaexercise" id="pre-14"><span class="sans_dogma_ot_bold_b_15-n">Project 14: Find the Shortest Distance Between Two Locations on Earth</span></p>
<p class="tni">We use the Pythagorean theorem to calculate distances between points on the same plane. However, for points on Earth’s surface, this method isn’t accurate over long distances, because it doesn’t consider Earth’s curved shape. That’s where the <i class="calibre9">haversine formula</i> comes in. It calculates the shortest distance between two points on the surface of a sphere using the latitude and longitude coordinates of the points. In the case of Earth, the formula isn’t totally accurate, since Earth isn’t perfectly spherical, but it still offers a reasonable distance approximation for many practical applications, including in navigation, astronomy, and geography.</p>
<p class="tx">The haversine formula revolves around the concept of a <i class="calibre9">great circle</i>, the largest circle that can be drawn on a sphere. It’s formed by the intersection of the sphere’s surface with a plane that passes through the sphere’s center. <span aria-label="149" epub:type="pagebreak" id="pg_149" role="doc-pagebreak"/>The great circle divides the sphere into two equal halves, and its circumference matches the circumference of the sphere itself.</p>
<p class="tx"><a href="chapter4.xhtml#fig4-5" class="calibre2">Figure 4-5</a> showcases two prominent great circles: the equator and the prime meridian. The equator acts as a dividing line between the northern and southern hemispheres, while the prime meridian (which passes through Greenwich, England) separates the Eastern and Western Hemispheres on Earth’s surface. These two great circles serve as references for latitude and longitude, which together define the locations of points on Earth’s surface.</p>
<figure class="img"><img alt="" class="img1" height="733" id="fig4-5" src="../images/Figure4-5.jpg" width="1563"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 4-5: The latitude and longitude of a point P</span></p></figcaption>
</figure>
<p class="tx"><i class="calibre9">Latitude</i> measures the distance north or south of the equator. It’s expressed in degrees, with the equator being 0 degrees latitude, the North Pole 90 degrees north (90°N), and the South Pole 90 degrees south (90°S). In <a href="chapter4.xhtml#fig4-5" class="calibre2">Figure 4-5</a>, the latitude of point P would be denoted as <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i>°N, as it lies <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i> degrees north of the equator along a great circle that intersects with P and the North Pole. <i class="calibre9">Longitude</i> measures the distance east or west of the prime meridian. The prime meridian itself has a longitude of 0 degrees, and longitude values range from –180 degrees west of the prime meridian to 180 degrees east of the prime meridian. In the case of point P, its longitude would be <i class="calibre9"><span lang="el" xml:lang="el">λ</span></i>°E, indicating its great circle is <i class="calibre9"><span lang="el" xml:lang="el">λ</span></i> degrees east of the prime meridian.</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_15-n">NOTE</span></p>
</blockquote>
<p class="note-txt"><i class="calibre9">You may be used to seeing all latitude and longitude values expressed as positive numbers, but for the haversine formula to work, southern latitudes and western longitudes must be negative. Our program will automatically convert coordinates that don’t follow this convention.</i></p>
<p class="tx">Given any two points on the surface of a sphere, you can draw a great circle that intersects with both points, and that great circle will define the shortest path between the two points. If you know the angle <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> (in radians) <span aria-label="150" epub:type="pagebreak" id="pg_150" role="doc-pagebreak"/>between the points—that is, the angle formed at the sphere’s center by the arc connecting the points—and if you know the radius <i class="calibre9">r</i> of the sphere, you can calculate the distance along the sphere’s surface between the two points as follows:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>d</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>r</mi><mi>θ</mi></mrow></math> (4.5)</span>
<span class="mobi"><img alt="" class="img1" height="38" src="../images/eq4-5.jpg" width="1384"/></span></figure>
<p class="tx">In the case of Earth, we know the radius <i class="calibre9">R</i> to be about 6,371.009 kilometers, but how do we know the angle between two points on Earth’s surface? This is where the haversine formula comes in. It uses the points’ latitude and longitude coordinates, and a bit of trigonometry, to determine that angle, which in turn lets us calculate the distance between the points. The formula involves a little-known trigonometric function called the haversine function. The haversine of an angle <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> is defined as follows:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mtext>hav</mtext><mfenced><mi>θ</mi></mfenced><mtext> </mtext><mo>=</mo><mtext> </mtext><msup><mrow><mi>sin</mi></mrow><mn>2</mn></msup><mfenced><mrow><mfrac><mi>θ</mi><mn>2</mn></mfrac></mrow></mfenced></mrow></math> (4.6)</span>
<span class="mobi"><img alt="" class="img1" height="75" src="../images/eq4-6.jpg" width="1384"/></span></figure>
<p class="tx">The haversine formula calculates <i class="calibre9">a</i>, the haversine of the angle between two points on Earth’s surface, as follows:</p>
<p class="equation"><i class="calibre9">  a</i> = hav(<i class="calibre9"><span lang="el" xml:lang="el">φ</span></i><sub class="calibre19">2</sub> – <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i><sub class="calibre19">1</sub>) + cos(<i class="calibre9"><span lang="el" xml:lang="el">φ</span></i><sub class="calibre19">1</sub>) cos(<i class="calibre9"><span lang="el" xml:lang="el">φ</span></i><sub class="calibre19">2</sub>) hav(<i class="calibre9"><span lang="el" xml:lang="el">λ</span></i><sub class="calibre19">2</sub> – <i class="calibre9"><span lang="el" xml:lang="el">λ</span></i><sub class="calibre19">1</sub>)</p>
<p class="tni">Here (<i class="calibre9"><span lang="el" xml:lang="el">φ</span></i><sub class="calibre19">1</sub>, <i class="calibre9"><span lang="el" xml:lang="el">λ</span></i><sub class="calibre19">1</sub>) and (<i class="calibre9"><span lang="el" xml:lang="el">φ</span></i><sub class="calibre19">2</sub>, <i class="calibre9"><span lang="el" xml:lang="el">λ</span></i><sub class="calibre19">2</sub>) are the latitude and longitude coordinates of the two points, expressed in radians. To convert from degrees to radians, simply multiply by <span class="copyright_accent"><span lang="el" xml:lang="el">π</span></span> and divide by 180.</p>
<p class="tx">We now have the haversine of the angle between the two points, but not the angle itself. For that, we can use the <i class="calibre9">a</i> we just calculated and the definition of haversine (Equation 4.6) to solve for the arc angle <i class="calibre9">c</i>:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>c</mi><mo>=</mo><mn>2</mn><msup><mrow><mi>sin</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mfenced><mrow><msqrt><mi>a</mi></msqrt></mrow></mfenced></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="56" src="../images/pg150-1.jpg" width="1384"/></span></figure>
<p class="tni">Now that we have the angle <i class="calibre9">c</i>, we have everything we need to calculate the distance between the points using Equation 4.5:</p>
<p class="equation"><i class="calibre9">  d</i> = <i class="calibre9">Rc</i></p>
<p class="tx">There’s one catch, however: <i class="calibre9">d</i> works out to a real number only when 0 ≤ <i class="calibre9">a</i> ≤ 1, but sometimes <i class="calibre9">a</i> can be pushed outside this range due to a floating-point error. To avoid this, we should instead express <i class="calibre9">c</i> as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>c</mi><mo>=</mo><mn>2</mn><msup><mrow><mi>sin</mi></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><msqrt><mrow><mi>max</mi><mo stretchy="false">(</mo><mn>0.0</mn><mo>,</mo><mi>min</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mn>1.0</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></msqrt></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="45" src="../images/pg150-2.jpg" width="1384"/></span></figure>
<p class="tni">This constrains the value of <i class="calibre9">a</i> to a range from 0 to 1, preventing any unrealistic results.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="h1"><span id="sec18"/><span id="h2-75"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">We now have everything we need to write a Kotlin program that calculates the shortest distance between two locations on Earth. For this example, I’ve hardcoded the locations of two well-known landmarks, Big Ben in London <span aria-label="151" epub:type="pagebreak" id="pg_151" role="doc-pagebreak"/>and the Statue of Liberty in New York, but you can use any locations you want. The code consists of four main segments: an import block and global declarations, the <span class="sans_thesansmonocd_w5regular_">main()</span> function, the <span class="sans_thesansmonocd_w5regular_">printLatLong()</span> function, and the <span class="sans_thesansmonocd_w5regular_">haversineDistance()</span> function. I’ll discuss them in the same order.</p>
<pre class="calibre10"><code class="calibre11">// Import math functions.
import kotlin.math.sin
import kotlin.math.asin
import kotlin.math.cos
import kotlin.math.PI
import kotlin.math.max
import kotlin.math.min
import kotlin.math.pow
import kotlin.math.sqrt

// Define a Location data class.
data class Location(
    val name: String = "",
    var lat: Double,
    val latDir: String,
    var lon: Double,
    val lonDir: String
)

//  global variables and parameters
//  N = north, S = south, E = east, W = west
val L1 = Location(name = "Big Ben", lat=51.5004,
    latDir = "N", lon=0.12143, lonDir = "W")
val L2 = Location(name="Statue of Liberty", lat = 40.689978,
    latDir = "N", lon = 74.045448, lonDir = "W")
val locations = listOf(L1, L2)

val R = 6371.009  // radius of Earth in km

fun main() {
    println("\n*** Measuring Distance Between Two Locations on Earth ***\n")
    printLatLong(category = "input", locations)
    val d = haversineDistance()
    printLatLong(category = "adjusted", locations)
    println("\nThe distance between the two given locations:")
    println("d = ${"%10.2f".format(d)} km")
}

fun printLatLong(category: String, locationsToPrint: List&lt;Location&gt;) {
    when(category) {
        "input" -&gt;
            println("...inputted coordinates...\n")
        "adjusted" -&gt;
            println("\n...adjusted coordinates...\n")
    }
    locationsToPrint.forEach {location -&gt; println(location)}
}

<span aria-label="152" epub:type="pagebreak" id="pg_152" role="doc-pagebreak"/>fun haversineDistance(): Double {
    // Adjust signs based on N-S and E-W directions.
  <span aria-label="annotation1" class="code_codeannotation">❶</span> for (location in locations) {
        with(location) {
            if(latDir == "S" &amp;&amp; lat &gt; 0.0) lat = - lat
            if(lonDir == "W" &amp;&amp; lon &gt; 0.0) lon = - lon
        }
    }
    // Calculate the angles in radians.
    val phi1 = L1.lat * PI/180
    val phi2 = L2.lat * PI/180
    val delPhi = phi2 - phi1
    val delLambda = (L2.lon - L1.lon) * PI/180

    // Calculate the distance using haversine formula.
  <span aria-label="annotation2" class="code_codeannotation">❷</span> val a = sin(delPhi/2).pow(2) +
            cos(phi1) * cos(phi2) *
            sin(delLambda/2).pow(2)
    // Ensure that 0 &lt;= a &lt;= 1 before calculating c.
  <span aria-label="annotation3" class="code_codeannotation">❸</span> val c = 2 * asin(sqrt(max(0.0, min(1.0, a))))
  <span aria-label="annotation4" class="code_codeannotation">❹</span> val d = R * c
    return d
}</code></pre>
<p class="tx">Since the haversine formula needs to use quite a few math functions, we begin by importing those from the <span class="sans_thesansmonocd_w5regular_">kotlin.math</span> package. Next, we declare a data class <span class="sans_thesansmonocd_w5regular_">Location</span> with five properties: <span class="sans_thesansmonocd_w5regular_">name</span> (the name of the location), <span class="sans_thesansmonocd_w5regular_">lat</span> (the latitude), <span class="sans_thesansmonocd_w5regular_">latDir</span> (the direction of the latitude), <span class="sans_thesansmonocd_w5regular_">lon</span> (the longitude), and <span class="sans_thesansmonocd_w5regular_">lonDir</span> (the direction of the longitude). We then create two <span class="sans_thesansmonocd_w5regular_">Location</span> objects, <span class="sans_thesansmonocd_w5regular_">L1</span> and <span class="sans_thesansmonocd_w5regular_">L2</span>, representing Big Ben and the Statue of Liberty. We store them together in a list called <span class="sans_thesansmonocd_w5regular_">locations</span> so we can efficiently iterate over the locations.</p>
<p class="tx">Notice that I’ve provided the latitude and longitude values as positive numbers in degrees, regardless of which direction they’re in. I’m relying on the <span class="sans_thesansmonocd_w5regular_">latDir</span> and <span class="sans_thesansmonocd_w5regular_">lonDir</span> properties to communicate that extra information. The convention is <span class="sans_thesansmonocd_w5regular_">N</span> for north, <span class="sans_thesansmonocd_w5regular_">S</span> for south, <span class="sans_thesansmonocd_w5regular_">E</span> for east, and <span class="sans_thesansmonocd_w5regular_">W</span> for west. In cases where the latitude or longitude of a location is exactly 0, the corresponding direction can be set to <span class="sans_thesansmonocd_w5regular_">EQ</span> (equator) or <span class="sans_thesansmonocd_w5regular_">PM</span> (prime meridian), although this won’t impact the final result. Later, in the <span class="sans_thesansmonocd_w5regular_">haversineDistance()</span> function, we ensure that when the <span class="sans_thesansmonocd_w5regular_">lat</span> or <span class="sans_thesansmonocd_w5regular_">lon</span> direction is <span class="sans_thesansmonocd_w5regular_">S</span> or <span class="sans_thesansmonocd_w5regular_">W</span>, respectively, the corresponding values are always negative <span aria-label="annotation1" class="codeannotation">❶</span>.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">main()</span> function prints the provided latitude and longitude values before and after adjustments (if any) using the <span class="sans_thesansmonocd_w5regular_">printLatLong()</span> function, makes a single call to the <span class="sans_thesansmonocd_w5regular_">haversineDistance()</span> function, and prints the result.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">printLatLong()</span> function takes one argument, <span class="sans_thesansmonocd_w5regular_">category</span>, which is of type <span class="sans_thesansmonocd_w5regular_">String</span>. The <span class="sans_thesansmonocd_w5regular_">category</span> parameter is passed to a <span class="sans_thesansmonocd_w5regular_">when</span> block to determine which of two messages to print, indicating whether the coordinates have been adjusted for their direction properties. The locations themselves are then printed one at a time using the <span class="sans_thesansmonocd_w5regular_">forEach()</span> method of the <span class="sans_thesansmonocd_w5regular_">locationsToPrint</span> list. We could have used a regular <span class="sans_thesansmonocd_w5regular_">for</span> loop here, but some Kotlin enthusiasts consider <span class="sans_thesansmonocd_w5regular_">forEach()</span> to be more idiomatic.</p>
<p class="tx"><span aria-label="153" epub:type="pagebreak" id="pg_153" role="doc-pagebreak"/>Finally, the <span class="sans_thesansmonocd_w5regular_">haversineDistance()</span> function calculates the shortest distance between the two locations on a spherical surface. It first iterates over the locations and negates the latitudes and longitudes if needed <span aria-label="annotation1" class="codeannotation">❶</span>, then converts all the latitude and longitude values from degrees to radians. Next, it steps through the equations we discussed on <span><a href="#pg_150" class="calibre2">page 150</a></span>, using the coordinates to calculate <i class="calibre9">a</i> <span aria-label="annotation2" class="codeannotation">❷</span>, using <i class="calibre9">a</i> (constrained to between 0 and 1) to calculate the angle <i class="calibre9">c</i> <span aria-label="annotation3" class="codeannotation">❸</span>, and using <i class="calibre9">c</i> to calculate and return the haversine distance <i class="calibre9">d</i> between the points <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="h1"><span id="sec19"/><span id="h2-76"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">When you run the program for the set location and parameter values, the output should appear as follows:</p>
<pre class="calibre10"><code class="calibre11">*** Measuring Distance Between Two Locations on Earth ***

...inputted coordinates...

Location(name=Big Ben, lat=51.5004, latDir=N, lon=0.12143, lonDir=W)
Location(name=Statue of Liberty, lat=40.689978, latDir=N, lon=74.045448,
lonDir=W)

...adjusted coordinates...

Location(name=Big Ben, lat=51.5004, latDir=N, lon=-0.12143, lonDir=W)
Location(name=Statue of Liberty, lat=40.689978, latDir=N, lon=-74.045448,
lonDir=W)

The distance between the two given locations:
d =   5575.08 km</code></pre>
<p class="tx">As mentioned on <span><a href="#pg_148" class="calibre2">page 148</a></span>, the haversine calculation assumes that Earth is a perfect sphere, which is not true. In fact, Earth is an oblate spheroid, slightly flattened at the poles and bulging at the equator. To get around this wrinkle, you could use Vincenty’s formula, which takes into account the oblate spheroidal shape of Earth by considering Earth’s equatorial and polar diameters. Which formula to use really depends on the nature of the problem, as both methods have their strengths and their weaknesses.</p>
<aside aria-label="box-24" class="box2">
<p class="boxtitle" id="box-24"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Every time you fly to a distant location for business or pleasure, you might wonder about the minimum flight distance between the departing and arriving cities. Now that you know how to calculate the haversine distance, you can find the answer if you know the latitude and longitude coordinates of the locations. Try finding the shortest distance between the locations listed here. (You can look up the coordinates for these locations online; for the last two cases, you should already know what they are.)</span></p>
<ul class="ul">
<li class="boxlistbullet"><span aria-label="154" epub:type="pagebreak" id="pg_154" role="doc-pagebreak"/><span class="sans_futura_std_book_">Tokyo, Japan, and Sydney, Australia</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Paris, France, and Lima, Peru</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Dublin, Ireland, and Ankara, Turkey</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The North Pole and South Pole</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">Two points where the equator and the prime meridian intersect, located on opposite sides of the globe</span></li>
</ul>
<p class="box1"><span class="sans_futura_std_book_">As an added step, use the calculated distances and an average speed of air travel to estimate the flight times between these locations.</span></p>
</aside>
<p class="headaexercise" id="pre-15"><span class="sans_dogma_ot_bold_b_15-n">Project 15: Do Encryption with the Hill Cipher</span></p>
<p class="tni">In today’s interconnected world, we constantly share sensitive data like personal information, financial details, and confidential messages. What’s to stop unauthorized parties from accessing that information? The answer is <i class="calibre9">encryption</i>, a set of techniques for scrambling our data into gibberish that can be deciphered only with the right key. Encryption protects our privacy, safeguards against hackers and cybercriminals, and secures our online transactions.</p>
<p class="tx">There are a variety of encryption algorithms in use today. In this project, we’ll focus on a particular algorithm called the Hill cipher, developed by American mathematician Lester S. Hill in 1929. According to this method, the <i class="calibre9">plaintext</i> (text in plain English or any other language) is divided into blocks of fixed size and represented as vectors. These vectors are then multiplied by a square matrix called the <i class="calibre9">encryption key</i>, modulo a specified number, to obtain the <i class="calibre9">ciphertext</i> (encrypted text). For decryption, the ciphertext vectors are multiplied by the inverse of the encryption key matrix, modulo the same specified number.</p>
<p class="tx">Hill’s encryption method can be vulnerable to attacks if we don’t choose the encryption key matrix carefully. While it’s no longer employed as the sole encryption mechanism, it can still be incorporated into more sophisticated methods and remains a valuable concept to grasp. Plus, exploring Hill’s method provides an excellent opportunity to apply and enhance our coding skills in the crucial field of cryptography.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="h1"><span id="sec20"/><span id="h2-77"/><span class="sans_futura_std_bold_condensed_oblique_">How It Works</span></h4>
<p class="tni">The Hill cipher revolves around concepts from linear algebra and modulo operations. I don’t expect you to have an in-depth knowledge of these areas of mathematics, but you may wish to review these topics to gain a better insight into how the Hill cipher actually works, as well as its strengths and weaknesses. Here are brief definitions of the key terms that we’ll use in this project:</p>
<p class="listhead"><span aria-label="155" epub:type="pagebreak" id="pg_155" role="doc-pagebreak"/><b class="calibre6">Vector</b></p>
<p class="listplainfirst">A one-dimensional sequence of values. For example, [1, 3, 5] is a row vector with three elements.</p>
<p class="listhead"><b class="calibre6">Matrix</b></p>
<p class="listplainfirst">A two-dimensional collection of values, arranged in rows and columns. For example, a 3×3 matrix has three rows and three columns, and a total of nine elements (numbers) that can be real or complex.</p>
<p class="listhead"><b class="calibre6">Determinant</b></p>
<p class="listplainfirst">A single value calculated using the elements of a matrix. The matrix must be square, meaning it has the same number of rows and columns. Say we have the following square matrix <span class="copyright_italic">A</span>:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>A</mi><mo>=</mo><mfenced close="|" open="|"><mrow><mtable equalcolumns="true" equalrows="true"><mtr><mtd><mi>a</mi></mtd><mtd><mi>b</mi></mtd><mtd><mi>c</mi></mtd></mtr><mtr><mtd><mi>d</mi></mtd><mtd><mi>e</mi></mtd><mtd><mi>f</mi></mtd></mtr><mtr><mtd><mi>g</mi></mtd><mtd><mi>h</mi></mtd><mtd><mi>i</mi></mtd></mtr></mtable></mrow></mfenced></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="123" src="../images/pg155-1.jpg" width="1388"/></span></figure>
<p class="runinpara">Its determinant, denoted by det(<span class="copyright_italic">A</span>), det <span class="copyright_italic">A</span>, or |<span class="copyright_italic">A</span>|, can be calculated as follows:</p>
<p class="equation">  det(<i class="calibre9">A</i>) = <i class="calibre9">aei</i> + <i class="calibre9">bfg</i> + <i class="calibre9">cdh</i> – <i class="calibre9">ceg</i> – <i class="calibre9">bdi</i> – <i class="calibre9">afh</i></p>
<p class="listhead"><b class="calibre6">Identity matrix</b></p>
<p class="listplainfirst">A square matrix, often denoted as <span class="copyright_italic">I</span>, where all the elements along a diagonal from the top left to the bottom right have a value of 1 and all other elements have a value of 0. A 3×3 identity matrix looks like this:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>I</mi><mo>=</mo><mfenced close="|" open="|"><mrow><mtable equalcolumns="true" equalrows="true"><mtr><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr></mtable></mrow></mfenced></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="117" src="../images/pg155-2.jpg" width="1388"/></span></figure>
<p class="listhead"><b class="calibre6">Inverse matrix</b></p>
<p class="listplainfirst">For a given matrix <span class="copyright_italic">A</span>, its inverse <span class="copyright_italic">A</span><sup class="calibre8">–1</sup> is another matrix such that multiplying the two matrices results in the identity matrix (that is, <span class="copyright_italic">AA</span><sup class="calibre8">–1</sup> = <span class="copyright_italic">I</span>). A matrix must be square to have an inverse, although not all square matrices have one.</p>
<p class="listhead"><b class="calibre6">Modulo</b></p>
<p class="listplainfirst">An operation represented by the symbol % that finds the remainder when one number is divided by another. For example, 5 % 2 is 1. Modulo (<span class="copyright_italic">mod</span> for short) is a multipurpose operator used in various applications, such as determining divisibility, cycling through a range of values, and handling periodic patterns. Hill’s algorithm relies on the modulo operation to keep the encrypted and decrypted texts within the same alphabet as the plaintext. Thus, the size of the alphabet serves as the <span class="copyright_italic">base</span> or <span class="copyright_italic">modulus</span> (the number after the % operator) for these operations, guaranteeing valid ciphertext and plaintext representations.</p>
<p class="listhead"><span aria-label="156" epub:type="pagebreak" id="pg_156" role="doc-pagebreak"/><b class="calibre6">Modular multiplicative inverse (MMI)</b></p>
<p class="listplainfirst">For a given integer <span class="copyright_italic">a</span> and a modulus <span class="copyright_italic">m</span>, the MMI is positive integer <span class="copyright_italic">x</span> such that <span class="copyright_italic">ax</span> % <span class="copyright_italic">m</span> = 1. The value of <span class="copyright_italic">x</span> must be less than the modulus. For example, the MMI for 5 modulo 11 is 9, because (5 * 9) % 11 = 1, and 9 is less than 11.</p>
<p class="tx">Armed with these definitions, let’s now dive into the core encryption and decryption steps employed by the Hill cipher and highlight some of our Kotlin implementation.</p>
<section aria-labelledby="sec21" epub:type="division">
<h5 class="h2"><span id="sec21"/><span id="h3-29"/><span class="sans_futura_std_bold_b_">For Encryption</span></h5>
<p class="listnumber">  1.  Define the alphabet. Choose which letters are to be used for writing plain and encrypted messages. For messages written in English, the alphabet size should be at least 26 to include all lowercase letters. We’ll also include a period, a space, and a question mark, giving us an alphabet of 29 characters total. The size of the alphabet serves as the modulus.</p>
<p class="listnumber1">  2.  Choose a block size. During encryption and decryption, the message is divided into small blocks of characters, each of the same length. In this exercise, we’ll have three characters per block.</p>
<p class="listnumber1">  3.  Generate the encryption key matrix. For the purposes of this project, I’ve generated the encryption key matrix for you, but if you’re curious, it must adhere to these rules:</p>
<p class="listnumbersub">a.  The matrix must be square and have the same dimension as the block size chosen in step 2. In this case, with a block size of 3, we need a 3×3 matrix.</p>
<p class="listnumbersub">b.  The determinant of the matrix can’t be 0.</p>
<p class="listnumbersub">c.  The determinant must not share a factor, other than 1, with the modulus from step 1.</p>
<p class="listnumber1">  4.  Prepare the plaintext. Divide the plaintext message into blocks based on the chosen block size. If the last block is smaller than the fixed size, pad it with filler characters. We’ll use spaces for padding to ensure that the message remains the same after decryption, with no extra visible characters.</p>
<p class="listnumber1">  5.  Create vectors from the plaintext. Each block of the plaintext must be converted into a numerical vector with the same length as the block size. To assign numerical values to characters, we’ll save the alphabet in a single <span class="sans_thesansmonocd_w5regular_">String</span> object. We can then map each character in the plaintext to that character’s corresponding index in the string. For example, <span class="sans_thesansmonocd_w5regular_">a</span> will be mapped to <span class="sans_thesansmonocd_w5regular_">0</span>, <span class="sans_thesansmonocd_w5regular_">b</span> to <span class="sans_thesansmonocd_w5regular_">1</span>, and so on. This way, the block <span class="sans_thesansmonocd_w5regular_">cab</span> will become <span class="sans_thesansmonocd_w5regular_">(2, 0, 1)</span>, a vector of size 3.</p>
<p class="listnumber1">  6.  Encrypt the message. For each block, carry out the following steps:</p>
<p class="listnumbersub">a.  Multiply the block’s plaintext vector by the key matrix, modulo 29, to generate a ciphertext vector.</p>
<p class="listnumbersub"><span aria-label="157" epub:type="pagebreak" id="pg_157" role="doc-pagebreak"/>b.  Convert the numerical values in the ciphertext vector back to text characters using the reverse mapping scheme.</p>
<p class="listnumbersub">c.  Add the ciphered characters to a mutable list of characters, which will become the encrypted message (ciphertext) once all the blocks have been processed.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h5 class="h2"><span id="sec22"/><span id="h3-30"/><span class="sans_futura_std_bold_b_">For Decryption</span></h5>
<p class="listnumber">  1.  Generate the decryption key matrix. To decipher the encrypted text, we must first create the inverse of the encryption key matrix modulo the specified number. This process involves multiple linear algebraic steps and modulo operations; for simplicity, I’ve provided the inverse matrix. If you want to work with a different set of key and inverse matrices, you can look up the online tools that will generate those for you.</p>
<p class="listnumber1">  2.  Prepare the ciphertext. Divide the ciphertext into blocks of the specified size used during encryption (3 for this project). This time, no padding is needed, since the padding was already done during encryption.</p>
<p class="listnumber1">  3.  Create vectors from the ciphertext. Use the same character-numbering scheme to convert the ciphertext blocks into ciphertext vectors of size 3.</p>
<p class="listnumber1">  4.  Decrypt the message. For each block, carry out the following steps:</p>
<p class="listnumbersub">a.  Multiply the ciphertext vector by the decryption key matrix, modulo 29, to generate a deciphered vector.</p>
<p class="listnumbersub">b.  Convert the numerical values in the deciphered vector back to text characters using the reverse mapping scheme.</p>
<p class="listnumbersub">c.  Add the deciphered characters to a mutable list of characters, which will become the decrypted message (plaintext) once all the blocks have been processed.</p>
<p class="tx">Finally, keep in mind that it’s customary to pick an encryption key matrix made up of only integers, preferably falling between 0 and the modulus.</p>
</section>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="h1"><span id="sec23"/><span id="h2-78"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">We’re ready to implement the Kotlin code for Hill’s encryption and decryption method. The code is organized in a top-down manner, starting with global declarations, continuing with the <span class="sans_thesansmonocd_w5regular_">main()</span> function, and ending with a series of short helper functions. We’ll review everything in sequence.</p>
<section aria-labelledby="sec24" epub:type="division">
<h5 class="h2"><span id="sec24"/><span id="h3-31"/><span class="sans_futura_std_bold_b_">Variables and Data Structures</span></h5>
<p class="tni">We begin by declaring the variables and data structures needed to implement Hill’s method.</p>
<pre class="calibre10"><code class="calibre11">/*  --- Hill's method for encrypting and decrypting texts --- */

// Declare the key matrix and its inverse.
// keyInv is based on mod 29.
val key = arrayOf(
<span aria-label="158" epub:type="pagebreak" id="pg_158" role="doc-pagebreak"/>    intArrayOf(13, 11, 6),
    intArrayOf(15, 21, 8),
    intArrayOf(5, 7, 9)
)

val keyInv = arrayOf(
    intArrayOf(1, 12, 8),
    intArrayOf(20, 0, 6),
    intArrayOf(0, 3, 20)
)

val dim = key.size
const val alphabet = "abcdefghijklmnopqrstuvwxyz .?"

data class Block(
    val t1: Char,
    val t2: Char,
    val t3: Char,
)

val indexVector = IntArray(dim)
val processedVector = IntArray(dim)
val blocks = mutableListOf&lt;Block&gt;()
val processedText = mutableListOf&lt;Char&gt;()</code></pre>
<p class="tx">First, we create the matrices for encryption and decryption (<span class="sans_thesansmonocd_w5regular_">key</span> and <span class="sans_thesansmonocd_w5regular_">keyInv</span>). For this project, we’ll accept these as given, but you can use online tools to create a different encryption key matrix that meets the required conditions and calculate the corresponding inverse matrix. The size of these square matrices is captured in the parameter <span class="sans_thesansmonocd_w5regular_">dim</span>, which is later used as the block size for processing messages. We also define a string called <span class="sans_thesansmonocd_w5regular_">alphabet</span> that stores all the valid letters that can be used in the plaintext and ciphertext.</p>
<p class="tx">Next, we introduce a data class called <span class="sans_thesansmonocd_w5regular_">Block</span>, which we’ll use to store the text blocks generated while processing the message. These blocks will be stored as a mutable list named <span class="sans_thesansmonocd_w5regular_">blocks</span>. We also create a few other collections to temporarily hold and manipulate the vectors created during encryption and decryption operations, along with a mutable list named <span class="sans_thesansmonocd_w5regular_">processedText</span> to store the final list of characters. Since the encryption and decryption processes are very similar, we’ll be able to use these variables and collections during both processes to store the intermediate and final values.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h5 class="h2"><span id="sec25"/><span id="h3-32"/><span class="sans_futura_std_bold_b_">The main() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">main()</span> function calls a series of helper functions to coordinate the overall encryption or decryption process.</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    println("\n*** Cryptography with Hill's Method ***\n")
    runValidation()
    println("\nEnter 1 for encryption or 2 for decryption:")

  <span aria-label="annotation1" class="code_codeannotation">❶</span> when(val choice = readln().toInt()) {
        1 -&gt; {
<span aria-label="159" epub:type="pagebreak" id="pg_159" role="doc-pagebreak"/>            println("You have chosen encryption\n")
            getText()
            encrypt()
            printProcessedText(choice)
        }
        2 -&gt; {
            println("You have chosen decryption\n")
            getText()
            decrypt()
            printProcessedText(choice)
        }
        else -&gt; println("\nInvalid choice...exiting program\n")
    }
}</code></pre>
<p class="tx">In <span class="sans_thesansmonocd_w5regular_">main()</span>, we first call the <span class="sans_thesansmonocd_w5regular_">runValidation()</span> function, which uses matrix multiplication (mod 29) to ensure that the encryption and decryption matrices are valid. We then prompt the user to choose which operation to carry out: encryption (enter <span class="sans_thesansmonocd_w7bold_">1</span>) or decryption (enter <span class="sans_thesansmonocd_w7bold_">2</span>). Based on the choice, we use a <span class="sans_thesansmonocd_w5regular_">when</span> block <span aria-label="annotation1" class="codeannotation">❶</span> to implement the steps to encrypt or decrypt a message.</p>
<p class="tx">For both choices, we start with the <span class="sans_thesansmonocd_w5regular_">getText()</span> function, which takes in the message to be encrypted or decrypted from the user as a text string and divides it into blocks. We then call <span class="sans_thesansmonocd_w5regular_">encrypt()</span> or <span class="sans_thesansmonocd_w5regular_">decrypt()</span>, depending on the choice made earlier. Finally, we display the result with help from the <span class="sans_thesansmonocd_w5regular_">printProcessedText()</span> function.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h5 class="h2"><span id="sec26"/><span id="h3-33"/><span class="sans_futura_std_bold_b_">The Helper Functions</span></h5>
<p class="tni">There are several helper functions called from within the <span class="sans_thesansmonocd_w5regular_">main()</span> function. We’ll turn to those next, starting with the functions that help validate the matrices.</p>
<pre class="calibre10"><code class="calibre11">fun runValidation() {
    println("key matrix dimension:")
    println("${key.size}  x  ${key[0].size}\n")

    // validation of key and keyInv
    val productMatrix = multiplyMatricesMod29(key, keyInv,
        r1=dim, c1=dim, c2=dim)
    displayProduct(productMatrix)
}

fun multiplyMatricesMod29(firstMatrix: Array &lt;IntArray&gt;,
                          secondMatrix: Array &lt;IntArray&gt;,
                          r1: Int,
                          c1: Int,
                          c2: Int): Array &lt;IntArray&gt; {
    val product = Array(r1) {IntArray(c2)}
    for (i in 0 until r1) {
        for (j in 0 until c2) {
<span aria-label="160" epub:type="pagebreak" id="pg_160" role="doc-pagebreak"/>            for (k in 0 until c1) {
                product[i][j] += (firstMatrix[i][k] *
                                  secondMatrix[k][j])
            }
          <span aria-label="annotation1" class="code_codeannotation">❶</span> product[i][j] = product[i][j] % 29
        }
    }
    return product
}

fun displayProduct(product: Array &lt;IntArray&gt;) {
    println("[key * keyInv] mod 29 =")
    for (row in product) {
        for (column in row) {
            print("$column    ")
        }
        println()
    }
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">runValidation()</span> function displays the size of the key matrices. It then calls <span class="sans_thesansmonocd_w5regular_">multiplyMatricesMod29()</span> to do the validation check and shows the results with <span class="sans_thesansmonocd_w5regular_">displayProduct()</span>. The matrices are considered valid if one is the inverse of the other, modulo 29. If this is the case, the product of the two matrices, modulo 29, should be an identity matrix where all elements are zeros, except for ones along the diagonal from the top left to the bottom right.</p>
<p class="tx">In <span class="sans_thesansmonocd_w5regular_">multiplyMatricesMod29()</span>, we test this out, using three nested <span class="sans_thesansmonocd_w5regular_">for</span> loops to multiply the encryption and decryption key matrices, taking modulo 29 of each resulting value before putting it in the <span class="sans_thesansmonocd_w5regular_">product</span> matrix <span aria-label="annotation1" class="codeannotation">❶</span>. See the <span>“Multiplying Two Matrices”</span> box for details about the math behind this process.</p>
<aside aria-label="box-25" class="box">
<p class="boxtitle" id="box-25"><span class="sans_futura_std_bold_b_">MULTIPLYING TWO MATRICES</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">To multiply two matrices, we must first ensure that their shapes (number of rows and columns) are compatible: the number of columns in the first matrix must be equal to the number of rows in the second matrix. As a result, the product matrix will have the same number of rows as the first matrix and the same number of columns as the second matrix.</span></p>
<p class="box1"><span class="sans_futura_std_book_">Once this condition is met, we work through the rows of one matrix and the corresponding columns of the other, multiplying and summing the values. Say we have the following two 3×3 matrices,</span> <span class="sans_futura_std_book_oblique_">A</span> <span class="sans_futura_std_book_">and</span> <span class="sans_futura_std_book_oblique_">B</span><span class="sans_futura_std_book_">:</span></p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>A</mi><mo>=</mo><mfenced close="|" open="|"><mrow><mtable equalcolumns="true" equalrows="true"><mtr><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mn>4</mn></mtd><mtd><mn>5</mn></mtd><mtd><mn>6</mn></mtd></mtr><mtr><mtd><mn>7</mn></mtd><mtd><mn>8</mn></mtd><mtd><mn>9</mn></mtd></mtr></mtable></mrow></mfenced><mo>,</mo><mtext> </mtext><mi>B</mi><mo>=</mo><mfenced close="|" open="|"><mrow><mtable equalcolumns="true" equalrows="true"><mtr><mtd><mn>9</mn></mtd><mtd><mn>8</mn></mtd><mtd><mn>7</mn></mtd></mtr><mtr><mtd><mn>6</mn></mtd><mtd><mn>5</mn></mtd><mtd><mn>4</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>1</mn></mtd></mtr></mtable></mrow></mfenced></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="125" src="../images/pg160.jpg" width="1222"/></span></figure>
<p class="boxfirst"><span class="sans_futura_std_book_">Here are the steps to find their product matrix</span> <span class="sans_futura_std_book_oblique_">C</span><span class="sans_futura_std_book_">:</span></p>
<p class="boxlistnumber"><span aria-label="161" epub:type="pagebreak" id="pg_161" role="doc-pagebreak"/><span class="sans_futura_std_book_">1.  Multiply the elements in the first row of matrix</span> <span class="sans_futura_std_book_oblique_">A</span> <span class="sans_futura_std_book_">by the elements in the first column of matrix</span> <span class="sans_futura_std_book_oblique_">B</span> <span class="sans_futura_std_book_">and add the results together: (1 × 9) + (2 × 6) + (3 × 3) = 9 + 12 + 9 = 30. This is the value at</span> <span class="sans_futura_std_book_oblique_">C</span><span class="sans_futura_std_book_">[1,1], the first row and first column of the product matrix.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">2.  Multiply the elements in the first row of matrix</span> <span class="sans_futura_std_book_oblique_">A</span> <span class="sans_futura_std_book_">by the elements in the second column of matrix</span> <span class="sans_futura_std_book_oblique_">B</span> <span class="sans_futura_std_book_">and add the results together: (1 × 8) + (2 × 5) + (3 × 2) = 8 + 10 + 6 = 24. This is the value at</span> <span class="sans_futura_std_book_oblique_">C</span><span class="sans_futura_std_book_">[1,2], the first row and second column of the product matrix.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">3.  Multiply the elements in the first row of matrix</span> <span class="sans_futura_std_book_oblique_">A</span> <span class="sans_futura_std_book_">by the elements in the third column of matrix</span> <span class="sans_futura_std_book_oblique_">B</span> <span class="sans_futura_std_book_">and add the results together: (1 × 7) + (2 × 4) + (3 × 1) = 7 + 8 + 3 = 18. This is the value at</span> <span class="sans_futura_std_book_oblique_">C</span><span class="sans_futura_std_book_">[1,3], the first row and third column of the product matrix.</span></p>
<p class="boxlistnumber"><span class="sans_futura_std_book_">4.  Repeat steps 1 through 3 for the second and third rows of matrix</span> <span class="sans_futura_std_book_oblique_">A</span> <span class="sans_futura_std_book_">to get the values in the second and third rows of the product matrix</span> <span class="sans_futura_std_book_oblique_">C</span><span class="sans_futura_std_book_">.</span><br class="calibre1"/><span class="sans_futura_std_book_">After performing all these calculations, we get this result:</span></p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>A</mi><mo>=</mo><mfenced close="|" open="|"><mrow><mtable equalcolumns="true" equalrows="true"><mtr><mtd><mrow><mn>30</mn></mrow></mtd><mtd><mrow><mn>24</mn></mrow></mtd><mtd><mrow><mn>18</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>84</mn></mrow></mtd><mtd><mrow><mn>69</mn></mrow></mtd><mtd><mrow><mn>54</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>138</mn></mrow></mtd><mtd><mrow><mn>114</mn></mrow></mtd><mtd><mrow><mn>90</mn></mrow></mtd></mtr></mtable></mrow></mfenced></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="117" src="../images/pg161.jpg" width="1223"/></span></figure>
</aside>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">displayProduct()</span> function neatly formats and prints the contents of the product matrix. As you’ll later see in the example output, the result should indeed be an identity matrix.</p>
<p class="tx">Here’s the <span class="sans_thesansmonocd_w5regular_">getText()</span> function, which we call from <span class="sans_thesansmonocd_w5regular_">main()</span> at the start of the encryption or decryption process:</p>
<pre class="calibre10"><code class="calibre11">fun getText() {
    println("Enter text for processing:")
    var text = readln().lowercase()
    val tmp = " " // Use a space for padding.

  <span aria-label="annotation1" class="code_codeannotation">❶</span> when(text.length % 3) {
        1 -&gt; text = text + tmp + tmp
        2 -&gt; text += tmp
    }
    for (i in text.indices step 3)
        blocks.add(Block(text[i], text[i+1], text[i+2]))
}</code></pre>
<p class="tx">The function uses <span class="sans_thesansmonocd_w5regular_">readln()</span> to take in the plaintext or ciphertext from the user. We convert all the characters to lowercase since we have only lowercase letters in our alphabet. We then check if the input string is divisible by <span class="sans_thesansmonocd_w5regular_">3</span> <span aria-label="annotation1" class="codeannotation">❶</span> and pad it with spaces if not. Finally, we use a <span class="sans_thesansmonocd_w5regular_">for</span> loop with a step size of <span class="sans_thesansmonocd_w5regular_">3</span> to break the text into three-character blocks. Each one is stored in a <span class="sans_thesansmonocd_w5regular_">Block</span> object and added to the <span class="sans_thesansmonocd_w5regular_">blocks</span> mutable list.</p>
<p class="tx"><span aria-label="162" epub:type="pagebreak" id="pg_162" role="doc-pagebreak"/>The remainder of the helper functions do the work of actually encrypting and decrypting the text.</p>
<pre class="calibre10"><code class="calibre11">fun encrypt() {
    for (block in blocks) {
        getIndexBlock(block)
        encryptIndexBlock()
        addToProcessedText()
    }
}

fun decrypt() {
    for (block in blocks) {
        getIndexBlock(block)
        decryptIndexBlock()
        addToProcessedText()
    }
}

fun getIndexBlock(block: Block) {
    val (x,y,z) = block
    indexVector[0] = alphabet.indexOf(x)
    indexVector[1] = alphabet.indexOf(y)
    indexVector[2] = alphabet.indexOf(z)
}

fun encryptIndexBlock() {
    for (j in 0 until  3) {
        var sum = 0
        for (i in 0 until  3) {
            sum += indexVector[i] * key[i][j]
        }
        processedVector[j] = sum % 29
    }
}

fun decryptIndexBlock() {
    for (j in 0 until  3) {
        var sum = 0
        for (i in 0 until  3) {
            sum += indexVector[i] * keyInv[i][j]
        }
        processedVector[j] = sum % 29
    }
}

fun addToProcessedText() {
    processedVector.forEach {i -&gt;
        processedText += alphabet[i]
    }
}

<span aria-label="163" epub:type="pagebreak" id="pg_163" role="doc-pagebreak"/>fun printProcessedText(choice: Int) {
    when(choice) {
        1 -&gt; println("\nHere is the encrypted text:")
        2 -&gt; println("\nHere is the decrypted text:")
    }
    print(processedText.joinToString(""))
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">encrypt()</span> and <span class="sans_thesansmonocd_w5regular_">decrypt()</span> functions both iterate through the <span class="sans_thesansmonocd_w5regular_">Block</span> objects in the <span class="sans_thesansmonocd_w5regular_">blocks</span> list and call a series of helpers to process them. The first helper called is the <span class="sans_thesansmonocd_w5regular_">getIndexBlock()</span> function, which looks up each character’s index in the <span class="sans_thesansmonocd_w5regular_">alphabet</span> string, thereby converting each character to an integer. The values are stored in the <span class="sans_thesansmonocd_w5regular_">indexVector</span> array.</p>
<p class="tx">Next, we call <span class="sans_thesansmonocd_w5regular_">encryptIndexBlock()</span> or <span class="sans_thesansmonocd_w5regular_">decryptIndexBlock()</span>, which converts the plaintext vector into a cipher (encrypted) vector or vice versa by multiplying the vector by the appropriate matrix (<span class="sans_thesansmonocd_w5regular_">key</span> or <span class="sans_thesansmonocd_w5regular_">keyInv</span>), modulo 29. Multiplying a vector by a matrix is much like multiplying two matrices, but in this case, we need only two levels of <span class="sans_thesansmonocd_w5regular_">for</span> loops. The result goes in the <span class="sans_thesansmonocd_w5regular_">processedVector</span> array.</p>
<p class="tx">Our last encryption and decryption helper is the <span class="sans_thesansmonocd_w5regular_">addToProcessedText()</span> function, which takes each number from the <span class="sans_thesansmonocd_w5regular_">processedVector</span> array, looks up the corresponding character from the <span class="sans_thesansmonocd_w5regular_">alphabet</span> string, and adds that character to <span class="sans_thesansmonocd_w5regular_">processedText</span>, a mutable list. In the end, once all the vectors are processed, this list contains the final encrypted or decrypted text. Back in <span class="sans_thesansmonocd_w5regular_">main()</span>, we call the <span class="sans_thesansmonocd_w5regular_">printProcessedText()</span> function, which concatenates all the characters stored in the <span class="sans_thesansmonocd_w5regular_">processedText</span> list into a single string for easy printing.</p>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h4 class="h1"><span id="sec27"/><span id="h2-79"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">Here’s a sample run of the program in encryption mode:</p>
<pre class="calibre10"><code class="calibre11">*** Cryptography with Hill's Method ***

key matrix dimension:
3  x  3

[key * keyInv] mod 29 =
1    0    0
0    1    0
0    0    1

Enter 1 for encryption or 2 for decryption:
<b class="calibre6">1</b>
You have chosen encryption

Enter text for processing:
<b class="calibre6">Code is like humor. It is bad code when you have to explain it.</b>

Here is the encrypted text:
tsgsiomjjnhtvwpqxs.ahk?ru gbn tsgbtynurosksdoqfb a?ujsmtexvjcji</code></pre>
<p class="tx"><span aria-label="164" epub:type="pagebreak" id="pg_164" role="doc-pagebreak"/>First, notice the validation check: the product of the two matrices is indeed an identity matrix, with ones running along the diagonal and zeros everywhere else. Then notice the final output, where the program has turned the readable plaintext into unreadable gibberish. The process also works in reverse: if you choose the decryption option (enter <span class="sans_thesansmonocd_w7bold_">2</span>) and input the encrypted text, the program will instantly convert the ciphertext back to the original plaintext.</p>
<p class="tx">Currently, the final result is displayed in all lowercase letters. I invite you to improve the <span class="sans_thesansmonocd_w5regular_">printProcessedText()</span> function so that the final result is capitalized as needed before printing. If you’re thorough, you’ll soon realize that implementing a complete set of capitalization rules isn’t as simple as it sounds.</p>
<p class="headaexercise" id="pre-16"><span class="sans_dogma_ot_bold_b_15-n">Project 16: Simulate a One-Dimensional Random Walk</span></p>
<p class="tni">So far in this chapter, the projects have all been <i class="calibre9">deterministic</i>, meaning there’s a unique solution for a given set of input parameters. If we were to run the code multiple times with the same input, the output would remain unchanged. In this project, we’ll explore a different kind of problem, one that’s <i class="calibre9">stochastic</i> in nature. In a stochastic problem, the output for a given set of inputs isn’t predetermined. We may be aware of various possible outcomes, or a range within which the output will fall, but the specific value generated by an individual instance of the experiment is determined purely by chance. To illustrate this concept, we’ll probe the idea of a random walk.</p>
<p class="tx">A <i class="calibre9">random walk</i> is a process made up of a series of <i class="calibre9">random steps</i>, actions with multiple possible outcomes. We know the probability of each potential outcome, but the actual outcome is determined randomly. For example, rolling a die is a type of random step. Assuming the die is fair, each of its six sides will have the same likelihood of landing face up (one-sixth, or approximately 16.67 percent). Therefore, when we actually roll the die, we can’t know for sure what number we’ll get. Our guesses will be correct only 16.67 percent of the time.</p>
<p class="tx">Random walks can be described using a <i class="calibre9">mathematical space</i> with a certain number of dimensions, depending on the nature of the random step. Let’s say we’re considering the movement of a heavily inebriated person who has just come out of a pub. The street in front of the pub runs east–west. This person is totally disoriented and is taking random steps along the street in both directions. We can mathematically describe the distance the person travels over time as the sum of individual steps along the x-direction (the x-axis being the east–west line). We could record each step toward the east as +1 and a step in the opposite direction as −1 (assuming all steps cover the same distance). This is an example of a one-dimensional random walk—we need only the x-axis to describe it mathematically.</p>
<p class="tx">Now suppose the person has been drinking in the middle of an open field and has started to wander randomly in different directions. The person’s steps can now have both an x-component (east or west) and a y-component (north or south). In this case, to measure the distance <span aria-label="165" epub:type="pagebreak" id="pg_165" role="doc-pagebreak"/>traveled from the center of the field, we’ll have to track the person’s movements in a two-dimensional space, which will make this a two-dimensional random walk problem.</p>
<p class="tx">A well-known example of a random walk is <i class="calibre9">Brownian motion</i>, named for Robert Brown, a 19th-century Scottish botanist. Using a microscope, Brown was observing grains of pollen immersed in water when he noticed that the grains were constantly moving in random directions. In fact, we can find similar movements whenever very small particles are injected in a fluid medium, such as dust or smoke particles in the air or the movement of particles in a colloidal suspension such as milk or paint. Brown’s observation was an important scientific discovery that remained unexplained for more than half a century until 1905, when Albert Einstein explained that Brownian motion was caused by the continuous bombardment of the pollen grains by the surrounding water molecules.</p>
<p class="tx">In this exercise, we’ll build and simulate a 1D random walk model in Kotlin. This will allow us to gain a deeper insight into how particles or objects move in one dimension through random steps. In particular, by repeating the simulation many times and plotting the results, we’ll be able to identify patterns and explore the statistical properties that underlie this dynamic behavior.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="h1"><span id="sec28"/><span id="h2-80"/><span class="sans_futura_std_bold_condensed_oblique_">A One-Dimensional Model</span></h4>
<p class="tni">Imagine a single particle moving randomly along a line in small steps. For simplicity’s sake, we’ll assume that the particle’s step size remains constant and that steps are made at steady time intervals (we do not need to use time as an explicit variable in our model). Physicists often call this scenario a <i class="calibre9">free diffusion</i> problem in one dimension. The process is schematically shown in <a href="chapter4.xhtml#fig4-6" class="calibre2">Figure 4-6</a>.</p>
<figure class="img"><img alt="" class="img1" height="252" id="fig4-6" src="../images/Figure4-6.jpg" width="1667"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 4-6: A random walk in one dimension, starting at</span> <span class="sans_futura_std_book_">x</span> <span class="sans_futura_std_book_oblique_">= 0</span></p></figcaption>
</figure>
<p class="tx">The particle starts at location <i class="calibre9">x</i> = 0 and moves in discrete steps of length <span class="copyright_accent"><span lang="el" xml:lang="el">Δ</span></span><i class="calibre9">x</i> = ±1. The direction of the particle’s movement is random, so its next position after 0 can be either 1 (with a displacement of +1) or 2 (with a displacement of −1). The probability <i class="calibre9">p</i> of choosing either direction is equal, so <i class="calibre9">p</i> = 0.5. Notice that at any given location, the particle can change its direction, so it’s possible for the particle to take several random steps and end up back where it started.</p>
<p class="tx">The question we’re interested in exploring is this: After making an arbitrary number of steps, <i class="calibre9">n</i>, how far on average will the particle have moved from its starting position? To answer this question, we’ll need to simulate <span aria-label="166" epub:type="pagebreak" id="pg_166" role="doc-pagebreak"/>many random walks—say, 500 walks of 1,000 steps each—and analyze the results. We can’t simply take the average of the cumulative distances traveled in the different simulations, however; the particle can drift in both the positive and negative x-directions, so the net-positive and net-negative distances would likely cancel each other out, giving us an average distance of roughly 0. Instead, we’ll use the <i class="calibre9">root-mean-square (RMS) distance</i>, which is calculated in three steps:</p>
<p class="listnumber">  1.  Square all the distances from all the simulations after a given number of steps <span class="copyright_italic">n</span>. This converts any negative numbers to positive numbers.</p>
<p class="listnumber1">  2.  Add all the results from step 1 and divide by the number of simulations to find the mean (average) of the squared distances.</p>
<p class="listnumber2">  3.  Take the square root of step 2’s result to arrive at the RMS distance.</p>
<p class="tx">Based on past research conducted on one-dimensional random walks, we know that the RMS distance exhibits a nonlinear relationship with the number of steps taken; in theory, the RMS distance after the <i class="calibre9">n</i>th step should equal the square root of <i class="calibre9">n</i>. To validate this notion, we’ll compute the RMS distance (the <i class="calibre9">simulated</i> RMS) and the square root of <i class="calibre9">n</i> (the <i class="calibre9">theoretical</i> RMS) and plot them both against the number of steps, <i class="calibre9">n</i>. Hopefully, the two plots will be similar. We’ll also plot the mean distance traveled at each time step, which should remain close to 0.</p>
<p class="tx">In a separate graph, we’ll visualize the trajectories of the 500 random walks themselves. This should help illustrate the random nature of the outcomes and give further support to our theories about the cumulative and RMS distances traveled.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="h1"><span id="sec29"/><span id="h2-81"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">I’ll present the code segments for this project in a top-down sequence, starting with some general setup code. Since we want to visualize the random walks from different simulations and examine the relationship between the cumulative, mean, and RMS distances with the number of steps, we’ll use the JavaFX template that we developed and used in <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span>.</p>
<pre class="calibre10"><code class="calibre11">// import block
import javafx.application.Application
import javafx.scene.Node
import javafx.scene.Scene
import javafx.scene.chart.LineChart
import javafx.scene.chart.NumberAxis
import javafx.scene.chart.XYChart
import javafx.scene.control.ScrollPane
import javafx.scene.layout.Background
import javafx.scene.layout.BackgroundFill
import javafx.scene.layout.CornerRadii
import javafx.geometry.Insets
import javafx.scene.layout.VBox
<span aria-label="167" epub:type="pagebreak" id="pg_167" role="doc-pagebreak"/>import javafx.scene.paint.Color
import javafx.stage.Stage
import kotlin.math.sqrt

// data class
<span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> data class State(
    var step: Double,
    var dist: Double
)

// global parameters
val numStep = 1000
val numSim = 500

<span aria-label="annotation2" class="codeannotated_codeannotation">❷</span> // Create lists needed for plotting line charts.
val xList  : List&lt;State&gt; = List(numStep) {State(0.0, 0.0)}
val avgList: List&lt;State&gt; = List(numStep) {State(0.0, 0.0)}
val rmsList: List&lt;State&gt; = List(numStep) {State(0.0, 0.0)}
val expList: List&lt;State&gt; = List(numStep) {State(0.0, 0.0)}

val states1 = mutableListOf&lt;List&lt;State&gt;&gt;()
val states2 = mutableListOf&lt;List&lt;State&gt;&gt;()

class RandomWalk1D : Application() {
    override fun start(primaryStage: Stage) {
      <span aria-label="annotation3" class="code_codeannotation">❸</span> val root = VBox()
        /*------------------------------------------*/
      <span aria-label="annotation4" class="code_codeannotation">❹</span> root.styleClass.add("color-palette")
        root.background = Background(BackgroundFill(Color.WHITE,
             CornerRadii.EMPTY, Insets.EMPTY))
        /*------------------------------------------*/
      <span aria-label="annotation5" class="code_codeannotation">❺</span> val scroll = ScrollPane()
        scroll.setContent = root
        val scene = Scene(scroll, 550.0, 850.0, Color.WHITE)
        primaryStage.title = "1D random Walk Simulation"
        primaryStage.scene = scene
        primaryStage.show()

        // ----- Random walk simulation starts here. -----
        // Call random walk function.
        randomWalk1d()
        // Get the theoretical RMS values.
        calcRMS1d()
        // Create line charts.
        createRWChart1(root)
        createRWChart2(root)
    }
}

fun main() {
    Application.launch(RandomWalk1D::class.java)
}</code></pre>
<p class="tx"><span aria-label="168" epub:type="pagebreak" id="pg_168" role="doc-pagebreak"/>The code segment starts with the import block. Since this project will use the XY charting features of JavaFX instead of the canvas feature, the import block is somewhat different from what we needed for <span><a href="chapter4.xhtml#pre-13" class="calibre2">Project 13</a></span>, and it includes a few extra lines of code to import the <span class="sans_thesansmonocd_w5regular_">Background</span>, <span class="sans_thesansmonocd_w5regular_">BackgroundFill</span>, <span class="sans_thesansmonocd_w5regular_">CornerRadii</span>, and <span class="sans_thesansmonocd_w5regular_">Insets</span> features, which we’ll use to set the chart background to white.</p>
<p class="tx">Next, we declare a simple data class <span class="sans_thesansmonocd_w5regular_">State</span> <span aria-label="annotation1" class="codeannotation">❶</span> for holding individual data points during the simulation. Its <span class="sans_thesansmonocd_w5regular_">step</span> property represents the number of steps taken since the beginning of the random walk, and <span class="sans_thesansmonocd_w5regular_">dist</span> is the cumulative distance traveled after that many steps. We then declare two global parameters: <span class="sans_thesansmonocd_w5regular_">numStep</span>, to specify the maximum number of steps per simulation, and <span class="sans_thesansmonocd_w5regular_">numSim</span>, to set the maximum number of simulations.</p>
<p class="tx">We’ll accumulate data in a number of lists <span aria-label="annotation2" class="codeannotation">❷</span>, each of size <span class="sans_thesansmonocd_w5regular_">numStep</span> and type <span class="sans_thesansmonocd_w5regular_">State</span>, as follows:</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">xList</span> Stores the cumulative distance traveled after each step for a particular simulation</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">avgList</span> Stores the arithmetic average (mean) of the cumulative distances traveled across all simulations after each step</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">rmsList</span> Stores the RMS distance calculated across all simulations after each step</p>
<p class="runinpara"><span class="sans_thesansmonocd_w7bold_">expList</span> Stores the theoretical (exponential) RMS distance after each step</p>
<p class="tni">All these lists are initialized to <span class="sans_thesansmonocd_w5regular_">(0.0, 0.0)</span>, meaning all simulations start at step number 0 and position 0. In addition to these lists, we also create two mutable lists, <span class="sans_thesansmonocd_w5regular_">states1</span> and <span class="sans_thesansmonocd_w5regular_">states2</span>, which we’ll use for charting purposes.</p>
<p class="tx">Inside the <span class="sans_thesansmonocd_w5regular_">RandomWalk1D</span> application class, we use a <span class="sans_thesansmonocd_w5regular_">VBox</span> container <span aria-label="annotation3" class="codeannotation">❸</span> to hold the chart objects, as we’ll generate two sets of charts that will be placed vertically inside the <span class="sans_thesansmonocd_w5regular_">VBox</span>. Notice the additional lines of code for setting the background of the container to white programmatically <span aria-label="annotation4" class="codeannotation">❹</span>, without using the cascading style sheets needed for more extensive customizations. We’ve also introduced the <span class="sans_thesansmonocd_w5regular_">ScrollPane</span> feature <span aria-label="annotation5" class="codeannotation">❺</span>, which will allow us to scroll the chart window to view the top or the bottom chart, as needed. We can also enlarge the window to make both charts visible at the same time.</p>
<p class="tx">After setting up the graphics window, we call three custom functions that will run the simulation and help visualize the results. The first call is to the <span class="sans_thesansmonocd_w5regular_">randomWalk1d()</span> function, which simulates <span class="sans_thesansmonocd_w5regular_">numSim</span> one-dimensional random walks over <span class="sans_thesansmonocd_w5regular_">numStep</span> steps. Here’s how it works:</p>
<pre class="calibre10"><code class="calibre11">fun randomWalk1d() {
    // Create local arrays.
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val s = Array (numSim) {DoubleArray(numStep)}
    val sumX = DoubleArray(numStep)
    val sumX2 = DoubleArray(numStep)

    // Walk numStep steps numSim times.
    for (i in 0 until numSim) {
        var draw: Int
        var step: Int
<span aria-label="169" epub:type="pagebreak" id="pg_169" role="doc-pagebreak"/>        for (j in 1 until numStep) {
          <span aria-label="annotation2" class="code_codeannotation">❷</span> draw = (0..1).random()
            step = if (draw == 0) -1 else 1
          <span aria-label="annotation3" class="code_codeannotation">❸</span> s[i][j] = s[i][j-1] + step
            sumX[j] += s[i][j]
            sumX2[j] += (s[i][j] * s[i][j])
            xList[j].step = j.toDouble()
            xList[j].dist = s[i][j]
        }
      <span aria-label="annotation4" class="code_codeannotation">❹</span> states1.add(xList.map {it.copy()})
    }

    // Create average (mean) and RMS for distances traveled.
    for (j in 0 until numStep) {
        avgList[j].step = j.toDouble()
        avgList[j].dist = sumX[j] / numSim
        rmsList[j].step = j.toDouble()
        rmsList[j].dist = sqrt(sumX2[j] / numSim)
    }
  <span aria-label="annotation5" class="code_codeannotation">❺</span> states2.addAll(listOf(avgList, rmsList))
}</code></pre>
<p class="tx">The function body starts by creating three local arrays of type <span class="sans_thesansmonocd_w5regular_">DoubleArray</span>. The first, <span class="sans_thesansmonocd_w5regular_">s</span>, is a two-dimensional array that stores the cumulative distance traveled at each step of each simulation <span aria-label="annotation1" class="codeannotation">❶</span>. The others are one-dimensional arrays, <span class="sans_thesansmonocd_w5regular_">sumX</span> and <span class="sans_thesansmonocd_w5regular_">sumX2</span>, to save the running sums of the cumulative distances at each step and the sums of squared distances at each step, respectively. We’ll use these values to get the mean and RMS distances.</p>
<p class="tx">The random walks are implemented inside a nested <span class="sans_thesansmonocd_w5regular_">for</span> loop. The outer loop controls the number of simulations, and the inner loop makes the particle take <span class="sans_thesansmonocd_w5regular_">numStep</span> steps in succession. During each step, a local variable <span class="sans_thesansmonocd_w5regular_">draw</span> is randomly set to either <span class="sans_thesansmonocd_w5regular_">0</span> or <span class="sans_thesansmonocd_w5regular_">1</span> with equal likelihood <span aria-label="annotation2" class="codeannotation">❷</span>. Based on the outcome, <span class="sans_thesansmonocd_w5regular_">step</span> (referred to as <span class="copyright_accent"><span lang="el" xml:lang="el">Δ</span></span><i class="calibre9">x</i> in <a href="chapter4.xhtml#fig4-6" class="calibre2">Figure 4-6</a>) is set to <span class="sans_thesansmonocd_w5regular_">-1</span> or <span class="sans_thesansmonocd_w5regular_">1</span>, which is then added to the cumulative distance traveled up to the previous step of the simulation <span aria-label="annotation3" class="codeannotation">❸</span>. These cumulative distances are used to create the elements of <span class="sans_thesansmonocd_w5regular_">xList</span>, which is then copied and passed on to <span class="sans_thesansmonocd_w5regular_">states1</span> once per simulation <span aria-label="annotation4" class="codeannotation">❹</span>. Notice how we’re reusing the memory allocated for <span class="sans_thesansmonocd_w5regular_">xList</span> during each simulation by overwriting the values of its elements. In the end, <span class="sans_thesansmonocd_w5regular_">states1</span> has all the data we need to visualize the random walks themselves.</p>
<p class="tx">Once we’re done with the random walks, we use the resulting lists, <span class="sans_thesansmonocd_w5regular_">sumX</span> and <span class="sans_thesansmonocd_w5regular_">sumX2</span>, to create the <span class="sans_thesansmonocd_w5regular_">avgList</span> and <span class="sans_thesansmonocd_w5regular_">rmsList</span> inside another <span class="sans_thesansmonocd_w5regular_">for</span> loop by dividing the elements of <span class="sans_thesansmonocd_w5regular_">sumX</span> and <span class="sans_thesansmonocd_w5regular_">sumX2</span> by <span class="sans_thesansmonocd_w5regular_">numSim</span>. Here <span class="sans_thesansmonocd_w5regular_">sumX[j]</span> is the sum of all the elements in column <span class="sans_thesansmonocd_w5regular_">j</span> of the <span class="sans_thesansmonocd_w5regular_">s[i][j]</span> matrix, where <span class="sans_thesansmonocd_w5regular_">i</span> represents the simulation number and <span class="sans_thesansmonocd_w5regular_">j</span> represents the number of steps taken so far. (Likewise, <span class="sans_thesansmonocd_w5regular_">sumX2[j]</span> is the same, squared.) Finally, <span class="sans_thesansmonocd_w5regular_">avgList</span> and <span class="sans_thesansmonocd_w5regular_">rmsList</span> are passed on as elements of <span class="sans_thesansmonocd_w5regular_">states2</span> <span aria-label="annotation5" class="codeannotation">❺</span>, which we defined earlier as a list of lists.</p>
<p class="tx">The second function call inside the application class is <span class="sans_thesansmonocd_w5regular_">calcRMS1d()</span>. It generates the theoretical RMS distance at each step:</p>
<pre class="calibre10"><code class="calibre11">fun calcRMS1d() {
    // Create the theoretical (exponential) rms/list.
<span aria-label="170" epub:type="pagebreak" id="pg_170" role="doc-pagebreak"/>    for (j in 0 until numStep) {
        expList[j].step = j.toDouble()
      <span aria-label="annotation1" class="code_codeannotation">❶</span> expList[j].dist = sqrt(j.toDouble())
    }
    states2.add(expList)
}</code></pre>
<p class="tx">We know from the theoretical analysis of the one-dimensional random walk problem that the RMS distance is a nonlinear function of the number of steps <i class="calibre9">n</i>, which can be expressed as <i class="calibre9">x</i><span class="epub-i-sub">n</span> = √<i class="calibre9">n</i>, where <i class="calibre9">x</i><span class="epub-i-sub">n</span> is the RMS distance for the <i class="calibre9">n</i>th step (<i class="calibre9">n</i> is equivalent to looping variable <span class="sans_thesansmonocd_w5regular_">j</span> in the code). We use this relationship in the <span class="sans_thesansmonocd_w5regular_">calcRMS1d()</span> function to calculate the theoretical RMS distances and update <span class="sans_thesansmonocd_w5regular_">expList</span> <span aria-label="annotation1" class="codeannotation">❶</span>. We’ll use this list to create a side-by-side plot of the theoretical and simulated RMS distances to see how closely they follow each other.</p>
<p class="tx">In the last two lines of the application class, we make two successive calls to the <span class="sans_thesansmonocd_w5regular_">createRWChart1()</span> and <span class="sans_thesansmonocd_w5regular_">createRWChart2()</span> functions, shown here:</p>
<pre class="calibre10"><code class="calibre11">fun createRWChart1(root: VBox) {
    val xyChart1 =
        singleXYChart(states1,
            title = "Random Walk 1D Experiment",
            xLabel = "Steps",
            yLabel = "Cumulative distance traveled")
    root.children.add(xyChart1)
}

fun createRWChart2(root: VBox) {
    val xyChart2 =
        singleXYChart(states2,
            title = "Random Walk 1D Experiment",
            xLabel = "Steps",
            yLabel = "Mean and RMS distance traveled")
    root.children.add(xyChart2)
}</code></pre>
<p class="tx">Other than the chart labels, the only difference between these two functions is that the first one uses <span class="sans_thesansmonocd_w5regular_">states1</span> and the second one uses <span class="sans_thesansmonocd_w5regular_">states2</span> to generate the respective charts. Both of these functions call the <span class="sans_thesansmonocd_w5regular_">singleXYChart()</span> function (which we discussed and used in <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span>) to draw the line charts and stack them inside a scroll pane.</p>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h4 class="h1"><span id="sec30"/><span id="h2-82"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">When you run the full code on your device, you should see a single scrollable window pop up with two separate charts. Let’s first consider the visualization of the random walks themselves, shown in <a href="chapter4.xhtml#fig4-7" class="calibre2">Figure 4-7</a>.</p>
<span aria-label="171" epub:type="pagebreak" id="pg_171" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img2" height="859" id="fig4-7" src="../images/Figure4-7.jpg" width="1041"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 4-7: The random walk paths from 500 simulations of 1,000 steps</span></p></figcaption>
</figure>
<p class="tx">This chart shows all 500 random paths generated by the <span class="sans_thesansmonocd_w5regular_">randomWalk1d()</span> function (one per simulation, based on our global <span class="sans_thesansmonocd_w5regular_">numSim</span> parameter). These paths show a number of key features of one-dimensional random walks:</p>
<ul class="ul">
<li class="listbullet">Each random path is unique, evident from the tangled web of lines moving across the chart.</li>
<li class="listbullet">Most random walks tend to stay close to their starting position, even after many steps. We can see this in the darker band along the x-axis.</li>
<li class="listbullet">The paths are equally dispersed on both sides of <span class="listbullet_italic">x</span> = 0, as expected. You could confirm this by creating histograms of the cumulative distances traveled at different numbers of steps. (I’ll leave this for you to try out as an exercise.)</li>
<li class="listbullet">For any given number of steps, if we add the cumulative distances from all simulations, the sum will be close to zero because positive and negative distances will cancel each other. For the same reason, the arithmetic mean will also be close to zero.</li>
<li class="listbullet">The RMS distance increases with the number of steps, as confirmed by the gradual widening of the band that envelops all random paths. The RMS distance is therefore a better measure for the average distance traveled than the arithmetic mean, as we don’t care about the direction of the movement.</li>
</ul>
<p class="tx">All these points collectively provide the answer we were seeking at the start of this project. A particle moving randomly in one dimension will likely trace a path that will initially stay close to its starting position. <span aria-label="172" epub:type="pagebreak" id="pg_172" role="doc-pagebreak"/>However, if we follow the particle for a long time, it may gradually move farther away. Again, we can’t predict exactly how far a particular particle will move, but if we measure the RMS distance from many different particles, we’ll see that the RMS distance increases with the number of steps. Our other chart, shown in <a href="chapter4.xhtml#fig4-8" class="calibre2">Figure 4-8</a>, helps us explore this last point further.</p>
<figure class="img"><img alt="" class="img2" height="859" id="fig4-8" src="../images/Figure4-8.jpg" width="1042"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 4-8: The mean and RMS distances traveled for a given number of steps</span></p></figcaption>
</figure>
<p class="tx"><a href="chapter4.xhtml#fig4-8" class="calibre2">Figure 4-8</a> charts three lines. First, we have the line labeled “Simulated mean,” generated from the data in <span class="sans_thesansmonocd_w5regular_">avgList</span>. This line stays very close to zero, confirming one of the key points made based on <a href="chapter4.xhtml#fig4-7" class="calibre2">Figure 4-7</a>: that the arithmetic average or mean for any number of steps will be zero if we have a sufficiently large number of observations. Second, we have the “Simulated RMS” line, generated from the data in <span class="sans_thesansmonocd_w5regular_">rmsList</span>, which clearly shows the RMS distance increasing (although at a decreasing rate) with the number of steps. Third, the smooth “Theoretical RMS” line represents the theoretical RMS distances from <span class="sans_thesansmonocd_w5regular_">expList</span>, calculated by simply taking the square root of the number of steps. Again, we can visually confirm that the simulated RMS values are very close to the theoretically expected RMS values.</p>
<p class="tx">The minor discrepancies we see between the simulated and theoretical RMS values are to be expected. The simulated RMS values will approach the theoretical values as the number of simulations approaches infinity. I invite you to run the code again, this time setting <span class="sans_thesansmonocd_w5regular_">numSim</span> to <span class="sans_thesansmonocd_w5regular_">5000</span>. Make sure that you comment out the call to the <span class="sans_thesansmonocd_w5regular_">createRWChart1()</span> function before doing that. The default implementation of JavaFX is memory and computation intensive, and trying to plot 5,000 lines, each with 1,000 data points, can take a while depending on your processor and memory configuration. However, if you do this experiment as suggested, you’ll see that with the added <span aria-label="173" epub:type="pagebreak" id="pg_173" role="doc-pagebreak"/>random walks, the simulated and theoretical RMS lines become virtually the same. If you go further by setting <span class="sans_thesansmonocd_w5regular_">numSim</span> to <span class="sans_thesansmonocd_w5regular_">50000</span>, you’ll see only one line.</p>
<aside aria-label="box-26" class="box2">
<p class="boxtitle" id="box-26"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Now that you’ve seen how to model a random walk in one dimension, try extending your random walk app to model molecular diffusion in two dimensions. The effect should be similar to adding a drop of food coloring to the center of a dish of water and watching the color spread.</span></p>
<p class="box1"><span class="sans_futura_std_book_">Hint: To be able to track distances in 2D, the</span> <span class="sans_thesansmonocd_w5regular_">State</span> <span class="sans_futura_std_book_">data class has to be changed to replace</span> <span class="sans_thesansmonocd_w5regular_">dist</span> <span class="sans_futura_std_book_">with two values for the x- and y-components—say,</span> <span class="sans_thesansmonocd_w5regular_">distX</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">distY</span><span class="sans_futura_std_book_">. At each step in the random walk, treat these values separately. For the x-component, for example, assume that a particle can either stay still, move toward the positive x-direction, or move toward the negative x-direction. You can code this as</span> <span class="sans_thesansmonocd_w5regular_">stepX</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">(-1..1).random()</span><span class="sans_futura_std_book_">, meaning</span> <span class="sans_thesansmonocd_w5regular_">stepX</span> <span class="sans_futura_std_book_">is equally likely to be</span> <span class="sans_thesansmonocd_w5regular_">-1</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">0</span><span class="sans_futura_std_book_">, or</span> <span class="sans_thesansmonocd_w5regular_">1</span><span class="sans_futura_std_book_">. Repeat the same for the y-component.</span></p>
<p class="boxlast"><span class="sans_futura_std_book_">Define how large you want the dish to be (set an appropriate diameter), and decide what happens when a particle hits the boundary of the dish. (Perhaps the particle should bounce off the wall.) Update the particle positions inside a nested</span> <span class="sans_thesansmonocd_w5regular_">for</span> <span class="sans_futura_std_book_">loop, and update the series for charting using the</span> <span class="sans_thesansmonocd_w5regular_">ScatterChart</span> <span class="sans_futura_std_book_">feature of JavaFX. Start with 300 particles. To show particle positions dynamically (which looks really cool), run the random walk function and update the data points as an animation, using</span> <span class="sans_thesansmonocd_w5regular_">Timeline</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">KeyFrame</span><span class="sans_futura_std_book_">, as discussed in <a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span><span class="sans_futura_std_book_">.</span></p>
</aside>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h3 class="h"><span id="sec31"/><span id="h1-35"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, we used Kotlin code and custom algorithms to solve math-related problems. The problems weren’t just theoretical; they also had practical applications in fields like mathematics, geodesy, navigation, and cryptography. Throughout our journey, we employed various mathematical concepts, operations, and tools, including basic arithmetic, math and trigonometric functions, the Pythagorean theorem, the Fibonacci sequence, the haversine formula, modulo operations, and linear algebra. We also probed the realm of stochastic processes, exploring the generation and utilization of random numbers to simulate random phenomena.</p>
<p class="tx">Along the way, we used many core features of Kotlin, such as variables and collections, data classes, and conditional and iterative structures like <span class="sans_thesansmonocd_w5regular_">if</span>, <span class="sans_thesansmonocd_w5regular_">when</span>, <span class="sans_thesansmonocd_w5regular_">for</span>, and <span class="sans_thesansmonocd_w5regular_">while</span>. We also discovered the convenience of functions and lambdas, along with the rich set of mathematical and graphics library functions at our disposal.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<span aria-label="174" epub:type="pagebreak" id="pg_174" role="doc-pagebreak"/>
<h3 class="h"><span id="sec32"/><span id="h1-36"/><span class="sans_futura_std_bold_b_">Resources</span></h3>
<p class="reference">Ayars, Eric. “Stochastic Methods.” In <i class="calibre9">Computational Physics with Python</i>, 131–139. August 18, 2013. Accessed June 15, 2024. <i class="calibre9"><a href="https://belglas.files.wordpress.com/2018/03/cpwp.pdf" class="calibre2">https://belglas.files.wordpress.com/2018/03/cpwp.pdf</a></i>.</p>
<p class="reference">Dutka, Jacques. “Eratosthenes’ Measurement of the Earth Reconsidered.” <i class="calibre9">Archive for History of Exact Sciences</i> 46, no. 1 (1993): 55–66. Accessed June 15, 2024. <i class="calibre9"><a href="http://www.jstor.org/stable/41134135" class="calibre2">http://<wbr/>www<wbr/>.jstor<wbr/>.org<wbr/>/stable<wbr/>/41134135</a></i>.</p>
<p class="reference">Eisenberg, Murray. “Hill Ciphers and Modular Linear Algebra.” November 3, 1999. Accessed June 15, 2024. <i class="calibre9"><a href="https://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf" class="calibre2">https://apprendre-en-ligne.net/crypto/hill/Hillciph.pdf</a></i>.</p>
<p class="reference">Harder, Douglas. “Project H.1: Sieve of Eratosthenes.” University of Waterloo. Accessed June 15, 2024. <i class="calibre9"><a href="https://ece.uwaterloo.ca/~ece150/Programming_challenges/H/1/" class="calibre2">https://ece.uwaterloo.ca/~ece150/Programming_challenges/H/1/</a>.</i></p>
<p class="reference">Kereki, Federico. “A Modern Look at Square Roots in the Babylonian Way.” <i class="calibre9">Cantor’s Paradise</i>. December 7, 2020. Accessed June 15, 2024. <i class="calibre9"><a href="https://medium.com/cantors-paradise/a-modern-look-at-square-roots-in-the-babylonian-way-ccd48a5e8716" class="calibre2">https://medium.com/cantors-paradise/a-modern-look-at-square-roots-in-the-babylonian-way-ccd48a5e8716</a></i>.</p>
<p class="reference">“Pythagorean Triples.” Prime Glossary. Accessed June 15, 2024. <i class="calibre9"><a href="https://t5k.org/glossary/page.php?sort=PrmPythagTriples" class="calibre2">https://t5k.org/glossary/page.php?sort=PrmPythagTriples</a></i>.</p>
<p class="reference">Reich, Dan. “The Fibonacci Sequence, Spirals and the Golden Mean.” Department of Mathematics, Temple University. Accessed June 15, 2024. <i class="calibre9"><a href="https://math.temple.edu/~reich/Fib/fibo.xhtml" class="calibre2">https://math.temple.edu/~reich/Fib/fibo.xhtml</a></i>.</p>
<p class="reference">Van Brummelen, Glen. <i class="calibre9">Heavenly Mathematics: The Forgotten Art of Spherical Trigonometry</i>. Princeton, NJ: Princeton University Press, 2013.</p>
</section>
</section>
</div></body></html>