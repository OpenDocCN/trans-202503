<html><head></head><body>
<h2 class="h2" id="app02"><span epub:type="pagebreak" id="page_411"/><span class="big">B</span><br/>BECAUSE I CAN’T RESIST</h2>
<div class="image1"><img alt="Image" src="../images/common1.jpg"/></div>
<p class="noindenta">In this appendix, I include additional material related to some of the problems studied in this book. I consider this appendix as optional: it doesn’t concern material that I think is core to the goal of learning about data structures and algorithms. However, if you’re keen to learn more about a problem, this appendix is for you.</p>
<h3 class="h3" id="lev71">Unique Snowflakes: Implicit Linked Lists</h3>
<p class="noindent">It’s often the case that at compile time we don’t know how much memory our program will need. If you’ve ever asked, “How big should I make this array?” or “Will this array be big enough?” then you’ve experienced firsthand the inflexibility of C arrays: we have to choose an array size, but we might not know the size we need until the array starts filling up. In many such cases, linked lists neatly solve the problem. Whenever we require new memory to store some data, we just call <span class="literal">malloc</span> at runtime to add a node to a linked list.</p>
<p class="indent">In the first problem in <a href="ch01.xhtml">Chapter 1</a>, Unique Snowflakes, we used linked lists to chain together the snowflakes that reside in the same bucket. For every snowflake that we read in, we used <span class="literal">malloc</span> to allocate memory for <span epub:type="pagebreak" id="page_412"/>exactly one snowflake. If we read 5,000 snowflakes, we’ll have made 5,000 <span class="literal">malloc</span> calls. The time taken by these <span class="literal">malloc</span> calls can add up.</p>
<p class="indent">Wait! We just said that linked lists are useful when we don’t know how much memory we might need. In Unique Snowflakes, we <em>do</em> know! Or, at least, we know the <em>maximum</em> that we’ll need: it’s whatever is required to store at most 100,000 snowflakes.</p>
<p class="indent">That raises questions. Why are we using <span class="literal">malloc</span>, anyway? Is there a way to avoid using <span class="literal">malloc</span> and linked lists? Indeed, we can solve Unique Snowflakes in a way that doesn’t use <span class="literal">malloc</span> and leads to a doubling of speed. How?</p>
<p class="indent">The key idea is to preallocate an array of the maximum number of nodes (100,000) that we might use. The array is called <span class="literal">nodes</span>, and it stores the nodes from all of the (now-implicit) linked lists. Each element of <span class="literal">nodes</span> is an integer giving the index of the next node in its list of nodes. Let’s get a handle on this by deciphering a sample <span class="literal">nodes</span> array:</p>
<pre>[-1, 0, -1, 1, 2, 4, 5]</pre>
<p class="indent">Suppose we know that one of the lists starts at index <span class="literal">6</span>. The value of index <span class="literal">6</span>, <span class="literal">5</span>, tells us that index <span class="literal">5</span> is the next node in the list. Similarly, index <span class="literal">5</span> tells us that index <span class="literal">4</span> is the next node in the list. Index <span class="literal">4</span> tells us that index <span class="literal">2</span> is the next node in the list. What about index <span class="literal">2</span>, with the value of <span class="literal">-1</span>? We’ll use <span class="literal">-1</span> as our <span class="literal">NULL</span> value: it indicates that there’s no “next” element. We have discovered the list of indices <span class="literal">6</span>, <span class="literal">5</span>, <span class="literal">4</span>, and <span class="literal">2</span>.</p>
<p class="indent">There’s one more nonempty list in that array. Suppose we know this list starts at index <span class="literal">3</span>. Index <span class="literal">3</span> tells us that index <span class="literal">1</span> is the next node in the list. Index <span class="literal">1</span> tells us that index <span class="literal">0</span> is the next node in the list. That’s all then—index <span class="literal">0</span> is a <span class="literal">-1</span>, so the list is over. We have discovered the list of indices <span class="literal">3</span>, <span class="literal">1</span>, and <span class="literal">0</span>.</p>
<p class="indent">That’s the <span class="literal">nodes</span> array. If some index has a value of <span class="literal">-1</span>, then it’s the end of a list. Otherwise, it gives the index of the next element in the list.</p>
<p class="indent">Notice that <span class="literal">nodes</span> doesn’t tell us anything about where the lists start. We had to assume that we somehow knew that the list heads were at indices <span class="literal">6</span> and <span class="literal">3</span>. How could we have known that? By using another array, <span class="literal">heads</span>, that gives the index of the first node in a list. <span class="literal">heads</span> uses <span class="literal">-1</span> for the value of any element that does not start a list.</p>
<p class="indent">Our <span class="literal">malloc</span>-less solution uses a total of three arrays in the <span class="literal">main</span> function: <span class="literal">snowflakes</span>, <span class="literal">nodes</span>, and <span class="literal">heads</span>. The <span class="literal">snowflakes</span> array stores the actual snowflakes so that we can look up a snowflake according to the indices in <span class="literal">nodes</span> and <span class="literal">heads</span>. Here are the three arrays:</p>
<pre>static int snowflakes[SIZE][6];
static int heads[SIZE];
static int nodes[SIZE];</pre>
<p class="indent">Only two of our functions must be adjusted to move from linked lists to the implicit lists that we use here: <span class="literal">identify_identical</span> and <span class="literal">main</span>. These adjustments are about syntax, not substance: <span class="literal">identify_identical</span> still performs pairwise comparisons of all snowflakes in a list, and <span class="literal">main</span> still reads in the snowflakes and builds the lists.</p>
<p class="indent"><span epub:type="pagebreak" id="page_413"/>The new <span class="literal">identify_identical</span> is in <a href="app02.xhtml#app02ex01">Listing B-1</a>—compare this to what we had before in <a href="ch01.xhtml#ch01ex012">Listing 1-12</a>!</p>
<pre>void identify_identical(int snowflakes[][6], int heads[],
                        int nodes[]) {
  int i, node1, node2;
  for (i = 0; i &lt; SIZE; i++) {
    node1 = heads[i];
    while (node1 != -1) {
   <span class="ent">➊</span> node2 = nodes[node1];
      while (node2 != -1) {
        if (are_identical(snowflakes[node1], snowflakes[node2])) {
          printf("Twin snowflakes found.\n");
          return;
        }
     <span class="ent">➋</span> node2 = nodes[node2];
     }
   <span class="ent">➌</span> node1 = nodes[node1];
   }
  }
  printf("No two snowflakes are alike.\n");
}</pre>
<p class="excap" id="app02ex01"><em>Listing B-1: Identifying identical snowflakes in implicit linked lists</em></p>
<p class="indent">Inside the <span class="literal">for</span> loop, <span class="literal">node1</span> is set to the head of the current list. If this list is empty, then the outer <span class="literal">while</span> loop won’t run at all for this node. If it isn’t empty, then, by using the <span class="literal">nodes</span> array, <span class="literal">node2</span> is set to the node after <span class="literal">node1</span> <span class="ent">➊</span>. Rather than linked-list code like <span class="literal">node2 = node2-&gt;next</span>, we again use the <span class="literal">nodes</span> array to find the next node <span class="ent">➋ ➌</span>.</p>
<p class="indent">The new <span class="literal">main</span> function is given in <a href="app02.xhtml#app02ex02">Listing B-2</a>.</p>
<pre>int main(void) {
  static int snowflakes[SIZE][6];
  static int heads[SIZE];
  static int nodes[SIZE];
  int n;
  int i, j, snowflake_code;
  for (i = 0; i &lt; SIZE; i++) {
    heads[i] = -1;
    nodes[i] = -1;
  }
  scanf("%d", &amp;n);
  for (i = 0; i &lt; n; i++) {
    for (j = 0; j &lt; 6; j++)
      scanf("%d", &amp;snowflakes[i][j]);
    snowflake_code = code(snowflakes[i]);
  <span class="ent">➊</span> nodes[i] = heads[snowflake_code];
  <span class="ent">➋</span> heads[snowflake_code] = i;
  }
  identify_identical(snowflakes, heads, nodes);
  return 0;
}</pre>
<p class="excap" id="app02ex02"><em>Listing B-2: The</em><span epub:type="pagebreak" id="page_414"/> <span class="codeitalic1">main</span> <em>function for implicit linked lists</em></p>
<p class="indent">Suppose we have just read a snowflake and we have stored it in row <span class="literal">i</span> of <span class="literal">snowflakes</span>. We want this snowflake to become the head of its list. To accomplish this, we store the old list head at <span class="literal">nodes[i]</span> <span class="ent">➊</span>, and then we set the head of the list to be snowflake <span class="literal">i</span> <span class="ent">➋</span>.</p>
<p class="indent">Take some time to compare this solution to our linked-list solution. Which do you prefer? Is the <span class="literal">malloc</span>-less solution harder or easier for you to understand? Submit both to the judge; is the speedup worth it?</p>
<h3 class="h3" id="lev72">Burger Fervor: Reconstructing a Solution</h3>
<p class="noindent">In <a href="ch03.xhtml">Chapter 3</a>, we solved three problems—Burger Fervor, Moneygrubbers, and Hockey Rivalry—that involved minimizing or maximizing the value of a solution. In Burger Fervor, we maximized Homer’s time spent eating burgers; we gave an answer such as <span class="literal">2 2</span>, meaning two burgers and two minutes drinking beer. In Moneygrubbers, we minimized the amount of money required to purchase apples; we gave an answer such as <span class="literal">Buy 3 for $3.00</span>. In Hockey Rivalry, we maximized the number of goals in rivalry games; we gave an answer such as <span class="literal">20</span>.</p>
<p class="indent">Notice, though, that what we are doing here is giving the <em>value</em> of an optimal solution. We are not giving the optimal solution itself. We are not indicating which burgers to eat, or how to purchase the apples, or which games are the rivalry games.</p>
<p class="indent">The vast majority of optimization problems in competitive programming ask for the value of an optimal solution, which was the focus in <a href="ch03.xhtml">Chapters 3</a> and <a href="ch04.xhtml">4</a>. However, we can, if we like, use memoization and dynamic programming to return an optimal solution itself.</p>
<p class="indent">Let’s see how this is done using Burger Fervor as an example. Given the following test case:</p>
<pre>4 9 15</pre>
<p class="noindent">let’s output not only the value of an optimal solution, but an optimal solution itself, like this:</p>
<pre>2 2
Eat a 4-minute burger
Eat a 9-minute burger</pre>
<p class="indent">The first line is what we had before; the other lines constitute an optimal solution itself, proof that the <span class="literal">2 2</span> is indeed achievable.</p>
<p class="indent">Outputting an optimal solution like this is known as <em>reconstructing</em> or <em>recovering</em> a solution. Both of these words suggest that we already have the pieces that can be put together to produce the optimal solution. And that’s <span epub:type="pagebreak" id="page_415"/>true: what we need is sitting right there in the <span class="literal">memo</span> or <span class="literal">dp</span> array. Here, let’s use the <span class="literal">dp</span> array; the <span class="literal">memo</span> array could be used in precisely the same way.</p>
<p class="indent">We’re going to write the body for this function signature:</p>
<pre>void reconstruct(int m, int n, int dp[], int minutes)</pre>
<p class="noindent">Recall that we have <em>m</em>-minute and <em>n</em>-minute burgers. The <span class="literal">m</span> and <span class="literal">n</span> parameters are these values and come from the current test case. The <span class="literal">dp</span> parameter is the array that is produced by the dynamic-programming algorithm in <a href="ch03.xhtml#ch03ex08">Listing 3-8</a>. Finally, the <span class="literal">minutes</span> parameter is the number of minutes spent eating burgers. The function will print, one per line, the number of burgers that should be eaten in an optimal solution.</p>
<p class="indent">What is the last burger that Homer should eat in an optimal solution? If we were solving this problem from scratch, then we wouldn’t know this answer. We’d have to see what happens if we choose an <em>m</em>-minute burger to be last and also see what happens if we choose an <em>n</em>-minute burger to be last. Indeed, that’s what we did when solving this problem in <a href="ch03.xhtml">Chapter 3</a>. Remember, though, that we now have the <span class="literal">dp</span> array at our disposal. That array is going to tell us which of the two options is the best.</p>
<p class="indent">Here’s the key idea: take a look at <span class="literal">dp[minutes - m]</span> and <span class="literal">dp[minutes - n]</span>. Both of those values are available to us, because the <span class="literal">dp</span> array has already been constructed. Whichever of these values is larger tells us what we should use as the last burger. That is, if <span class="literal">dp[minutes - m]</span> is larger, then an <em>m</em>-minute burger is last; if <span class="literal">dp[minutes - n]</span> is larger, then an <em>n</em>-minute burger is last. (If <span class="literal">dp[minutes - m]</span> and <span class="literal">dp[minutes - n]</span> are equal, then you can choose arbitrarily whether to make the last burger an <em>m</em>-minute or <em>n</em>-minute burger.)</p>
<p class="indent">This reasoning parallels that used in <a href="ch03.xhtml#ch03ex08">Listing 3-8</a> to build the <span class="literal">dp</span> array. There, we chose the maximum of <span class="literal">first</span> and <span class="literal">second</span>; here, we reverse engineer which of those choices the dynamic-programming algorithm made.</p>
<p class="indent">Once we have deduced the final burger, we remove the time taken to eat that burger and then repeat the process. We keep going until we get down to zero minutes, at which point our reconstruction is complete. <a href="app02.xhtml#app02ex03">Listing B-3</a> gives the code for the function.</p>
<pre>void reconstruct(int m, int n, int dp[], int minutes) {
  int first, second;
  while (minutes &gt; 0) {
    first = -1;
    second = -1;
    if (minutes &gt;= m)
      first = dp[minutes - m];
    if (minutes &gt;= n)
      second = dp[minutes - n];
    if (first &gt;= second) {
      printf("Eat a %d-minute burger\n", m);
      minutes = minutes - m;
    } else {
      printf("Eat a %d-minute burger\n", n);
<span epub:type="pagebreak" id="page_416"/>      minutes = minutes - n;
    }
  }
}</pre>
<p class="excap" id="app02ex03"><em>Listing B-3: Reconstructing the solution</em></p>
<p class="indent">This function should be called in two places in <a href="ch03.xhtml#ch03ex08">Listing 3-8</a>, once after each <span class="literal">printf</span> call. The first is:</p>
<pre>reconstruct(m, n, dp, t);</pre>
<p class="noindent">The second is:</p>
<pre>reconstruct(m, n, dp, i);</pre>
<p class="indent">I encourage you to reconstruct optimal solutions for the Moneygrubbers and Hockey Rivalry problems, following this same style.</p>
<h3 class="h3" id="lev73">Knight Chase: Encoding Moves</h3>
<p class="noindent">In the Knight Chase problem of <a href="ch05.xhtml">Chapter 5</a>, we designed a BFS algorithm to find the number of moves needed for a knight to reach each square from its starting point. The knight has eight possible moves, and we wrote each of them out in our code (see <a href="ch05.xhtml#ch05ex01">Listing 5-1</a>). For example, here’s what we did to have the knight explore moving up one and right two:</p>
<pre>add_position(from_row, from_col, from_row + 1, from_col + 2,
             num_rows, num_cols, new_positions,
             &amp;num_new_positions, min_moves);</pre>
<p class="indent">Here’s what we did for up one and left two:</p>
<pre>add_position(from_row, from_col, from_row + 1, from_col - 2,
             num_rows, num_cols, new_positions,
             &amp;num_new_positions, min_moves);</pre>
<p class="indent">There is gross code duplication there: the only change is a plus sign to a minus sign! In fact, all eight moves are encoded in a very similar way, just messing around with some pluses and minuses and 1s and 2s. That kind of thing is quite error-prone.</p>
<p class="indent">Fortunately, there is a neat technique to dodge this kind of code duplication. It applies to many problems where you’re asked to explore an implicit graph of multiple dimensions (such as rows and columns).</p>
<p class="indent">Here are the knight’s eight possible moves, as presented in the problem description in <a href="ch05.xhtml">Chapter 5</a>:</p>
<ul>
<li class="noindents">Up 1, right 2</li>
<li class="noindents">Up 1, left 2</li>
<li class="noindents">Down 1, right 2</li>
<li class="noindents"><span epub:type="pagebreak" id="page_417"/>Down 1, left 2</li>
<li class="noindents">Up 2, right 1</li>
<li class="noindents">Up 2, left 1</li>
<li class="noindents">Down 2, right 1</li>
<li class="noindents">Down 2, left 1</li>
</ul>
<p class="indent">Let’s first focus on the rows and write down how each move changes the row number. The first move increases the row number by one, as does the second move. The third and fourth moves, by contrast, reduce the row number by one. The fifth and sixth moves increase the row number by two, and the seventh and eighth moves reduce the row number by two. Here’s an array of those numbers:</p>
<pre>int row_dif[8] = {1, 1, -1, -1, 2, 2, -2, -2};</pre>
<p class="indent">It’s called <span class="literal">row_dif</span> because it gives the difference in row numbers between the current row and the row after making a move.</p>
<p class="indent">Now let’s do the same thing for the columns. The first move increases the column number by two, the second move decreases the column number by two, and so on. As an array, the column differences are:</p>
<pre>int col_dif[8] = {2, -2, 2, -2, 1, -1, 1, -1};</pre>
<p class="indent">What’s useful about these two parallel arrays is that they characterize the effect that each move has on the current row and column. The numbers in <span class="literal">row_dif[0]</span> and <span class="literal">col_dif[0]</span> tell you that the first move increases the row by one and increases the column by two, those in <span class="literal">row_dif[1]</span> and <span class="literal">col_dif[1]</span> tell you that the second move increases the row by one and decreases the column by two, and so on.</p>
<p class="indent">Now, instead of typing out eight near-identical calls to <span class="literal">add_position</span>, we can use a loop of eight iterations, typing out just one call to <span class="literal">add_position</span> in there. Here’s how it’s done, using a new integer variable <span class="literal">m</span> to loop through the moves:</p>
<pre>for (m = 0; m &lt; 8; m++)
  add_position(from_row, from_col,
               from_row + row_dif[m], from_col + col_dif[m],
               num_rows, num_cols, new_positions,
               &amp;num_new_positions, min_moves);</pre>
<p class="indent">That’s better! Update your Knight Chase code from <a href="ch05.xhtml">Chapter 5</a> and give it a go with the judge. You should still pass all of the test cases and your code shouldn’t be noticeably faster or slower, but you’ve shaved off quite a bit of repetitive code, and that’s a win.</p>
<p class="indent">We had only eight moves here, so we managed to survive Knight Chase in <a href="ch05.xhtml">Chapter 5</a> without using this encoding trick. However, if we had many more moves than this, then pasting the call to <span class="literal">add_position</span> over and over simply wouldn’t be feasible. What we’ve seen here scales much more nicely.</p>
<h3 class="h3" id="lev74"><span epub:type="pagebreak" id="page_418"/>Dijkstra’s Algorithm: Using a Heap</h3>
<p class="noindent">In <a href="ch06.xhtml">Chapter 6</a>, we learned Dijkstra’s algorithm for finding shortest paths in weighted graphs. The runtime of our Dijkstra implementation was <em>O</em>(<em>n</em><sup>2</sup>), where <em>n</em> is the number of nodes in the graph. Dijkstra’s algorithm spends a lot of its time searching for minimums: on each iteration, it has to find the node whose distance is minimum of all nodes that are not done.</p>
<p class="indent">Then, in <a href="ch08.xhtml">Chapter 8</a>, we learned about max-heaps and min-heaps. A max-heap won’t help here—but a min-heap will, because its job is to quickly find the minimum. We can therefore use a min-heap to speed up Dijkstra’s algorithm. This is a match made in computer-science heaven.</p>
<p class="indent">The min-heap will hold all of the nodes that have been discovered and that are not done. It might also hold some discovered nodes that <em>are</em> done. That’s okay, though: as we did when solving the Supermarket Promotion problem with heaps in <a href="ch08.xhtml">Chapter 8</a>, we’ll just ignore any done node that happens to come off the min-heap.</p>
<h4 class="h4" id="sec179"><em>Mice Maze: Tracing with Heaps</em></h4>
<p class="noindent">Let’s enhance our solution to the Mice Maze problem from <a href="ch06.xhtml">Chapter 6</a> to use a min-heap. Here’s the graph that we used there (<a href="ch06.xhtml#ch06fig01">Figure 6-1</a>):</p>
<div class="image1"><img alt="Image" src="../images/unapp02fig01.jpg"/></div>
<p class="indent">In <a href="ch06.xhtml">Chapter 6</a>, we traced Dijkstra’s algorithm starting from Node 1. Let’s do that again, this time using a min-heap. Each heap element will consist of a node and a time necessary to reach that node. We’ll see that there can be multiple occurrences of the same node on the heap. However, because it’s a min-heap, we’ll be able to process each node using only its minimum time.</p>
<p class="indent">In each min-heap snapshot that follows, I’ve arranged the rows in the same order as they’d be stored in the heap array.</p>
<p class="indent">We start with only Node 1 in the heap, with a time of 0. We have no time information for other nodes. We therefore have this snapshot:</p>
<p class="noindent1"><span epub:type="pagebreak" id="page_419"/>Min-heap</p>
<table>
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th style="vertical-align: top"><strong><em>node</em></strong></th>
<th style="vertical-align: top"><strong><em>time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table-h" style="vertical-align: top">1</td>
<td class="table-h" style="vertical-align: top">0</td>
</tr>
</tbody>
</table>
<p class="noindent1">Rest of State</p>
<table>
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">1</td>
<td class="grayzz" style="vertical-align: top">false</td>
<td class="grayzz" style="vertical-align: top">0</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top"/>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">false</td>
<td class="grayzz" style="vertical-align: top"/>
</tr>
<tr>
<td class="center" style="vertical-align: top">4</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top"/>
</tr>
<tr>
<td class="table-b-gray" style="vertical-align: top">5</td>
<td class="table-b-gray" style="vertical-align: top">false</td>
<td class="table-b-gray" style="vertical-align: top"/>
</tr>
</tbody>
</table>
<p class="indent">Extracting from the min-heap gives us its sole element, Node 1. We then process Node 1 to update the shortest paths to Nodes 2, 3, 4, and 5 and place these nodes on the min-heap. Here’s our state now:</p>
<p class="noindent1">Min-heap</p>
<table>
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">6</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">12</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">5</td>
<td class="grayzz" style="vertical-align: top">7</td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top">4</td>
<td class="table-b" style="vertical-align: top">45</td>
</tr>
</tbody>
</table>
<p class="noindent1">Rest of State</p>
<table>
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">1</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">0</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top">12</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">false</td>
<td class="grayzz" style="vertical-align: top">6</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">4</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top">45</td>
</tr>
<tr>
<td class="table-b-gray" style="vertical-align: top">5</td>
<td class="table-b-gray" style="vertical-align: top">false</td>
<td class="table-b-gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
<p class="indent">Node 3 is next out of the min-heap and gives us a shorter path to Node 2. We therefore add another occurrence of Node 2 to the heap, this one with a shorter path than before. Here’s what we’ve got now:</p>
<p class="noindent1">Min-heap</p>
<table>
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">5</td>
<td class="grayzz" style="vertical-align: top">7</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">8</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">4</td>
<td class="grayzz" style="vertical-align: top">45</td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top">2</td>
<td class="table-b" style="vertical-align: top">12</td>
</tr>
</tbody>
</table>
<p class="noindent1">Rest of State</p>
<table>
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">1</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">0</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top">8</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">6</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">4</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top">45</td>
</tr>
<tr>
<td class="table-b-gray" style="vertical-align: top">5</td>
<td class="table-b-gray" style="vertical-align: top">false</td>
<td class="table-b-gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
<p class="indent">Next out is Node 5. It doesn’t lead to any shortest-path updates, so nothing new gets added to the heap. Here’s where we are:</p>
<p class="noindent1">Min-heap</p>
<table>
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">2</td>
<td class="grayzz" style="vertical-align: top">8</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">12</td>
</tr>
<tr>
<td class="table-b-gray" style="vertical-align: top">4</td>
<td class="table-b-gray" style="vertical-align: top">45</td>
</tr>
</tbody>
</table>
<p class="noindent1">Rest of State</p>
<table>
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">1</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">0</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top">8</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">6</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">4</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top">45</td>
</tr>
<tr>
<td class="table-b-gray" style="vertical-align: top">5</td>
<td class="table-b-gray" style="vertical-align: top">true</td>
<td class="table-b-gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
<p class="indent"><span epub:type="pagebreak" id="page_420"/>Node 2 is next out of the min-heap—specifically the one with 8 time, not the one with 12 time! It leads to an update of Node 4’s shortest path, and consequently a new occurrence of Node 4 on the min-heap. Here’s the result:</p>
<p class="noindent1">Min-heap</p>
<table>
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">2</td>
<td class="grayzz" style="vertical-align: top">12</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">4</td>
<td class="center" style="vertical-align: top">45</td>
</tr>
<tr>
<td class="table-b-gray" style="vertical-align: top">4</td>
<td class="table-b-gray" style="vertical-align: top">17</td>
</tr>
</tbody>
</table>
<p class="noindent1">Rest of State</p>
<table>
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">1</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">0</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">true</td>
<td class="center" style="vertical-align: top">8</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">6</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">4</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top">17</td>
</tr>
<tr>
<td class="table-b-gray" style="vertical-align: top">5</td>
<td class="table-b-gray" style="vertical-align: top">true</td>
<td class="table-b-gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
<p class="indent">The next node to come out of the min-heap is Node 2. Again! Node 2 is already done, so we simply extract it from the heap and do nothing else. We certainly don’t process this node again. Here’s what’s left:</p>
<p class="noindent1">Min-heap</p>
<table>
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>cell</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">4</td>
<td class="grayzz" style="vertical-align: top">17</td>
</tr>
<tr>
<td class="table-b" style="vertical-align: top">4</td>
<td class="table-b" style="vertical-align: top">45</td>
</tr>
</tbody>
</table>
<p class="noindent1">Rest of State</p>
<table>
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<th class="table-b" style="vertical-align: top"><strong><em>node</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>done</em></strong></th>
<th class="table-b" style="vertical-align: top"><strong><em>min_time</em></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="grayzz" style="vertical-align: top">1</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">0</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">2</td>
<td class="center" style="vertical-align: top">true</td>
<td class="center" style="vertical-align: top">8</td>
</tr>
<tr>
<td class="grayzz" style="vertical-align: top">3</td>
<td class="grayzz" style="vertical-align: top">true</td>
<td class="grayzz" style="vertical-align: top">6</td>
</tr>
<tr>
<td class="center" style="vertical-align: top">4</td>
<td class="center" style="vertical-align: top">false</td>
<td class="center" style="vertical-align: top">17</td>
</tr>
<tr>
<td class="table-b-gray" style="vertical-align: top">5</td>
<td class="table-b-gray" style="vertical-align: top">true</td>
<td class="table-b-gray" style="vertical-align: top">7</td>
</tr>
</tbody>
</table>
<p class="indent">The two occurrences of Node 4 will be extracted from the min-heap in turn. The first Node 4 won’t lead to any shortest-path updates—all other nodes are done—but will set Node 4 to done. The second Node 4 will therefore be skipped.</p>
<p class="indent">In most textbook heap-based implementations of Dijkstra’s algorithm, it is assumed that there’s a way to decrease the shortest-path distance of a node in a heap. That way, a node can be updated in the heap, and there’s no need to have multiple occurrences of a node hanging around. The heaps that we developed in <a href="ch08.xhtml">Chapter 8</a>, though, don’t support such a “decrease” operation. Rest assured that what we’re doing here, with the insertions instead of updates, has the same worst-case time complexity. Which is what, exactly?</p>
<p class="indent">Let’s use <em>n</em> to represent the number of nodes in the graph and <em>m</em> the number of edges. We process each edge <em>u</em> <em>→</em> <em>v</em> at most once, when <em>u</em> is extracted from the heap. Each edge can lead to at most one insertion into the heap, so we insert at most <em>m</em> elements. The biggest the heap could ever get, then, is size <em>m</em>. We can only extract what’s been inserted, so there are at most <em>m</em> extractions. That’s 2<em>m</em> heap operations in all, each of which takes at most log <em>m</em> time. Therefore, we have an <em>O</em>(<em>m</em> log <em>m</em>) algorithm.</p>
<p class="indent">Compare this to the <em>O</em>(<em>n</em><sup>2</sup>) implementation from <a href="ch06.xhtml">Chapter 6</a>. The heap-based implementation is a clear win when the number of edges is small in <span epub:type="pagebreak" id="page_421"/>relation to <em>n</em><sup>2</sup>. For example, if there are <em>n</em> edges, then the heap-based implementation is <em>O</em>(<em>n</em> log <em>n</em>), which blows away the <em>O</em>(<em>n</em><sup>2</sup>) runtime in <a href="ch06.xhtml">Chapter 6</a>. If the number of edges is large, then it matters less which implementation we use. For example, if there are <em>n</em><sup>2</sup> edges, then the heap-based implementation is <em>O</em>(<em>n</em><sup>2</sup> log <em>n</em>), which is competitive with, but a little slower than, <em>O</em>(<em>n</em><sup>2</sup>). If you don’t know in advance whether your graph will have few or many edges, using a heap is a safe bet: the only cost is the extra log <em>n</em> factor on graphs with many edges, but that’s a small price to pay in exchange for much better performance on graphs with few edges.</p>
<h4 class="h4" id="sec180"><em>Mice Maze: Implementation with Heaps</em></h4>
<p class="noindent">Now let’s solve Mice Maze using heaps. We use this struct for the heap elements:</p>
<pre>typedef struct heap_element {
  int cell;
  int time;
} heap_element;</pre>
<p class="indent">I won’t replicate the min-heap insertion code (<a href="ch08.xhtml#ch08ex05">Listing 8-5</a>) or extraction code (<a href="ch08.xhtml#ch08ex06">Listing 8-6</a>) here. The only change is to compare <span class="literal">time</span> rather than <span class="literal">cost</span>; I’ll leave that to you.</p>
<p class="indent">The <span class="literal">main</span> function is the same as it was in <a href="ch06.xhtml">Chapter 6</a> (<a href="ch06.xhtml#ch06ex01">Listing 6-1</a>). All we need is a replacement of <span class="literal">find_time</span> (<a href="ch06.xhtml#ch06ex02">Listing 6-2</a>) to use a min-heap instead of linear searches. That code is given in <a href="app02.xhtml#app02ex04">Listing B-4</a>.</p>
<pre>int find_time(edge *adj_list[], int num_cells,
              int from_cell, int exit_cell) {
  static int done[MAX_CELLS + 1];
  static int min_times[MAX_CELLS + 1];
<span class="ent">➊</span> static heap_element min_heap[MAX_CELLS * MAX_CELLS + 1];
  int i;
  int min_time, min_time_index, old_time;
  edge *e;
  int num_min_heap = 0;
  for (i = 1; i &lt;= num_cells; i++) {
    done[i] = 0;
    min_times[i] = -1;
  }
  min_times[from_cell] = 0;
  min_heap_insert(min_heap, &amp;num_min_heap, from_cell, 0);

 <span class="ent">➋</span> while (num_min_heap &gt; 0) {
      min_time_index = min_heap_extract(min_heap, &amp;num_min_heap).cell;
      if (done[min_time_index])
      <span class="ent">➌</span> continue;
      min_time = min_times[min_time_index];
<span epub:type="pagebreak" id="page_422"/>   done[min_time_index] = 1;
 
   e = adj_list[min_time_index];
 <span class="ent">➍</span> while (e) {
      old_time = min_times[e-&gt;to_cell];
      if (old_time == -1 || old_time&gt; min_time + e-&gt;length) {
        min_times[e-&gt;to_cell] = min_time + e-&gt;length;
     <span class="ent">➎</span> min_heap_insert(min_heap, &amp;num_min_heap,
                e-&gt;to_cell, min_time + e-&gt;length);
      }
      e = e-&gt;next;
    }
  }
  return min_times[exit_cell];
}</pre>
<p class="excap" id="app02ex04"><em>Listing B-4: Shortest path to exit using Dijkstra’s algorithm and heaps</em></p>
<p class="indent">Each cell can result in at most <span class="literal">MAX_CELLS</span> elements added to the min-heap, and there are at most <span class="literal">MAX_CELLS</span>. We’re safe from overflowing the min-heap, then, if we allocate space for <span class="literal">MAX_CELLS * MAX_CELLS</span> elements plus one, since we index starting at <span class="literal">1</span> rather than <span class="literal">0</span> <span class="ent">➊</span>.</p>
<p class="indent">The main <span class="literal">while</span> loop continues as long as there’s something in the min-heap <span class="ent">➋</span>. If the node that we extract from the min-heap is already done, then we don’t do anything on its iteration <span class="ent">➌</span>. Otherwise, we process the outgoing edges as usual <span class="ent">➍</span>, adding nodes to the min-heap when shorter paths are found <span class="ent">➎</span>.</p>
<h3 class="h3" id="lev75">Compressing Path Compression</h3>
<p class="noindent">In <a href="ch09.xhtml">Chapter 9</a>, you learned about path compression, an optimization to the tree-based union-find data structure. We saw its code in the context of the Social Network problem in <a href="ch09.xhtml#ch09ex08">Listing 9-8</a>. Written like that, with the two <span class="literal">while</span> loops, is not how you’ll see the code in practice.</p>
<p class="indent">I generally don’t like to dwell on opaque code—and I hope I haven’t presented you with any such code in the book—but I’ll make an exception here, because you may at some point run into a particularly dense, one-line implementation of path compression. It’s presented in <a href="app02.xhtml#app02ex05">Listing B-5</a>.</p>
<pre>int find(int p, int parent[]) {
  return p == parent[p] ? p : (parent[p] = find(parent[p], parent));
}</pre>
<p class="excap" id="app02ex05"><em>Listing B-5: Path compression in practice</em></p>
<p class="indent">I changed <span class="literal">person</span> to <span class="literal">p</span> to get the code on one line (since readability is already shot, why not?).</p>
<p class="indent">There’s a lot going on here: the <span class="literal">? :</span> ternary if operator, using the result of the <span class="literal">=</span> assignment operator, and even recursion. We’re going to unravel this in three steps.</p>
<h4 class="h4" id="sec181"><span epub:type="pagebreak" id="page_423"/><em>Step 1: No More Ternary If</em></h4>
<p class="noindent">The <span class="literal">? :</span> operator is a form of if–else that returns a value. Programmers use it when they want to save space and jam an entire if statement on one line. A quick example looks like this:</p>
<pre>return x &gt;= 10 ? "big" : "small";</pre>
<p class="indent">If <span class="literal">x</span> is greater than or equal to 10, <span class="literal">"big"</span> is returned; otherwise, <span class="literal">"small"</span> is returned.</p>
<p class="indent">The <span class="literal">? :</span> operator is called a <em>ternary</em> operator because it takes three operands: the first expression is the boolean expression whose truth we are testing, the second expression is the result when the first expression is true, and the third is the result when the first expression is false.</p>
<p class="indent">Let’s rewrite <a href="app02.xhtml#app02ex05">Listing B-5</a> to use a standard <span class="literal">if...else</span> statement rather than the ternary <span class="literal">if</span>:</p>
<pre>int find(int p, int parent[]) {
  if (p == parent[p])
    return p;
  else
    return parent[p] = find(parent[p], parent);
}</pre>
<p class="indent">That’s a little better. Now we explicitly see that the code has two paths: one if <span class="literal">p</span> is already the root and the other if <span class="literal">p</span> is not the root.</p>
<h4 class="h4" id="sec182"><em>Step 2: Cleaner Assignment Operator</em></h4>
<p class="noindent">What do you think this code snippet does?</p>
<pre>int x;
printf("%d\n", x = 5);</pre>
<p class="indent">The answer is that it prints <span class="literal">5</span>! You know that <span class="literal">x = 5</span> assigns <span class="literal">5</span> to <span class="literal">x</span>, but it’s also an expression whose value is <span class="literal">5</span>. That’s right: <span class="literal">=</span> assigns a value, but it also returns the value that it stored in the variable. It’s also why we can do</p>
<pre>a = b = c = 5;</pre>
<p class="noindent">to assign the same value to multiple variables.</p>
<p class="indent">In the path-compression code, we have a return statement and an assignment statement on the same line. That line both assigns a value to <span class="literal">parent[p]</span> and returns that value. Let’s split those two actions out:</p>
<pre>int find(int p, int parent[]) {
  int community;
  if (p == parent[p])
    return p;
  else {
    community = find(parent[p], parent);
<span epub:type="pagebreak" id="page_424"/>    parent[p] = community;
    return community;
  }
}</pre>
<p class="indent">We’re explicitly finding the representative for <span class="literal">p</span>, assigning <span class="literal">parent[p]</span> to that representative, and then returning the representative.</p>
<h4 class="h4" id="sec183"><em>Step 3: Understand the Recursion</em></h4>
<p class="noindent">Now we have the recursion isolated on its own line:</p>
<pre>community = find(parent[p], parent);</pre>
<p class="indent">The <span class="literal">find</span> function performs path compression from its argument to the root of the tree, and it returns the root of the tree. Therefore, this recursive call performs path compression from <span class="literal">p</span>’s parent to the root of the tree, and it returns the root of the tree. That handles all of the path compression except for <span class="literal">p</span> itself. We need to set <span class="literal">p</span>’s parent to the root of the tree as well, which we do with this:</p>
<pre>parent[p] = community;</pre>
<p class="indent">There we have it: proof that the one-line path-compression code really does work!</p>
<h3 class="h3" id="lev76">Caps and Bottles: In-Place Sorting</h3>
<p class="noindent">In <a href="ch10.xhtml">Chapter 10</a>, we solved the Caps and Bottles problem using a famous “splitting” idea from Quicksort. If you look back at <a href="ch10.xhtml#ch010ex09">Listing 10-9</a>, you’ll notice that we’re allocating a lot of additional memory as our algorithm runs. Specifically, on each invocation of <span class="literal">solve</span>, we use <span class="literal">malloc</span> to allocate memory for four arrays: the small caps, the small bottles, the big caps, and the big bottles.</p>
<p class="indent">It’s possible to avoid this use of additional memory and perform the splitting directly in the <span class="literal">cap_nums</span> and <span class="literal">bottle_nums</span> arrays. This won’t decrease the number of queries that we need to make, but it does decrease the memory that our program uses. It’s also a common optimization that people perform when implementing Quicksort.</p>
<p class="indent">To make this work, we need to keep track of the border between small values and large values. We’ll maintain a variable called <span class="literal">border</span> to make this happen. Once we finish going through all of the caps and bottles, that <span class="literal">border</span> variable will tell us exactly where our problem is split in two; we need that in order to make our recursive calls. See <a href="app02.xhtml#app02ex06">Listing B-6</a> for our new solution that uses this idea.</p>
<pre>#define MAX_N 10000

void swap(int *x, int *y) {
  int temp = *x;
<span epub:type="pagebreak" id="page_425"/>    *x = *y;
    *y = temp;
  }

  int random_value(int left, int width) {
    return (rand() % width) + left;
  }

<span class="ent">➊</span> void solve(int cap_nums[], int bottle_nums[], int left, int right) {
    int border, cap_index, cap_num, i, result, matching_bottle;
    if (right &lt; left)
      return;

    border = left;
  <span class="ent">➋</span> cap_index = random_value(left, right - left + 1);
     cap_num = cap_nums[cap_index];

     i = left;
     while (i &lt; right) {
       printf("0 %d %d\n", cap_num, bottle_nums[i]);
       scanf("%d", &amp;result);
     <span class="ent">➌</span> if (result == 0) {
         swap(&amp;bottle_nums[i], &amp;bottle_nums[right]);
    <span class="ent">➍</span> } else if (result == 1) {
      <span class="ent">➎</span> swap(&amp;bottle_nums[border], &amp;bottle_nums[i]);
         border++;
         i++;
<span epub:type="pagebreak" id="page_426"/>       } else {
         i++;
       }
    }

    matching_bottle = bottle_nums[right];
 <span class="ent">➏</span> printf("1 %d %d\n", cap_num, matching_bottle);

    border = left;

    i = left;
    while (i &lt; right) {
      printf("0 %d %d\n", cap_nums[i], matching_bottle);
      scanf("%d", &amp;result);
      if (result == 0) {
        swap(&amp;cap_nums[i], &amp;cap_nums[right]);
      } else if (result == -1) {
        swap(&amp;cap_nums[border], &amp;cap_nums[i]);
        border++;
        i++;
      } else {
        i++;
      }
   }

<span class="ent">➐</span> solve(cap_nums, bottle_nums, left, border - 1);
<span class="ent">➑</span> solve(cap_nums, bottle_nums, border, right - 1);
}

int main(void) {
  int n, i;
  int cap_nums[MAX_N], bottle_nums[MAX_N];
  srand((unsigned) time(NULL));
  scanf("%d", &amp;n);
  for (i = 0; i &lt; n; i++) {
    cap_nums[i] = i + 1;
    bottle_nums[i] = i + 1;
  }
  solve(cap_nums, bottle_nums, 0, n - 1);
  return 0;
}</pre>
<p class="excap" id="app02ex06"><em>Listing B-6: Solution with no extra memory allocation</em></p>
<p class="indent">Rather than an <span class="literal">n</span> parameter giving the number of caps and bottles, now we need <span class="literal">left</span> and <span class="literal">right</span> parameters delimiting the operative part of the arrays <span class="ent">➊</span>.</p>
<p class="indent">Prior to the first <span class="literal">while</span> loop, we choose our random cap <span class="ent">➋</span>. The key invariant for the first <span class="literal">while</span> loop is that all bottles from <span class="literal">left</span> to <span class="literal">border - 1</span> are small bottles and all bottles from <span class="literal">border</span> to <span class="literal">i - 1</span> are big bottles. The loop will also eventually find the matching bottle; when it does, it puts that at the right <span class="ent">➌</span>. We’ll then be able to ignore that bottle in future recursive calls.</p>
<p class="indent">If we find that the cap is too big for the current bottle <span class="ent">➍</span>, it means that the current bottle is on the wrong side of <span class="literal">border</span>. After all, it’s a small bottle, and small bottles have to go to the left of <span class="literal">border</span>. To fix it, we swap that small bottle with the big bottle at <span class="literal">bottle_nums[border]</span> <span class="ent">➎</span>, and then we increment <span class="literal">border</span> to take into account that we now have one more small bottle to the left of <span class="literal">border</span>.</p>
<p class="indent">When that <span class="literal">while</span> loop is done, we’ll have rearranged the bottles so the small bottles are first and the big bottles follow. We’ll also have placed the matching bottle at the right, so we tell the judge about that match now <span class="ent">➏</span>.</p>
<p class="indent">The second <span class="literal">while</span> loop is nearly identical to the first, though this time it’s splitting the caps rather than the bottles.</p>
<p class="indent">The final thing we need to do is make our two recursive calls. The first one goes from <span class="literal">left</span> to <span class="literal">border - 1</span> <span class="ent">➐</span>—that’s all of the small caps and bottles. The second one goes from <span class="literal">border</span> to <span class="literal">right - 1</span> <span class="ent">➑</span>—that’s all of the big caps and bottles. Be careful: we need <span class="literal">right - 1</span> here, not <span class="literal">right</span>. The bottle and cap at index <span class="literal">right</span> have already been matched and should therefore never again be passed to a recursive call.</p>
</body></html>