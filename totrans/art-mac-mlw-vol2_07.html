<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="part" role="doc-part" aria-labelledby="pt2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label="139"/>&#13;
<hgroup>&#13;
&#13;
<h1 class="PART" id="pt2">&#13;
<span class="PN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">PART II</span></span>&#13;
<span class="PT"><span class="Sans_Dogma_B">SYSTEM MONITORING</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<p class="PCO">So far, I’ve covered programmatic methods of collecting data to generate snapshots of the system’s state, then analyzed these snapshots to uncover symptoms of malicious activity. This approach limits the analysis to single points in time, however. Simple antivirus programs often provide such a feature in a “scan now” option, which can be useful for determining whether the system has already been infected and for creating a baseline of a known good state. The obvious downside to this approach is that it’s reactive and, worse, could miss an infection altogether. For example, ransomware could infect a system and render it inoperable in the window of time between snapshots.</p>&#13;
<p class="TX">The solution is to expand upon the methods presented in <a href="part1.xhtml">Part I</a> to provide real-time monitoring capabilities. In <a href="part2.xhtml">Part II</a>, I’ll explain how to monitor the system log, as well as network, filesystem, and process events, in real time. In some cases, we’ll have to write code specific to the target of our monitoring; in other cases, Apple’s Endpoint Security framework can serve <span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label="140"/>as the basis for a wide range of monitors capable of overseeing filesystem, process, and many other noteworthy events. To fully understand Endpoint Security’s capabilities, I’ll spend an entire chapter highlighting its advanced features, including authorization and muting. The most comprehensive malware detection solutions will include the approaches presented in <a href="part1.xhtml">Part I</a> as well as the techniques I’ll cover in <a href="part2.xhtml">Part II</a>.</p>&#13;
<p class="TX">Also, the monitoring code can apply strategies covered in <a href="part1.xhtml">Part I</a> for identifying anomalies. For example, the logic we wrote in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> to detect that a running process’s binary is packed can identify suspicious binaries in real time, such as when a process monitor intercepts a newly spawned process.</p>&#13;
</section>&#13;
</div>
</div>
</body></html>