<html><head></head><body><section class="chapter" title="Chapter&#xA0;3.&#xA0;Numbering" epub:type="chapter" id="numbering"><div class="titlepage"><div><div><h2 class="title">Chapter 3. Numbering</h2></div></div></div><p><a id="idx00240" class="indexterm"/><a id="idx00351" class="indexterm"/><a id="idx00423" class="indexterm"/>In this chapter, we’ll look at various one-liners for numbering lines and words, and you’ll get to know the <code class="literal">$.</code> special variable. You’ll also learn about Perl golfing, a “sport” that involves writing the shortest Perl program to get a task done.</p><div class="sect1" title="3.1 Number all lines in a file"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_1_number_all_lines_in_a_file">3.1 Number all lines in a file</h2></div></div></div><a id="I_programlisting3_id302826"/><pre class="programlisting">perl -pe '$_ = "$. $_"'</pre><p>As I explained in one-liner 2.1 (page 7), <code class="literal">-p</code> tells Perl to assume a loop around the program (specified by <code class="literal">-e</code>) that reads each line of input into the <code class="literal">$_</code> variable, executes the program, and then prints the contents of the <code class="literal">$_</code> variable.</p><p><a id="idx00029" class="indexterm"/><a id="idx00053" class="indexterm"/><a id="idx00147" class="indexterm"/><a id="idx00316" class="indexterm"/><a id="idx00417" class="indexterm"/><a id="idx00507" class="indexterm"/><a id="idx00640" class="indexterm"/>This one-liner simply modifies <code class="literal">$_</code> by prepending the <code class="literal">$.</code> variable to it. The special variable <code class="literal">$.</code> contains the current line number of the input. The result is that each line has its line number prepended.</p><p>Similarly, you can also use the <code class="literal">-n</code> argument and print the string <code class="literal">"$. $_"</code>, which is the current line number followed by the line:</p><a id="I_programlisting3_id302926"/><pre class="programlisting">perl -ne 'print "$. $_"'</pre><p>Say a file contains three lines:</p><a id="I_programlisting3_id302935"/><pre class="programlisting">foo
bar
baz</pre><p>Running this one-liner numbers them:</p><a id="I_programlisting3_id302942"/><pre class="programlisting">1 foo
2 bar
3 baz</pre></div><div class="sect1" title="3.2 Number only non-empty lines in a file"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_2_number_only_non-empty_lines_in_a">3.2 Number only non-empty lines in a file</h2></div></div></div><a id="I_programlisting3_id302957"/><pre class="programlisting">perl -pe '$_ = ++$x." $_" if /./'</pre><p>Here you employ an “action if condition” statement that executes an action only if the condition is true. In this case, the condition is the regular expression <code class="literal">/./</code>, which matches all characters other than newline (that is, it matches a non-empty line). The action <code class="literal">$_ = ++$x." $_"</code> prepends the variable <code class="literal">$x</code> incremented by one to the current line. Because you’re not using the <code class="literal">strict</code> pragma, <code class="literal">$x</code> is created automatically the first time it’s incremented.</p><p>The result is that at each non-empty line <code class="literal">$x</code> is incremented by one and prepended to that line. Nothing is modified at the empty lines, and they are printed as is.</p><p>One-liner 2.2 (page 11) shows another way to match non-empty lines through the <code class="literal">\S</code> regular expression:</p><a id="I_programlisting3_id303002"/><pre class="programlisting">perl -pe '$_ = ++$x." $_" if /\S/'</pre><p>Say a file contains four lines, two of which are empty:</p><a id="I_programlisting3_id303010"/><pre class="programlisting">line1

line4</pre><p>Running this one-liner numbers only lines one and four:</p><a id="I_programlisting3_id303017"/><pre class="programlisting">1 line1

2 line4</pre></div><div class="sect1" title="3.3 Number and print only non-empty lines in a file (drop empty lines)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_3_number_and_print_only_non-empty">3.3 Number and print only non-empty lines in a file (drop empty lines)</h2></div></div></div><a id="I_programlisting3_id303029"/><pre class="programlisting">perl -ne 'print ++$x." $_" if /./'</pre><p>This one-liner uses the <code class="literal">-n</code> program argument, which places the line in the <code class="literal">$_</code> variable and then executes the program specified by <code class="literal">-e</code>. Unlike <code class="literal">-p</code>, <code class="literal">-n</code> does not print the line after executing the code in <code class="literal">-e</code>, so you have to call <code class="literal">print</code> explicitly to print the contents of the <code class="literal">$_</code> variable.</p><p>The one-liner calls <code class="literal">print</code> only on lines with at least one character, and as in the previous one-liner, it increments the line number in the variable <code class="literal">$x</code> by one for each non-empty line. The empty lines are ignored and never printed.</p><p>Say a file contains the same four lines as in one-liner 3.2:</p><a id="I_programlisting3_id303084"/><pre class="programlisting">line1

line4</pre><p>Running this one-liner drops the empty lines and numbers lines one and four:</p><a id="I_programlisting3_id303092"/><pre class="programlisting">1 line1
2 line4</pre></div><div class="sect1" title="3.4 Number all lines but print line numbers only for non-empty lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_4_number_all_lines_but_print_line">3.4 Number all lines but print line numbers only for non-empty lines</h2></div></div></div><a id="I_programlisting3_id303106"/><pre class="programlisting">perl -pe '$_ = "$. $_" if /./'</pre><p><a id="idx00054" class="indexterm"/><a id="idx00148" class="indexterm"/><a id="idx00317" class="indexterm"/>This one-liner is similar to one-liner 3.2. Here, you modify the <code class="literal">$_</code> variable that holds the entire line only if the line has at least one character. All other empty lines are printed as is, without line numbers.</p><p>Say a file contains four lines:</p><a id="I_programlisting3_id303142"/><pre class="programlisting">line1

line4</pre><p>Running this one-liner numbers all the lines but prints the line numbers only for lines one and four:</p><a id="I_programlisting3_id303150"/><pre class="programlisting">1 line1

4 line4</pre></div><div class="sect1" title="3.5 Number only lines that match a pattern; print others unmodified"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_5_number_only_lines_that_match_a_p">3.5 Number only lines that match a pattern; print others unmodified</h2></div></div></div><a id="I_programlisting3_id303165"/><pre class="programlisting">perl -pe '$_ = ++$x." $_" if /<span class="emphasis"><em>regex</em></span>/'</pre><p>Here, again, you use an “action if condition” statement, and again the condition is a pattern (a regular expression): <code class="literal">/regex/</code>. The action is the same as in one-liner 3.2.</p><p>Say a file contains these lines:</p><a id="I_programlisting3_id303185"/><pre class="programlisting">record foo
bar baz
record qux</pre><p>and you want to number the lines that contain the word <span class="emphasis"><em>record</em></span>. You can replace <code class="literal">/regex/</code> in the one-liner with <code class="literal">/record/</code>:</p><a id="I_programlisting3_id303203"/><pre class="programlisting">perl -pe '$_ = ++$x." $_" if /record/'</pre><p><a id="idx00530" class="indexterm"/>When you run this one-liner, it gives you the following output:</p><a id="I_programlisting3_id303222"/><pre class="programlisting">1 record foo
bar baz
2 record qux</pre></div><div class="sect1" title="3.6 Number and print only lines that match a pattern"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_6_number_and_print_only_lines_that">3.6 Number and print only lines that match a pattern</h2></div></div></div><a id="I_programlisting3_id303237"/><pre class="programlisting">perl -ne 'print ++$x." $_" if /<span class="emphasis"><em>regex</em></span>/'</pre><p>This one-liner is almost exactly like one-liner 3.3, except it only numbers and prints lines that match <code class="literal">/regex/</code>. It doesn’t print nonmatching lines.</p><p>For example, a file contains the same lines as in one-liner 3.5:</p><a id="I_programlisting3_id303256"/><pre class="programlisting">record foo
bar baz
record qux</pre><p>And let’s say you want to number and print only the lines that contain the word <span class="emphasis"><em>record</em></span>. In this case, changing <code class="literal">/regex/</code> to <code class="literal">/record/</code> and running the one-liner gives you this result:</p><a id="I_programlisting3_id303275"/><pre class="programlisting">1 record foo
2 record qux</pre></div><div class="sect1" title="3.7 Number all lines but print line numbers only for lines that match a pattern"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_7_number_all_lines_but_print_line">3.7 Number all lines but print line numbers only for lines that match a pattern</h2></div></div></div><a id="I_programlisting3_id303289"/><pre class="programlisting">perl -pe '$_ = "$. $_" if /<span class="emphasis"><em>regex</em></span>/'</pre><p>This one-liner is similar to one-liners 3.4 and 3.6. Here, the line number is prepended to the line if the line matches a <code class="literal">/regex/</code>; otherwise, it’s simply printed without a line number.</p><p>Replacing <code class="literal">/regex/</code> with <code class="literal">/record/</code> and running this one-liner on the same example file shown in one-liner 3.6 gives you this output:</p><a id="I_programlisting3_id303318"/><pre class="programlisting">1 record foo
bar baz
3 record qux</pre></div><div class="sect1" title="3.8 Number all lines in a file using a custom format"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_8_number_all_lines_in_a_file_using">3.8 Number all lines in a file using a custom format</h2></div></div></div><a id="I_programlisting3_id303334"/><pre class="programlisting">perl -ne 'printf "%-5d %s", $., $_'</pre><p><a id="idx00085" class="indexterm"/><a id="idx00097" class="indexterm"/><a id="idx00203" class="indexterm"/><a id="idx00239" class="indexterm"/><a id="idx00272" class="indexterm"/><a id="idx00349" class="indexterm"/><a id="idx00421" class="indexterm"/><a id="idx00497" class="indexterm"/><a id="idx00509" class="indexterm"/>This one-liner uses <code class="literal">printf</code> to print the line number together with the line contents. <code class="literal">printf</code> does formatted printing. You specify the format and send it the data to print, and it formats and prints the data accordingly. Here, the format for the line numbers is <code class="literal">%-5d</code>, which aligns the line numbers five positions to the left.</p><p>Here’s an example. Say the input to this one-liner is</p><a id="I_programlisting3_id303435"/><pre class="programlisting">hello world
bye world</pre><p>Then the output is</p><a id="I_programlisting3_id303442"/><pre class="programlisting">1     hello world
2     bye world</pre><p>Other format strings include <code class="literal">%5d</code>, which aligns the line numbers five positions to the right, and <code class="literal">%05d</code>, which zero-fills and right-justifies the line numbers. Here’s the output you get with the <code class="literal">%5d</code> format string for line numbers:</p><a id="I_programlisting3_id303462"/><pre class="programlisting">    1 hello world
    2 bye world</pre><p>And this is what you get with the <code class="literal">%05d</code> format string:</p><a id="I_programlisting3_id303473"/><pre class="programlisting">00001 hello world
00002 bye world</pre><p>To learn more about the various formats that are available, run <code class="literal">perldoc -f sprintf</code> at the command line.</p></div><div class="sect1" title="3.9 Print the total number of lines in a file (emulate wc -l)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_9_print_the_total_number_of_lines">3.9 Print the total number of lines in a file (emulate wc -l)</h2></div></div></div><a id="I_programlisting3_id303498"/><pre class="programlisting">perl -lne 'END { print $. }'</pre><p>This one-liner uses the <code class="literal">END</code> block that Perl took as a feature from the Awk language. The <code class="literal">END</code> block is executed once the Perl program has executed. Here, the Perl program is the hidden loop over the input created by the <code class="literal">-n</code> argument. Once it loops over the input, the special variable <code class="literal">$.</code> contains the number of lines in the input, and the <code class="literal">END</code> block prints this variable. The <code class="literal">-l</code> parameter sets the output record separator for <code class="literal">print</code> to a newline, so you don’t have to print the newline yourself, like this: <code class="literal">print "$.\n"</code>.</p><p><a id="idx00009" class="indexterm"/><a id="idx00019" class="indexterm"/><a id="idx00034" class="indexterm"/><a id="idx00153" class="indexterm"/><a id="idx00154" class="indexterm"/><a id="idx00179" class="indexterm"/><a id="idx00215" class="indexterm"/><a id="idx00438" class="indexterm"/><a id="idx00441" class="indexterm"/><a id="idx00464" class="indexterm"/><a id="idx00546" class="indexterm"/>You can do the same thing with this one-liner:</p><a id="I_programlisting3_id303619"/><pre class="programlisting">perl -le 'print $n = () = &lt;&gt;'</pre><p>This one-liner is easy to grasp if you understand Perl contexts well. The <code class="literal">() = &lt;&gt;</code> part tells Perl to evaluate the <code class="literal">&lt;&gt;</code> operator (the <span class="emphasis"><em>diamond operator</em></span>) in the list context, which makes the diamond operator read the whole file as a list of lines. Next, you assign this list to <code class="literal">$n</code>. Because <code class="literal">$n</code> is scalar, this list assignment is evaluated in the scalar context.</p><p>What’s really happening here is the <code class="literal">=</code> operator is right-associative, meaning the <code class="literal">=</code> on the right is done first and the <code class="literal">=</code> on the left is done second:</p><a id="I_programlisting3_id303662"/><pre class="programlisting">perl -le 'print $n = (() = &lt;&gt;)'</pre><p>Evaluating a list assignment in the scalar context returns the number of elements in the list; thus, the <code class="literal">$n = () = &lt;&gt;</code> construction is equal to the number of lines in the input, that is, the number of lines in the file. The <code class="literal">print</code> statement prints this number. The <code class="literal">-l</code> argument ensures a newline is added after printing this number.</p><p>You can also drop the variable <code class="literal">$n</code> from this one-liner and force the scalar context through the <code class="literal">scalar</code> operator:</p><a id="I_programlisting3_id303694"/><pre class="programlisting">perl -le 'print scalar(() = &lt;&gt;)'</pre><p>Here, instead of evaluating a list assignment in the scalar context by assigning it again to another scalar, you simply evaluate the list assignment in the scalar context using the <code class="literal">scalar</code> operator.</p><p>And now for a more obvious version:</p><a id="I_programlisting3_id303711"/><pre class="programlisting">perl -le 'print scalar(@foo = &lt;&gt;)'</pre><p>Here, instead of using an empty list <code class="literal">()</code> to force the list context on <code class="literal">&lt;&gt;</code>, you use the variable <code class="literal">@foo</code> to achieve the same effect.</p><p>And here’s another way to do it:</p><a id="I_programlisting3_id303734"/><pre class="programlisting">perl -ne '}{print $.'</pre><p>This one-liner uses the so-called <span class="emphasis"><em>eskimo operator</em></span> <code class="literal">}{</code> (actually a clever construct) in conjunction with the <code class="literal">-n</code> command-line argument. As I explained earlier, the <code class="literal">-n</code> argument forces Perl to assume a <code class="literal">while(&lt;&gt;) { }</code> loop around the program. The eskimo operator forces Perl to escape the loop, and the one-liner expands to</p><a id="I_programlisting3_id303762"/><pre class="programlisting">while (&lt;&gt;) {
}{               # eskimo operator here
    print $.;
}</pre><p><a id="idx00047" class="indexterm"/><a id="idx00157" class="indexterm"/><a id="idx00185" class="indexterm"/><a id="idx00213" class="indexterm"/><a id="idx00256" class="indexterm"/><a id="idx00296" class="indexterm"/><a id="idx00299" class="indexterm"/><a id="idx00348" class="indexterm"/><a id="idx00418" class="indexterm"/><a id="idx00485" class="indexterm"/>As you can see, this program just loops over all the input, and once it’s finished, it prints the <code class="literal">$.</code>, which is the number of lines in the input. It becomes even more obvious if you change the formatting a little:</p><a id="I_programlisting3_id303850"/><pre class="programlisting">while (&lt;&gt;) {}
{
    print $.;
}</pre><p>As you can see, this is just an empty loop that loops over all the input, followed by the <code class="literal">print</code> statement wrapped in curly brackets.</p></div><div class="sect1" title="3.10 Print the number of non-empty lines in a file"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_10_print_the_number_of_non-empty_l">3.10 Print the number of non-empty lines in a file</h2></div></div></div><a id="I_programlisting3_id303869"/><pre class="programlisting">perl -le 'print scalar(grep { /./ } &lt;&gt;)'</pre><p>This one-liner uses Perl’s <code class="literal">grep</code> function, which is similar to the <code class="literal">grep</code> UNIX command. Given a list of values, <code class="literal">grep { condition } list</code> returns only those values in the <code class="literal">list</code> that make the <code class="literal">condition</code> true. In this case, the condition is a regular expression that matches at least one character, so the input is filtered and <code class="literal">grep{ /./ }</code> returns all non-empty lines. To get the number of lines, you evaluate <code class="literal">grep</code> in the scalar context and print the result.</p><p>Some Perl programmers like to create the shortest Perl program that does some particular task—an exercise called <span class="emphasis"><em>Perl golfing</em></span>. A golfer’s version of this one-liner would replace <code class="literal">scalar()</code> with <code class="literal">~~</code> (double bitwise negate) and drop the spaces, shortening it like this:</p><a id="I_programlisting3_id303922"/><pre class="programlisting">perl -le 'print ~~grep{/./}&lt;&gt;'</pre><p>This double bitwise negate trick is effectively a synonym for <code class="literal">scalar</code> because the bitwise negation works on scalar values, so <code class="literal">grep</code> is evaluated in the scalar context.</p><p>You can make this even shorter by dropping the space after <code class="literal">print</code> and getting rid of the curly brackets:</p><a id="I_programlisting3_id303946"/><pre class="programlisting">perl -le 'print~~grep/./,&lt;&gt;'</pre><p><a id="idx00036" class="indexterm"/><a id="idx00048" class="indexterm"/><a id="idx00156" class="indexterm"/><a id="idx00158" class="indexterm"/><a id="idx00186" class="indexterm"/><a id="idx00199" class="indexterm"/><a id="idx00321" class="indexterm"/><a id="idx00360" class="indexterm"/><a id="idx00391" class="indexterm"/><a id="idx00456" class="indexterm"/><a id="idx00484" class="indexterm"/><a id="idx00504" class="indexterm"/><a id="idx00532" class="indexterm"/>If you have Perl 5.10 or later, you can also use the <code class="literal">-E</code> command-line switch and the <code class="literal">say</code> operator:</p><a id="I_programlisting3_id304063"/><pre class="programlisting">perl -lE 'say~~grep/./,&lt;&gt;'</pre><p>A true golfer’s masterpiece!</p></div><div class="sect1" title="3.11 Print the number of empty lines in a file"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_11_print_the_number_of_empty_lines">3.11 Print the number of empty lines in a file</h2></div></div></div><a id="I_programlisting3_id304081"/><pre class="programlisting">perl -lne '$x++ if /^$/; END { print $x+0 }'</pre><p>Here, you use the variable <code class="literal">$x</code> to count the number of empty lines encountered. Once you’ve looped over all the lines, you print the value of <code class="literal">$x</code> in the <code class="literal">END</code> block. You use the <code class="literal">$x+0</code> construction to ensure that <code class="literal">0</code> is output if no lines are empty. (Otherwise <code class="literal">$x</code> is never created and is undefined. Adding <code class="literal">+0</code> to the undefined value produces <code class="literal">0</code>.) An alternative to <code class="literal">$x+0</code> is the <code class="literal">int</code> operator:</p><a id="I_programlisting3_id304090"/><pre class="programlisting">perl -lne '$x++ if /^$/; END { print int $x }'</pre><p>You could also modify the previous one-liner by doing this:</p><a id="I_programlisting3_id304136"/><pre class="programlisting">perl -le 'print scalar(grep { /^$/ } &lt;&gt;)'</pre><p>Or write it with <code class="literal">~~</code>:</p><a id="I_programlisting3_id304147"/><pre class="programlisting">perl -le 'print ~~grep{ /^$/ } &lt;&gt;'</pre><p>The <code class="literal">~~</code> does bitwise negation twice, which makes <code class="literal">grep</code> execute in the scalar context and return the number of empty lines.</p><p>These last two versions are not as effective as the one-liner with the <code class="literal">END</code> block because they read the whole file into memory, whereas the one-liner with the <code class="literal">END</code> block does it line by line and, therefore, keeps only one line of input in memory.</p></div><div class="sect1" title="3.12 Print the number of lines in a file that match a pattern (emulate grep -c)"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_12_print_the_number_of_lines_in_a">3.12 Print the number of lines in a file that match a pattern (emulate grep -c)</h2></div></div></div><a id="I_programlisting3_id304183"/><pre class="programlisting">perl -lne '$x++ if /<span class="emphasis"><em>regex</em></span>/; END { print $x+0 }'</pre><p>This one-liner is basically the same as 3.11, except it increments the line counter <code class="literal">$x</code> by one when a line matches the regular expression <code class="literal">/regex/</code>. The <code class="literal">$x+0</code> trick makes sure <code class="literal">0</code> is printed when no lines match <code class="literal">/regex/</code>. (See one-liner 3.11 for a more detailed explanation of the <code class="literal">$x+0</code> trick.)</p></div><div class="sect1" title="3.13 Number words across all lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_13_number_words_across_all_lines">3.13 Number words across all lines</h2></div></div></div><a id="I_programlisting3_id304230"/><pre class="programlisting">perl -pe 's/(\w+)/++$i.".$1"/ge'</pre><p><a id="idx00020" class="indexterm"/><a id="idx00226" class="indexterm"/><a id="idx00353" class="indexterm"/><a id="idx00425" class="indexterm"/><a id="idx00631" class="indexterm"/><a id="idx00669" class="indexterm"/>This one-liner uses the <code class="literal">/e</code> flag, which makes Perl evaluate the <code class="literal">replace</code> part of the <code class="literal">s/regex/replace/</code> expression as code!</p><p>The code here is <code class="literal">++$i.".$1"</code>, which means “increment variable <code class="literal">$i</code> by one and then add it in front of the string <code class="literal">".$1"</code> (that is, a dot followed by the contents of the matched group <code class="literal">$1</code>).” The matched group here is each word: <code class="literal">(\w+)</code>.</p><p>In one sentence, this one-liner matches a word <code class="literal">(\w+)</code>, puts it in <code class="literal">$1</code>, and then executes the <code class="literal">++$i.".$1"</code> code that numbers the word globally (<code class="literal">/g</code> flag). There—all words are numbered.</p><p>For example, if you have a file with the following three lines:</p><a id="I_programlisting3_id304344"/><pre class="programlisting">just another
perl hacker
hacking perl code</pre><p>running this one-liner numbers each word in the file and produces the following output:</p><a id="I_programlisting3_id304353"/><pre class="programlisting">1.just 2.another
3.perl 4.hacker
5.hacking 6.perl 7.code</pre></div><div class="sect1" title="3.14 Number words on each individual line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_14_number_words_on_each_individual">3.14 Number words on each individual line</h2></div></div></div><a id="I_programlisting3_id304367"/><pre class="programlisting">perl -pe '$i=0; s/(\w+)/++$i.".$1"/ge'</pre><p>This is similar to one-liner 3.13, except that you reset the <code class="literal">$i</code> variable to <code class="literal">0</code> on each line. Here’s the result of running this one-liner on the example from one-liner 3.13:</p><a id="I_programlisting3_id304384"/><pre class="programlisting">1.just 2.another
1.perl 2.hacker
1.hacking 2.perl 3.code</pre><p>As you can see, in each line the words are numbered independently of other lines.</p></div><div class="sect1" title="3.15 Replace all words with their numeric positions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="three_15_replace_all_words_with_their_nu">3.15 Replace all words with their numeric positions</h2></div></div></div><a id="I_programlisting3_id304402"/><pre class="programlisting">perl -pe 's/(\w+)/++$i/ge'</pre><p><a id="idx00099" class="indexterm"/><a id="idx00430" class="indexterm"/><a id="idx00670" class="indexterm"/>This one-liner is almost the same as one-liner 3.13. Here, you simply replace each word with its numeric position, which is kept in the variable <code class="literal">$i</code>. For example, if you run this one-liner on the file from one-liners 3.13 and 3.14, it replaces the words in the file with their numeric positions to produce this output:</p><a id="I_programlisting3_id304442"/><pre class="programlisting">1 2
3 4
5 6 7</pre><p>Fun!</p></div></section></body></html>