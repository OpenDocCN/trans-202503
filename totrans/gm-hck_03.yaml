- en: '**2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DEBUGGING GAMES WITH OLLYDBG**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can scratch the surface of what happens as a game runs with Cheat Engine,
    but with a good debugger, you can dig deeper until you understand the game’s structure
    and execution flow. That makes OllyDbg essential to your game-hacking arsenal.
    It’s packed with a myriad of powerful tools like conditional breakpoints, referenced
    string search, assembly pattern search, and execution tracing, making it a robust
    assembler-level debugger for 32-bit Windows applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll cover low-level code structure in detail in [Chapter 4](ch04.xhtml#ch04),
    but for this chapter, I assume you’re at least familiar with modern code-level
    debuggers, such as the one packaged with Microsoft Visual Studio. OllyDbg is functionally
    similar to those, with one major difference: it interfaces with the assembly code
    of an application, working even in the absence of source code and/or debug symbols,
    making it ideal when you need to dig into the internals of a game. After all,
    game companies are rarely nice (or dumb) enough to ship their games with debug
    symbols!'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll go over OllyDbg’s user interface, show you how to use
    its most common debugging features, break down its expression engine, and provide
    some real-world examples of how you can tie it in to your game hacking endeavors.
    As a wrap-up, I’ll teach you about some useful plug-ins and send you off with
    a test game designed to get you started in OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter focuses on OllyDbg 1.10 and may not be entirely accurate for
    later versions. I use this version because, at the time of writing, the plug-in
    interface for OllyDbg 2 is still far less robust than the one for OllyDbg 1.*'
  prefs: []
  type: TYPE_NORMAL
- en: When you feel like you have a handle on OllyDbg’s interface and features, you
    can try it on a game yourself with “[Patching an `if()` Statement](ch02.xhtml#ch02sb01)”
    on [page 46](ch02.xhtml#page_46).
  prefs: []
  type: TYPE_NORMAL
- en: '**A Brief Look at OllyDbg’s User Interface**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go to the OllyDbg website (*[http://www.ollydbg.de/](http://www.ollydbg.de/)*),
    download and install OllyDbg, and open the program. You should see the toolbar
    shown in [Figure 2-1](ch02.xhtml#ch2fig1) above a multiple window interface area.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: OllyDbg main window*'
  prefs: []
  type: TYPE_NORMAL
- en: This toolbar contains the program controls ➊, the debug buttons ➋, the Go to
    button ➌, the control window buttons ➍, and the Settings button ➎.
  prefs: []
  type: TYPE_NORMAL
- en: The three program controls allow you to open an executable and attach to the
    process it creates, restart the current process, or terminate execution of the
    current process, respectively. You can also complete these functions with the
    hotkeys F3, CTRL-F2, and ALT-F2, respectively. To attach to a process that is
    already running, click **File** ▸ **Attach**.
  prefs: []
  type: TYPE_NORMAL
- en: The debug buttons control the debugger actions. [Table 2-1](ch02.xhtml#ch2tab1)
    describes what these buttons do, along with their hotkeys and functions. This
    table also lists three useful debugger actions that don’t have buttons on the
    debug toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Debug Buttons and Other Debugger Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Button** | **Hotkey** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Play | F9 | Resumes normal execution of the process. |'
  prefs: []
  type: TYPE_TB
- en: '| Pause | F12 | Pauses execution of all threads within the process and brings
    up the CPU window at the instruction currently being executed. |'
  prefs: []
  type: TYPE_TB
- en: '| Step into | F7 | Single-steps to the next operation to be executed (will
    dive down into function calls). |'
  prefs: []
  type: TYPE_TB
- en: '| Step over | F8 | Steps to the next operation to be executed within current
    scope (will skip over function calls). |'
  prefs: []
  type: TYPE_TB
- en: '| Trace into | CTRL-F11 | Runs a deep trace, tracing every operation that is
    executed. |'
  prefs: []
  type: TYPE_TB
- en: '| Trace over | CTRL-F12 | Runs a passive trace that traces only operations
    within the current scope. |'
  prefs: []
  type: TYPE_TB
- en: '| Execute until return | CTRL-F9 | Executes until a return operation is hit
    within the current scope. |'
  prefs: []
  type: TYPE_TB
- en: '|  | CTRL-F7 | Automatically single-steps on every operation, following execution
    in the disassembly window. This makes execution appear to be animated. |'
  prefs: []
  type: TYPE_TB
- en: '|  | CTRL-F8 | Also animates execution, but steps over functions instead of
    stepping into them. |'
  prefs: []
  type: TYPE_TB
- en: '|  | ESC | Stops animation, pausing execution on the current operation. |'
  prefs: []
  type: TYPE_TB
- en: The Go to button opens a dialog asking for a hexadecimal address. Once you enter
    the address, OllyDbg opens the CPU window and shows the disassembly at the specified
    address. When the CPU window is in focus, you can also show that information with
    the hotkey CTRL-G.
  prefs: []
  type: TYPE_NORMAL
- en: The control window buttons open different *control windows*, which display useful
    information about the process you’re debugging and expose more debugging functions,
    like the ability to set breakpoints. OllyDbg has a total of 13 control windows,
    which can all be open simultaneously within the multiple window interface. [Table
    2-2](ch02.xhtml#ch2tab2) describes these windows, listed in the order in which
    they appear on the window buttons toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** OllyDbg’s Control Windows'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Window** | **Hotkey** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Log | ALT-L | Displays a list of log messages, including debug prints, thread
    events, debugger events, module loads, and much more. |'
  prefs: []
  type: TYPE_TB
- en: '| Modules | ALT-E | Displays a list of all executable modules loaded into the
    process. Double-click a module to open it in the CPU window. |'
  prefs: []
  type: TYPE_TB
- en: '|  Memory map  | ALT-M | Displays a list of all blocks of memory allocated
    by the process. Double-click a block in the list to bring up a dump window of
    that memory block. |'
  prefs: []
  type: TYPE_TB
- en: '| Threads |  | Displays a list of threads running in the process. For each
    thread in this list, the process has a structure called a *Thread Information
    Block (TIB)*. OllyDbg allows you to view each thread’s TIB; simply right-click
    a thread and select Dump thread data block. |'
  prefs: []
  type: TYPE_TB
- en: '| Windows |  | Displays a list of window handles held by the process. Right-click
    a window in this list to jump to or set a breakpoint on its class procedure (the
    function that gets called when a message is sent to the window). |'
  prefs: []
  type: TYPE_TB
- en: '| Handles |  | Displays a list of handles held by the process. (Note that Process
    Explorer has a much better handle list than OllyDbg, as I will discuss in [Chapter
    3](ch03.xhtml#ch03).) |'
  prefs: []
  type: TYPE_TB
- en: '| CPU | ALT-C | Displays the main disassembler interface and controls a majority
    of the debugger functionality. |'
  prefs: []
  type: TYPE_TB
- en: '| Patches | CTRL-P | Displays a list of any assembly code modifications you
    have made to modules within the process. |'
  prefs: []
  type: TYPE_TB
- en: '| Call stack | ALT-K | Displays the call stack for the active thread. The window
    updates when the process halts. |'
  prefs: []
  type: TYPE_TB
- en: '| Breakpoints | ALT-B | Displays a list of active debugger breakpoints and
    allows you to toggle them on and off. |'
  prefs: []
  type: TYPE_TB
- en: '| References |  | Displays the reference list, which typically holds the search
    results for many different types of searches. It pops up on its own when you run
    a search. |'
  prefs: []
  type: TYPE_TB
- en: '| Run trace |  | Displays a list of operations logged by a debugger trace.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Source |  | Displays the source code of the disassembled module if a program
    debug database is present. |'
  prefs: []
  type: TYPE_TB
- en: Finally, the Settings button opens the OllyDbg settings window. Keep the default
    settings for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve had a tour of the main OllyDbg window, let’s explore the CPU,
    Patches, and Run trace windows more closely. You’ll use those windows extensively
    as a game hacker, and knowing your way around them is key.
  prefs: []
  type: TYPE_NORMAL
- en: '**OllyDbg’s CPU Window**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CPU window in [Figure 2-2](ch02.xhtml#ch2fig2) is where game hackers spend
    most of their time in OllyDbg because it is the main control window for the debugging
    features.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: OllyDbg CPU window*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This window houses four distinct control panes: the disassembler pane ➊, the
    registers pane ➋, the dump pane ➌, and the stack pane ➍. These four panes encapsulate
    OllyDbg’s main debugger functions, so it’s important to know them inside and out.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing and Navigating a Game’s Assembly Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll navigate game code and control most aspects of debugging from OllyDbg’s
    disassembler pane. This pane displays the assembly code for the current module,
    and its data is neatly displayed in a table composed of four distinct columns:
    Address, Hex dump, Disassembly, and Comment.'
  prefs: []
  type: TYPE_NORMAL
- en: The Address column displays the memory addresses of each operation in the game
    process you’re attached to. You can double-click an address in this column to
    toggle whether it’s the *display base*. When an address is set as the display
    base, the Address column displays all other addresses as offsets relative to it.
  prefs: []
  type: TYPE_NORMAL
- en: The Hex dump column displays the byte code for each operation, grouping operation
    codes and parameters accordingly. Black braces spanning multiple lines on the
    left side of this column mark known function boundaries. Operations that have
    jumps going to them are shown with a right-facing arrow on the inside of these
    braces. Operations that perform jumps are shown with either up-facing or down-facing
    arrows, depending on the direction in which they jump, on the inside of these
    braces. For example, in [Figure 2-2](ch02.xhtml#ch2fig2), the instruction at address
    0x779916B1 (highlighted in gray) has an up-facing arrow, indicating it’s an upward
    jump. You can think of a jump as a `goto` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The Disassembly column displays the assembly code of each operation the game
    performs. So, for example, you can confirm that the instruction at 0x779916B1
    in [Figure 2-2](ch02.xhtml#ch2fig2) is a jump by looking at the assembly, which
    shows a JNZ (jump if nonzero) instruction. Black braces in this column mark the
    boundaries of loops. Right-facing arrows attached to these braces point to the
    conditional statements that control whether the loops continue or exit. The three
    right-facing arrows in this column in [Figure 2-2](ch02.xhtml#ch2fig2) point to
    CMP (compare) and TEST instructions, which are used by assembly code to compare
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The Comment column displays human-readable comments about each operation the
    game performs. If OllyDbg encounters known API function names, it will automatically
    insert a comment with the name of the function. Similarly, if it successfully
    detects arguments being passed to a function, it will label them (for example,
    `Arg1`, `Arg2`, . . . , `ArgN`). You can double-click in this column to add a
    customized comment. Black braces in this column mark the assumed boundaries of
    function call parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*OllyDbg infers function boundaries, jump directions, loop structures, and
    function parameters during code analysis, so if these columns lack boundary lines
    or jump arrows, just press CTRL-A to run a code analysis on the binary.*'
  prefs: []
  type: TYPE_NORMAL
- en: When the disassembler pane is in focus, there are a few hotkeys you can use
    to quickly navigate code and control the debugger. Use F2 for Toggle breakpoint,
    SHIFT-F12 for Place conditional breakpoint, - (hyphen) for Go back and + (plus)
    for Go forward (these two work as you’d expect in a web browser), * (asterisk)
    for Go to EIP (which is the execution pointer in the x86 architecture), CTRL--
    (hyphen) for Go to previous function, and CTRL-+ for Go to next function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disassembler can also populate the References window with different types
    of search results. When you want to change the References window’s contents, right-click
    in the disassembler pane, mouse over the Search for menu to expand it, and select
    one of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**All intermodular calls** Searches for all calls to functions in remote modules.
    This can, for example, allow you to see everywhere that a game calls `Sleep()`,
    `PeekMessage()`, or any other Windows API function, enabling you to inspect or
    set breakpoints on the calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '**All commands** Searches for all occurrences of a given operation written
    in assembly, where the added operators `CONST` and `R32` will match a constant
    value or a register value, respectively. One use for this option might be searching
    for commands like `MOV [0xDEADBEEF], CONST`; `MOV [0xDEADBEEF], R32`; and `MOV
    [0xDEADBEEF], [R32+CONST]` to list all operations that modify memory at the address
    `0xDEADBEEF`, which could be anything, including the address of your player’s
    health.'
  prefs: []
  type: TYPE_NORMAL
- en: '**All sequences** Searches for all occurrences of a given sequence of operations.
    This is similar to the previous options, but it allows you to specify multiple
    commands.'
  prefs: []
  type: TYPE_NORMAL
- en: '**All constants** Searches for all instances of a given hexadecimal constant.
    For instance, if you enter the address of your character’s health, this will list
    all of the commands that directly access it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**All switches** Searches for all switch-case blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**All referenced text strings** Searches for all strings referenced in code.
    You can use this option to search through all referenced strings and see what
    code accesses them, which can be useful for correlating in-game text displays
    with the code that displays them. This option is also very useful for locating
    any debug assertion or logging strings, which can be a tremendous help in determining
    the purpose of code parts.'
  prefs: []
  type: TYPE_NORMAL
- en: The disassembler can also populate the Names window with all labels in the current
    module (CTRL-N) or all known labels in all modules (Search for ▸ Name in all modules).
    Known API functions will be automatically labeled with their names, and you can
    add a label to a command by highlighting it, pressing SHIFT-; and entering the
    label when prompted. When a labeled command is referenced in code, the label will
    be shown in place of the address. One way to use this feature is to name functions
    that you’ve analyzed (just set a label on the first command in a function) so
    you can see their names when other functions call them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing and Editing Register Contents***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The registers pane displays the contents of the eight processor registers, all
    eight flag bits, the six segment registers, the last Windows error code, and EIP.
    Underneath these values, this pane can display either *Floating-Point Unit (FPU)*
    registers or debug registers; click on the pane’s header to change which registers
    are displayed. The values in this pane are populated only if you freeze your process.
    Values that are displayed in red have been changed since the previous pause. Double-click
    on values in this pane to edit them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing and Searching a Game’s Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The dump pane displays a dump of the memory at a specific address. To jump to
    an address and display the memory contents, press CTRL-G and enter the address
    in the box that appears. You can also jump to the address of an entry in the other
    CPU window panes by right-clicking on the Address column and selecting Follow
    in dump.
  prefs: []
  type: TYPE_NORMAL
- en: While there are always three columns in the dump pane, the only one you should
    always see is the Address column, which behaves much like its cousin within the
    disassembler pane. The data display type you choose determines the other two columns
    shown. Right-click the dump pane to change the display type; for the one shown
    in [Figure 2-2](ch02.xhtml#ch2fig2), you’d right-click and select Hex ▸ Hex/ASCII
    (8 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: You can set a memory breakpoint on an address shown in the dump pane by right-clicking
    that address and expanding the Breakpoint submenu. Select **Memory** ▸ **On access**
    from this menu to break on any code that uses the address at all, or select **Memory**
    ▸ **On write** to break only on code that writes to that space in memory. To remove
    a memory breakpoint, select **Remove memory breakpoint** in the same menu; this
    option appears only when the address you right-click has a breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: With one or more values selected in the dump, you can press CTRL-R to search
    the current module’s code for references to addresses of the selected values;
    results of this search appear in the References window. You can also search for
    values in this pane using CTRL-B for binary strings and CTRL-N for labels. After
    you initiate a search, press CTRL-L to jump to the next match. CTRL-E allows you
    to edit any values you have selected.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The dump windows that you can open from the Memory window work in the same
    way as the dump pane.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing a Game’s Call Stack***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final CPU pane is the stack pane, and as the name suggests, it shows the
    call stack. Like the dump and disassembler panes, the stack pane has an Address
    column. The stack pane also has a Value column, which shows the stack as an array
    of 32-bit integers, and a Comment column, which shows return addresses, known
    function names, and other informative labels. The stack pane supports all the
    same hotkeys as the dump pane, with the exception of CTRL-N.
  prefs: []
  type: TYPE_NORMAL
- en: '**MULTICLIENT PATCHING**'
  prefs: []
  type: TYPE_NORMAL
- en: One type of hack, called a *multiclient patch*, overwrites the single-instance
    limitation code within a game’s binary with no-operation code, allowing the user
    to run multiple game clients, even when doing so is normally forbidden. Because
    the code that performs instance limitation must be executed very early after a
    game client is launched, it can be nearly impossible for a bot to inject its patch
    on time. The easiest workaround for this is to make multiclient patches persist
    by applying them within OllyDbg and saving them directly to the game binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Code Patches**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OllyDbg’s *code patches* let you make assembly code modifications for a game
    you want to hack, removing the need to engineer a tool tailored to that specific
    game. This makes prototyping *control flow hacks*—which manipulate game behavior
    through a mix of game design flaws, x86 assembly protocols, and common binary
    constructs—much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Game hackers typically include perfected patches as optional features in a bot’s
    tool suite, but in some cases, making those features persistent is actually more
    convenient for your end user. Luckily, OllyDbg patches provide the complete functionality
    you need to design, test, and permanently save code modifications to an executable
    binary using only OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: To place a patch, navigate to the line of assembly code you want to patch in
    the CPU window, double-click the instruction you wish to modify, place a new assembly
    instruction in the pop-up prompt, and click **Assemble**, as shown in [Figure
    2-3](ch02.xhtml#ch2fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: Placing a patch with OllyDbg*'
  prefs: []
  type: TYPE_NORMAL
- en: Always pay attention to the size of your patch—you can’t just resize and move
    around assembled code however you’d like. Patches *larger* than the code you intend
    to replace will overflow into subsequent operations, potentially removing critical
    functionality. Patches *smaller* than the operations you intend to replace are
    safe, as long as Fill with NOPs is checked. This option fills any abandoned bytes
    with *no-operation (NOP)* commands, which are single-byte operations that do nothing
    when executed.
  prefs: []
  type: TYPE_NORMAL
- en: All patches you place are listed, along with the address, size, state, old code,
    new code, and comment, in the Patches window. Select a patch in this list to access
    a small but powerful set of hotkeys, shown in [Table 2-3](ch02.xhtml#ch2tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-3:** Patches Window Hotkeys'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ENTER | Jumps to the patch in the disassembler. |'
  prefs: []
  type: TYPE_TB
- en: '| spacebar | Toggles the patch on or off. |'
  prefs: []
  type: TYPE_TB
- en: '| F2 | Places a breakpoint on the patch. |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-F2 | Places a conditional breakpoint on the patch. |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-F4 | Places a conditional log breakpoint on the patch. |'
  prefs: []
  type: TYPE_TB
- en: '| DEL | Removes the patch entry from the list only. |'
  prefs: []
  type: TYPE_TB
- en: In OllyDbg, you can also save your patches directly to the binary. First, right-click
    in the disassembler and click **Copy to executable** ▸ **All modifications**.
    If you want to copy only certain patches, highlight them in the disassembly pane
    and press **Copy to executable** ▸ **Selection** instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**DETERMINING PATCH SIZE**'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few ways to determine whether your patch will be a different size
    than the original code. For example, in [Figure 2-3](ch02.xhtml#ch2fig3), you
    can see the command at `0x7790ED2E` being changed from `SHR AL, 6` to `SHR AL,
    7`. If you look at the bytes to the left of the command, you see 3 bytes that
    represent the memory of the command. This means our new command must either be
    3 bytes or padded with NOPs if it’s less than 3 bytes. Furthermore, these bytes
    are arranged in two columns. The first column contains `0xC0` and `0x08`, which
    represent the command `SHR` and the first operand, `AL`. The second column contains
    `0x06`, which represents the original operand. Because the second column shows
    a single byte, any replacement operand must also be 1 byte (between `0x00` and
    `0xFF`). If this column had shown `0x00000006` instead, a replacement operand
    could be up to 4 bytes in length.
  prefs: []
  type: TYPE_NORMAL
- en: Typical code patches will either use all NOPs to completely remove a command
    (by leaving the box empty and letting it fill the entire command with NOPs) or
    just replace a single operand, so this method of checking patch size is almost
    always effective.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracing Through Assembly Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you run a trace on any program, OllyDbg single-steps over every executed
    operation and stores data about each one. When the trace is complete, the logged
    data is displayed in the Run trace window, shown in [Figure 2-4](ch02.xhtml#ch2fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: The Run trace window*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Run trace window is organized into the following six columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Back** The number of operations logged between an operation and the current
    execution state'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thread** The thread that executed the operation'
  prefs: []
  type: TYPE_NORMAL
- en: '**Module** The module where the operation resides'
  prefs: []
  type: TYPE_NORMAL
- en: '**Address** The address of the operation'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command** The operation that was executed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified registers** The registers changed by the operation and their new
    values'
  prefs: []
  type: TYPE_NORMAL
- en: When hacking games, I find OllyDbg’s trace feature very effective at helping
    me find pointer paths to dynamic memory when Cheat Engine scans prove inconclusive.
    This works because you can follow the log in the Run trace window backward from
    the point when the memory is used to the point where it is resolved from a static
    address.
  prefs: []
  type: TYPE_NORMAL
- en: This potent feature’s usefulness is limited only by the creativity of the hacker
    using it. Though I typically use it only to find pointer paths, I’ve come across
    a few other situations where it has proven invaluable. The anecdotes in “[OllyDbg
    Expressions in Action](ch02.xhtml#ch00lev1sec44)” on [page 36](ch02.xhtml#page_36)
    will help to illuminate the functionality and power of tracing.
  prefs: []
  type: TYPE_NORMAL
- en: '**OllyDbg’s Expression Engine**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OllyDbg is home to a custom expression engine that can compile and evaluate
    advanced expressions with a simple syntax. The expression engine is surprisingly
    powerful and, when utilized properly, can be the difference between an average
    OllyDbg user and an OllyDbg wizard. You can use this engine to specify expressions
    for many features, such as conditional breakpoints, conditional traces, and the
    command line plug-in. This section introduces the expression engine and the options
    it provides.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Parts of this section are based on the official expressions documentation*
    ([http://www.ollydbg.de/Help/i_Expressions.htm](http://www.ollydbg.de/Help/i_Expressions.htm)*).
    I have found, however, that a few of the components defined in the documentation
    don’t seem to work, at least not in OllyDbg v1.10\. Two examples are the* `INT`
    *and* `ASCII` *data types, which must be substituted with the aliases* `LONG`
    *and* `STRING`*. For this reason, here I include only components that I’ve personally
    tested and fully understand.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Expressions in Breakpoints***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a *conditional breakpoint* is toggled on, OllyDbg prompts you to enter
    an expression for the condition; this is where most expressions are used. When
    that breakpoint is executed, OllyDbg silently pauses execution and evaluates the
    expression. If the result of the evaluation is nonzero, execution remains paused
    and you will see the breakpoint get triggered. But if the result of the evaluation
    is `0`, OllyDbg silently resumes execution as if nothing happened.
  prefs: []
  type: TYPE_NORMAL
- en: With the huge number of executions that happen within a game every second, you’ll
    often find that a piece of code is executed in far too many contexts for a breakpoint
    to be an effective way of getting the data you are looking for. A conditional
    breakpoint paired with a good understanding of the code surrounding it is a foolproof
    way to avoid these situations.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Operators in the Expression Engine***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For numeric data types, OllyDbg expressions support general C-style operators,
    as seen in [Table 2-4](ch02.xhtml#ch2tab4). While there is no clear documentation
    on the operator precedence, OllyDbg seems to follow C-style precedence and can
    use parenthesized scoping.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-4:** OllyDbg Numeric Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a == b` | Returns `1` if `a` is equal to `b`, else returns `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a != b` | Returns `1` if `a` is not equal to `b`, else returns `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a > b` | Returns `1` if `a` is greater than `b`, else returns `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a < b` | Returns `1` if `a` is less than `b`, else returns `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a >= b` | Returns `1` if `a` is greater than or equal to `b`, else returns
    `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a <= b` | Returns `1` if `a` is less than or equal to `b`, else returns
    `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a && b` | Returns `1` if `a` and `b` are both nonzero, else returns `0`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124; b` | Returns `1` if either `a` or `b` are nonzero, else returns
    `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a ^ b` | Returns the result of `XOR(a, b)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a % b` | Returns the result of `MODULUS(a, b)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | Return the result of `AND(a, b)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | Return the result of `OR(a, b)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a << b` | Returns the result of `a` shifted `b` bits to the left. |'
  prefs: []
  type: TYPE_TB
- en: '| `a >> b` | Returns the result of `a` shifted `b` bits to the right. |'
  prefs: []
  type: TYPE_TB
- en: '|  `a + b`  | Returns the sum of `a` plus `b`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a - b` | Returns the difference of `a` minus `b`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a / b` | Returns the quotient of `a` divided by `b`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | Returns the product of `a` times `b`. |'
  prefs: []
  type: TYPE_TB
- en: '| `+a` | Returns the signed representation of `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Returns `a*-1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `!a` | Returns `1` if `a` is `0`, else returns `0`. |'
  prefs: []
  type: TYPE_TB
- en: 'For strings, on the other hand, the only available operators are `==` and `!=`,
    which both adhere to the following set of rules:'
  prefs: []
  type: TYPE_NORMAL
- en: • String comparisons are case insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: • If only one of the operands is a string literal, the comparison will terminate
    after it reaches the length of the literal. As a result, the expression `[STRING
    EAX]=="ABC123"`, where `EAX` is a pointer to the string `ABC123XYZ`, will evaluate
    to `1` instead of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: • If no type is specified for an operand in a string comparison and the other
    operand is a string literal (for example, `"MyString"!=EAX`), the comparison will
    first assume the nonliteral operand is an ASCII string, and, if that compare would
    return `0`, it will try a second compare assuming the operand is a Unicode string.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, operators aren’t much use without operands. Let’s look at some of
    the data you can evaluate in expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Basic Expression Elements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Expressions are able to evaluate many different elements, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU registers** `EAX`, `EBX`, `ECX`, `EDX`, `ESP`, `EBP`, `ESI`, and `EDI`.
    You can also use the 1-byte and 2-byte registers (for example, `AL` for the low
    byte and `AX` for the low word of `EAX`). `EIP` can also be used.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Segment registers** `CS`, `DS`, `ES`, `SS`, `FS`, and `GS`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FPU registers** `ST0`, `ST1`, `ST2`, `ST3`, `ST4`, `ST5`, `ST6`, and `ST7`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple labels** Can be API function names, such as `GetModuleHandle`, or
    user-defined labels.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows constants** Such as `ERROR_SUCCESS`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integers** Are written in hexadecimal format or decimal format if followed
    by a trailing decimal point (for example, `FFFF` or `65535`.).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating-point numbers** Allow exponents in decimal format (for example,
    `654.123e-5`).'
  prefs: []
  type: TYPE_NORMAL
- en: '**String literals** Are wrapped in quotation marks (for example, `"my string"`).'
  prefs: []
  type: TYPE_NORMAL
- en: The expressions engine looks for these elements in the order they’re listed
    here. For example, if you have a label that matches the name of a Windows constant,
    the engine uses the address of the label instead of the constant’s value. But
    if you have a label named after a register, such as EAX, the engine uses the register
    value, not the label value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing Memory Contents with Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OllyDbg expressions are also powerful enough to incorporate memory reading,
    which you can do by wrapping a memory address, or an expression that evaluates
    to one, in square brackets. For example, `[EAX+C]` and `[401000]` represent the
    contents at the addresses EAX+C and 401000\. To read the memory as a type other
    than `DWORD`, you can specify the desired type either before the brackets, as
    in `BYTE [EAX]`, or as the first token within them, as in `[STRING ESP+C]`. Supported
    types are listed in [Table 2-5](ch02.xhtml#ch2tab5).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-5:** OllyDbg Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Interpretation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BYTE` | 8-bit integer (unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| `CHAR` | 8-bit integer (signed) |'
  prefs: []
  type: TYPE_TB
- en: '| `WORD` | 16-bit integer (unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| `SHORT` | 16-bit integer (signed) |'
  prefs: []
  type: TYPE_TB
- en: '| `DWORD` | 32-bit integer (unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| `LONG` | 32-bit integer (signed) |'
  prefs: []
  type: TYPE_TB
- en: '| `FLOAT` | 32-bit floating-point number |'
  prefs: []
  type: TYPE_TB
- en: '| `DOUBLE` | 64-bit floating-point number |'
  prefs: []
  type: TYPE_TB
- en: '| `STRING` | Pointer to an ASCII string (null-terminated) |'
  prefs: []
  type: TYPE_TB
- en: '| `UNICODE` | Pointer to a Unicode string (null-terminated) |'
  prefs: []
  type: TYPE_TB
- en: Plugging memory contents directly into your OllyDbg expressions is incredibly
    useful in game hacking, in part because you can tell the debugger to check a character’s
    health, name, gold, and so on in memory before breaking. You’ll see an example
    of this in “[Pausing Execution When a Specific Player’s Name Is Printed](ch02.xhtml#ch00lev1sec45)”
    on [page 37](ch02.xhtml#page_37).
  prefs: []
  type: TYPE_NORMAL
- en: '**OllyDbg Expressions in Action**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Expressions in OllyDbg use a syntax similar to that of most programming languages;
    you can even combine multiple expressions and nest one expression within another.
    Game hackers (really, all hackers) commonly use them to create conditional breakpoints,
    as I described in “[Using Expressions in Breakpoints](ch02.xhtml#ch00lev1sec40)”
    on [page 34](ch02.xhtml#page_34), but you can use them in many different places
    in OllyDbg. For instance, OllyDbg’s command line plug-in can evaluate expressions
    in place and display their results, allowing you to easily read arbitrary memory,
    inspect values that are being calculated by assembly code, or quickly get the
    results of mathematical equations. Furthermore, hackers can even create intelligent,
    position-agnostic breakpoints by coupling expressions with the trace feature.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll share some anecdotes where the expression engine has come
    in handy during my work. I will explain my thought process, walk through my entire
    debugging session, and break each expression down into its component parts so
    you can see some ways to use OllyDbg expressions in game hacking.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*These examples contain some assembly code, but if you don’t have much experience
    with assembly, don’t worry. Just ignore the fine details and know that values
    like* `ECX`, `EAX`*, and* `ESP` *are process registers like the ones discussed
    in “[Viewing and Editing Register Contents](ch02.xhtml#ch00lev1sec34)” on [page
    29](ch02.xhtml#page_29). From there, I’ll explain everything else.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you get confused about an operator, element, or data type in an expression
    as I walk through these anecdotes, just refer to “[OllyDbg’s Expression Engine](ch02.xhtml#ch00lev1sec39)”
    on [page 33](ch02.xhtml#page_33).
  prefs: []
  type: TYPE_NORMAL
- en: '***Pausing Execution When a Specific Player’s Name Is Printed***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During one particular debugging session, I needed to figure out exactly what
    was happening when a game was drawing the names of players on screen. Specifically,
    I needed to invoke a breakpoint before the game drew the name “Player 1,” ignoring
    all other names that were drawn.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figuring Out Where to Pause**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As a starting point, I used Cheat Engine to find the address of Player 1’s name
    in memory. Once I had the address, I used OllyDbg to set a memory breakpoint on
    the first byte of the string. Every time this breakpoint got hit, I quickly inspected
    the assembly code to determine how it was using Player 1’s name. Eventually, I
    found the name being accessed directly above a call to a function that I had previously
    given the name `printText()`. I had found the code that was drawing the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'I removed my memory breakpoint and replaced it with a code breakpoint on the
    call to `printText()`. There was a problem, however: because the call to `printText()`
    was inside a loop that iterated over every player in the game, my new breakpoint
    was getting hit every time a name was drawn—and that was much too often. I needed
    to fix it to hit only on a specific player.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the assembly code at my previous memory breakpoint told me that
    each player’s name was accessed using the following assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EAX` register contained the address of an array of player data; I’ll call
    it `playerStruct`. The size of `playerStruct` was 0x90 bytes, the `ECX` register
    contained the iteration index (the famous variable `i`), and each player’s name
    was stored 0x50 bytes after the start of its respective `playerStruct`. This meant
    that this `PUSH` instruction essentially put `EAX[ECX].name` (the name of the
    player at index `i`) on the stack to be passed as an argument to the `printText()`
    function call. The loop, then, broke down to something like the following psuedocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Purely through analysis, I determined that the `playerStruct()` function contained
    data for all players, and the loop iterated over the total number of players (counting
    up with `ECX` ➊), fetched the character name ➋ for each index, and printed the
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '**Crafting the Conditional Breakpoint**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Knowing that, to pause execution only when printing “Player 1” all I had to
    do was check the current player name before executing my breakpoint. In pseudocode,
    the new breakpoint would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once I figured out the form of my new breakpoint, I needed to access `EAX[ECX].name`
    from within the loop. That’s where OllyDbg’s expression engine came in: I could
    achieve my goal by making slight modifications to the expression that the assembly
    code used, leaving me with this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I removed the code breakpoint on `printText()` and replaced it with a conditional
    breakpoint that used this expression, which told OllyDbg to break only if the
    string value stored at `EAX + ECX*0x90 + 0x50` matched Player 1’s name. This breakpoint
    hit only when `"Player 1"` was being drawn, allowing me to continue my analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of work it took to engineer this breakpoint might seem extensive,
    but with practice, the entire process becomes as intuitive as writing code. Experienced
    hackers can do this in a matter of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this breakpoint enabled me to inspect certain values in the `playerStruct()`
    function for `"Player 1"` as soon as he appeared on screen. Doing it this way
    was important, as the states of these values were relevant to my analysis only
    in the first few frames after the player entered the screen. Creatively using
    breakpoints like this can enable you to analyze all sorts of complex game behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '***Pausing Execution When Your Character’s Health Drops***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During another debugging session, I needed to find the first function called
    after my character’s health dropped below the maximum. I knew two ways to approach
    this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: • Find every piece of code that accesses the health value and place a conditional
    breakpoint that checks the health on each one. Then, once one of these breakpoints
    is hit, single-step through the code until the next function call.
  prefs: []
  type: TYPE_NORMAL
- en: • Use OllyDbg’s trace function to create a dynamic breakpoint that can stop
    exactly where I need.
  prefs: []
  type: TYPE_NORMAL
- en: The first method required more setup and was not easily repeatable, mostly due
    to the sheer number of breakpoints needed and the fact that I’d have to single-step
    by hand. In contrast, the latter method had a quick setup, and since it did everything
    automatically, it was easily repeatable. Though using the trace function would
    slow the game down considerably (every single operation was captured by the trace),
    I chose the latter method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing an Expression to Check Health**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once again, I started by using Cheat Engine to find the address that stored
    my health. Using the method described in “[Cheat Engine’s Memory Scanner](ch01.xhtml#ch00lev1sec9)”
    on [page 5](ch01.xhtml#page_5), I determined the address to be 0x40A000.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I needed an expression that told OllyDbg to return `1` when my health
    was below maximum and return `0` otherwise. Knowing that my health was stored
    at 0x40A000 and that the maximum value was `500`, I initially devised this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression would invoke a break when my health was below 500 (remember,
    decimal numbers must be suffixed with a period in the expression engine), but
    instead of waiting for a function to be called, the break would happen immediately.
    To ensure that it waited until a function was called, I appended another expression
    with the `&&` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: On x86 processors, the EIP register stores the address of the operation being
    executed, so I decided to check the first byte at `EIP` ➊ to see if it was equal
    to `0xE8`. This value tells the processor to execute a *near function call*, which
    is the type of call I was looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting my trace, I had to do one last thing. Because the trace feature
    repeatedly single-steps (Trace into uses step into and Trace over uses step over,
    as described in “[A Brief Look at OllyDbg’s User Interface](ch02.xhtml#ch00lev1sec31)”
    on [page 24](ch02.xhtml#page_24)), I needed to start the trace at a location scoped
    at or above the level of any code that could possibly update the health value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figuring Out Where to Start the Trace**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To find a good location, I opened the game’s main module in OllyDbg’s CPU window,
    right-clicked in the disassembler pane, and selected Search for ▸ All intermodular
    calls. The References window popped up and displayed a list of external API functions
    that were called by the game. Nearly all gaming software polls for new messages
    using the Windows `USER32.PeekMessage()` function, so I sorted the list using
    the Destination column and typed `PEEK` (you can search the list by simply typing
    a name with the window in focus) to locate the first call to `USER32.PeekMessage()`.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the Destination sorting, every call to this function was listed in
    a contiguous chunk following the first, as shown in [Figure 2-5](ch02.xhtml#ch2fig5).
    I set a breakpoint on each by selecting it and pressing F2.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: OllyDbg’s Found intermodular calls window*'
  prefs: []
  type: TYPE_NORMAL
- en: Though there were around a dozen calls to `USER32.PeekMessage()`, only two of
    them were setting off my breakpoints. Even better, the active calls were beside
    one another in an unconditional loop. At the bottom of this loop were a number
    of internal function calls. This looked exactly like a main game loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Activating the Trace**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To finally set my trace, I removed all of my previous breakpoints and placed
    one at the top of the suspected main loop. I removed the breakpoint as soon as
    it was hit. I then pressed CTRL-T from the CPU window, which brought up a dialog
    called Condition to pause run trace, shown in [Figure 2-6](ch02.xhtml#ch2fig6).
    Within this new dialog, I enabled the Condition is TRUE option, placed my expression
    in the box beside it, and pressed OK. Then, I went back to the CPU window and
    pressed CTRL-F11 to begin a Trace Into session.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: Condition to pause run trace dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the trace began, the game ran so slowly it was nearly unplayable. To decrease
    my test character’s health, I opened a second instance of the game, logged into
    a different character, and attacked my test character. When the execution of the
    trace caught up to real time, OllyDbg saw my health change and triggered the breakpoint
    on the following function call—just as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this game, the main pieces of code that would modify the health value were
    directly invoked from the network code. Using this trace, I was able to find the
    function that the network module called directly after a network packet told the
    game to change the player’s health. Here’s the psuedocode of what the game was
    doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I knew the game had code that needed to execute only when the player’s health
    was changed, and I needed to add code that could also respond to such changes.
    Without knowing the overall code structure, I guessed that the health-dependent
    code would be executed from some function call directly after `health` was updated.
    My trace conditional breakpoint confirmed this hunch, as it broke directly on
    the `observe()` function ➊. From there, I was able to place a *hook* on the function
    (*hooking*, a way to intercept function calls, is described in “[Hooking to Redirect
    Game Execution](ch08.xhtml#ch00lev1sec151)” on [page 153](ch08.xhtml#page_153))
    and execute my own code when the player’s health changed.
  prefs: []
  type: TYPE_NORMAL
- en: '**OllyDbg Plug-ins for Game Hackers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OllyDbg’s highly versatile plug-in system is perhaps one of its most powerful
    features. Experienced game hackers often configure their OllyDbg environments
    with dozens of useful plug-ins, both publicly available and custom-made.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download popular plug-ins from the OpenRCE (*[http://www.openrce.org/downloads/browse/OllyDbg_Plugins](http://www.openrce.org/downloads/browse/OllyDbg_Plugins)*)
    and tuts4you (*[http://www.tuts4you.com/download.php?list.9/](http://www.tuts4you.com/download.php?list.9/)*)
    plug-in repositories. Installing them is easy: just unzip the plug-in files and
    place them inside OllyDbg’s installation folder.'
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, some plug-ins can be accessed from the OllyDbg’s Plugin menu
    item. Other plug-ins, however, might be found only in specific places throughout
    the OllyDbg interface.
  prefs: []
  type: TYPE_NORMAL
- en: You can find hundreds of potent plug-ins using these online repositories, but
    you should be careful when constructing your arsenal. Working in an environment
    bloated by unused plug-ins can actually impede productivity. In this section,
    I’ve carefully selected four plug-ins that I believe are not only integral to
    a game hacker’s toolkit but also noninvasive to the environment.
  prefs: []
  type: TYPE_NORMAL
- en: '***Copying Assembly Code with Asm2Clipboard***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Asm2Clipboard is a minimalistic plug-in from the OpenRCE repository that allows
    you to copy chunks of assembly code from the disassembler pane to the clipboard.
    This can be useful for updating address offsets and devising code caves, two game-hacking
    essentials I cover deeply in [Chapters 5](ch05.xhtml#ch05) and [7](ch07.xhtml#ch07).
  prefs: []
  type: TYPE_NORMAL
- en: With Asm2Clipboard installed, you can highlight a block of assembly code in
    the disassembler, right-click the highlighted code, expand the Asm2Clipboard submenu,
    and select either Copy fixed Asm code to clipboard or Copy Asm code to clipboard.
    The latter prepends the code address of each instruction as a comment, while the
    former copies only the pure code.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Cheat Engine to OllyDbg with Cheat Utility***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Cheat Utility plug-in from tuts4you provides a highly slimmed-down version
    of Cheat Engine within OllyDbg. While Cheat Utility only allows you to do exact-value
    scans with a very limited number of data types, it can make simple scans much
    easier when you don’t need the full functionality of Cheat Engine to find what
    you’re looking for. After installing Cheat Utility, to open its interface (shown
    in [Figure 2-7](ch02.xhtml#ch2fig7)), select **Plugins** ▸ **Cheat utility** ▸
    **Start**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Cheat Utility interface*'
  prefs: []
  type: TYPE_NORMAL
- en: Cheat Utility’s user interface and operation mimic Cheat Engine closely, so
    review [Chapter 1](ch01.xhtml#ch01) if you need a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Games Invader, an updated version of Cheat Utility also from tuts4you, was
    created to provide more functionality. I’ve found it buggy, however, and I prefer
    Cheat Utility since I can always use Cheat Engine for advanced scans.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Controlling OllyDbg Through the Command Line***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The command line plug-in enables you to control OllyDbg through a small command
    line interface. To access the plug-in, either press ALT-F1 or select Plugins ▸
    Command line ▸ Command line. You should then see a window, shown in [Figure 2-8](ch02.xhtml#ch2fig8),
    which acts as the command line interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: Command line interface*'
  prefs: []
  type: TYPE_NORMAL
- en: To execute a command, type it into the input box ➊ and press ENTER. You will
    see a session-level command history in the center list ➋, and the bottom label
    displays the command’s return value ➌ (if any).
  prefs: []
  type: TYPE_NORMAL
- en: Though there are many commands available, I find a majority of them useless.
    I primarily use this tool as a way to test that expressions are parsing as expected
    and as a handy calculator, but there are a few additional use cases that are also
    worth mentioning. I’ve described these in [Table 2-6](ch02.xhtml#ch2tab6).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-6:** Command Line Plug-in Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BC identifier` | Removes any breakpoints present on `identifier`, which
    can be a code address or API function name. |'
  prefs: []
  type: TYPE_TB
- en: '| `BP identifier [,condition]` | Places a debugger breakpoint on `identifier`,
    which can be a code address or API function name. When `identifier` is an API
    function name, the breakpoint will be placed on the function entry point. The
    `condition` parameter is an optional expression that, if present, will be set
    as the breakpoint condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `BPX label` | Places a debugger breakpoint on every instance of `label` within
    the module currently being disassembled. This `label` will typically be an API
    function name. |'
  prefs: []
  type: TYPE_TB
- en: '| `CALC expression ? expression` | Evaluates `expression` and displays the
    result. |'
  prefs: []
  type: TYPE_TB
- en: '| `HD address` | Removes any hardware breakpoints present on `address`. |'
  prefs: []
  type: TYPE_TB
- en: '| `HE address` | Places a hardware on-execute breakpoint on `address`. |'
  prefs: []
  type: TYPE_TB
- en: '| `HR address` | Places a hardware on-access breakpoint on `address`. Only
    four hardware breakpoints can exist at a time. |'
  prefs: []
  type: TYPE_TB
- en: '| `HW address` | Places a hardware on-write breakpoint on `address`. |'
  prefs: []
  type: TYPE_TB
- en: '| `MD` | Removes any existing memory breakpoint, if present. |'
  prefs: []
  type: TYPE_TB
- en: '| `MR address1, address2` | Places a memory on-access breakpoint starting at
    `address1` and spanning until `address2`. Will replace any existing memory breakpoint.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MW address1, address2` | Places a memory on-write breakpoint starting at
    `address1` and spanning until `address2`. Will replace any existing memory breakpoint.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `WATCH expression W expression` | Opens the Watches window and adds `expression`
    to the watch list. Expressions in this list will be reevaluated every time the
    process receives a message and the evaluation results will be displayed beside
    them. |'
  prefs: []
  type: TYPE_TB
- en: The command line plug-in was made by the OllyDbg developer and should come preinstalled
    with OllyDbg.
  prefs: []
  type: TYPE_NORMAL
- en: '***Visualizing Control Flow with OllyFlow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OllyFlow, which can be found in the OpenRCE plug-in directory, is a purely visual
    plug-in that can generate code graphs like the one in [Figure 2-9](ch02.xhtml#ch2fig9)
    and display them using Wingraph32.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: An OllyFlow function flowchart*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Wingraph32 is not provided with OllyFlow, but it is available with the free
    version of IDA here:* [https://www.hex-rays.com/products/ida/](https://www.hex-rays.com/products/ida/)*.
    Download it and drop the* .exe *in your OllyDbg installation folder.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Though not interactive, these graphs allow you to easily identify constructs
    such as loops and nested `if()` statements in game code, which can be paramount
    in control flow analysis. With OllyFlow installed, you can generate a graph by
    going to Plugins ▸ OllyFlow (alternatively, right-click in the disassembler pane
    and expand the OllyFlow graph submenu) and selecting one of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate function flowchart** Generates a graph of the function currently
    in scope, breaking apart different code blocks and showing jump paths. [Figure
    2-9](ch02.xhtml#ch2fig9) shows a function flowchart. Without a doubt, this is
    OllyFlow’s most useful feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate xrefs from graph** Generates a graph of all functions called by
    the function that is currently in scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate xrefs to graph** Generates a graph of all functions that call the
    function currently in scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate call stack graph** Generates a graph of the assumed call path from
    the process entry point to the function currently in scope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate module graph** Theoretically generates a complete graph of all function
    calls in the entire module, but rarely actually works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea of the usefulness of OllyFlow, take a look at the graph in [Figure
    2-9](ch02.xhtml#ch2fig9) and compare it to the relatively simple assembly function
    that generated it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There are five boxes in [Figure 2-9](ch02.xhtml#ch2fig9), and they map to the
    five pieces of this function. The function starts with ➊, and it falls through
    to ➋ if the branch fails or jumps to ➌ if it succeeds. After ➋ executes, it jumps
    directly to piece ➎, which then returns out of the function. After ➌ executes,
    it either falls through to ➍ or branches to ➎ to return directly. After ➍ executes,
    it unconditionally falls through to ➎. What this function does is irrelevant to
    understanding OllyFlow; for now, just focus on seeing how the code maps to the
    graph.
  prefs: []
  type: TYPE_NORMAL
- en: '**PATCHING AN IF( ) STATEMENT**'
  prefs: []
  type: TYPE_NORMAL
- en: If you think you’re ready to get your hands dirty with OllyDbg, keep reading.
    Go to *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*,
    download the book’s resource files, grab *BasicDebugging.exe*, and execute it.
    At first glance, you’ll see that it looks like the classic game Pong. In this
    version of Pong, the ball is invisible to you when it is on your opponent’s screen.
    Your task is to disable this feature so that you can always see the ball. To make
    it easier for you, I’ve made the game autonomous. You don’t have to play, only
    hack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, attach OllyDbg to the game. Then focus the CPU window on the main
    module (find the *.exe* in the module list and double-click it) and use the Referenced
    text strings feature to locate the string that is displayed when the ball is hidden.
    Next, double-click the string to bring it up in the code and analyze the surrounding
    code until you find the `if()` statement that determines whether to hide the ball.
    Lastly, using the code-patching feature, patch the `if()` statement so the ball
    is always drawn. As an added bonus, you might try using OllyFlow to graph this
    function so you can get a better understanding of what exactly it is doing. (Hint:
    The `if()` statement checks whether the ball’s x-coordinate is less than 0x140\.
    If so, it jumps to code that draws the ball. If not, it draws the scene without
    the ball. If you can change 0x140 to, say, 0xFFFF, the ball will never get hidden.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OllyDbg is a much more complex beast than Cheat Engine, but you’ll learn best
    by using it, so dive in and get your hands dirty! You can start by pairing the
    controls taught in this chapter with your debugging skills and going to work on
    some real games. If you are not yet ready to tamper with your virtual fate, however,
    try tackling the example in “[Patching an `if()` Statement](ch02.xhtml#ch02sb01)”
    for a practice environment. When you’re done, read on to [Chapter 3](ch03.xhtml#ch03),
    where I’ll introduce you to Process Monitor and Process Explorer, two tools you’ll
    find invaluable in game-hacking reconnaissance.
  prefs: []
  type: TYPE_NORMAL
