- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**DEBUGGING GAMES WITH OLLYDBG**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用OLLYDBG调试游戏**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: You can scratch the surface of what happens as a game runs with Cheat Engine,
    but with a good debugger, you can dig deeper until you understand the game’s structure
    and execution flow. That makes OllyDbg essential to your game-hacking arsenal.
    It’s packed with a myriad of powerful tools like conditional breakpoints, referenced
    string search, assembly pattern search, and execution tracing, making it a robust
    assembler-level debugger for 32-bit Windows applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cheat Engine你可以了解游戏运行时的一些表面现象，但使用一个优秀的调试器，你可以深入挖掘，直到完全理解游戏的结构和执行流程。这使得OllyDbg成为你游戏破解工具包中不可或缺的部分。它包含了许多强大的工具，如条件断点、字符串引用搜索、汇编模式搜索和执行跟踪，使其成为一个功能强大的32位Windows应用程序汇编级调试器。
- en: 'I’ll cover low-level code structure in detail in [Chapter 4](ch04.xhtml#ch04),
    but for this chapter, I assume you’re at least familiar with modern code-level
    debuggers, such as the one packaged with Microsoft Visual Studio. OllyDbg is functionally
    similar to those, with one major difference: it interfaces with the assembly code
    of an application, working even in the absence of source code and/or debug symbols,
    making it ideal when you need to dig into the internals of a game. After all,
    game companies are rarely nice (or dumb) enough to ship their games with debug
    symbols!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第4章](ch04.xhtml#ch04)详细讲解低级代码结构，但在本章中，我假设你至少对现代代码级调试器有所了解，比如微软Visual Studio自带的调试器。OllyDbg在功能上与这些调试器相似，但有一个重要的区别：它与应用程序的汇编代码进行交互，即使没有源代码和/或调试符号，仍然能够工作，这使得它在你需要深入了解游戏内部时非常理想。毕竟，游戏公司通常不会“好心”或“愚蠢”到将调试符号随游戏一起发布！
- en: In this chapter, I’ll go over OllyDbg’s user interface, show you how to use
    its most common debugging features, break down its expression engine, and provide
    some real-world examples of how you can tie it in to your game hacking endeavors.
    As a wrap-up, I’ll teach you about some useful plug-ins and send you off with
    a test game designed to get you started in OllyDbg.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将介绍OllyDbg的用户界面，向你展示如何使用其最常见的调试功能，解析其表达式引擎，并提供一些实际案例，展示如何将其应用于你的游戏破解工作。最后，我还将介绍一些有用的插件，并送你一款测试游戏，帮助你入门OllyDbg。
- en: '**NOTE**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This chapter focuses on OllyDbg 1.10 and may not be entirely accurate for
    later versions. I use this version because, at the time of writing, the plug-in
    interface for OllyDbg 2 is still far less robust than the one for OllyDbg 1.*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章聚焦于OllyDbg 1.10，可能对后续版本不完全适用。我使用这个版本是因为，在撰写时，OllyDbg 2的插件接口仍然比OllyDbg 1的接口弱很多。*'
- en: When you feel like you have a handle on OllyDbg’s interface and features, you
    can try it on a game yourself with “[Patching an `if()` Statement](ch02.xhtml#ch02sb01)”
    on [page 46](ch02.xhtml#page_46).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你觉得已经掌握了OllyDbg的界面和功能时，可以通过[第46页](ch02.xhtml#page_46)中的“[修改`if()`语句](ch02.xhtml#ch02sb01)”自己尝试调试一个游戏。
- en: '**A Brief Look at OllyDbg’s User Interface**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**简要了解OllyDbg的用户界面**'
- en: Go to the OllyDbg website (*[http://www.ollydbg.de/](http://www.ollydbg.de/)*),
    download and install OllyDbg, and open the program. You should see the toolbar
    shown in [Figure 2-1](ch02.xhtml#ch2fig1) above a multiple window interface area.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 访问OllyDbg官网 (*[http://www.ollydbg.de/](http://www.ollydbg.de/)*)，下载并安装OllyDbg，然后打开程序。你应该会看到如[图2-1](ch02.xhtml#ch2fig1)所示的工具栏和多窗口界面区域。
- en: '![image](../images/f02-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-01.jpg)'
- en: '*Figure 2-1: OllyDbg main window*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：OllyDbg主窗口*'
- en: This toolbar contains the program controls ➊, the debug buttons ➋, the Go to
    button ➌, the control window buttons ➍, and the Settings button ➎.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具栏包含了程序控制按钮➊、调试按钮➋、跳转按钮➌、控制窗口按钮➍和设置按钮➎。
- en: The three program controls allow you to open an executable and attach to the
    process it creates, restart the current process, or terminate execution of the
    current process, respectively. You can also complete these functions with the
    hotkeys F3, CTRL-F2, and ALT-F2, respectively. To attach to a process that is
    already running, click **File** ▸ **Attach**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个程序控制选项让你分别能够打开可执行文件并附加到它创建的进程、重启当前进程，或者终止当前进程的执行。你也可以通过快捷键F3、CTRL-F2和ALT-F2分别完成这些功能。要附加到已经在运行的进程，点击**文件**
    ▸ **附加**。
- en: The debug buttons control the debugger actions. [Table 2-1](ch02.xhtml#ch2tab1)
    describes what these buttons do, along with their hotkeys and functions. This
    table also lists three useful debugger actions that don’t have buttons on the
    debug toolbar.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 调试按钮控制调试器的操作。[表2-1](ch02.xhtml#ch2tab1)描述了这些按钮的功能、快捷键和作用。此表还列出了三个没有按钮的有用调试器操作。
- en: '**Table 2-1:** Debug Buttons and Other Debugger Functions'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 调试按钮和其他调试器功能'
- en: '| **Button** | **Hotkey** | **Function** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **按钮** | **快捷键** | **功能** |'
- en: '| --- | --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Play | F9 | Resumes normal execution of the process. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 播放 | F9 | 恢复进程的正常执行。 |'
- en: '| Pause | F12 | Pauses execution of all threads within the process and brings
    up the CPU window at the instruction currently being executed. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 暂停 | F12 | 暂停进程中所有线程的执行，并在当前执行的指令处打开CPU窗口。 |'
- en: '| Step into | F7 | Single-steps to the next operation to be executed (will
    dive down into function calls). |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 步进进入 | F7 | 单步执行到下一个操作（会进入函数调用）。 |'
- en: '| Step over | F8 | Steps to the next operation to be executed within current
    scope (will skip over function calls). |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 步进越过 | F8 | 单步执行到当前作用域内的下一个操作（会跳过函数调用）。 |'
- en: '| Trace into | CTRL-F11 | Runs a deep trace, tracing every operation that is
    executed. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 跟踪进入 | CTRL-F11 | 执行深度跟踪，跟踪每个执行的操作。 |'
- en: '| Trace over | CTRL-F12 | Runs a passive trace that traces only operations
    within the current scope. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 跟踪超出 | CTRL-F12 | 运行被动跟踪，仅跟踪当前作用域内的操作。 |'
- en: '| Execute until return | CTRL-F9 | Executes until a return operation is hit
    within the current scope. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 执行直到返回 | CTRL-F9 | 执行直到当前作用域内遇到返回操作为止。 |'
- en: '|  | CTRL-F7 | Automatically single-steps on every operation, following execution
    in the disassembly window. This makes execution appear to be animated. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|  | CTRL-F7 | 每次操作都自动单步执行，跟随反汇编窗口中的执行。这使得执行看起来像是动画的。 |'
- en: '|  | CTRL-F8 | Also animates execution, but steps over functions instead of
    stepping into them. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  | CTRL-F8 | 也会动画化执行，但跳过函数而不是进入函数。 |'
- en: '|  | ESC | Stops animation, pausing execution on the current operation. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  | ESC | 停止动画，暂停当前操作的执行。 |'
- en: The Go to button opens a dialog asking for a hexadecimal address. Once you enter
    the address, OllyDbg opens the CPU window and shows the disassembly at the specified
    address. When the CPU window is in focus, you can also show that information with
    the hotkey CTRL-G.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “转到”按钮打开一个对话框，要求输入一个十六进制地址。一旦输入地址，OllyDbg将打开CPU窗口并显示指定地址处的反汇编。当CPU窗口处于焦点时，你还可以通过快捷键CTRL-G显示该信息。
- en: The control window buttons open different *control windows*, which display useful
    information about the process you’re debugging and expose more debugging functions,
    like the ability to set breakpoints. OllyDbg has a total of 13 control windows,
    which can all be open simultaneously within the multiple window interface. [Table
    2-2](ch02.xhtml#ch2tab2) describes these windows, listed in the order in which
    they appear on the window buttons toolbar.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 控制窗口按钮打开不同的*控制窗口*，这些窗口展示了调试中进程的有用信息，并暴露更多的调试功能，例如设置断点的能力。OllyDbg共有13个控制窗口，所有这些窗口可以在多窗口界面中同时打开。[表2-2](ch02.xhtml#ch2tab2)描述了这些窗口，按它们在窗口按钮工具栏中出现的顺序列出。
- en: '**Table 2-2:** OllyDbg’s Control Windows'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-2：** OllyDbg的控制窗口'
- en: '| **Window** | **Hotkey** | **Function** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **窗口** | **快捷键** | **功能** |'
- en: '| --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Log | ALT-L | Displays a list of log messages, including debug prints, thread
    events, debugger events, module loads, and much more. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 日志 | ALT-L | 显示日志消息列表，包括调试打印、线程事件、调试器事件、模块加载等。 |'
- en: '| Modules | ALT-E | Displays a list of all executable modules loaded into the
    process. Double-click a module to open it in the CPU window. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | ALT-E | 显示加载到进程中的所有可执行模块的列表。双击一个模块以在CPU窗口中打开它。 |'
- en: '|  Memory map  | ALT-M | Displays a list of all blocks of memory allocated
    by the process. Double-click a block in the list to bring up a dump window of
    that memory block. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 内存映射 | ALT-M | 显示进程分配的所有内存块的列表。双击列表中的某个块以打开该内存块的转储窗口。 |'
- en: '| Threads |  | Displays a list of threads running in the process. For each
    thread in this list, the process has a structure called a *Thread Information
    Block (TIB)*. OllyDbg allows you to view each thread’s TIB; simply right-click
    a thread and select Dump thread data block. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 线程 |  | 显示进程中运行的线程列表。每个线程在此列表中都有一个名为*线程信息块（TIB）*的结构。OllyDbg允许你查看每个线程的TIB；只需右键点击线程并选择“转储线程数据块”。'
- en: '| Windows |  | Displays a list of window handles held by the process. Right-click
    a window in this list to jump to or set a breakpoint on its class procedure (the
    function that gets called when a message is sent to the window). |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| Windows |  | 显示进程所持有的窗口句柄列表。在此列表中右键单击一个窗口，跳转到该窗口或在其类过程上设置断点（该过程是当消息发送到窗口时被调用的函数）。
    |'
- en: '| Handles |  | Displays a list of handles held by the process. (Note that Process
    Explorer has a much better handle list than OllyDbg, as I will discuss in [Chapter
    3](ch03.xhtml#ch03).) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Handles |  | 显示进程所持有的句柄列表。（注意，Process Explorer 的句柄列表比 OllyDbg 更好，具体细节我会在[第
    3 章](ch03.xhtml#ch03)中讨论。） |'
- en: '| CPU | ALT-C | Displays the main disassembler interface and controls a majority
    of the debugger functionality. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| CPU | ALT-C | 显示主要的反汇编界面并控制大多数调试器功能。 |'
- en: '| Patches | CTRL-P | Displays a list of any assembly code modifications you
    have made to modules within the process. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| Patches | CTRL-P | 显示你对进程中模块所做的任何汇编代码修改的列表。 |'
- en: '| Call stack | ALT-K | Displays the call stack for the active thread. The window
    updates when the process halts. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| Call stack | ALT-K | 显示活动线程的调用栈。进程停止时，窗口会更新。 |'
- en: '| Breakpoints | ALT-B | Displays a list of active debugger breakpoints and
    allows you to toggle them on and off. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| Breakpoints | ALT-B | 显示活动的调试器断点列表，并允许你切换它们的开关。 |'
- en: '| References |  | Displays the reference list, which typically holds the search
    results for many different types of searches. It pops up on its own when you run
    a search. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| References |  | 显示参考列表，通常包含多种类型搜索的结果。它会在你运行搜索时自动弹出。 |'
- en: '| Run trace |  | Displays a list of operations logged by a debugger trace.
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| Run trace |  | 显示调试器追踪记录的操作列表。 |'
- en: '| Source |  | Displays the source code of the disassembled module if a program
    debug database is present. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Source |  | 如果存在程序调试数据库，显示反汇编模块的源代码。 |'
- en: Finally, the Settings button opens the OllyDbg settings window. Keep the default
    settings for now.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置按钮打开 OllyDbg 设置窗口。暂时保持默认设置即可。
- en: Now that you’ve had a tour of the main OllyDbg window, let’s explore the CPU,
    Patches, and Run trace windows more closely. You’ll use those windows extensively
    as a game hacker, and knowing your way around them is key.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经参观了 OllyDbg 主窗口，让我们更深入地探讨 CPU、Patches 和 Run trace 窗口。作为一名游戏黑客，你将大量使用这些窗口，熟悉它们是关键。
- en: '**OllyDbg’s CPU Window**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**OllyDbg 的 CPU 窗口**'
- en: The CPU window in [Figure 2-2](ch02.xhtml#ch2fig2) is where game hackers spend
    most of their time in OllyDbg because it is the main control window for the debugging
    features.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](ch02.xhtml#ch2fig2)中的 CPU 窗口是游戏黑客在 OllyDbg 中大部分时间都待的地方，因为它是调试功能的主要控制窗口。'
- en: '![image](../images/f02-02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-02.jpg)'
- en: '*Figure 2-2: OllyDbg CPU window*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：OllyDbg CPU 窗口*'
- en: 'This window houses four distinct control panes: the disassembler pane ➊, the
    registers pane ➋, the dump pane ➌, and the stack pane ➍. These four panes encapsulate
    OllyDbg’s main debugger functions, so it’s important to know them inside and out.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口包含四个独立的控制面板：反汇编面板 ➊、寄存器面板 ➋、转储面板 ➌ 和堆栈面板 ➍。这四个面板封装了 OllyDbg 的主要调试功能，因此了解它们的细节非常重要。
- en: '***Viewing and Navigating a Game’s Assembly Code***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看和浏览游戏的汇编代码***'
- en: 'You’ll navigate game code and control most aspects of debugging from OllyDbg’s
    disassembler pane. This pane displays the assembly code for the current module,
    and its data is neatly displayed in a table composed of four distinct columns:
    Address, Hex dump, Disassembly, and Comment.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过 OllyDbg 的反汇编面板浏览游戏代码并控制调试的大多数方面。这个面板显示当前模块的汇编代码，其数据整齐地以由四列组成的表格显示：地址、十六进制转储、反汇编和注释。
- en: The Address column displays the memory addresses of each operation in the game
    process you’re attached to. You can double-click an address in this column to
    toggle whether it’s the *display base*. When an address is set as the display
    base, the Address column displays all other addresses as offsets relative to it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 地址列显示你所附加的游戏进程中每个操作的内存地址。你可以双击此列中的地址来切换它是否为*显示基址*。当地址被设置为显示基址时，地址列将显示所有其他地址作为相对于它的偏移量。
- en: The Hex dump column displays the byte code for each operation, grouping operation
    codes and parameters accordingly. Black braces spanning multiple lines on the
    left side of this column mark known function boundaries. Operations that have
    jumps going to them are shown with a right-facing arrow on the inside of these
    braces. Operations that perform jumps are shown with either up-facing or down-facing
    arrows, depending on the direction in which they jump, on the inside of these
    braces. For example, in [Figure 2-2](ch02.xhtml#ch2fig2), the instruction at address
    0x779916B1 (highlighted in gray) has an up-facing arrow, indicating it’s an upward
    jump. You can think of a jump as a `goto` operator.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制转储列显示每个操作的字节码，并按操作码和参数分组。此列左侧跨越多行的黑色括号标记了已知函数的边界。指向这些操作的跳转操作将显示在这些括号内的右箭头。执行跳转的操作会根据跳转的方向，在这些括号内显示向上或向下的箭头。例如，在
    [图 2-2](ch02.xhtml#ch2fig2) 中，地址为 0x779916B1（高亮显示）的指令上有一个向上的箭头，表示这是一个向上的跳转。您可以将跳转视为一个
    `goto` 操作符。
- en: The Disassembly column displays the assembly code of each operation the game
    performs. So, for example, you can confirm that the instruction at 0x779916B1
    in [Figure 2-2](ch02.xhtml#ch2fig2) is a jump by looking at the assembly, which
    shows a JNZ (jump if nonzero) instruction. Black braces in this column mark the
    boundaries of loops. Right-facing arrows attached to these braces point to the
    conditional statements that control whether the loops continue or exit. The three
    right-facing arrows in this column in [Figure 2-2](ch02.xhtml#ch2fig2) point to
    CMP (compare) and TEST instructions, which are used by assembly code to compare
    values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编列显示游戏执行的每个操作的汇编代码。例如，您可以通过查看汇编代码确认 [图 2-2](ch02.xhtml#ch2fig2) 中地址为 0x779916B1
    的指令是一个跳转指令，因为汇编代码中显示了 JNZ（非零时跳转）指令。此列中的黑色括号标记了循环的边界。附着在这些括号上的右箭头指向控制循环是否继续或退出的条件语句。在
    [图 2-2](ch02.xhtml#ch2fig2) 中的这一列里，三个右箭头指向 CMP（比较）和 TEST 指令，这些指令用于汇编代码中进行值的比较。
- en: The Comment column displays human-readable comments about each operation the
    game performs. If OllyDbg encounters known API function names, it will automatically
    insert a comment with the name of the function. Similarly, if it successfully
    detects arguments being passed to a function, it will label them (for example,
    `Arg1`, `Arg2`, . . . , `ArgN`). You can double-click in this column to add a
    customized comment. Black braces in this column mark the assumed boundaries of
    function call parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注释列显示游戏执行的每个操作的可读注释。如果 OllyDbg 遇到已知的 API 函数名，它将自动插入带有函数名称的注释。同样，如果它成功检测到传递给函数的参数，它将标记这些参数（例如，`Arg1`、`Arg2`、...、`ArgN`）。您可以在该列中双击以添加自定义注释。此列中的黑色括号标记了假定的函数调用参数边界。
- en: '**NOTE**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*OllyDbg infers function boundaries, jump directions, loop structures, and
    function parameters during code analysis, so if these columns lack boundary lines
    or jump arrows, just press CTRL-A to run a code analysis on the binary.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*OllyDbg 在代码分析过程中推断函数边界、跳转方向、循环结构和函数参数，因此如果这些列缺少边界线或跳转箭头，只需按 CTRL-A 对二进制文件进行代码分析即可。*'
- en: When the disassembler pane is in focus, there are a few hotkeys you can use
    to quickly navigate code and control the debugger. Use F2 for Toggle breakpoint,
    SHIFT-F12 for Place conditional breakpoint, - (hyphen) for Go back and + (plus)
    for Go forward (these two work as you’d expect in a web browser), * (asterisk)
    for Go to EIP (which is the execution pointer in the x86 architecture), CTRL--
    (hyphen) for Go to previous function, and CTRL-+ for Go to next function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当反汇编窗格获得焦点时，您可以使用一些快捷键来快速导航代码并控制调试器。使用 F2 来切换断点，SHIFT-F12 来设置条件断点，-（短横线）来后退，+（加号）来前进（这两个操作与网页浏览器中的表现相同），*（星号）来跳转到
    EIP（即 x86 架构中的执行指针），CTRL--（短横线）来跳转到上一函数，CTRL-+ 来跳转到下一函数。
- en: 'The disassembler can also populate the References window with different types
    of search results. When you want to change the References window’s contents, right-click
    in the disassembler pane, mouse over the Search for menu to expand it, and select
    one of the following options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编器还可以通过不同类型的搜索结果填充引用窗口。当您想要更改引用窗口的内容时，右键单击反汇编窗格，鼠标悬停在“搜索”菜单上以展开它，然后选择以下选项之一：
- en: '**All intermodular calls** Searches for all calls to functions in remote modules.
    This can, for example, allow you to see everywhere that a game calls `Sleep()`,
    `PeekMessage()`, or any other Windows API function, enabling you to inspect or
    set breakpoints on the calls.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有跨模块调用** 搜索所有调用远程模块中函数的操作。例如，这可以让你看到游戏中所有调用 `Sleep()`、`PeekMessage()` 或任何其他
    Windows API 函数的地方，从而使你能够检查或在调用时设置断点。'
- en: '**All commands** Searches for all occurrences of a given operation written
    in assembly, where the added operators `CONST` and `R32` will match a constant
    value or a register value, respectively. One use for this option might be searching
    for commands like `MOV [0xDEADBEEF], CONST`; `MOV [0xDEADBEEF], R32`; and `MOV
    [0xDEADBEEF], [R32+CONST]` to list all operations that modify memory at the address
    `0xDEADBEEF`, which could be anything, including the address of your player’s
    health.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有命令** 搜索所有给定的汇编操作的出现，其中新增的操作符 `CONST` 和 `R32` 分别匹配常量值或寄存器值。此选项的一个用例可能是搜索诸如
    `MOV [0xDEADBEEF], CONST`；`MOV [0xDEADBEEF], R32`；和 `MOV [0xDEADBEEF], [R32+CONST]`
    的命令，以列出所有修改地址 `0xDEADBEEF` 上内存的操作，这个地址可以是任何东西，包括你角色的生命值地址。'
- en: '**All sequences** Searches for all occurrences of a given sequence of operations.
    This is similar to the previous options, but it allows you to specify multiple
    commands.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有序列** 搜索所有给定操作序列的出现。这类似于之前的选项，但允许你指定多个命令。'
- en: '**All constants** Searches for all instances of a given hexadecimal constant.
    For instance, if you enter the address of your character’s health, this will list
    all of the commands that directly access it.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有常量** 搜索给定十六进制常量的所有实例。例如，如果你输入角色生命值的地址，这将列出所有直接访问该地址的命令。'
- en: '**All switches** Searches for all switch-case blocks.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有开关** 搜索所有的开关-案例块。'
- en: '**All referenced text strings** Searches for all strings referenced in code.
    You can use this option to search through all referenced strings and see what
    code accesses them, which can be useful for correlating in-game text displays
    with the code that displays them. This option is also very useful for locating
    any debug assertion or logging strings, which can be a tremendous help in determining
    the purpose of code parts.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有引用的文本字符串** 搜索代码中引用的所有字符串。你可以使用此选项搜索所有引用的字符串，并查看哪些代码访问了它们，这对于关联游戏中的文本显示与显示它们的代码非常有用。此选项对于定位任何调试断言或日志字符串也非常有用，这对确定代码部分的目的帮助巨大。'
- en: The disassembler can also populate the Names window with all labels in the current
    module (CTRL-N) or all known labels in all modules (Search for ▸ Name in all modules).
    Known API functions will be automatically labeled with their names, and you can
    add a label to a command by highlighting it, pressing SHIFT-; and entering the
    label when prompted. When a labeled command is referenced in code, the label will
    be shown in place of the address. One way to use this feature is to name functions
    that you’ve analyzed (just set a label on the first command in a function) so
    you can see their names when other functions call them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编器还可以将当前模块中的所有标签（CTRL-N）或所有模块中已知的标签（搜索 ▸ 名称在所有模块中）填充到名称窗口中。已知的 API 函数将自动标记为其名称，你可以通过高亮命令、按
    SHIFT-; 并在提示时输入标签来为命令添加标签。当代码中引用带标签的命令时，标签将替代地址显示。使用此功能的一种方法是为你分析过的函数命名（只需在函数的第一个命令上设置标签），这样你就可以看到其他函数调用时的名称。
- en: '***Viewing and Editing Register Contents***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看和编辑寄存器内容***'
- en: The registers pane displays the contents of the eight processor registers, all
    eight flag bits, the six segment registers, the last Windows error code, and EIP.
    Underneath these values, this pane can display either *Floating-Point Unit (FPU)*
    registers or debug registers; click on the pane’s header to change which registers
    are displayed. The values in this pane are populated only if you freeze your process.
    Values that are displayed in red have been changed since the previous pause. Double-click
    on values in this pane to edit them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器窗格显示八个处理器寄存器的内容、所有八个标志位、六个段寄存器、最后的 Windows 错误代码和 EIP。在这些值下方，窗格可以显示*浮点单元（FPU）*寄存器或调试寄存器；点击窗格的标题更改显示的寄存器类型。只有在你冻结进程时，这些值才会被填充。以红色显示的值自上次暂停以来已被更改。双击此窗格中的值可进行编辑。
- en: '***Viewing and Searching a Game’s Memory***'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看和搜索游戏内存***'
- en: The dump pane displays a dump of the memory at a specific address. To jump to
    an address and display the memory contents, press CTRL-G and enter the address
    in the box that appears. You can also jump to the address of an entry in the other
    CPU window panes by right-clicking on the Address column and selecting Follow
    in dump.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 转储窗格显示特定地址的内存转储。要跳转到某个地址并显示该地址的内存内容，请按CTRL-G并在弹出的框中输入地址。你也可以通过右键点击其他CPU窗格的地址列，并选择“在转储中跟随”来跳转到该条目的地址。
- en: While there are always three columns in the dump pane, the only one you should
    always see is the Address column, which behaves much like its cousin within the
    disassembler pane. The data display type you choose determines the other two columns
    shown. Right-click the dump pane to change the display type; for the one shown
    in [Figure 2-2](ch02.xhtml#ch2fig2), you’d right-click and select Hex ▸ Hex/ASCII
    (8 bytes).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然转储窗格始终有三列，但你应始终看到的唯一一列是地址列，它的行为与反汇编窗格中的类似。你选择的数据展示类型决定了其他两列的显示方式。右键点击转储窗格来更改展示类型；对于[图
    2-2](ch02.xhtml#ch2fig2)中显示的类型，你需要右键点击并选择“十六进制” ▸ “十六进制/ASCII（8字节）”。
- en: You can set a memory breakpoint on an address shown in the dump pane by right-clicking
    that address and expanding the Breakpoint submenu. Select **Memory** ▸ **On access**
    from this menu to break on any code that uses the address at all, or select **Memory**
    ▸ **On write** to break only on code that writes to that space in memory. To remove
    a memory breakpoint, select **Remove memory breakpoint** in the same menu; this
    option appears only when the address you right-click has a breakpoint.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过右键点击转储窗格中显示的地址并展开断点子菜单，在某个地址上设置内存断点。 从此菜单中选择**内存** ▸ **按访问**，可以在任何使用该地址的代码上断点，或者选择**内存**
    ▸ **按写入**，仅在写入该内存区域的代码上断点。要删除内存断点，请在相同菜单中选择**删除内存断点**；此选项仅在右键点击的地址上已有断点时出现。
- en: With one or more values selected in the dump, you can press CTRL-R to search
    the current module’s code for references to addresses of the selected values;
    results of this search appear in the References window. You can also search for
    values in this pane using CTRL-B for binary strings and CTRL-N for labels. After
    you initiate a search, press CTRL-L to jump to the next match. CTRL-E allows you
    to edit any values you have selected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在转储窗格中选择一个或多个值后，你可以按CTRL-R在当前模块的代码中搜索引用所选值的地址；此搜索的结果会显示在“引用”窗口中。你还可以使用CTRL-B搜索此窗格中的二进制字符串，使用CTRL-N搜索标签。发起搜索后，按CTRL-L可以跳转到下一个匹配项。CTRL-E可以让你编辑任何已选择的值。
- en: '**NOTE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The dump windows that you can open from the Memory window work in the same
    way as the dump pane.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以从内存窗口打开的转储窗口与转储窗格的工作方式相同。*'
- en: '***Viewing a Game’s Call Stack***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查看游戏的调用栈***'
- en: The final CPU pane is the stack pane, and as the name suggests, it shows the
    call stack. Like the dump and disassembler panes, the stack pane has an Address
    column. The stack pane also has a Value column, which shows the stack as an array
    of 32-bit integers, and a Comment column, which shows return addresses, known
    function names, and other informative labels. The stack pane supports all the
    same hotkeys as the dump pane, with the exception of CTRL-N.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种CPU窗格是堆栈窗格，顾名思义，它显示调用栈。与转储和反汇编窗格一样，堆栈窗格也有地址列。堆栈窗格还具有值列，显示堆栈中的32位整数数组，并且有一个注释列，显示返回地址、已知的函数名称和其他信息标签。堆栈窗格支持与转储窗格相同的所有快捷键，唯一的例外是CTRL-N。
- en: '**MULTICLIENT PATCHING**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**多客户端补丁**'
- en: One type of hack, called a *multiclient patch*, overwrites the single-instance
    limitation code within a game’s binary with no-operation code, allowing the user
    to run multiple game clients, even when doing so is normally forbidden. Because
    the code that performs instance limitation must be executed very early after a
    game client is launched, it can be nearly impossible for a bot to inject its patch
    on time. The easiest workaround for this is to make multiclient patches persist
    by applying them within OllyDbg and saving them directly to the game binary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一种被称为*多客户端补丁*的黑客方式，会在游戏的二进制文件中覆盖单实例限制代码，将其替换为无操作代码，从而允许用户运行多个游戏客户端，即使通常情况下这样做是被禁止的。由于执行实例限制代码必须在游戏客户端启动后非常早的时候进行，这使得机器人的补丁几乎不可能及时注入。最简单的解决方法是通过在OllyDbg中应用补丁并直接将其保存到游戏二进制文件中，使多客户端补丁得以持久化。
- en: '**Creating Code Patches**'
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建代码补丁**'
- en: OllyDbg’s *code patches* let you make assembly code modifications for a game
    you want to hack, removing the need to engineer a tool tailored to that specific
    game. This makes prototyping *control flow hacks*—which manipulate game behavior
    through a mix of game design flaws, x86 assembly protocols, and common binary
    constructs—much easier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: OllyDbg 的 *代码补丁* 允许你对想要破解的游戏进行汇编代码修改，无需专门为该游戏开发工具。这使得原型设计 *控制流破解*——通过游戏设计缺陷、x86
    汇编协议和常见的二进制构造组合来操控游戏行为——变得更加容易。
- en: Game hackers typically include perfected patches as optional features in a bot’s
    tool suite, but in some cases, making those features persistent is actually more
    convenient for your end user. Luckily, OllyDbg patches provide the complete functionality
    you need to design, test, and permanently save code modifications to an executable
    binary using only OllyDbg.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏黑客通常将完善的补丁作为可选功能集成到机器人的工具套件中，但在某些情况下，使这些功能持久化实际上对最终用户更为方便。幸运的是，OllyDbg 的补丁提供了你所需的完整功能，允许你仅使用
    OllyDbg 来设计、测试并永久保存代码修改到可执行的二进制文件中。
- en: To place a patch, navigate to the line of assembly code you want to patch in
    the CPU window, double-click the instruction you wish to modify, place a new assembly
    instruction in the pop-up prompt, and click **Assemble**, as shown in [Figure
    2-3](ch02.xhtml#ch2fig3).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置一个补丁，在 CPU 窗口中导航到你想要修补的汇编代码行，双击你希望修改的指令，在弹出的提示框中输入新的汇编指令，并点击 **汇编**，如 [图
    2-3](ch02.xhtml#ch2fig3) 所示。
- en: '![image](../images/f02-03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-03.jpg)'
- en: '*Figure 2-3: Placing a patch with OllyDbg*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：在 OllyDbg 中设置补丁*'
- en: Always pay attention to the size of your patch—you can’t just resize and move
    around assembled code however you’d like. Patches *larger* than the code you intend
    to replace will overflow into subsequent operations, potentially removing critical
    functionality. Patches *smaller* than the operations you intend to replace are
    safe, as long as Fill with NOPs is checked. This option fills any abandoned bytes
    with *no-operation (NOP)* commands, which are single-byte operations that do nothing
    when executed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 始终注意补丁的大小——你不能随意调整和移动汇编代码。比你打算替换的代码*更大的*补丁会溢出到后续的操作中，可能会移除关键功能。比你打算替换的操作*更小*的补丁是安全的，只要勾选了“用
    NOP 填充”选项。此选项会用*无操作（NOP）*指令填充任何弃用的字节，NOP 指令是单字节操作，在执行时不会执行任何操作。
- en: All patches you place are listed, along with the address, size, state, old code,
    new code, and comment, in the Patches window. Select a patch in this list to access
    a small but powerful set of hotkeys, shown in [Table 2-3](ch02.xhtml#ch2tab3).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有你放置的补丁都会列出，并显示其地址、大小、状态、旧代码、新代码和注释，在补丁窗口中查看。在这个列表中选择一个补丁，访问一组小而强大的快捷键，参见 [表
    2-3](ch02.xhtml#ch2tab3)。
- en: '**Table 2-3:** Patches Window Hotkeys'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-3：补丁窗口快捷键**'
- en: '| **Operator** | **Function** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **功能** |'
- en: '| --- | --- |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ENTER | Jumps to the patch in the disassembler. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| ENTER | 跳转到反汇编器中的补丁。 |'
- en: '| spacebar | Toggles the patch on or off. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 空格键 | 切换补丁的启用或禁用状态。 |'
- en: '| F2 | Places a breakpoint on the patch. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| F2 | 在补丁上设置断点。 |'
- en: '| SHIFT-F2 | Places a conditional breakpoint on the patch. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| SHIFT-F2 | 在补丁上设置条件断点。 |'
- en: '| SHIFT-F4 | Places a conditional log breakpoint on the patch. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| SHIFT-F4 | 在补丁上设置条件日志断点。 |'
- en: '| DEL | Removes the patch entry from the list only. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| DEL | 仅从列表中移除补丁条目。 |'
- en: In OllyDbg, you can also save your patches directly to the binary. First, right-click
    in the disassembler and click **Copy to executable** ▸ **All modifications**.
    If you want to copy only certain patches, highlight them in the disassembly pane
    and press **Copy to executable** ▸ **Selection** instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OllyDbg 中，你还可以直接将补丁保存到二进制文件中。首先，在反汇编器中右键单击，然后点击 **复制到可执行文件** ▸ **所有修改**。如果你只想复制特定的补丁，可以在反汇编窗格中高亮显示它们，然后按
    **复制到可执行文件** ▸ **选择**。
- en: '**DETERMINING PATCH SIZE**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**确定补丁大小**'
- en: There are a few ways to determine whether your patch will be a different size
    than the original code. For example, in [Figure 2-3](ch02.xhtml#ch2fig3), you
    can see the command at `0x7790ED2E` being changed from `SHR AL, 6` to `SHR AL,
    7`. If you look at the bytes to the left of the command, you see 3 bytes that
    represent the memory of the command. This means our new command must either be
    3 bytes or padded with NOPs if it’s less than 3 bytes. Furthermore, these bytes
    are arranged in two columns. The first column contains `0xC0` and `0x08`, which
    represent the command `SHR` and the first operand, `AL`. The second column contains
    `0x06`, which represents the original operand. Because the second column shows
    a single byte, any replacement operand must also be 1 byte (between `0x00` and
    `0xFF`). If this column had shown `0x00000006` instead, a replacement operand
    could be up to 4 bytes in length.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以判断你的补丁是否会与原始代码的大小不同。例如，在[图 2-3](ch02.xhtml#ch2fig3)中，你可以看到位于 `0x7790ED2E`
    的命令从 `SHR AL, 6` 被更改为 `SHR AL, 7`。如果你看命令左边的字节，你会看到三个字节，表示该命令的内存。这意味着我们的新命令必须是3个字节，或者如果少于3个字节，则用NOP填充。此外，这些字节被分为两列。第一列包含
    `0xC0` 和 `0x08`，它们分别表示命令 `SHR` 和第一个操作数 `AL`。第二列包含 `0x06`，表示原始操作数。因为第二列显示了一个字节，所以任何替代操作数也必须是1字节（介于
    `0x00` 和 `0xFF` 之间）。如果第二列显示的是 `0x00000006`，则替代操作数的长度可以达到4字节。
- en: Typical code patches will either use all NOPs to completely remove a command
    (by leaving the box empty and letting it fill the entire command with NOPs) or
    just replace a single operand, so this method of checking patch size is almost
    always effective.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的代码补丁通常会使用所有的NOP指令来完全移除命令（通过留空并让它填充整个命令为NOP），或者仅替换一个操作数，因此这种检查补丁大小的方法几乎总是有效的。
- en: '**Tracing Through Assembly Code**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过汇编代码追踪**'
- en: When you run a trace on any program, OllyDbg single-steps over every executed
    operation and stores data about each one. When the trace is complete, the logged
    data is displayed in the Run trace window, shown in [Figure 2-4](ch02.xhtml#ch2fig4).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对任何程序进行追踪时，OllyDbg 会逐步执行每个操作，并记录每个操作的数据。当追踪完成后，记录的数据会显示在运行追踪窗口中，如[图 2-4](ch02.xhtml#ch2fig4)所示。
- en: '![image](../images/f02-04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-04.jpg)'
- en: '*Figure 2-4: The Run trace window*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：运行追踪窗口*'
- en: 'The Run trace window is organized into the following six columns:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行追踪窗口被组织为以下六列：
- en: '**Back** The number of operations logged between an operation and the current
    execution state'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回** 记录操作与当前执行状态之间的操作次数'
- en: '**Thread** The thread that executed the operation'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程** 执行该操作的线程'
- en: '**Module** The module where the operation resides'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块** 操作所在的模块'
- en: '**Address** The address of the operation'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址** 操作的地址'
- en: '**Command** The operation that was executed'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令** 执行的操作'
- en: '**Modified registers** The registers changed by the operation and their new
    values'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改的寄存器** 操作更改的寄存器及其新值'
- en: When hacking games, I find OllyDbg’s trace feature very effective at helping
    me find pointer paths to dynamic memory when Cheat Engine scans prove inconclusive.
    This works because you can follow the log in the Run trace window backward from
    the point when the memory is used to the point where it is resolved from a static
    address.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在破解游戏时，我发现OllyDbg的追踪功能非常有效，能帮助我找到动态内存的指针路径，尤其是在Cheat Engine扫描结果不明确时。这之所以有效，是因为你可以在运行追踪窗口中，逆向跟踪从内存使用点到内存从静态地址解析点的日志。
- en: This potent feature’s usefulness is limited only by the creativity of the hacker
    using it. Though I typically use it only to find pointer paths, I’ve come across
    a few other situations where it has proven invaluable. The anecdotes in “[OllyDbg
    Expressions in Action](ch02.xhtml#ch00lev1sec44)” on [page 36](ch02.xhtml#page_36)
    will help to illuminate the functionality and power of tracing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个强大的功能的有用性仅受使用它的黑客创造力的限制。虽然我通常只用它来查找指针路径，但我遇到过一些其他情况，在这些情况下，它证明了非常宝贵。[《OllyDbg
    表达式的实际应用》](ch02.xhtml#ch00lev1sec44)中的轶事，以及[第36页](ch02.xhtml#page_36)的内容，有助于阐明追踪的功能和强大之处。
- en: '**OllyDbg’s Expression Engine**'
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**OllyDbg 的表达式引擎**'
- en: OllyDbg is home to a custom expression engine that can compile and evaluate
    advanced expressions with a simple syntax. The expression engine is surprisingly
    powerful and, when utilized properly, can be the difference between an average
    OllyDbg user and an OllyDbg wizard. You can use this engine to specify expressions
    for many features, such as conditional breakpoints, conditional traces, and the
    command line plug-in. This section introduces the expression engine and the options
    it provides.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*Parts of this section are based on the official expressions documentation*
    ([http://www.ollydbg.de/Help/i_Expressions.htm](http://www.ollydbg.de/Help/i_Expressions.htm)*).
    I have found, however, that a few of the components defined in the documentation
    don’t seem to work, at least not in OllyDbg v1.10\. Two examples are the* `INT`
    *and* `ASCII` *data types, which must be substituted with the aliases* `LONG`
    *and* `STRING`*. For this reason, here I include only components that I’ve personally
    tested and fully understand.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Expressions in Breakpoints***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a *conditional breakpoint* is toggled on, OllyDbg prompts you to enter
    an expression for the condition; this is where most expressions are used. When
    that breakpoint is executed, OllyDbg silently pauses execution and evaluates the
    expression. If the result of the evaluation is nonzero, execution remains paused
    and you will see the breakpoint get triggered. But if the result of the evaluation
    is `0`, OllyDbg silently resumes execution as if nothing happened.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: With the huge number of executions that happen within a game every second, you’ll
    often find that a piece of code is executed in far too many contexts for a breakpoint
    to be an effective way of getting the data you are looking for. A conditional
    breakpoint paired with a good understanding of the code surrounding it is a foolproof
    way to avoid these situations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Operators in the Expression Engine***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For numeric data types, OllyDbg expressions support general C-style operators,
    as seen in [Table 2-4](ch02.xhtml#ch2tab4). While there is no clear documentation
    on the operator precedence, OllyDbg seems to follow C-style precedence and can
    use parenthesized scoping.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-4:** OllyDbg Numeric Operators'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Function** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `a == b` | Returns `1` if `a` is equal to `b`, else returns `0`. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `a != b` | Returns `1` if `a` is not equal to `b`, else returns `0`. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `a > b` | Returns `1` if `a` is greater than `b`, else returns `0`. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `a < b` | Returns `1` if `a` is less than `b`, else returns `0`. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `a >= b` | Returns `1` if `a` is greater than or equal to `b`, else returns
    `0`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `a <= b` | Returns `1` if `a` is less than or equal to `b`, else returns
    `0`. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `a && b` | Returns `1` if `a` and `b` are both nonzero, else returns `0`.
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `a &#124;&#124; b` | Returns `1` if either `a` or `b` are nonzero, else returns
    `0`. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `a ^ b` | Returns the result of `XOR(a, b)`. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `a % b` | Returns the result of `MODULUS(a, b)`. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `a & b` | Return the result of `AND(a, b)`. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `a &#124; b` | Return the result of `OR(a, b)`. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `a << b` | Returns the result of `a` shifted `b` bits to the left. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| `a >> b` | Returns the result of `a` shifted `b` bits to the right. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
- en: '|  `a + b`  | Returns the sum of `a` plus `b`. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
- en: '| `a - b` | Returns the difference of `a` minus `b`. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| `a / b` | Returns the quotient of `a` divided by `b`. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| `a * b` | Returns the product of `a` times `b`. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| `+a` | Returns the signed representation of `a`. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Returns `a*-1`. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `!a` | Returns `1` if `a` is `0`, else returns `0`. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: 'For strings, on the other hand, the only available operators are `==` and `!=`,
    which both adhere to the following set of rules:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: • String comparisons are case insensitive.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: • If only one of the operands is a string literal, the comparison will terminate
    after it reaches the length of the literal. As a result, the expression `[STRING
    EAX]=="ABC123"`, where `EAX` is a pointer to the string `ABC123XYZ`, will evaluate
    to `1` instead of `0`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: • If no type is specified for an operand in a string comparison and the other
    operand is a string literal (for example, `"MyString"!=EAX`), the comparison will
    first assume the nonliteral operand is an ASCII string, and, if that compare would
    return `0`, it will try a second compare assuming the operand is a Unicode string.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Of course, operators aren’t much use without operands. Let’s look at some of
    the data you can evaluate in expressions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Basic Expression Elements***'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Expressions are able to evaluate many different elements, including:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU registers** `EAX`, `EBX`, `ECX`, `EDX`, `ESP`, `EBP`, `ESI`, and `EDI`.
    You can also use the 1-byte and 2-byte registers (for example, `AL` for the low
    byte and `AX` for the low word of `EAX`). `EIP` can also be used.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Segment registers** `CS`, `DS`, `ES`, `SS`, `FS`, and `GS`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**FPU registers** `ST0`, `ST1`, `ST2`, `ST3`, `ST4`, `ST5`, `ST6`, and `ST7`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple labels** Can be API function names, such as `GetModuleHandle`, or
    user-defined labels.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows constants** Such as `ERROR_SUCCESS`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**Integers** Are written in hexadecimal format or decimal format if followed
    by a trailing decimal point (for example, `FFFF` or `65535`.).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating-point numbers** Allow exponents in decimal format (for example,
    `654.123e-5`).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**String literals** Are wrapped in quotation marks (for example, `"my string"`).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The expressions engine looks for these elements in the order they’re listed
    here. For example, if you have a label that matches the name of a Windows constant,
    the engine uses the address of the label instead of the constant’s value. But
    if you have a label named after a register, such as EAX, the engine uses the register
    value, not the label value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing Memory Contents with Expressions***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OllyDbg expressions are also powerful enough to incorporate memory reading,
    which you can do by wrapping a memory address, or an expression that evaluates
    to one, in square brackets. For example, `[EAX+C]` and `[401000]` represent the
    contents at the addresses EAX+C and 401000\. To read the memory as a type other
    than `DWORD`, you can specify the desired type either before the brackets, as
    in `BYTE [EAX]`, or as the first token within them, as in `[STRING ESP+C]`. Supported
    types are listed in [Table 2-5](ch02.xhtml#ch2tab5).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-5:** OllyDbg Data Types'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Interpretation** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `BYTE` | 8-bit integer (unsigned) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `CHAR` | 8-bit integer (signed) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `WORD` | 16-bit integer (unsigned) |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| `SHORT` | 16-bit integer (signed) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| `DWORD` | 32-bit integer (unsigned) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `LONG` | 32-bit integer (signed) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `FLOAT` | 32-bit floating-point number |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `DOUBLE` | 64-bit floating-point number |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `STRING` | Pointer to an ASCII string (null-terminated) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| `UNICODE` | Pointer to a Unicode string (null-terminated) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: Plugging memory contents directly into your OllyDbg expressions is incredibly
    useful in game hacking, in part because you can tell the debugger to check a character’s
    health, name, gold, and so on in memory before breaking. You’ll see an example
    of this in “[Pausing Execution When a Specific Player’s Name Is Printed](ch02.xhtml#ch00lev1sec45)”
    on [page 37](ch02.xhtml#page_37).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**OllyDbg Expressions in Action**'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Expressions in OllyDbg use a syntax similar to that of most programming languages;
    you can even combine multiple expressions and nest one expression within another.
    Game hackers (really, all hackers) commonly use them to create conditional breakpoints,
    as I described in “[Using Expressions in Breakpoints](ch02.xhtml#ch00lev1sec40)”
    on [page 34](ch02.xhtml#page_34), but you can use them in many different places
    in OllyDbg. For instance, OllyDbg’s command line plug-in can evaluate expressions
    in place and display their results, allowing you to easily read arbitrary memory,
    inspect values that are being calculated by assembly code, or quickly get the
    results of mathematical equations. Furthermore, hackers can even create intelligent,
    position-agnostic breakpoints by coupling expressions with the trace feature.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll share some anecdotes where the expression engine has come
    in handy during my work. I will explain my thought process, walk through my entire
    debugging session, and break each expression down into its component parts so
    you can see some ways to use OllyDbg expressions in game hacking.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*These examples contain some assembly code, but if you don’t have much experience
    with assembly, don’t worry. Just ignore the fine details and know that values
    like* `ECX`, `EAX`*, and* `ESP` *are process registers like the ones discussed
    in “[Viewing and Editing Register Contents](ch02.xhtml#ch00lev1sec34)” on [page
    29](ch02.xhtml#page_29). From there, I’ll explain everything else.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: If you get confused about an operator, element, or data type in an expression
    as I walk through these anecdotes, just refer to “[OllyDbg’s Expression Engine](ch02.xhtml#ch00lev1sec39)”
    on [page 33](ch02.xhtml#page_33).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我走过这些轶事时，你对表达式中的某个运算符、元素或数据类型感到困惑，只需参考[“OllyDbg的表达式引擎”](ch02.xhtml#ch00lev1sec39)（第33页）。
- en: '***Pausing Execution When a Specific Player’s Name Is Printed***'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当打印特定玩家的名称时暂停执行***'
- en: During one particular debugging session, I needed to figure out exactly what
    was happening when a game was drawing the names of players on screen. Specifically,
    I needed to invoke a breakpoint before the game drew the name “Player 1,” ignoring
    all other names that were drawn.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次特定的调试会话中，我需要搞清楚在游戏绘制玩家名称时究竟发生了什么。具体来说，我需要在游戏绘制“Player 1”名称之前设置断点，忽略所有绘制的其他名称。
- en: '**Figuring Out Where to Pause**'
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**弄清楚在哪儿暂停执行**'
- en: As a starting point, I used Cheat Engine to find the address of Player 1’s name
    in memory. Once I had the address, I used OllyDbg to set a memory breakpoint on
    the first byte of the string. Every time this breakpoint got hit, I quickly inspected
    the assembly code to determine how it was using Player 1’s name. Eventually, I
    found the name being accessed directly above a call to a function that I had previously
    given the name `printText()`. I had found the code that was drawing the name.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，我使用Cheat Engine找到了玩家1名称在内存中的地址。一旦找到了地址，我就用OllyDbg在该字符串的第一个字节上设置了内存断点。每次这个断点被触发时，我快速检查汇编代码，弄清楚它是如何使用玩家1名称的。最终，我找到了名称被直接访问的地方，它位于一个我之前命名为`printText()`的函数调用上方。我找到了绘制名称的代码。
- en: 'I removed my memory breakpoint and replaced it with a code breakpoint on the
    call to `printText()`. There was a problem, however: because the call to `printText()`
    was inside a loop that iterated over every player in the game, my new breakpoint
    was getting hit every time a name was drawn—and that was much too often. I needed
    to fix it to hit only on a specific player.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我移除了我的内存断点，并在调用`printText()`的地方设置了一个代码断点。然而，出现了一个问题：由于调用`printText()`的地方在一个循环中，这个循环遍历了游戏中的每个玩家，所以每次绘制名称时，我的新断点都会被触发——这太频繁了。我需要修复它，使其仅在特定玩家时触发。
- en: 'Inspecting the assembly code at my previous memory breakpoint told me that
    each player’s name was accessed using the following assembly code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我之前的内存断点时发现，每个玩家的名称是通过以下汇编代码访问的：
- en: '[PRE0]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `EAX` register contained the address of an array of player data; I’ll call
    it `playerStruct`. The size of `playerStruct` was 0x90 bytes, the `ECX` register
    contained the iteration index (the famous variable `i`), and each player’s name
    was stored 0x50 bytes after the start of its respective `playerStruct`. This meant
    that this `PUSH` instruction essentially put `EAX[ECX].name` (the name of the
    player at index `i`) on the stack to be passed as an argument to the `printText()`
    function call. The loop, then, broke down to something like the following psuedocode:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`EAX`寄存器包含了一个玩家数据数组的地址；我将其称为`playerStruct`。`playerStruct`的大小为0x90字节，`ECX`寄存器包含迭代索引（著名的变量`i`），每个玩家的名称存储在其相应`playerStruct`开始位置后0x50字节的地方。这意味着，这条`PUSH`指令本质上将`EAX[ECX].name`（索引`i`的玩家名称）压入栈中，并作为参数传递给`printText()`函数调用。于是，循环大致可以分解为如下伪代码：'
- en: '[PRE1]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Purely through analysis, I determined that the `playerStruct()` function contained
    data for all players, and the loop iterated over the total number of players (counting
    up with `ECX` ➊), fetched the character name ➋ for each index, and printed the
    name.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析，我确定了`playerStruct()`函数包含了所有玩家的数据，而循环遍历了玩家的总数（通过`ECX` ➊递增），为每个索引获取了角色名称
    ➋，并打印了这个名字。
- en: '**Crafting the Conditional Breakpoint**'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**制作条件断点**'
- en: 'Knowing that, to pause execution only when printing “Player 1” all I had to
    do was check the current player name before executing my breakpoint. In pseudocode,
    the new breakpoint would look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了这一点，为了仅在打印“Player 1”时暂停执行，我只需要在执行断点之前检查当前玩家的名称。在伪代码中，新的断点看起来像这样：
- en: '[PRE2]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once I figured out the form of my new breakpoint, I needed to access `EAX[ECX].name`
    from within the loop. That’s where OllyDbg’s expression engine came in: I could
    achieve my goal by making slight modifications to the expression that the assembly
    code used, leaving me with this expression:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我弄清楚了新断点的形式，我需要在循环中访问`EAX[ECX].name`。这时，OllyDbg的表达式引擎派上了用场：通过稍微修改汇编代码所用的表达式，我达到了目标，最终得到了这个表达式：
- en: '[PRE3]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I removed the code breakpoint on `printText()` and replaced it with a conditional
    breakpoint that used this expression, which told OllyDbg to break only if the
    string value stored at `EAX + ECX*0x90 + 0x50` matched Player 1’s name. This breakpoint
    hit only when `"Player 1"` was being drawn, allowing me to continue my analysis.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我移除了 `printText()` 上的代码断点，改为使用一个条件断点，该断点使用这个表达式，告诉 OllyDbg 仅当 `EAX + ECX*0x90
    + 0x50` 存储的字符串值与 Player 1 的名字匹配时才中断。这个断点只会在绘制 `"Player 1"` 时触发，从而让我继续我的分析。
- en: The amount of work it took to engineer this breakpoint might seem extensive,
    but with practice, the entire process becomes as intuitive as writing code. Experienced
    hackers can do this in a matter of seconds.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这个断点所需的工作量可能看起来很大，但通过练习，整个过程变得像写代码一样直观。经验丰富的黑客可以在几秒钟内完成这个操作。
- en: In practice, this breakpoint enabled me to inspect certain values in the `playerStruct()`
    function for `"Player 1"` as soon as he appeared on screen. Doing it this way
    was important, as the states of these values were relevant to my analysis only
    in the first few frames after the player entered the screen. Creatively using
    breakpoints like this can enable you to analyze all sorts of complex game behavior.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个断点使我能够在 `"Player 1"` 一出现就检查 `playerStruct()` 函数中的某些值。这样做很重要，因为这些值的状态只有在玩家进入屏幕后头几帧才与我的分析相关。像这样创造性地使用断点，可以让你分析各种复杂的游戏行为。
- en: '***Pausing Execution When Your Character’s Health Drops***'
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当角色生命值降低时暂停执行***'
- en: 'During another debugging session, I needed to find the first function called
    after my character’s health dropped below the maximum. I knew two ways to approach
    this problem:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次调试过程中，我需要找到在我的角色的生命值降到最大值以下后，第一次被调用的函数。我知道两种方法来解决这个问题：
- en: • Find every piece of code that accesses the health value and place a conditional
    breakpoint that checks the health on each one. Then, once one of these breakpoints
    is hit, single-step through the code until the next function call.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: • 查找每一段访问生命值的代码，并在每一段代码上设置一个条件断点，检查生命值。然后，当其中一个断点被触发时，逐步执行代码，直到下一个函数调用。
- en: • Use OllyDbg’s trace function to create a dynamic breakpoint that can stop
    exactly where I need.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: • 使用 OllyDbg 的追踪功能来创建一个动态断点，能够在我需要的地方停止。
- en: The first method required more setup and was not easily repeatable, mostly due
    to the sheer number of breakpoints needed and the fact that I’d have to single-step
    by hand. In contrast, the latter method had a quick setup, and since it did everything
    automatically, it was easily repeatable. Though using the trace function would
    slow the game down considerably (every single operation was captured by the trace),
    I chose the latter method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法需要更多的设置，而且不容易重复，主要是因为需要设置大量的断点，而且我必须手动逐步执行代码。相比之下，后者方法的设置较为快速，且由于它是自动执行的，因此容易重复。尽管使用追踪功能会显著降低游戏速度（每个操作都会被追踪捕获），但我选择了后者方法。
- en: '**Writing an Expression to Check Health**'
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编写检查生命值的表达式**'
- en: Once again, I started by using Cheat Engine to find the address that stored
    my health. Using the method described in “[Cheat Engine’s Memory Scanner](ch01.xhtml#ch00lev1sec9)”
    on [page 5](ch01.xhtml#page_5), I determined the address to be 0x40A000.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我再次使用了 Cheat Engine 来查找存储生命值的地址。通过参考 “[Cheat Engine的内存扫描器](ch01.xhtml#ch00lev1sec9)”
    在 [第5页](ch01.xhtml#page_5) 中描述的方法，我确定该地址为 0x40A000。
- en: 'Next, I needed an expression that told OllyDbg to return `1` when my health
    was below maximum and return `0` otherwise. Knowing that my health was stored
    at 0x40A000 and that the maximum value was `500`, I initially devised this expression:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要一个表达式，告诉 OllyDbg 当我的生命值低于最大值时返回 `1`，否则返回 `0`。知道我的生命值存储在 0x40A000，并且最大值是
    `500`，我最初设计了这个表达式：
- en: '[PRE4]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This expression would invoke a break when my health was below 500 (remember,
    decimal numbers must be suffixed with a period in the expression engine), but
    instead of waiting for a function to be called, the break would happen immediately.
    To ensure that it waited until a function was called, I appended another expression
    with the `&&` operator:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式会在我的生命值低于 500 时触发中断（记住，在表达式引擎中，十进制数字必须以句点作为后缀），但与其等待一个函数被调用，不如立即触发中断。为了确保它等待直到函数被调用，我用
    `&&` 运算符附加了另一个表达式：
- en: '[PRE5]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: On x86 processors, the EIP register stores the address of the operation being
    executed, so I decided to check the first byte at `EIP` ➊ to see if it was equal
    to `0xE8`. This value tells the processor to execute a *near function call*, which
    is the type of call I was looking for.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x86 处理器中，EIP 寄存器存储正在执行的操作的地址，因此我决定检查 `EIP` ➊ 处的第一个字节，看看它是否等于 `0xE8`。这个值告诉处理器执行一个*近距离函数调用*，这正是我所寻找的调用类型。
- en: Before starting my trace, I had to do one last thing. Because the trace feature
    repeatedly single-steps (Trace into uses step into and Trace over uses step over,
    as described in “[A Brief Look at OllyDbg’s User Interface](ch02.xhtml#ch00lev1sec31)”
    on [page 24](ch02.xhtml#page_24)), I needed to start the trace at a location scoped
    at or above the level of any code that could possibly update the health value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始我的跟踪之前，我还需要做一件最后的事情。由于跟踪功能会反复单步执行（如 “[简要了解 OllyDbg 的用户界面](ch02.xhtml#ch00lev1sec31)”
    中所述，Trace into 使用步入，Trace over 使用步过，[第 24 页](ch02.xhtml#page_24)），我需要从一个位于或高于任何可能更新生命值的代码的地方开始跟踪。
- en: '**Figuring Out Where to Start the Trace**'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**找出从哪里开始跟踪**'
- en: To find a good location, I opened the game’s main module in OllyDbg’s CPU window,
    right-clicked in the disassembler pane, and selected Search for ▸ All intermodular
    calls. The References window popped up and displayed a list of external API functions
    that were called by the game. Nearly all gaming software polls for new messages
    using the Windows `USER32.PeekMessage()` function, so I sorted the list using
    the Destination column and typed `PEEK` (you can search the list by simply typing
    a name with the window in focus) to locate the first call to `USER32.PeekMessage()`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到一个合适的位置，我在 OllyDbg 的 CPU 窗口中打开了游戏的主模块，在反汇编面板中右键单击，然后选择了“搜索 ▸ 所有模块间调用”。随后弹出了“引用”窗口，显示了游戏调用的外部
    API 函数列表。几乎所有的游戏软件都使用 Windows 的 `USER32.PeekMessage()` 函数来轮询新的消息，因此我根据目标列对列表进行了排序，并输入了
    `PEEK`（你可以通过将窗口聚焦并直接输入名称来搜索列表），找到了第一次调用 `USER32.PeekMessage()` 的位置。
- en: Thanks to the Destination sorting, every call to this function was listed in
    a contiguous chunk following the first, as shown in [Figure 2-5](ch02.xhtml#ch2fig5).
    I set a breakpoint on each by selecting it and pressing F2.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了目标列排序，每次调用这个函数的记录都紧随其后地列在一起，正如[图 2-5](ch02.xhtml#ch2fig5)所示。我通过选择它并按下 F2
    在每个调用上设置了断点。
- en: '![image](../images/f02-05.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-05.jpg)'
- en: '*Figure 2-5: OllyDbg’s Found intermodular calls window*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：OllyDbg 的找到的模块间调用窗口*'
- en: Though there were around a dozen calls to `USER32.PeekMessage()`, only two of
    them were setting off my breakpoints. Even better, the active calls were beside
    one another in an unconditional loop. At the bottom of this loop were a number
    of internal function calls. This looked exactly like a main game loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有大约十几次调用 `USER32.PeekMessage()`，但只有其中两次触发了我的断点。更好的是，活跃的调用彼此相邻，位于一个无条件的循环中。在这个循环的底部有一些内部函数调用。这看起来完全像是一个主游戏循环。
- en: '**Activating the Trace**'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**激活跟踪**'
- en: To finally set my trace, I removed all of my previous breakpoints and placed
    one at the top of the suspected main loop. I removed the breakpoint as soon as
    it was hit. I then pressed CTRL-T from the CPU window, which brought up a dialog
    called Condition to pause run trace, shown in [Figure 2-6](ch02.xhtml#ch2fig6).
    Within this new dialog, I enabled the Condition is TRUE option, placed my expression
    in the box beside it, and pressed OK. Then, I went back to the CPU window and
    pressed CTRL-F11 to begin a Trace Into session.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最终设置我的跟踪，我删除了所有先前的断点，并在怀疑的主循环顶部放置了一个断点。我在断点触发后立即将其移除。然后，我按下了 CPU 窗口中的 CTRL-T，弹出了一个名为“条件暂停跟踪运行”的对话框，如[图
    2-6](ch02.xhtml#ch2fig6)所示。在这个新对话框中，我启用了“条件为 TRUE”选项，将我的表达式放入旁边的框中，并点击了 OK。接着，我回到
    CPU 窗口，按下 CTRL-F11 开始一个“跟踪进入”会话。
- en: '![image](../images/f02-06.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-06.jpg)'
- en: '*Figure 2-6: Condition to pause run trace dialog*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：用于暂停跟踪运行的条件对话框*'
- en: Once the trace began, the game ran so slowly it was nearly unplayable. To decrease
    my test character’s health, I opened a second instance of the game, logged into
    a different character, and attacked my test character. When the execution of the
    trace caught up to real time, OllyDbg saw my health change and triggered the breakpoint
    on the following function call—just as expected.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦跟踪开始，游戏运行得非常慢，几乎无法玩耍。为了减少我的测试角色的生命值，我打开了第二个游戏实例，登录了一个不同的角色，并攻击了我的测试角色。当跟踪执行进度赶上实时进度时，OllyDbg
    看到我的生命值发生变化，并在以下函数调用时触发了断点——正如预期的那样。
- en: 'In this game, the main pieces of code that would modify the health value were
    directly invoked from the network code. Using this trace, I was able to find the
    function that the network module called directly after a network packet told the
    game to change the player’s health. Here’s the psuedocode of what the game was
    doing:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I knew the game had code that needed to execute only when the player’s health
    was changed, and I needed to add code that could also respond to such changes.
    Without knowing the overall code structure, I guessed that the health-dependent
    code would be executed from some function call directly after `health` was updated.
    My trace conditional breakpoint confirmed this hunch, as it broke directly on
    the `observe()` function ➊. From there, I was able to place a *hook* on the function
    (*hooking*, a way to intercept function calls, is described in “[Hooking to Redirect
    Game Execution](ch08.xhtml#ch00lev1sec151)” on [page 153](ch08.xhtml#page_153))
    and execute my own code when the player’s health changed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**OllyDbg Plug-ins for Game Hackers**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OllyDbg’s highly versatile plug-in system is perhaps one of its most powerful
    features. Experienced game hackers often configure their OllyDbg environments
    with dozens of useful plug-ins, both publicly available and custom-made.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download popular plug-ins from the OpenRCE (*[http://www.openrce.org/downloads/browse/OllyDbg_Plugins](http://www.openrce.org/downloads/browse/OllyDbg_Plugins)*)
    and tuts4you (*[http://www.tuts4you.com/download.php?list.9/](http://www.tuts4you.com/download.php?list.9/)*)
    plug-in repositories. Installing them is easy: just unzip the plug-in files and
    place them inside OllyDbg’s installation folder.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, some plug-ins can be accessed from the OllyDbg’s Plugin menu
    item. Other plug-ins, however, might be found only in specific places throughout
    the OllyDbg interface.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: You can find hundreds of potent plug-ins using these online repositories, but
    you should be careful when constructing your arsenal. Working in an environment
    bloated by unused plug-ins can actually impede productivity. In this section,
    I’ve carefully selected four plug-ins that I believe are not only integral to
    a game hacker’s toolkit but also noninvasive to the environment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '***Copying Assembly Code with Asm2Clipboard***'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Asm2Clipboard is a minimalistic plug-in from the OpenRCE repository that allows
    you to copy chunks of assembly code from the disassembler pane to the clipboard.
    This can be useful for updating address offsets and devising code caves, two game-hacking
    essentials I cover deeply in [Chapters 5](ch05.xhtml#ch05) and [7](ch07.xhtml#ch07).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: With Asm2Clipboard installed, you can highlight a block of assembly code in
    the disassembler, right-click the highlighted code, expand the Asm2Clipboard submenu,
    and select either Copy fixed Asm code to clipboard or Copy Asm code to clipboard.
    The latter prepends the code address of each instruction as a comment, while the
    former copies only the pure code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Cheat Engine to OllyDbg with Cheat Utility***'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Cheat Utility plug-in from tuts4you provides a highly slimmed-down version
    of Cheat Engine within OllyDbg. While Cheat Utility only allows you to do exact-value
    scans with a very limited number of data types, it can make simple scans much
    easier when you don’t need the full functionality of Cheat Engine to find what
    you’re looking for. After installing Cheat Utility, to open its interface (shown
    in [Figure 2-7](ch02.xhtml#ch2fig7)), select **Plugins** ▸ **Cheat utility** ▸
    **Start**.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-07.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Cheat Utility interface*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Cheat Utility’s user interface and operation mimic Cheat Engine closely, so
    review [Chapter 1](ch01.xhtml#ch01) if you need a refresher.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '*Games Invader, an updated version of Cheat Utility also from tuts4you, was
    created to provide more functionality. I’ve found it buggy, however, and I prefer
    Cheat Utility since I can always use Cheat Engine for advanced scans.*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '***Controlling OllyDbg Through the Command Line***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The command line plug-in enables you to control OllyDbg through a small command
    line interface. To access the plug-in, either press ALT-F1 or select Plugins ▸
    Command line ▸ Command line. You should then see a window, shown in [Figure 2-8](ch02.xhtml#ch2fig8),
    which acts as the command line interface.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-08.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: Command line interface*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: To execute a command, type it into the input box ➊ and press ENTER. You will
    see a session-level command history in the center list ➋, and the bottom label
    displays the command’s return value ➌ (if any).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Though there are many commands available, I find a majority of them useless.
    I primarily use this tool as a way to test that expressions are parsing as expected
    and as a handy calculator, but there are a few additional use cases that are also
    worth mentioning. I’ve described these in [Table 2-6](ch02.xhtml#ch2tab6).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-6:** Command Line Plug-in Commands'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Function** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: '| `BC identifier` | Removes any breakpoints present on `identifier`, which
    can be a code address or API function name. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
- en: '| `BP identifier [,condition]` | Places a debugger breakpoint on `identifier`,
    which can be a code address or API function name. When `identifier` is an API
    function name, the breakpoint will be placed on the function entry point. The
    `condition` parameter is an optional expression that, if present, will be set
    as the breakpoint condition. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '| `BPX label` | Places a debugger breakpoint on every instance of `label` within
    the module currently being disassembled. This `label` will typically be an API
    function name. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
- en: '| `CALC expression ? expression` | Evaluates `expression` and displays the
    result. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
- en: '| `HD address` | Removes any hardware breakpoints present on `address`. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '| `HE address` | Places a hardware on-execute breakpoint on `address`. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
- en: '| `HR address` | Places a hardware on-access breakpoint on `address`. Only
    four hardware breakpoints can exist at a time. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '| `HW address` | Places a hardware on-write breakpoint on `address`. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '| `MD` | Removes any existing memory breakpoint, if present. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '| `MR address1, address2` | Places a memory on-access breakpoint starting at
    `address1` and spanning until `address2`. Will replace any existing memory breakpoint.
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '| `MW address1, address2` | Places a memory on-write breakpoint starting at
    `address1` and spanning until `address2`. Will replace any existing memory breakpoint.
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '| `WATCH expression W expression` | Opens the Watches window and adds `expression`
    to the watch list. Expressions in this list will be reevaluated every time the
    process receives a message and the evaluation results will be displayed beside
    them. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
- en: The command line plug-in was made by the OllyDbg developer and should come preinstalled
    with OllyDbg.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '***Visualizing Control Flow with OllyFlow***'
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: OllyFlow, which can be found in the OpenRCE plug-in directory, is a purely visual
    plug-in that can generate code graphs like the one in [Figure 2-9](ch02.xhtml#ch2fig9)
    and display them using Wingraph32.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-09.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: An OllyFlow function flowchart*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '*Wingraph32 is not provided with OllyFlow, but it is available with the free
    version of IDA here:* [https://www.hex-rays.com/products/ida/](https://www.hex-rays.com/products/ida/)*.
    Download it and drop the* .exe *in your OllyDbg installation folder.*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Though not interactive, these graphs allow you to easily identify constructs
    such as loops and nested `if()` statements in game code, which can be paramount
    in control flow analysis. With OllyFlow installed, you can generate a graph by
    going to Plugins ▸ OllyFlow (alternatively, right-click in the disassembler pane
    and expand the OllyFlow graph submenu) and selecting one of the following options:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate function flowchart** Generates a graph of the function currently
    in scope, breaking apart different code blocks and showing jump paths. [Figure
    2-9](ch02.xhtml#ch2fig9) shows a function flowchart. Without a doubt, this is
    OllyFlow’s most useful feature.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate xrefs from graph** Generates a graph of all functions called by
    the function that is currently in scope.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate xrefs to graph** Generates a graph of all functions that call the
    function currently in scope.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate call stack graph** Generates a graph of the assumed call path from
    the process entry point to the function currently in scope.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate module graph** Theoretically generates a complete graph of all function
    calls in the entire module, but rarely actually works.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an idea of the usefulness of OllyFlow, take a look at the graph in [Figure
    2-9](ch02.xhtml#ch2fig9) and compare it to the relatively simple assembly function
    that generated it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are five boxes in [Figure 2-9](ch02.xhtml#ch2fig9), and they map to the
    five pieces of this function. The function starts with ➊, and it falls through
    to ➋ if the branch fails or jumps to ➌ if it succeeds. After ➋ executes, it jumps
    directly to piece ➎, which then returns out of the function. After ➌ executes,
    it either falls through to ➍ or branches to ➎ to return directly. After ➍ executes,
    it unconditionally falls through to ➎. What this function does is irrelevant to
    understanding OllyFlow; for now, just focus on seeing how the code maps to the
    graph.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**PATCHING AN IF( ) STATEMENT**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: If you think you’re ready to get your hands dirty with OllyDbg, keep reading.
    Go to *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*,
    download the book’s resource files, grab *BasicDebugging.exe*, and execute it.
    At first glance, you’ll see that it looks like the classic game Pong. In this
    version of Pong, the ball is invisible to you when it is on your opponent’s screen.
    Your task is to disable this feature so that you can always see the ball. To make
    it easier for you, I’ve made the game autonomous. You don’t have to play, only
    hack.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, attach OllyDbg to the game. Then focus the CPU window on the main
    module (find the *.exe* in the module list and double-click it) and use the Referenced
    text strings feature to locate the string that is displayed when the ball is hidden.
    Next, double-click the string to bring it up in the code and analyze the surrounding
    code until you find the `if()` statement that determines whether to hide the ball.
    Lastly, using the code-patching feature, patch the `if()` statement so the ball
    is always drawn. As an added bonus, you might try using OllyFlow to graph this
    function so you can get a better understanding of what exactly it is doing. (Hint:
    The `if()` statement checks whether the ball’s x-coordinate is less than 0x140\.
    If so, it jumps to code that draws the ball. If not, it draws the scene without
    the ball. If you can change 0x140 to, say, 0xFFFF, the ball will never get hidden.)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OllyDbg is a much more complex beast than Cheat Engine, but you’ll learn best
    by using it, so dive in and get your hands dirty! You can start by pairing the
    controls taught in this chapter with your debugging skills and going to work on
    some real games. If you are not yet ready to tamper with your virtual fate, however,
    try tackling the example in “[Patching an `if()` Statement](ch02.xhtml#ch02sb01)”
    for a practice environment. When you’re done, read on to [Chapter 3](ch03.xhtml#ch03),
    where I’ll introduce you to Process Monitor and Process Explorer, two tools you’ll
    find invaluable in game-hacking reconnaissance.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
