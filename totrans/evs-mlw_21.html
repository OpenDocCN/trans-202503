<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_345" aria-label="345"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch17">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">17</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">PACKERS AND UNPACKING MALWARE</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">Modern malware needs built-in protections to evade modern endpoint and network defenses. Ideally, these protections will also impede reverse-engineering and help protect the malware’s payload and internals from investigators. One option is a <i>packer</i>, a tool that adds obfuscation and protection to software. Many of the malware samples you’re likely to encounter in the wild will be packed, so it’s very important to be familiar with them. This chapter will introduce various types of malware packers, their architecture, how they work, and, most importantly, how to bypass them in order to access the malicious code they contain.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_346" aria-label="346"/>&#13;
<h3 class="H1" id="sec1"><span id="h-268"/><samp class="SANS_Futura_Std_Bold_B_11">Types of Packers</samp></h3>&#13;
<p class="TNI1">When packers were originally designed, there was nothing inherently malicious about them. They were used simply to compress files such as executables. Once malware started using packing programs, however, the word <i>packer</i> became synonymous with malware.</p>&#13;
<p class="TX">There are multiple varieties of packers. The most common type, which I’ll call <i>general packers</i>, is often free, open source, or otherwise widely available. Examples of general packers include NSPack, MPRESS, and UPX (Ultimate Packer for Executables), which are freely available to anyone, including malware authors. The downside of malware using general packers (for their authors, at least) is that they’re typically very easy to unpack using automated tools or manual analysis since they weren’t designed with anti-analysis in mind. Still, some malware samples in the wild use these simple packers as a quick and inexpensive way to provide basic obfuscation for their payloads.</p>&#13;
<p class="TX">The second type of packer includes <i>commercial packers</i> such as VMProtect, Themida, and Armadillo. Also known as protectors or obfuscators, these were created primarily for protecting the intellectual property of legitimate software. Because a lot of research went into their design, commercial packers are often very difficult to unpack. Luckily for us, they’re not as commonly used to protect malware.</p>&#13;
<p class="TX">Finally, the last type of packer is designed specifically for malware. These packers, sometimes called <i>crypters</i>, are often developed by threat actor groups or affiliates and sold on hacker forums. Some examples of this type of packer are Warzone, Atilla, and Softinca Crypter, the last of which is shown in <a href="chapter17.xhtml#fig17-1">Figure 17-1</a>.</p>&#13;
<figure class="IMG"><img class="img60" id="fig17-1" src="../images/fig17-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-1: The interface for Softinca Crypter</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_347" aria-label="347"/>Softinca Crypter takes an executable file (the unpacked malware payload) as input, adds protection such as code obfuscation and the ability to hide the payload execution from the victim, and then creates the packed executable file.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Since</i> <span class="note_Italic">packer</span> <i>is often used as a catch-all term for protectors, obfuscators, and crypters, I’ll follow that convention throughout this chapter.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-269"/><samp class="SANS_Futura_Std_Bold_B_11">Packer Architecture and Functionality</samp></h3>&#13;
<p class="TNI1">When a malware executable is run through a packing program, the program encrypts and compresses the PE’s sections (<i>.text</i>, <i>.data</i>, <i>.rdata</i>, <i>.rsrc</i>, and so on) within the executable. The packer also adds an <i>unpacking stub</i>, a (usually) small section of code that’s responsible for decrypting the executable’s sections once it’s run on the target host, to the packed executable. <a href="chapter17.xhtml#fig17-2">Figure 17-2</a> illustrates this process.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-2" src="../images/fig17-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-2: The malware packing process</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can see in <a href="chapter17.xhtml#fig17-2">Figure 17-2</a> that the unpacked malware executable is being run through the packing program, which takes its code and data and encrypts (or packs) it. The unpacking stub is also added to the packed file. Upon running on the victim host, the unpacking stub decrypts the packed code and data, loads the unpacked payload into memory, and executes the payload by transferring control flow to the <i>Original Entry Point (OEP)</i>, as shown in <a href="chapter17.xhtml#fig17-3">Figure 17-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_348" aria-label="348"/>&#13;
<figure class="IMG"><img class="img100" id="fig17-3" src="../images/fig17-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-3: Packed malware being unpacked into memory</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s take a look at this process in more depth.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-270"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unpacking the Malware Payload</samp></h4>&#13;
<p class="TNI1">Before the malware’s payload can be executed, it must be unpacked. The unpacking stub must decrypt (or deobfuscate) the original executable file’s code and data into memory. For most Windows executables, this will involve running decryption and decompression algorithms on the packed executable, allocating memory space using Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, and writing the newly unpacked executable to the new memory region.</p>&#13;
<p class="TX">Unpacking can occur in one or more stages. General packers, such as UPX, simply unpack the executable in memory and run it. Other packers, especially custom packers designed for malware, may have more than one unpacking stage, as shown in <a href="chapter17.xhtml#fig17-4">Figure 17-4</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_349" aria-label="349"/>&#13;
<figure class="IMG"><img class="img50" id="fig17-4" src="../images/fig17-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-4: Malware using multistage unpacking</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The simplified process shown in <a href="chapter17.xhtml#fig17-4">Figure 17-4</a> illustrates a packed malware sample unpacking code Segment 1, which unpacks code Segment 2, which in turn unpacks code Segment 3. By unpacking the code in pieces, malware can evade host-based defenses that are looking for the entire malicious code in memory. This sort of unpacking routine also complicates the malware analysis process since the analyst will have a more difficult time understanding the unpacking process and identifying all the locations in memory into which the malware is being unpacked.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-271"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Resolving Imports</samp></h4>&#13;
<p class="TNI1">Once the malware’s payload has been unpacked into memory, the unpacking stub must resolve the imports of the original executable. Remember, imports are the Windows libraries (DLLs) that allow the executable to function within a Windows environment. When a malware sample is run through a packing program, the import address table (IAT) is typically obfuscated or hidden to mask the intent of the program and better evade defenses. This IAT must be rebuilt for the malware’s unpacked executable to function as originally intended.</p>&#13;
<p class="TX">It’s common for packed malware to contain only a few entries in its IAT, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> functions. These two functions are often used to load additional libraries, resolve function addresses, and rebuild the IAT of the original executable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> function loads each library required by the original malware executable, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> function gets the address of each required function. You should be suspicious if you come across an executable file with only a few libraries listed in its IAT.</p>&#13;
<p class="TX">Packers might also remove all imports, leaving behind an empty IAT. This is the stealthiest approach, but the unpacking stub is then required to do the heavy lifting and resolve all imports. It starts by getting the address <span role="doc-pagebreak" epub:type="pagebreak" id="pg_350" aria-label="350"/>of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> functions, and then it loads each library and resolves each function address needed for the unpacked payload’s operation.</p>&#13;
<p class="TX">Alternatively, certain packers will not rebuild the original IAT at all. In this case, the imports and address resolution process must be completely handled by the unpacked malware itself. If this is the case, you will see the malware likely using <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> to resolve its imports <i>after</i> the unpacking process has completed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-272"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Transferring Execution to the OEP</samp></h4>&#13;
<p class="TNI1">Finally, once the malware is unpacked and the IAT is rebuilt, the unpacking stub must transfer execution from its own code to the OEP of the executable. The OEP is where the unpacked malware payload will begin executing its code. This transfer of execution, often called the <i>tail jump</i> or <i>tailing jump</i>, usually appears in the form of a jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>), return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>), or <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction at the end of the unpacking stub. Once this instruction is hit, the program control will be transferred to the unpacked code in memory, and the unpacked malware payload will finally run.</p>&#13;
<p class="TX">Many packers, especially ones designed specifically for malware packing, implement some form of code injection technique to try to bypass defenses and hide on the host. For example, a packer might allocate memory inside an arbitrary or specific process on the victim host, write its unpacked code into that memory, and transfer execution to this code. In this case, you’ll likely spot some of the process injection techniques and related functions covered in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>. This is an important point to remember, and we’ll come back to it later in the chapter.</p>&#13;
<p class="TX">Next, let’s take a look at how to identify whether malware is packed.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h-273"/><samp class="SANS_Futura_Std_Bold_B_11">How to Identify Packed Malware</samp></h3>&#13;
<p class="TNI1">Before you begin to unpack a malware sample, you have to identify whether it’s even packed to begin with. There are a few ways to do so.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-274"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Viewing Imports</samp></h4>&#13;
<p class="TNI1">One of the simplest and most effective ways of determining whether a sample is packed is to inspect the file’s imports. You can do this with almost any PE file viewer tool, such as CFF Explorer, PEStudio, and PE-bear. Packed malware may have only a few imported libraries and functions. The screenshot from PEStudio in <a href="chapter17.xhtml#fig17-5">Figure 17-5</a> illustrates what packed malware might look like.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_351" aria-label="351"/>&#13;
<figure class="IMG"><img class="img100" id="fig17-5" src="../images/fig17-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-5: Viewing a packed malware sample in PEStudio</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice how there’s only a limited subset of functions listed, two of which are <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibraryA</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>. By comparison, in <a href="chapter17.xhtml#fig17-6">Figure 17-6</a> you can see an unpacked malware sample’s list of imports.</p>&#13;
<figure class="IMG"><img class="img80" id="fig17-6" src="../images/fig17-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-6: Viewing an unpacked malware sample in PEStudio</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_352" aria-label="352"/>Clearly, the malware sample in <a href="chapter17.xhtml#fig17-6">Figure 17-6</a> has more imports. Again, if malware has only a limited list of imports, there’s a good chance that it is packed.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h-275"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Inspecting Strings</samp></h4>&#13;
<p class="TNI1">Another good way to determine whether a sample is packed is to inspect its strings. Packed malware will have either many strings that aren’t human readable or hardly any strings at all. This is because during the packing process, the packer compresses, encrypts, or otherwise obfuscates the data in the file to make analysis more difficult and to bypass defenses. The screenshot from PEStudio in <a href="chapter17.xhtml#fig17-7">Figure 17-7</a> shows what packed malware’s strings might look like.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-7" src="../images/fig17-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-7: Strings from a packed malware sample</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In contrast, an unpacked sample should have many cleartext (deobfuscated) strings.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-276"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Calculating the Entropy Value</samp></h4>&#13;
<p class="TNI1">Packed malware will likely have a high entropy value. <i>Entropy</i> is the measurement of randomness in data. High entropy indicates that the data may be encrypted or compressed, and in the context of packing, it suggests that a sample is likely packed. The maximum possible entropy value is 8; the closer the file gets to this value, the more likely that it is packed.</p>&#13;
<p class="TX">There are many tools that can calculate the entropy of a malware executable, but I’ve used PEStudio as an example once again. <a href="chapter17.xhtml#fig17-8">Figure 17-8</a> illustrates the entropy value of a packed malware sample.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-8" src="../images/fig17-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-8: Viewing a packed malware entropy value in PEStudio</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_353" aria-label="353"/>A good rule of thumb is that a packed executable file will have an entropy value of about 6 or higher. Anything lower than this, and the chances that the file is packed decrease.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Keep in mind that some non-PE files (such as document files) will always have a high entropy value, so the “6 or higher” rule of thumb applies only to PE files.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-277"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Checking PE Sections</samp></h4>&#13;
<p class="TNI1">You can also use the PE file section information to determine whether malware is packed. As you may remember from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, executable files have multiple sections called <i>.text</i>, <i>.data</i>, <i>.rdata</i>, .<i>rsrc</i>, and so on. In a normal, nonpacked executable, the sections will be labeled with these names. Sometimes packers rename these sections in the file in a way that identifies the packer. For example, the UPX packer renames them to <i>UPX0</i>, <i>UPX1</i>, and so on. Another anomaly of packed malware is that it often has too many or not enough sections. A normal, nonpacked executable typically has four sections (give or take a few), so a file with nine sections or only one or two sections is a possible red flag and should be investigated further.</p>&#13;
<p class="TX">There are many different tools that allow you to view PE file section information. In <a href="chapter17.xhtml#fig17-9">Figure 17-9</a>, I’ve used PE-bear to show what a packed malware sample may look like.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-9" src="../images/fig17-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-9: Viewing a packed malware sample’s PE sections in PE-bear</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The file in this figure has only two sections. One is completely unlabeled, and the other is called <i>petite</i>, which is a nonstandard executable section name. This file is likely packed, possibly using the Petite packer.</p>&#13;
<p class="TX">Lastly, a PE file’s section sizes can be another great indicator of packing. Each section has two size characteristics: the raw size and the virtual size. The PE file’s <i>raw size</i> is the size of the section on disk, and the <i>virtual size</i> is the size once it is executed and subsequently mapped to memory. If you spot a malware sample that has a raw size of zero and a virtual size of nonzero, this is a good indication that the malware is packed. In this case, the malware may be trying to hide its code in another section, for example.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-278"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Using Automated Packer Detection</samp></h4>&#13;
<p class="TNI1">Finally, the simplest method of determining whether or not a malware sample is packed is using an automated packer detection tool. There are several of these tools available, but my personal favorites are Detect It Easy (DIE), Exeinfo PE, PE Detective, and CFF Explorer. These tools provide <span role="doc-pagebreak" epub:type="pagebreak" id="pg_354" aria-label="354"/>information such as the file’s entropy, section names and sizes, compiler data, and sometimes (in the best case) the name of the packer itself.</p>&#13;
<p class="TX">Exeinfo PE, for example, attempts to identify the packer variant using static signatures. In <a href="chapter17.xhtml#fig17-10">Figure 17-10</a>, you can see Exeinfo PE in action: it has identified that this malware sample is possibly written in .NET and potentially packed with the DeepSea obfuscator.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-10" src="../images/fig17-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-10: Identifying a malware’s packer in Exeinfo PE</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">While automated packer detectors like Exeinfo PE are not always 100 percent accurate, using them is a great first step in inspecting malware executable files, and they can provide vital tips to guide your analysis and unpacking process. It’s always best to try a few of these tools and see which provides the best output for the malware sample you are inspecting.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Many of these tools update their detection databases regularly, so be sure to install any updates for these tools to ensure that you’re getting accurate results.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-279"/><samp class="SANS_Futura_Std_Bold_B_11">Automated Unpacking</samp></h3>&#13;
<p class="TNI1">Once you’ve identified that the malware sample is indeed packed, you can start thinking of ways to unpack it. You may be asking yourself, <i>Why should I unpack the malware sample? Can’t I simply run it and analyze it as is?</i> It’s always an option to simply run the malware in a sandbox or debugger and avoid unpacking entirely; in fact, I’ll specifically address that in <span class="Xref">“Analyzing Without Unpacking”</span> on <span class="Xref"><a href="chapter17.xhtml#pg_383">page 383</a></span>. However, unpacking allows you to get to the heart of the malware and extract its payload, which is often necessary for you to fully understand the malware’s capabilities and statically analyze its code.</p>&#13;
<p class="TX">While you can still understand a malware’s behaviors without unpacking it, you may lose some nuance. An example is a malware sample that has <span role="doc-pagebreak" epub:type="pagebreak" id="pg_355" aria-label="355"/>hidden capabilities or acts differently depending on its analysis environment. In the context of evasive malware, for example, this could mean that the malware behaves differently in an automated malware sandbox. Without unpacking this malware and closely analyzing its code, you might miss some key behaviors, capabilities, and indicators. There are multiple ways to unpack a malware sample, including fully automated unpacking, sandbox-assisted unpacking, manual dynamic unpacking, and static unpacking. We’ll begin in this section with fully automated unpacking and sandbox-assisted unpacking, then dig into the other methods in the coming sections.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h-280"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Fully Automated Unpacking</samp></h4>&#13;
<p class="TNI1"><i>Fully automated unpacking</i> is the simplest and fastest method of unpacking a malware sample, so it’s always a good idea to try it first. Many general and common packers have either built-in capabilities for unpacking or automated unpackers written specifically for them. The UPX packing program contains a flag that allows files to be unpacked as well. Simply passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> parameter to UPX like so will unpack the file:</p>&#13;
<pre class="pre-184"><code>C:\&gt; <b>upx.exe -d</b> <b><var>file.exe</var></b></code></pre>&#13;
<p class="TX">Other tools include Un{i}packer, which uses code emulation to unpack many common packers (such as MPRESS, ASPack, and, of course, UPX), and Universal Extractor 2 (UniExtract2), which can unpack many common packers and compressed file archives. You should first try to identify the packer being used; employ the techniques you’ve seen so far and then test out some of these helpful automated tools.</p>&#13;
<p class="TX">One important thing to remember is that common packers like the ones just mentioned can be modified by malware authors, since many of them are open source. It’s relatively simple to modify these packers to prevent unpacking with these fully automated methods. Also keep in mind that advanced malware generally won’t be packed (or, at least, won’t be solely packed) with free and common packers, so make sure not to rely only on these automated tools. As you’ll soon see, there are many other tools that can assist you in both automated and semiautomated unpacking.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h-281"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sandbox-Assisted Unpacking</samp></h4>&#13;
<p class="TNI1">The next-simplest way to unpack a sample is to use a malware analysis sandbox. Many malware sandboxes can automate malware unpacking, typically by detecting malicious code in memory, hooking and monitoring key Windows functions often invoked during the malware-unpacking process, and automating the extraction of executable code from memory. One sandbox that does this fairly well is the commercial sandbox VMRay Analyzer. In the output shown in <a href="chapter17.xhtml#fig17-11">Figure 17-11</a>, you can see that VMRay Analyzer was able to extract the malware from memory in its various stages of unpacking.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_356" aria-label="356"/>&#13;
<figure class="IMG"><img class="img100" id="fig17-11" src="../images/fig17-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-11: Viewing malware executable code dumped from memory in the VMRay Analyzer sandbox</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this screenshot you can see how VMRay Analyzer has attempted to unpack the sample by dumping the malware’s memory at key stages of its behavior. For example, as you can see in the Dump Reason column, the malicious code is dumped from memory when its content is changed, when it is first executed, and when there is an executable file (image) in memory. VMRay Analyzer has also attempted to rebuild the PE headers of the dumped executable file so that it can be better analyzed in a disassembler or debugger.</p>&#13;
<p class="TX">There’s even a sandbox dedicated solely to unpacking: UnpacMe. According to its author, “UnpacMe automates the first step in your malware analysis process.” That is, it automates the unpacking process. UnpacMe is a commercial sandbox but (at the time of this writing) offers a free service with limited submissions per month. <a href="chapter17.xhtml#fig17-12">Figure 17-12</a> shows an example submission to UnpacMe and the resulting unpacked, downloadable payload files.</p>&#13;
<figure class="IMG"><img class="img80" id="fig17-12" src="../images/fig17-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-12: A malware sample unpacked by UnpacMe</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_357" aria-label="357"/>Sometimes malware sandboxes fail to successfully unpack the malware’s payload. There are a number of reasons for this, such as evasive behaviors by the malware or failure to follow the malware’s unpacking process in memory. Let’s look at some manual unpacking techniques that will help you in the event that these automated techniques fail.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h-282"/><samp class="SANS_Futura_Std_Bold_B_11">Manual Dynamic Unpacking</samp></h3>&#13;
<p class="TNI1">Manual unpacking involves identifying where the unpacking routine is located in the packed malware’s code, determining how it is unpacking the malware, and following this unpacking process to “catch” the malware’s payload in a freshly unpacked state. There are two forms of manual unpacking: dynamic and static.</p>&#13;
<p class="TX"><i>Manual dynamic unpacking</i> involves detonating the malware in a virtual machine environment and allowing the malware to execute and unpack as it normally would on a victim host, while using a debugger to follow the unpacking process and catch the unpacked payload in memory. By contrast, <i>static unpacking</i> involves reverse engineering the malware’s unpacking stub code, re-creating this code logic, and running it on the packed malware. This section will focus on dynamic packing, and we’ll discuss static unpacking in <span class="Xref">“Manual Static Unpacking”</span> on <span class="Xref"><a href="chapter17.xhtml#pg_382">page 382</a></span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Rather than providing very specific techniques for unpacking certain packers, I’ll be covering more generic methods that you can use to dynamically unpack many variants of malware, regardless of the packer used. These techniques are not presented in any particular order; every packer behaves differently, so there’s no one-size-fits-all technique. You may need to try different techniques or combine bits and pieces from several of them. This is what makes unpacking so challenging but also very rewarding!</i></p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h-283"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">The Quick-and-Dirty Option: Letting the Malware Do the Work</samp></h4>&#13;
<p class="TNI1">When packed malware runs on the victim host, it must unpack itself somewhere in memory. Detonating the malware in a virtual machine, letting the malware do the work of unpacking itself, and then extracting the unpacked code is one of the simplest forms of dynamic unpacking. You can attempt this first before delving into the more difficult unpacking techniques in this section.</p>&#13;
<p class="TX">Dumping a process from memory is fairly straightforward and can be done simply with Process Hacker or Process Explorer, as well as with other advanced task manager–type tools. In Process Hacker, you right-click the malware’s running process and select <b>Create Dump File</b>, as shown in <a href="chapter17.xhtml#fig17-13">Figure 17-13</a> with the <i>sample.exe</i> process.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_358" aria-label="358"/>&#13;
<figure class="IMG"><img class="img70" id="fig17-13" src="../images/fig17-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-13: Extracting malware from memory using Process Hacker</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This is a quick-and-dirty unpacking method, and it has some limitations. First, there’s no way of knowing if the malware completely unpacked itself in memory yet. For example, evasive malware may detect the VM environment and refuse to unpack its payload. Not only that, but since this file was extracted directly from memory, it also hasn’t been properly unmapped from memory and will be misaligned, which means that you likely won’t be able to easily analyze it in a disassembler like IDA Pro. You can, however, inspect the strings of the file by running the Strings tool (or a tool such as PEStudio), which will give you hints about what this malware sample may be doing. You may even spot cleartext functions, C2 addresses, or decrypted data. There’s a better option, however.</p>&#13;
<p class="TX">The tool Scylla allows you to extract this malware from memory and will automatically realign the file, fix the file headers, and even repair the IAT. Scylla is both a plug-in for x64dbg and a stand-alone tool, and it works exactly the same in both capacities. For example, say you have a malware sample, and after transferring it to your analysis VM, you detonate it. The sample may not immediately unpack itself into memory, so you choose to wait a minute or so to ensure the sample has completely unpacked itself. Next, you can run the Scylla tool, as shown in <a href="chapter17.xhtml#fig17-14">Figure 17-14</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_359" aria-label="359"/>&#13;
<figure class="IMG"><img class="img70" id="fig17-14" src="../images/fig17-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-14: Malware process dumping with Scylla</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Scylla allows you to select a target process in which to dump; this would normally be the malware’s active process (<i>sample.exe</i> in this case). You can then click <b>IAT Autosearch</b> to automatically search the process memory for a possible IAT. Once the IAT has been found, click <b>Get Imports</b> to generate a list of imports that will populate the IAT once the process has been dumped. Next, clicking <b>Dump</b> will dump the process from memory to disk into an executable file, which essentially unmaps the process from memory.</p>&#13;
<p class="TX">Most advanced malware won’t allow itself to be unpacked so cleanly. However, since this technique takes less than five minutes, it’s always worth a shot. Now let’s dig into some more advanced unpacking techniques.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h-284"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Memory Operation Monitoring</samp></h4>&#13;
<p class="TNI1">Since the unpacking stub must allocate memory for the newly unpacked executable and modify its memory protections, we can assume that at some point, it will invoke Windows functions related to memory operations. The idea here is to set breakpoints in the debugger on these memory operation functions, run the malware, and closely monitor these operations, looking for an opportunity to dump the malware’s unpacked code.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">VirtualAlloc</samp></h5>&#13;
<p class="TNI1"><samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> is likely the most common memory allocation function you’ll see, but <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> are also used. You can simply attach the packed malware sample to a debugger such as x64bdg, set a breakpoint on <span role="doc-pagebreak" epub:type="pagebreak" id="pg_360" aria-label="360"/>the memory allocation function you’d like to target (or set breakpoints on all of them), and run the malware sample. Once a memory allocation function breakpoint is hit, you must identify the base address of the newly created memory region and watch this memory region for new data. Let’s see how this works in practice.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To follow along with this example, you can find the required malware file on VirusTotal or MalShare at the following hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: 7b8fc6e62ef39770587a056af9709cb38f052aad5d815f808346494b7a3d00c5</p>&#13;
</blockquote>&#13;
<p class="TX">Load the executable (which I’ve renamed in <a href="chapter17.xhtml#fig17-15">Figure 17-15</a> to <i>badthing.exe</i>) into x64dbg and execute the <b>Run to User Code</b> function in the Debug menu, which brings you to the entry point of the malware’s code.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-15" src="../images/fig17-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-15: The malware’s entry point in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Next, place a breakpoint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> function (<samp class="SANS_TheSansMonoCd_W5Regular_11">bp VirtualAlloc</samp>), as shown in <a href="chapter17.xhtml#fig17-16">Figure 17-16</a>. What we’re hoping for here is that the unpacked executable will eventually be mapped to this region of memory.</p>&#13;
<figure class="IMG"><img class="img60" id="fig17-16" src="../images/fig17-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-16: Setting a breakpoint on VirtualAlloc</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Following this, continue to run the malware (by pressing F9) until this breakpoint is hit (see <a href="chapter17.xhtml#fig17-17">Figure 17-17</a>).</p>&#13;
<figure class="IMG"><img class="img60" id="fig17-17" src="../images/fig17-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-17: Hitting the breakpoint on VirtualAlloc</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Once the breakpoint is hit, you can execute the malware until the function returns; select <b>Debug</b><span class="MenuArrow"></span><b>Execute Till Return</b> and then check the value of the EAX register, which contains the target memory region that was allocated by <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> (see <a href="chapter17.xhtml#fig17-18">Figure 17-18</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_361" aria-label="361"/>&#13;
<figure class="IMG"><img class="img50" id="fig17-18" src="../images/fig17-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-18: A newly allocated memory region in EAX</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In my case, this memory region’s base address is <samp class="SANS_TheSansMonoCd_W5Regular_11">000F0000</samp>. Right-click on this value in EAX and select <b>Follow in Dump</b>. You should see an empty memory region in the Dump window (see <a href="chapter17.xhtml#fig17-19">Figure 17-19</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-19" src="../images/fig17-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-19: A fresh memory region in the x64dbg Dump window</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you continue to press F9 to run the code while watching this Dump window, you might see something of interest, such as an <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp> header, which could be the malware’s unpacked payload (see <a href="chapter17.xhtml#fig17-20">Figure 17-20</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-20" src="../images/fig17-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-20: Viewing the unpacked code in allocated memory</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can extract this file from memory by selecting the start of the header (starting at the <samp class="SANS_TheSansMonoCd_W5Regular_11">M</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>) and the rest of this memory region in the dump view, right-clicking, and selecting <b>Binary</b><span class="MenuArrow"></span><b>Save to File</b>. You can then inspect this file in a PE file viewer tool, looking for signs of successful unpacking, such as cleartext strings and imports.</p>&#13;
<p class="TX">Keep in mind that the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp> functions subsequently call the lower-level API function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>. Sneaky malware might invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> directly instead of using <span role="doc-pagebreak" epub:type="pagebreak" id="pg_362" aria-label="362"/><samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>. Setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> can help in these situations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h5 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">HeapAlloc and Malloc</samp></h5>&#13;
<p class="TNI1">Malware will sometimes call <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> when allocating memory. <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp> differs from <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> in two ways: it allocates memory on the program’s heap rather than the stack, and it’s a higher-level API call and will sometimes subsequently invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>. Because of this, it’s more common to put a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, but you can try setting a <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp> breakpoint as well.</p>&#13;
<p class="TX">The C function <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> also allocates memory similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>. In fact, <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> typically invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>, or in some cases, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>. It’s not as common to see malware calling <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>, but it might if it’s written in C or if it’s trying to evade analysis or hide its activities, since <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> may get less attention from analysts. Setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> can be useful in these scenarios.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Memory Deallocation</samp></h5>&#13;
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualFree</samp> (as well as its sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualFreeEx</samp>) and <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapFree</samp> functions are used by Windows to release and free a memory region after it has been used. During the malware’s unpacking process, once the malware allocates memory for its unpacked code and executes it, it will likely need to clean up afterward. Similarly to setting a debugger breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>, setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualFree</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualFreeEx</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapFree</samp> can be a good tactic for catching unpacked malicious code before it has a chance to deallocate its memory. You may get lucky and spot an unpacked executable in one of these memory regions that can then be extracted for further analysis.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">VirtualProtect</samp></h5>&#13;
<p class="TNI1"><samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> and its sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtectEx</samp>, are also functions that can be monitored for unpacked code. During the unpacking phase, after the malware allocates memory, it must set protections on the memory. The memory’s protection represents what the malware is able to do with that memory region: write to it, read from it, execute it, or all of these. The memory protection option is passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> function as a parameter when the function is called, as shown in IDA Pro in <a href="chapter17.xhtml#fig17-21">Figure 17-21</a>.</p>&#13;
<figure class="IMG"><img class="img60" id="fig17-21" src="../images/fig17-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-21: Malware calling VirtualProtect, viewed in IDA Pro</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_363" aria-label="363"/>In this screenshot, the <samp class="SANS_TheSansMonoCd_W5Regular_11">flNewProtect</samp> parameter represents the new protection (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x40</samp>, which is PAGE_EXECUTE_READWRITE) that will be applied to the memory region (referenced in <samp class="SANS_TheSansMonoCd_W5Regular_11">lpAddress</samp>). Also important is the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwSize</samp> parameter, which represents the size of the memory region that will have the new protection class.</p>&#13;
<p class="TX">Setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtectEx</samp> and watching for memory regions being marked as executable can help you catch malicious code that will soon be executed by the malware. Oftentimes, the malware’s unpacked code resides in one of these memory regions. This area of code can then be dumped from memory for further analysis.</p>&#13;
<p class="TX"><a href="chapter17.xhtml#tab17-1">Table 17-1</a> lists some of the important memory protection constants.</p>&#13;
<p class="TT" id="tab17-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 17-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Memory Protection Constants</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Constant (hex)</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Constant value</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x10</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">This memory region will now be execut</samp><samp class="SANS_Futura_Std_Book_11">able only (writes and reads will result in an access violation error).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x20</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE_READ</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">This memory region will now be executable and readable, but not writable.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0x40</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE_READWRITE</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">This memory region will now be execut</samp><samp class="SANS_Futura_Std_Book_11">able, readable, and writable.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You can read about these and others in the “Memory Protection Constants” page in Microsoft’s documentation at <a href="https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants"><i>https://<wbr/>learn<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/windows<wbr/>/win32<wbr/>/memory<wbr/>/memory<wbr/>-protection<wbr/>-constants</i></a>.</p>&#13;
<p class="TX">It’s important to note that <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtectEx</samp> subsequently call the lower-level API function <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>. Sometimes tricky malware samples may call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp> directly, bypassing the normal <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> call, thus circumventing malware analysts who may only be on the lookout for <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>. In these cases, it can be helpful to simply put a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>.</p>&#13;
<p class="TX">When using breakpoints on <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>-like functions, it can be helpful to set hardware breakpoints on the memory region being modified rather than software breakpoints. As <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span> discussed, hardware breakpoints are more persistent, so evasive malware will have a tougher time removing them to circumvent analysis. I’ll come back to this in <span class="Xref">“Hardware Breakpoints on Allocated Memory”</span> on <span class="Xref"><a href="chapter17.xhtml#pg_365">page 365</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Memory Inspection During Runtime</samp></h5>&#13;
<p class="TNI1">Another useful general technique for unpacking malware is inspecting memory regions within the debugger, looking specifically for regions that are assigned executable protections. Such regions can indicate the presence of executable code. To do this in a debugger (in my case, x64dbg), select <b>Memory Map</b> near the top of the debugger window. The result should look similar to <a href="chapter17.xhtml#fig17-22">Figure 17-22</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_364" aria-label="364"/>&#13;
<figure class="IMG"><img class="img100" id="fig17-22" src="../images/fig17-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-22: Viewing a memory map in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This memory map shows a few memory regions that are marked as executable. You can sort this list simply by clicking on the <b>Protection</b> column header at the top. Once you spot one of these memory regions, you can dump it by right-clicking the memory address and selecting <b>Dump Memory to File</b>, or you can view it in the Dump window for closer inspection by selecting <b>Follow in Dump</b>. You can also view this memory region in the disassembler, which is helpful if you suspect the data contained in a memory region is code, for example. The debugger’s disassembler will also help you quickly see the disassembled code. To do this, right-click the memory address and select <b>Follow in Disassembler</b>.</p>&#13;
<p class="TX">Some key things to look for are as follows:</p>&#13;
<p class="ListHead"><b>Memory regions that have E (Executable) in the Protection column</b></p>&#13;
<p class="ListPlainFirst">This would indicate that there is executable code in this region. Regions with protection class ERW (Execute-Read-Write) should be prioritized; in many cases, malware that is about to execute its unpacked payload will assign ERW protection to this memory. Note that in some debuggers and memory editors, this protection class is called RWX (Read-Write-Executable).</p>&#13;
<p class="ListHead"><b>Regions with the PRV memory type</b></p>&#13;
<p class="ListPlainFirst">You can spot this in the Type column. PRV is a great candidate for finding unpacked code.</p>&#13;
<p class="ListHead"><b>Memory regions that have nothing in the Info and Content columns</b></p>&#13;
<p class="ListPlainFirst">If these fields are populated, it likely means that these memory regions are associated with the malware executable file itself (the packed version) and not its unpacked code. The memory region highlighted in <a href="chapter17.xhtml#fig17-22">Figure 17-22</a> is a prime candidate for closer inspection.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_365" aria-label="365"/><b>Large data size (indicated by the Size column)</b></p>&#13;
<p class="ListPlainFirst">A substantial memory region (for example, 30,000 bytes) could indicate an unpacked executable in memory. This is not always true, however, as smaller memory sections can contain small bits of malicious code such as shellcode.</p>&#13;
<p class="ListHead"><b>Any areas of memory that contain a PE header</b></p>&#13;
<p class="ListPlainFirst">It can be helpful to run a memory string scan for <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">This program</samp>. To do this in x64dbg, right-click in the Memory Map area and select <b>Find Pattern</b>. Then, input your desired search string (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">This program</samp>) in the ASCII text box and click <b>OK</b>. This will search all memory regions for your chosen ASCII string. If you find a PE header in one of these regions, you should closely inspect it, as it could be the malware’s unpacked payload (but take into account the next point).</p>&#13;
<p class="ListHead"><b>Addresses below the 0x7 range</b></p>&#13;
<p class="ListPlainFirst">Memory addresses that start with 0x7 (x77300000, for example) are usually associated with legitimate Windows DLLs that are mapped into the malware’s process address space, so you should focus less on this memory range. I say <i>usually</i> because malware can load malicious code into one of these regions, but it’s not as common. Focus your efforts on the addresses below the 0x7 range first. For 64-bit malware, this would be addresses below the range of 0x700000000000.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hardware Breakpoints on Allocated Memory</samp></h5>&#13;
<p class="TNI1">As discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, most modern debuggers offer both software and hardware breakpoint options. In most cases, software breakpoints will suffice (for example, for setting a breakpoint on a specific CPU instruction or API function call). However, hardware breakpoints are also useful for following a malware’s unpacking process, as they can be set directly on memory regions. When a malware sample calls a memory allocation function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, setting a hardware breakpoint on the newly allocated memory region can help catch the malware executing its unpacked code.</p>&#13;
<p class="TX">To do this in x64dbg, locate the memory region you’re interested in (for example, a newly allocated memory region created via <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>), view the memory in the Dump area, right-click, and select <b>Breakpoint</b><span class="MenuArrow"></span><b>Hardware, Write</b>. This effectively creates a persistent hardware breakpoint that will cause the malware program to pause when code or data is written to this memory region. Once code has been written to this region, you can set a <samp class="SANS_TheSansMonoCd_W5Regular_11">Hardware, Execute</samp> breakpoint to catch the malware executing it. Note that memory breakpoints can also be used here for the same purpose.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h5 class="H3" id="sec24"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Pitfalls of Following Memory Operations</samp></h5>&#13;
<p class="TNI1">Setting breakpoints on memory management functions can be an effective trick for following the malware unpacking process, but there are pitfalls. First, since these memory management functions are used often (both in legitimate and illegitimate circumstances), they can create a lot of noise. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_366" aria-label="366"/>It’s not uncommon to see thousands of memory management functions executed in a malware sample, so you may find that setting breakpoints on them will trigger constant pauses in your debugger execution, giving you too much to go through. In this case, coordinating your efforts with process creations and code injection is best, as will be covered in the sections that follow. Alternatively, you can simply switch up your tactics. For example, focus only on one memory operation function, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>, rather than all of the functions listed in this chapter.</p>&#13;
<p class="TX">Second, breakpoints on memory can trigger unintended consequences during the malware’s execution, usually in the form of exceptions and program crashes. Malware can take advantage of this by implementing special safeguards and evasion techniques in its code, as discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>; we’ll revisit this briefly toward the end of this chapter.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h-285"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Injection Monitoring</samp></h4>&#13;
<p class="TNI1">After unpacking their malicious code, malware packers must write this code into memory. This may involve writing it into its own process address space (self-injection) or injecting the code into a spawned child process or other victim process on the host. This is a critical part of how malware unpacks itself, and it’s important to keep an eye out for. As mentioned previously, detonating the malware sample in a sandbox is always a good first step, but this is even truer when you’re attempting to manually unpack the malware. Many sandboxes provide a great overview of how the malware is executing its process injection behaviors; such guidance will help you decide where to set breakpoints in the running malware sample while you’re dynamically unpacking it.</p>&#13;
<p class="TX">To illustrate this, <a href="chapter17.xhtml#fig17-23">Figure 17-23</a> shows the results of a suspect malware sample submitted to the Hybrid Analysis sandbox.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-23" src="../images/fig17-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-23: Malware sample behavior in the Hybrid Analysis sandbox</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can see that this malware sample is spawning a child process <i>svchost.exe</i>, which appears to be executed from the path <i>C:\system32\svchost.exe</i>. This tells us that the malware sample may be unpacking its payload and injecting it into the legitimate <i>svchost.exe</i> Windows executable from the <i>system32</i> directory. If we wanted to unpack this malware sample manually by using a debugger, a good first step would be to set breakpoints on functions we predict would be invoked for this injection technique. For example, the malware would probably call <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessInternal</samp> in order to execute the <i>svchost.exe</i> process. Next, it may invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> to write the malicious code into the target process. And finally, in order to execute the malicious code in the context of <i>svchost.exe</i>, the malware may call a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp>. Setting breakpoints on each of these <span role="doc-pagebreak" epub:type="pagebreak" id="pg_367" aria-label="367"/>functions could help you catch the malware’s payload in an unpacked state and extract it from memory for further analysis. All of these functions were described in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>, so they shouldn’t be completely new to you. Let’s see what injection-based unpacking looks like in practice.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To follow along with this example, you can find the required malware file on VirusTotal or MalShare using the following hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: cfb959cc29e728cd0dc6d6f45bcd893fc91cad6f465720d63c5143001e63e705</p>&#13;
</blockquote>&#13;
<p class="TX">The malware sample we’re investigating, a variant of the Ryuk ransomware family, is using a process injection technique that involves getting a handle to a process (<samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>), allocating memory within that process (<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>), writing its unpacked code into the victim process (<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>), and finally executing this malicious code (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>). <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> is a great function to investigate when you’re unpacking malware because the code is fully unpacked at this point and about to be executed.</p>&#13;
<p class="TX">Load the malware sample into your debugger of choice (x64dbg, in my case) and set a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>. Next, run the malware to hit the breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>, as shown in <a href="chapter17.xhtml#fig17-24">Figure 17-24</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-24" src="../images/fig17-24.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-24: Malware calling CreateRemoteThread for process injection</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> takes a few arguments, one of which is a handle to the process the malicious code was written to; this process is the one about to be executed. Since this malware sample is a 64-bit sample, this parameter for the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp> function is in the RCX register (see <a href="chapter17.xhtml#fig17-25">Figure 17-25</a>). If this were a 32-bit sample, this value would be on the stack.</p>&#13;
<figure class="IMG"><img class="img70" id="fig17-25" src="../images/fig17-25.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-25: Investigating 64-bit CPU registers</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In my case, this handle value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1A8</samp>. Cross-referencing this with the list of handles in the Handles tab of x64dbg, we can see that it is associated with process ID <samp class="SANS_TheSansMonoCd_W5Regular_11">2924</samp>, which, on my VM, is the system process <i>sihost.exe</i> (see <a href="chapter17.xhtml#fig17-26">Figure 17-26</a>). Note that you may need to refresh the data in the handles tab by pressing F5.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_368" aria-label="368"/>&#13;
<figure class="IMG"><img class="img100" id="fig17-26" src="../images/fig17-26.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-26: A list of handles in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To find the injected unpacked malicious code that’s about to be executed, you need to locate the memory region where this code resides in the <i>sihost.exe</i> process. To do so, start another debugger instance and then attach to this process by selecting <b>File</b><span class="MenuArrow"></span><b>Attach</b> and choosing <b>sihost.exe</b> from the process list.</p>&#13;
<p class="TX">After attaching this process, you can use the Memory Map tab to locate the suspect region of memory. This suspect memory region will have ERW (Execute-Read-Write) protection and will be a private (PRV) memory region. <a href="chapter17.xhtml#fig17-27">Figure 17-27</a> shows a screenshot of the suspect memory region.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-27" src="../images/fig17-27.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-27: Suspected injected code in the memory map</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To verify whether this memory region contains an unpacked executable, right-click it and select <b>Follow in Dump</b>. <a href="chapter17.xhtml#fig17-28">Figure 17-28</a> shows that this memory region contains executable code!</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-28" src="../images/fig17-28.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-28: The unpacked executable in memory</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now, to confirm that this is indeed unpacked malicious code, let’s dump this code to disk (in the Memory Map tab, right-click the target memory region and select <b>Dump Memory to File</b>) and open the file in a PE viewer such as PEStudio. As <a href="chapter17.xhtml#fig17-29">Figure 17-29</a> shows, the Strings tab in PEStudio reveals some interesting things.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_369" aria-label="369"/>&#13;
<figure class="IMG"><img class="img100" id="fig17-29" src="../images/fig17-29.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-29: Viewing strings from the unpacked code in PEStudio</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Some of the incriminating strings include commands (specifically, <i>cmd.exe</i> commands that attempt to delete backup files from the host) and registry keys that may be related to establishing persistence on the host (<samp class="SANS_TheSansMonoCd_W5Regular_11">/C REG...</samp> ). When we compare these strings to the original malware sample file, we can see drastic differences (see <a href="chapter17.xhtml#fig17-30">Figure 17-30</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-30" src="../images/fig17-30.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-30: Strings from the original, packed malware</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Can you spot the differences in <a href="chapter17.xhtml#fig17-30">Figure 17-30</a>? Many of the strings from the unpacked code are missing. As you can see, comparing the strings in the unpacked file with those in the original packed malware file can be an effective way to confirm that the malware was successfully unpacked.</p>&#13;
<p class="TX">Simply viewing strings has its limits, however. To further analyze the unpacked code, such as in a disassembler, we’d likely need to repair and realign the dumped code, which we’ll cover shortly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h-286"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Process Injection Tracing with API Monitor</samp></h4>&#13;
<p class="TNI1">Tracing, which was introduced in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, is an effective technique not only for spying on malware’s function calls but also for unpacking malware. <a href="chapter17.xhtml#fig17-31">Figure 17-31</a> shows a malware sample in API Monitor. You can see the malware sample executing a process injection technique and using several functions you’ve seen in this chapter.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_370" aria-label="370"/>&#13;
<figure class="IMG"><img class="img100" id="fig17-31" src="../images/fig17-31.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-31: Viewing process injection in API Monitor</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">After creating a new process (<samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessA</samp>) and allocating a new memory region in this process (<samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAllocEx</samp>), the malware sample uses <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> to write code into this new memory region (see <a href="chapter17.xhtml#fig17-32">Figure 17-32</a>). Selecting the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> function in API Monitor and inspecting the Hex Buffer window reveals something interesting: an <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp> header! This <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp> header tells us that the malware wrote an executable to memory, and this can be copied and dumped from API Monitor.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-32" src="../images/fig17-32.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-32: Viewing WriteProcessMemory process injection in API Monitor</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">API tracing tools like API Monitor are excellent additions to your toolbox for following process injection and catching malware in the unpacking process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h-287"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Library Loading and Address Resolution</samp></h4>&#13;
<p class="TNI1">Earlier you learned that the packer’s unpacking stub will likely use functions like <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> to dynamically resolve the malware’s required functions. Because these functions are called before the malware can execute its malicious behaviors, <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> are great starting points for getting to the unpacked malware payload.</p>&#13;
<p class="TX">When you have the packed executable file loaded in a debugger, simply place a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> and run the code by pressing F9. Optionally, place a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> only, and you can skip all of the <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> operations. The first breakpoint to be hit will likely be <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>, which is responsible for importing the respective DLL library, and then <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp> will get the address of the specific function exports from this DLL that the malware wishes to execute. If you continue to run the program until all function addresses have been resolved, this may be the point at which the malware is unpacked in memory and ready to start executing its malicious payload and functionalities.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_371" aria-label="371"/>From here, you can either dump the process from memory (which hopefully contains the unpacked executable) or try to locate the OEP.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h-288"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">OEP Location</samp></h4>&#13;
<p class="TNI1">Since all packers eventually transfer control flow to the malware’s OEP after unpacking its payload, locating this OEP is one of the best and cleanest methods of unpacking. By “cleanest,” I mean that dumping the unpacked malware at the OEP often results in an executable that most resembles the original, prepacked malware sample. Let’s dig into how you can find the OEP.</p>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3" id="sec29"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locating the Decryption Routine</samp></h5>&#13;
<p class="TNI1">First, to better understand the unpacking procedure that the malware will go through once executed, it’s helpful to know how to locate decryption and decompression routines in the packed sample. <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span> described how to locate decryption routines in malware, and the process is mostly the same with packers. You can locate these routines in a debugger while debugging the packed sample or in a disassembler such as IDA Pro.</p>&#13;
<p class="TX">There are a few key indicators of possible decryption and decompression routines. First, there will likely be shift-related assembly instructions that are executed repeatedly, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>, and so on. You might also see many mathematical instructions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">mul</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>. Finally, there will be looping, which indicates multiple iterations of decryption or decompression. Here’s an example of what an unpacking routine in an unpacking stub may look like:</p>&#13;
<pre class="pre-187"><code><var>--snip--</var>&#13;
movzx  edx, byte ptr [ecx]&#13;
shr    edx, 2&#13;
shl    esi, 6&#13;
lea    esi, [edx+esi+701h]&#13;
mov    edi, eax&#13;
sub    edi, esi&#13;
mov    dl, [edi]&#13;
mov    [eax], dl&#13;
mov    dl, [edi+1]&#13;
mov    [eax+1], dl&#13;
mov    dl, [edi+2]&#13;
inc    ecx&#13;
mov    [eax+2], dl&#13;
add    eax, 3&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">In this malware sample code, you may have spotted the <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> instructions, which all hint that this code block is modifying data. Also notice the move instructions (<samp class="SANS_TheSansMonoCd_W5Regular_11">movzx</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>), which indicate that the code is shifting data around. Given these indicators, you can assume that this block of code may be loading encrypted (packed) data and decrypting (unpacking) it. But to be certain, locate the tailing jump, which we’ll talk about now.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_372" aria-label="372"/>&#13;
<h5 class="H3" id="sec30"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding the Tailing Jump</samp></h5>&#13;
<p class="TNI1">The tailing jump, as mentioned earlier in the chapter, occurs at the end of the unpacking stub and directs the malware’s control flow to the newly unpacked code (more specifically, the OEP). Locating the tailing jump instruction can help you identify where the unpacked code will begin execution and is a good technique to use during the unpacking process. Since the tailing jump will be at the end of the unpacking procedure, it will likely come directly after the decompression and decryption routines you’ve just identified. Locating the tailing jump is easiest with a disassembler like IDA Pro. It should look something like <a href="chapter17.xhtml#fig17-33">Figure 17-33</a>.</p>&#13;
<figure class="IMG"><img class="img60" id="fig17-33" src="../images/fig17-33.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-33: The packed malware’s tailing jump in IDA Pro</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this screenshot, there are three arrows at the top of the code block, which means that other code blocks in the unpacking routine are jumping to this one. There is also a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction, followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> instruction. Both of these instructions reference dynamic locations (notice the CPU registers) rather than a static address, which is another good sign that one of these is the tailing jump. Since the malware could execute a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> instruction, though, which one is actually the tailing jump? To answer this, you’d probably have to throw this sample into a debugger and set breakpoints on the addresses of these instructions to see what happens, or spend more time statically analyzing the unpacking stub’s code. One of them leads to the OEP, the point at which the malware is unpacked and begins to execute its payload code.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You may have noticed <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sp-analysis failed</samp> in the highlighted last line of the code in <a href="chapter17.xhtml#fig17-33">Figure 17-33</a>. This is IDA’s way of stating that it couldn’t disassemble the rest of this code, likely due to the fact that the rest of the code is dynamically resolved after unpacking and not available statically in the binary. This is another good indicator of packed code and the unpacking stub!</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_373" aria-label="373"/>&#13;
<h5 class="H3" id="sec31"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding the OEP Automatically</samp></h5>&#13;
<p class="TNI1">While the best method of locating the OEP is usually by first locating the tailing jump, there are also debugging tools and plug-ins that try to automatically locate the OEP in a sample. For example, OllyDbg (an older debugger that is still occasionally used by malware analysts and reverse engineers) has a built-in feature called SFX that may be useful in finding the unpacking routine and OEP. In OllyDbg, navigate to <b>Options</b><span class="MenuArrow"></span><b>Debugging Options</b><span class="MenuArrow"></span><b>SFX</b>, and you should see the options shown in <a href="chapter17.xhtml#fig17-34">Figure 17-34</a>.</p>&#13;
<figure class="IMG"><img class="img70" id="fig17-34" src="../images/fig17-34.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-34: Debugging options in OllyDbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Select either <b>Trace Real Entry Blockwise</b> or <b>Trace Real Entry Bytewise</b> and then run the executable. This tool will attempt to trace the unpacking code and break at the OEP.</p>&#13;
<p class="TX">Since tools for locating the OEP automatically are hit or miss, they likely won’t be effective on advanced malware and packers. However, they’re still options to keep in your toolbox and may save you some time and headaches.</p>&#13;
<p class="TX">Once you believe you’ve found the OEP (using any of the techniques discussed previously) and the sample is unpacked in memory, there are multiple ways of verifying that this is the true OEP and that the sample is fully unpacked. One approach is to inspect strings in memory. In x64dbg, simply right-click the mouse in the disassembler view and select <b>Search For</b><span class="MenuArrow"></span><b>Current Module</b><span class="MenuArrow"></span><b>String References</b>. An unpacked malware sample typically has human-readable strings loaded into memory that indicate some of its capabilities. If you see some suspect strings in memory, the sample (or at least parts of it) is now unpacked in memory. In this window, you can also use the search bar at the bottom of the screen to search for a specific string.</p>&#13;
<p class="TX">You can also search for specific strings or binary patterns in memory by right-clicking in the disassembler window and then selecting <span role="doc-pagebreak" epub:type="pagebreak" id="pg_374" aria-label="374"/><b>Search For</b><span class="MenuArrow"></span><b>Current Module</b><span class="MenuArrow"></span><b>Pattern</b>. This approach is useful if you know the malware has a certain capability that will be unpacked in memory. For example, if you know the malware will attempt to contact a C2 URL (such as <i>http://<wbr/>evil<wbr/>.com<wbr/>/c2<wbr/>.php</i>), you can specifically search for this pattern in the debugger; if it exists, the malware is likely unpacked or the string has otherwise been deobfuscated. Note that this could also mean simply that the string has been loaded onto the stack at this point in runtime.</p>&#13;
<p class="TX">Finally, you can inspect <i>intermodular calls</i>, the Windows API functions that the malware executes at some point, which may now be unpacked in memory. To do so, right-click in the disassembly view in x64dbg and select <b>Search For</b><span class="MenuArrow"></span><b>Current Module</b><span class="MenuArrow"></span><b>Intermodular Calls</b>. In an unpacked malware sample, there usually will be many interesting API functions listed here. Keep in mind, however, that some malware won’t reveal its intermodular calls and will further unpack and resolve the functions at a later time.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h-289"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unpacked Malware Extraction</samp></h4>&#13;
<p class="TNI1">When you believe the malware’s payload has been unpacked in memory, it’s a good time to dump the unpacked code. Dumping the unpacked executable from memory will allow you to analyze the malicious code in more detail, such as in a disassembler. You can do this at any point in the unpacking process, so you don’t necessarily need to have already located the OEP. However, finding the tailing jump and the subsequent control transfer to the OEP first is usually best. You also don’t have to extract the payload from memory in order to analyze it further; you can simply continue letting the malware run and analyze it in the debugger, as I’ll discuss later in the chapter.</p>&#13;
<p class="TX">There are a few ways to dump the malware’s unpacked payload from memory. One method is to use Scylla, and the steps are roughly the same as described earlier in the chapter. To launch Scylla in x64dbg, simply navigate to <b>Plugins</b><span class="MenuArrow"></span><b>Scylla</b>. Select the malware’s process, and in the OEP field, enter the OEP address if you’ve located it or leave this set to the default OEP. You can also click <b>IAT Autosearch</b> and <b>Get Imports</b> to try to automatically rebuild the IAT. Finally, click <b>Dump</b>. After dumping the unpacked payload, you may also need to use the PE Rebuild option to repair the executable file.</p>&#13;
<p class="TX">Alternatively, you can use OllyDumpEx, which is included with some packages of x64dbg or can be found here: <a href="https://github.com/x64dbg/x64dbg/wiki/Plugins"><i>https://<wbr/>github<wbr/>.com<wbr/>/x64dbg<wbr/>/x64dbg<wbr/>/wiki<wbr/>/Plugins</i></a>. OllyDumpEx allows more granularity and control but is a bit less user-friendly. To launch OllyDumpEx in x64dbg, navigate to <b>Plugins</b><span class="MenuArrow"></span><b>OllyDumpEx</b><span class="MenuArrow"></span><b>Dump Process</b>. OllyDumpEx allows you to select a process (module), a specific memory region, or a memory address to dump. Which option you use depends on how the sample has been unpacked and whether you’ve successfully found the OEP. If you’ve found the unpacked malware’s OEP, select the malware process module and click <b>Get EIP as OEP</b> and then <b>Dump</b>, as shown in <a href="chapter17.xhtml#fig17-35">Figure 17-35</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_375" aria-label="375"/>&#13;
<figure class="IMG"><img class="img70" id="fig17-35" src="../images/fig17-35.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-35: The OllyDumpEx plug-in in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Lastly, you can use the native x64dbg interface to save the suspect memory region to disk. Right-click the disassembler window and select <b>Follow in Memory Map</b>. Next, select the region of memory that contains the unpacked code, right-click it, and select <b>Dump Memory to File</b>.</p>&#13;
<p class="TX">In this case, the extracted memory will be in the form of binary data, usually saved as a <i>.bin</i> file. Running a strings utility (such as Strings or PE Viewer) on this extracted memory is always a good first step. Looking at the strings can provide clues about how to proceed with your analysis. If you load this file into a disassembler to view its code, however, you might be disappointed to find it needs some repairs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h-290"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unpacked Executable Repair</samp></h4>&#13;
<p class="TNI1">Once the unpacked payload has been dumped to disk, depending on how it was extracted, it may not be in a runnable state or cleanly analyzable in a disassembler. Common reasons for this are file misalignment, PE header corruption, or a broken IAT, all of which can also make static analysis of the executable problematic. Let’s look at how to fix these issues.</p>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h5 class="H3" id="sec34"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Automated Repair</samp></h5>&#13;
<p class="TNI1">Scylla will allow you to rebuild a broken executable dump file. After you dump the malware’s suspected unpacked payload from memory, launch Scylla (either the stand-alone version or the plug-in built into x64dbg), select the malware’s running process, enter the correct OEP (if you have identified it), and click <b>IAT Autosearch</b> and then <b>Get Imports</b>. You may get <span role="doc-pagebreak" epub:type="pagebreak" id="pg_376" aria-label="376"/>a message asking whether or not to use the advanced results. Select <b>No</b> for now. (Try the advanced results later if this method doesn’t work correctly.) Next, click <b>Fix Dump</b>, select your memory dump, and save the file. After inspecting the newly generated executable, if the PE headers are corrupted, you can also click <b>PE Rebuild</b> to rebuild the headers. There are other tools you could use to rebuild the IAT, such as Imports Fixer, ImpREC, and ChimpREC, but I have found Scylla to be one of the best for imports reconstruction. Feel free to test out these other tools if Scylla isn’t working in your specific situation.</p>&#13;
<p class="TX">Another one of my go-to tools for fixing unmapped (dumped) PE executables is PE Unmapper (<a href="https://github.com/hasherezade/pe_unmapper"><i>https://<wbr/>github<wbr/>.com<wbr/>/hasherezade<wbr/>/pe<wbr/>_unmapper</i></a>). This tool can help automate the process of unmapping an executable image from memory into a file and realigning the executable. Here’s an example of it in use:</p>&#13;
<pre class="pre-188"><code>C:\&gt; <b>pe_unmapper.exe dumped_executable.mem 0x13F630000 fixed_executable.exe</b></code></pre>&#13;
<p class="TX">To execute PE Unmapper, you point the tool (<samp class="SANS_TheSansMonoCd_W5Regular_11">pe_unmapper.exe</samp>) at your target memory image (<samp class="SANS_TheSansMonoCd_W5Regular_11">dumped_executable.mem</samp>, in this example), specify the base address of the image (where you dumped the image from memory; in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x13F630000</samp>), and then specify the output filename (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">fixed_executable.exe</samp>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h5 class="H3" id="sec35"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Manual Realignment</samp></h5>&#13;
<p class="TNI1">If your automated tools fail, you’ll need to manually realign the headers using a PE editor tool such as PE-bear. In PE-bear, simply load the executable file and navigate to the <b>Section Hdrs</b> tab, and you should see all sections and their associated raw and virtual sizes. Remember, the raw size represents the size of the file on disk, and the virtual size represents the size once it is loaded into memory. Since we unmapped the file from memory, we need to get the file on disk to match the file that was in memory as closely as possible. <a href="chapter17.xhtml#fig17-36">Figure 17-36</a> shows what the dumped executable may look like prior to section realignment.</p>&#13;
<figure class="IMG"><img class="img70" id="fig17-36" src="../images/fig17-36.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-36: Viewing the newly unmapped executable in PE-bear</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice how the raw (Raw Addr.) and virtual (Virtual Addr.) address offsets do not match. To fix and realign the file, first ensure each raw address matches its associated virtual address. This can be a simple copy-paste <span role="doc-pagebreak" epub:type="pagebreak" id="pg_377" aria-label="377"/>operation from the Virtual Addr. column to the Raw Addr. column. For example, if the virtual address of the <i>.text</i> section is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp>, then the raw address should be <samp class="SANS_TheSansMonoCd_W5Regular_11">1000</samp> as well.</p>&#13;
<p class="TX">Next, we need to recalculate the raw size to match the new raw addresses in order to allocate space in the file. Subtract the raw address of the first section (usually <i>.text</i>) from the raw address of the next listed section (usually <i>.rdata</i>). For example, if the raw address of the <i>.text</i> section is 1,000 bytes and the raw address of <i>.rdata</i> is 13,000 bytes, the raw size of the <i>.text</i> section should be <samp class="SANS_TheSansMonoCd_W5Regular_11">A000</samp> (12,000 bytes in decimal). You’ll need to do this for each address. For the last section, you can try entering 0 bytes, which will usually be okay. If this doesn’t work, try changing it to something like 1,000 bytes. <a href="chapter17.xhtml#fig17-37">Figure 17-37</a> shows what the file should look like afterward.</p>&#13;
<figure class="IMG"><img class="img70" id="fig17-37" src="../images/fig17-37.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-37: Viewing the fixed executable in PE-bear</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To test whether the realignment was successful, navigate to the <b>Imports</b> tab in PE-bear and you should see the imports listed. If needed, you can use Scylla to attempt to rebuild the IAT and headers as described previously.</p>&#13;
<p class="TX">If automated and manual repairing are ineffective and the unpacked executable still won’t run, you may not necessarily need to repair it. You could simply continue to examine the malware in a debugger (since the unpacked payload was already about to execute when you dumped it from memory), or you could try to analyze the unpacked executable as it is in a disassembler or PE tool. It just may be a bit more difficult to navigate, and you may need to manually label Windows function calls.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h4 class="H2" id="sec36"><span id="h-291"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">General Tips for Dynamic Unpacking</samp></h4>&#13;
<p class="TNI1">Sometimes these techniques just won’t cut it. The malware could be using an uncommon unpacking method, or maybe it’s especially stealthy in the way it unpacks or injects its code. If you’re in this situation and have hit a wall, there are some general tips that may help you get unstuck.</p>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h5 class="H3" id="sec37"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Working Backward</samp></h5>&#13;
<p class="TNI1">If you are analyzing a stubborn malware sample and are unable to follow the unpacking process or locate the OEP, working backward can help.</p>&#13;
<p class="TX">First, you identify a certain behavior that you know the malware is exhibiting and determine which Windows API function is likely responsible for this behavior. For example, if the malware attempts to contact a C2 <span role="doc-pagebreak" epub:type="pagebreak" id="pg_378" aria-label="378"/>address via HTTP, it might call the function <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetConnectA</samp> after its payload is unpacked. Or, if the malware is creating and modifying files on the disk, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteFile</samp>.</p>&#13;
<p class="TX">Next, set a breakpoint on the functions you’ve identified. Once the breakpoint is hit, walk backward in the code and try to find the unpacking routine, the memory region where the sample first unpacked itself, or (even better) the OEP.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h5 class="H3" id="sec38"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hooking Windows Decryption and Compression Functions</samp></h5>&#13;
<p class="TNI1">Malware packers may call native Windows API decryption-related functions during the unpacking process. Two of these functions are <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDecompressBuffer</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp> is used to decrypt data that was previously encrypted with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp> function. Setting a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp> may enable you to catch part of the malware’s unpacked payload (or other juicy data) directly after it has been decrypted and before it is executed. After the breakpoint has been hit, examine the buffer passed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp> function (usually the <i>fifth</i> value on the stack) after the function call.</p>&#13;
<p class="TX"><samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDecompressBuffer</samp> is sometimes used by malware to decompress a buffer that was previously compressed. As with <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>, set a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">RtlDecompressBuffer</samp> and examine the buffer (usually the <i>second</i> value on the stack) after the function call. You may get lucky and see newly unpacked code or an executable in this buffer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
&#13;
<h5 class="H3" id="sec39"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locating Packed Code</samp></h5>&#13;
<p class="TNI1">IDA Pro and some other disassemblers have a feature that visually represents the data and code in an executable file as colored boxes. You can find this visual at the top of the IDA interface, as shown in <a href="chapter17.xhtml#fig17-38">Figure 17-38</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig17-38" src="../images/fig17-38.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-38: A visual representation of a file in IDA Pro</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Although you can’t see it in a black-and-white book, this visual representation assigns different colors to the different types of data contained in the file. The Unexplored section (at the far-right of this image) is an area of the executable where IDA can’t determine the type of data. Sometimes these regions are encrypted or packed data or code, or they are areas where the malware will write data once it is executed. These regions are typically assigned a name (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">unk_4141C0</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">dword_1000502C</samp>). If you select the region name and press X (a shortcut for cross-reference), you should see a list of the areas of code that reference that region. Exploring these code areas may lead you to the malware’s main unpacking routine! Alternatively, setting a breakpoint on a code area referencing the unexplored region may give you some insight into how the malware is using the region.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_379" aria-label="379"/>&#13;
<h4 class="H2" id="sec40"><span id="h-292"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Helpful Tools for Dynamic Unpacking</samp></h4>&#13;
<p class="TNI1">Because unpacking can be very difficult at times, it is helpful to have a set of tools that you can rely on when the going gets tough. This section will outline some of my favorites.</p>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h5 class="H3" id="sec41"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">HollowsHunter</samp></h5>&#13;
<p class="TNI1">HollowsHunter (<a href="https://github.com/hasherezade/hollows_hunter"><i>https://<wbr/>github<wbr/>.com<wbr/>/hasherezade<wbr/>/hollows<wbr/>_hunter</i></a>), which is built on a tool called PE-Sieve (<a href="https://github.com/hasherezade/pe-sieve"><i>https://<wbr/>github<wbr/>.com<wbr/>/hasherezade<wbr/>/pe<wbr/>-sieve</i></a>), is a Windows command line tool that can detect various anomalies in running processes (such as injected PE files and code, hooked functions, and in-memory patches) and then dump the suspect regions of memory. While it’s not a tool solely for unpacking, it’s also great at that. <a href="chapter17.xhtml#tab17-2">Table 17-2</a> lists some of the most useful HollowsHunter parameters.</p>&#13;
<p class="TT" id="tab17-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 17-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Helpful HollowsHunter Parameters</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Parameter</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/help</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Shows all commands and their usage.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/pid</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">pid</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Specifies a target process ID to scan, rather than scanning all processes. Can also specify multiple target process IDs.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/loop</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Continues to loop after the initial scan is completed. Good for</samp> <samp class="SANS_Futura_Std_Book_11">monitoring the running processes on a system in case there is a delay in malware unpacking or code injection.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/data</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Scans nonexecutable memory regions as well as executable regions. Enable this if you suspect the malware may be writing code or data and setting it to a nonexecutable protection (R, W, RW, and so on).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/hooks</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Scans for memory patches and inline hooks.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/iat</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mode</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Scans for IAT hooks. Setting</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mode</samp> <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_Futura_Std_Book_11">will produce a filtered scan, leaving out the noise of system IAT hooks.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/shellc</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Scans for shellcode injections. Can be a bit noisy, so use with caution.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/imp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mode</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Attempts to recover the imports table of any dumped executables. Setting</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mode</samp> <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_Futura_Std_Book_11">will attempt to automatically detect the correct method of imports reconstruction.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">To use HollowsHunter, execute the malware in your analysis environment and run HollowsHunter with your desired command line options, such as the following:</p>&#13;
<pre class="pre-189"><code>C:\&gt; <b>hollows_hunter64.exe /loop /hooks /shellc /iat 1 /imp 1</b></code></pre>&#13;
<p class="TX">This command tells HollowsHunter to continue to loop through all the running processes on the system (<samp class="SANS_TheSansMonoCd_W5Regular_11">/loop</samp>), specifically searching for hooks (<samp class="SANS_TheSansMonoCd_W5Regular_11">/hooks</samp>), injected shellcode (<samp class="SANS_TheSansMonoCd_W5Regular_11">/shellc</samp>), and IAT hooks (<samp class="SANS_TheSansMonoCd_W5Regular_11">/iat 1</samp>). Finally, HollowsHunter will attempt to rebuild the IAT (<samp class="SANS_TheSansMonoCd_W5Regular_11">/imp 1</samp>) of the dumped unpacked executable files.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_380" aria-label="380"/>After you run HollowsHunter, it will attempt to detect malicious code in memory. For example, in <a href="chapter17.xhtml#fig17-39">Figure 17-39</a>, HollowsHunter has detected potentially malicious code in the <i>RuntimeBroker.exe</i> and <i>dllhost.exe</i> processes. This code could be the result of the malware unpacking itself and subsequently injecting code into these processes.</p>&#13;
<figure class="IMG"><img class="img50" id="fig17-39" src="../images/fig17-39.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-39: HollowsHunter scanning process memory</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Once it detects suspicious code, HollowsHunter dumps the suspect memory regions to disk and nicely organizes all the dumped memory images into a series of directories by process ID, as shown in <a href="chapter17.xhtml#fig17-40">Figure 17-40</a>.</p>&#13;
<figure class="IMG"><img class="img80" id="fig17-40" src="../images/fig17-40.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-40: The HollowsHunter output</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">HollowsHunter is often one of the first unpacking techniques I try. Sometimes I just need to get to the unpacked malware sample quickly, without messing around with the unpacking process. A similar tool, Mal_Unpack (<a href="https://github.com/hasherezade/mal_unpack"><i>https://<wbr/>github<wbr/>.com<wbr/>/hasherezade<wbr/>/mal<wbr/>_unpack</i></a>), is written by the same author and can also be very helpful. Like HollowsHunter, Mal_Unpack is based on PE-Sieve, but it uses a special optional driver that allows for better control of the automated unpacking process. <a href="chapter17.xhtml#fig17-41">Figure 17-41</a> shows Mal_Unpack in action.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_381" aria-label="381"/>&#13;
<figure class="IMG"><img class="img70" id="fig17-41" src="../images/fig17-41.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-41: Mal_Unpack unpacking a Dridex malware sample</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As you can see, Mal_Unpack was able to unpack a malware sample that is part of the Dridex family!</p>&#13;
<p class="TX">Both tools can be valuable additions to your analysis arsenal. However, since HollowsHunter is able to scan all processes running on the host, it can often identify and locate code that malware has injected into other processes. For this reason, I often find that it suits my needs better. I recommend trying out both tools to determine which works best for you.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h5 class="H3" id="sec42"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">ScyllaHide RunPE Unpacker</samp></h5>&#13;
<p class="TNI1">ScyllaHide, which I’ve mentioned several times throughout this book, has an option called RunPE Unpacker that attempts to automatically extract executable files from memory when it detects that unpacking has occurred. The feature hooks <samp class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp> to intercept certain process injection techniques and dump the unpacked malware before it can execute its payload.</p>&#13;
<p class="TX">To use this feature, load your malware sample into x64dbg and select <b>Plugins</b><span class="MenuArrow"></span><b>ScyllaHide</b><span class="MenuArrow"></span><b>Options</b>. Check <b>RunPE Unpacker</b> and click <b>Apply</b>, as shown in <a href="chapter17.xhtml#fig17-42">Figure 17-42</a>.</p>&#13;
<figure class="IMG"><img class="img50" id="fig17-42" src="../images/fig17-42.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 17-42: RunPE Unpacker in ScyllaHide</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_382" aria-label="382"/>After enabling this feature, run the malware as normal. If the unpacking is successful, you should see a newly created executable file on your desktop; you won’t receive any other notification about whether or not it is successful. RunPE Unpacker targets a specific process injection technique and does not work in all cases. When it does work, however, it saves you a lot of time.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec43">&#13;
&#13;
<h5 class="H3" id="sec43"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">A Note on Emulation and Instrumentation</samp></h5>&#13;
<p class="TNI1">Emulators and binary instrumentation frameworks, which we’ll briefly discuss in <span class="Xref"><a href="appendix-A.xhtml">Appendix A</a></span> can also be useful for dynamically unpacking malware. These toolsets can even provide a means of completely automating the unpacking process. For example, Speakeasy (<a href="https://github.com/mandiant/speakeasy"><i>https://<wbr/>github<wbr/>.com<wbr/>/mandiant<wbr/>/speakeasy</i></a>) allows you to emulate malicious code and “hook” suspect function calls. As Speakeasy operations can be scripted, it’s possible to automate the interception of function calls such as <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">ResumeThread</samp> in order to automate malware unpacking. I won’t touch on emulators or instrumentation more in this chapter, but know that many of the techniques you learned in this chapter can be applied to these toolsets.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec44">&#13;
&#13;
<h5 class="H3" id="sec44"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other Tools</samp></h5>&#13;
<p class="TNI1">Finally, you can find several scripts and plug-ins for x64dbg that can aid in unpacking on GitHub at <a href="https://github.com/x64dbg/Scripts"><i>https://<wbr/>github<wbr/>.com<wbr/>/x64dbg<wbr/>/Scripts</i></a> and <a href="https://github.com/x64dbg/x64dbg/wiki/Plugins"><i>https://<wbr/>github<wbr/>.com<wbr/>/x64dbg<wbr/>/x64dbg<wbr/>/wiki<wbr/>/Plugins</i></a>. These scripts and plug-ins can automatically unpack certain packers, automatically locate the OEP, hide your debugger from unpackers, help bypass anti-analysis checks, and more.</p>&#13;
<p class="TX">As a final note, there are always new and innovative research projects and tools being released from the amazing malware research and reverse engineering community, so there’s no way I can capture them all here. Always be on the lookout for newly released tools that can aid in unpacking and in malware analysis more generally.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec45">&#13;
&#13;
<h3 class="H1" id="sec45"><span id="h-293"/><samp class="SANS_Futura_Std_Bold_B_11">Manual Static Unpacking</samp></h3>&#13;
<p class="TNI1">The final method of unpacking we’ll discuss is <i>static unpacking</i>, the process of reverse engineering the unpacking mechanism in a packed malware sample and then writing code that replicates that mechanism. Once this code is run on the packed malware executable, the malware sample will theoretically be unpacked. The process of writing a static unpacker is roughly as follows:</p>&#13;
<p class="ListNumber1">  1.  Locate the unpacking routine in the packed malware executable.</p>&#13;
<p class="ListNumber">  2.  Locate the specific instructions that are part of the deobfuscation or decryption process.</p>&#13;
<p class="ListNumber">  3.  Reverse engineer the decryption routine (this can be done with the help of a decompiler, such as the ones built into IDA Pro, Ghidra, or x64dbg).</p>&#13;
<p class="ListNumber"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_383" aria-label="383"/>  4.  Write the static unpacking code to model the unpacking routine in the executable.</p>&#13;
<p class="ListNumber2">  5.  Feed the packed malware sample into your static unpacker and test it out! Debug as necessary.</p>&#13;
<p class="TX">I chose not to go into depth on this unpacking technique for two reasons. First, this process can be very time-consuming and tedious, and learning about other unpacking techniques may be a better use of your time, assuming your goal is to quickly unpack the malware sample so that you can better understand it. Second, if you were to successfully reverse engineer the unpacking technique and write a static unpacker, your code might only work properly on this particular sample, as malware packers often introduce some sort of randomness to the unpacking routine (a random decryption key, obfuscation technique, or something else). Static unpackers are not resilient to heavy modification of the packer’s code.</p>&#13;
<p class="TX">This doesn’t mean that there’s no value in manual static unpacking. Static unpackers are often better for at-scale analysis. For example, if you’re attempting to unpack tens or hundreds of samples at a time, it’s more efficient to do so statically than to run all those samples through a dynamic engine. Also, reversing the unpacking process and writing an unpacker is a great way to learn how malware packs its code and, more generally, a great way to learn about encryption, compression, and obfuscation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec46">&#13;
&#13;
<h3 class="H1" id="sec46"><span id="h-294"/><samp class="SANS_Futura_Std_Bold_B_11">Analyzing Without Unpacking</samp></h3>&#13;
<p class="TNI1">Sometimes you may find yourself unable to successfully unpack a malware sample. Maybe you lose control of the sample while it is running, can’t determine where and how the malware is unpacking itself, or can’t find the OEP. When in this situation, ask yourself if unpacking the malware is really necessary. What are you trying to achieve by doing so? What questions are you trying to answer?</p>&#13;
<p class="TX">In many cases, you don’t have to fully unpack the sample to understand its key behaviors or even to perform code analysis. You may be able to extract pieces of the unpacked malware sample from memory using the techniques described throughout this book. This will allow you to at least perform some analysis of the data, code, and extracted strings. Alternatively, you can inspect the running malware in a debugger, monitor its behaviors, set breakpoints on interesting function calls, and examine code and strings in memory. Finally, sometimes simply examining the malware executing in an automated sandbox is all you need to be able to understand the malware’s basic functionalities.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec47">&#13;
&#13;
<h3 class="H1" id="sec47"><span id="h-295"/><samp class="SANS_Futura_Std_Bold_B_11">Anti-unpacking Techniques</samp></h3>&#13;
<p class="TNI1">Up until now, we’ve been discussing typical methods that malware packers use to decrypt and deobfuscate the malware’s payload, write it into memory, and execute it, sometimes in a covert manner. We’ve also talked about <span role="doc-pagebreak" epub:type="pagebreak" id="pg_384" aria-label="384"/>common methods of automatically and manually unpacking the malware so that it can be better analyzed and understood. But what if the malware packer itself fights back and attempts to evade your tools and analysis? Some packers, especially those designed specifically for malware, implement some form of VM and sandbox detection techniques and attempt to evade the analysis process in order to protect the malware’s original code. For this reason, it’s important to know and understand common anti-unpacking techniques used by advanced packers.</p>&#13;
<p class="TX">Many of these techniques have already been discussed throughout this book. For example, malware packers often implement the sandbox and VM detection techniques covered in <span class="Xref"><a href="part2.xhtml">Part II</a></span>. Before unpacking the malicious code, the packers try to identify whether the sample is running in a VM or sandbox environment and, if so, whether it will avoid unpacking.</p>&#13;
<p class="TX">Many malware packers also take advantage of the techniques discussed in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> to detect and obstruct debugging programs. For example, before unpacking and running the malicious code, the packer tries to detect if it is being debugged and kills itself if it is. It might also attempt to interfere with the manual unpacking process by using anti-debugging techniques, such as interfering with breakpoints or using memory guard pages. Some packers even implement the sandbox evasion techniques discussed in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a>.</span> For example, they may sleep for a certain amount of time before unpacking and executing the malware’s payload in order to create a timeout situation in malware sandboxes and confuse the analysis process.</p>&#13;
<p class="TX">Basic anti-unpacking techniques can be as simple as modifying the original packer so that it’s more difficult to detect and unpack, which can be accomplished with any well-known or open source packer. The malware author could pack their sample with the UPX packer, for example, but modify it to remove the normal section name strings (UPX0, UPX1, and so on) or corrupt its headers. Then, when the malware analyst tries to identify the packer, they won’t be able to detect UPX as easily. Additionally, the packer’s code could be modified so that the normal UPX unpacking is impossible (by using the UPX tool, for example). Packers can also modify or destroy the unpacked executable’s headers so that when the sample is unpacked, it’s more difficult for automated tooling and malware analysts to locate the unpacked PE.</p>&#13;
<p class="TX">IAT confusion is another technique employed by malware packers. After the packer has resolved the initial imports and functions, it may alter or completely destroy the IAT and then rebuild it at a later point by dynamically resolving function addresses. Similarly, the packer may allocate a separate area of memory, like a jump table, to store instructions that jump to the functions it wishes to execute as a way of obfuscating its IAT.</p>&#13;
<p class="TX">Finally, malware packers can obfuscate themselves through sheer confusion. It’s not uncommon for the packer to have a very convoluted control flow, with spaghetti code and control flow transfers (such as some of the techniques discussed in <span class="Xref"><a href="chapter9.xhtml">Chapters 9</a></span> and <span class="Xref"><a href="chapter11.xhtml">11</a></span>) that make following the code and unpacking process difficult. The packer might also unpack the malicious code in multiple steps, further obfuscating the unpacking process and making it difficult for analysts to cleanly unpack the malware’s payload.</p>&#13;
<aside class="box" aria-label="box-13">&#13;
<p class="BoxTitle" id="box-13"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_385" aria-label="385"/><samp class="SANS_Dogma_OT_Bold_B_11">VIRTUAL MACHINES IN PACKERS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The use of packer virtual machines is an anti-unpacking and software protection technique not only in malware but also in legitimate software. Some of the more advanced packers use a small VM included in the packed executable. The packer essentially transforms parts of the original executable code in the packed binary into a proprietary intermediate language that executes in the mini-VM. This creates a scenario in which the original executable’s code isn’t clearly visible in memory. You can probably guess why this makes a reverse engineer’s life a lot more difficult.</samp></p>&#13;
<p class="Boxtext"><samp class="SANS_Futura_Std_Book_11">Perhaps the best-known packers that utilize this technique are VMProtect and Themida. Since these packers are commercial and used mostly for protecting legitimate software, it is rare for malware to use them. There are a few reasons for this. First, it’s fairly trivial to detect malware packed with them because they weren’t designed with anti-malware and detection evasion in mind. Second, it can be difficult to use these packers correctly, and any misconfigurations can render them ineffective. And third, virtualized packers increase the file size of the malware and are slower than running the executable natively.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Because these types of packers aren’t often seen in the wild in malware, I don’t say much more about them in this book. If you spot a malware sample using one of them, remember that the malware author is human, and humans make mistakes. Virtualized packers are more difficult to use, so misconfigurations can occur. If the packer is misconfigured, you might be able to unpack the malware sample using the techniques discussed throughout this chapter, bypassing the virtualization completely.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec48">&#13;
&#13;
<h3 class="H1" id="sec48"><span id="h-296"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, you learned about some common packer types and how malware can leverage packers to obfuscate code, obstruct analysts and researchers from understanding its behaviors, and evade detection and defensive tools. You also saw several techniques you can use to peel back the unpacker’s layers and get to the source of the malware’s evil: its payload. Finally, we briefly examined some ways in which malware packers may try to circumvent analysis measures.</p>&#13;
<p class="TX">In <a href="appendix-A.xhtml">Appendix A</a>, we’ll look at how to build an effective anti-evasion analysis lab, which can be a great asset in your evasive-malware investigations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec49">&#13;
&#13;
<h3 class="H1" id="sec49"><span id="h-297"/><samp class="SANS_Futura_Std_Bold_B_11">Closing Thoughts</samp></h3>&#13;
<p class="TNI1">This chapter marks the end of <i>Evasive Malware</i>. I hope you’ve obtained new skills you can start applying to your threat investigations and analysis <span role="doc-pagebreak" epub:type="pagebreak" id="pg_386" aria-label="386"/>efforts. But above all, I hope this book has deepened your interest in the area of evasive threats and given you a thirst for more knowledge.</p>&#13;
<p class="TX">I encourage you to continue researching this fascinating topic. A great start would be to consult <span class="Xref"><a href="appendix-C.xhtml">Appendix C</a></span>, which contains some recommended resources and further reading. Then, test out your new skills. Take apart an interesting piece of malware. Experiment and uncover how it attempts to evade defenses and your analysis tooling. And most importantly: document your findings for others! We are much more powerful fighting the battle against malware and cybercrime together than we are individually. Thank you for reading.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>