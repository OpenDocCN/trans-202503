<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch8" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch8">
<span class="CN"><span aria-label=" Page 111. " epub:type="pagebreak" id="pg_111" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CONTROLLING HIGHER-POWERED DEVICES</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">Many Arduino users rely on the 74HC595 shift register for their projects, as it’s popular and easy to use. However, the 74HC595 can handle only a relatively low amount of current, especially when all pins are active: while you can draw 20 mA of current from one output continuously, the entire IC is rated for a draw of only 70 mA through the V<sub>CC</sub> or GND pin.</p>
<p class="TX">If you need 20 mA per output to drive, for instance, eight separate LEDs, you could use only three of the eight pins under recommended operating conditions. While it may be possible to exceed the manufacturer’s direction, good electronic designs should consider safety and reliability. A shift register designed to handle higher currents is a better choice.</p>
<p class="TX">This chapter shows you how to control higher-powered devices with your Arduino with the TPIC6B595 shift register IC. You’ll learn to:</p>
<ul class="ul">
<li class="BL">Experiment with a binary number display</li>
<li class="BL">Use multiple TPIC6B595s to control more than eight high-powered outputs</li>
<li class="BL">Use bright Piranha-style LEDs that are more powerful than regular LEDs</li>
</ul>
<p class="TX"><span aria-label=" Page 112. " epub:type="pagebreak" id="pg_112" role="doc-pagebreak"/>You’ll also build a PC-controlled eight-relay board and control giant seven-segment numeric displays.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-57"/><samp class="SANS_Futura_Std_Bold_B_11">The TPIC6B595</samp></h2>
<p class="TNI">The TPIC6B595 is controlled in the same way as the 74HC595 but offers up to 150 mA per output and a 500 mA IC total current draw—just over 60 mA per pin when all pins are used. It can also switch voltages up to 50 V DC. This allows for control of eight higher-current items such as powerful LEDs, relay coils, or mechanical switchgear.</p>
<p class="TX">The TPIC6B595 is a <i>latching shift register</i>, meaning that as long as power is connected, it will maintain the output status. For example, if you upload a new sketch, the outputs are not affected. If you’ve powered your circuit from a power supply and not the Arduino, you can reset the Arduino without altering the outputs.</p>
<p class="TX"><a href="chapter8.xhtml#fig8-1">Figure 8-1</a> shows a TPIC6B595 in a dual in-line package, through-hole format in a solderless breadboard.</p>
<figure class="IMG"><img alt="A PICTURE OF A TPIC6B595 IN A SOLDERLESS BREADBOARD" class="img8" id="fig8-1" src="../images/fig8-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: A TPIC6B595 shift register</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter8.xhtml#fig8-2">Figure 8-2</a> shows the TPIC6B595’s schematic symbol.</p>
<figure class="IMG"><img alt="THE SCHEMATIC SYMBOL FOR THE TPIC6B595" class="img4" id="fig8-2" src="../images/fig8-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: The schematic symbol for the TPIC6B595</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 113. " epub:type="pagebreak" id="pg_113" role="doc-pagebreak"/>The eight output pins in the schematic are labeled DRAIN<i>x</i>, since the TPIC6B595 has low-side outputs. Like the 2N7000 N-MOSFETs used in previous chapters, each of these outputs controls current entering the pin (as opposed to the 74HC595’s high-side outputs, for example, where currents flow out from the eight control pins). This means the devices to be controlled are connected between the power supply and the control pins on the TPIC6B595, which switches the currents’ ability to flow from the device to GND.</p>
<p class="TX">Consider the schematic in <a href="chapter8.xhtml#fig8-3">Figure 8-3</a>. Current flows from the 5 V source, through the resistor and LED, and into the TPIC6B595’s output pin. When that pin is activated, the current continues to GND, completing the circuit.</p>
<figure class="IMG"><img alt="A SCHEMATIC OF THE LED CONNECTED TO THE TPIC6B595 VIA 5V AND CURRENT-LIMITING RESISTOR" class="img7" id="fig8-3" src="../images/fig8-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: An example of LED control with TPIC6B595</samp></p></figcaption>
</figure>
<p class="TX">Given the TPIC6B595’s method of controlling current, the voltage of the devices it controls can be up to 50 V, while the shift register is still operating on 5 V. Conveniently, that means you can control 12 V devices or higher without worrying about level conversion back to the Arduino.</p>
<p class="TX">Let’s put the TPIC6B595 to the test with a simple project that demonstrates shift register operation.</p>
<p class="HeadProject"><span id="h1-58"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #25: Creating a TPIC6B595 Binary Number Display</samp></p>
<p class="TNI">This project demonstrates the use of TPIC6B595 outputs while refreshing your knowledge of binary numbers and how they relate to shift register output control. You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Various jumper wires</li>
<li class="BL">A TPIC6B595 shift register IC</li>
<li class="BL">One 0.1 µF capacitor</li>
<li class="BL">Eight LEDs</li>
<li class="BL">Eight 1 kΩ, 0.25 W, 1 percent resistors</li>
</ul>
<p class="TX"><span aria-label=" Page 114. " epub:type="pagebreak" id="pg_114" role="doc-pagebreak"/>Assemble the circuit as shown in <a href="chapter8.xhtml#fig8-4">Figure 8-4</a>.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #25, SHOWING A TPIC6B595 CONTROLLING EIGHT LEDS VIA CURRENT-LIMITING RESISTORS" class="img1" id="fig8-4" src="../images/fig8-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4:</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">The schematic for Project #25</samp></p></figcaption>
</figure>
<p class="TX">Enter and upload the Project #25 sketch. Open the Serial Monitor in the IDE and enter a number between 0 and 255, inclusive, then press <small>CTRL</small>-<small>ENTER</small>. The Arduino should respond by displaying the number in binary using the LEDs, as well as in the Serial Monitor, as shown in <a href="chapter8.xhtml#fig8-5">Figure 8-5</a>. LED 1 will be the least significant bit of the number, which represents 1, and LED 8 will be the most significant bit, which represents 255.</p>
<figure class="IMG"><img alt="AN EXAMPLE OUTPUT FROM THE SERIAL MONITOR FOR PROJECT #25 SHOWING THE NUMBER ENTERED AND THE MATCHING BINARY VALUE" class="img7" id="fig8-5" src="../images/fig8-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: Example output from Project #25</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-25"/>

<pre><code>// Project #25 - TPIC6B595 binary number display

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #define latch 8 // Latch RCK pin
#define clock 9 // Clock SRCK pin
#define data 10 // Data SERIN pin

void displayBinary(int displayNumber)
{
    digitalWrite(latch, LOW);
    shiftOut(data, clock, MSBFIRST, displayNumber);
    digitalWrite(latch, HIGH);
}

<span aria-label=" Page 115. " epub:type="pagebreak" id="pg_115" role="doc-pagebreak"/>void setup()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Serial.begin(9600);
    pinMode(latch, OUTPUT);
    pinMode(clock, OUTPUT);
    pinMode(data, OUTPUT);
}

voi<code>d</code> loop()
{
    long number = 0;
    long entry = 0;
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Serial.flush();
    while (Serial.available() == 0) {}
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> while (Serial.available() &gt; 0)
    {
        number = number * 10;
        entry = Serial.read() - '0';
        number = number + entry;
        delay(5);
    }
    displayBinary(number);
    Serial.print("You entered: ");
    Serial.print(number);
    Serial.print(", which is ");
    Serial.print(number, BIN);
    Serial.println(" in binary.");
}
</code></pre>

<p class="TX">The sketch begins by defining the Arduino digital pins used for connecting to the shift register’s Latch, Clock, and Data pins, respectively <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">displayBinary()</samp> function accepts an integer and sends it to the shift register for output control, using the same method as the 74HC595 shift register mentioned earlier. To send the bits representing the number to the shift register in binary and to activate the pins in the shift register to control the LEDs that will match the number to be displayed in binary, the function uses <samp class="SANS_TheSansMonoCd_W5Regular_11">MSBFIRST</samp> (most significant bit first).</p>
<p class="TX">You can turn shift register outputs on and off with the 8 bits of the number sent to the shift register, as each bit matches an output and a status (1 for HIGH, 0 for LOW). You can also change <samp class="SANS_TheSansMonoCd_W5Regular_11">MSBFIRST</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">LSBFIRST</samp>, standing for least significant bit first, to see the number “reversed” in binary.</p>
<p class="TX">The sketch initializes the Serial Monitor and digital output pins <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> and then flushes the serial input and waits for the user to enter a number into the Serial Monitor <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. It then combines the digits of the number entered in the Serial Monitor to make the final number to display <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">displayBinary()</samp> function sends that number to the shift register and the Serial Monitor.</p>
<p class="TX">You’ll put this framework for shift register control to use in the next project.</p>
<p class="HeadProject"><span id="h1-59"/><span aria-label=" Page 116. " epub:type="pagebreak" id="pg_116" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #26: Building a PC-Controlled Relay Board</samp></p>
<p class="TNI">In this project, you’ll build a relay control board with eight single-pole, double-throw (SPDT) relays that you control via a PC or another device with an Arduino-compatible UART. In the future, you might use the technique introduced in this project to control low-voltage lighting or electric door locks, turn speakers on and off, and more.</p>
<p class="TX">Each relay in this project is capable of controlling up to 30 V DC at 2 A of current, if you’re using the project PCB. If you’re using the solderless breadboard, the relays should be used to switch only up to 100 mA or so.</p>
<p class="TX">While it’s possible to build this project using a solderless breadboard, this requires soldering jumper wires to the relay pins for remotely wiring the relays back to the circuit, as shown in <a href="chapter8.xhtml#fig8-6">Figure 8-6</a>, as the relay pins don’t sit in the breadboard very well. I strongly recommend you use the PCB instead.</p>
<figure class="IMG"><img alt="A PHOTO OF A RELAY WITH JUMPER WIRES SOLDERED TO ITS PINS, FOR USE WITH A SOLDERLESS BREADBOARD" class="img4" id="fig8-6" src="../images/fig8-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-6: A relay with remote wiring for breadboard use</samp></p></figcaption>
</figure>
<p class="TX">You’ll need the following parts for this project:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">A 12 V power supply or wall wart with DC plug</li>
<li class="BL">A TPIC6B595 shift register</li>
<li class="BL">A 20-pin IC socket</li>
<li class="BL">One 0.1 µF capacitor</li>
<li class="BL">Eight LEDs</li>
<li class="BL">Eight 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">Eight 1N4001 power diodes</li>
<li class="BL">Eight SRD-12VDC-SL-C SPDT relays</li>
<li class="BL">A solderless breadboard or Project #26 PCB</li>
</ul>
<p class="TX">If you’re using the PCB, you will also need the following:</p>
<ul class="ul">
<li class="BL">Ten three-way 5.08 mm terminal blocks</li>
<li class="BL">A 20-pin IC socket</li>
<li class="BL">A PCB mount DC socket</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter8.xhtml#fig8-7">Figure 8-7</a>.<span aria-label=" Page 117. " epub:type="pagebreak" id="pg_117" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A SCHEMATIC FOR PROJECT #26, SHOWING THE TPIC6B595 CONTROLLING EIGHT RELAYS WITH INDICATOR LEDS" class="img1" id="fig8-7" src="../images/fig8-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-7: The schematic for Project #26</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 118. " epub:type="pagebreak" id="pg_118" role="doc-pagebreak"/>If you’re using the PCB, the layout is simple, as shown in <a href="chapter8.xhtml#fig8-8">Figure 8-8</a>.</p>
<figure class="IMG"><img alt="A PHOTO OF AN UNPOPULATED PCB FOR PROJECT #26" class="img4" id="fig8-8" src="../images/fig8-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-8: The PCB for Project #26</samp></p></figcaption>
</figure>
<p class="TX">Start by inserting the resistors; then insert the diodes, the LEDs, the IC and DC sockets, the terminal blocks, and end with the relays. Be sure to insert the shift register correctly—pin 1 is marked on the PCB. Connect to the Arduino via the two terminal blocks next to the shift register, as shown in the schematic and <a href="chapter8.xhtml#fig8-9">Figure 8-9</a>. The Arduino is powered by the relay board’s 12 V supply and returns 5 V to the board to power the shift register.</p>
<figure class="IMG"><img alt="A PHOTO OF COMPLETED PROJECT #26 CONNECTED TO EXTERNAL POWER AND AN ARDUINO UNO, WITH SEVEN LIGHTS LIT UP" class="img6" id="fig8-9" src="../images/fig8-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-9: The completed hardware for Project #26</samp></p></figcaption>
</figure>
<p class="TX">Once you’ve set up the hardware, enter and upload the Project #26 sketch, which controls the relays with various commands. Entering the numbers 0 through 7 using the Serial Monitor or terminal software turns on relays 0 through 7, respectively; entering 8 through F turns off relays 0 to 7; G turns all relays on; and H turns all relays off. Enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">?</samp> to check which relays are on and off based on the commands being entered. The result is returned as a binary number matching the relay order. If the user enters an unrecognized character, the Arduino returns a list of valid commands.</p>
<p class="TX"><span aria-label=" Page 119. " epub:type="pagebreak" id="pg_119" role="doc-pagebreak"/>For example, <a href="chapter8.xhtml#fig8-10">Figure 8-10</a> shows the output for the commands <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">Q</samp> (which caused the incorrect command message to display), then <samp class="SANS_TheSansMonoCd_W5Regular_11">H</samp>, and then <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>.</p>
<figure class="IMG"><img alt="AN EXAMPLE SERIAL MONITOR OUTPUT FOR PROJECT #26 SHOWING EXAMPLE COMMANDS TO TURN ON AND OFF RELAYS AND SHOWING USER HELP LINE" class="img1" id="fig8-10" src="../images/fig8-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-10: An example of operations in the Serial Monitor</samp></p></figcaption>
</figure>
<p class="TX">If you’re sharing the relay board and Arduino with others, they don’t need to run the Arduino IDE for control; instead they can use any terminal software on their PC, Mac, or other computer that supports USB serial. For example, the same operation is possible with Roger Meier’s CoolTerm application, available from <a href="http://freeware.the-meiers.org"><i>http://<wbr/>freeware<wbr/>.the<wbr/>-meiers<wbr/>.org</i></a>, as shown in <a href="chapter8.xhtml#fig8-11">Figure 8-11</a>.</p>
<figure class="IMG"><img alt="AN EXAMPLE OUTPUT FOR PROJECT #26 SHOWING EXAMPLE COMMANDS TO TURN ON AND OFF RELAYS AND SHOWING THE USER HELP LINE USING THE COOLTERM TERMINAL SOFTWARE INSTEAD OF A SERIAL MONITOR" class="img5" id="fig8-11" src="../images/fig8-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-11: Controlling the relays using the CoolTerm application</samp></p></figcaption>
</figure>
<p class="TX">The control Arduino expects only single characters from the host computer (or other UART), so you can write software for your computer in many environments to control the relays. Search your preferred environment’s resources for “plaintext serial over USB” or similar to learn more.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-26"/>

<pre><code>// Project #26 - PC-controlled relay board

#define latch 8 // Latch RCK pin
#define clock 9 // Clock SRCK pin
#define data 10 // Data SERIN pin

int relayStatus;

<span aria-label=" Page 120. " epub:type="pagebreak" id="pg_120" role="doc-pagebreak"/>void showStatus()
{
    Serial.print("Relay status 7 to 0 is: ");
    Serial.println(relayStatus,BIN);
}

void waveHello()
{
    int d = 250;
    Serial.println("Hello!");
    allOff();
    for (int a = 0; a &lt; 8; a++)
    {
        relayOn(a);
        delay(d);
        relayOff(a);
    }
    for (int a = 6; a &gt;= 0; a--)
    {
        relayOn(a);
        delay(d);
        relayOff(a);
    }
}

void relayOn(int a)
{
    relayStatus = relayStatus|(1&lt;&lt;a);
    sendStatus(relayStatus);
    Serial.print("Relay "); Serial.print(a); Serial.println(" On");
}

void relayOff(int a)
{
    relayStatus = relayStatus^(1&lt;&lt;a);
    sendStatus(relayStatus);
    Serial.print("Relay "); Serial.print(a); Serial.println(" Off");
}

void allOn()
{
    relayStatus = 255;
    sendStatus(relayStatus);
    Serial.println("All relays turned on");
}

void allOff()
{
    relayStatus = 0;
    sendStatus(relayStatus);
    Serial.println("All relays turned off");
}

<span aria-label=" Page 121. " epub:type="pagebreak" id="pg_121" role="doc-pagebreak"/>void sendStatus(int a)
{
    digitalWrite(latch, LOW);
    shiftOut(data, clock, MSBFIRST, a);
    digitalWrite(latch, HIGH);
}

void setup()
{
    Serial.begin(9600);
    pinMode(latch, OUTPUT);
    pinMode(clock, OUTPUT);
    pinMode(data, OUTPUT);
}

void loop()
{
    char a = 0;
    Serial.flush();
    while (Serial.available() == 0) {}
    while (Serial.available() &gt; 0) <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
    {
        a = Serial.read();
    }
    switch (a) <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
    {
        case '0' : relayOn(0); break;
        case '1' : relayOn(1); break;
        case '2' : relayOn(2); break;
        case '3' : relayOn(3); break;
        case '4' : relayOn(4); break;
        case '5' : relayOn(5); break;
        case '6' : relayOn(6); break;
        case '7' : relayOn(7); break;
        case '8' : relayOff(0); break;
        case '9' : relayOff(1); break;
        case 'A' : relayOff(2); break;
        case 'B' : relayOff(3); break;
        case 'C' : relayOff(4); break;
        case 'D' : relayOff(5); break;
        case 'E' : relayOff(6); break;
        case 'F' : relayOff(7); break;
        case 'G' : allOn(); break;
        case 'H' : allOff(); break;
        case 'Z' : waveHello(); break; <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
        case '?' : showStatus(); break;
        default : Serial.print("Incorrect command - 0 1 2 3 4 5 6 7 turns 0~7 on, "); <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
        Serial.println("8 9 A B C D E F turns 0~7 off, G - all on, H - all off");
    }
}</code></pre>

<p class="TX"><span aria-label=" Page 122. " epub:type="pagebreak" id="pg_122" role="doc-pagebreak"/>The sketch first declares the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp>, which holds the status of the relays. Think of this number in binary, with the least significant bit representing relay 0: if this bit is 1, the relay is on, and if it is 0, the relay is off. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">showStatus()</samp> function sends the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp> in binary back to the serial interface, so the receiver can see which relays are on or off in their terminal, Serial Monitor, or other software. All the functions that control a relay also send feedback via serial to the user, describing the completed action.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">relayOn(int a)</samp> function turns on relays, using the bitwise arithmetic operator OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>) to activate the desired relay without interrupting other relays. The function receives the value <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and performs a bitwise OR with the <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp> variable, then it updates the relays using the new value of <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp>. For example, if relays 0, 1, 2, and 3 are on, then the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp> in binary is currently B00001111. If the user then enters <samp class="SANS_TheSansMonoCd_W7Bold_B_11">5</samp> in the Serial Monitor (or terminal software) to turn on relay 5, the program would switch bit 5 to 1, as follows:</p>

<pre><code>B00001111 | // Current value of relayStatus
B00100000 = // Perform OR with 1 &lt;&lt; 5—received by the function in a
B00101111   // New value of relayStatus
</code></pre>

<p class="BodyContinued">The <samp class="SANS_TheSansMonoCd_W5Regular_11">sendStatus()</samp> function changes the relays accordingly by updating the shift register outputs.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">relayOff(int a)</samp> function turns relays off, using the bitwise arithmetic operator XOR (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>) to deactivate the desired relay without interrupting other relays. For example, if relays 0, 1, 2, 3, and 5 are on, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">relayStatus</samp> in binary is currently B00101111. If you enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">A</samp> in the Serial Monitor or terminal software to turn off relay 3, the program should switch bit 3 to 0, as follows:</p>

<pre><code>B00101111 ^ // Current value of relayStatus
B00001000 = // Perform XOR with 1 &lt;&lt; 3
B00100111   // New value of relayStatus
</code></pre>

<p class="BodyContinued">Again, the <samp class="SANS_TheSansMonoCd_W5Regular_11">sendStatus()</samp> function changes the relays accordingly by updating the shift register outputs. Two additional functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">allOn()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">allOff()</samp>, turn all relays on and off, respectively, by sending 255 (binary <samp class="SANS_TheSansMonoCd_W5Regular_11">B11111111</samp>) and 0 (binary <samp class="SANS_TheSansMonoCd_W5Regular_11">B0000000</samp>) to the shift register.</p>
<p class="TX">General operation is simple. The Arduino awaits a single character from the serial line <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Once a character has arrived, it is matched to a command <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The user can activate the simple <samp class="SANS_TheSansMonoCd_W5Regular_11">waveHello()</samp> function <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> by pressing <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Z</samp> to turn the relays on and off one at a time, for testing and amusement. Finally, if the character isn’t a command, the program sends a quick reference to serial <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> so the user can learn the command set.</p>
<p class="TX">For a challenge, you can modify the sketch so the relay status is saved to the internal EEPROM when changed and the system sets the relays from the EEPROM data after a reset.</p>
<p class="TX"><span aria-label=" Page 123. " epub:type="pagebreak" id="pg_123" role="doc-pagebreak"/>Now that you know how to control eight higher-current devices with a single TPIC6B595, I’ll show you how to use two or more TPIC6B595s at once.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-60"/><samp class="SANS_Futura_Std_Bold_B_11">Using Multiple TPIC6B595s</samp></h2>
<p class="TNI">You can easily use two or more TPIC6B595 shift registers at once to control 16 or more devices in the same way you would with the 74HC595, but with the ability to handle higher currents. Start by connecting each TPIC6B595’s Clock lines together, connect their Latch lines together, then connect the Serial Out from the first shift register to the Serial In on the second shift register, repeating as required. For example, the schematic in <a href="chapter8.xhtml#fig8-12">Figure 8-12</a> shows double the number of LEDs controlled by Project #25.</p>
<figure class="IMG"><img alt="" class="img1" id="fig8-12" src="../images/fig8-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-12: The schematic for controlling 16 LEDs with shift registers</samp></p></figcaption>
</figure>
<p class="TX">Next, send out 2 bytes of data while the latch is low, instead of 1 byte. You’ll need to send the byte for the last shift register in the chain first. For <span aria-label=" Page 124. " epub:type="pagebreak" id="pg_124" role="doc-pagebreak"/>example, to send out 2 bytes to the shift registers in <a href="chapter8.xhtml#fig8-12">Figure 8-12</a>, you would use the following function:</p>

<pre><code>void sendData(int a, int b)
{
digitalWrite(latch, LOW);
shiftOut(data, clock, MSBFIRST, b); // For TPIC #2
shiftOut(data, clock, MSBFIRST, a); // For TPIC #1
digitalWrite(latch, HIGH);
}
</code></pre>

<p class="TX">To add one or more additional shift registers, just add more parameters and <samp class="SANS_TheSansMonoCd_W5Regular_11">shiftOut()</samp> functions, one for each extra register. You’ll use multiple TPIC6B595s in the following project, along with a new type of LED.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-61"/><samp class="SANS_Futura_Std_Bold_B_11">Piranha-Style LEDs</samp></h2>
<p class="TNI">There’s an incredible range of LEDs available on the market, from tiny surface-mount LEDs to those large enough to serve as part of an automotive headlight. One example in between these two is the compact yet very bright Piranha-style LED; its through-hole packaging makes it easy to use. <a href="chapter8.xhtml#fig8-13">Figure 8-13</a> shows a pair of Piranha LEDs.</p>
<figure class="IMG"><img alt="A PHOTO OF TWO PIRANHA LEDS ON A SOLDERLESS BREADBOARD" class="img8" id="fig8-13" src="../images/fig8-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-13: Two Piranha LEDs</samp></p></figcaption>
</figure>
<p class="TX">Each LED has four legs, two anodes, and two cathodes. The two anode pins are electrically connected to each other, as are the two cathode pins. The anode side has the corner cut off at the bottom left, as well as a larger metallic surface compared to the cathode side. <a href="chapter8.xhtml#fig8-14">Figure 8-14</a> shows the schematic symbol for Piranha LEDs.<span aria-label=" Page 125. " epub:type="pagebreak" id="pg_125" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC SYMBOL FOR PIRANHA LEDS" class="img3" id="fig8-14" src="../images/fig8-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-14: The schematic symbol for Piranha-style LEDs</samp></p></figcaption>
</figure>
<p class="TX">When used alone, these LEDs operate safely at 20 mA of current at around 2 to 2.2 V DC. For the next project, you’ll use them in groups of four each, organized in series (rather than parallel to each other). In this configuration, each group of four LEDs will require 9 V DC power and a 47 Ω resistor to maintain the required current and a high brightness.</p>
<p class="TX">To calculate the required resistor to use with LEDs in series, you use formula R = (V<sub>s</sub> <span class="symbol">−</span> V<sub>f</sub>) / I<sub>f</sub> , where V<sub>s</sub> is the power supply voltage, V<sub>f</sub> is the forward voltage (recommended operating voltage) of the LEDs, and I<sub>f</sub> is the recommended operating current for the LEDs. For the following project, you’d use 8 V at 20 mA as the LED forward voltage and operating current, with a 9 V supply. This gives you R = (9 V <span class="symbol">−</span> 8 V) / .02 A, which results in 50 Ω. We don’t have a 50 Ω resistor, so 47 Ω is the nearest choice.</p>
<p class="HeadProject"><span id="h1-62"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #27: Creating a Giant Seven-Segment LED Display</samp></p>
<p class="TNI">Multiple TPIC6B595s work well to drive large numbers of LEDs. In this project, you’ll build one or more seven-segment LED displays to create large numerical displays you can use for various purposes. For instance, you might use them to indicate various data generated with an Arduino project, such as temperature, an event count, or time.</p>
<p class="TX">To construct a single-digit display, you’ll need the following parts. For a larger display, multiply all parts other than the Arduino by the number of digits you’d like to create. This project shows you how to use four digits at once, so multiply by four if you’d like to follow the example exactly. For this project, use the PCB rather than a breadboard.</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">Assorted jumper wires</li>
<li class="BL">A 9 V power supply or wall wart with DC plug</li>
<li class="BL">A TPIC6B595 shift register</li>
<li class="BL">A 20-pin IC socket</li>
<li class="BL">A 0.1 µF capacitor</li>
<li class="BL">Thirty-two 5 mm Piranha-style LEDs</li>
<li class="BL">Eight 47 Ω, 0.25 W, 1 percent resistors</li>
<li class="BL">Four 3-contact 5.08 mm terminal blocks</li>
<li class="BL">A PCB mount DC socket</li>
<li class="BL">The Project #27 PCB</li>
</ul>
<p class="TX"><a href="chapter8.xhtml#fig8-15">Figure 8-15</a> shows the project’s schematic.<span aria-label=" Page 126. " epub:type="pagebreak" id="pg_126" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #27, SHOWING SHIFT REGISTER CONTROL OF EIGHT GROUPS OF PIRANHA LEDS" class="img1" id="fig8-15" src="../images/fig8-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-15: The schematic for Project #27</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 127. " epub:type="pagebreak" id="pg_127" role="doc-pagebreak"/>As you can see, the TPIC6B595 has “low-side” outputs. When an output is activated, the current starts from the power supply, goes through the items to be controlled, and then passes through the shift register DRAIN pins and out via GND.</p>
<section aria-labelledby="sec4" epub:type="division">
<h3 class="H2" id="sec4"><span id="h2-14"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Single-Digit Display</samp></h3>
<p class="TNI"><a href="chapter8.xhtml#fig8-16">Figure 8-16</a> shows the simple PCB layout.</p>
<figure class="IMG"><img alt="AN UNPOPULATED PCB FOR ONE DISPLAY DIGIT" class="img5" id="fig8-16" src="../images/fig8-16.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-16: The unpopulated PCB for one digit</samp></p></figcaption>
</figure>
<p class="TX">Always start by connecting the lowest-profile components: the resistors, the IC socket, the LEDs, and, finally, the DC socket and terminal blocks. Don’t be tempted to insert all the LEDs at once and then turn the PCB over, as some of the LEDs may come loose or fall out. Instead, solder them in one at a time. Orient all the LEDs with the anodes on the left and cathodes on the right (the left side of the PCB is the one with the DC socket). Once completed, your board should resemble the example shown in <a href="chapter8.xhtml#fig8-17">Figure 8-17</a>.</p>
<figure class="IMG"><img alt="THE COMPLETED PCB FOR ONE DISPLAY DIGIT WITH ALL LEDS AND COMPONENTS SOLDERED IN, READY FOR USE" class="img5" id="fig8-17" src="../images/fig8-17.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-17: The completed PCB for one digit</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 128. " epub:type="pagebreak" id="pg_128" role="doc-pagebreak"/>Once you’ve set up the hardware, enter and upload the Project #27a sketch that follows, which demonstrates one digit (you can choose to build three more digits in the section <span class="Xref">“Four-Digit Display”</span>). After uploading the sketch, you’ll need to connect your Arduino and power supply to the PCB. With the PCB facing upward and the DC socket on your left, make the connections as described in <a href="chapter8.xhtml#tab8-1">Table 8-1</a>.</p>
<figure class="table">
<p class="TableTitle" id="tab8-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 8-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">PCB to Arduino Connections</samp></p>
<table class="table">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">PCB left side</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Arduino</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Clock</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D9</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Latch</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D8</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">GND</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">9V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Vin</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5V</samp></p></td>
</tr>
<tr>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Serial In</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">D10</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">Finally, connect a 9 V DC power supply to the DC socket on the PCB. The Arduino is powered by the 9 V supply via the Vin pin and feeds back 5 V to the display board to power the shift register. The display should count from zero to nine; then again with a decimal point beside each numeral, as shown in <a href="chapter8.xhtml#fig8-18">Figure 8-18</a>; and finally repeat.</p>
<figure class="IMG"><img alt="AN EXAMPLE PHOTO OF ONE DIGIT, DISPLAYING THE NUMBER THREE WITH THE DECIMAL POINT ON" class="img1" id="fig8-18" src="../images/fig8-18.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-18: Example display board output</samp></p></figcaption>
</figure>
<p class="TX">Because of the incredible brightness of the LEDs, I set the supply voltage to 7 V DC before taking the photo in <a href="chapter8.xhtml#fig8-18">Figure 8-18</a> for a clearer picture. Your display should be much brighter when operating at its designated 9 V DC.</p>
<p class="TX"><span aria-label=" Page 129. " epub:type="pagebreak" id="pg_129" role="doc-pagebreak"/>Each segment of the digit consists of 28 Piranha LEDs, plus 4 more for the decimal point, driven by an output on the TPIC6B595. Therefore, you could consider the digit to be made up of seven LEDs, plus one more for the decimal point. These are controlled via the TPIC6B595’s outputs in the same method as the relay board described in Project #26.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-27a"/>

<pre><code>// Project #27a - Single giant seven-segment LED displays

<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #define latch 8 // Latch RCK pin
#define clock 9 // Clock SRCK pin
#define data 10 // Data SERIN pin

int digits[] = {B00111111,  // 0
              <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> B00000110,  // 1
                B01011011,  // 2
                B01001111,  // 3
                B01100110,  // 4
                B01101101,  // 5
                B01111101,  // 6
                B00000111,  // 7
                B01111111,  // 8
                B01100111}; // 9

void sendNumber(int a, boolean point)
{
    if (point == false)
    {
        digitalWrite(latch, LOW);
        shiftOut(data, clock, MSBFIRST, digits[a]);
        digitalWrite(latch, HIGH);
    } else if (point == true)
    {
        digitalWrite(latch, LOW);
      <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> shiftOut(data, clock, MSBFIRST, digits[a]|B10000000);
        digitalWrite(latch, HIGH);
    }
}

void setup()
{
    pinMode(latch, OUTPUT);
    pinMode(clock, OUTPUT);
    pinMode(data, OUTPUT);
}

void loop()
{
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> for (int a = 0; a &lt; 10; a++)
    {
        sendNumber(a,false);
        delay(1000);
    }
<span aria-label=" Page 130. " epub:type="pagebreak" id="pg_130" role="doc-pagebreak"/>  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> for (int a = 0; a &lt; 10; a++)
    {
        sendNumber(a,true);
        delay(1000);
    }
}
</code></pre>

<p class="TX">The sketch first defines the Arduino digital pins used for connecting to the shift register’s Latch, Clock, and Data pins <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. For the array of 8 bytes <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, each byte represents the eight outputs that are used to control the segments on the display. For example, the number 1 is represented in binary as <samp class="SANS_TheSansMonoCd_W5Regular_11">B00000110</samp>, as you want to turn on the second and third segments of the display to display 1.</p>
<p class="TX">The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">sendNumber()</samp> function sends the requisite data to display each digit to the shift register, which then sets the appropriate outputs. This function accepts the digit to display and accepts <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> as the second parameter, which is used to turn the decimal point on or off. If the decimal point is required, the sketch uses the OR function <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> (as in <span class="Xref">Project #7 in <a href="chapter2.xhtml">Chapter 2</a></span>) to turn on the most significant bit of the shift register (bit 7), which controls DRAIN7.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> function sets the required digital output pins. Finally, the sketch demonstrates the display by counting from zero to nine and back again <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and then again with the decimal point turned on <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>.</p>
<p class="TX">You now have a large, impressive numerical LED display that can be seen from quite a distance. If the LEDs are too bright for your liking, you can increase the value of the resistors, perhaps to 180 or 270 Ω. Be sure to use 0.25 W (1/4 W) resistor types.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H2" id="sec5"><span id="h2-15"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Four-Digit Display</samp></h3>
<p class="TNI">You can build and use multiple display boards for larger numerical projects. In this example, you’ll use four boards to display numbers of up to four digits. You might use this to display data or as a large, bright clock.</p>
<p class="TX">Construct a second, third, and fourth board just as you did in the previous section, with one difference: these new boards won’t need the DC socket, as the first display board will act as your power source. Once the extra boards are assembled, connect them by bridging the terminal blocks on each side to each other. The matching labels on the rear of the display boards, as shown in <a href="chapter8.xhtml#fig8-19">Figure 8-19</a>, will help you do so.</p>
<figure class="IMG"><img alt="A PHOTO SHOWING THE WIRING BETWEEN TWO DIGIT PCBS" class="img3" id="fig8-19" src="../images/fig8-19.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-19: The rears of two display boards</samp></p></figcaption>
</figure>
<p class="TX">Next, enter and upload the Project #27b demonstration sketch. Once the upload completes, connect the Arduino to the leftmost display board and connect the 9 V power supply. The display boards should show random four-digit numbers, with random placement of the decimal point, as shown in <a href="chapter8.xhtml#fig8-20">Figure 8-20</a>.<span aria-label=" Page 131. " epub:type="pagebreak" id="pg_131" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PHOTO OF THE FOUR DIGITS IN OPERATION, SHOWING THE VALUE 634.1" class="img8" id="fig8-20" src="../images/fig8-20.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-20: The four display boards operating at 7 V DC</samp></p></figcaption>
</figure>
<p class="TX">Let’s see how this works:</p>
<span id="pro-27b"/>

<pre><code>// Project #27b - Four giant seven-segment LED displays

#define latch 8 // Latch RCK pin <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
#define clock 9 // Clock SRCK pin
#define data 10 // Data SERIN pin

int digits[] = {B00111111,   // 0 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
                B00000110,   // 1
                B01011011,   // 2
                B01001111,   // 3
                B01100110,   // 4
                B01101101,   // 5
                B01111101,   // 6
                B00000111,   // 7
                B01111111,   // 8
                B01100111};  // 9

void sendNumbers(int numbers[], int dp)
{
    digitalWrite(latch, LOW);
    for (int i = 0; i &lt; 4; i++)
    {
        int dig_idx = numbers[i]; <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
        if (dp == i) {
        // Display the digit
           shiftOut(data, clock, MSBFIRST, digits[dig_idx] | B10000000); <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
        } else {
            shiftOut(data, clock, MSBFIRST, digits[dig_idx]);
        }
    }
    digitalWrite(latch, HIGH);
}

void setup()
{
    randomSeed(analogRead(0)); <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
    pinMode(latch, OUTPUT);
    pinMode(clock, OUTPUT);
    pinMode(data, OUTPUT);
}

<span aria-label=" Page 132. " epub:type="pagebreak" id="pg_132" role="doc-pagebreak"/>void loop()
{
    int numbers[4] = {random(0, 10), random(0, 10), random(0, 10), random(0, 10)}; <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
    sendNumbers(numbers, random(0, 3)); <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
    delay(1000);
}</code></pre>

<p class="TX">The sketch for four boards has a few differences from the Project #27a sketch to make using multiple displays easier. Once again, it defines the Arduino digital pins used for connecting to the shift register’s Latch, Clock, and Data pins <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and defines the array of 8 bytes <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> that represents the eight outputs used to control the segments on the display.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">void sendNumbers()</samp> function accepts two parameters: an array of four numbers (one for each display board) and an integer that represents on which boards to display the decimal point. The sketch checks for this <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If the parameter is 1, the required bit for the decimal point display is included in the byte sent to the shift register <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">As you’re displaying random numbers, the generator is seeded with the analog input data <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, and then the array for numbers to be displayed is also filled with random numbers <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> and sent to the display boards <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. Finally, the sketch includes a delay before displaying more random numbers.</p>
<p class="TX">You can display all sorts of numerical data with these boards. You might also add your own characters by adding more elements to the digit arrays. For example, a degree symbol for temperature would be as follows:</p>

<pre><code>B01100011 // Binary representation of °
</code></pre>

<p class="TX">For a challenge, pair up four display boards with an Arduino and a real-time clock module to make a large, bright clock. You might add a thermometer as well. I hope you enjoy using these display boards as much as I enjoyed designing them.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h1-63"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">In this chapter, you learned how to control currents and voltages using the TPIC6B595 shift register, a more capable alternative to the popular 74HC595. You can now control items that draw more current than an Arduino’s digital I/O pin can safely handle. You also learned how to use bright Piranha-style LEDs for excellent indicators.</p>
<p class="TX">In the next chapter, you’ll use MP3 player modules to create digital music players and sound boards for various purposes.</p>
</section>
</section>
</body>
</html>