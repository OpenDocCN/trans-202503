- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UNIT AND INTEGRATION TESTING WITH AUTOTEST
  prefs: []
  type: TYPE_NORMAL
- en: '*. . . to learn is not to know; there are the learners and the learned. Memory
    makes the one, philosophy the other.'
  prefs: []
  type: TYPE_NORMAL
- en: —Alexandre Dumas, The Count of Monte Cristo*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing is important. All developers test their software to one degree or another;
    otherwise, they don’t know if the product meets the design criteria. On one end
    of the spectrum, the author compiles and runs the program. If it presents the
    general interface they envisioned, they call it done. On the other end, the author
    writes a suite of tests that attempt to exercise as much of the code as possible
    under varying conditions, validating that the outputs are correct for the specified
    inputs. Straining to reach the rightmost point on this line, we find the person
    who literally writes tests first and then adds and modifies code iteratively until
    all the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I won’t attempt to expound on the virtues of testing. I assume
    every developer agrees that *some* level of testing is important, whether they
    are a compile-run-and-ship sorta person or a bona-fide test-driven person. I also
    assume every developer has some level of aversion to testing that lies somewhere
    along this spectrum. Therefore, our goal here is to let someone else do as much
    of the work of testing as possible. In this case, “someone else” means the Autotools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Chapter 3](ch03.xhtml), we added a test to our handcoded makefiles
    for Jupiter. The output of the test was completely controlled by the `make` script
    we put into *src/Makefile*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When we moved on to Autoconf in [Chapters 4](ch04.xhtml) and [5](ch05.xhtml),
    not much changed. The output was still controlled by our handwritten `make` script.
    We just moved it into *src/Makefile.in*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.xhtml), however, we dropped our handcoded makefiles and
    templates in favor of Automake’s much more terse *Makefile.am* files. Then we
    had to figure out how to shoehorn our handwritten test into `automake` script.
    In doing so, we got a bit of an upgrade on the test output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you’re running this code on your terminal with a reasonably late version
    of Automake, you’ll even see colored test output.
  prefs: []
  type: TYPE_NORMAL
- en: Every test added to the `TESTS` variable in our *src/Makefile.am* template generates
    a `PASS:` or `FAIL:` line, and the summary values account for all of them. This
    is because Automake has a nice built-in testing framework driven by the `TESTS`
    variable. If you need to build any of the files specified in `TESTS`, you can
    just create a rule for it as we did for the trivial driver script (*greptest.sh*)
    that we created. If your test program needs to be built from sources, you can
    use a `check_PROGRAM` variable. One minor problem with Automake’s testing framework
    is that if tests are found in multiple directories, you see multiple such displays
    during `make check`, which can be a little annoying, especially when using `make
    -k` (continue in the face of errors), because it may not occur to you to scroll
    up to see the output of earlier, possibly failed tests.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `TESTS` variable, if you set the `XFAIL_TESTS` variable to
    a subset of the tests listed in `TESTS`, you might also see some output in the
    `XFAIL:` and `XPASS:` lines. These are tests that are expected to fail. When such
    tests pass, they’re listed in the `XPASS:` line as an *unexpected pass*. When
    they fail, they’re listed in the `XFAIL:` line as an *expected failure*.
  prefs: []
  type: TYPE_NORMAL
- en: A test returning a shell code of 77 increases the count in the `SKIP:` line,
    and 99 increases the count in the `ERROR:` line. I’ll provide more detail about
    special shell codes returned by tests later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have guessed by now, Autoconf also includes a testing framework,
    called *autotest*, that provides all of the infrastructure required to allow you
    to simply and easily specify a test that exercises some portion of your code.
    The results are displayed in a consistent and easy-to-comprehend manner, and failed
    tests are easy to reproduce in an isolated fashion, complete with a built-in debugging
    environment. Almost makes you want to write tests, doesn’t it? The fact is, a
    well-designed testing framework, like any other well-designed tool, is a joy to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, autotest is portable—as long as you write your portion of the
    tests using portable script or code, the entire test suite will be 100 percent
    portable to any system on which you can run your `configure` script. That’s not
    as hard as it sounds. Often the shell script you have to write amounts to running
    a command, and the code behind the command is written using Autotools-provided
    portability features and is generated using Autotools-provided build processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For several years, autotest has been documented as being “experimental.” Regardless,
    its base functionality hasn’t changed much during those years, and Autoconf uses
    it to test itself, as we saw in [Chapter 1](ch01.xhtml). So, it’s time to stop
    worrying about whether it’s going to change and just start using it for its intended
    purpose: to make testing less of a chore for software developers, who—let’s face
    it—really just want to write code and let someone else worry about testing.'
  prefs: []
  type: TYPE_NORMAL
- en: Being the rational creatures that we are, we can’t deny that testing is important.
    What we can do is make use of good tools that allow us to focus on our code, letting
    frameworks like autotest worry about ancillary issues like result formatting,
    success/failure semantics, data gathering for user-submitted bug reports, and
    portability. As we’ll see throughout this chapter, this is the value that autotest
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: In the spirit of transparency, I’ll admit it’s difficult to justify using autotest
    for small test suites like Jupiter’s. The testing harness built into Automake
    is more than adequate for most small project needs. Larger projects—such as Autoconf
    itself, with its 500-plus unit and integration tests, which test functionality
    spread out over its entire project directory structure, and even installed components—are
    a different matter entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Autotest Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are three phases to the files consumed and generated by autotest. The
    first phase is what the *GNU Autoconf Manual* calls the “prep for distribution”
    phase. The second phase occurs when `configure` is executed, and the third phase
    happens during execution of the test suite. Let’s take each of these phases in
    turn.
  prefs: []
  type: TYPE_NORMAL
- en: The first phase, which happens during building of the distribution archive,
    is essentially the process of generating the executable test program that can
    be run by users on their systems. It may seem a bit strange that this process
    must be done during the building of a distribution archive; however, Autoconf
    is required to be installed on any system that needs to generate this program,
    so the `testsuite` program must be built when the distribution archive is built
    so that it may be included in the archive for the user. While the `dist` or `distcheck`
    targets are being made, `configure` (and `make check`, when using `distcheck`)
    is executed; `make check` encapsulates rules to rebuild the test program from
    sources using `autom4te`—the Autoconf caching `m4` driver. The test program is
    built during execution of the `dist` target by virtue of having it included in
    the Automake `EXTRA_DIST` variable, which I’ll talk about near the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-1](ch09.xhtml#ch09fig1) shows the flow of data from maintainer-written
    source files to the `testsuite` program during `make dist` (or `make distcheck`).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Data flow from maintainer-written input files to the `testsuite`
    program*'
  prefs: []
  type: TYPE_NORMAL
- en: The file *testsuite.at*, found at the top of the second column of the diagram,
    is the main test file written by a project author. This is actually the only maintainer-written
    file required by autotest. Exactly like *configure.ac*, this file contains shell
    script sprinkled with M4 macro definitions and invocations. This file is passed
    through the M4 macro processor, with `autom4te` acting as the driver for `m4`,
    to generate the `testsuite` program at the top of the last column, which is pure
    shell script. This process occurs during execution of `autom4te`, which is driven
    by `make check` reading the makefile generated from a *Makefile.in* or *Makefile.am*
    file that we write. The prep-for-distribution concept comes from the fact that
    the `check` target is executed during `make distcheck` (which, of course, builds
    the distribution archive); the `testsuite` program is added to the distribution
    archive during this process. It’s built during `make dist`, which does not execute
    `make check`, because all files listed in `EXTRA_DIST` must be built before they
    can be included in the distribution archive.
  prefs: []
  type: TYPE_NORMAL
- en: Details like this are normally hidden from us by the Autotools, but as autotest
    is still considered experimental—meaning, not fully integrated into the Autotools
    suite—the responsibility for some of this additional infrastructure is relegated
    to us, the maintainers. We’ll cover these details shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The Autoconf manual suggests that test suite authors may put individual sets
    of related tests, called *test groups*, into separate *.at* files. The *testsuite.at*
    file, then, contains only a series of `m4_include` directives, including each
    of these group-specific *.at* files. Therefore, M4 inclusion is the mechanism
    by which the optional *test-1.at* through *test-*`N`*.at* are gathered together
    into *testsuite.at* for processing by M4.
  prefs: []
  type: TYPE_NORMAL
- en: The *package.m4* and *local.at* files are optional maintainer-written (or generated)
    input files that are automatically included by `autom4te` when processing *testsuite.at*,
    if they’re found. The former contains basic information about the test suite that’s
    displayed on the console and embedded in bug reports generated by the test suite.
    The latter, the manual suggests, is an optional mechanism we may choose to use
    that can help us keep *testsuite.at* uncluttered with global definitions, non-group-related
    tests, and helper macro definitions and shell functions that may be used by the
    actual tests. We’ll discuss the exact contents of these files later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When a `configure` script is instrumented for autotest, the configuration process
    generates additional, autotest-related artifacts. [Figure 9-2](ch09.xhtml#ch09fig2)
    shows what happens graphically during the configuration process, relative to autotest.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: The flow of data during *`configure`* while generating test-related
    templates*'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 2](ch02.xhtml) that `config.status` drives the file-generation
    portion of the configuration process. When a *configure.ac* file is set up for
    autotest, `config.status` generates *atconfig*—a shell script that’s designed
    to be sourced by `testsuite` when it’s executed.^([1](footnote.xhtml#ch09fn1))
    It contains source- and build-tree variables such as `at_testdir`, `abs_builddir`,
    `abs_srcdir`, `at_top_srcdir`, and so on, in order to facilitate access to files
    and products in the source and build trees during test suite execution.
  prefs: []
  type: TYPE_NORMAL
- en: The test author may also choose to create a template file called *atlocal.in*
    that allows them to pass additional Autoconf and project-specific configuration
    variables through to the test environment, as needed. The product of this template
    is *atlocal*—also a shell script that’s designed to be sourced by `testsuite`,
    if it’s present. If you choose to write *atlocal.in*, you must add it to the list
    of tags passed to an invocation of `AC_CONFIG_FILES` in *configure.ac*. We’ll
    see how this is done later as we export Jupiter’s `async_exec` flag to our test
    suite.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t confuse atlocal with local.at from [Figure 9-1](ch09.xhtml#ch09fig1).
    The atlocal file in [Figure 9-2](ch09.xhtml#ch09fig2), sourced by *`testsuite`*
    at runtime, is used to pass configuration variables into the test environment
    from *`configure`*, while the local.at file is written directly by the project
    maintainer and contains additional test code processed by *`autom4te`* when *`testsuite`*
    is generated.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-3](ch09.xhtml#ch09fig3) shows the flow of data during the execution
    of `testsuite`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: The flow of data during execution of the `testsuite` script*'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, `testsuite` sources *atconfig* and *atlocal* (if present)
    to access source- and build-tree information and other project-related variables,
    then executes the tests that were generated into it. As it does so, it creates
    a *testsuite.log* file containing verbose information on the execution of each
    test. What you see on the screen is a single line of text per test.^([2](footnote.xhtml#ch09fn2))
  prefs: []
  type: TYPE_NORMAL
- en: The `testsuite` program generates a directory called *testsuite.dir*. A separate
    subdirectory is created within this directory for each test. The test suite does
    not delete test-specific subdirectories for failed tests; we can use the contents
    of this directory structure to obtain details and to debug the problem. We’ll
    go into detail about what gets added to these directories shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The `testsuite` program may be executed by hand, of course, but it has to be
    generated first. The Autoconf manual suggests that the process of generating the
    `testsuite` program is best tied directly into the `check` target so that when
    `make check` is executed, `testsuite` will be generated (if it’s missing or out-of-date
    with respect to its dependencies) and then executed.
  prefs: []
  type: TYPE_NORMAL
- en: Since `testsuite` is added to the distribution archive, end users who run `make
    check` will merely execute the existing `testsuite` program, unless they’ve touched
    one of the files that `testsuite` depends on, in which case `make` will attempt
    to regenerate `testsuite`. Without Autoconf installed, this process would fail.
    Fortunately, it’s not generally in the user’s best interest to touch any of `testsuite`’s
    dependencies in the distribution archive.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring Up Autotest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since my goal here is to teach you how to use this framework, the approach I
    chose to take in configuring Jupiter for autotest was to incorporate the entire
    set of optional files shown in Figures 9-1 through 9-3\. This allows us to explore
    exactly how everything works together. While this approach is probably unwarranted
    for a project the size of Jupiter, it does work correctly, and it can always be
    pared down. I’ll show you at the end of this chapter just what you can delete
    to reduce the autotest input file set to the bare minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can write tests, we need to make *configure.ac* aware of our desire
    to use autotest. This is done by adding two macro invocations to *configure.ac*,
    as shown in [Listing 9-1](ch09.xhtml#ch09ex1).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.0
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1:* configure.ac: *Wiring autotest into* configure.ac'
  prefs: []
  type: TYPE_NORMAL
- en: The first of these two macros, `AC_CONFIG_TESTDIR`, tells Autoconf to enable
    autotest and specifies that the testing directory will be called *tests*. You
    may use a dot here to represent the current directory if you wish, but the *GNU
    Autoconf Manual* recommends that you use a separate directory for ease in managing
    test output files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The addition of `AC_CONFIG_TESTDIR` to* configure.ac *is actually the only
    change required to enable autotest in a project, though changes to makefiles and
    additional support files are required to make it useful and more automated. Interestingly,
    this important tidbit is not found anywhere in the manual, though it is implied
    rather subtly.*'
  prefs: []
  type: TYPE_NORMAL
- en: The second line is the standard Autoconf `AC_CONFIG_FILES` instantiating macro.
    I’m using a separate instance of it here to generate the test-related files from
    templates.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at what goes into each of these files. The first is a makefile for
    the *tests* directory that’s generated from an Autoconf *Makefile.in* template,
    which itself is generated from the Automake *Makefile.am* file that we need to
    write. In this makefile, we need to get `make check` to generate and execute `testsuite`.
    [Listing 9-2](ch09.xhtml#ch09ex2) shows how we might write *tests/Makefile.am*
    so that Automake and Autoconf will generate such a makefile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2:* tests/Makefile.am: *Getting* `make check` *to build and run*
    `testsuite`'
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin dissecting this file, I should mention that these contents were
    taken from Section 19.4 of the *GNU Autoconf Manual*. I’ve tweaked them a bit,
    but essentially these lines comprise a portion of the recommended way to tie autotest
    into Automake. We’ll complete this file as we discuss additional features and
    requirements of autotest-oriented `make` script.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This lack of more complete integration, along with the fact that Autoconf
    can be configured to use several different test drivers (DejaGNU, for instance),
    is likely what keeps autotest in experimental mode. While Libtool, for instance,
    has slowly migrated toward a position of complete integration with Automake, autotest
    still requires some fiddling to properly integrate into a project build system.
    Nevertheless, once the requirements are understood, proper integration is pretty
    simple. Additionally, as we’ve seen, Automake has its own test framework, which
    gives Automake maintainers little incentive to fully support autotest.*'
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 9-2](ch09.xhtml#ch09ex2) is pretty straightforward when
    taken a line at a time—four variables and four rules. The variables are not strictly
    necessary, but they make for shorter command lines and less duplication in rules
    and commands. The `TESTSUITE` variable at ➊ simply keeps us from having to prefix
    `testsuite` with `$(srcdir)/` everywhere we use it.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `testsuite` program is distributed, so it should be built in the source
    tree. Files that are destined to end up in the distribution archive should be
    found in the source directory structure. Additionally, the content of such built
    and distributed files should be the same, regardless of differences in configuration
    options used by the original archive creator, or the end user.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `TESTSOURCES` variable at ➋ allows us to easily add additional tests to
    the makefile. Each *.at* file becomes a dependency of `testsuite` so that when
    one of them is changed, `testsuite` is rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: The `AUTOM4TE` variable at ➌ allows us to wrap execution of `autom4te` with
    the Automake `missing` script, which prints a nicer error message if `autom4te`
    is not found. This happens when an end user who doesn’t have the Autotools installed
    does something that requires `testsuite` to be rebuilt—such as modify *testsuite.at*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We can’t use Automake’s `maintainer-rules` option to avoid writing these rules
    into distribution archive Makefiles because we must manually write these rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `AUTOTEST` variable at ➍ appends the `--language=autotest` option to the
    `autom4te` command line. *There is actually no program in the Autoconf package
    called* autotest. If we had to pin down the definition of such a tool, it would
    be the contents of this `AUTOTEST` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `check-local` rule at ➎ ties execution of `testsuite` into Automake’s `check`
    target. Automake standard targets like `check` have a `-local` counterpart that
    you can use to supplement the functionality generated by Automake for the base
    target. If Automake sees a rule with the target `check-local` in *Makefile.am*,
    it generates a command to run `$(MAKE) check-local` under the generated *Makefile*’s
    `check` rule. This gives you a hook into the standard Automake targets. We’ll
    cover such hooks in greater detail in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml),
    where we’ll use them extensively in our efforts to convert a real-world project
    to use an Autotools-based build system.
  prefs: []
  type: TYPE_NORMAL
- en: The `check-local` target depends on *atconfig*, *atlocal*, and `$(TESTSUITE)`.
    Recall from [Figure 9-3](ch09.xhtml#ch09fig3) that *atlocal* is a script sourced
    by `testsuite`. It’s generated directly by the invocation of `AC_CONFIG_FILES`
    that we added to *configure.ac* in [Listing 9-1](ch09.xhtml#ch09ex1), so we’ll
    cover its contents shortly. The command for this rule executes `'$(TESTSUITE)'`
    with `$(TESTSUITEFLAGS)` as a command line argument. The contents of `TESTSUITEFLAGS`
    are user defined, allowing the end user to run `make check TESTSUITEFLAGS=-v`,
    for instance, to enable verbose output from `testsuite` while making targets that
    invoke `testsuite`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `TESTSUITEFLAGS` to target specific test groups by number (for
    instance, `TESTSUITEFLAGS=2 testsuite`) or, if you’ve written your tests using
    the `AT_KEYWORDS` macro, by tag name. In addition, several command line options
    are available for the generated `testsuite` program. You can find complete documentation
    for `testsuite` options in Section 19.3 of the *GNU Autoconf Manual*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The single quotes around *`$(TESTSUITE)`* allow the path in *`TESTSUITE`*
    to contain spaces, if needed. This technique can and should be used in all makefiles
    to handle whitespace in paths. I’ve generally ignored the concept of whitespace
    in paths within this book in order to reduce the noise in the listings, but you
    should be aware that makefiles can be written to properly handle whitespace in
    all filenames and paths—those in targets and dependencies, as well as those in
    the commands associated with rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned previously that the *atconfig* script, also sourced by `testsuite`,
    is generated automatically beneath the covers by `AC_CONFIG_TESTDIR`. The problem
    is, even though `config.status` understands how to build this file, Automake doesn’t
    know anything about it because it’s not listed directly in any of the instantiating
    macro invocations in *configure.ac*, so we need to add an explicit rule to *Makefile.am*
    to create or update it. This is where the `atconfig` rule at ➏ in [Listing 9-2](ch09.xhtml#ch09ex2)
    comes in. The `check-local` rule depends on it, so its commands will be executed
    if *atconfig* is missing or older than its dependency, `$(top_builddir)/config.status`,
    when `make check` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The command in the rule for generating `$(srcdir)/package.m4` at ➐ (note there
    is only one command here) merely writes text into the target file if the file
    is missing or older than *configure.ac*. This is an optional input file (see [Figure
    9-1](ch09.xhtml#ch09fig1)), the contents of which are actually required by autotest
    in some form. Several M4 macros must be defined in the input data that is processed
    by autotest to create a test suite, including `AT_PACKAGE_NAME`, `AT_PACKAGE_TARNAME`,
    `AT_PACKAGE_VERSION`, `AT_PACKAGE_STRING`, `AT_PACKAGE_BUGREPORT`, and `AT_PACKAGE_URL`.
    These variables may be defined directly in *testsuite.at* (or any of the subfiles
    included by that file), but it makes more sense to generate this information from
    values already found in *configure.ac* so we don’t have to maintain two sets of
    the same information. This is the very reason why *package.m4* is included automatically
    by `autom4te` if it’s found while processing *testsuite.at*.
  prefs: []
  type: TYPE_NORMAL
- en: But wait—why not use `AC_CONFIG_FILES` to have `configure` generate this file?
    All we’re doing is generating a text file that contains configuration variables,
    and that sounds like exactly what `AC_CONFIG_FILES` is for. The problem is, `AC_CONFIG_FILES`
    and the other instantiating macros always generate files into the build tree,
    and *package.m4* must end up in the source tree in order to be added to the distribution
    archive (not because it’s part of any build or execution process the user may
    instigate, but because it’s part of the source code for `testsuite`). Perhaps
    the full integration of autotest, at some point in the future, will result in
    the ability to request the instantiating macros to generate files into the source
    tree. Until then, this is what we have to work with.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth and final rule, `$(TESTSUITE)`, at ➑, generates `$(srcdir)/testsuite`
    using the `$(AUTOTEST)` command. Because `$(TESTSUITE)` is a dependency of `check-local`,
    it’ll get built if it’s not up-to-date. The `autom4te` program, when executed
    in *autotest mode*, accepts the `-I` option for specifying include paths for *.at*
    files that may be included by *testsuite.at* or any of its inclusions. It also
    accepts the `-o` option for specifying the output file, `testsuite`.^([3](footnote.xhtml#ch09fn3))
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve added *`$(AM_V_GEN)`* in front of the commands of the last two rules
    in [Listing 9-2](ch09.xhtml#ch09ex2) to allow my custom rules to tie into the
    Autotools’ silent build rules system. Any command prefixed with *`$(AM_V_GEN)`*
    will cause the normal command output to be replaced with *`GEN`* `target` when
    building with silent rules enabled. See Section 21.3 of the GNU Automake manual
    for more details on this and other variables that affect build output when building
    with silent rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: Taken as a whole, all of this allows us to run `make check` at the command prompt
    to build (if needed) and execute `$(srcdir)/testsuite`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There’s a bit more we need to do in this* Makefile.am *file to fully integrate
    autotest functionality into Automake. We’ll add some additional administrative
    rules and variables later in this chapter. For clarity at this point, I limited
    the content to just what we need to build and run the test suite.*'
  prefs: []
  type: TYPE_NORMAL
- en: Well, we’ve created a new directory and added a new *Makefile.am*. By now, you
    should be automatically thinking about how this *Makefile.am* file is going to
    be called if we don’t link it into the top-level *Makefile.am* `SUBDIRS` variable.
    You’re absolutely correct—this must be our next step. [Listing 9-3](ch09.xhtml#ch09ex3)
    shows this modification to the top-level *Makefile.am* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3:* Makefile.am: *Adding the tests subdirectory*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I added tests last. This will almost always be the pattern for a directory
    such as* tests. *In order to test the system, most, if not all, of the other directories
    must be built first.*'
  prefs: []
  type: TYPE_NORMAL
- en: The second file in [Listing 9-1](ch09.xhtml#ch09ex1) is the *atlocal* shell
    script that’s automatically sourced by `testsuite`, if present, which may be used
    to pass additional configuration variables through to `testsuite`’s runtime environment.
    We’ll use this file in the Jupiter project to pass the `async_exec` flag through
    to `testsuite` so it may know if the program it’s testing has been configured
    with the *async-exec* feature enabled. [Listing 9-4](ch09.xhtml#ch09ex4) shows
    how this is done in *atlocal*’s template, *atlocal.in*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4:* tests/atlocal.in: *A template for generating* atlocal'
  prefs: []
  type: TYPE_NORMAL
- en: Now, this causes a small problem for us because `configure` is not yet exporting
    a substitution variable called `async_exec`. We wrote a shell script that uses
    a shell variable of this name back in [Chapter 5](ch05.xhtml), but recall we only
    used it to indicate whether we should invoke `AC_DEFINE` to generate the `ASYNC_EXEC`
    preprocessor definition into *config.h.in*. We now need to use `AC_SUBST` on this
    variable in order to generate an Autoconf substitution variable of the same name.
    [Listing 9-5](ch09.xhtml#ch09ex5) highlights the single-line addition to *configure.ac*
    required to make this happen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5:* configure.ac: *Making autoconf generate the `async_exec` substitution
    variable*'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last comment on [Listing 9-1](ch09.xhtml#ch09ex1): we could have simply
    added these files to the existing invocation of `AC_CONFIG_FILES` at the bottom
    of *configure.ac*, but using a separate invocation here keeps test-related items
    together. It also serves to illustrate the fact that `AC_CONFIG_FILES` may indeed
    be invoked multiple times within *configure.ac*, the results being cumulative.'
  prefs: []
  type: TYPE_NORMAL
- en: We now need to create a set of source *.at* files that can be used by `autom4te`
    to generate our test program. This set of files can be as simple as a single *testsuite.at*
    file or as complex as the diagram in [Figure 9-1](ch09.xhtml#ch09fig1), including
    *testsuite.at*, a set of test-group-specific *.at* files, and a *local.at* file.
    These files will contain autotest macro invocations mixed with simple or complex
    shell script, as required by your testing needs. We’ll start with a single line
    of autotest initialization code in a *tests/local.at* file, as shown in [Listing
    9-6](ch09.xhtml#ch09ex6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6:* tests/local.at: *Initialization code for `testsuite` can be
    added to a* local.at file'
  prefs: []
  type: TYPE_NORMAL
- en: The `AT_INIT` macro is required by `autom4te` to be found somewhere within the
    translation unit presented by *testsuite.at* and its inclusions. This single macro
    invocation expands into several hundred lines of shell script that define the
    basic testing framework and all of the ancillary boilerplate functionality associated
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create an empty *testsuite.at* file in the *tests* directory.
    We’ll add items to it as we progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the basis for generation and execution of the autotest framework
    in Jupiter. Every project that uses autotest will have to be configured in the
    manner we’ve shown so far. For smaller projects, some of the optional pieces may
    be omitted, the contents of which would then be combined directly into *testsuite.at*.
    We’ll discuss how to simplify when we’ve completed our exploration of autotest.
    For now, let’s give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the output of `configure` that our generated files were created
    in the *tests* directory, as expected. It also appears that the code generated
    by `AC_CONFIG_TESTDIR` has wired in the generation of the *tests/atconfig* file
    as a *command* tag, rather than as a simple template file, using `AC_CONFIG_COMMANDS`
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: We then see from the output of `make check` that `testsuite` was both built
    and executed. We can’t yet incorporate `testsuite` into a distribution archive
    from the `dist` or `distcheck` targets because we haven’t wired our autotest functionality
    into Automake. However, when we complete our changes at the end of this chapter,
    you’ll find that running `make check` against the contents of a distribution archive
    will not build `testsuite`, as it will have shipped with the archive (assuming
    we haven’t touched any of `testsuite`’s dependencies).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*One interesting item of note near the top of the *`make check`* output is
    highlighted by the lines starting with *`make[1]:`* and *`make[2]:`*, where *`make`*
    indicates it’s entering the jupiter/tests directory twice. This happens because
    of the *`check-local`* hook we added, where the *`check`* target recursively invokes
    *`$(MAKE) check-local`* as a command within the same directory.*'
  prefs: []
  type: TYPE_NORMAL
- en: Great, it works—with `make check` anyway. But it doesn’t do anything yet except
    print a few extra lines of text to the console. To make it do something useful,
    we need to add some tests. Therefore, our first task will be to move the original
    Automake-based `jupiter` execution test from *src/Makefile.am* into our autotest
    test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Autotest tests are bundled into sets called *test groups*. The purpose of a
    test group is to allow tests within a group to interact with each other. For example,
    the first test in a group may generate some data files used by subsequent tests
    within the same group.
  prefs: []
  type: TYPE_NORMAL
- en: Tests that interact with each other are harder to debug, and broken tests are
    harder to reproduce if they require other tests to run first. Multi-test groups
    are hard to avoid when striving for full coverage; the ideal is to have only one
    test per test group as much as possible. Where you just can’t do it, test groups
    exist to facilitate the required interaction. The crux of this facility is that
    *tests within the same test group are executed within the same temporary directory*,
    allowing initial tests to generate files that subsequent tests can then see and
    access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our single test will not suffer from these problems—mainly because we haven’t
    yet put much effort into testing Jupiter (and, if we’re honest with ourselves,
    there isn’t much actual code to test). Right now, when you execute `make check`,
    you see two sets of test output on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first set of tests (beginning at ➊) are executed in the *jupiter/src* directory.
    This is our original `grep`-based test where we check `jupiter`’s output against
    a pattern. As you can see, the basic test framework built into Automake is not
    bad. We’re hoping to improve on that framework with autotest. The second set of
    tests (beginning at ➋) are executed in the *jupiter/tests* directory and involve
    autotest.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Tests with AT_CHECK
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `grep`-based test we’ve been using in *src/Makefile.am* is a perfect example
    for use in the `AT_CHECK` macro provided by the autotest framework. Here are the
    prototypes for the `AT_CHECK` family of macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`AT_CHECK` executes *`commands`*, checks the returned status against *`status`*,
    and compares the output on `stdout` and `stderr` with the contents of the *`stdout`*
    and *`stderr`* macro arguments. If *`status`* is omitted, autotest assumes a successful
    status code of zero. If *`commands`* returns a status code to the shell that does
    not match the expected status code specified in *`status`*, the test fails. In
    order to ignore the status code of *`commands`*, you should use the special command
    `ignore` in the *`status`* parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless, there are a couple of status codes that even `ignore` will not
    ignore: a status code of 77 (skip) returned by *`commands`* will cause autotest
    to skip the rest of the tests in the current test group, while 99 (hard failure)
    will cause autotest to fail the entire test group immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like *`status`*, the *`stdout`* and *`stderr`* parameters appear to be optional,
    but looks can be deceiving. If you pass nothing in these arguments, this merely
    tells Autoconf that the test’s `stdout` and `stderr` output streams are expected
    to be empty. Anything else will fail the test. So how do we tell autotest we don’t
    want to check the output? As with *`status`*, we can use special commands in *`stdout`*
    or *`stderr`*, including those shown in [Table 9-1](ch09.xhtml#ch09tab1):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Special Commands Allowed in *`stdout`* and *`stderr`* Arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `ignore` | Do not check this output stream, but do log it to the test group’s
    log file. |'
  prefs: []
  type: TYPE_TB
- en: '| `ignore-no-log` | Do not check or log this output stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `stdout` | Log and capture the test’s `stdout` output to the file `stdout`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `stderr` | Log and capture the test’s `stderr` output to the file `stderr`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `stdout-nolog` | Capture the test’s `stdout` output to the file `stdout`,
    but do not log. |'
  prefs: []
  type: TYPE_TB
- en: '| `stderr-nolog` | Capture the test’s `stderr` output to the file `stderr`,
    but do not log. |'
  prefs: []
  type: TYPE_TB
- en: '| `expout` | Compare the test’s `stdout` output to the file `expout`, created
    earlier; log the differences. |'
  prefs: []
  type: TYPE_TB
- en: '| `experr` | Compare the test’s `stderr` output to the file `experr`, created
    earlier; log the differences. |'
  prefs: []
  type: TYPE_TB
- en: The *`run-if-fail`* and *`run-if-pass`* arguments allow you to optionally specify
    shell code that should be executed upon test failure or success, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`AT_CHECK_UNQUOTED` does exactly the same thing as `AT_CHECK`, except that
    it performs shell expansion on *`stdout`* and *`stderr`* first, before making
    the comparison with the output of *`commands`*. Since `AT_CHECK` doesn’t do shell
    expansion on *`stdout`* and *`stderr`*, it stands to reason that you need to use
    `AT_CHECK_UNQUOTED` if you reference any shell variables in the text of these
    parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Test Groups with AT_SETUP and AT_CLEANUP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `AT_CHECK` macro must be invoked between invocations of `AT_SETUP` and
    `AT_CLEANUP`, the pair of which define a test group and, therefore, the temporary
    directory from which the tests in the group are executed. The prototypes for these
    macros are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve got any experience with the *xUnit* family of unit test frameworks
    (JUnit, NUnit, CPPUnit, and so on), you’ve probably got a pretty strong notion
    of what the setup and cleanup (or teardown) functions should be used for. Usually
    a *setup* function runs some common code before each test in a test set, and a
    *cleanup* or *teardown* function executes some common code at the end of each
    test in the set.
  prefs: []
  type: TYPE_NORMAL
- en: Autotest is a bit different—there is no formal setup or teardown functionality
    shared by tests belonging to the same group (although this sort of functionality
    can be emulated with shell functions defined within the test group in *testsuite.at*,
    or in its included subfiles). As with *xUnit* frameworks, Autotest runs every
    test in total isolation, because every test runs within its own subshell. The
    only way a test can affect a subsequent test is by sharing the same test group
    and leaving filesystem droppings around for subsequent tests to examine and act
    upon.
  prefs: []
  type: TYPE_NORMAL
- en: '`AT_SETUP` accepts only one argument, *`test-group-name`*, which is the name
    of the test group that we’re starting, and this argument is required. `AT_CLEANUP`
    accepts no arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add the group setup and cleanup macro invocations, wrapping a call to
    `AT_CHECK`, to a new file, *tests/jupiter.at*, as shown in [Listing 9-7](ch09.xhtml#ch09ex7).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-7:* tests/jupiter.at: *Adding our first test group—attempt #1*'
  prefs: []
  type: TYPE_NORMAL
- en: Libtool adds a wrapper script in the *src* directory for any executables that
    use Libtool shared libraries. This wrapper script allows `jupiter` to find the
    uninstalled Libtool libraries it’s trying to use. As mentioned in [Chapter 7](ch07.xhtml),
    it’s a convenience mechanism that Libtool provides so we don’t have to jump through
    hoops to test programs using Libtool shared libraries before they’re installed.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that the *src/jupiter* script is executing the real `jupiter`
    program from *src/.libs/lt-jupiter*. Because `jupiter` displays its own location,
    based on its `argv[0]` contents, we need to expect it to print this path.
  prefs: []
  type: TYPE_NORMAL
- en: We then need to add an `m4_include` statement to our currently empty *testsuite.at*
    file in order to include *jupiter.at*, as shown in [Listing 9-8](ch09.xhtml#ch09ex8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-8:* tests/testsuite.at: *Including* jupiter.at *in* testsuite.at'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also want to add this new source file to our *tests/Makefile.am* file’s
    `TESTSOURCES` variable so it becomes a prerequisite of `testsuite`, as shown in
    [Listing 9-9](ch09.xhtml#ch09ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-9:* tests/Makefile.am: *Adding additional sources to `TESTSOURCES`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll follow this practice for every test we add to our test suite. In the
    end, the only thing in *testsuite.at* will be several invocations of `m4_include`,
    one for each test group. Executing this code renders the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Running `autoreconf` and `configure` was required only because we updated
    the* tests/Makefile.am *file. If we’d just touched an existing .at file, which
    is rebuilt by the `check` target in* tests/Makefile, *then neither `autoreconf`
    nor `configure` would have been necessary.*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll admit here that our single test failed because I deliberately coded the
    test incorrectly in order to show you what a failed test looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Although not obvious from the output, there is more than one *testsuite.log*
    file created by `testsuite` when tests fail. The first is a master *testsuite.log*
    file in the *tests* directory, which is always created, even when all tests pass,
    and is designed to be sent in bug reports to the project maintainer. There is
    also a log file of the same name in a separate numbered directory within the *tests/testsuite.dir*
    directory for failed tests. The name of each of these directories is the number
    of the test group that failed. The test group number can be seen in the output.
    While you only need the master *testsuite.log* file, since it contains the entire
    contents of all of the individual tests’ *testsuite.log* files, this file also
    contains a lot of other information about your project and the test environment
    that the maintainer would want to see but just gets in the way for our purposes
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see exactly how our test failed, let’s examine the contents of the *testsuite**.log*
    file left in the *tests/testsuite.dir/1* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First note that autotest writes, as often as possible, the related source line
    into the *testsuite.log* file. This isn’t a big win for us at this point, but
    if *testsuite.at* or its included files were long and complicated, you can see
    how this information could be very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, we see the argument we passed to the *`commands`* parameter of `AT_CHECK`,
    along with the number of the line at which this argument was passed to the macro
    in *jupiter.at*.
  prefs: []
  type: TYPE_NORMAL
- en: However, now things start to get a bit muddy. The entire point of the *`stdout`*
    and *`stderr`* arguments in `AT_CHECK` is to provide some comparison text for
    what is actually sent by the *`commands`* to these output streams. In accordance
    with the general Unix philosophy of not duplicating existing functionality, the
    autotest authors chose to use the `diff` utility to make these comparisons. The
    log lines from ➋ to ➌ (inclusive) show the *unified*^([4](footnote.xhtml#ch09fn4))
    output of the `diff` utility when comparing the *original* file (*/dev/null* since
    we passed no value in the *`stderr`* argument) to the *modified* file—the text
    sent to the `stderr` output stream during the attempt to execute *../src/jupiter*.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with unified `diff` output, a brief explanation is in
    order. The two lines starting at ➋ indicate the objects being compared. The original,
    or minus (`---`), line indicates the left side of the comparison, while the modified,
    or plus (`+++`), line indicates the right side of the comparison. Here, we’re
    comparing */dev/null* with a temporary file called */.../jupiter/tests/testsuite.dir/at-groups/1/stderr*
    that was used by autotest to capture the `stderr` stream during the attempt to
    execute *../src/jupiter*.
  prefs: []
  type: TYPE_NORMAL
- en: The next line, starting and ending with `@@`, is a *chunk* marker—`diff`’s way
    of telling us about a portion of the two files that does not match. There can
    be more than one chunk in the output displayed by `diff`. In this case, the entire
    output text is so short that only one chunk was required to show us the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers in the chunk marker represent two ranges, separated by a space.
    The first range starts with a minus (`-`) sign, indicating the range associated
    with the *original* file, and the second range starts with a plus (`+`) sign,
    indicating the range associated with the *modified* file. Here’s the line we’re
    currently discussing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A range is made up of two integer values separated by a comma (`,`) or a single
    value with a default second value of 1\. In this example, the range being compared
    starts at zero in the original file and is zero lines long, while the comparison
    range in the second file starts at line 1 and is one line long. These ranges are
    1-based, meaning line 1 is the first line in the file. Therefore, the first range
    specification, `-0,0`, is a special range that means there’s no content in the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines following the range specification contain the full text of these
    ranges, showing us the actual differences. The original file lines are printed
    first, each prefixed with a minus sign, and then the modified file lines are printed
    afterward, each prefixed with a plus sign. When there is enough content around
    the modified lines to do so, additional unprefixed lines are added before and
    after these lines, showing some context around the changes. In this case, the
    entire content of this section is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since the original file was empty, as indicated by the `-0,0` range in the chunk
    marker, there are no lines starting with minus. All we see is the one modified
    file line starting with a plus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, clearly these files are not the same—we expected nothing on the `stderr`
    stream, but we got some error text instead. The shell experienced an error attempting
    to execute *../src/jupiter*—it could not be found. If you try this at the shell
    prompt, you’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Obviously you should not do this from the* tests *directory, or any other
    directory that’s a sibling to the* src *directory, or it’ll actually find* jupiter
    *(if it’s been built) rather than print this error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put this line into a shell script called (arbitrarily) *abc.sh* and
    execute the script on the `bash` command line, you’ll see output that matches
    the format shown in *testsuite.log*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see at ➎ in *testsuite.log* that the shell returned a 127 status code,
    indicating an error of some sort. The value 127 is used by the shell to indicate
    execution errors—file not found or file not executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be complete, let’s also consider the lines between ➍ and ➎ for a moment.
    This is the unified `diff` output seen when comparing the text specified in `AT_CHECK`’s
    *`stdout`* argument with what was actually written to `stdout` by `jupiter` (actually
    the shell, since we know *../src/jupiter* was not found). In this case, we see
    that the minus text is the original comparison text we specified and the plus
    text is a single newline character, as this is what the shell sent to `stdout`.
    The chunk marker range specification, fully expanded, would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There was one line of text in each of the original and modified sources to be
    compared, but, as we can see by the output, the text in these sources was completely
    different.
  prefs: []
  type: TYPE_NORMAL
- en: '*So What Happened?*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This first attempt assumed that the `jupiter` program (or, rather, the Libtool
    wrapper script) is found at *../src/jupiter*, relative to the *tests* directory.
    While this assumption is true, I’ve already alluded to the fact that each test
    group is executed in its own temporary directory, so it makes perfect sense that
    this relative path is not going to work from another directory. Even if we figured
    out, by trial and error, how many parent directory references to use, it would
    be quite fragile; if we ran `testsuite` from a different directory, it would fail
    because it depends so intimately on running from a specific position relative
    to the `jupiter` program.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try a different tack. We’ll make use of the variables generated by `configure`
    into *atconfig*. One of them, `abs_top_builddir`, contains the absolute path to
    the top build directory. Therefore, we should be able to successfully reference
    `jupiter` from anywhere using `${abs_top_builddir}`*/src/jupiter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now we have another problem: `jupiter` prints its own path and we’ve just
    decided to obtain that path using a shell variable, so we’ll also need to change
    the comparison text to use this variable, as well. This change, however, causes
    yet another issue—we’ll need to change `AT_CHECK` to `AT_CHECK_UNQUOTED` if we
    expect that shell variable in `AT_CHECK`’s *`stdout`* parameter to be expanded
    before the macro makes the comparison. Let’s make these modifications by changing
    *jupiter.at* as shown in [Listing 9-10](ch09.xhtml#ch09ex10).'
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-10:* tests/jupiter.at: *Adding our first test group—attempt #2*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve switched to using `AC_CHECK_UNQUOTED`, and we’ve changed both the
    `jupiter` program path in the first argument and the comparison text in the third
    argument to use the `abs_top_builddir` variable we inherit from *atconfig*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The newline at the end of the *`stdout`* argument is intentional and explained
    shortly.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once again, I only had to run `make`. Even though our changes were dramatic,
    affecting even the macros we called in the test suite, remember that the entire
    test suite is generated from `make check`. The only time we need to execute `autoreconf`
    and `configure` is if we make changes to *configure.ac* or any of the templates
    from which it generates files used by `make check`, or if we make any changes
    to *Makefile.am* files.
  prefs: []
  type: TYPE_NORMAL
- en: This attempt had much better results, but what’s with that extra newline at
    the end of our comparison text in [Listing 9-10](ch09.xhtml#ch09ex10)? Well, remember
    what it is that we’re sending to `stdout` from `jupiter`. [Listing 9-11](ch09.xhtml#ch09ex11)
    provides a reminder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-11:* common/print.c: *What `jupiter` sends to `stdout`*'
  prefs: []
  type: TYPE_NORMAL
- en: The comparison text is an exact duplicate of what we expect to find on `jupiter`’s
    `stdout`, so we’d better be sure to include every character we write; the trailing
    newline is part of that data stream.
  prefs: []
  type: TYPE_NORMAL
- en: It’s probably a good idea at this point to remove the *src/Makefile.am* code
    that builds and runs the Automake version of the test. Change *src/Makefile.am*
    as shown in [Listing 9-12](ch09.xhtml#ch09ex12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-12:* src/Makefile.am: *The updated full contents of this file after
    removing tests*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All we did here was remove the test-related lines from the bottom half of
    the file.*'
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing vs. Integration Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the whole, the autotest version is not much better than what we had when
    our test was being executed by Automake’s test framework in *src/Makefile.am*.
    Adding new tests is, however, a bit simpler than what we’d have to do in *src/Makefile.am*’s
    `TESTS` variable. In fact, the only way the Automake version becomes simpler is
    if we actually write test programs and build them in `check` primaries. We might
    still have to build test programs in `check` primaries, but calling them and validating
    their output is trivial when using autotest.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re thinking that it feels like autotest is more attuned to system and
    integration testing than unit testing, you’re pretty close to the mark. Autotest
    is designed to test your project from the outside, but it’s not limited to such
    tests. Anything you can call from the command line can be a test, from autotest’s
    perspective. What autotest actually offers you is a framework for generating uniform
    test output, regardless of the kind of tests you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to unit testing that I’ve used for years involves writing test
    programs where the main source module of my test program literally `#include`s
    the *.c* file I’m testing. This gives me the option of calling static methods
    within the module under test and provides direct access to internal structures
    defined within that module.^([5](footnote.xhtml#ch09fn5)) This approach is pretty
    C oriented, but other languages have their own ways of performing the same sort
    of tricks. The idea is to create a test program that can reach into the private
    parts of a module and exercise functionality in small chunks. When you put those
    chunks together, you can feel confident that the individual chunks are working
    as designed; if there’s a problem, it’s probably in the way you glued them together.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add some unit testing to Jupiter by creating a test module that tests
    the functions in the *common/print.c* module. Create a file called *test_print.c*
    in the *common* directory that contains the content in [Listing 9-13](ch09.xhtml#ch09ex13).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-13:* common/test_print.c: *A unit test program for the print.c module*'
  prefs: []
  type: TYPE_NORMAL
- en: The first line uses the preprocessor to rename any calls to `printf` to `mock_printf`.
    The second line then uses the preprocessor to `#include` *print.c* directly into
    *test_print.c*. Now, any calls to `printf` inside of *print.c* will be redefined
    to call `mock_printf` instead—including any prototypes defined in system header
    files like *stdio.h*.^([6](footnote.xhtml#ch09fn6))
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to verify that the `print_it` function actually prints *Hello
    from* `argument`*!\n* and returns zero to the caller. We don’t need any output—a
    shell return code is sufficient for this test to indicate to the user that `print_it`
    is working as designed.
  prefs: []
  type: TYPE_NORMAL
- en: Neither do we need this module’s `main` routine to accept any command line arguments.
    If we had several tests in here, however, it might be convenient to accept some
    sort of argument that allows us to tell the code which test we want to run.
  prefs: []
  type: TYPE_NORMAL
- en: All we’re really doing here is directly calling `print_it` with a short string
    and then attempting to verify that `print_it` returned zero and actually passed
    what we expected to `printf`. Note that `print_it` is a static function, which
    should make it inaccessible to other modules, but because we’re including *print.c*
    at the top of *test_print.c*, we’re effectively combining both source files into
    a single translation unit.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s write the build code for this test program. First, we need to add
    some lines to *common/Makefile.am* so that a `test_print` program gets built when
    we run `make check`. Modify *common/Makefile.am* as shown in [Listing 9-14](ch09.xhtml#ch09ex14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-14:* common/Makefile.am: *Adding `test_print` as a `check_PROGRAM`*'
  prefs: []
  type: TYPE_NORMAL
- en: When we make the `check` target, we’ll now get a new program, `test_print`,
    in the *common* directory. Now we need to add a call to this program to our test
    suite. Create a new file in *tests* called *print.at*, as shown in [Listing 9-15](ch09.xhtml#ch09ex15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-15:* tests/print.at: *Adding the `print` test*'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to add an `m4_include` statement for this test to *testsuite.at*,
    as in [Listing 9-16](ch09.xhtml#ch09ex16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-16:* tests/testsuite.at: *Adding print.at to testsuite.at*'
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we need to add this new source file to the `TESTSOURCES` variable
    in *tests/Makefile.am*, as shown in [Listing 9-17](ch09.xhtml#ch09ex17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-17:* tests/Makefile.am: *Adding print.at to `TESTSOURCES`*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the `test_print` program only uses the shell status code to indicate an
    error, using it in `AT_CHECK` is as simple as it gets. You only need the first
    argument—the name of the program itself. If `test_print` had more than one test,
    you might accept a command line argument (within the same parameter) that indicates
    which test you want to run and then add several invocations of `AC_CHECK`, each
    running `test_print` with a different argument.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve started a new test group—as I mentioned earlier, you should
    try hard to limit your test groups to a single test unless the nature of the tests
    are such that they work together on the same file-based data set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a shot. Note that in order to run the new test, we really only
    need to make the `check` target to update and execute `testsuite`. However, since
    we added the *print.at* dependency to *tests/Makefile.am*, we should probably
    also run `autoreconf` and `configure`. Had we enabled maintainer mode, the extra
    maintainer-mode rules would have done this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Administrative Details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned while describing the contents of *tests/Makefile.am* back near [Listing
    9-2](ch09.xhtml#ch09ex2) that we needed to add some additional infrastructure
    to that file in order to complete the tie-in with Automake. Let’s take care of
    those details now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen that `make` (`all`) and `make check` work just fine, building our
    products and building and executing our test suite. But we’ve neglected some of
    the other targets that Automake wires up for us—specifically, `installcheck`,
    `clean`, and distribution-related targets like `dist` and `distcheck`. There’s
    a general lesson to be considered here: whenever we add custom rules to *Makefile.am*,
    we need to consider the impact on the standard targets generated by Automake.'
  prefs: []
  type: TYPE_NORMAL
- en: Distributing Test Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several generated files that need to be distributed. These files are
    not inherently known by Automake, and, therefore, Automake needs to be told explicitly
    about them. This is done with the Automake-recognized `EXTRA_DIST` variable, which
    we’ll add to the top of *tests/Makefile.am*, as shown in [Listing 9-18](ch09.xhtml#ch09ex18).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-18:* tests/Makefile.am: *Ensuring test files get distributed with
    `EXTRA_DIST`*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ve added all the test suite source files, including *testsuite.at*,
    *local.at*, *jupiter.at*, and *print.at*. I’ve also added the `testsuite` program
    and any input files we generated using a non-Automake mechanism. These include
    *atconfig*, which is generated by code provided by the `AC_CONFIG_TESTDIR` macro
    internally, and *package.m4*, which is generated by a custom rule we added earlier
    to this *Makefile.am* file. It’s important to understand here that adding files
    to `EXTRA_DIST` causes them to be built, if needed, when `make dist` is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I would have like to have just used *`$(TESTSOURCES)`* in *`EXTRA_DIST`*,
    but the sources in that variable were formatted for rules and commands. *`EXTRA_DIST`*,
    as interpreted by Automake, is designed to refer to a list of files relative to
    the current directory within the source tree.*'
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, we distribute *.at* files because the GNU General Public License
    says we must distribute the source code for our project and these files are the
    source code for `testsuite`, just as *configure.ac* is the source code for `configure`.
    However, even if you’re not using the GPL, you should still consider shipping
    the preferred editing format of all files in your project; it is an open source
    project, after all.
  prefs: []
  type: TYPE_NORMAL
- en: '*Checking Installed Products*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We wrote a `check` target; it’s probably a good idea to support the *GCS* `installcheck`
    target, which Automake also supports. This is done by adding the `installcheck-local`
    target to this *Makefile.am* file, as shown in [Listing 9-19](ch09.xhtml#ch09ex19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-19:* tests/Makefile.am: *Supporting installed-product testing*'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between `check-local` and `installcheck-local` is the addition
    of the `AUTOTEST_PATH` command line option to `testsuite`, pointing `testsuite`
    to the copy of `jupiter` found in `$(DESTDIR)$(bindir)`, where it was installed.
    `AUTOTEST_PATH` is prepended to the shell `PATH` variable before invoking *`commands`*
    in `AT_CHECK_UNQUOTED`; therefore, you could write test code that assumes `PATH`
    contains the path to an installed copy of `jupiter`. However, tests are designed
    to be executed on either installed or uninstalled programs, so it’s a good idea
    to continue deriving and using a full path to programs within your test commands.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll need to make a decision. When the user types `make check`, they clearly
    mean to test the copy of `jupiter` in the build tree. But when they type `make
    installcheck`, certainly they want to check the installed version of the program,
    either in the default install location or wherever the user indicates by using
    command line `make` variables like `DESTDIR`, `prefix`, and `bindir`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up a new issue: when we run tests for uninstalled `jupiter`, we’re
    relying on Libtool’s wrapper script to ensure `jupiter` can find *libjupiter.so*.
    Once we start testing installed `jupiter`, we’ll become responsible for showing
    `jupiter` where *libjupiter.so* is located. If `jupiter` is installed in standard
    places (such as */usr/lib*), the system will naturally find *libjupiter.so*. Otherwise,
    we’ll have to set the `LD_LIBRARY_PATH` environment variable to point to it.'
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we write our tests to work correctly in both situations? One interesting
    (but broken) approach is shown in [Listing 9-20](ch09.xhtml#ch09ex20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-20:* tests/jupiter.at: *Testing execution for both installed and
    uninstalled *`jupiter`*—attempt#1*'
  prefs: []
  type: TYPE_NORMAL
- en: The `find_jupiter` shell function attempts to locate `jupiter` in the `PATH`
    by using the shell’s `type` command. If the first result is empty, we revert to
    using the uninstalled version of `jupiter`.
  prefs: []
  type: TYPE_NORMAL
- en: The function sets two shell variables, `jupiter` and `compare`. The `jupiter`
    variable is the full path to `jupiter`. The `compare` variable is derived from
    `jupiter` and contains either the value of `${jupiter}` or the Libtool location
    and name for uninstalled versions. We can set `LD_LIBRARY_PATH` in both cases
    to the *../lib* directory, relative to where `jupiter` is found because that’s
    probably^([7](footnote.xhtml#ch09fn7)) where it’s installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problems with this approach are numerous. First, it doesn’t handle, very
    well, the situation where `jupiter` *should* be installed but isn’t found in the
    specified or implied install path. In this case, the code quietly reverts to testing
    the uninstalled version—likely not what you wanted. Another issue is that `find_jupiter`
    will locate `jupiter` anywhere in the `PATH`, even if the instance is not the
    one you intended to test. But there’s an even more nefarious bug: if you execute
    `make check`, intending to test the uninstalled version, and an installed version
    of `jupiter` happens to be somewhere in the `PATH`, that’s the version that will
    be tested.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s unfortunate that `AUTOTEST_PATH` defaults to a non-empty value when it’s
    not specified on the command line, as this would be a good way to differentiate
    the use of `make check` from `make installcheck`. However, `AUTOTEST_PATH` does
    default to the name of the directory specified in `AC_CONFIG_TESTDIR`, which also
    happens to be the value of `${at_testdir}`—one of the variables generated by `AC_CONFIG_TESTDIR`
    in *atconfig*. We can use this fact to differentiate between `make check` and
    `make installcheck` by comparing `${AUTOTEST_PATH}` to `${at_testdir}`. Change
    *tests/jupiter.at* as shown in [Listing 9-21](ch09.xhtml#ch09ex21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-21:* tests/jupiter.at: *A better way to use `AUTOTEST_PATH`*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when `make check` is executed, the `jupiter` variable will always be set
    directly to the uninstalled version in the build tree (and `compare` will be set
    to *.../.libs/lt-jupiter*), but when `make installcheck` is entered, it will be
    set to `${AUTOTEST_PATH}`*/jupiter* (and `compare` will be set to the same value).
    Additionally, since we’re able to fully distinguish between installed and uninstalled
    testing, we can set the `LD_LIBRARY_PATH` only for installed versions of `jupiter`.
  prefs: []
  type: TYPE_NORMAL
- en: If `AUTOTEST_PATH` has been set incorrectly, which can happen (for example,
    when the user sets `DESTDIR` or `prefix` incorrectly on the `make` command line),
    the test will fail because `${jupiter}` will not be found.
  prefs: []
  type: TYPE_NORMAL
- en: If I were to add additional tests that needed to run the `jupiter` program,
    these lines would be a perfect candidate for *local.at*. The problem is that a
    shell script designed to run within tests *must* be defined and executed between
    calls to `AT_SETUP` and `AT_CLEANUP`; otherwise, it’s simply omitted from the
    `autom4te` output stream while generating `testsuite`. So, how exactly is *local.at*
    useful to us? Well, you can’t write shell code directly in *local.at*, but you
    can define M4 macros that can be invoked from within your test modules. Let’s
    move the `find_jupiter` functionality into a macro definition in *local.at*, as
    shown in [Listing 9-22](ch09.xhtml#ch09ex22).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-22:* tests/local.at: *Moving `find_jupiter` to an M4 macro*'
  prefs: []
  type: TYPE_NORMAL
- en: Using a shell function was, perhaps, a good idea when we started, but it’s become
    a bit extraneous at this point, so I modified the code to just set the `jupiter`
    variable directly. Notice the second (*`value`*) argument of the call to `m4_define`
    is set verbatim to the shell script we want to have generated when the macro is
    invoked.
  prefs: []
  type: TYPE_NORMAL
- en: The `set -x` command in the first line of the *`value`* argument enables shell
    diagnostic output so you can see the contents of this macro executing, but only
    if you set `TESTSUITEFLAGS=-v` on the `make` command line. This is the default
    setting for the output generated into *testsuite.log*, so you’ll be able to see
    what the code generated by the macro invocation is actually doing.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You may have noticed the code in the second argument of *`m4_define`* has
    two sets of square brackets around it. This is not strictly necessary in this
    example because there are no special characters in the embedded code snippet.
    However, if there had been, double quoting would have allowed the special characters—embedded
    square brackets, or even a previously defined M4 macro name—to be generated exactly
    as is, without interference from the *`m4`* utility.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now change *tests/jupiter.at* as shown in [Listing 9-23](ch09.xhtml#ch09ex23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-23:* tests/jupiter.at: *Calling the `FIND_JUPITER` macro*'
  prefs: []
  type: TYPE_NORMAL
- en: With this change in place, all tests that needed to run the `jupiter` program
    may do so merely by invoking the `FIND_JUPITER` macro and then executing `${jupiter}`
    within the *`commands`* argument. As you can see, the options available to you
    are endless—they’re limited only by your mastery of the shell. Because each test
    is run in a separate subshell, you can feel free to set any environment variables
    you want without affecting subsequent tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out. Note we haven’t changed anything except for *.at* files,
    so we need only run `make` to see the effects of our changes. First, we’ll install
    into a local directory using `DESTDIR` so that we can see how `make installcheck`
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, the execution of `make check TESTSUITEFLAGS=-v` shows us at ➊ that `jupiter`
    is being picked up from the build tree and `compare` is set to the path of the
    Libtool binary, while `make installcheck DESTDIR=$PWD/inst TESTSUITEFLAGS=-v`
    indicates at ➋ that `jupiter` being picked up from the installation path we specified
    and `compare` is set to the same location. `LD_LIBRARY``_PATH` is also being set
    in this code path.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cleaning Up*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `testsuite` program has a `--clean` command line option that cleans up the
    *tests* directory of all test droppings. To wire that into the `clean` target,
    we add a `clean-local` rule, as shown in [Listing 9-24](ch09.xhtml#ch09ex24).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-24:* tests/Makefile.am: *Adding support for `make clean` in tests*'
  prefs: []
  type: TYPE_NORMAL
- en: If `testsuite` exists, it’s asked to clean up after itself. I’ve also added
    a command to remove the generated *atconfig* script, as `make distcheck` fails
    if this file is not removed during execution of the `clean` target while checking
    the distribution directory from which the package is built, and *atconfig* is
    not generated by Automake or by any Autoconf code that Automake monitors. At this
    point, you could try out `make dist` or `make distcheck` to see whether it now
    works as it should.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You might think the *`clean-local`* target is optional, but it’s required
    so that *`make distcheck`* won’t fail when building a distribution archive due
    to extra files being left around after *`distcheck`* runs *`make clean`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Note also that we don’t need to, nor should we, attempt to clean up files generated
    into the source tree, such as *package.m4* and `testsuite` itself. Why not? Much
    like `configure`, autotest products like `testsuite` sit somewhere between source
    files we write by hand and product files found in the build tree. They’re built
    from sources, but stored in the source tree and ultimately distributed in the
    archive.
  prefs: []
  type: TYPE_NORMAL
- en: Niceties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One more thing I like to do is add a call to `AT_COLOR_TESTS` to my *local.at*
    file, right after the invocation of `AT_INIT`. Users can always specify colored
    test output using a command line argument to `testsuite` (`--color`), but using
    this macro allows you to enable colored test output by default. Change your *local.at*
    file as shown in [Listing 9-25](ch09.xhtml#ch09ex25).
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-25:* tests/local.at: *Making colored test output the default*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should notice that the `ok` text after each successful test, as well as
    the summary line `All 2 tests were successful.`, is now green. If you had experienced
    any failed tests, those tests would have shown `FAILED (testsuite``.at:`*`N`*`)`
    in red after the failed tests, with summary lines in red as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: A Minimal Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I mentioned at the outset that we’d take a look at cutting this system down
    to the bare necessities for smaller projects. Here’s what we can do without:'
  prefs: []
  type: TYPE_NORMAL
- en: '***tests/local.at*** Copy the contents of this file to the top of *testsuite.at*
    and delete the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '***tests/atlocal.in*** Assuming you don’t need to pass any configuration variables
    into your testing environment, remove the reference to the product file, *atlocal*,
    from the call to `AC_CONFIG_FILES` in *configure.ac* and delete this template
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '***tests/*.at*** **(subtest files included by** ***testsuite.at***) Copy the
    content of these files serially into *testsuite.at* and delete the files; remove
    the `m4_include` macro invocations that were originally used to include these
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: Edit *tests/Makefile.am* and remove all references to the preceding files (templates
    and generated products) from the `EXTRA_DIST` and `TESTSOURCES` variables, as
    well as from the `check-local` and `installcheck-local` rules.
  prefs: []
  type: TYPE_NORMAL
- en: I would not remove the *package.m4* rule, although you may do so if you wish
    by copying the `m4_define` macro invocations generated into this file directly
    to the top of *testsuite.at*. Since `make` generates this file using variables
    defined by Autoconf, a generated instance of *package.m4* already contains the
    values that replace the variable references in the command in *tests/Makefile.am*.
    In my opinion, the value of not having to edit this information in two places
    far outweighs the overhead of maintaining the file generation rule.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve covered the basics of autotest, but there are a dozen more or less useful
    `AT_*` macros you can use in your *testsuite.at* file. Section 19.2 of the *GNU
    Autoconf Manual* documents them in detail. I’ve shown you how to wire autotest
    into the Automake infrastructure. If you’ve chosen to use autotest without Automake,
    there will be some differences between the Automake’s *tests/Makefile.am* and
    Autoconf’s *tests/Makefile.in*, as you can no longer rely on Automake to do some
    things for you. However, if you’re writing your own *Makefile.in* templates, these
    modifications will quickly become obvious to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve also shown you a technique for creating unit tests in C that allows you
    full access to the private implementation details of a source module. I’ve attained
    nearly 100 percent code coverage using this technique in past projects, but I’ll
    warn you of one caveat now: writing unit tests at this level makes it much more
    difficult to change the functionality of your application. Fixing a bug is not
    so bad, but making design changes will generally require you to disable or entirely
    rewrite the unit tests associated with the code affected by your changes. It’s
    a good idea to be pretty sure of your design before committing yourself to this
    level of unit testing. It has been said that one of the primary values of writing
    unit tests is that you can *set them and forget them*—that is, you can write the
    tests once, wire them into your build system, and no longer pay attention to whether
    the code under test is working. Well, this is mostly true, but if you ever have
    to modify a well-tested feature in your project, unless you comment your test
    code well, you’ll find yourself wondering what you were thinking when you wrote
    that test code.'
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, I sleep better at night knowing that code I just committed to
    my company repository is fully tested. I’ve also been more confident in discussions
    with colleagues regarding bugs surrounding my well-tested code. Autotest has helped
    reduce the effort involved in these projects.
  prefs: []
  type: TYPE_NORMAL
- en: With the end of this chapter, we’ve also come to the end of the Jupiter project—and
    it’s a good thing, because I’ve taken the *Hello, world!* concept *much* further
    than anyone has a right to. From here on out, we’ll be focusing on more isolated
    topics and real-world examples.
  prefs: []
  type: TYPE_NORMAL
