- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: UNIT AND INTEGRATION TESTING WITH AUTOTEST
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AUTOTEST 进行单元和集成测试
- en: '*. . . to learn is not to know; there are the learners and the learned. Memory
    makes the one, philosophy the other.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*...学习不是知道；有学习者和被学者。记忆造就了前者，哲学造就了后者。*'
- en: —Alexandre Dumas, The Count of Monte Cristo*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —亚历山大·仲马，《基督山伯爵》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Testing is important. All developers test their software to one degree or another;
    otherwise, they don’t know if the product meets the design criteria. On one end
    of the spectrum, the author compiles and runs the program. If it presents the
    general interface they envisioned, they call it done. On the other end, the author
    writes a suite of tests that attempt to exercise as much of the code as possible
    under varying conditions, validating that the outputs are correct for the specified
    inputs. Straining to reach the rightmost point on this line, we find the person
    who literally writes tests first and then adds and modifies code iteratively until
    all the tests pass.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是重要的。所有开发者都在某种程度上测试他们的软件，否则他们无法知道产品是否符合设计标准。在这个谱系的一端，作者编译并运行程序。如果程序呈现出他们设想的通用接口，他们就认为完成了。在另一端，作者编写了一套测试，尽可能地在不同条件下检验代码的各个部分，验证输出对于指定输入是正确的。努力追求这个谱系的最右端，我们会看到这样的人，他们字面上先写测试，然后迭代地添加和修改代码，直到所有测试通过。
- en: In this chapter, I won’t attempt to expound on the virtues of testing. I assume
    every developer agrees that *some* level of testing is important, whether they
    are a compile-run-and-ship sorta person or a bona-fide test-driven person. I also
    assume every developer has some level of aversion to testing that lies somewhere
    along this spectrum. Therefore, our goal here is to let someone else do as much
    of the work of testing as possible. In this case, “someone else” means the Autotools.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我不会尝试详细阐述测试的优点。我假设每个开发者都同意*某种*程度的测试是重要的，无论他们是那种编译-运行-发布类型的人，还是正统的测试驱动开发者。我还假设每个开发者对测试都有一定的反感，这种反感程度在这个谱系上有所不同。因此，我们在这里的目标是尽可能让别人做大部分的测试工作。在这种情况下，“别人”指的是
    Autotools。
- en: 'Back in [Chapter 3](ch03.xhtml), we added a test to our handcoded makefiles
    for Jupiter. The output of the test was completely controlled by the `make` script
    we put into *src/Makefile*:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml)中，我们为 Jupiter 添加了一个手写的 makefile 测试。该测试的输出完全由我们放入*src/Makefile*中的`make`脚本控制：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we moved on to Autoconf in [Chapters 4](ch04.xhtml) and [5](ch05.xhtml),
    not much changed. The output was still controlled by our handwritten `make` script.
    We just moved it into *src/Makefile.in*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第 4 章](ch04.xhtml)和[第 5 章](ch05.xhtml)中转向 Autoconf 时，变化不大。输出依然由我们手写的`make`脚本控制。我们只是将它移到了*src/Makefile.in*中。
- en: 'In [Chapter 6](ch06.xhtml), however, we dropped our handcoded makefiles and
    templates in favor of Automake’s much more terse *Makefile.am* files. Then we
    had to figure out how to shoehorn our handwritten test into `automake` script.
    In doing so, we got a bit of an upgrade on the test output:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在[第 6 章](ch06.xhtml)中，我们放弃了手写的 makefile 和模板，转而使用 Automake 更为简洁的*Makefile.am*文件。然后，我们需要弄清楚如何将我们手写的测试嵌入到
    `automake` 脚本中。在这样做的过程中，我们对测试输出进行了些许升级：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you’re running this code on your terminal with a reasonably late version
    of Automake, you’ll even see colored test output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在终端上运行这个代码，并且使用的是一个相对较新的 Automake 版本，你甚至会看到彩色的测试输出。
- en: Every test added to the `TESTS` variable in our *src/Makefile.am* template generates
    a `PASS:` or `FAIL:` line, and the summary values account for all of them. This
    is because Automake has a nice built-in testing framework driven by the `TESTS`
    variable. If you need to build any of the files specified in `TESTS`, you can
    just create a rule for it as we did for the trivial driver script (*greptest.sh*)
    that we created. If your test program needs to be built from sources, you can
    use a `check_PROGRAM` variable. One minor problem with Automake’s testing framework
    is that if tests are found in multiple directories, you see multiple such displays
    during `make check`, which can be a little annoying, especially when using `make
    -k` (continue in the face of errors), because it may not occur to you to scroll
    up to see the output of earlier, possibly failed tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个添加到`TESTS`变量中的测试都会在我们的*src/Makefile.am*模板中生成一个`PASS:`或`FAIL:`行，并且汇总值会计算所有的测试结果。这是因为Automake有一个很好的内置测试框架，驱动它的是`TESTS`变量。如果你需要构建`TESTS`中指定的任何文件，你只需要像我们为简单的驱动脚本（*greptest.sh*）所做的那样创建一个规则。如果你的测试程序需要从源代码构建，你可以使用`check_PROGRAM`变量。Automake的测试框架有一个小问题，如果测试分布在多个目录中，你会在`make
    check`时看到多次类似的显示，这可能会有点烦人，特别是在使用`make -k`（在遇到错误时继续）时，因为你可能没有意识到需要向上滚动以查看早期可能失败的测试输出。
- en: In addition to the `TESTS` variable, if you set the `XFAIL_TESTS` variable to
    a subset of the tests listed in `TESTS`, you might also see some output in the
    `XFAIL:` and `XPASS:` lines. These are tests that are expected to fail. When such
    tests pass, they’re listed in the `XPASS:` line as an *unexpected pass*. When
    they fail, they’re listed in the `XFAIL:` line as an *expected failure*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`TESTS`变量，如果你将`XFAIL_TESTS`变量设置为`TESTS`中测试的一个子集，你可能还会看到`XFAIL:`和`XPASS:`行中的一些输出。这些是预期会失败的测试。当这样的测试通过时，它们会列在`XPASS:`行中，作为*意外通过*。当它们失败时，它们会列在`XFAIL:`行中，作为*预期失败*。
- en: A test returning a shell code of 77 increases the count in the `SKIP:` line,
    and 99 increases the count in the `ERROR:` line. I’ll provide more detail about
    special shell codes returned by tests later in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 返回77的测试会增加`SKIP:`行中的计数，而返回99的测试会增加`ERROR:`行中的计数。我将在本章稍后提供有关测试返回的特殊shell代码的更多详细信息。
- en: As you might have guessed by now, Autoconf also includes a testing framework,
    called *autotest*, that provides all of the infrastructure required to allow you
    to simply and easily specify a test that exercises some portion of your code.
    The results are displayed in a consistent and easy-to-comprehend manner, and failed
    tests are easy to reproduce in an isolated fashion, complete with a built-in debugging
    environment. Almost makes you want to write tests, doesn’t it? The fact is, a
    well-designed testing framework, like any other well-designed tool, is a joy to
    use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经猜到的那样，Autoconf也包含了一个测试框架，叫做*autotest*，它提供了所有所需的基础设施，让你能够简单而轻松地指定一个测试来验证你代码的某些部分。结果以一致且易于理解的方式显示，失败的测试也能在独立的环境中轻松重现，并配有内置的调试环境。几乎让你想写测试了，不是吗？事实是，一个设计良好的测试框架，就像任何其他设计良好的工具一样，是一种乐趣。
- en: Additionally, autotest is portable—as long as you write your portion of the
    tests using portable script or code, the entire test suite will be 100 percent
    portable to any system on which you can run your `configure` script. That’s not
    as hard as it sounds. Often the shell script you have to write amounts to running
    a command, and the code behind the command is written using Autotools-provided
    portability features and is generated using Autotools-provided build processes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，autotest是可移植的——只要你使用可移植的脚本或代码编写你的测试部分，整个测试套件就可以100%移植到任何可以运行`configure`脚本的系统。这并不像听起来那么难。你通常需要编写的shell脚本只是运行一个命令，而命令背后的代码使用Autotools提供的可移植性功能编写，并且是通过Autotools提供的构建过程生成的。
- en: 'For several years, autotest has been documented as being “experimental.” Regardless,
    its base functionality hasn’t changed much during those years, and Autoconf uses
    it to test itself, as we saw in [Chapter 1](ch01.xhtml). So, it’s time to stop
    worrying about whether it’s going to change and just start using it for its intended
    purpose: to make testing less of a chore for software developers, who—let’s face
    it—really just want to write code and let someone else worry about testing.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，autotest 一直被文档描述为“实验性”。不过，无论如何，它的基本功能在这些年中变化不大，Autoconf 使用它来测试自己，正如我们在[第
    1 章](ch01.xhtml)中看到的那样。因此，是时候停止担心它是否会改变，开始将它用于预定的目的：让软件开发者的测试工作变得不那么繁琐，毕竟，软件开发者真正希望做的是写代码，让别人来担心测试。
- en: Being the rational creatures that we are, we can’t deny that testing is important.
    What we can do is make use of good tools that allow us to focus on our code, letting
    frameworks like autotest worry about ancillary issues like result formatting,
    success/failure semantics, data gathering for user-submitted bug reports, and
    portability. As we’ll see throughout this chapter, this is the value that autotest
    provides.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为理性生物，我们无法否认测试的重要性。我们能做的是利用好的工具，让我们能专注于代码本身，而让像 autotest 这样的框架来处理诸如结果格式化、成功/失败语义、用户提交的
    bug 报告的数据收集以及可移植性等附加问题。正如我们在本章中将看到的那样，这就是 autotest 提供的价值。
- en: In the spirit of transparency, I’ll admit it’s difficult to justify using autotest
    for small test suites like Jupiter’s. The testing harness built into Automake
    is more than adequate for most small project needs. Larger projects—such as Autoconf
    itself, with its 500-plus unit and integration tests, which test functionality
    spread out over its entire project directory structure, and even installed components—are
    a different matter entirely.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本着透明的精神，我承认，对于像 Jupiter 这样的较小的测试套件，使用 autotest 是很难证明其合理性的。Automake 中内建的测试工具已经足够满足大多数小型项目的需求。较大的项目——例如
    Autoconf 本身，它有超过 500 个单元和集成测试，测试覆盖整个项目目录结构中的功能，甚至包括已安装的组件——则是完全不同的情况。
- en: Autotest Overview
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autotest 概述
- en: There are three phases to the files consumed and generated by autotest. The
    first phase is what the *GNU Autoconf Manual* calls the “prep for distribution”
    phase. The second phase occurs when `configure` is executed, and the third phase
    happens during execution of the test suite. Let’s take each of these phases in
    turn.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: autotest 使用和生成的文件有三个阶段。第一阶段是 *GNU Autoconf 手册* 所称的“准备分发”阶段。第二阶段发生在执行 `configure`
    时，第三阶段发生在执行测试套件时。让我们逐一看看这些阶段。
- en: The first phase, which happens during building of the distribution archive,
    is essentially the process of generating the executable test program that can
    be run by users on their systems. It may seem a bit strange that this process
    must be done during the building of a distribution archive; however, Autoconf
    is required to be installed on any system that needs to generate this program,
    so the `testsuite` program must be built when the distribution archive is built
    so that it may be included in the archive for the user. While the `dist` or `distcheck`
    targets are being made, `configure` (and `make check`, when using `distcheck`)
    is executed; `make check` encapsulates rules to rebuild the test program from
    sources using `autom4te`—the Autoconf caching `m4` driver. The test program is
    built during execution of the `dist` target by virtue of having it included in
    the Automake `EXTRA_DIST` variable, which I’ll talk about near the end of this
    chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段发生在构建分发档案时，实际上是生成可以在用户系统上运行的可执行测试程序的过程。可能会觉得奇怪，为什么这个过程必须在构建分发档案时进行；然而，Autoconf
    必须安装在任何需要生成此程序的系统上，因此 `testsuite` 程序必须在构建分发档案时构建，以便将其包含在归档文件中供用户使用。在执行 `dist`
    或 `distcheck` 目标时，`configure`（以及使用 `distcheck` 时的 `make check`）会被执行；`make check`
    封装了重建测试程序的规则，使用 `autom4te` —— Autoconf 缓存的 `m4` 驱动程序。测试程序在执行 `dist` 目标时构建，这是因为它被包括在
    Automake 的 `EXTRA_DIST` 变量中，我将在本章结束时讲解这个内容。
- en: '[Figure 9-1](ch09.xhtml#ch09fig1) shows the flow of data from maintainer-written
    source files to the `testsuite` program during `make dist` (or `make distcheck`).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](ch09.xhtml#ch09fig1) 显示了在执行 `make dist`（或 `make distcheck`）时，从维护者编写的源文件到
    `testsuite` 程序的数据流。'
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig01.jpg)'
- en: '*Figure 9-1: Data flow from maintainer-written input files to the `testsuite`
    program*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：从维护者编写的输入文件到 `testsuite` 程序的数据流*'
- en: The file *testsuite.at*, found at the top of the second column of the diagram,
    is the main test file written by a project author. This is actually the only maintainer-written
    file required by autotest. Exactly like *configure.ac*, this file contains shell
    script sprinkled with M4 macro definitions and invocations. This file is passed
    through the M4 macro processor, with `autom4te` acting as the driver for `m4`,
    to generate the `testsuite` program at the top of the last column, which is pure
    shell script. This process occurs during execution of `autom4te`, which is driven
    by `make check` reading the makefile generated from a *Makefile.in* or *Makefile.am*
    file that we write. The prep-for-distribution concept comes from the fact that
    the `check` target is executed during `make distcheck` (which, of course, builds
    the distribution archive); the `testsuite` program is added to the distribution
    archive during this process. It’s built during `make dist`, which does not execute
    `make check`, because all files listed in `EXTRA_DIST` must be built before they
    can be included in the distribution archive.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的第二列顶部找到的 *testsuite.at* 文件，是由项目作者编写的主要测试文件。实际上，这是 autotest 所需的唯一维护者编写的文件。与
    *configure.ac* 完全相同，这个文件包含了 shell 脚本，并掺杂了 M4 宏定义和调用。该文件通过 M4 宏处理器处理，由 `autom4te`
    作为 `m4` 的驱动程序，生成位于最后一列顶部的 `testsuite` 程序，这是纯粹的 shell 脚本。这个过程发生在执行 `autom4te` 时，`make
    check` 读取我们编写的 *Makefile.in* 或 *Makefile.am* 文件生成的 makefile，并驱动该过程。准备发布的概念来源于
    `check` 目标在 `make distcheck` 时执行（这当然会构建分发档案）；`testsuite` 程序会在这个过程中被添加到分发档案中。它是在
    `make dist` 过程中构建的，`make dist` 并不会执行 `make check`，因为在所有列在 `EXTRA_DIST` 中的文件被构建之前，它们不能包含在分发档案中。
- en: Details like this are normally hidden from us by the Autotools, but as autotest
    is still considered experimental—meaning, not fully integrated into the Autotools
    suite—the responsibility for some of this additional infrastructure is relegated
    to us, the maintainers. We’ll cover these details shortly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如此类的细节通常会被 Autotools 隐藏起来，但由于 autotest 仍被视为实验性的——意味着它尚未完全融入 Autotools 套件——因此一些额外的基础设施责任落在了我们这些维护者身上。我们将很快讨论这些细节。
- en: The Autoconf manual suggests that test suite authors may put individual sets
    of related tests, called *test groups*, into separate *.at* files. The *testsuite.at*
    file, then, contains only a series of `m4_include` directives, including each
    of these group-specific *.at* files. Therefore, M4 inclusion is the mechanism
    by which the optional *test-1.at* through *test-*`N`*.at* are gathered together
    into *testsuite.at* for processing by M4.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 手册建议，测试套件的作者可以将一组组相关的测试，称为*测试组*，放入单独的 *.at* 文件中。然后，*testsuite.at* 文件仅包含一系列
    `m4_include` 指令，包含这些特定于组的 *.at* 文件。因此，M4 包含机制是通过它将可选的 *test-1.at* 到 *test-*`N`*.at*
    文件汇集到 *testsuite.at* 中，由 M4 进行处理。
- en: The *package.m4* and *local.at* files are optional maintainer-written (or generated)
    input files that are automatically included by `autom4te` when processing *testsuite.at*,
    if they’re found. The former contains basic information about the test suite that’s
    displayed on the console and embedded in bug reports generated by the test suite.
    The latter, the manual suggests, is an optional mechanism we may choose to use
    that can help us keep *testsuite.at* uncluttered with global definitions, non-group-related
    tests, and helper macro definitions and shell functions that may be used by the
    actual tests. We’ll discuss the exact contents of these files later in the chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*package.m4* 和 *local.at* 文件是可选的维护者编写（或生成）的输入文件，在处理 *testsuite.at* 时，如果找到了它们，会自动由
    `autom4te` 包含。前者包含有关测试套件的基本信息，这些信息会在控制台上显示，并嵌入由测试套件生成的错误报告中。后者，手册建议，是一种可选机制，我们可以选择使用，它可以帮助我们保持
    *testsuite.at* 文件简洁，不包含全局定义、与组无关的测试，以及可能由实际测试使用的辅助宏定义和 shell 函数。我们将在本章后面讨论这些文件的具体内容。'
- en: When a `configure` script is instrumented for autotest, the configuration process
    generates additional, autotest-related artifacts. [Figure 9-2](ch09.xhtml#ch09fig2)
    shows what happens graphically during the configuration process, relative to autotest.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `configure` 脚本用于 autotest 时，配置过程会生成额外的与 autotest 相关的产物。[图 9-2](ch09.xhtml#ch09fig2)
    显示了在配置过程中，关于 autotest 的图示。
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig02.jpg)'
- en: '*Figure 9-2: The flow of data during *`configure`* while generating test-related
    templates*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：在生成与测试相关的模板时，*`configure`* 过程中数据流的示意图*'
- en: Recall from [Chapter 2](ch02.xhtml) that `config.status` drives the file-generation
    portion of the configuration process. When a *configure.ac* file is set up for
    autotest, `config.status` generates *atconfig*—a shell script that’s designed
    to be sourced by `testsuite` when it’s executed.^([1](footnote.xhtml#ch09fn1))
    It contains source- and build-tree variables such as `at_testdir`, `abs_builddir`,
    `abs_srcdir`, `at_top_srcdir`, and so on, in order to facilitate access to files
    and products in the source and build trees during test suite execution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第2章](ch02.xhtml)中的内容，`config.status` 驱动配置过程中的文件生成部分。当为 autotest 设置 *configure.ac*
    文件时，`config.status` 会生成 *atconfig*——一个设计为由 `testsuite` 在执行时调用的 shell 脚本。^([1](footnote.xhtml#ch09fn1))
    它包含源代码树和构建树的变量，如 `at_testdir`、`abs_builddir`、`abs_srcdir`、`at_top_srcdir` 等，以便在测试套件执行期间访问源代码和构建树中的文件及产物。
- en: The test author may also choose to create a template file called *atlocal.in*
    that allows them to pass additional Autoconf and project-specific configuration
    variables through to the test environment, as needed. The product of this template
    is *atlocal*—also a shell script that’s designed to be sourced by `testsuite`,
    if it’s present. If you choose to write *atlocal.in*, you must add it to the list
    of tags passed to an invocation of `AC_CONFIG_FILES` in *configure.ac*. We’ll
    see how this is done later as we export Jupiter’s `async_exec` flag to our test
    suite.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试作者还可以选择创建一个名为 *atlocal.in* 的模板文件，允许他们根据需要将额外的 Autoconf 和项目特定的配置变量传递到测试环境中。该模板的产物是
    *atlocal*——同样是一个 shell 脚本，设计为由 `testsuite` 调用（如果它存在）。如果你选择编写 *atlocal.in*，必须将其添加到
    *configure.ac* 中传递给 `AC_CONFIG_FILES` 调用的标签列表中。稍后我们将在将 Jupiter 的 `async_exec`
    标志导出到我们的测试套件时看到如何执行此操作。
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t confuse atlocal with local.at from [Figure 9-1](ch09.xhtml#ch09fig1).
    The atlocal file in [Figure 9-2](ch09.xhtml#ch09fig2), sourced by *`testsuite`*
    at runtime, is used to pass configuration variables into the test environment
    from *`configure`*, while the local.at file is written directly by the project
    maintainer and contains additional test code processed by *`autom4te`* when *`testsuite`*
    is generated.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将 atlocal 与[图9-1](ch09.xhtml#ch09fig1)中的 local.at 混淆。[图9-2](ch09.xhtml#ch09fig2)中的
    atlocal 文件，由 *`testsuite`* 在运行时调用，用于将配置变量从 *`configure`* 传递到测试环境，而 local.at 文件是由项目维护者直接编写的，包含在生成
    *`testsuite`* 时由 *`autom4te`* 处理的额外测试代码。*'
- en: '[Figure 9-3](ch09.xhtml#ch09fig3) shows the flow of data during the execution
    of `testsuite`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-3](ch09.xhtml#ch09fig3) 展示了 `testsuite` 执行过程中的数据流。'
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig03.jpg)'
- en: '*Figure 9-3: The flow of data during execution of the `testsuite` script*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：`testsuite` 脚本执行过程中的数据流*'
- en: As mentioned previously, `testsuite` sources *atconfig* and *atlocal* (if present)
    to access source- and build-tree information and other project-related variables,
    then executes the tests that were generated into it. As it does so, it creates
    a *testsuite.log* file containing verbose information on the execution of each
    test. What you see on the screen is a single line of text per test.^([2](footnote.xhtml#ch09fn2))
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`testsuite` 会获取 *atconfig* 和 *atlocal*（如果存在）来访问源代码树和构建树信息以及其他与项目相关的变量，然后执行生成的测试。执行过程中，它会创建一个
    *testsuite.log* 文件，包含每个测试执行的详细信息。你在屏幕上看到的每行文本代表一个测试的结果。^([2](footnote.xhtml#ch09fn2))
- en: The `testsuite` program generates a directory called *testsuite.dir*. A separate
    subdirectory is created within this directory for each test. The test suite does
    not delete test-specific subdirectories for failed tests; we can use the contents
    of this directory structure to obtain details and to debug the problem. We’ll
    go into detail about what gets added to these directories shortly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`testsuite` 程序会生成一个名为 *testsuite.dir* 的目录。在这个目录中，每个测试都会创建一个单独的子目录。测试套件不会删除失败测试的特定子目录；我们可以利用该目录结构的内容获取详细信息并调试问题。稍后我们将详细介绍这些目录中添加了什么内容。'
- en: The `testsuite` program may be executed by hand, of course, but it has to be
    generated first. The Autoconf manual suggests that the process of generating the
    `testsuite` program is best tied directly into the `check` target so that when
    `make check` is executed, `testsuite` will be generated (if it’s missing or out-of-date
    with respect to its dependencies) and then executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`testsuite` 程序当然可以手动执行，但首先必须生成它。Autoconf 手册建议将生成 `testsuite` 程序的过程直接与 `check`
    目标绑定，这样当执行 `make check` 时，`testsuite` 会被生成（如果它缺失或与其依赖关系不一致），然后再执行。'
- en: Since `testsuite` is added to the distribution archive, end users who run `make
    check` will merely execute the existing `testsuite` program, unless they’ve touched
    one of the files that `testsuite` depends on, in which case `make` will attempt
    to regenerate `testsuite`. Without Autoconf installed, this process would fail.
    Fortunately, it’s not generally in the user’s best interest to touch any of `testsuite`’s
    dependencies in the distribution archive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `testsuite` 已被添加到分发包中，运行 `make check` 的最终用户将仅执行现有的 `testsuite` 程序，除非他们修改了
    `testsuite` 依赖的某些文件，在这种情况下，`make` 会尝试重新生成 `testsuite`。如果没有安装 Autoconf，这个过程会失败。幸运的是，用户通常不需要修改分发包中
    `testsuite` 的任何依赖项。
- en: Wiring Up Autotest
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Autotest
- en: Since my goal here is to teach you how to use this framework, the approach I
    chose to take in configuring Jupiter for autotest was to incorporate the entire
    set of optional files shown in Figures 9-1 through 9-3\. This allows us to explore
    exactly how everything works together. While this approach is probably unwarranted
    for a project the size of Jupiter, it does work correctly, and it can always be
    pared down. I’ll show you at the end of this chapter just what you can delete
    to reduce the autotest input file set to the bare minimum.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我这里的目标是教你如何使用这个框架，因此我选择的配置 Jupiter 用于 autotest 的方法是包含图 9-1 至 9-3 中所示的整个可选文件集。这使我们能够准确地探索所有内容如何一起工作。虽然对于像
    Jupiter 这样规模的项目，这种方法可能不必要，但它确实能正确工作，而且以后可以随时删减。我将在本章末尾向你展示，如何删除一些内容，将 autotest
    输入文件集精简到最少。
- en: Before we can write tests, we need to make *configure.ac* aware of our desire
    to use autotest. This is done by adding two macro invocations to *configure.ac*,
    as shown in [Listing 9-1](ch09.xhtml#ch09ex1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试之前，需要让 *configure.ac* 知道我们希望使用 autotest。这是通过在 *configure.ac* 中添加两个宏调用来实现的，如
    [列表 9-1](ch09.xhtml#ch09ex1) 所示。
- en: Git tag 9.0
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 9.0
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-1:* configure.ac: *Wiring autotest into* configure.ac'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1:* configure.ac: *将 autotest 集成到* configure.ac'
- en: The first of these two macros, `AC_CONFIG_TESTDIR`, tells Autoconf to enable
    autotest and specifies that the testing directory will be called *tests*. You
    may use a dot here to represent the current directory if you wish, but the *GNU
    Autoconf Manual* recommends that you use a separate directory for ease in managing
    test output files and directories.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏中的第一个，`AC_CONFIG_TESTDIR`，告诉 Autoconf 启用 autotest，并指定测试目录将命名为 *tests*。如果愿意，你可以在这里使用点（.）表示当前目录，但
    *GNU Autoconf 手册* 建议使用单独的目录，以便更容易管理测试输出文件和目录。
- en: '**NOTE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The addition of `AC_CONFIG_TESTDIR` to* configure.ac *is actually the only
    change required to enable autotest in a project, though changes to makefiles and
    additional support files are required to make it useful and more automated. Interestingly,
    this important tidbit is not found anywhere in the manual, though it is implied
    rather subtly.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*将 `AC_CONFIG_TESTDIR` 添加到* configure.ac *实际上是启用 autotest 所需的唯一更改，尽管为了使其更有用和更自动化，还需要更改
    makefile 和添加支持文件。有趣的是，这个重要的细节在手册中没有直接提到，尽管它是微妙地暗示的。*'
- en: The second line is the standard Autoconf `AC_CONFIG_FILES` instantiating macro.
    I’m using a separate instance of it here to generate the test-related files from
    templates.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是标准的 Autoconf `AC_CONFIG_FILES` 实例化宏。我在这里使用了它的一个独立实例，用于从模板生成与测试相关的文件。
- en: Let’s look at what goes into each of these files. The first is a makefile for
    the *tests* directory that’s generated from an Autoconf *Makefile.in* template,
    which itself is generated from the Automake *Makefile.am* file that we need to
    write. In this makefile, we need to get `make check` to generate and execute `testsuite`.
    [Listing 9-2](ch09.xhtml#ch09ex2) shows how we might write *tests/Makefile.am*
    so that Automake and Autoconf will generate such a makefile.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看这些文件中包含了什么。第一个是为*tests*目录生成的 makefile，它是从 Autoconf 的 *Makefile.in* 模板生成的，而该模板本身是从我们需要编写的
    Automake *Makefile.am* 文件生成的。在这个 makefile 中，我们需要通过 `make check` 来生成并执行 `testsuite`。[列表
    9-2](ch09.xhtml#ch09ex2) 展示了如何编写 *tests/Makefile.am*，以便 Automake 和 Autoconf 能够生成这样的
    makefile。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-2:* tests/Makefile.am: *Getting* `make check` *to build and run*
    `testsuite`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2:* tests/Makefile.am: *使* `make check` *构建并运行* `testsuite`'
- en: Before we begin dissecting this file, I should mention that these contents were
    taken from Section 19.4 of the *GNU Autoconf Manual*. I’ve tweaked them a bit,
    but essentially these lines comprise a portion of the recommended way to tie autotest
    into Automake. We’ll complete this file as we discuss additional features and
    requirements of autotest-oriented `make` script.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始分析这个文件之前，我应该提到，这些内容取自 *GNU Autoconf 手册* 的第 19.4 节。我对它们做了一些修改，但本质上，这些行组成了将
    autotest 与 Automake 结合的推荐方式的一部分。我们将在讨论 autotest 定向的 `make` 脚本的其他功能和需求时完成这个文件。
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This lack of more complete integration, along with the fact that Autoconf
    can be configured to use several different test drivers (DejaGNU, for instance),
    is likely what keeps autotest in experimental mode. While Libtool, for instance,
    has slowly migrated toward a position of complete integration with Automake, autotest
    still requires some fiddling to properly integrate into a project build system.
    Nevertheless, once the requirements are understood, proper integration is pretty
    simple. Additionally, as we’ve seen, Automake has its own test framework, which
    gives Automake maintainers little incentive to fully support autotest.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种缺乏更完整集成的情况，以及 Autoconf 可以配置为使用几个不同的测试驱动程序（例如 DejaGNU）的事实，可能是导致 autotest
    仍处于实验模式的原因。虽然 Libtool 逐步向与 Automake 完全集成的方向发展，但 autotest 仍需要一些调整才能正确地集成到项目构建系统中。然而，一旦理解了这些需求，正确的集成其实是相当简单的。此外，正如我们所看到的，Automake
    有自己的测试框架，这使得 Automake 的维护者没有足够的动力去全面支持 autotest。*'
- en: The code in [Listing 9-2](ch09.xhtml#ch09ex2) is pretty straightforward when
    taken a line at a time—four variables and four rules. The variables are not strictly
    necessary, but they make for shorter command lines and less duplication in rules
    and commands. The `TESTSUITE` variable at ➊ simply keeps us from having to prefix
    `testsuite` with `$(srcdir)/` everywhere we use it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-2](ch09.xhtml#ch09ex2) 中的代码逐行来看非常简单——四个变量和四个规则。这些变量并非严格必要，但它们使命令行更短，并且减少了规则和命令中的重复。➍
    处的 `TESTSUITE` 变量让我们不必在每次使用时都加上 `$(srcdir)/` 前缀。'
- en: '**NOTE**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `testsuite` program is distributed, so it should be built in the source
    tree. Files that are destined to end up in the distribution archive should be
    found in the source directory structure. Additionally, the content of such built
    and distributed files should be the same, regardless of differences in configuration
    options used by the original archive creator, or the end user.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*`testsuite` 程序是分发的，因此它应该在源树中构建。那些最终会进入分发归档的文件应该位于源目录结构中。此外，这些构建并分发的文件的内容应该是相同的，无论原始归档创建者或最终用户使用的配置选项有何不同。*'
- en: The `TESTSOURCES` variable at ➋ allows us to easily add additional tests to
    the makefile. Each *.at* file becomes a dependency of `testsuite` so that when
    one of them is changed, `testsuite` is rebuilt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 处的 `TESTSOURCES` 变量使我们可以轻松地将额外的测试添加到 makefile 中。每个 *.at* 文件都会成为 `testsuite`
    的依赖项，因此当其中一个文件发生变化时，`testsuite` 会被重新构建。
- en: The `AUTOM4TE` variable at ➌ allows us to wrap execution of `autom4te` with
    the Automake `missing` script, which prints a nicer error message if `autom4te`
    is not found. This happens when an end user who doesn’t have the Autotools installed
    does something that requires `testsuite` to be rebuilt—such as modify *testsuite.at*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 处的 `AUTOM4TE` 变量允许我们使用 Automake 的 `missing` 脚本包装 `autom4te` 的执行，当未找到 `autom4te`
    时，它会打印出更友好的错误信息。这通常发生在没有安装 Autotools 的最终用户做出需要重建 `testsuite` 的操作时——例如修改 *testsuite.at*。
- en: '**NOTE**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We can’t use Automake’s `maintainer-rules` option to avoid writing these rules
    into distribution archive Makefiles because we must manually write these rules.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们不能使用 Automake 的 `maintainer-rules` 选项来避免将这些规则写入分发归档的 Makefile，因为我们必须手动编写这些规则。*'
- en: The `AUTOTEST` variable at ➍ appends the `--language=autotest` option to the
    `autom4te` command line. *There is actually no program in the Autoconf package
    called* autotest. If we had to pin down the definition of such a tool, it would
    be the contents of this `AUTOTEST` variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`AUTOTEST` 变量在 ➍ 处将 `--language=autotest` 选项添加到 `autom4te` 命令行中。*实际上，Autoconf
    包中并没有名为* autotest 的程序。如果我们必须界定这样一个工具的定义，它将是这个 `AUTOTEST` 变量的内容。'
- en: The `check-local` rule at ➎ ties execution of `testsuite` into Automake’s `check`
    target. Automake standard targets like `check` have a `-local` counterpart that
    you can use to supplement the functionality generated by Automake for the base
    target. If Automake sees a rule with the target `check-local` in *Makefile.am*,
    it generates a command to run `$(MAKE) check-local` under the generated *Makefile*’s
    `check` rule. This gives you a hook into the standard Automake targets. We’ll
    cover such hooks in greater detail in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml),
    where we’ll use them extensively in our efforts to convert a real-world project
    to use an Autotools-based build system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 位置的 `check-local` 规则将 `testsuite` 的执行与 Automake 的 `check` 目标关联起来。像 `check`
    这样的 Automake 标准目标有一个 `-local` 对应目标，你可以用它来补充 Automake 为基本目标生成的功能。如果 Automake 在
    *Makefile.am* 中看到一个目标为 `check-local` 的规则，它会生成一个命令，在生成的 *Makefile* 的 `check` 规则下运行
    `$(MAKE) check-local`。这为你提供了一个钩子，允许你进入标准的 Automake 目标。我们将在 [第 14 章](ch14.xhtml)
    和 [第 15 章](ch15.xhtml) 中更详细地讲解这些钩子，在那里我们将广泛使用它们，将一个真实世界的项目转换为使用基于 Autotools 的构建系统。
- en: The `check-local` target depends on *atconfig*, *atlocal*, and `$(TESTSUITE)`.
    Recall from [Figure 9-3](ch09.xhtml#ch09fig3) that *atlocal* is a script sourced
    by `testsuite`. It’s generated directly by the invocation of `AC_CONFIG_FILES`
    that we added to *configure.ac* in [Listing 9-1](ch09.xhtml#ch09ex1), so we’ll
    cover its contents shortly. The command for this rule executes `'$(TESTSUITE)'`
    with `$(TESTSUITEFLAGS)` as a command line argument. The contents of `TESTSUITEFLAGS`
    are user defined, allowing the end user to run `make check TESTSUITEFLAGS=-v`,
    for instance, to enable verbose output from `testsuite` while making targets that
    invoke `testsuite`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-local` 目标依赖于 *atconfig*、*atlocal* 和 `$(TESTSUITE)`。回想一下 [图 9-3](ch09.xhtml#ch09fig3)，*atlocal*
    是由 `testsuite` 引用的脚本。它是通过我们在 [清单 9-1](ch09.xhtml#ch09ex1) 中添加到 *configure.ac*
    的 `AC_CONFIG_FILES` 调用直接生成的，所以我们很快会讲解它的内容。这个规则的命令执行 `''$(TESTSUITE)''`，并将 `$(TESTSUITEFLAGS)`
    作为命令行参数。`TESTSUITEFLAGS` 的内容由用户定义，允许最终用户运行 `make check TESTSUITEFLAGS=-v`，例如，以便在执行调用
    `testsuite` 的目标时启用 `testsuite` 的详细输出。'
- en: You can also use `TESTSUITEFLAGS` to target specific test groups by number (for
    instance, `TESTSUITEFLAGS=2 testsuite`) or, if you’ve written your tests using
    the `AT_KEYWORDS` macro, by tag name. In addition, several command line options
    are available for the generated `testsuite` program. You can find complete documentation
    for `testsuite` options in Section 19.3 of the *GNU Autoconf Manual*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `TESTSUITEFLAGS` 通过编号（例如，`TESTSUITEFLAGS=2 testsuite`）或如果你已经使用 `AT_KEYWORDS`
    宏编写了测试，通过标签名来指定特定的测试组。此外，生成的 `testsuite` 程序还提供了几个命令行选项。你可以在 *GNU Autoconf 手册*
    第 19.3 节中找到 `testsuite` 选项的完整文档。
- en: '**NOTE**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The single quotes around *`$(TESTSUITE)`* allow the path in *`TESTSUITE`*
    to contain spaces, if needed. This technique can and should be used in all makefiles
    to handle whitespace in paths. I’ve generally ignored the concept of whitespace
    in paths within this book in order to reduce the noise in the listings, but you
    should be aware that makefiles can be written to properly handle whitespace in
    all filenames and paths—those in targets and dependencies, as well as those in
    the commands associated with rules.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*`$(TESTSUITE)`* 周围的单引号允许 *`TESTSUITE`* 中的路径包含空格（如果需要）。这种技术可以并且应该在所有 Makefile
    中使用，以处理路径中的空格问题。在本书中，我通常忽略了路径中空格的概念，以减少列表中的噪音，但你应该意识到，Makefile 可以正确地处理所有文件名和路径中的空格——无论是在目标和依赖关系中的，还是与规则相关的命令中的。'
- en: I mentioned previously that the *atconfig* script, also sourced by `testsuite`,
    is generated automatically beneath the covers by `AC_CONFIG_TESTDIR`. The problem
    is, even though `config.status` understands how to build this file, Automake doesn’t
    know anything about it because it’s not listed directly in any of the instantiating
    macro invocations in *configure.ac*, so we need to add an explicit rule to *Makefile.am*
    to create or update it. This is where the `atconfig` rule at ➏ in [Listing 9-2](ch09.xhtml#ch09ex2)
    comes in. The `check-local` rule depends on it, so its commands will be executed
    if *atconfig* is missing or older than its dependency, `$(top_builddir)/config.status`,
    when `make check` is executed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，*atconfig* 脚本（同样由 `testsuite` 引用）是由 `AC_CONFIG_TESTDIR` 自动生成的。问题在于，尽管
    `config.status` 理解如何构建这个文件，但 Automake 并不知道它，因为它没有直接列出在 *configure.ac* 中任何实例化宏调用的列表中，因此我们需要在
    *Makefile.am* 中添加一个明确的规则来创建或更新它。这就是在 [清单 9-2](ch09.xhtml#ch09ex2) 中 ➏ 位置的 `atconfig`
    规则的作用。`check-local` 规则依赖于它，因此当执行 `make check` 时，如果 *atconfig* 缺失或比其依赖项 `$(top_builddir)/config.status`
    旧，它的命令会被执行。
- en: The command in the rule for generating `$(srcdir)/package.m4` at ➐ (note there
    is only one command here) merely writes text into the target file if the file
    is missing or older than *configure.ac*. This is an optional input file (see [Figure
    9-1](ch09.xhtml#ch09fig1)), the contents of which are actually required by autotest
    in some form. Several M4 macros must be defined in the input data that is processed
    by autotest to create a test suite, including `AT_PACKAGE_NAME`, `AT_PACKAGE_TARNAME`,
    `AT_PACKAGE_VERSION`, `AT_PACKAGE_STRING`, `AT_PACKAGE_BUGREPORT`, and `AT_PACKAGE_URL`.
    These variables may be defined directly in *testsuite.at* (or any of the subfiles
    included by that file), but it makes more sense to generate this information from
    values already found in *configure.ac* so we don’t have to maintain two sets of
    the same information. This is the very reason why *package.m4* is included automatically
    by `autom4te` if it’s found while processing *testsuite.at*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 生成`$(srcdir)/package.m4`的规则中的命令在➐位置（注意这里只是一个命令）仅在文件缺失或比*configure.ac*旧时将文本写入目标文件。这是一个可选的输入文件（见[图
    9-1](ch09.xhtml#ch09fig1)），其内容实际上是autotest以某种形式所需的。多个M4宏必须在输入数据中定义，autotest会处理这些数据以创建测试套件，包括`AT_PACKAGE_NAME`、`AT_PACKAGE_TARNAME`、`AT_PACKAGE_VERSION`、`AT_PACKAGE_STRING`、`AT_PACKAGE_BUGREPORT`和`AT_PACKAGE_URL`。这些变量可以直接在*testsuite.at*（或该文件包含的任何子文件）中定义，但从已经在*configure.ac*中找到的值生成这些信息更为合理，这样我们就不必维护两份相同的信息。这正是为什么如果在处理*testsuite.at*时找到*package.m4*，`autom4te`会自动包含它。
- en: But wait—why not use `AC_CONFIG_FILES` to have `configure` generate this file?
    All we’re doing is generating a text file that contains configuration variables,
    and that sounds like exactly what `AC_CONFIG_FILES` is for. The problem is, `AC_CONFIG_FILES`
    and the other instantiating macros always generate files into the build tree,
    and *package.m4* must end up in the source tree in order to be added to the distribution
    archive (not because it’s part of any build or execution process the user may
    instigate, but because it’s part of the source code for `testsuite`). Perhaps
    the full integration of autotest, at some point in the future, will result in
    the ability to request the instantiating macros to generate files into the source
    tree. Until then, this is what we have to work with.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 等等——为什么不使用`AC_CONFIG_FILES`让`configure`来生成这个文件呢？我们所做的只是生成一个包含配置变量的文本文件，这正是`AC_CONFIG_FILES`的作用。问题在于，`AC_CONFIG_FILES`和其他实例化宏总是将文件生成到构建树中，而*package.m4*必须放到源代码树中，才能被添加到分发归档中（不是因为它是用户可能启动的任何构建或执行过程的一部分，而是因为它是`testsuite`的源代码的一部分）。也许在未来的某个时刻，autotest的完全集成将导致可以要求实例化宏将文件生成到源代码树中。在那之前，这就是我们所能使用的。
- en: The fourth and final rule, `$(TESTSUITE)`, at ➑, generates `$(srcdir)/testsuite`
    using the `$(AUTOTEST)` command. Because `$(TESTSUITE)` is a dependency of `check-local`,
    it’ll get built if it’s not up-to-date. The `autom4te` program, when executed
    in *autotest mode*, accepts the `-I` option for specifying include paths for *.at*
    files that may be included by *testsuite.at* or any of its inclusions. It also
    accepts the `-o` option for specifying the output file, `testsuite`.^([3](footnote.xhtml#ch09fn3))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第四条也是最后一条规则，`$(TESTSUITE)`，在➑位置，使用`$(AUTOTEST)`命令生成`$(srcdir)/testsuite`。因为`$(TESTSUITE)`是`check-local`的一个依赖项，如果它不是最新的，就会被构建。`autom4te`程序在*autotest模式*下执行时，接受`-I`选项来指定可能由*testsuite.at*或其任何包含文件包含的*.at*文件的包含路径。它还接受`-o`选项来指定输出文件`testsuite`。^([3](footnote.xhtml#ch09fn3))
- en: '**NOTE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I’ve added *`$(AM_V_GEN)`* in front of the commands of the last two rules
    in [Listing 9-2](ch09.xhtml#ch09ex2) to allow my custom rules to tie into the
    Autotools’ silent build rules system. Any command prefixed with *`$(AM_V_GEN)`*
    will cause the normal command output to be replaced with *`GEN`* `target` when
    building with silent rules enabled. See Section 21.3 of the GNU Automake manual
    for more details on this and other variables that affect build output when building
    with silent rules.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在[清单 9-2](ch09.xhtml#ch09ex2)中添加了*`$(AM_V_GEN)`*，以便让我自定义的规则能够与Autotools的静默构建规则系统结合。任何以*`$(AM_V_GEN)`*为前缀的命令都会导致正常的命令输出在启用静默构建规则时被替换为*`GEN`*
    `target`。有关此和其他影响构建输出的变量的更多细节，请参阅GNU Automake手册的第21.3节。*'
- en: Taken as a whole, all of this allows us to run `make check` at the command prompt
    to build (if needed) and execute `$(srcdir)/testsuite`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这一切使得我们能够在命令行中运行`make check`，以构建（如果需要）并执行`$(srcdir)/testsuite`。
- en: '**NOTE**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There’s a bit more we need to do in this* Makefile.am *file to fully integrate
    autotest functionality into Automake. We’ll add some additional administrative
    rules and variables later in this chapter. For clarity at this point, I limited
    the content to just what we need to build and run the test suite.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个* Makefile.am *文件中，我们还需要做一些工作，以完全将 autotest 功能集成到 Automake 中。稍后我们将在本章中添加一些额外的管理规则和变量。为了清晰起见，此时我将内容限制为仅包含我们需要构建和运行测试套件的部分。*'
- en: Well, we’ve created a new directory and added a new *Makefile.am*. By now, you
    should be automatically thinking about how this *Makefile.am* file is going to
    be called if we don’t link it into the top-level *Makefile.am* `SUBDIRS` variable.
    You’re absolutely correct—this must be our next step. [Listing 9-3](ch09.xhtml#ch09ex3)
    shows this modification to the top-level *Makefile.am* file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经创建了一个新目录并添加了一个新的 *Makefile.am*。现在，你应该自动开始思考，如果我们不将它链接到顶层 *Makefile.am*
    的 `SUBDIRS` 变量中，这个 *Makefile.am* 文件将如何被调用。你完全正确——这将是我们接下来的步骤。[清单 9-3](ch09.xhtml#ch09ex3)展示了对顶层
    *Makefile.am* 文件的修改。
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-3:* Makefile.am: *Adding the tests subdirectory*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3:* Makefile.am: *添加测试子目录*'
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I added tests last. This will almost always be the pattern for a directory
    such as* tests. *In order to test the system, most, if not all, of the other directories
    must be built first.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*我最后添加了测试。这几乎总是像* tests 这样的目录的模式。*为了测试系统，大多数（如果不是所有的话）其他目录必须先构建。*'
- en: The second file in [Listing 9-1](ch09.xhtml#ch09ex1) is the *atlocal* shell
    script that’s automatically sourced by `testsuite`, if present, which may be used
    to pass additional configuration variables through to `testsuite`’s runtime environment.
    We’ll use this file in the Jupiter project to pass the `async_exec` flag through
    to `testsuite` so it may know if the program it’s testing has been configured
    with the *async-exec* feature enabled. [Listing 9-4](ch09.xhtml#ch09ex4) shows
    how this is done in *atlocal*’s template, *atlocal.in*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-1](ch09.xhtml#ch09ex1)中的第二个文件是 *atlocal* shell 脚本，如果存在，`testsuite` 会自动调用它，这可以用来将额外的配置变量传递到
    `testsuite` 的运行时环境中。我们将在 Jupiter 项目中使用这个文件，将 `async_exec` 标志传递给 `testsuite`，以便它知道它正在测试的程序是否已启用
    *async-exec* 特性。[清单 9-4](ch09.xhtml#ch09ex4)展示了如何在 *atlocal* 模板 *atlocal.in* 中实现这一点。'
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-4:* tests/atlocal.in: *A template for generating* atlocal'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-4:* tests/atlocal.in: *生成 atlocal 的模板*'
- en: Now, this causes a small problem for us because `configure` is not yet exporting
    a substitution variable called `async_exec`. We wrote a shell script that uses
    a shell variable of this name back in [Chapter 5](ch05.xhtml), but recall we only
    used it to indicate whether we should invoke `AC_DEFINE` to generate the `ASYNC_EXEC`
    preprocessor definition into *config.h.in*. We now need to use `AC_SUBST` on this
    variable in order to generate an Autoconf substitution variable of the same name.
    [Listing 9-5](ch09.xhtml#ch09ex5) highlights the single-line addition to *configure.ac*
    required to make this happen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这对我们来说带来了一个小问题，因为 `configure` 尚未导出名为 `async_exec` 的替代变量。我们在[第 5 章](ch05.xhtml)中写了一个
    shell 脚本，使用了这个名称的 shell 变量，但请记住，我们只是用它来指示是否应该调用 `AC_DEFINE` 以将 `ASYNC_EXEC` 预处理器定义生成到
    *config.h.in* 中。现在，我们需要使用 `AC_SUBST` 处理这个变量，以便生成一个同名的 Autoconf 替代变量。[清单 9-5](ch09.xhtml#ch09ex5)突出了
    *configure.ac* 中的单行添加，以实现这一点。
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-5:* configure.ac: *Making autoconf generate the `async_exec` substitution
    variable*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5:* configure.ac: *使 autoconf 生成 `async_exec` 替代变量*'
- en: 'One last comment on [Listing 9-1](ch09.xhtml#ch09ex1): we could have simply
    added these files to the existing invocation of `AC_CONFIG_FILES` at the bottom
    of *configure.ac*, but using a separate invocation here keeps test-related items
    together. It also serves to illustrate the fact that `AC_CONFIG_FILES` may indeed
    be invoked multiple times within *configure.ac*, the results being cumulative.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[清单 9-1](ch09.xhtml#ch09ex1)的最后一点评论：我们本可以将这些文件简单地添加到 *configure.ac* 底部现有的
    `AC_CONFIG_FILES` 调用中，但这里使用单独的调用可以将与测试相关的项目聚集在一起。它还表明，`AC_CONFIG_FILES` 确实可以在
    *configure.ac* 中多次调用，并且结果是累积的。
- en: We now need to create a set of source *.at* files that can be used by `autom4te`
    to generate our test program. This set of files can be as simple as a single *testsuite.at*
    file or as complex as the diagram in [Figure 9-1](ch09.xhtml#ch09fig1), including
    *testsuite.at*, a set of test-group-specific *.at* files, and a *local.at* file.
    These files will contain autotest macro invocations mixed with simple or complex
    shell script, as required by your testing needs. We’ll start with a single line
    of autotest initialization code in a *tests/local.at* file, as shown in [Listing
    9-6](ch09.xhtml#ch09ex6).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要创建一组源*.at*文件，供`autom4te`使用，以生成我们的测试程序。这组文件可以像单个*testsuite.at*文件一样简单，或像[图9-1](ch09.xhtml#ch09fig1)中的示意图那样复杂，包括*testsuite.at*、一组特定测试组的*.at*文件以及一个*local.at*文件。这些文件将包含自动测试宏调用，并根据测试需求混合简单或复杂的Shell脚本。我们将从一个包含自动测试初始化代码的单行*tests/local.at*文件开始，如[清单
    9-6](ch09.xhtml#ch09ex6)所示。
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-6:* tests/local.at: *Initialization code for `testsuite` can be
    added to a* local.at file'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-6:* tests/local.at：*可以将`testsuite`的初始化代码添加到* local.at 文件中。'
- en: The `AT_INIT` macro is required by `autom4te` to be found somewhere within the
    translation unit presented by *testsuite.at* and its inclusions. This single macro
    invocation expands into several hundred lines of shell script that define the
    basic testing framework and all of the ancillary boilerplate functionality associated
    with it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`AT_INIT`宏是`autom4te`所必需的，它必须出现在*testsuite.at*及其包含文件中呈现的翻译单元中的某个地方。这个单一的宏调用会展开成几百行的Shell脚本，定义了基本的测试框架以及与之相关的所有附加模板功能。'
- en: 'We also need to create an empty *testsuite.at* file in the *tests* directory.
    We’ll add items to it as we progress:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在*tests*目录下创建一个空的*testsuite.at*文件。随着进展，我们会向其中添加内容：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now have the basis for generation and execution of the autotest framework
    in Jupiter. Every project that uses autotest will have to be configured in the
    manner we’ve shown so far. For smaller projects, some of the optional pieces may
    be omitted, the contents of which would then be combined directly into *testsuite.at*.
    We’ll discuss how to simplify when we’ve completed our exploration of autotest.
    For now, let’s give it a try:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为在Jupiter中生成和执行自动测试框架奠定了基础。每个使用自动测试的项目都必须按照我们目前展示的方式进行配置。对于较小的项目，一些可选的部分可以省略，这些内容将直接合并到*testsuite.at*中。我们将在完成自动测试的探索后讨论如何简化。目前，让我们先试一下：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see from the output of `configure` that our generated files were created
    in the *tests* directory, as expected. It also appears that the code generated
    by `AC_CONFIG_TESTDIR` has wired in the generation of the *tests/atconfig* file
    as a *command* tag, rather than as a simple template file, using `AC_CONFIG_COMMANDS`
    internally.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`configure`的输出中看到，生成的文件已经按照预期创建在*tests*目录下。看起来，由`AC_CONFIG_TESTDIR`生成的代码已将*tests/atconfig*文件的生成作为*command*标签，而不是作为简单的模板文件，内部使用`AC_CONFIG_COMMANDS`。
- en: We then see from the output of `make check` that `testsuite` was both built
    and executed. We can’t yet incorporate `testsuite` into a distribution archive
    from the `dist` or `distcheck` targets because we haven’t wired our autotest functionality
    into Automake. However, when we complete our changes at the end of this chapter,
    you’ll find that running `make check` against the contents of a distribution archive
    will not build `testsuite`, as it will have shipped with the archive (assuming
    we haven’t touched any of `testsuite`’s dependencies).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们从`make check`的输出中看到，`testsuite`已经被构建并执行。我们目前还不能将`testsuite`纳入从`dist`或`distcheck`目标生成的发行档案中，因为我们还没有将自动测试功能接入到Automake中。然而，当我们在本章末完成更改时，你会发现运行`make
    check`时，针对发行档案的内容将不会构建`testsuite`，因为它已经随档案一起发布（假设我们没有修改任何`testsuite`的依赖项）。
- en: '**NOTE**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*One interesting item of note near the top of the *`make check`* output is
    highlighted by the lines starting with *`make[1]:`* and *`make[2]:`*, where *`make`*
    indicates it’s entering the jupiter/tests directory twice. This happens because
    of the *`check-local`* hook we added, where the *`check`* target recursively invokes
    *`$(MAKE) check-local`* as a command within the same directory.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*在*`make check`*输出的顶部附近，有一项有趣的内容由以*`make[1]:`*和*`make[2]:`*开头的行高亮显示，其中*`make`*表示它两次进入了jupiter/tests目录。这是因为我们添加了*`check-local`*钩子，*`check`*目标在相同目录中递归调用*`$(MAKE)
    check-local`*作为命令。*'
- en: Great, it works—with `make check` anyway. But it doesn’t do anything yet except
    print a few extra lines of text to the console. To make it do something useful,
    we need to add some tests. Therefore, our first task will be to move the original
    Automake-based `jupiter` execution test from *src/Makefile.am* into our autotest
    test suite.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，它能工作——至少在`make check`下是这样。但是目前它还什么都不做，只是在控制台上打印几行额外的文本。为了让它做一些有用的事情，我们需要添加一些测试。因此，我们的第一项任务是将最初基于Automake的`jupiter`执行测试从*src/Makefile.am*移入我们的autotest测试套件中。
- en: Adding a Test
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加测试
- en: Autotest tests are bundled into sets called *test groups*. The purpose of a
    test group is to allow tests within a group to interact with each other. For example,
    the first test in a group may generate some data files used by subsequent tests
    within the same group.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试将测试打包成称为*测试组*的集合。测试组的目的是允许组内的测试互相交互。例如，组内的第一个测试可能会生成一些数据文件，后续的测试会使用这些文件。
- en: Tests that interact with each other are harder to debug, and broken tests are
    harder to reproduce if they require other tests to run first. Multi-test groups
    are hard to avoid when striving for full coverage; the ideal is to have only one
    test per test group as much as possible. Where you just can’t do it, test groups
    exist to facilitate the required interaction. The crux of this facility is that
    *tests within the same test group are executed within the same temporary directory*,
    allowing initial tests to generate files that subsequent tests can then see and
    access.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 互相交互的测试更难调试，如果它们需要先运行其他测试才能复现问题，那么损坏的测试也更难复现。在追求完全覆盖时，多个测试组很难避免；理想的情况是每个测试组尽可能只包含一个测试。对于无法做到这一点的情况，测试组的存在是为了促进所需的交互。该功能的关键在于，*同一测试组内的测试会在同一个临时目录中执行*，允许初始测试生成的文件供后续测试查看和访问。
- en: 'Our single test will not suffer from these problems—mainly because we haven’t
    yet put much effort into testing Jupiter (and, if we’re honest with ourselves,
    there isn’t much actual code to test). Right now, when you execute `make check`,
    you see two sets of test output on the screen:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单个测试不会遭遇这些问题——主要是因为我们还没有投入很多精力测试Jupiter（如果我们实话实说，其实也没有太多代码需要测试）。目前，当你执行`make
    check`时，屏幕上会显示两组测试输出：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first set of tests (beginning at ➊) are executed in the *jupiter/src* directory.
    This is our original `grep`-based test where we check `jupiter`’s output against
    a pattern. As you can see, the basic test framework built into Automake is not
    bad. We’re hoping to improve on that framework with autotest. The second set of
    tests (beginning at ➋) are executed in the *jupiter/tests* directory and involve
    autotest.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组测试（从➊开始）在* jupiter/src *目录中执行。这是我们最初基于`grep`的测试，检查`jupiter`的输出是否与模式匹配。正如你所见，Automake中内置的基本测试框架并不差。我们希望通过autotest对这个框架进行改进。第二组测试（从➋开始）在*
    jupiter/tests *目录中执行，并涉及到autotest。
- en: Defining Tests with AT_CHECK
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用AT_CHECK定义测试
- en: 'The `grep`-based test we’ve been using in *src/Makefile.am* is a perfect example
    for use in the `AT_CHECK` macro provided by the autotest framework. Here are the
    prototypes for the `AT_CHECK` family of macros:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*src/Makefile.am*中使用的基于`grep`的测试是一个完美的示例，可以用在autotest框架提供的`AT_CHECK`宏中。以下是`AT_CHECK`宏系列的原型：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`AT_CHECK` executes *`commands`*, checks the returned status against *`status`*,
    and compares the output on `stdout` and `stderr` with the contents of the *`stdout`*
    and *`stderr`* macro arguments. If *`status`* is omitted, autotest assumes a successful
    status code of zero. If *`commands`* returns a status code to the shell that does
    not match the expected status code specified in *`status`*, the test fails. In
    order to ignore the status code of *`commands`*, you should use the special command
    `ignore` in the *`status`* parameter.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`AT_CHECK`执行*`commands`*，将返回的状态与*`status`*进行比较，并将`stdout`和`stderr`上的输出与*`stdout`*和*`stderr`*宏参数的内容进行比较。如果省略了*`status`*，自动化测试默认假设状态码为零的成功。如果*`commands`*返回的状态码与*`status`*中指定的预期状态码不符，则测试失败。为了忽略*`commands`*的状态码，应该在*`status`*参数中使用特殊命令`ignore`。'
- en: 'Regardless, there are a couple of status codes that even `ignore` will not
    ignore: a status code of 77 (skip) returned by *`commands`* will cause autotest
    to skip the rest of the tests in the current test group, while 99 (hard failure)
    will cause autotest to fail the entire test group immediately.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，有一些状态码是即使是`ignore`也无法忽略的：*`commands`*返回的状态码77（跳过）会导致自动化测试跳过当前测试组中其余的测试，而99（硬错误）则会立即使自动化测试失败整个测试组。
- en: 'Like *`status`*, the *`stdout`* and *`stderr`* parameters appear to be optional,
    but looks can be deceiving. If you pass nothing in these arguments, this merely
    tells Autoconf that the test’s `stdout` and `stderr` output streams are expected
    to be empty. Anything else will fail the test. So how do we tell autotest we don’t
    want to check the output? As with *`status`*, we can use special commands in *`stdout`*
    or *`stderr`*, including those shown in [Table 9-1](ch09.xhtml#ch09tab1):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 像*`status`*一样，*`stdout`*和*`stderr`*参数似乎是可选的，但外表可能会欺骗你。如果你什么都不传递给这些参数，这只是告诉Autoconf，测试的`stdout`和`stderr`输出流预计为空。其他任何内容都会导致测试失败。那么我们如何告诉autotest我们不想检查输出呢？与*`status`*一样，我们可以在*`stdout`*或*`stderr`*中使用特殊命令，包括[表9-1](ch09.xhtml#ch09tab1)中列出的命令：
- en: '**Table 9-1:** Special Commands Allowed in *`stdout`* and *`stderr`* Arguments.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**表9-1：** 允许在*`stdout`*和*`stderr`*参数中使用的特殊命令。'
- en: '| **Command** | **Description** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| `ignore` | Do not check this output stream, but do log it to the test group’s
    log file. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `ignore` | 不检查此输出流，但会将其记录到测试组的日志文件中。 |'
- en: '| `ignore-no-log` | Do not check or log this output stream. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `ignore-no-log` | 不检查也不记录此输出流。 |'
- en: '| `stdout` | Log and capture the test’s `stdout` output to the file `stdout`.
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `stdout` | 将测试的`stdout`输出记录并捕获到文件`stdout`中。 |'
- en: '| `stderr` | Log and capture the test’s `stderr` output to the file `stderr`.
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `stderr` | 将测试的`stderr`输出记录并捕获到文件`stderr`中。 |'
- en: '| `stdout-nolog` | Capture the test’s `stdout` output to the file `stdout`,
    but do not log. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `stdout-nolog` | 将测试的`stdout`输出捕获到文件`stdout`中，但不记录日志。 |'
- en: '| `stderr-nolog` | Capture the test’s `stderr` output to the file `stderr`,
    but do not log. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `stderr-nolog` | 将测试的`stderr`输出捕获到文件`stderr`中，但不记录日志。 |'
- en: '| `expout` | Compare the test’s `stdout` output to the file `expout`, created
    earlier; log the differences. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `expout` | 将测试的`stdout`输出与先前创建的文件`expout`进行比较，记录差异。 |'
- en: '| `experr` | Compare the test’s `stderr` output to the file `experr`, created
    earlier; log the differences. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `experr` | 比较测试的`stderr`输出与先前创建的文件`experr`，并记录差异。 |'
- en: The *`run-if-fail`* and *`run-if-pass`* arguments allow you to optionally specify
    shell code that should be executed upon test failure or success, respectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*`run-if-fail`*和*`run-if-pass`*参数允许你可选地指定应在测试失败或成功时分别执行的shell代码。'
- en: '`AT_CHECK_UNQUOTED` does exactly the same thing as `AT_CHECK`, except that
    it performs shell expansion on *`stdout`* and *`stderr`* first, before making
    the comparison with the output of *`commands`*. Since `AT_CHECK` doesn’t do shell
    expansion on *`stdout`* and *`stderr`*, it stands to reason that you need to use
    `AT_CHECK_UNQUOTED` if you reference any shell variables in the text of these
    parameters.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`AT_CHECK_UNQUOTED`的功能与`AT_CHECK`完全相同，唯一的区别是它首先对*`stdout`*和*`stderr`*进行shell扩展，然后再与*`commands`*的输出进行比较。由于`AT_CHECK`不会对*`stdout`*和*`stderr`*进行shell扩展，因此如果你在这些参数的文本中引用了任何shell变量，显然你需要使用`AT_CHECK_UNQUOTED`。'
- en: Defining Test Groups with AT_SETUP and AT_CLEANUP
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用AT_SETUP和AT_CLEANUP定义测试组
- en: 'The `AT_CHECK` macro must be invoked between invocations of `AT_SETUP` and
    `AT_CLEANUP`, the pair of which define a test group and, therefore, the temporary
    directory from which the tests in the group are executed. The prototypes for these
    macros are defined as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`AT_CHECK`宏必须在`AT_SETUP`和`AT_CLEANUP`的调用之间调用，这两个宏定义了一个测试组，从而定义了测试组中测试执行的临时目录。这些宏的原型如下所示：'
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you’ve got any experience with the *xUnit* family of unit test frameworks
    (JUnit, NUnit, CPPUnit, and so on), you’ve probably got a pretty strong notion
    of what the setup and cleanup (or teardown) functions should be used for. Usually
    a *setup* function runs some common code before each test in a test set, and a
    *cleanup* or *teardown* function executes some common code at the end of each
    test in the set.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有使用过*xUnit*系列单元测试框架（如JUnit、NUnit、CPPUnit等）的经验，你可能已经对设置（setup）和清理（cleanup）或拆解（teardown）函数的用途有了相当清晰的认识。通常，*setup*函数会在每个测试集中的每个测试之前运行一些公共代码，而*cleanup*或*teardown*函数会在测试集中的每个测试结束时执行一些公共代码。
- en: Autotest is a bit different—there is no formal setup or teardown functionality
    shared by tests belonging to the same group (although this sort of functionality
    can be emulated with shell functions defined within the test group in *testsuite.at*,
    or in its included subfiles). As with *xUnit* frameworks, Autotest runs every
    test in total isolation, because every test runs within its own subshell. The
    only way a test can affect a subsequent test is by sharing the same test group
    and leaving filesystem droppings around for subsequent tests to examine and act
    upon.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Autotest稍有不同——没有正式的设置或拆解功能由属于同一组的测试共享（尽管这种功能可以通过在*testsuite.at*中的测试组内，或在其包含的子文件中定义的shell函数进行模拟）。与*xUnit*框架一样，Autotest将每个测试完全隔离运行，因为每个测试都在其自己的子shell中运行。一个测试唯一能影响后续测试的方式是通过共享同一个测试组，并且在文件系统中留下数据供后续测试检查并进行操作。
- en: '`AT_SETUP` accepts only one argument, *`test-group-name`*, which is the name
    of the test group that we’re starting, and this argument is required. `AT_CLEANUP`
    accepts no arguments.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`AT_SETUP`只接受一个参数，*`test-group-name`*，这是我们要开始的测试组的名称，而且这个参数是必需的。`AT_CLEANUP`不接受任何参数。'
- en: We’ll add the group setup and cleanup macro invocations, wrapping a call to
    `AT_CHECK`, to a new file, *tests/jupiter.at*, as shown in [Listing 9-7](ch09.xhtml#ch09ex7).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个新文件*tests/jupiter.at*中添加组设置和清理宏调用，并包装对`AT_CHECK`的调用，如[清单 9-7](ch09.xhtml#ch09ex7)所示。
- en: Git tag 9.1
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 9.1
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-7:* tests/jupiter.at: *Adding our first test group—attempt #1*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-7:* tests/jupiter.at: *添加我们的第一个测试组——尝试 #1*'
- en: Libtool adds a wrapper script in the *src* directory for any executables that
    use Libtool shared libraries. This wrapper script allows `jupiter` to find the
    uninstalled Libtool libraries it’s trying to use. As mentioned in [Chapter 7](ch07.xhtml),
    it’s a convenience mechanism that Libtool provides so we don’t have to jump through
    hoops to test programs using Libtool shared libraries before they’re installed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Libtool在*src*目录中为任何使用Libtool共享库的可执行文件添加了一个包装脚本。这个包装脚本允许`jupiter`找到它试图使用的未安装的Libtool库。如[第7章](ch07.xhtml)所述，这是一种Libtool提供的便捷机制，使我们不必在程序使用Libtool共享库并且尚未安装之前就进行测试。
- en: The end result is that the *src/jupiter* script is executing the real `jupiter`
    program from *src/.libs/lt-jupiter*. Because `jupiter` displays its own location,
    based on its `argv[0]` contents, we need to expect it to print this path.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是*src/jupiter*脚本执行了真正的`jupiter`程序，来自*src/.libs/lt-jupiter*。因为`jupiter`根据其`argv[0]`的内容显示其自身位置，我们需要预期它打印出这个路径。
- en: We then need to add an `m4_include` statement to our currently empty *testsuite.at*
    file in order to include *jupiter.at*, as shown in [Listing 9-8](ch09.xhtml#ch09ex8).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在当前空的*testsuite.at*文件中添加一个`m4_include`语句，以便包含* jupiter.at*，如[清单 9-8](ch09.xhtml#ch09ex8)所示。
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-8:* tests/testsuite.at: *Including* jupiter.at *in* testsuite.at'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-8:* tests/testsuite.at: *在* testsuite.at *中包含* jupiter.at'
- en: We’ll also want to add this new source file to our *tests/Makefile.am* file’s
    `TESTSOURCES` variable so it becomes a prerequisite of `testsuite`, as shown in
    [Listing 9-9](ch09.xhtml#ch09ex9).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将这个新源文件添加到*tests/Makefile.am*文件的`TESTSOURCES`变量中，使其成为`testsuite`的前提条件，如[清单
    9-9](ch09.xhtml#ch09ex9)所示。
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-9:* tests/Makefile.am: *Adding additional sources to `TESTSOURCES`*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-9:* tests/Makefile.am: *将额外的源添加到`TESTSOURCES`*'
- en: 'We’ll follow this practice for every test we add to our test suite. In the
    end, the only thing in *testsuite.at* will be several invocations of `m4_include`,
    one for each test group. Executing this code renders the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们添加到测试套件中的每个测试，我们都会遵循这一做法。最终，*testsuite.at*中只会包含几次对`m4_include`的调用，每个测试组对应一次调用。执行这段代码会输出以下内容：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**NOTE**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Running `autoreconf` and `configure` was required only because we updated
    the* tests/Makefile.am *file. If we’d just touched an existing .at file, which
    is rebuilt by the `check` target in* tests/Makefile, *then neither `autoreconf`
    nor `configure` would have been necessary.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*运行`autoreconf`和`configure`仅仅是因为我们更新了* tests/Makefile.am *文件。如果我们只是修改了一个现有的.at文件，而这个文件是由*
    tests/Makefile *中的`check`目标重新构建的，那么就不需要`autoreconf`和`configure`了。*'
- en: I’ll admit here that our single test failed because I deliberately coded the
    test incorrectly in order to show you what a failed test looks like.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里承认，我们的单个测试失败了，因为我故意将测试编写错误，以向你展示失败的测试是什么样子的。
- en: Although not obvious from the output, there is more than one *testsuite.log*
    file created by `testsuite` when tests fail. The first is a master *testsuite.log*
    file in the *tests* directory, which is always created, even when all tests pass,
    and is designed to be sent in bug reports to the project maintainer. There is
    also a log file of the same name in a separate numbered directory within the *tests/testsuite.dir*
    directory for failed tests. The name of each of these directories is the number
    of the test group that failed. The test group number can be seen in the output.
    While you only need the master *testsuite.log* file, since it contains the entire
    contents of all of the individual tests’ *testsuite.log* files, this file also
    contains a lot of other information about your project and the test environment
    that the maintainer would want to see but just gets in the way for our purposes
    here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从输出中不容易看出，但 `testsuite` 在测试失败时会创建多个 *testsuite.log* 文件。第一个是位于 *tests* 目录下的主
    *testsuite.log* 文件，这个文件总是会被创建，即使所有测试都通过，并且这个文件旨在发送给项目维护者作为错误报告。另一个同名的日志文件位于 *tests/testsuite.dir*
    目录中的一个单独的编号目录下，用于记录失败的测试。每个这些目录的名称是失败的测试组的编号，测试组编号可以在输出中看到。虽然你只需要主 *testsuite.log*
    文件，因为它包含了所有单独测试的 *testsuite.log* 文件的全部内容，但这个文件也包含了许多关于项目和测试环境的其他信息，维护者会希望看到这些信息，但对于我们来说，这些信息会造成干扰。
- en: 'To see exactly how our test failed, let’s examine the contents of the *testsuite**.log*
    file left in the *tests/testsuite.dir/1* directory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要准确查看我们的测试失败原因，首先让我们检查一下 *testsuite**.log* 文件的内容，该文件位于 *tests/testsuite.dir/1*
    目录下：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First note that autotest writes, as often as possible, the related source line
    into the *testsuite.log* file. This isn’t a big win for us at this point, but
    if *testsuite.at* or its included files were long and complicated, you can see
    how this information could be very helpful.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意，autotest 尽可能将相关的源代码行写入 *testsuite.log* 文件。此时这对我们来说并没有太大帮助，但如果 *testsuite.at*
    或其包含的文件很长且复杂，你会发现这些信息会非常有用。
- en: At ➊, we see the argument we passed to the *`commands`* parameter of `AT_CHECK`,
    along with the number of the line at which this argument was passed to the macro
    in *jupiter.at*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们可以看到传递给 `AT_CHECK` 的 *`commands`* 参数以及将该参数传递给 *jupiter.at* 宏时所在的行号。
- en: However, now things start to get a bit muddy. The entire point of the *`stdout`*
    and *`stderr`* arguments in `AT_CHECK` is to provide some comparison text for
    what is actually sent by the *`commands`* to these output streams. In accordance
    with the general Unix philosophy of not duplicating existing functionality, the
    autotest authors chose to use the `diff` utility to make these comparisons. The
    log lines from ➋ to ➌ (inclusive) show the *unified*^([4](footnote.xhtml#ch09fn4))
    output of the `diff` utility when comparing the *original* file (*/dev/null* since
    we passed no value in the *`stderr`* argument) to the *modified* file—the text
    sent to the `stderr` output stream during the attempt to execute *../src/jupiter*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在事情开始变得有些模糊。*`stdout`* 和 *`stderr`* 参数在 `AT_CHECK` 中的作用就是提供一些比较文本，用来显示 *`commands`*
    实际发送到这些输出流的内容。根据 Unix 一般哲学中避免重复已有功能的原则，autotest 的作者选择使用 `diff` 工具来进行这些比较。从➋到➌（包括）之间的日志行显示了
    `diff` 工具在比较 *原始* 文件（*/dev/null*，因为我们没有在 *`stderr`* 参数中传递任何值）和 *修改* 文件时的 *统一*^([4](footnote.xhtml#ch09fn4))
    输出——这个修改文件是在尝试执行 *../src/jupiter* 时发送到 `stderr` 输出流的文本。
- en: If you’re not familiar with unified `diff` output, a brief explanation is in
    order. The two lines starting at ➋ indicate the objects being compared. The original,
    or minus (`---`), line indicates the left side of the comparison, while the modified,
    or plus (`+++`), line indicates the right side of the comparison. Here, we’re
    comparing */dev/null* with a temporary file called */.../jupiter/tests/testsuite.dir/at-groups/1/stderr*
    that was used by autotest to capture the `stderr` stream during the attempt to
    execute *../src/jupiter*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉统一的 `diff` 输出，下面是简要说明。从➋开始的两行表示正在比较的对象。原始的，或减号（`---`）行表示比较的左侧，而修改的，或加号（`+++`）行表示比较的右侧。在这里，我们正在比较
    */dev/null* 和一个名为 */.../jupiter/tests/testsuite.dir/at-groups/1/stderr* 的临时文件，该文件由
    autotest 用来捕获执行 *../src/jupiter* 时的 `stderr` 流。
- en: The next line, starting and ending with `@@`, is a *chunk* marker—`diff`’s way
    of telling us about a portion of the two files that does not match. There can
    be more than one chunk in the output displayed by `diff`. In this case, the entire
    output text is so short that only one chunk was required to show us the differences.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行，以 `@@` 开头和结尾，是一个 *块*标记——`diff` 用来告诉我们两个文件中不匹配的部分。`diff` 显示的输出中可能有多个块。在这种情况下，由于输出文本非常短，只需要一个块来展示差异。
- en: 'The numbers in the chunk marker represent two ranges, separated by a space.
    The first range starts with a minus (`-`) sign, indicating the range associated
    with the *original* file, and the second range starts with a plus (`+`) sign,
    indicating the range associated with the *modified* file. Here’s the line we’re
    currently discussing:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 块标记中的数字代表两个范围，由空格分隔。第一个范围以减号（`-`）开头，表示与*原始*文件相关的范围，第二个范围以加号（`+`）开头，表示与*修改后*文件相关的范围。这里是我们当前讨论的那一行：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A range is made up of two integer values separated by a comma (`,`) or a single
    value with a default second value of 1\. In this example, the range being compared
    starts at zero in the original file and is zero lines long, while the comparison
    range in the second file starts at line 1 and is one line long. These ranges are
    1-based, meaning line 1 is the first line in the file. Therefore, the first range
    specification, `-0,0`, is a special range that means there’s no content in the
    file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 范围由两个整数值组成，这两个值由逗号（`,`）分隔，或者是一个值，默认第二个值为 1。在这个例子中，比较的范围在原始文件中从零开始，并且长度为零行，而第二个文件中的比较范围从第
    1 行开始，长度为一行。这些范围是基于 1 的，也就是说，第 1 行是文件中的第一行。因此，第一个范围说明`-0,0`是一个特殊范围，意味着文件中没有内容。
- en: 'The lines following the range specification contain the full text of these
    ranges, showing us the actual differences. The original file lines are printed
    first, each prefixed with a minus sign, and then the modified file lines are printed
    afterward, each prefixed with a plus sign. When there is enough content around
    the modified lines to do so, additional unprefixed lines are added before and
    after these lines, showing some context around the changes. In this case, the
    entire content of this section is:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随范围说明的行包含这些范围的完整文本，向我们展示实际的差异。原始文件的行首先被打印，每行前面带有一个减号，然后是修改后的文件行，每行前面带有一个加号。当修改行周围有足够的内容时，还会在这些行之前和之后添加额外的无前缀行，显示一些关于更改的上下文。在这种情况下，本节的全部内容是：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the original file was empty, as indicated by the `-0,0` range in the chunk
    marker, there are no lines starting with minus. All we see is the one modified
    file line starting with a plus.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原始文件是空的，如块标记中的`-0,0`范围所示，因此没有任何以减号开头的行。我们只看到一行修改后的文件行，以加号开头。
- en: 'Well, clearly these files are not the same—we expected nothing on the `stderr`
    stream, but we got some error text instead. The shell experienced an error attempting
    to execute *../src/jupiter*—it could not be found. If you try this at the shell
    prompt, you’ll see the following output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 很显然，这些文件并不相同——我们原本期望 `stderr` 流中没有内容，但我们却得到了错误文本。Shell 在尝试执行 *../src/jupiter*
    时遇到错误——它无法找到该文件。如果你在 shell 提示符下尝试此操作，你将看到以下输出：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**NOTE**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Obviously you should not do this from the* tests *directory, or any other
    directory that’s a sibling to the* src *directory, or it’ll actually find* jupiter
    *(if it’s been built) rather than print this error.*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*显然，你不应该从* tests *目录，或任何与* src *目录平行的目录中执行此操作，否则它实际上会找到* jupiter *(如果已构建)而不是显示此错误。*'
- en: 'If you put this line into a shell script called (arbitrarily) *abc.sh* and
    execute the script on the `bash` command line, you’ll see output that matches
    the format shown in *testsuite.log*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此行放入一个名为（随意）*abc.sh*的 shell 脚本中，并在 `bash` 命令行上执行该脚本，你将看到与 *testsuite.log*
    中显示的格式匹配的输出：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see at ➎ in *testsuite.log* that the shell returned a 127 status code,
    indicating an error of some sort. The value 127 is used by the shell to indicate
    execution errors—file not found or file not executable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *testsuite.log* 的 ➎ 位置看到，shell 返回了一个 127 状态码，表示某种错误。值 127 被 shell 用来表示执行错误——文件未找到或文件不可执行。
- en: 'To be complete, let’s also consider the lines between ➍ and ➎ for a moment.
    This is the unified `diff` output seen when comparing the text specified in `AT_CHECK`’s
    *`stdout`* argument with what was actually written to `stdout` by `jupiter` (actually
    the shell, since we know *../src/jupiter* was not found). In this case, we see
    that the minus text is the original comparison text we specified and the plus
    text is a single newline character, as this is what the shell sent to `stdout`.
    The chunk marker range specification, fully expanded, would be:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们也来看看 ➍ 和 ➎ 之间的几行。这是通过比较`AT_CHECK`的*`stdout`*参数中指定的文本与`jupiter`（实际上是shell，因为我们知道*../src/jupiter*没有找到）实际写入`stdout`的内容时，所看到的统一`diff`输出。在这种情况下，我们看到减号文本是我们指定的原始比较文本，而加号文本是一个换行符，因为这是shell发送到`stdout`的内容。完全展开后的块标记范围说明如下：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There was one line of text in each of the original and modified sources to be
    compared, but, as we can see by the output, the text in these sources was completely
    different.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个原始和修改后的源文件中都只有一行文本需要比较，但正如我们通过输出看到的，这些源文件中的文本完全不同。
- en: '*So What Happened?*'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*那么发生了什么？*'
- en: This first attempt assumed that the `jupiter` program (or, rather, the Libtool
    wrapper script) is found at *../src/jupiter*, relative to the *tests* directory.
    While this assumption is true, I’ve already alluded to the fact that each test
    group is executed in its own temporary directory, so it makes perfect sense that
    this relative path is not going to work from another directory. Even if we figured
    out, by trial and error, how many parent directory references to use, it would
    be quite fragile; if we ran `testsuite` from a different directory, it would fail
    because it depends so intimately on running from a specific position relative
    to the `jupiter` program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一次尝试假设`jupiter`程序（或者更准确地说，是Libtool包装脚本）位于相对于*tests*目录的*../src/jupiter*。虽然这个假设是正确的，但我已经暗示过，每个测试组是在自己的临时目录中执行的，因此，这个相对路径在其他目录下无法正常工作也是完全合乎逻辑的。即使我们通过反复试验找出应该使用多少个父目录引用，它也会相当脆弱；如果我们从其他目录运行`testsuite`，它会失败，因为它过于依赖于相对于`jupiter`程序的特定位置来运行。
- en: Let’s try a different tack. We’ll make use of the variables generated by `configure`
    into *atconfig*. One of them, `abs_top_builddir`, contains the absolute path to
    the top build directory. Therefore, we should be able to successfully reference
    `jupiter` from anywhere using `${abs_top_builddir}`*/src/jupiter*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们换个方式试试。我们将使用`configure`生成的变量到*atconfig*中。其中一个变量`abs_top_builddir`包含了顶层构建目录的绝对路径。因此，我们应该能够在任何地方成功地引用`jupiter`，方法是使用`${abs_top_builddir}`*/src/jupiter*。
- en: 'But now we have another problem: `jupiter` prints its own path and we’ve just
    decided to obtain that path using a shell variable, so we’ll also need to change
    the comparison text to use this variable, as well. This change, however, causes
    yet another issue—we’ll need to change `AT_CHECK` to `AT_CHECK_UNQUOTED` if we
    expect that shell variable in `AT_CHECK`’s *`stdout`* parameter to be expanded
    before the macro makes the comparison. Let’s make these modifications by changing
    *jupiter.at* as shown in [Listing 9-10](ch09.xhtml#ch09ex10).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在我们遇到了另一个问题：`jupiter`打印了它自己的路径，而我们刚决定通过shell变量来获取这个路径，所以我们还需要更改比较文本，以使用这个变量。然而，这个更改又引发了另一个问题——如果我们希望在宏进行比较之前，`AT_CHECK`的*`stdout`*参数中的shell变量被展开，我们就需要将`AT_CHECK`更改为`AT_CHECK_UNQUOTED`。让我们通过修改*`jupiter.at`*，按[列表
    9-10](ch09.xhtml#ch09ex10)所示进行这些更改。
- en: Git tag 9.2
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 9.2
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 9-10:* tests/jupiter.at: *Adding our first test group—attempt #2*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-10:* tests/jupiter.at: *添加我们的第一个测试组—尝试 #2*'
- en: Here, we’ve switched to using `AC_CHECK_UNQUOTED`, and we’ve changed both the
    `jupiter` program path in the first argument and the comparison text in the third
    argument to use the `abs_top_builddir` variable we inherit from *atconfig*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们切换到使用`AC_CHECK_UNQUOTED`，并且我们将第一个参数中的`jupiter`程序路径和第三个参数中的比较文本更改为使用我们从*atconfig*继承的`abs_top_builddir`变量。
- en: '**NOTE**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The newline at the end of the *`stdout`* argument is intentional and explained
    shortly.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*`stdout`*参数末尾的换行符是故意的，稍后会解释。'
- en: 'Let’s try it out:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once again, I only had to run `make`. Even though our changes were dramatic,
    affecting even the macros we called in the test suite, remember that the entire
    test suite is generated from `make check`. The only time we need to execute `autoreconf`
    and `configure` is if we make changes to *configure.ac* or any of the templates
    from which it generates files used by `make check`, or if we make any changes
    to *Makefile.am* files.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，我只需要运行`make`。尽管我们的更改很大，甚至影响了我们在测试套件中调用的宏，但请记住，整个测试套件是通过`make check`生成的。我们只需要在更改了*configure.ac*或它生成的用于`make
    check`的文件模板，或者更改了*Makefile.am*文件时，才需要执行`autoreconf`和`configure`。
- en: This attempt had much better results, but what’s with that extra newline at
    the end of our comparison text in [Listing 9-10](ch09.xhtml#ch09ex10)? Well, remember
    what it is that we’re sending to `stdout` from `jupiter`. [Listing 9-11](ch09.xhtml#ch09ex11)
    provides a reminder.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个尝试取得了更好的结果，但为什么我们在[列表9-10](ch09.xhtml#ch09ex10)中的比较文本末尾会有一个额外的换行符呢？嗯，记得我们从`jupiter`发送到`stdout`的是什么吗？[列表9-11](ch09.xhtml#ch09ex11)提供了提示。
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 9-11:* common/print.c: *What `jupiter` sends to `stdout`*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-11:* common/print.c: *`jupiter`发送到`stdout`的内容*'
- en: The comparison text is an exact duplicate of what we expect to find on `jupiter`’s
    `stdout`, so we’d better be sure to include every character we write; the trailing
    newline is part of that data stream.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 比较文本是我们期望在`jupiter`的`stdout`中找到的内容的精确副本，因此我们最好确保包括我们写的每一个字符；尾随的新行是数据流的一部分。
- en: It’s probably a good idea at this point to remove the *src/Makefile.am* code
    that builds and runs the Automake version of the test. Change *src/Makefile.am*
    as shown in [Listing 9-12](ch09.xhtml#ch09ex12).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是移除*src/Makefile.am*中构建和运行Automake版本测试代码的好时机。按[列表9-12](ch09.xhtml#ch09ex12)所示修改*src/Makefile.am*。
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 9-12:* src/Makefile.am: *The updated full contents of this file after
    removing tests*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-12:* src/Makefile.am: *移除测试后的文件更新后的完整内容*'
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All we did here was remove the test-related lines from the bottom half of
    the file.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们在这里做的只是从文件的下半部分移除与测试相关的行。*'
- en: Unit Testing vs. Integration Testing
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试与集成测试
- en: On the whole, the autotest version is not much better than what we had when
    our test was being executed by Automake’s test framework in *src/Makefile.am*.
    Adding new tests is, however, a bit simpler than what we’d have to do in *src/Makefile.am*’s
    `TESTS` variable. In fact, the only way the Automake version becomes simpler is
    if we actually write test programs and build them in `check` primaries. We might
    still have to build test programs in `check` primaries, but calling them and validating
    their output is trivial when using autotest.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，autotest版本比我们在*src/Makefile.am*中由Automake测试框架执行时的版本要好一些。然而，添加新测试比我们在*src/Makefile.am*的`TESTS`变量中所做的要简单一些。事实上，Automake版本变得更简单的唯一方式是如果我们实际上编写测试程序并将其构建在`check`主干中。我们可能仍然需要在`check`主干中构建测试程序，但使用autotest时，调用它们并验证其输出是微不足道的。
- en: If you’re thinking that it feels like autotest is more attuned to system and
    integration testing than unit testing, you’re pretty close to the mark. Autotest
    is designed to test your project from the outside, but it’s not limited to such
    tests. Anything you can call from the command line can be a test, from autotest’s
    perspective. What autotest actually offers you is a framework for generating uniform
    test output, regardless of the kind of tests you’re using.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得autotest似乎更适合系统和集成测试，而不是单元测试，你的想法差不多。Autotest旨在从外部测试你的项目，但它并不限于这类测试。从autotest的角度来看，任何可以从命令行调用的东西都可以成为测试。实际上，autotest为你提供的是一个生成统一测试输出的框架，无论你使用什么类型的测试。
- en: One approach to unit testing that I’ve used for years involves writing test
    programs where the main source module of my test program literally `#include`s
    the *.c* file I’m testing. This gives me the option of calling static methods
    within the module under test and provides direct access to internal structures
    defined within that module.^([5](footnote.xhtml#ch09fn5)) This approach is pretty
    C oriented, but other languages have their own ways of performing the same sort
    of tricks. The idea is to create a test program that can reach into the private
    parts of a module and exercise functionality in small chunks. When you put those
    chunks together, you can feel confident that the individual chunks are working
    as designed; if there’s a problem, it’s probably in the way you glued them together.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我多年来使用的一种单元测试方法是编写测试程序，其中我的测试程序的主源模块实际上会`#include`我正在测试的*.c*文件。这给了我调用被测试模块中的静态方法的选项，并提供了对该模块中定义的内部结构的直接访问。^([5](footnote.xhtml#ch09fn5))这种方法相当偏向C语言，但其他语言也有自己执行相同操作的方法。其核心思想是创建一个能够访问模块私有部分的测试程序，并以小块的方式进行功能验证。当你将这些小块组合在一起时，你可以确信每个小块都按设计工作；如果有问题，可能是在你将它们组合起来的方式上。
- en: Let’s add some unit testing to Jupiter by creating a test module that tests
    the functions in the *common/print.c* module. Create a file called *test_print.c*
    in the *common* directory that contains the content in [Listing 9-13](ch09.xhtml#ch09ex13).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个测试模块来为Jupiter添加一些单元测试，该模块测试*common/print.c*模块中的函数。创建一个名为*test_print.c*的文件，并将其放在*common*目录中，文件内容参见[Listing
    9-13](ch09.xhtml#ch09ex13)。
- en: Git tag 9.3
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签9.3
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 9-13:* common/test_print.c: *A unit test program for the print.c module*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-13:* common/test_print.c: *一个针对print.c模块的单元测试程序*'
- en: The first line uses the preprocessor to rename any calls to `printf` to `mock_printf`.
    The second line then uses the preprocessor to `#include` *print.c* directly into
    *test_print.c*. Now, any calls to `printf` inside of *print.c* will be redefined
    to call `mock_printf` instead—including any prototypes defined in system header
    files like *stdio.h*.^([6](footnote.xhtml#ch09fn6))
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用预处理器将所有对`printf`的调用重命名为`mock_printf`。第二行然后使用预处理器将`#include`直接引入*print.c*到*test_print.c*中。现在，*print.c*中的任何`printf`调用将重新定义为调用`mock_printf`——包括在系统头文件如*stdio.h*中定义的任何原型。^([6](footnote.xhtml#ch09fn6))
- en: The idea here is to verify that the `print_it` function actually prints *Hello
    from* `argument`*!\n* and returns zero to the caller. We don’t need any output—a
    shell return code is sufficient for this test to indicate to the user that `print_it`
    is working as designed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是验证`print_it`函数是否实际打印了*Hello from* `argument`*!\n*并返回零给调用者。我们不需要任何输出——一个Shell返回码就足够表明`print_it`按设计工作。
- en: Neither do we need this module’s `main` routine to accept any command line arguments.
    If we had several tests in here, however, it might be convenient to accept some
    sort of argument that allows us to tell the code which test we want to run.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也不需要这个模块的`main`例程接受任何命令行参数。不过，如果这里有多个测试，可能会方便一些，接受某种参数来告诉代码我们想运行哪个测试。
- en: All we’re really doing here is directly calling `print_it` with a short string
    and then attempting to verify that `print_it` returned zero and actually passed
    what we expected to `printf`. Note that `print_it` is a static function, which
    should make it inaccessible to other modules, but because we’re including *print.c*
    at the top of *test_print.c*, we’re effectively combining both source files into
    a single translation unit.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的其实很简单，就是直接调用`print_it`并传入一个短字符串，然后尝试验证`print_it`是否返回了零，并且实际将我们期望的内容传递给了`printf`。请注意，`print_it`是一个静态函数，这应该使其无法被其他模块访问，但由于我们在*test_print.c*的顶部包含了*print.c*，实际上我们将这两个源文件合并为一个翻译单元。
- en: Now, let’s write the build code for this test program. First, we need to add
    some lines to *common/Makefile.am* so that a `test_print` program gets built when
    we run `make check`. Modify *common/Makefile.am* as shown in [Listing 9-14](ch09.xhtml#ch09ex14).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个测试程序编写构建代码。首先，我们需要在*common/Makefile.am*中添加一些行，以便在运行`make check`时构建`test_print`程序。按照[Listing
    9-14](ch09.xhtml#ch09ex14)中所示的方式修改*common/Makefile.am*。
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 9-14:* common/Makefile.am: *Adding `test_print` as a `check_PROGRAM`*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-14:* common/Makefile.am: *将`test_print`添加为`check_PROGRAM`*'
- en: When we make the `check` target, we’ll now get a new program, `test_print`,
    in the *common* directory. Now we need to add a call to this program to our test
    suite. Create a new file in *tests* called *print.at*, as shown in [Listing 9-15](ch09.xhtml#ch09ex15).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `check` 目标时，我们现在会在 *common* 目录中获得一个新的程序 `test_print`。现在，我们需要将此程序的调用添加到我们的测试套件中。在
    *tests* 中创建一个名为 *print.at* 的新文件，如 [清单 9-15](ch09.xhtml#ch09ex15) 所示。
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 9-15:* tests/print.at: *Adding the `print` test*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-15:* tests/print.at: *添加 `print` 测试*'
- en: We also need to add an `m4_include` statement for this test to *testsuite.at*,
    as in [Listing 9-16](ch09.xhtml#ch09ex16).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为此测试向 *testsuite.at* 添加一个 `m4_include` 语句，如 [清单 9-16](ch09.xhtml#ch09ex16)
    所示。
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 9-16:* tests/testsuite.at: *Adding print.at to testsuite.at*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-16:* tests/testsuite.at: *将 print.at 添加到 testsuite.at*'
- en: And finally, we need to add this new source file to the `TESTSOURCES` variable
    in *tests/Makefile.am*, as shown in [Listing 9-17](ch09.xhtml#ch09ex17).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将这个新的源文件添加到 *tests/Makefile.am* 中的 `TESTSOURCES` 变量，如 [清单 9-17](ch09.xhtml#ch09ex17)
    所示。
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 9-17:* tests/Makefile.am: *Adding print.at to `TESTSOURCES`*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-17:* tests/Makefile.am: *将 print.at 添加到 `TESTSOURCES`*'
- en: Since the `test_print` program only uses the shell status code to indicate an
    error, using it in `AT_CHECK` is as simple as it gets. You only need the first
    argument—the name of the program itself. If `test_print` had more than one test,
    you might accept a command line argument (within the same parameter) that indicates
    which test you want to run and then add several invocations of `AC_CHECK`, each
    running `test_print` with a different argument.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `test_print` 程序仅使用 shell 状态码来指示错误，因此在 `AT_CHECK` 中使用它是最简单的。你只需要提供第一个参数——程序本身的名称。如果
    `test_print` 有多个测试，你可能会接受一个命令行参数（在同一参数内），用来指示你想运行哪个测试，然后添加多个 `AC_CHECK` 调用，每个调用运行
    `test_print` 并带有不同的参数。
- en: Notice that we’ve started a new test group—as I mentioned earlier, you should
    try hard to limit your test groups to a single test unless the nature of the tests
    are such that they work together on the same file-based data set.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经开始了一个新的测试组——正如我之前提到的，除非测试的性质使得它们必须在同一文件数据集上共同工作，否则你应该尽量将每个测试组限制为一个测试。
- en: 'Let’s give it a shot. Note that in order to run the new test, we really only
    need to make the `check` target to update and execute `testsuite`. However, since
    we added the *print.at* dependency to *tests/Makefile.am*, we should probably
    also run `autoreconf` and `configure`. Had we enabled maintainer mode, the extra
    maintainer-mode rules would have done this for us:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试吧。请注意，为了运行新的测试，我们实际上只需要执行 `check` 目标来更新并执行 `testsuite`。然而，由于我们已经将 *print.at*
    依赖项添加到了 *tests/Makefile.am* 中，我们可能还应该运行 `autoreconf` 和 `configure`。如果我们启用了维护者模式，额外的维护者模式规则会为我们处理这些：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Administrative Details
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理细节
- en: I mentioned while describing the contents of *tests/Makefile.am* back near [Listing
    9-2](ch09.xhtml#ch09ex2) that we needed to add some additional infrastructure
    to that file in order to complete the tie-in with Automake. Let’s take care of
    those details now.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我在描述 *tests/Makefile.am* 内容时提到过，正如在 [清单 9-2](ch09.xhtml#ch09ex2) 中提到的，我们需要在该文件中添加一些额外的基础设施，以便完成与
    Automake 的集成。让我们现在来处理这些细节。
- en: 'We’ve seen that `make` (`all`) and `make check` work just fine, building our
    products and building and executing our test suite. But we’ve neglected some of
    the other targets that Automake wires up for us—specifically, `installcheck`,
    `clean`, and distribution-related targets like `dist` and `distcheck`. There’s
    a general lesson to be considered here: whenever we add custom rules to *Makefile.am*,
    we need to consider the impact on the standard targets generated by Automake.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，`make` (`all`) 和 `make check` 可以正常工作，构建我们的产品并构建和执行我们的测试套件。但我们忽略了 Automake
    为我们配置的其他一些目标——具体来说，`installcheck`、`clean` 以及与分发相关的目标，如 `dist` 和 `distcheck`。这里有一个需要考虑的一般教训：每当我们向
    *Makefile.am* 添加自定义规则时，我们需要考虑这些规则对 Automake 生成的标准目标的影响。
- en: Distributing Test Files
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分发测试文件
- en: There are several generated files that need to be distributed. These files are
    not inherently known by Automake, and, therefore, Automake needs to be told explicitly
    about them. This is done with the Automake-recognized `EXTRA_DIST` variable, which
    we’ll add to the top of *tests/Makefile.am*, as shown in [Listing 9-18](ch09.xhtml#ch09ex18).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个生成的文件需要分发。这些文件并不是 Automake 固有的知道的，因此，Automake 需要显式地告知这些文件。这是通过 Automake 识别的
    `EXTRA_DIST` 变量来完成的，我们将在 *tests/Makefile.am* 文件顶部添加该变量，如 [清单 9-18](ch09.xhtml#ch09ex18)
    所示。
- en: Git tag 9.4
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 9.4
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 9-18:* tests/Makefile.am: *Ensuring test files get distributed with
    `EXTRA_DIST`*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-18:* tests/Makefile.am: *确保测试文件与`EXTRA_DIST`一起分发*'
- en: Here, I’ve added all the test suite source files, including *testsuite.at*,
    *local.at*, *jupiter.at*, and *print.at*. I’ve also added the `testsuite` program
    and any input files we generated using a non-Automake mechanism. These include
    *atconfig*, which is generated by code provided by the `AC_CONFIG_TESTDIR` macro
    internally, and *package.m4*, which is generated by a custom rule we added earlier
    to this *Makefile.am* file. It’s important to understand here that adding files
    to `EXTRA_DIST` causes them to be built, if needed, when `make dist` is executed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我已经添加了所有测试套件源文件，包括*testsuite.at*、*local.at*、*jupiter.at*和*print.at*。我还添加了`testsuite`程序和我们通过非Automake机制生成的任何输入文件。这些文件包括*atconfig*，它是由`AC_CONFIG_TESTDIR`宏提供的代码生成的，以及*package.m4*，它是我们之前向此*Makefile.am*文件添加的自定义规则生成的。这里需要理解的是，向`EXTRA_DIST`添加文件会导致它们在执行`make
    dist`时被构建（如果需要）。
- en: '**NOTE**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*I would have like to have just used *`$(TESTSOURCES)`* in *`EXTRA_DIST`*,
    but the sources in that variable were formatted for rules and commands. *`EXTRA_DIST`*,
    as interpreted by Automake, is designed to refer to a list of files relative to
    the current directory within the source tree.*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*我本来只想在`EXTRA_DIST`中使用*`$(TESTSOURCES)`*，但是该变量中的源文件是为规则和命令格式化的。*`EXTRA_DIST`*由Automake解释时，旨在引用相对于源树中当前目录的文件列表。*'
- en: As a reminder, we distribute *.at* files because the GNU General Public License
    says we must distribute the source code for our project and these files are the
    source code for `testsuite`, just as *configure.ac* is the source code for `configure`.
    However, even if you’re not using the GPL, you should still consider shipping
    the preferred editing format of all files in your project; it is an open source
    project, after all.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，我们分发*.at*文件，因为GNU通用公共许可证要求我们必须分发项目的源代码，而这些文件就是`testsuite`的源代码，就像*configure.ac*是`configure`的源代码一样。然而，即使您不使用GPL，您仍然应该考虑分发项目中所有文件的首选编辑格式；毕竟，它是一个开源项目。
- en: '*Checking Installed Products*'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*检查已安装的产品*'
- en: We wrote a `check` target; it’s probably a good idea to support the *GCS* `installcheck`
    target, which Automake also supports. This is done by adding the `installcheck-local`
    target to this *Makefile.am* file, as shown in [Listing 9-19](ch09.xhtml#ch09ex19).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写了一个`check`目标；支持*GCS* `installcheck`目标可能是个好主意，Automake也支持这个目标。这是通过在此*Makefile.am*文件中添加`installcheck-local`目标来实现的，如[清单
    9-19](ch09.xhtml#ch09ex19)所示。
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 9-19:* tests/Makefile.am: *Supporting installed-product testing*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-19:* tests/Makefile.am: *支持已安装产品的测试*'
- en: The only difference between `check-local` and `installcheck-local` is the addition
    of the `AUTOTEST_PATH` command line option to `testsuite`, pointing `testsuite`
    to the copy of `jupiter` found in `$(DESTDIR)$(bindir)`, where it was installed.
    `AUTOTEST_PATH` is prepended to the shell `PATH` variable before invoking *`commands`*
    in `AT_CHECK_UNQUOTED`; therefore, you could write test code that assumes `PATH`
    contains the path to an installed copy of `jupiter`. However, tests are designed
    to be executed on either installed or uninstalled programs, so it’s a good idea
    to continue deriving and using a full path to programs within your test commands.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`check-local`和`installcheck-local`之间唯一的区别是向`testsuite`添加了`AUTOTEST_PATH`命令行选项，指向在`$(DESTDIR)$(bindir)`中找到的`jupiter`副本，即它被安装的位置。`AUTOTEST_PATH`在调用`AT_CHECK_UNQUOTED`中的*`commands`*之前，会被添加到shell的`PATH`变量中；因此，您可以编写假设`PATH`包含已安装的`jupiter`副本路径的测试代码。然而，测试旨在同时在已安装或未安装的程序上执行，因此建议在测试命令中继续派生并使用程序的完整路径。'
- en: Now we’ll need to make a decision. When the user types `make check`, they clearly
    mean to test the copy of `jupiter` in the build tree. But when they type `make
    installcheck`, certainly they want to check the installed version of the program,
    either in the default install location or wherever the user indicates by using
    command line `make` variables like `DESTDIR`, `prefix`, and `bindir`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做出决定。当用户输入`make check`时，他们显然是想测试构建树中的`jupiter`副本。但当他们输入`make installcheck`时，肯定是想检查已安装的程序版本，无论是默认安装位置，还是用户通过使用命令行`make`变量，如`DESTDIR`、`prefix`和`bindir`，指定的位置。
- en: 'This brings up a new issue: when we run tests for uninstalled `jupiter`, we’re
    relying on Libtool’s wrapper script to ensure `jupiter` can find *libjupiter.so*.
    Once we start testing installed `jupiter`, we’ll become responsible for showing
    `jupiter` where *libjupiter.so* is located. If `jupiter` is installed in standard
    places (such as */usr/lib*), the system will naturally find *libjupiter.so*. Otherwise,
    we’ll have to set the `LD_LIBRARY_PATH` environment variable to point to it.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个新问题：当我们运行未安装的`jupiter`测试时，我们依赖于Libtool的包装脚本来确保`jupiter`能够找到*libjupiter.so*。一旦我们开始测试已安装的`jupiter`，我们将负责告诉`jupiter`*libjupiter.so*的位置。如果`jupiter`安装在标准位置（如*/usr/lib*），系统会自然找到*libjupiter.so*。否则，我们必须设置`LD_LIBRARY_PATH`环境变量来指向它。
- en: So, how do we write our tests to work correctly in both situations? One interesting
    (but broken) approach is shown in [Listing 9-20](ch09.xhtml#ch09ex20).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何编写测试，以确保在这两种情况中都能正确工作呢？一个有趣（但有问题）的方法见于[Listing 9-20](ch09.xhtml#ch09ex20)。
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 9-20:* tests/jupiter.at: *Testing execution for both installed and
    uninstalled *`jupiter`*—attempt#1*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-20:* tests/jupiter.at：*测试已安装和未安装的*`jupiter`*执行——尝试#1*'
- en: The `find_jupiter` shell function attempts to locate `jupiter` in the `PATH`
    by using the shell’s `type` command. If the first result is empty, we revert to
    using the uninstalled version of `jupiter`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_jupiter` Shell函数通过使用Shell的`type`命令来尝试在`PATH`中定位`jupiter`。如果第一个结果为空，我们会回退到使用未安装版本的`jupiter`。'
- en: The function sets two shell variables, `jupiter` and `compare`. The `jupiter`
    variable is the full path to `jupiter`. The `compare` variable is derived from
    `jupiter` and contains either the value of `${jupiter}` or the Libtool location
    and name for uninstalled versions. We can set `LD_LIBRARY_PATH` in both cases
    to the *../lib* directory, relative to where `jupiter` is found because that’s
    probably^([7](footnote.xhtml#ch09fn7)) where it’s installed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数设置了两个Shell变量，`jupiter`和`compare`。`jupiter`变量是`jupiter`的完整路径。`compare`变量是从`jupiter`派生出来的，包含`${jupiter}`的值或者Libtool未安装版本的位置和名称。我们可以在这两种情况下将`LD_LIBRARY_PATH`设置为相对于`jupiter`所在位置的*../lib*目录，因为那里很可能是它被安装的地方^[7](footnote.xhtml#ch09fn7)。
- en: 'The problems with this approach are numerous. First, it doesn’t handle, very
    well, the situation where `jupiter` *should* be installed but isn’t found in the
    specified or implied install path. In this case, the code quietly reverts to testing
    the uninstalled version—likely not what you wanted. Another issue is that `find_jupiter`
    will locate `jupiter` anywhere in the `PATH`, even if the instance is not the
    one you intended to test. But there’s an even more nefarious bug: if you execute
    `make check`, intending to test the uninstalled version, and an installed version
    of `jupiter` happens to be somewhere in the `PATH`, that’s the version that will
    be tested.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题很多。首先，它并没有很好地处理`jupiter`*应该*安装但在指定或隐含的安装路径中找不到的情况。在这种情况下，代码会悄悄地回退到测试未安装版本——这可能不是你想要的结果。另一个问题是，`find_jupiter`会在`PATH`中找到`jupiter`的任何位置，即使该实例不是你打算测试的版本。但还有一个更加隐蔽的bug：如果你执行`make
    check`，本意是测试未安装版本，但`jupiter`的已安装版本恰好出现在`PATH`中，那么系统会测试已安装的版本。
- en: It’s unfortunate that `AUTOTEST_PATH` defaults to a non-empty value when it’s
    not specified on the command line, as this would be a good way to differentiate
    the use of `make check` from `make installcheck`. However, `AUTOTEST_PATH` does
    default to the name of the directory specified in `AC_CONFIG_TESTDIR`, which also
    happens to be the value of `${at_testdir}`—one of the variables generated by `AC_CONFIG_TESTDIR`
    in *atconfig*. We can use this fact to differentiate between `make check` and
    `make installcheck` by comparing `${AUTOTEST_PATH}` to `${at_testdir}`. Change
    *tests/jupiter.at* as shown in [Listing 9-21](ch09.xhtml#ch09ex21).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾的是，当命令行中未指定`AUTOTEST_PATH`时，它默认会有一个非空值，而这本来是一个很好的方法来区分`make check`和`make
    installcheck`的使用。然而，`AUTOTEST_PATH`默认会是`AC_CONFIG_TESTDIR`指定目录的名称，而该目录的名称也恰好是`${at_testdir}`的值——这是由`AC_CONFIG_TESTDIR`在*atconfig*中生成的变量。我们可以利用这一点，通过比较`${AUTOTEST_PATH}`和`${at_testdir}`来区分`make
    check`和`make installcheck`。如[Listing 9-21](ch09.xhtml#ch09ex21)所示，修改*tests/jupiter.at*。
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 9-21:* tests/jupiter.at: *A better way to use `AUTOTEST_PATH`*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-21:* tests/jupiter.at：*更好的方法使用`AUTOTEST_PATH`*'
- en: Now, when `make check` is executed, the `jupiter` variable will always be set
    directly to the uninstalled version in the build tree (and `compare` will be set
    to *.../.libs/lt-jupiter*), but when `make installcheck` is entered, it will be
    set to `${AUTOTEST_PATH}`*/jupiter* (and `compare` will be set to the same value).
    Additionally, since we’re able to fully distinguish between installed and uninstalled
    testing, we can set the `LD_LIBRARY_PATH` only for installed versions of `jupiter`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当执行 `make check` 时，`jupiter` 变量将始终直接设置为构建树中的未安装版本（并且 `compare` 将设置为 *.../.libs/lt-jupiter*），但当进入
    `make installcheck` 时，它将设置为 `${AUTOTEST_PATH}`*/jupiter*（`compare` 也将设置为相同的值）。此外，由于我们能够完全区分已安装和未安装的测试，因此我们只会为已安装版本的
    `jupiter` 设置 `LD_LIBRARY_PATH`。
- en: If `AUTOTEST_PATH` has been set incorrectly, which can happen (for example,
    when the user sets `DESTDIR` or `prefix` incorrectly on the `make` command line),
    the test will fail because `${jupiter}` will not be found.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `AUTOTEST_PATH` 设置不正确，可能会发生这种情况（例如，当用户在 `make` 命令行中错误地设置 `DESTDIR` 或 `prefix`
    时），测试将失败，因为找不到 `${jupiter}`。
- en: If I were to add additional tests that needed to run the `jupiter` program,
    these lines would be a perfect candidate for *local.at*. The problem is that a
    shell script designed to run within tests *must* be defined and executed between
    calls to `AT_SETUP` and `AT_CLEANUP`; otherwise, it’s simply omitted from the
    `autom4te` output stream while generating `testsuite`. So, how exactly is *local.at*
    useful to us? Well, you can’t write shell code directly in *local.at*, but you
    can define M4 macros that can be invoked from within your test modules. Let’s
    move the `find_jupiter` functionality into a macro definition in *local.at*, as
    shown in [Listing 9-22](ch09.xhtml#ch09ex22).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我需要添加额外的测试，且这些测试需要运行 `jupiter` 程序，那么这些行将是 *local.at* 的完美候选者。问题是，设计用于在测试中运行的
    Shell 脚本 *必须* 在 `AT_SETUP` 和 `AT_CLEANUP` 的调用之间定义并执行；否则，它将在生成 `testsuite` 时从 `autom4te`
    输出流中被省略。那么，*local.at* 到底如何对我们有用呢？嗯，你不能直接在 *local.at* 中编写 Shell 代码，但你可以定义可以在测试模块中调用的
    M4 宏。让我们将 `find_jupiter` 功能移动到 *local.at* 中的宏定义，如 [示例 9-22](ch09.xhtml#ch09ex22)
    所示。
- en: Git tag 9.5
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 9.5
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 9-22:* tests/local.at: *Moving `find_jupiter` to an M4 macro*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-22:* tests/local.at: *将 `find_jupiter` 移动到 M4 宏*'
- en: Using a shell function was, perhaps, a good idea when we started, but it’s become
    a bit extraneous at this point, so I modified the code to just set the `jupiter`
    variable directly. Notice the second (*`value`*) argument of the call to `m4_define`
    is set verbatim to the shell script we want to have generated when the macro is
    invoked.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Shell 函数可能在我们开始时是个好主意，但现在它有点多余，所以我修改了代码，直接设置了 `jupiter` 变量。注意调用 `m4_define`
    的第二个 (*`value`*) 参数被原样设置为我们希望在宏被调用时生成的 Shell 脚本。
- en: The `set -x` command in the first line of the *`value`* argument enables shell
    diagnostic output so you can see the contents of this macro executing, but only
    if you set `TESTSUITEFLAGS=-v` on the `make` command line. This is the default
    setting for the output generated into *testsuite.log*, so you’ll be able to see
    what the code generated by the macro invocation is actually doing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*`value`* 参数中第一行的 `set -x` 命令启用 Shell 调试输出，这样你就能看到该宏执行的内容，但前提是你在 `make` 命令行中设置了
    `TESTSUITEFLAGS=-v`。这是生成到 *testsuite.log* 中输出的默认设置，因此你将能够看到宏调用实际执行的代码。'
- en: '**NOTE**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may have noticed the code in the second argument of *`m4_define`* has
    two sets of square brackets around it. This is not strictly necessary in this
    example because there are no special characters in the embedded code snippet.
    However, if there had been, double quoting would have allowed the special characters—embedded
    square brackets, or even a previously defined M4 macro name—to be generated exactly
    as is, without interference from the *`m4`* utility.*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能注意到 *`m4_define`* 的第二个参数中的代码有两组方括号。这在本例中并不是严格必要的，因为嵌入的代码片段中没有特殊字符。然而，如果有的话，使用双引号会允许特殊字符——如嵌入的方括号，甚至是之前定义的
    M4 宏名称——被准确地生成，而不会受到 *`m4`* 工具的干扰。*'
- en: Now change *tests/jupiter.at* as shown in [Listing 9-23](ch09.xhtml#ch09ex23).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照 [示例 9-23](ch09.xhtml#ch09ex23) 中所示的修改 *tests/jupiter.at*。
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 9-23:* tests/jupiter.at: *Calling the `FIND_JUPITER` macro*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-23:* tests/jupiter.at: *调用 `FIND_JUPITER` 宏*'
- en: With this change in place, all tests that needed to run the `jupiter` program
    may do so merely by invoking the `FIND_JUPITER` macro and then executing `${jupiter}`
    within the *`commands`* argument. As you can see, the options available to you
    are endless—they’re limited only by your mastery of the shell. Because each test
    is run in a separate subshell, you can feel free to set any environment variables
    you want without affecting subsequent tests.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个更改，所有需要运行`jupiter`程序的测试可以仅通过调用`FIND_JUPITER`宏，然后在*`commands`*参数中执行`${jupiter}`来实现。正如你所看到的，可用的选项是无穷无尽的——它们仅受你对shell的掌握程度的限制。由于每个测试都在一个单独的子shell中运行，你可以随意设置任何环境变量，而不会影响后续的测试。
- en: 'Let’s try it out. Note we haven’t changed anything except for *.at* files,
    so we need only run `make` to see the effects of our changes. First, we’ll install
    into a local directory using `DESTDIR` so that we can see how `make installcheck`
    works:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下。注意，我们没有更改任何内容，除了*.at*文件，因此我们只需要运行`make`来查看我们更改的效果。首先，我们将使用`DESTDIR`安装到本地目录，以便查看`make
    installcheck`的工作方式：
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the execution of `make check TESTSUITEFLAGS=-v` shows us at ➊ that `jupiter`
    is being picked up from the build tree and `compare` is set to the path of the
    Libtool binary, while `make installcheck DESTDIR=$PWD/inst TESTSUITEFLAGS=-v`
    indicates at ➋ that `jupiter` being picked up from the installation path we specified
    and `compare` is set to the same location. `LD_LIBRARY``_PATH` is also being set
    in this code path.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，执行`make check TESTSUITEFLAGS=-v`向我们展示了在➊处`jupiter`是从构建树中被调用的，而`compare`被设置为Libtool二进制文件的路径，`make
    installcheck DESTDIR=$PWD/inst TESTSUITEFLAGS=-v`在➋处则表明`jupiter`是从我们指定的安装路径中调用的，`compare`也设置为相同的位置。`LD_LIBRARY_PATH`也在这个代码路径中被设置。
- en: '*Cleaning Up*'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*清理工作*'
- en: The `testsuite` program has a `--clean` command line option that cleans up the
    *tests* directory of all test droppings. To wire that into the `clean` target,
    we add a `clean-local` rule, as shown in [Listing 9-24](ch09.xhtml#ch09ex24).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`testsuite`程序有一个`--clean`命令行选项，可以清理*tests*目录中的所有测试遗留文件。为了将其接入`clean`目标，我们添加了一个`clean-local`规则，如[清单9-24](ch09.xhtml#ch09ex24)所示。'
- en: Git tag 9.6
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 9.6
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 9-24:* tests/Makefile.am: *Adding support for `make clean` in tests*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-24:* tests/Makefile.am: *为测试添加对`make clean`的支持*'
- en: If `testsuite` exists, it’s asked to clean up after itself. I’ve also added
    a command to remove the generated *atconfig* script, as `make distcheck` fails
    if this file is not removed during execution of the `clean` target while checking
    the distribution directory from which the package is built, and *atconfig* is
    not generated by Automake or by any Autoconf code that Automake monitors. At this
    point, you could try out `make dist` or `make distcheck` to see whether it now
    works as it should.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`testsuite`存在，它会被要求在执行后进行清理。我还添加了一个命令来删除生成的*atconfig*脚本，因为如果在执行`clean`目标时没有删除这个文件，`make
    distcheck`会失败，而*atconfig*并不是由Automake或Automake监控的任何Autoconf代码生成的。此时，你可以尝试运行`make
    dist`或`make distcheck`，看看它是否按预期工作。
- en: '**NOTE**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might think the *`clean-local`* target is optional, but it’s required
    so that *`make distcheck`* won’t fail when building a distribution archive due
    to extra files being left around after *`distcheck`* runs *`make clean`*.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能认为*`clean-local`*目标是可选的，但它是必需的，这样当构建分发档案时，*`make distcheck`*不会因`distcheck`执行`make
    clean`后留下多余的文件而失败。*'
- en: Note also that we don’t need to, nor should we, attempt to clean up files generated
    into the source tree, such as *package.m4* and `testsuite` itself. Why not? Much
    like `configure`, autotest products like `testsuite` sit somewhere between source
    files we write by hand and product files found in the build tree. They’re built
    from sources, but stored in the source tree and ultimately distributed in the
    archive.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们不需要，也不应该，尝试清理生成到源代码树中的文件，比如*package.m4*和`testsuite`本身。为什么不呢？就像`configure`一样，像`testsuite`这样的autotest产品位于我们手动编写的源文件和构建树中的产品文件之间。它们是从源代码构建的，但存储在源代码树中，并最终分发到档案中。
- en: Niceties
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 细节
- en: One more thing I like to do is add a call to `AT_COLOR_TESTS` to my *local.at*
    file, right after the invocation of `AT_INIT`. Users can always specify colored
    test output using a command line argument to `testsuite` (`--color`), but using
    this macro allows you to enable colored test output by default. Change your *local.at*
    file as shown in [Listing 9-25](ch09.xhtml#ch09ex25).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢做的另一件事是，在调用`AT_INIT`之后，往我的*local.at*文件中添加一个`AT_COLOR_TESTS`的调用。用户可以始终通过向`testsuite`添加命令行参数（`--color`）来指定彩色测试输出，但使用这个宏可以让你默认启用彩色测试输出。按照[清单9-25](ch09.xhtml#ch09ex25)所示修改你的*local.at*文件。
- en: Git tag 9.7
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Git标签 9.7
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 9-25:* tests/local.at: *Making colored test output the default*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表9-25:* tests/local.at: *将彩色测试输出设为默认值*'
- en: 'You should notice that the `ok` text after each successful test, as well as
    the summary line `All 2 tests were successful.`, is now green. If you had experienced
    any failed tests, those tests would have shown `FAILED (testsuite``.at:`*`N`*`)`
    in red after the failed tests, with summary lines in red as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，每次测试成功后，`ok`文本以及总结行`All 2 tests were successful.`现在都是绿色的。如果你经历了任何失败的测试，失败的测试后会显示`FAILED
    (testsuite``.at:`*`N`*`)`，并且总结行将以红色显示如下：
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A Minimal Approach
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种简化方法
- en: 'I mentioned at the outset that we’d take a look at cutting this system down
    to the bare necessities for smaller projects. Here’s what we can do without:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我在开始时提到过，我们将看看如何为较小的项目简化这个系统。以下是我们可以省略的内容：
- en: '***tests/local.at*** Copy the contents of this file to the top of *testsuite.at*
    and delete the file.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '***tests/local.at*** 将此文件的内容复制到*testsuite.at*的顶部并删除该文件。'
- en: '***tests/atlocal.in*** Assuming you don’t need to pass any configuration variables
    into your testing environment, remove the reference to the product file, *atlocal*,
    from the call to `AC_CONFIG_FILES` in *configure.ac* and delete this template
    file.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '***tests/atlocal.in*** 假设你不需要将任何配置变量传递到测试环境中，请从*configure.ac*中的`AC_CONFIG_FILES`调用中移除对产品文件*atlocal*的引用，并删除此模板文件。'
- en: '***tests/*.at*** **(subtest files included by** ***testsuite.at***) Copy the
    content of these files serially into *testsuite.at* and delete the files; remove
    the `m4_include` macro invocations that were originally used to include these
    files.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '***tests/*.at*** **（由***testsuite.at***包含的子测试文件）** 将这些文件的内容按顺序复制到*testsuite.at*并删除这些文件；移除原本用于包含这些文件的`m4_include`宏调用。'
- en: Edit *tests/Makefile.am* and remove all references to the preceding files (templates
    and generated products) from the `EXTRA_DIST` and `TESTSOURCES` variables, as
    well as from the `check-local` and `installcheck-local` rules.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑*tests/Makefile.am*，从`EXTRA_DIST`和`TESTSOURCES`变量中删除对前述文件（模板和生成的产品）的所有引用，以及`check-local`和`installcheck-local`规则中的引用。
- en: I would not remove the *package.m4* rule, although you may do so if you wish
    by copying the `m4_define` macro invocations generated into this file directly
    to the top of *testsuite.at*. Since `make` generates this file using variables
    defined by Autoconf, a generated instance of *package.m4* already contains the
    values that replace the variable references in the command in *tests/Makefile.am*.
    In my opinion, the value of not having to edit this information in two places
    far outweighs the overhead of maintaining the file generation rule.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会删除*package.m4*规则，尽管你可以通过将生成的`m4_define`宏调用直接复制到*testsuite.at*的顶部来做到这一点。由于`make`使用Autoconf定义的变量生成此文件，生成的*package.m4*实例已经包含了替换*tests/Makefile.am*中命令中变量引用的值。在我看来，不需要在两个地方编辑这些信息的价值远远超过维护文件生成规则的开销。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve covered the basics of autotest, but there are a dozen more or less useful
    `AT_*` macros you can use in your *testsuite.at* file. Section 19.2 of the *GNU
    Autoconf Manual* documents them in detail. I’ve shown you how to wire autotest
    into the Automake infrastructure. If you’ve chosen to use autotest without Automake,
    there will be some differences between the Automake’s *tests/Makefile.am* and
    Autoconf’s *tests/Makefile.in*, as you can no longer rely on Automake to do some
    things for you. However, if you’re writing your own *Makefile.in* templates, these
    modifications will quickly become obvious to you.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了autotest的基本内容，但在你的*testsuite.at*文件中，你还可以使用十多个或多或少有用的`AT_*`宏。*GNU Autoconf
    Manual*的第19.2节详细记录了它们。我已经向你展示了如何将autotest集成到Automake基础设施中。如果你选择在没有Automake的情况下使用autotest，那么Automake的*tests/Makefile.am*和Autoconf的*tests/Makefile.in*之间会有所不同，因为你不能再依赖Automake为你做某些事情了。然而，如果你正在编写自己的*Makefile.in*模板，那么这些修改很快就会变得很明显。
- en: 'I’ve also shown you a technique for creating unit tests in C that allows you
    full access to the private implementation details of a source module. I’ve attained
    nearly 100 percent code coverage using this technique in past projects, but I’ll
    warn you of one caveat now: writing unit tests at this level makes it much more
    difficult to change the functionality of your application. Fixing a bug is not
    so bad, but making design changes will generally require you to disable or entirely
    rewrite the unit tests associated with the code affected by your changes. It’s
    a good idea to be pretty sure of your design before committing yourself to this
    level of unit testing. It has been said that one of the primary values of writing
    unit tests is that you can *set them and forget them*—that is, you can write the
    tests once, wire them into your build system, and no longer pay attention to whether
    the code under test is working. Well, this is mostly true, but if you ever have
    to modify a well-tested feature in your project, unless you comment your test
    code well, you’ll find yourself wondering what you were thinking when you wrote
    that test code.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我还向你展示了一种在 C 语言中创建单元测试的技术，它可以让你完全访问源模块的私有实现细节。在过去的项目中，我通过这种技术实现了接近 100% 的代码覆盖率，但我现在要提醒你一个警告：在这个层级上编写单元测试会使得改变应用程序的功能变得更加困难。修复一个
    bug 还好，但进行设计更改通常需要禁用或完全重写与受影响代码相关的单元测试。在决定采用这种单元测试方式之前，最好对你的设计非常有信心。有人说，编写单元测试的一个主要价值就是你可以*设置它们然后忘记它们*——也就是说，你可以一次性编写测试，将它们集成到构建系统中，然后不再关注被测试代码是否有效。嗯，这大部分是对的，但如果你以后需要修改项目中一个经过充分测试的功能，除非你对测试代码进行了良好的注释，否则你会发现自己会想，当初写这个测试代码时到底在想什么。
- en: Nevertheless, I sleep better at night knowing that code I just committed to
    my company repository is fully tested. I’ve also been more confident in discussions
    with colleagues regarding bugs surrounding my well-tested code. Autotest has helped
    reduce the effort involved in these projects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我在晚上睡得更安稳，因为我知道我刚提交到公司代码库的代码已经经过全面测试。我也在与同事讨论围绕我那些经过充分测试的代码的 bug 时，更加自信。自动化测试帮助减少了这些项目中的工作量。
- en: With the end of this chapter, we’ve also come to the end of the Jupiter project—and
    it’s a good thing, because I’ve taken the *Hello, world!* concept *much* further
    than anyone has a right to. From here on out, we’ll be focusing on more isolated
    topics and real-world examples.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们也来到了 Jupiter 项目的终点——这其实是件好事，因为我已经把*Hello, world!*的概念*远远*推得超过了任何人应该做到的程度。从现在开始，我们将专注于更多独立的主题和实际的例子。
