- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: UNIT AND INTEGRATION TESTING WITH AUTOTEST
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AUTOTEST 进行单元和集成测试
- en: '*. . . to learn is not to know; there are the learners and the learned. Memory
    makes the one, philosophy the other.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*...学习不是知道；有学习者和被学者。记忆造就了前者，哲学造就了后者。*'
- en: —Alexandre Dumas, The Count of Monte Cristo*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —亚历山大·仲马，《基督山伯爵》*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Testing is important. All developers test their software to one degree or another;
    otherwise, they don’t know if the product meets the design criteria. On one end
    of the spectrum, the author compiles and runs the program. If it presents the
    general interface they envisioned, they call it done. On the other end, the author
    writes a suite of tests that attempt to exercise as much of the code as possible
    under varying conditions, validating that the outputs are correct for the specified
    inputs. Straining to reach the rightmost point on this line, we find the person
    who literally writes tests first and then adds and modifies code iteratively until
    all the tests pass.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是重要的。所有开发者都在某种程度上测试他们的软件，否则他们无法知道产品是否符合设计标准。在这个谱系的一端，作者编译并运行程序。如果程序呈现出他们设想的通用接口，他们就认为完成了。在另一端，作者编写了一套测试，尽可能地在不同条件下检验代码的各个部分，验证输出对于指定输入是正确的。努力追求这个谱系的最右端，我们会看到这样的人，他们字面上先写测试，然后迭代地添加和修改代码，直到所有测试通过。
- en: In this chapter, I won’t attempt to expound on the virtues of testing. I assume
    every developer agrees that *some* level of testing is important, whether they
    are a compile-run-and-ship sorta person or a bona-fide test-driven person. I also
    assume every developer has some level of aversion to testing that lies somewhere
    along this spectrum. Therefore, our goal here is to let someone else do as much
    of the work of testing as possible. In this case, “someone else” means the Autotools.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我不会尝试详细阐述测试的优点。我假设每个开发者都同意*某种*程度的测试是重要的，无论他们是那种编译-运行-发布类型的人，还是正统的测试驱动开发者。我还假设每个开发者对测试都有一定的反感，这种反感程度在这个谱系上有所不同。因此，我们在这里的目标是尽可能让别人做大部分的测试工作。在这种情况下，“别人”指的是
    Autotools。
- en: 'Back in [Chapter 3](ch03.xhtml), we added a test to our handcoded makefiles
    for Jupiter. The output of the test was completely controlled by the `make` script
    we put into *src/Makefile*:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.xhtml)中，我们为 Jupiter 添加了一个手写的 makefile 测试。该测试的输出完全由我们放入*src/Makefile*中的`make`脚本控制：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we moved on to Autoconf in [Chapters 4](ch04.xhtml) and [5](ch05.xhtml),
    not much changed. The output was still controlled by our handwritten `make` script.
    We just moved it into *src/Makefile.in*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第 4 章](ch04.xhtml)和[第 5 章](ch05.xhtml)中转向 Autoconf 时，变化不大。输出依然由我们手写的`make`脚本控制。我们只是将它移到了*src/Makefile.in*中。
- en: 'In [Chapter 6](ch06.xhtml), however, we dropped our handcoded makefiles and
    templates in favor of Automake’s much more terse *Makefile.am* files. Then we
    had to figure out how to shoehorn our handwritten test into `automake` script.
    In doing so, we got a bit of an upgrade on the test output:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在[第 6 章](ch06.xhtml)中，我们放弃了手写的 makefile 和模板，转而使用 Automake 更为简洁的*Makefile.am*文件。然后，我们需要弄清楚如何将我们手写的测试嵌入到
    `automake` 脚本中。在这样做的过程中，我们对测试输出进行了些许升级：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you’re running this code on your terminal with a reasonably late version
    of Automake, you’ll even see colored test output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在终端上运行这个代码，并且使用的是一个相对较新的 Automake 版本，你甚至会看到彩色的测试输出。
- en: Every test added to the `TESTS` variable in our *src/Makefile.am* template generates
    a `PASS:` or `FAIL:` line, and the summary values account for all of them. This
    is because Automake has a nice built-in testing framework driven by the `TESTS`
    variable. If you need to build any of the files specified in `TESTS`, you can
    just create a rule for it as we did for the trivial driver script (*greptest.sh*)
    that we created. If your test program needs to be built from sources, you can
    use a `check_PROGRAM` variable. One minor problem with Automake’s testing framework
    is that if tests are found in multiple directories, you see multiple such displays
    during `make check`, which can be a little annoying, especially when using `make
    -k` (continue in the face of errors), because it may not occur to you to scroll
    up to see the output of earlier, possibly failed tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个添加到`TESTS`变量中的测试都会在我们的*src/Makefile.am*模板中生成一个`PASS:`或`FAIL:`行，并且汇总值会计算所有的测试结果。这是因为Automake有一个很好的内置测试框架，驱动它的是`TESTS`变量。如果你需要构建`TESTS`中指定的任何文件，你只需要像我们为简单的驱动脚本（*greptest.sh*）所做的那样创建一个规则。如果你的测试程序需要从源代码构建，你可以使用`check_PROGRAM`变量。Automake的测试框架有一个小问题，如果测试分布在多个目录中，你会在`make
    check`时看到多次类似的显示，这可能会有点烦人，特别是在使用`make -k`（在遇到错误时继续）时，因为你可能没有意识到需要向上滚动以查看早期可能失败的测试输出。
- en: In addition to the `TESTS` variable, if you set the `XFAIL_TESTS` variable to
    a subset of the tests listed in `TESTS`, you might also see some output in the
    `XFAIL:` and `XPASS:` lines. These are tests that are expected to fail. When such
    tests pass, they’re listed in the `XPASS:` line as an *unexpected pass*. When
    they fail, they’re listed in the `XFAIL:` line as an *expected failure*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`TESTS`变量，如果你将`XFAIL_TESTS`变量设置为`TESTS`中测试的一个子集，你可能还会看到`XFAIL:`和`XPASS:`行中的一些输出。这些是预期会失败的测试。当这样的测试通过时，它们会列在`XPASS:`行中，作为*意外通过*。当它们失败时，它们会列在`XFAIL:`行中，作为*预期失败*。
- en: A test returning a shell code of 77 increases the count in the `SKIP:` line,
    and 99 increases the count in the `ERROR:` line. I’ll provide more detail about
    special shell codes returned by tests later in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 返回77的测试会增加`SKIP:`行中的计数，而返回99的测试会增加`ERROR:`行中的计数。我将在本章稍后提供有关测试返回的特殊shell代码的更多详细信息。
- en: As you might have guessed by now, Autoconf also includes a testing framework,
    called *autotest*, that provides all of the infrastructure required to allow you
    to simply and easily specify a test that exercises some portion of your code.
    The results are displayed in a consistent and easy-to-comprehend manner, and failed
    tests are easy to reproduce in an isolated fashion, complete with a built-in debugging
    environment. Almost makes you want to write tests, doesn’t it? The fact is, a
    well-designed testing framework, like any other well-designed tool, is a joy to
    use.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经猜到的那样，Autoconf也包含了一个测试框架，叫做*autotest*，它提供了所有所需的基础设施，让你能够简单而轻松地指定一个测试来验证你代码的某些部分。结果以一致且易于理解的方式显示，失败的测试也能在独立的环境中轻松重现，并配有内置的调试环境。几乎让你想写测试了，不是吗？事实是，一个设计良好的测试框架，就像任何其他设计良好的工具一样，是一种乐趣。
- en: Additionally, autotest is portable—as long as you write your portion of the
    tests using portable script or code, the entire test suite will be 100 percent
    portable to any system on which you can run your `configure` script. That’s not
    as hard as it sounds. Often the shell script you have to write amounts to running
    a command, and the code behind the command is written using Autotools-provided
    portability features and is generated using Autotools-provided build processes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，autotest是可移植的——只要你使用可移植的脚本或代码编写你的测试部分，整个测试套件就可以100%移植到任何可以运行`configure`脚本的系统。这并不像听起来那么难。你通常需要编写的shell脚本只是运行一个命令，而命令背后的代码使用Autotools提供的可移植性功能编写，并且是通过Autotools提供的构建过程生成的。
- en: 'For several years, autotest has been documented as being “experimental.” Regardless,
    its base functionality hasn’t changed much during those years, and Autoconf uses
    it to test itself, as we saw in [Chapter 1](ch01.xhtml). So, it’s time to stop
    worrying about whether it’s going to change and just start using it for its intended
    purpose: to make testing less of a chore for software developers, who—let’s face
    it—really just want to write code and let someone else worry about testing.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，autotest 一直被文档描述为“实验性”。不过，无论如何，它的基本功能在这些年中变化不大，Autoconf 使用它来测试自己，正如我们在[第
    1 章](ch01.xhtml)中看到的那样。因此，是时候停止担心它是否会改变，开始将它用于预定的目的：让软件开发者的测试工作变得不那么繁琐，毕竟，软件开发者真正希望做的是写代码，让别人来担心测试。
- en: Being the rational creatures that we are, we can’t deny that testing is important.
    What we can do is make use of good tools that allow us to focus on our code, letting
    frameworks like autotest worry about ancillary issues like result formatting,
    success/failure semantics, data gathering for user-submitted bug reports, and
    portability. As we’ll see throughout this chapter, this is the value that autotest
    provides.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为理性生物，我们无法否认测试的重要性。我们能做的是利用好的工具，让我们能专注于代码本身，而让像 autotest 这样的框架来处理诸如结果格式化、成功/失败语义、用户提交的
    bug 报告的数据收集以及可移植性等附加问题。正如我们在本章中将看到的那样，这就是 autotest 提供的价值。
- en: In the spirit of transparency, I’ll admit it’s difficult to justify using autotest
    for small test suites like Jupiter’s. The testing harness built into Automake
    is more than adequate for most small project needs. Larger projects—such as Autoconf
    itself, with its 500-plus unit and integration tests, which test functionality
    spread out over its entire project directory structure, and even installed components—are
    a different matter entirely.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本着透明的精神，我承认，对于像 Jupiter 这样的较小的测试套件，使用 autotest 是很难证明其合理性的。Automake 中内建的测试工具已经足够满足大多数小型项目的需求。较大的项目——例如
    Autoconf 本身，它有超过 500 个单元和集成测试，测试覆盖整个项目目录结构中的功能，甚至包括已安装的组件——则是完全不同的情况。
- en: Autotest Overview
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autotest 概述
- en: There are three phases to the files consumed and generated by autotest. The
    first phase is what the *GNU Autoconf Manual* calls the “prep for distribution”
    phase. The second phase occurs when `configure` is executed, and the third phase
    happens during execution of the test suite. Let’s take each of these phases in
    turn.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: autotest 使用和生成的文件有三个阶段。第一阶段是 *GNU Autoconf 手册* 所称的“准备分发”阶段。第二阶段发生在执行 `configure`
    时，第三阶段发生在执行测试套件时。让我们逐一看看这些阶段。
- en: The first phase, which happens during building of the distribution archive,
    is essentially the process of generating the executable test program that can
    be run by users on their systems. It may seem a bit strange that this process
    must be done during the building of a distribution archive; however, Autoconf
    is required to be installed on any system that needs to generate this program,
    so the `testsuite` program must be built when the distribution archive is built
    so that it may be included in the archive for the user. While the `dist` or `distcheck`
    targets are being made, `configure` (and `make check`, when using `distcheck`)
    is executed; `make check` encapsulates rules to rebuild the test program from
    sources using `autom4te`—the Autoconf caching `m4` driver. The test program is
    built during execution of the `dist` target by virtue of having it included in
    the Automake `EXTRA_DIST` variable, which I’ll talk about near the end of this
    chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段发生在构建分发档案时，实际上是生成可以在用户系统上运行的可执行测试程序的过程。可能会觉得奇怪，为什么这个过程必须在构建分发档案时进行；然而，Autoconf
    必须安装在任何需要生成此程序的系统上，因此 `testsuite` 程序必须在构建分发档案时构建，以便将其包含在归档文件中供用户使用。在执行 `dist`
    或 `distcheck` 目标时，`configure`（以及使用 `distcheck` 时的 `make check`）会被执行；`make check`
    封装了重建测试程序的规则，使用 `autom4te` —— Autoconf 缓存的 `m4` 驱动程序。测试程序在执行 `dist` 目标时构建，这是因为它被包括在
    Automake 的 `EXTRA_DIST` 变量中，我将在本章结束时讲解这个内容。
- en: '[Figure 9-1](ch09.xhtml#ch09fig1) shows the flow of data from maintainer-written
    source files to the `testsuite` program during `make dist` (or `make distcheck`).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](ch09.xhtml#ch09fig1) 显示了在执行 `make dist`（或 `make distcheck`）时，从维护者编写的源文件到
    `testsuite` 程序的数据流。'
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig01.jpg)'
- en: '*Figure 9-1: Data flow from maintainer-written input files to the `testsuite`
    program*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：从维护者编写的输入文件到 `testsuite` 程序的数据流*'
- en: The file *testsuite.at*, found at the top of the second column of the diagram,
    is the main test file written by a project author. This is actually the only maintainer-written
    file required by autotest. Exactly like *configure.ac*, this file contains shell
    script sprinkled with M4 macro definitions and invocations. This file is passed
    through the M4 macro processor, with `autom4te` acting as the driver for `m4`,
    to generate the `testsuite` program at the top of the last column, which is pure
    shell script. This process occurs during execution of `autom4te`, which is driven
    by `make check` reading the makefile generated from a *Makefile.in* or *Makefile.am*
    file that we write. The prep-for-distribution concept comes from the fact that
    the `check` target is executed during `make distcheck` (which, of course, builds
    the distribution archive); the `testsuite` program is added to the distribution
    archive during this process. It’s built during `make dist`, which does not execute
    `make check`, because all files listed in `EXTRA_DIST` must be built before they
    can be included in the distribution archive.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的第二列顶部找到的 *testsuite.at* 文件，是由项目作者编写的主要测试文件。实际上，这是 autotest 所需的唯一维护者编写的文件。与
    *configure.ac* 完全相同，这个文件包含了 shell 脚本，并掺杂了 M4 宏定义和调用。该文件通过 M4 宏处理器处理，由 `autom4te`
    作为 `m4` 的驱动程序，生成位于最后一列顶部的 `testsuite` 程序，这是纯粹的 shell 脚本。这个过程发生在执行 `autom4te` 时，`make
    check` 读取我们编写的 *Makefile.in* 或 *Makefile.am* 文件生成的 makefile，并驱动该过程。准备发布的概念来源于
    `check` 目标在 `make distcheck` 时执行（这当然会构建分发档案）；`testsuite` 程序会在这个过程中被添加到分发档案中。它是在
    `make dist` 过程中构建的，`make dist` 并不会执行 `make check`，因为在所有列在 `EXTRA_DIST` 中的文件被构建之前，它们不能包含在分发档案中。
- en: Details like this are normally hidden from us by the Autotools, but as autotest
    is still considered experimental—meaning, not fully integrated into the Autotools
    suite—the responsibility for some of this additional infrastructure is relegated
    to us, the maintainers. We’ll cover these details shortly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如此类的细节通常会被 Autotools 隐藏起来，但由于 autotest 仍被视为实验性的——意味着它尚未完全融入 Autotools 套件——因此一些额外的基础设施责任落在了我们这些维护者身上。我们将很快讨论这些细节。
- en: The Autoconf manual suggests that test suite authors may put individual sets
    of related tests, called *test groups*, into separate *.at* files. The *testsuite.at*
    file, then, contains only a series of `m4_include` directives, including each
    of these group-specific *.at* files. Therefore, M4 inclusion is the mechanism
    by which the optional *test-1.at* through *test-*`N`*.at* are gathered together
    into *testsuite.at* for processing by M4.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Autoconf 手册建议，测试套件的作者可以将一组组相关的测试，称为*测试组*，放入单独的 *.at* 文件中。然后，*testsuite.at* 文件仅包含一系列
    `m4_include` 指令，包含这些特定于组的 *.at* 文件。因此，M4 包含机制是通过它将可选的 *test-1.at* 到 *test-*`N`*.at*
    文件汇集到 *testsuite.at* 中，由 M4 进行处理。
- en: The *package.m4* and *local.at* files are optional maintainer-written (or generated)
    input files that are automatically included by `autom4te` when processing *testsuite.at*,
    if they’re found. The former contains basic information about the test suite that’s
    displayed on the console and embedded in bug reports generated by the test suite.
    The latter, the manual suggests, is an optional mechanism we may choose to use
    that can help us keep *testsuite.at* uncluttered with global definitions, non-group-related
    tests, and helper macro definitions and shell functions that may be used by the
    actual tests. We’ll discuss the exact contents of these files later in the chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*package.m4* 和 *local.at* 文件是可选的维护者编写（或生成）的输入文件，在处理 *testsuite.at* 时，如果找到了它们，会自动由
    `autom4te` 包含。前者包含有关测试套件的基本信息，这些信息会在控制台上显示，并嵌入由测试套件生成的错误报告中。后者，手册建议，是一种可选机制，我们可以选择使用，它可以帮助我们保持
    *testsuite.at* 文件简洁，不包含全局定义、与组无关的测试，以及可能由实际测试使用的辅助宏定义和 shell 函数。我们将在本章后面讨论这些文件的具体内容。'
- en: When a `configure` script is instrumented for autotest, the configuration process
    generates additional, autotest-related artifacts. [Figure 9-2](ch09.xhtml#ch09fig2)
    shows what happens graphically during the configuration process, relative to autotest.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `configure` 脚本用于 autotest 时，配置过程会生成额外的与 autotest 相关的产物。[图 9-2](ch09.xhtml#ch09fig2)
    显示了在配置过程中，关于 autotest 的图示。
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig02.jpg)'
- en: '*Figure 9-2: The flow of data during *`configure`* while generating test-related
    templates*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：在生成与测试相关的模板时，*`configure`* 过程中数据流的示意图*'
- en: Recall from [Chapter 2](ch02.xhtml) that `config.status` drives the file-generation
    portion of the configuration process. When a *configure.ac* file is set up for
    autotest, `config.status` generates *atconfig*—a shell script that’s designed
    to be sourced by `testsuite` when it’s executed.^([1](footnote.xhtml#ch09fn1))
    It contains source- and build-tree variables such as `at_testdir`, `abs_builddir`,
    `abs_srcdir`, `at_top_srcdir`, and so on, in order to facilitate access to files
    and products in the source and build trees during test suite execution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第2章](ch02.xhtml)中的内容，`config.status` 驱动配置过程中的文件生成部分。当为 autotest 设置 *configure.ac*
    文件时，`config.status` 会生成 *atconfig*——一个设计为由 `testsuite` 在执行时调用的 shell 脚本。^([1](footnote.xhtml#ch09fn1))
    它包含源代码树和构建树的变量，如 `at_testdir`、`abs_builddir`、`abs_srcdir`、`at_top_srcdir` 等，以便在测试套件执行期间访问源代码和构建树中的文件及产物。
- en: The test author may also choose to create a template file called *atlocal.in*
    that allows them to pass additional Autoconf and project-specific configuration
    variables through to the test environment, as needed. The product of this template
    is *atlocal*—also a shell script that’s designed to be sourced by `testsuite`,
    if it’s present. If you choose to write *atlocal.in*, you must add it to the list
    of tags passed to an invocation of `AC_CONFIG_FILES` in *configure.ac*. We’ll
    see how this is done later as we export Jupiter’s `async_exec` flag to our test
    suite.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试作者还可以选择创建一个名为 *atlocal.in* 的模板文件，允许他们根据需要将额外的 Autoconf 和项目特定的配置变量传递到测试环境中。该模板的产物是
    *atlocal*——同样是一个 shell 脚本，设计为由 `testsuite` 调用（如果它存在）。如果你选择编写 *atlocal.in*，必须将其添加到
    *configure.ac* 中传递给 `AC_CONFIG_FILES` 调用的标签列表中。稍后我们将在将 Jupiter 的 `async_exec`
    标志导出到我们的测试套件时看到如何执行此操作。
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Don’t confuse atlocal with local.at from [Figure 9-1](ch09.xhtml#ch09fig1).
    The atlocal file in [Figure 9-2](ch09.xhtml#ch09fig2), sourced by *`testsuite`*
    at runtime, is used to pass configuration variables into the test environment
    from *`configure`*, while the local.at file is written directly by the project
    maintainer and contains additional test code processed by *`autom4te`* when *`testsuite`*
    is generated.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将 atlocal 与[图9-1](ch09.xhtml#ch09fig1)中的 local.at 混淆。[图9-2](ch09.xhtml#ch09fig2)中的
    atlocal 文件，由 *`testsuite`* 在运行时调用，用于将配置变量从 *`configure`* 传递到测试环境，而 local.at 文件是由项目维护者直接编写的，包含在生成
    *`testsuite`* 时由 *`autom4te`* 处理的额外测试代码。*'
- en: '[Figure 9-3](ch09.xhtml#ch09fig3) shows the flow of data during the execution
    of `testsuite`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-3](ch09.xhtml#ch09fig3) 展示了 `testsuite` 执行过程中的数据流。'
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig03.jpg)'
- en: '*Figure 9-3: The flow of data during execution of the `testsuite` script*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：`testsuite` 脚本执行过程中的数据流*'
- en: As mentioned previously, `testsuite` sources *atconfig* and *atlocal* (if present)
    to access source- and build-tree information and other project-related variables,
    then executes the tests that were generated into it. As it does so, it creates
    a *testsuite.log* file containing verbose information on the execution of each
    test. What you see on the screen is a single line of text per test.^([2](footnote.xhtml#ch09fn2))
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`testsuite` 会获取 *atconfig* 和 *atlocal*（如果存在）来访问源代码树和构建树信息以及其他与项目相关的变量，然后执行生成的测试。执行过程中，它会创建一个
    *testsuite.log* 文件，包含每个测试执行的详细信息。你在屏幕上看到的每行文本代表一个测试的结果。^([2](footnote.xhtml#ch09fn2))
- en: The `testsuite` program generates a directory called *testsuite.dir*. A separate
    subdirectory is created within this directory for each test. The test suite does
    not delete test-specific subdirectories for failed tests; we can use the contents
    of this directory structure to obtain details and to debug the problem. We’ll
    go into detail about what gets added to these directories shortly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`testsuite` 程序会生成一个名为 *testsuite.dir* 的目录。在这个目录中，每个测试都会创建一个单独的子目录。测试套件不会删除失败测试的特定子目录；我们可以利用该目录结构的内容获取详细信息并调试问题。稍后我们将详细介绍这些目录中添加了什么内容。'
- en: The `testsuite` program may be executed by hand, of course, but it has to be
    generated first. The Autoconf manual suggests that the process of generating the
    `testsuite` program is best tied directly into the `check` target so that when
    `make check` is executed, `testsuite` will be generated (if it’s missing or out-of-date
    with respect to its dependencies) and then executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`testsuite` 程序当然可以手动执行，但首先必须生成它。Autoconf 手册建议将生成 `testsuite` 程序的过程直接与 `check`
    目标绑定，这样当执行 `make check` 时，`testsuite` 会被生成（如果它缺失或与其依赖关系不一致），然后再执行。'
- en: Since `testsuite` is added to the distribution archive, end users who run `make
    check` will merely execute the existing `testsuite` program, unless they’ve touched
    one of the files that `testsuite` depends on, in which case `make` will attempt
    to regenerate `testsuite`. Without Autoconf installed, this process would fail.
    Fortunately, it’s not generally in the user’s best interest to touch any of `testsuite`’s
    dependencies in the distribution archive.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `testsuite` 已被添加到分发包中，运行 `make check` 的最终用户将仅执行现有的 `testsuite` 程序，除非他们修改了
    `testsuite` 依赖的某些文件，在这种情况下，`make` 会尝试重新生成 `testsuite`。如果没有安装 Autoconf，这个过程会失败。幸运的是，用户通常不需要修改分发包中
    `testsuite` 的任何依赖项。
- en: Wiring Up Autotest
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Autotest
- en: Since my goal here is to teach you how to use this framework, the approach I
    chose to take in configuring Jupiter for autotest was to incorporate the entire
    set of optional files shown in Figures 9-1 through 9-3\. This allows us to explore
    exactly how everything works together. While this approach is probably unwarranted
    for a project the size of Jupiter, it does work correctly, and it can always be
    pared down. I’ll show you at the end of this chapter just what you can delete
    to reduce the autotest input file set to the bare minimum.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我这里的目标是教你如何使用这个框架，因此我选择的配置 Jupiter 用于 autotest 的方法是包含图 9-1 至 9-3 中所示的整个可选文件集。这使我们能够准确地探索所有内容如何一起工作。虽然对于像
    Jupiter 这样规模的项目，这种方法可能不必要，但它确实能正确工作，而且以后可以随时删减。我将在本章末尾向你展示，如何删除一些内容，将 autotest
    输入文件集精简到最少。
- en: Before we can write tests, we need to make *configure.ac* aware of our desire
    to use autotest. This is done by adding two macro invocations to *configure.ac*,
    as shown in [Listing 9-1](ch09.xhtml#ch09ex1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试之前，需要让 *configure.ac* 知道我们希望使用 autotest。这是通过在 *configure.ac* 中添加两个宏调用来实现的，如
    [列表 9-1](ch09.xhtml#ch09ex1) 所示。
- en: Git tag 9.0
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签 9.0
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-1:* configure.ac: *Wiring autotest into* configure.ac'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-1:* configure.ac: *将 autotest 集成到* configure.ac'
- en: The first of these two macros, `AC_CONFIG_TESTDIR`, tells Autoconf to enable
    autotest and specifies that the testing directory will be called *tests*. You
    may use a dot here to represent the current directory if you wish, but the *GNU
    Autoconf Manual* recommends that you use a separate directory for ease in managing
    test output files and directories.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏中的第一个，`AC_CONFIG_TESTDIR`，告诉 Autoconf 启用 autotest，并指定测试目录将命名为 *tests*。如果愿意，你可以在这里使用点（.）表示当前目录，但
    *GNU Autoconf 手册* 建议使用单独的目录，以便更容易管理测试输出文件和目录。
- en: '**NOTE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The addition of `AC_CONFIG_TESTDIR` to* configure.ac *is actually the only
    change required to enable autotest in a project, though changes to makefiles and
    additional support files are required to make it useful and more automated. Interestingly,
    this important tidbit is not found anywhere in the manual, though it is implied
    rather subtly.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*将 `AC_CONFIG_TESTDIR` 添加到* configure.ac *实际上是启用 autotest 所需的唯一更改，尽管为了使其更有用和更自动化，还需要更改
    makefile 和添加支持文件。有趣的是，这个重要的细节在手册中没有直接提到，尽管它是微妙地暗示的。*'
- en: The second line is the standard Autoconf `AC_CONFIG_FILES` instantiating macro.
    I’m using a separate instance of it here to generate the test-related files from
    templates.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是标准的 Autoconf `AC_CONFIG_FILES` 实例化宏。我在这里使用了它的一个独立实例，用于从模板生成与测试相关的文件。
- en: Let’s look at what goes into each of these files. The first is a makefile for
    the *tests* directory that’s generated from an Autoconf *Makefile.in* template,
    which itself is generated from the Automake *Makefile.am* file that we need to
    write. In this makefile, we need to get `make check` to generate and execute `testsuite`.
    [Listing 9-2](ch09.xhtml#ch09ex2) shows how we might write *tests/Makefile.am*
    so that Automake and Autoconf will generate such a makefile.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看这些文件中包含了什么。第一个是为*tests*目录生成的 makefile，它是从 Autoconf 的 *Makefile.in* 模板生成的，而该模板本身是从我们需要编写的
    Automake *Makefile.am* 文件生成的。在这个 makefile 中，我们需要通过 `make check` 来生成并执行 `testsuite`。[列表
    9-2](ch09.xhtml#ch09ex2) 展示了如何编写 *tests/Makefile.am*，以便 Automake 和 Autoconf 能够生成这样的
    makefile。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-2:* tests/Makefile.am: *Getting* `make check` *to build and run*
    `testsuite`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-2:* tests/Makefile.am: *使* `make check` *构建并运行* `testsuite`'
- en: Before we begin dissecting this file, I should mention that these contents were
    taken from Section 19.4 of the *GNU Autoconf Manual*. I’ve tweaked them a bit,
    but essentially these lines comprise a portion of the recommended way to tie autotest
    into Automake. We’ll complete this file as we discuss additional features and
    requirements of autotest-oriented `make` script.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '*This lack of more complete integration, along with the fact that Autoconf
    can be configured to use several different test drivers (DejaGNU, for instance),
    is likely what keeps autotest in experimental mode. While Libtool, for instance,
    has slowly migrated toward a position of complete integration with Automake, autotest
    still requires some fiddling to properly integrate into a project build system.
    Nevertheless, once the requirements are understood, proper integration is pretty
    simple. Additionally, as we’ve seen, Automake has its own test framework, which
    gives Automake maintainers little incentive to fully support autotest.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 9-2](ch09.xhtml#ch09ex2) is pretty straightforward when
    taken a line at a time—four variables and four rules. The variables are not strictly
    necessary, but they make for shorter command lines and less duplication in rules
    and commands. The `TESTSUITE` variable at ➊ simply keeps us from having to prefix
    `testsuite` with `$(srcdir)/` everywhere we use it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '*The `testsuite` program is distributed, so it should be built in the source
    tree. Files that are destined to end up in the distribution archive should be
    found in the source directory structure. Additionally, the content of such built
    and distributed files should be the same, regardless of differences in configuration
    options used by the original archive creator, or the end user.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The `TESTSOURCES` variable at ➋ allows us to easily add additional tests to
    the makefile. Each *.at* file becomes a dependency of `testsuite` so that when
    one of them is changed, `testsuite` is rebuilt.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The `AUTOM4TE` variable at ➌ allows us to wrap execution of `autom4te` with
    the Automake `missing` script, which prints a nicer error message if `autom4te`
    is not found. This happens when an end user who doesn’t have the Autotools installed
    does something that requires `testsuite` to be rebuilt—such as modify *testsuite.at*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '*We can’t use Automake’s `maintainer-rules` option to avoid writing these rules
    into distribution archive Makefiles because we must manually write these rules.*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The `AUTOTEST` variable at ➍ appends the `--language=autotest` option to the
    `autom4te` command line. *There is actually no program in the Autoconf package
    called* autotest. If we had to pin down the definition of such a tool, it would
    be the contents of this `AUTOTEST` variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The `check-local` rule at ➎ ties execution of `testsuite` into Automake’s `check`
    target. Automake standard targets like `check` have a `-local` counterpart that
    you can use to supplement the functionality generated by Automake for the base
    target. If Automake sees a rule with the target `check-local` in *Makefile.am*,
    it generates a command to run `$(MAKE) check-local` under the generated *Makefile*’s
    `check` rule. This gives you a hook into the standard Automake targets. We’ll
    cover such hooks in greater detail in [Chapters 14](ch14.xhtml) and [15](ch15.xhtml),
    where we’ll use them extensively in our efforts to convert a real-world project
    to use an Autotools-based build system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The `check-local` target depends on *atconfig*, *atlocal*, and `$(TESTSUITE)`.
    Recall from [Figure 9-3](ch09.xhtml#ch09fig3) that *atlocal* is a script sourced
    by `testsuite`. It’s generated directly by the invocation of `AC_CONFIG_FILES`
    that we added to *configure.ac* in [Listing 9-1](ch09.xhtml#ch09ex1), so we’ll
    cover its contents shortly. The command for this rule executes `'$(TESTSUITE)'`
    with `$(TESTSUITEFLAGS)` as a command line argument. The contents of `TESTSUITEFLAGS`
    are user defined, allowing the end user to run `make check TESTSUITEFLAGS=-v`,
    for instance, to enable verbose output from `testsuite` while making targets that
    invoke `testsuite`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `TESTSUITEFLAGS` to target specific test groups by number (for
    instance, `TESTSUITEFLAGS=2 testsuite`) or, if you’ve written your tests using
    the `AT_KEYWORDS` macro, by tag name. In addition, several command line options
    are available for the generated `testsuite` program. You can find complete documentation
    for `testsuite` options in Section 19.3 of the *GNU Autoconf Manual*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '*The single quotes around *`$(TESTSUITE)`* allow the path in *`TESTSUITE`*
    to contain spaces, if needed. This technique can and should be used in all makefiles
    to handle whitespace in paths. I’ve generally ignored the concept of whitespace
    in paths within this book in order to reduce the noise in the listings, but you
    should be aware that makefiles can be written to properly handle whitespace in
    all filenames and paths—those in targets and dependencies, as well as those in
    the commands associated with rules.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned previously that the *atconfig* script, also sourced by `testsuite`,
    is generated automatically beneath the covers by `AC_CONFIG_TESTDIR`. The problem
    is, even though `config.status` understands how to build this file, Automake doesn’t
    know anything about it because it’s not listed directly in any of the instantiating
    macro invocations in *configure.ac*, so we need to add an explicit rule to *Makefile.am*
    to create or update it. This is where the `atconfig` rule at ➏ in [Listing 9-2](ch09.xhtml#ch09ex2)
    comes in. The `check-local` rule depends on it, so its commands will be executed
    if *atconfig* is missing or older than its dependency, `$(top_builddir)/config.status`,
    when `make check` is executed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The command in the rule for generating `$(srcdir)/package.m4` at ➐ (note there
    is only one command here) merely writes text into the target file if the file
    is missing or older than *configure.ac*. This is an optional input file (see [Figure
    9-1](ch09.xhtml#ch09fig1)), the contents of which are actually required by autotest
    in some form. Several M4 macros must be defined in the input data that is processed
    by autotest to create a test suite, including `AT_PACKAGE_NAME`, `AT_PACKAGE_TARNAME`,
    `AT_PACKAGE_VERSION`, `AT_PACKAGE_STRING`, `AT_PACKAGE_BUGREPORT`, and `AT_PACKAGE_URL`.
    These variables may be defined directly in *testsuite.at* (or any of the subfiles
    included by that file), but it makes more sense to generate this information from
    values already found in *configure.ac* so we don’t have to maintain two sets of
    the same information. This is the very reason why *package.m4* is included automatically
    by `autom4te` if it’s found while processing *testsuite.at*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: But wait—why not use `AC_CONFIG_FILES` to have `configure` generate this file?
    All we’re doing is generating a text file that contains configuration variables,
    and that sounds like exactly what `AC_CONFIG_FILES` is for. The problem is, `AC_CONFIG_FILES`
    and the other instantiating macros always generate files into the build tree,
    and *package.m4* must end up in the source tree in order to be added to the distribution
    archive (not because it’s part of any build or execution process the user may
    instigate, but because it’s part of the source code for `testsuite`). Perhaps
    the full integration of autotest, at some point in the future, will result in
    the ability to request the instantiating macros to generate files into the source
    tree. Until then, this is what we have to work with.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The fourth and final rule, `$(TESTSUITE)`, at ➑, generates `$(srcdir)/testsuite`
    using the `$(AUTOTEST)` command. Because `$(TESTSUITE)` is a dependency of `check-local`,
    it’ll get built if it’s not up-to-date. The `autom4te` program, when executed
    in *autotest mode*, accepts the `-I` option for specifying include paths for *.at*
    files that may be included by *testsuite.at* or any of its inclusions. It also
    accepts the `-o` option for specifying the output file, `testsuite`.^([3](footnote.xhtml#ch09fn3))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '*I’ve added *`$(AM_V_GEN)`* in front of the commands of the last two rules
    in [Listing 9-2](ch09.xhtml#ch09ex2) to allow my custom rules to tie into the
    Autotools’ silent build rules system. Any command prefixed with *`$(AM_V_GEN)`*
    will cause the normal command output to be replaced with *`GEN`* `target` when
    building with silent rules enabled. See Section 21.3 of the GNU Automake manual
    for more details on this and other variables that affect build output when building
    with silent rules.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Taken as a whole, all of this allows us to run `make check` at the command prompt
    to build (if needed) and execute `$(srcdir)/testsuite`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '*There’s a bit more we need to do in this* Makefile.am *file to fully integrate
    autotest functionality into Automake. We’ll add some additional administrative
    rules and variables later in this chapter. For clarity at this point, I limited
    the content to just what we need to build and run the test suite.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Well, we’ve created a new directory and added a new *Makefile.am*. By now, you
    should be automatically thinking about how this *Makefile.am* file is going to
    be called if we don’t link it into the top-level *Makefile.am* `SUBDIRS` variable.
    You’re absolutely correct—this must be our next step. [Listing 9-3](ch09.xhtml#ch09ex3)
    shows this modification to the top-level *Makefile.am* file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 9-3:* Makefile.am: *Adding the tests subdirectory*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '*I added tests last. This will almost always be the pattern for a directory
    such as* tests. *In order to test the system, most, if not all, of the other directories
    must be built first.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The second file in [Listing 9-1](ch09.xhtml#ch09ex1) is the *atlocal* shell
    script that’s automatically sourced by `testsuite`, if present, which may be used
    to pass additional configuration variables through to `testsuite`’s runtime environment.
    We’ll use this file in the Jupiter project to pass the `async_exec` flag through
    to `testsuite` so it may know if the program it’s testing has been configured
    with the *async-exec* feature enabled. [Listing 9-4](ch09.xhtml#ch09ex4) shows
    how this is done in *atlocal*’s template, *atlocal.in*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-4:* tests/atlocal.in: *A template for generating* atlocal'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Now, this causes a small problem for us because `configure` is not yet exporting
    a substitution variable called `async_exec`. We wrote a shell script that uses
    a shell variable of this name back in [Chapter 5](ch05.xhtml), but recall we only
    used it to indicate whether we should invoke `AC_DEFINE` to generate the `ASYNC_EXEC`
    preprocessor definition into *config.h.in*. We now need to use `AC_SUBST` on this
    variable in order to generate an Autoconf substitution variable of the same name.
    [Listing 9-5](ch09.xhtml#ch09ex5) highlights the single-line addition to *configure.ac*
    required to make this happen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-5:* configure.ac: *Making autoconf generate the `async_exec` substitution
    variable*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'One last comment on [Listing 9-1](ch09.xhtml#ch09ex1): we could have simply
    added these files to the existing invocation of `AC_CONFIG_FILES` at the bottom
    of *configure.ac*, but using a separate invocation here keeps test-related items
    together. It also serves to illustrate the fact that `AC_CONFIG_FILES` may indeed
    be invoked multiple times within *configure.ac*, the results being cumulative.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We now need to create a set of source *.at* files that can be used by `autom4te`
    to generate our test program. This set of files can be as simple as a single *testsuite.at*
    file or as complex as the diagram in [Figure 9-1](ch09.xhtml#ch09fig1), including
    *testsuite.at*, a set of test-group-specific *.at* files, and a *local.at* file.
    These files will contain autotest macro invocations mixed with simple or complex
    shell script, as required by your testing needs. We’ll start with a single line
    of autotest initialization code in a *tests/local.at* file, as shown in [Listing
    9-6](ch09.xhtml#ch09ex6).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 9-6:* tests/local.at: *Initialization code for `testsuite` can be
    added to a* local.at file'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The `AT_INIT` macro is required by `autom4te` to be found somewhere within the
    translation unit presented by *testsuite.at* and its inclusions. This single macro
    invocation expands into several hundred lines of shell script that define the
    basic testing framework and all of the ancillary boilerplate functionality associated
    with it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create an empty *testsuite.at* file in the *tests* directory.
    We’ll add items to it as we progress:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now have the basis for generation and execution of the autotest framework
    in Jupiter. Every project that uses autotest will have to be configured in the
    manner we’ve shown so far. For smaller projects, some of the optional pieces may
    be omitted, the contents of which would then be combined directly into *testsuite.at*.
    We’ll discuss how to simplify when we’ve completed our exploration of autotest.
    For now, let’s give it a try:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see from the output of `configure` that our generated files were created
    in the *tests* directory, as expected. It also appears that the code generated
    by `AC_CONFIG_TESTDIR` has wired in the generation of the *tests/atconfig* file
    as a *command* tag, rather than as a simple template file, using `AC_CONFIG_COMMANDS`
    internally.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: We then see from the output of `make check` that `testsuite` was both built
    and executed. We can’t yet incorporate `testsuite` into a distribution archive
    from the `dist` or `distcheck` targets because we haven’t wired our autotest functionality
    into Automake. However, when we complete our changes at the end of this chapter,
    you’ll find that running `make check` against the contents of a distribution archive
    will not build `testsuite`, as it will have shipped with the archive (assuming
    we haven’t touched any of `testsuite`’s dependencies).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*One interesting item of note near the top of the *`make check`* output is
    highlighted by the lines starting with *`make[1]:`* and *`make[2]:`*, where *`make`*
    indicates it’s entering the jupiter/tests directory twice. This happens because
    of the *`check-local`* hook we added, where the *`check`* target recursively invokes
    *`$(MAKE) check-local`* as a command within the same directory.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Great, it works—with `make check` anyway. But it doesn’t do anything yet except
    print a few extra lines of text to the console. To make it do something useful,
    we need to add some tests. Therefore, our first task will be to move the original
    Automake-based `jupiter` execution test from *src/Makefile.am* into our autotest
    test suite.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Test
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Autotest tests are bundled into sets called *test groups*. The purpose of a
    test group is to allow tests within a group to interact with each other. For example,
    the first test in a group may generate some data files used by subsequent tests
    within the same group.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Tests that interact with each other are harder to debug, and broken tests are
    harder to reproduce if they require other tests to run first. Multi-test groups
    are hard to avoid when striving for full coverage; the ideal is to have only one
    test per test group as much as possible. Where you just can’t do it, test groups
    exist to facilitate the required interaction. The crux of this facility is that
    *tests within the same test group are executed within the same temporary directory*,
    allowing initial tests to generate files that subsequent tests can then see and
    access.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Our single test will not suffer from these problems—mainly because we haven’t
    yet put much effort into testing Jupiter (and, if we’re honest with ourselves,
    there isn’t much actual code to test). Right now, when you execute `make check`,
    you see two sets of test output on the screen:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first set of tests (beginning at ➊) are executed in the *jupiter/src* directory.
    This is our original `grep`-based test where we check `jupiter`’s output against
    a pattern. As you can see, the basic test framework built into Automake is not
    bad. We’re hoping to improve on that framework with autotest. The second set of
    tests (beginning at ➋) are executed in the *jupiter/tests* directory and involve
    autotest.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Defining Tests with AT_CHECK
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `grep`-based test we’ve been using in *src/Makefile.am* is a perfect example
    for use in the `AT_CHECK` macro provided by the autotest framework. Here are the
    prototypes for the `AT_CHECK` family of macros:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`AT_CHECK` executes *`commands`*, checks the returned status against *`status`*,
    and compares the output on `stdout` and `stderr` with the contents of the *`stdout`*
    and *`stderr`* macro arguments. If *`status`* is omitted, autotest assumes a successful
    status code of zero. If *`commands`* returns a status code to the shell that does
    not match the expected status code specified in *`status`*, the test fails. In
    order to ignore the status code of *`commands`*, you should use the special command
    `ignore` in the *`status`* parameter.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless, there are a couple of status codes that even `ignore` will not
    ignore: a status code of 77 (skip) returned by *`commands`* will cause autotest
    to skip the rest of the tests in the current test group, while 99 (hard failure)
    will cause autotest to fail the entire test group immediately.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Like *`status`*, the *`stdout`* and *`stderr`* parameters appear to be optional,
    but looks can be deceiving. If you pass nothing in these arguments, this merely
    tells Autoconf that the test’s `stdout` and `stderr` output streams are expected
    to be empty. Anything else will fail the test. So how do we tell autotest we don’t
    want to check the output? As with *`status`*, we can use special commands in *`stdout`*
    or *`stderr`*, including those shown in [Table 9-1](ch09.xhtml#ch09tab1):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Special Commands Allowed in *`stdout`* and *`stderr`* Arguments.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `ignore` | Do not check this output stream, but do log it to the test group’s
    log file. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `ignore-no-log` | Do not check or log this output stream. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `stdout` | Log and capture the test’s `stdout` output to the file `stdout`.
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `stderr` | Log and capture the test’s `stderr` output to the file `stderr`.
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `stdout-nolog` | Capture the test’s `stdout` output to the file `stdout`,
    but do not log. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `stderr-nolog` | Capture the test’s `stderr` output to the file `stderr`,
    but do not log. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `expout` | Compare the test’s `stdout` output to the file `expout`, created
    earlier; log the differences. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `experr` | Compare the test’s `stderr` output to the file `experr`, created
    earlier; log the differences. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: The *`run-if-fail`* and *`run-if-pass`* arguments allow you to optionally specify
    shell code that should be executed upon test failure or success, respectively.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '`AT_CHECK_UNQUOTED` does exactly the same thing as `AT_CHECK`, except that
    it performs shell expansion on *`stdout`* and *`stderr`* first, before making
    the comparison with the output of *`commands`*. Since `AT_CHECK` doesn’t do shell
    expansion on *`stdout`* and *`stderr`*, it stands to reason that you need to use
    `AT_CHECK_UNQUOTED` if you reference any shell variables in the text of these
    parameters.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Defining Test Groups with AT_SETUP and AT_CLEANUP
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `AT_CHECK` macro must be invoked between invocations of `AT_SETUP` and
    `AT_CLEANUP`, the pair of which define a test group and, therefore, the temporary
    directory from which the tests in the group are executed. The prototypes for these
    macros are defined as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you’ve got any experience with the *xUnit* family of unit test frameworks
    (JUnit, NUnit, CPPUnit, and so on), you’ve probably got a pretty strong notion
    of what the setup and cleanup (or teardown) functions should be used for. Usually
    a *setup* function runs some common code before each test in a test set, and a
    *cleanup* or *teardown* function executes some common code at the end of each
    test in the set.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Autotest is a bit different—there is no formal setup or teardown functionality
    shared by tests belonging to the same group (although this sort of functionality
    can be emulated with shell functions defined within the test group in *testsuite.at*,
    or in its included subfiles). As with *xUnit* frameworks, Autotest runs every
    test in total isolation, because every test runs within its own subshell. The
    only way a test can affect a subsequent test is by sharing the same test group
    and leaving filesystem droppings around for subsequent tests to examine and act
    upon.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '`AT_SETUP` accepts only one argument, *`test-group-name`*, which is the name
    of the test group that we’re starting, and this argument is required. `AT_CLEANUP`
    accepts no arguments.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add the group setup and cleanup macro invocations, wrapping a call to
    `AT_CHECK`, to a new file, *tests/jupiter.at*, as shown in [Listing 9-7](ch09.xhtml#ch09ex7).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.1
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 9-7:* tests/jupiter.at: *Adding our first test group—attempt #1*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Libtool adds a wrapper script in the *src* directory for any executables that
    use Libtool shared libraries. This wrapper script allows `jupiter` to find the
    uninstalled Libtool libraries it’s trying to use. As mentioned in [Chapter 7](ch07.xhtml),
    it’s a convenience mechanism that Libtool provides so we don’t have to jump through
    hoops to test programs using Libtool shared libraries before they’re installed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that the *src/jupiter* script is executing the real `jupiter`
    program from *src/.libs/lt-jupiter*. Because `jupiter` displays its own location,
    based on its `argv[0]` contents, we need to expect it to print this path.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We then need to add an `m4_include` statement to our currently empty *testsuite.at*
    file in order to include *jupiter.at*, as shown in [Listing 9-8](ch09.xhtml#ch09ex8).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-8:* tests/testsuite.at: *Including* jupiter.at *in* testsuite.at'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also want to add this new source file to our *tests/Makefile.am* file’s
    `TESTSOURCES` variable so it becomes a prerequisite of `testsuite`, as shown in
    [Listing 9-9](ch09.xhtml#ch09ex9).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-9:* tests/Makefile.am: *Adding additional sources to `TESTSOURCES`*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll follow this practice for every test we add to our test suite. In the
    end, the only thing in *testsuite.at* will be several invocations of `m4_include`,
    one for each test group. Executing this code renders the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**NOTE**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '*Running `autoreconf` and `configure` was required only because we updated
    the* tests/Makefile.am *file. If we’d just touched an existing .at file, which
    is rebuilt by the `check` target in* tests/Makefile, *then neither `autoreconf`
    nor `configure` would have been necessary.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: I’ll admit here that our single test failed because I deliberately coded the
    test incorrectly in order to show you what a failed test looks like.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Although not obvious from the output, there is more than one *testsuite.log*
    file created by `testsuite` when tests fail. The first is a master *testsuite.log*
    file in the *tests* directory, which is always created, even when all tests pass,
    and is designed to be sent in bug reports to the project maintainer. There is
    also a log file of the same name in a separate numbered directory within the *tests/testsuite.dir*
    directory for failed tests. The name of each of these directories is the number
    of the test group that failed. The test group number can be seen in the output.
    While you only need the master *testsuite.log* file, since it contains the entire
    contents of all of the individual tests’ *testsuite.log* files, this file also
    contains a lot of other information about your project and the test environment
    that the maintainer would want to see but just gets in the way for our purposes
    here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'To see exactly how our test failed, let’s examine the contents of the *testsuite**.log*
    file left in the *tests/testsuite.dir/1* directory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First note that autotest writes, as often as possible, the related source line
    into the *testsuite.log* file. This isn’t a big win for us at this point, but
    if *testsuite.at* or its included files were long and complicated, you can see
    how this information could be very helpful.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, we see the argument we passed to the *`commands`* parameter of `AT_CHECK`,
    along with the number of the line at which this argument was passed to the macro
    in *jupiter.at*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: However, now things start to get a bit muddy. The entire point of the *`stdout`*
    and *`stderr`* arguments in `AT_CHECK` is to provide some comparison text for
    what is actually sent by the *`commands`* to these output streams. In accordance
    with the general Unix philosophy of not duplicating existing functionality, the
    autotest authors chose to use the `diff` utility to make these comparisons. The
    log lines from ➋ to ➌ (inclusive) show the *unified*^([4](footnote.xhtml#ch09fn4))
    output of the `diff` utility when comparing the *original* file (*/dev/null* since
    we passed no value in the *`stderr`* argument) to the *modified* file—the text
    sent to the `stderr` output stream during the attempt to execute *../src/jupiter*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with unified `diff` output, a brief explanation is in
    order. The two lines starting at ➋ indicate the objects being compared. The original,
    or minus (`---`), line indicates the left side of the comparison, while the modified,
    or plus (`+++`), line indicates the right side of the comparison. Here, we’re
    comparing */dev/null* with a temporary file called */.../jupiter/tests/testsuite.dir/at-groups/1/stderr*
    that was used by autotest to capture the `stderr` stream during the attempt to
    execute *../src/jupiter*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The next line, starting and ending with `@@`, is a *chunk* marker—`diff`’s way
    of telling us about a portion of the two files that does not match. There can
    be more than one chunk in the output displayed by `diff`. In this case, the entire
    output text is so short that only one chunk was required to show us the differences.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The numbers in the chunk marker represent two ranges, separated by a space.
    The first range starts with a minus (`-`) sign, indicating the range associated
    with the *original* file, and the second range starts with a plus (`+`) sign,
    indicating the range associated with the *modified* file. Here’s the line we’re
    currently discussing:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A range is made up of two integer values separated by a comma (`,`) or a single
    value with a default second value of 1\. In this example, the range being compared
    starts at zero in the original file and is zero lines long, while the comparison
    range in the second file starts at line 1 and is one line long. These ranges are
    1-based, meaning line 1 is the first line in the file. Therefore, the first range
    specification, `-0,0`, is a special range that means there’s no content in the
    file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The lines following the range specification contain the full text of these
    ranges, showing us the actual differences. The original file lines are printed
    first, each prefixed with a minus sign, and then the modified file lines are printed
    afterward, each prefixed with a plus sign. When there is enough content around
    the modified lines to do so, additional unprefixed lines are added before and
    after these lines, showing some context around the changes. In this case, the
    entire content of this section is:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the original file was empty, as indicated by the `-0,0` range in the chunk
    marker, there are no lines starting with minus. All we see is the one modified
    file line starting with a plus.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, clearly these files are not the same—we expected nothing on the `stderr`
    stream, but we got some error text instead. The shell experienced an error attempting
    to execute *../src/jupiter*—it could not be found. If you try this at the shell
    prompt, you’ll see the following output:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**NOTE**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '*Obviously you should not do this from the* tests *directory, or any other
    directory that’s a sibling to the* src *directory, or it’ll actually find* jupiter
    *(if it’s been built) rather than print this error.*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put this line into a shell script called (arbitrarily) *abc.sh* and
    execute the script on the `bash` command line, you’ll see output that matches
    the format shown in *testsuite.log*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see at ➎ in *testsuite.log* that the shell returned a 127 status code,
    indicating an error of some sort. The value 127 is used by the shell to indicate
    execution errors—file not found or file not executable.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'To be complete, let’s also consider the lines between ➍ and ➎ for a moment.
    This is the unified `diff` output seen when comparing the text specified in `AT_CHECK`’s
    *`stdout`* argument with what was actually written to `stdout` by `jupiter` (actually
    the shell, since we know *../src/jupiter* was not found). In this case, we see
    that the minus text is the original comparison text we specified and the plus
    text is a single newline character, as this is what the shell sent to `stdout`.
    The chunk marker range specification, fully expanded, would be:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There was one line of text in each of the original and modified sources to be
    compared, but, as we can see by the output, the text in these sources was completely
    different.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '*So What Happened?*'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This first attempt assumed that the `jupiter` program (or, rather, the Libtool
    wrapper script) is found at *../src/jupiter*, relative to the *tests* directory.
    While this assumption is true, I’ve already alluded to the fact that each test
    group is executed in its own temporary directory, so it makes perfect sense that
    this relative path is not going to work from another directory. Even if we figured
    out, by trial and error, how many parent directory references to use, it would
    be quite fragile; if we ran `testsuite` from a different directory, it would fail
    because it depends so intimately on running from a specific position relative
    to the `jupiter` program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try a different tack. We’ll make use of the variables generated by `configure`
    into *atconfig*. One of them, `abs_top_builddir`, contains the absolute path to
    the top build directory. Therefore, we should be able to successfully reference
    `jupiter` from anywhere using `${abs_top_builddir}`*/src/jupiter*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'But now we have another problem: `jupiter` prints its own path and we’ve just
    decided to obtain that path using a shell variable, so we’ll also need to change
    the comparison text to use this variable, as well. This change, however, causes
    yet another issue—we’ll need to change `AT_CHECK` to `AT_CHECK_UNQUOTED` if we
    expect that shell variable in `AT_CHECK`’s *`stdout`* parameter to be expanded
    before the macro makes the comparison. Let’s make these modifications by changing
    *jupiter.at* as shown in [Listing 9-10](ch09.xhtml#ch09ex10).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.2
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 9-10:* tests/jupiter.at: *Adding our first test group—attempt #2*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve switched to using `AC_CHECK_UNQUOTED`, and we’ve changed both the
    `jupiter` program path in the first argument and the comparison text in the third
    argument to use the `abs_top_builddir` variable we inherit from *atconfig*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '*The newline at the end of the *`stdout`* argument is intentional and explained
    shortly.*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Once again, I only had to run `make`. Even though our changes were dramatic,
    affecting even the macros we called in the test suite, remember that the entire
    test suite is generated from `make check`. The only time we need to execute `autoreconf`
    and `configure` is if we make changes to *configure.ac* or any of the templates
    from which it generates files used by `make check`, or if we make any changes
    to *Makefile.am* files.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: This attempt had much better results, but what’s with that extra newline at
    the end of our comparison text in [Listing 9-10](ch09.xhtml#ch09ex10)? Well, remember
    what it is that we’re sending to `stdout` from `jupiter`. [Listing 9-11](ch09.xhtml#ch09ex11)
    provides a reminder.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 9-11:* common/print.c: *What `jupiter` sends to `stdout`*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The comparison text is an exact duplicate of what we expect to find on `jupiter`’s
    `stdout`, so we’d better be sure to include every character we write; the trailing
    newline is part of that data stream.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: It’s probably a good idea at this point to remove the *src/Makefile.am* code
    that builds and runs the Automake version of the test. Change *src/Makefile.am*
    as shown in [Listing 9-12](ch09.xhtml#ch09ex12).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 9-12:* src/Makefile.am: *The updated full contents of this file after
    removing tests*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '*All we did here was remove the test-related lines from the bottom half of
    the file.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing vs. Integration Testing
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the whole, the autotest version is not much better than what we had when
    our test was being executed by Automake’s test framework in *src/Makefile.am*.
    Adding new tests is, however, a bit simpler than what we’d have to do in *src/Makefile.am*’s
    `TESTS` variable. In fact, the only way the Automake version becomes simpler is
    if we actually write test programs and build them in `check` primaries. We might
    still have to build test programs in `check` primaries, but calling them and validating
    their output is trivial when using autotest.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: If you’re thinking that it feels like autotest is more attuned to system and
    integration testing than unit testing, you’re pretty close to the mark. Autotest
    is designed to test your project from the outside, but it’s not limited to such
    tests. Anything you can call from the command line can be a test, from autotest’s
    perspective. What autotest actually offers you is a framework for generating uniform
    test output, regardless of the kind of tests you’re using.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: One approach to unit testing that I’ve used for years involves writing test
    programs where the main source module of my test program literally `#include`s
    the *.c* file I’m testing. This gives me the option of calling static methods
    within the module under test and provides direct access to internal structures
    defined within that module.^([5](footnote.xhtml#ch09fn5)) This approach is pretty
    C oriented, but other languages have their own ways of performing the same sort
    of tricks. The idea is to create a test program that can reach into the private
    parts of a module and exercise functionality in small chunks. When you put those
    chunks together, you can feel confident that the individual chunks are working
    as designed; if there’s a problem, it’s probably in the way you glued them together.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add some unit testing to Jupiter by creating a test module that tests
    the functions in the *common/print.c* module. Create a file called *test_print.c*
    in the *common* directory that contains the content in [Listing 9-13](ch09.xhtml#ch09ex13).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.3
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 9-13:* common/test_print.c: *A unit test program for the print.c module*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The first line uses the preprocessor to rename any calls to `printf` to `mock_printf`.
    The second line then uses the preprocessor to `#include` *print.c* directly into
    *test_print.c*. Now, any calls to `printf` inside of *print.c* will be redefined
    to call `mock_printf` instead—including any prototypes defined in system header
    files like *stdio.h*.^([6](footnote.xhtml#ch09fn6))
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to verify that the `print_it` function actually prints *Hello
    from* `argument`*!\n* and returns zero to the caller. We don’t need any output—a
    shell return code is sufficient for this test to indicate to the user that `print_it`
    is working as designed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Neither do we need this module’s `main` routine to accept any command line arguments.
    If we had several tests in here, however, it might be convenient to accept some
    sort of argument that allows us to tell the code which test we want to run.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: All we’re really doing here is directly calling `print_it` with a short string
    and then attempting to verify that `print_it` returned zero and actually passed
    what we expected to `printf`. Note that `print_it` is a static function, which
    should make it inaccessible to other modules, but because we’re including *print.c*
    at the top of *test_print.c*, we’re effectively combining both source files into
    a single translation unit.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s write the build code for this test program. First, we need to add
    some lines to *common/Makefile.am* so that a `test_print` program gets built when
    we run `make check`. Modify *common/Makefile.am* as shown in [Listing 9-14](ch09.xhtml#ch09ex14).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 9-14:* common/Makefile.am: *Adding `test_print` as a `check_PROGRAM`*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: When we make the `check` target, we’ll now get a new program, `test_print`,
    in the *common* directory. Now we need to add a call to this program to our test
    suite. Create a new file in *tests* called *print.at*, as shown in [Listing 9-15](ch09.xhtml#ch09ex15).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 9-15:* tests/print.at: *Adding the `print` test*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: We also need to add an `m4_include` statement for this test to *testsuite.at*,
    as in [Listing 9-16](ch09.xhtml#ch09ex16).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 9-16:* tests/testsuite.at: *Adding print.at to testsuite.at*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we need to add this new source file to the `TESTSOURCES` variable
    in *tests/Makefile.am*, as shown in [Listing 9-17](ch09.xhtml#ch09ex17).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 9-17:* tests/Makefile.am: *Adding print.at to `TESTSOURCES`*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Since the `test_print` program only uses the shell status code to indicate an
    error, using it in `AT_CHECK` is as simple as it gets. You only need the first
    argument—the name of the program itself. If `test_print` had more than one test,
    you might accept a command line argument (within the same parameter) that indicates
    which test you want to run and then add several invocations of `AC_CHECK`, each
    running `test_print` with a different argument.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve started a new test group—as I mentioned earlier, you should
    try hard to limit your test groups to a single test unless the nature of the tests
    are such that they work together on the same file-based data set.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a shot. Note that in order to run the new test, we really only
    need to make the `check` target to update and execute `testsuite`. However, since
    we added the *print.at* dependency to *tests/Makefile.am*, we should probably
    also run `autoreconf` and `configure`. Had we enabled maintainer mode, the extra
    maintainer-mode rules would have done this for us:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Administrative Details
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned while describing the contents of *tests/Makefile.am* back near [Listing
    9-2](ch09.xhtml#ch09ex2) that we needed to add some additional infrastructure
    to that file in order to complete the tie-in with Automake. Let’s take care of
    those details now.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve seen that `make` (`all`) and `make check` work just fine, building our
    products and building and executing our test suite. But we’ve neglected some of
    the other targets that Automake wires up for us—specifically, `installcheck`,
    `clean`, and distribution-related targets like `dist` and `distcheck`. There’s
    a general lesson to be considered here: whenever we add custom rules to *Makefile.am*,
    we need to consider the impact on the standard targets generated by Automake.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Distributing Test Files
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several generated files that need to be distributed. These files are
    not inherently known by Automake, and, therefore, Automake needs to be told explicitly
    about them. This is done with the Automake-recognized `EXTRA_DIST` variable, which
    we’ll add to the top of *tests/Makefile.am*, as shown in [Listing 9-18](ch09.xhtml#ch09ex18).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.4
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 9-18:* tests/Makefile.am: *Ensuring test files get distributed with
    `EXTRA_DIST`*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ve added all the test suite source files, including *testsuite.at*,
    *local.at*, *jupiter.at*, and *print.at*. I’ve also added the `testsuite` program
    and any input files we generated using a non-Automake mechanism. These include
    *atconfig*, which is generated by code provided by the `AC_CONFIG_TESTDIR` macro
    internally, and *package.m4*, which is generated by a custom rule we added earlier
    to this *Makefile.am* file. It’s important to understand here that adding files
    to `EXTRA_DIST` causes them to be built, if needed, when `make dist` is executed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '*I would have like to have just used *`$(TESTSOURCES)`* in *`EXTRA_DIST`*,
    but the sources in that variable were formatted for rules and commands. *`EXTRA_DIST`*,
    as interpreted by Automake, is designed to refer to a list of files relative to
    the current directory within the source tree.*'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, we distribute *.at* files because the GNU General Public License
    says we must distribute the source code for our project and these files are the
    source code for `testsuite`, just as *configure.ac* is the source code for `configure`.
    However, even if you’re not using the GPL, you should still consider shipping
    the preferred editing format of all files in your project; it is an open source
    project, after all.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*Checking Installed Products*'
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We wrote a `check` target; it’s probably a good idea to support the *GCS* `installcheck`
    target, which Automake also supports. This is done by adding the `installcheck-local`
    target to this *Makefile.am* file, as shown in [Listing 9-19](ch09.xhtml#ch09ex19).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Listing 9-19:* tests/Makefile.am: *Supporting installed-product testing*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between `check-local` and `installcheck-local` is the addition
    of the `AUTOTEST_PATH` command line option to `testsuite`, pointing `testsuite`
    to the copy of `jupiter` found in `$(DESTDIR)$(bindir)`, where it was installed.
    `AUTOTEST_PATH` is prepended to the shell `PATH` variable before invoking *`commands`*
    in `AT_CHECK_UNQUOTED`; therefore, you could write test code that assumes `PATH`
    contains the path to an installed copy of `jupiter`. However, tests are designed
    to be executed on either installed or uninstalled programs, so it’s a good idea
    to continue deriving and using a full path to programs within your test commands.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll need to make a decision. When the user types `make check`, they clearly
    mean to test the copy of `jupiter` in the build tree. But when they type `make
    installcheck`, certainly they want to check the installed version of the program,
    either in the default install location or wherever the user indicates by using
    command line `make` variables like `DESTDIR`, `prefix`, and `bindir`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up a new issue: when we run tests for uninstalled `jupiter`, we’re
    relying on Libtool’s wrapper script to ensure `jupiter` can find *libjupiter.so*.
    Once we start testing installed `jupiter`, we’ll become responsible for showing
    `jupiter` where *libjupiter.so* is located. If `jupiter` is installed in standard
    places (such as */usr/lib*), the system will naturally find *libjupiter.so*. Otherwise,
    we’ll have to set the `LD_LIBRARY_PATH` environment variable to point to it.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we write our tests to work correctly in both situations? One interesting
    (but broken) approach is shown in [Listing 9-20](ch09.xhtml#ch09ex20).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 9-20:* tests/jupiter.at: *Testing execution for both installed and
    uninstalled *`jupiter`*—attempt#1*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The `find_jupiter` shell function attempts to locate `jupiter` in the `PATH`
    by using the shell’s `type` command. If the first result is empty, we revert to
    using the uninstalled version of `jupiter`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The function sets two shell variables, `jupiter` and `compare`. The `jupiter`
    variable is the full path to `jupiter`. The `compare` variable is derived from
    `jupiter` and contains either the value of `${jupiter}` or the Libtool location
    and name for uninstalled versions. We can set `LD_LIBRARY_PATH` in both cases
    to the *../lib* directory, relative to where `jupiter` is found because that’s
    probably^([7](footnote.xhtml#ch09fn7)) where it’s installed.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The problems with this approach are numerous. First, it doesn’t handle, very
    well, the situation where `jupiter` *should* be installed but isn’t found in the
    specified or implied install path. In this case, the code quietly reverts to testing
    the uninstalled version—likely not what you wanted. Another issue is that `find_jupiter`
    will locate `jupiter` anywhere in the `PATH`, even if the instance is not the
    one you intended to test. But there’s an even more nefarious bug: if you execute
    `make check`, intending to test the uninstalled version, and an installed version
    of `jupiter` happens to be somewhere in the `PATH`, that’s the version that will
    be tested.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: It’s unfortunate that `AUTOTEST_PATH` defaults to a non-empty value when it’s
    not specified on the command line, as this would be a good way to differentiate
    the use of `make check` from `make installcheck`. However, `AUTOTEST_PATH` does
    default to the name of the directory specified in `AC_CONFIG_TESTDIR`, which also
    happens to be the value of `${at_testdir}`—one of the variables generated by `AC_CONFIG_TESTDIR`
    in *atconfig*. We can use this fact to differentiate between `make check` and
    `make installcheck` by comparing `${AUTOTEST_PATH}` to `${at_testdir}`. Change
    *tests/jupiter.at* as shown in [Listing 9-21](ch09.xhtml#ch09ex21).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 9-21:* tests/jupiter.at: *A better way to use `AUTOTEST_PATH`*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Now, when `make check` is executed, the `jupiter` variable will always be set
    directly to the uninstalled version in the build tree (and `compare` will be set
    to *.../.libs/lt-jupiter*), but when `make installcheck` is entered, it will be
    set to `${AUTOTEST_PATH}`*/jupiter* (and `compare` will be set to the same value).
    Additionally, since we’re able to fully distinguish between installed and uninstalled
    testing, we can set the `LD_LIBRARY_PATH` only for installed versions of `jupiter`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: If `AUTOTEST_PATH` has been set incorrectly, which can happen (for example,
    when the user sets `DESTDIR` or `prefix` incorrectly on the `make` command line),
    the test will fail because `${jupiter}` will not be found.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: If I were to add additional tests that needed to run the `jupiter` program,
    these lines would be a perfect candidate for *local.at*. The problem is that a
    shell script designed to run within tests *must* be defined and executed between
    calls to `AT_SETUP` and `AT_CLEANUP`; otherwise, it’s simply omitted from the
    `autom4te` output stream while generating `testsuite`. So, how exactly is *local.at*
    useful to us? Well, you can’t write shell code directly in *local.at*, but you
    can define M4 macros that can be invoked from within your test modules. Let’s
    move the `find_jupiter` functionality into a macro definition in *local.at*, as
    shown in [Listing 9-22](ch09.xhtml#ch09ex22).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.5
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 9-22:* tests/local.at: *Moving `find_jupiter` to an M4 macro*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Using a shell function was, perhaps, a good idea when we started, but it’s become
    a bit extraneous at this point, so I modified the code to just set the `jupiter`
    variable directly. Notice the second (*`value`*) argument of the call to `m4_define`
    is set verbatim to the shell script we want to have generated when the macro is
    invoked.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The `set -x` command in the first line of the *`value`* argument enables shell
    diagnostic output so you can see the contents of this macro executing, but only
    if you set `TESTSUITEFLAGS=-v` on the `make` command line. This is the default
    setting for the output generated into *testsuite.log*, so you’ll be able to see
    what the code generated by the macro invocation is actually doing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '*You may have noticed the code in the second argument of *`m4_define`* has
    two sets of square brackets around it. This is not strictly necessary in this
    example because there are no special characters in the embedded code snippet.
    However, if there had been, double quoting would have allowed the special characters—embedded
    square brackets, or even a previously defined M4 macro name—to be generated exactly
    as is, without interference from the *`m4`* utility.*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Now change *tests/jupiter.at* as shown in [Listing 9-23](ch09.xhtml#ch09ex23).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Listing 9-23:* tests/jupiter.at: *Calling the `FIND_JUPITER` macro*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: With this change in place, all tests that needed to run the `jupiter` program
    may do so merely by invoking the `FIND_JUPITER` macro and then executing `${jupiter}`
    within the *`commands`* argument. As you can see, the options available to you
    are endless—they’re limited only by your mastery of the shell. Because each test
    is run in a separate subshell, you can feel free to set any environment variables
    you want without affecting subsequent tests.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out. Note we haven’t changed anything except for *.at* files,
    so we need only run `make` to see the effects of our changes. First, we’ll install
    into a local directory using `DESTDIR` so that we can see how `make installcheck`
    works:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the execution of `make check TESTSUITEFLAGS=-v` shows us at ➊ that `jupiter`
    is being picked up from the build tree and `compare` is set to the path of the
    Libtool binary, while `make installcheck DESTDIR=$PWD/inst TESTSUITEFLAGS=-v`
    indicates at ➋ that `jupiter` being picked up from the installation path we specified
    and `compare` is set to the same location. `LD_LIBRARY``_PATH` is also being set
    in this code path.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '*Cleaning Up*'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `testsuite` program has a `--clean` command line option that cleans up the
    *tests* directory of all test droppings. To wire that into the `clean` target,
    we add a `clean-local` rule, as shown in [Listing 9-24](ch09.xhtml#ch09ex24).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.6
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 9-24:* tests/Makefile.am: *Adding support for `make clean` in tests*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: If `testsuite` exists, it’s asked to clean up after itself. I’ve also added
    a command to remove the generated *atconfig* script, as `make distcheck` fails
    if this file is not removed during execution of the `clean` target while checking
    the distribution directory from which the package is built, and *atconfig* is
    not generated by Automake or by any Autoconf code that Automake monitors. At this
    point, you could try out `make dist` or `make distcheck` to see whether it now
    works as it should.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '*You might think the *`clean-local`* target is optional, but it’s required
    so that *`make distcheck`* won’t fail when building a distribution archive due
    to extra files being left around after *`distcheck`* runs *`make clean`*.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Note also that we don’t need to, nor should we, attempt to clean up files generated
    into the source tree, such as *package.m4* and `testsuite` itself. Why not? Much
    like `configure`, autotest products like `testsuite` sit somewhere between source
    files we write by hand and product files found in the build tree. They’re built
    from sources, but stored in the source tree and ultimately distributed in the
    archive.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Niceties
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One more thing I like to do is add a call to `AT_COLOR_TESTS` to my *local.at*
    file, right after the invocation of `AT_INIT`. Users can always specify colored
    test output using a command line argument to `testsuite` (`--color`), but using
    this macro allows you to enable colored test output by default. Change your *local.at*
    file as shown in [Listing 9-25](ch09.xhtml#ch09ex25).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Git tag 9.7
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 9-25:* tests/local.at: *Making colored test output the default*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'You should notice that the `ok` text after each successful test, as well as
    the summary line `All 2 tests were successful.`, is now green. If you had experienced
    any failed tests, those tests would have shown `FAILED (testsuite``.at:`*`N`*`)`
    in red after the failed tests, with summary lines in red as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A Minimal Approach
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I mentioned at the outset that we’d take a look at cutting this system down
    to the bare necessities for smaller projects. Here’s what we can do without:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '***tests/local.at*** Copy the contents of this file to the top of *testsuite.at*
    and delete the file.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '***tests/atlocal.in*** Assuming you don’t need to pass any configuration variables
    into your testing environment, remove the reference to the product file, *atlocal*,
    from the call to `AC_CONFIG_FILES` in *configure.ac* and delete this template
    file.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '***tests/*.at*** **(subtest files included by** ***testsuite.at***) Copy the
    content of these files serially into *testsuite.at* and delete the files; remove
    the `m4_include` macro invocations that were originally used to include these
    files.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Edit *tests/Makefile.am* and remove all references to the preceding files (templates
    and generated products) from the `EXTRA_DIST` and `TESTSOURCES` variables, as
    well as from the `check-local` and `installcheck-local` rules.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: I would not remove the *package.m4* rule, although you may do so if you wish
    by copying the `m4_define` macro invocations generated into this file directly
    to the top of *testsuite.at*. Since `make` generates this file using variables
    defined by Autoconf, a generated instance of *package.m4* already contains the
    values that replace the variable references in the command in *tests/Makefile.am*.
    In my opinion, the value of not having to edit this information in two places
    far outweighs the overhead of maintaining the file generation rule.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve covered the basics of autotest, but there are a dozen more or less useful
    `AT_*` macros you can use in your *testsuite.at* file. Section 19.2 of the *GNU
    Autoconf Manual* documents them in detail. I’ve shown you how to wire autotest
    into the Automake infrastructure. If you’ve chosen to use autotest without Automake,
    there will be some differences between the Automake’s *tests/Makefile.am* and
    Autoconf’s *tests/Makefile.in*, as you can no longer rely on Automake to do some
    things for you. However, if you’re writing your own *Makefile.in* templates, these
    modifications will quickly become obvious to you.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve also shown you a technique for creating unit tests in C that allows you
    full access to the private implementation details of a source module. I’ve attained
    nearly 100 percent code coverage using this technique in past projects, but I’ll
    warn you of one caveat now: writing unit tests at this level makes it much more
    difficult to change the functionality of your application. Fixing a bug is not
    so bad, but making design changes will generally require you to disable or entirely
    rewrite the unit tests associated with the code affected by your changes. It’s
    a good idea to be pretty sure of your design before committing yourself to this
    level of unit testing. It has been said that one of the primary values of writing
    unit tests is that you can *set them and forget them*—that is, you can write the
    tests once, wire them into your build system, and no longer pay attention to whether
    the code under test is working. Well, this is mostly true, but if you ever have
    to modify a well-tested feature in your project, unless you comment your test
    code well, you’ll find yourself wondering what you were thinking when you wrote
    that test code.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, I sleep better at night knowing that code I just committed to
    my company repository is fully tested. I’ve also been more confident in discussions
    with colleagues regarding bugs surrounding my well-tested code. Autotest has helped
    reduce the effort involved in these projects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: With the end of this chapter, we’ve also come to the end of the Jupiter project—and
    it’s a good thing, because I’ve taken the *Hello, world!* concept *much* further
    than anyone has a right to. From here on out, we’ll be focusing on more isolated
    topics and real-world examples.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
