- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 1 EXAMINING PROCESSES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 检查进程
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The overwhelming majority of Mac malware executes as stand-alone processes continuously
    running on infected systems. As a result, if you generate a list of running processes,
    it’s more than likely to include any malware present on the system. Thus, when
    you’re trying to programmatically detect macOS malware, you should start by examining
    processes. In this chapter, we’ll first discuss various methods of enumerating
    running processes. Then we’ll programmatically extract various information and
    metadata about each running process to uncover anomalies commonly associated with
    malware. This information can include the full path, arguments, architecture,
    process, hierarchy, code signing information, loaded libraries, open files, and
    much more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Mac 恶意软件以独立进程的形式持续运行在感染的系统上。因此，如果你生成一个运行中的进程列表，很可能会包含系统上存在的任何恶意软件。因此，当你试图通过编程检测
    macOS 恶意软件时，应该首先检查进程。在本章中，我们将首先讨论枚举正在运行的进程的各种方法。然后，我们将编程提取每个运行进程的各种信息和元数据，以揭示与恶意软件常见的异常情况。这些信息可以包括完整路径、参数、架构、进程、层次结构、代码签名信息、加载的库、打开的文件等。
- en: Of course, the fact that a malicious process shows up in a listing doesn’t immediately
    allow you to determine that the process is indeed malicious. This is increasingly
    true as malware authors seek to masquerade their malicious creations as benign.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，恶意进程出现在列表中并不立即意味着该进程就是恶意的。随着恶意软件作者不断努力将恶意程序伪装成良性的，这一点变得愈发正确。
- en: Most of the code snippets presented in this chapter are from the *enumerateProcesses*
    project, whose code you can download from this book’s GitHub repository. When
    executed with no arguments, this tool will display information about all running
    processes on your system; when executed with a process ID, it retrieves information
    about the specified process. To query a process, the privilege levels of your
    running code must match or exceed those of the target process, so security tools
    like this one often run with root privileges.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的大部分代码片段来自 *enumerateProcesses* 项目，你可以从本书的 GitHub 仓库下载该项目的代码。当没有参数时执行此工具，它将显示你系统上所有运行进程的信息；当传递一个进程
    ID 时，它将检索指定进程的信息。要查询一个进程，运行代码的权限级别必须与目标进程相匹配或更高，因此像这样的安全工具通常需要以 root 权限运行。
- en: Process Enumeration
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程枚举
- en: The easiest way to enumerate all processes on macOS is via libproc APIs such
    as proc_listallpids. As its name suggests, this API provides a list containing
    the process ID (pid) of each running process. As arguments, it takes an output
    buffer and the size of this buffer. It will populate the buffer with the process
    IDs of all running processes and return the number of running processes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上枚举所有进程最简单的方法是通过 libproc API，例如 proc_listallpids。顾名思义，该 API 提供一个包含每个运行进程的进程
    ID（pid）列表。作为参数，它需要一个输出缓冲区和该缓冲区的大小。它将填充该缓冲区，包含所有运行进程的进程 ID，并返回运行进程的数量。
- en: How will you know how big the output buffer should be? One strategy is to first
    invoke the API with NULL and 0 as arguments. This will cause the function to return
    the number of currently running processes, which you can then use to allocate
    a buffer for subsequent calls. However, if a new process is spawned in the middle
    of this action, the API may fail to return its process ID.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么知道输出缓冲区应该多大呢？一种策略是首先调用 API，传递 NULL 和 0 作为参数。这会导致该函数返回当前正在运行的进程数，然后你可以使用这个数量来分配缓冲区，以便后续调用。然而，如果在这个过程中产生了一个新进程，API
    可能无法返回其进程 ID。
- en: Thus, it’s better just to allocate a buffer to hold the maximum number of possible
    running processes. Modern versions of macOS can generally hold several thousands
    of processes, but this number can be higher (or lower) depending on the specs
    of the system. Due to this variability, you’ll want to dynamically retrieve this
    maximum number from the kern.maxproc system variable via the sysctlbyname API
    ([Listing 1-1](chapter1.xhtml#Lis1-1)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好分配一个缓冲区来保存最大数量的可能运行进程。现代版本的 macOS 通常可以支持数千个进程，但这个数字可能会根据系统配置而更高（或更低）。由于这个可变性，你需要通过
    sysctlbyname API 从 kern.maxproc 系统变量中动态获取这个最大值（见[列表 1-1](chapter1.xhtml#Lis1-1)）。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 1-1: Dynamically retrieving the maximum number of running processes'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-1：动态获取最大运行进程数
- en: Now that we have the maximum number of possible running processes, we simply
    allocate a buffer of this size multiplied by the size of each process ID. Then
    we invoke the proc_listallpids function ([Listing 1-2](chapter1.xhtml#Lis1-2)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了可能的最大运行进程数，我们只需分配一个大小为该数量与每个进程 ID 大小的乘积的缓冲区。然后我们调用 proc_listallpids
    函数（[列表 1-2](chapter1.xhtml#Lis1-2)）。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 1-2: Generating a list of process identifiers for running processes'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-2：生成运行进程的进程标识符列表
- en: 'Now we can add print statements and then execute this code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加打印语句，然后执行此代码：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code should return a list containing the process IDs of all running processes,
    as you can see from this run of the *enumerateProcesses* project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码应该返回一个包含所有运行进程的进程 ID 列表，如你在执行 *enumerateProcesses* 项目时所看到的那样。
- en: Audit Tokens
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审计令牌
- en: Although process IDs are used system-wide to identify processes, they can be
    reused once a process exits, leading to a race condition where the process ID
    no longer references the original process. The solution to the process ID race
    condition issue is to use the process’s *audit token*, a unique value that is
    never reused. In subsequent chapters, you’ll see how macOS sometimes directly
    provides you with an audit token, for example, when a process is attempting to
    connect to a remote XPC endpoint or in a message from Endpoint Security. However,
    you can also obtain a processes audit token directly from an arbitrary process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管进程 ID 在系统范围内用于标识进程，但它们在进程退出后可以被重用，这会导致一个竞态条件，其中进程 ID 不再指向原始进程。解决进程 ID 竞态条件问题的方法是使用进程的
    *审计令牌*，这是一个独特的值，永远不会被重用。在后续章节中，你将看到 macOS 有时会直接提供审计令牌，例如当进程试图连接到远程 XPC 端点或 Endpoint
    Security 发来的消息时。不过，你也可以直接从任意进程获取其审计令牌。
- en: You’ll find the code to obtain an audit token in a function named getAuditToken
    in the *enumerateProcesses* project. Given a process ID, this function returns
    its audit token ([Listing 1-3](chapter1.xhtml#Lis1-3)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在 *enumerateProcesses* 项目中的一个名为 getAuditToken 的函数里找到获取审计令牌的代码。该函数根据进程 ID 返回其审计令牌（[列表
    1-3](chapter1.xhtml#Lis1-3)）。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 1-3: Obtaining an audit token for a process'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-3：获取进程的审计令牌
- en: First, the function declares required variables, including one of type audit_token_t
    to hold the audit token. It then invokes the task_name_for_pid API to obtain a
    Mach task for the specified process ❶. You need this task for the call to task_info,
    which will populate a passed-in variable with the process’s audit token ❷. Finally,
    the audit token is converted into a more manageable data object ❸ and returns
    it to the caller.^([1](#chapter1-1))
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，函数声明了所需的变量，包括一个类型为 audit_token_t 的变量，用于保存审计令牌。接着它调用 task_name_for_pid API
    获取指定进程的 Mach 任务 ❶。你需要这个任务来调用 task_info，它将把进程的审计令牌填充到传入的变量中 ❷。最后，审计令牌被转换为一个更易于管理的数据对象
    ❸，并将其返回给调用者。^([1](#chapter1-1))
- en: 'Of course, a list of process IDs or audit tokens won’t tell you which, if any,
    are malicious. Still, you can now extract a myriad of valuable information. The
    next section starts with an easy one: retrieving the full path for each process.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，进程 ID 或审计令牌的列表并不能告诉你哪些（如果有的话）是恶意的。尽管如此，你现在可以提取大量有价值的信息。接下来的章节将从一个简单的任务开始：检索每个进程的完整路径。
- en: Paths and Names
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径和名称
- en: One simple way to look up the full path for a process from its process ID is
    via the proc_pidpath API. This API takes the ID of the process, an output buffer
    for the path, and the size of the buffer. You can use the constant PROC_PIDPATHINFO_MAXSIZE
    to ensure the buffer is large enough to hold the path, as shown in [Listing 1-4](chapter1.xhtml#Lis1-4).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是通过 proc_pidpath API 从进程 ID 查找进程的完整路径。该 API 接受进程 ID、路径的输出缓冲区以及缓冲区的大小。你可以使用常量
    PROC_PIDPATHINFO_MAXSIZE 来确保缓冲区足够大以容纳路径，如[列表 1-4](chapter1.xhtml#Lis1-4)所示。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 1-4: Retrieving the path of a process'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-4：检索进程的路径
- en: There are also other ways to obtain the path of a process, some of which don’t
    require a process ID. We’ll cover an alternative approach in [Chapter 3](chapter3.xhtml),
    as it requires an understanding of various concepts related to code signing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以获取进程的路径，其中一些方法不需要进程 ID。我们将在[第 3 章](chapter3.xhtml)中介绍一种替代方法，因为它需要理解与代码签名相关的各种概念。
- en: Once you’ve obtained a process’s path, you can use it to perform various checks
    that can help you determine whether the process is malicious. These checks can
    range from trivial, such as seeing whether the path contains hidden components,
    to more involved (for example, performing an in-depth analysis of the binary specified
    in the path). This chapter considers hidden path components, while the next chapter
    dives into full binary analysis.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得了进程的路径，你可以利用它执行各种检查，帮助你判断该进程是否为恶意进程。这些检查可以是简单的，比如查看路径是否包含隐藏的组件，也可以是更复杂的（例如，对路径中指定的二进制文件进行深入分析）。本章讨论了隐藏路径组件，而下一章将深入探讨完整的二进制分析。
- en: Identifying Hidden Files and Directories
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别隐藏的文件和目录
- en: Information from the path can directly reveal anomalies. For example, a path
    containing either a directory or file component that is prefixed with a dot (.)
    will be hidden in the user interface and from various command line tools by default.
    (Of course, there are ways to view hidden items, for example, via the ls command
    executed with the -a flag.) From the malware’s perspective, remaining hidden is
    a good thing. However, this becomes a powerful detection heuristic, as benign
    processes are rarely hidden.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 路径中的信息可以直接揭示异常。例如，路径中包含以点（.）为前缀的目录或文件组件，默认情况下将在用户界面和各种命令行工具中被隐藏。（当然，也有方法查看隐藏项，例如通过执行带有
    -a 标志的 ls 命令。）从恶意软件的角度来看，保持隐藏是件好事。然而，这也成为了一种强有力的检测启发式，因为良性进程很少会被隐藏。
- en: 'There are many examples of Mac malware executing from hidden directories or
    that are hidden themselves. For example, the cyber-espionage implant known as
    DazzleSpy,^([2](#chapter1-2)) discovered in early 2022, persistently installs
    itself as a binary named *softwareupdate* in a hidden directory named *.local*.
    In a process listing, this directory sticks out like a sore thumb:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多 Mac 恶意软件的例子，它们从隐藏目录中执行或本身就被隐藏。例如，名为 DazzleSpy 的网络间谍植入程序，^([2](#chapter1-2))
    在 2022 年初被发现，它会作为名为 *softwareupdate* 的二进制文件持久安装在名为 *.local* 的隐藏目录中。在进程列表中，这个目录显得非常突兀：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Of course, any heuristic-based approach is bound to have false positives, and
    you’ll occasionally encounter legitimate software that hides itself. For example,
    my Wacom drawing tablet creates a hidden directory, *.Tablet*, from which it persistently
    runs various programs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何基于启发式的方法都不可避免地会产生误报，你偶尔会遇到合法的软件将自己隐藏。例如，我的 Wacom 绘图板会创建一个名为*.Tablet*的隐藏目录，从该目录中持续运行各种程序。
- en: Obtaining the Paths of Deleted Binaries
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取已删除二进制文件的路径
- en: On macOS, nothing stops a process from deleting the on-disk binary that backs
    it. Malware authors are aware of this option and may craft a program that self-deletes
    by stealthily removing its binary from the filesystem to hide it from file scanners,
    thus complicating analysis. You can see an example of this anomalous behavior
    in Mac malware such as KeRanger and NukeSped, the latter of which was used in
    the infamous 3CX supply chain attack.^([3](#chapter1-3))
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，进程没有任何障碍来删除其支持的磁盘上的二进制文件。恶意软件作者意识到这个选项，并可能设计出一种程序，通过悄悄地从文件系统中删除自己的二进制文件来隐藏自己，从而避开文件扫描器，复杂化分析。你可以在
    Mac 恶意软件中看到这种异常行为，例如 KeRanger 和 NukeSped，后者曾在臭名昭著的 3CX 供应链攻击中被使用。^([3](#chapter1-3))
- en: 'Let’s take a closer look at KeRanger, ransomware whose sole purpose is to encrypt
    a victim’s files and demand a ransom. As it performs both actions in a single
    execution of the process, it doesn’t need to keep its binary around once spawned.
    If you look at the disassembly of its main function, you can see that KeRanger’s
    first action is to delete itself via a call to the unlink API:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 KeRanger，它是一款勒索病毒，唯一的目的是加密受害者的文件并索要赎金。由于它在单次执行过程中完成这两个操作，因此在生成后不需要再保留其二进制文件。如果你查看它的主函数的反汇编，你会看到
    KeRanger 的第一个动作是通过调用 unlink API 来删除自己：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If a security tool obtains the process ID of the KeRanger process (perhaps because
    the ransomware’s actions triggered a detection heuristic), path recovery APIs
    such as proc_pidpath and SecCodeCopyPath will fail. The first of these APIs, which
    normally returns the length of the process’s path, will in this case return zero
    with errno set to ENOENT, whereas SecCodeCopyPath will directly return kPOSIXErrorENOENT.
    This will tell you that the process’s binary has been deleted, which itself is
    a red flag, as benign processes normally don’t self-delete.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全工具获取了KeRanger进程的进程ID（可能是因为勒索病毒的行为触发了检测启发式分析），像proc_pidpath和SecCodeCopyPath这样的路径恢复API将会失败。这些API中的第一个，通常返回进程路径的长度，在这种情况下将返回零，并且errno会被设置为ENOENT，而SecCodeCopyPath则会直接返回kPOSIXErrorENOENT。这将告诉你，进程的二进制文件已经被删除，这本身就是一个警告信号，因为正常的进程通常不会自删除。
- en: If you still want to recover the path of the now-deleted binary, your options
    are unfortunately rather limited. One approach is to extract the path directly
    from the process’s arguments. We’ll cover this option shortly, in “Process Arguments”
    on [page 9](chapter1.xhtml#pg_9). It’s worth noting, however, that once a process
    is launched, there is nothing stopping the process from modifying its arguments,
    including its path. Thus, the recovered path may have been surreptitiously modified
    to no longer point to the self-deleted binary.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然想恢复现在已删除的二进制文件的路径，不幸的是，你的选择相当有限。一种方法是直接从进程的参数中提取路径。我们将在稍后章节的“进程参数”部分讲解这一方法，参见[第9页](chapter1.xhtml#pg_9)。然而值得注意的是，一旦进程启动，就没有任何东西阻止进程修改其参数，包括路径。因此，恢复的路径可能已经被悄悄修改，不再指向自删除的二进制文件。
- en: Validating Process Names
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验证进程名称
- en: Malware authors know that their malicious programs will show up in Apple’s built-in
    Activity Monitor, where even a casual user may stumble across an infection simply
    by noticing a strange process name. As such, Mac malware often attempts to masquerade
    as either core macOS components or popular third-party software. Let’s illustrate
    this with two examples.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者知道他们的恶意程序会出现在苹果内置的活动监视器中，即便是普通用户，也可能仅凭注意到一个奇怪的进程名称就发现感染。因此，Mac恶意软件通常会尝试伪装成macOS的核心组件或流行的第三方软件。我们通过两个例子来说明这一点。
- en: Uncovered in early 2021, ElectroRAT is a remote access tool (RAT) that targets
    cryptocurrency users.^([4](#chapter1-4)) It attempts to blend in by naming itself
    *.mdworker*. On older versions of macOS, you’d often find several legitimate instances
    of Apple’s metadata server worker (*mdworker*) running. Malware can use this same
    name to avoid arousing suspicion, at least in the casual user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ElectroRAT是2021年初被曝光的一种远程访问工具（RAT），专门针对加密货币用户。^([4](#chapter1-4))它试图通过将自己命名为*.mdworker*来融入系统。在旧版本的macOS中，你通常会发现多个合法的Apple元数据服务器进程（*mdworker*）在运行。恶意软件可以利用这个相同的名称来避免引起怀疑，至少在普通用户眼中是如此。
- en: Luckily, thanks to code signing (discussed briefly later in the chapter and
    in full detail in [Chapter 3](chapter3.xhtml)), you can check that a process’s
    code signing information matches its apparent creator. For example, it is easy
    to detect that ElectroRAT’s *.mdworker* binary is suspicious. First, it isn’t
    signed by Apple, meaning it wasn’t created by developers in Cupertino. A binary
    that matches the name of a well-known macOS process but doesn’t belong to Apple
    is more than likely malware. Finally, because its name begins with a dot, ElectroRAT’s
    process file is also hidden, providing yet another red flag.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，由于代码签名（稍后在本章中简要讨论，详细内容见[第3章](chapter3.xhtml)），你可以检查一个进程的代码签名信息是否与其显著的创建者匹配。例如，很容易发现ElectroRAT的*.mdworker*二进制文件是可疑的。首先，它没有由苹果签名，这意味着它不是库比蒂诺的开发者创建的。一个匹配知名macOS进程名称但不属于苹果的二进制文件，很可能是恶意软件。最后，由于其名称以点开头，ElectroRAT的进程文件也被隐藏，这又是一个警告信号。
- en: Another example is CoinMiner, a surreptitious cryptocurrency miner that leverages
    the Invisible Internet Project (I2P) for its encrypted communications. The network
    component that implements the I2P logic is named *com.adobe.acc.network* to mimic
    Adobe software, which is notorious for installing a myriad of daemons. By checking
    the process’s code signing information, you can see that Adobe hasn’t signed the
    binary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是CoinMiner，一种隐秘的加密货币矿工，利用隐形互联网项目（I2P）进行加密通信。实现I2P逻辑的网络组件名为*com.adobe.acc.network*，以模仿Adobe软件，后者以安装各种守护进程而著名。通过检查进程的代码签名信息，你可以发现Adobe并没有签署这个二进制文件。
- en: You may now be wondering how to determine a process’s name. For nonapplication
    processes, such as command line programs or system daemons, this name usually
    corresponds to the file component. You can retrieve this component via the lastPathComponent
    instance property if the full path is stored in a string or URL object. The code
    in [Listing 1-5](chapter1.xhtml#Lis1-5), for example, extracts ElectroRAT’s process
    name, *.mdworker*, and stores this in the variable name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能在想，如何确定一个进程的名称。对于非应用程序进程，如命令行程序或系统守护进程，这个名称通常对应于文件组件。如果完整路径存储在字符串或 URL
    对象中，你可以通过 lastPathComponent 实例属性检索此组件。例如，[列表 1-5](chapter1.xhtml#Lis1-5) 中的代码提取了
    ElectroRAT 的进程名称，*.mdworker*，并将其存储在变量 name 中。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 1-5: Extracting ElectroRAT’s process name'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-5：提取 ElectroRAT 的进程名称
- en: 'If the process is an application, you can instantiate an NSRunningApplication
    object via the runningApplicationWithProcessIdentifier: method. This object will
    provide, among other things, the path to its application bundle in the bundleURL
    instance property. The bundle contains a wealth of information, but what’s most
    relevant here is the app’s name. [Listing 1-6](chapter1.xhtml#Lis1-6), from the
    getProcessName function in the *enumerateProcesses* project, illustrates how to
    do this for a given process ID.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '如果该进程是一个应用程序，你可以通过 runningApplicationWithProcessIdentifier: 方法实例化一个 NSRunningApplication
    对象。该对象将提供多种信息，其中最相关的是应用程序捆绑包的路径，该路径保存在 bundleURL 实例属性中。捆绑包包含大量信息，但这里最重要的是应用程序的名称。[列表
    1-6](chapter1.xhtml#Lis1-6)中的 *enumerateProcesses* 项目中的 getProcessName 函数展示了如何针对给定的进程
    ID 提取此信息。'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 1-6: Extracting an application name'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-6：提取应用程序名称
- en: From the NSRunningApplication object, we create an NSBundle object and then
    extract the application’s name from the bundle’s infoDictionary instance property.
    If the process isn’t an application, the NSRunningApplication instantiation will
    gracefully fail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从 NSRunningApplication 对象中，我们创建一个 NSBundle 对象，然后从捆绑包的 infoDictionary 实例属性中提取应用程序的名称。如果该进程不是应用程序，NSRunningApplication
    实例化将会优雅地失败。
- en: Process Arguments
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程参数
- en: 'Extracting and examining the arguments of each running process can shed valuable
    light on the actions of the process. They might also seem suspicious in their
    own right. An installer for the notorious Shlayer malware provides an illustrative
    example. It executes a bash shell with these arguments:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 提取并检查每个正在运行的进程的参数可以揭示该进程的活动。它们本身也可能看起来很可疑。臭名昭著的 Shlayer 恶意软件的安装程序提供了一个典型的示例。它执行了一个带有以下参数的
    bash shell：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These arguments instruct bash to execute various shell commands that extract
    bytes from a file masquerading as an image named *main.png*, decrypt them to a
    binary named *ZQEifWNV2l*, then execute and delete this binary. Though bash itself
    is not malicious, the programmatic extraction of encrypted, executable contents
    from a *.png* file indicates that something suspicious is afoot; installers don’t
    normally perform such obtusely obfuscated actions. We’ve also gained insight into
    the activities the installer takes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数指示 bash 执行各种 shell 命令，从一个伪装成名为 *main.png* 的图像文件中提取字节，将其解密为名为 *ZQEifWNV2l*
    的二进制文件，然后执行并删除该二进制文件。尽管 bash 本身并不具备恶意性，但从 *.png* 文件中程序化地提取加密的可执行内容表明某些可疑活动正在进行；安装程序通常不会执行如此晦涩的混淆操作。我们还对安装程序的行为有了进一步的了解。
- en: 'Another example of a program with clearly suspicious arguments is Chropex,
    also known as ChromeLoader.^([5](#chapter1-5)) This malware installs a launch
    agent to persistently execute Base64-encoded commands. A report from CrowdStrike^([6](#chapter1-6))
    shows an example of a Chropex launch agent, with a snippet reproduced here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个具有明显可疑参数的程序是 Chropex，也叫做 ChromeLoader。^([5](#chapter1-5)) 这个恶意软件安装一个启动代理，持久性地执行
    Base64 编码的命令。CrowdStrike 的一份报告^([6](#chapter1-6))展示了一个 Chropex 启动代理的示例，下面是一个摘录：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last argument string, beginning with echo, consists of an encoded blob and
    a command to decode and then execute it via bash. It goes without saying that
    such an argument is unusual and a symptom that something is amiss (for example,
    that the system is persistently infected with malware). Once a detection program
    encounters this launch agent and extracts its very suspicious arguments, the program
    should raise a red flag.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数字符串以 echo 开头，包含一个编码的二进制数据块和一个命令，用来解码并通过 bash 执行它。显然，这样的参数非常不寻常，是系统被恶意软件持久感染的迹象。一旦检测程序遇到这个启动代理并提取其非常可疑的参数，该程序应立即触发警报。
- en: As I mentioned earlier, extracting a program’s runtime arguments may provide
    insight into its functionality. For example, a surreptitious cryptocurrency miner
    found in the official Mac App Store masqueraded as an innocuous Calendar application
    ([Figure 1-1](chapter1.xhtml#fig1-1)).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，提取程序的运行时参数可能会为其功能提供一些线索。例如，一个隐藏的加密货币矿工在官方Mac App Store中伪装成一个无害的日历应用（[Figure
    1-1](chapter1.xhtml#fig1-1)）。
- en: '![](../images/Figure1-1.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-1.jpg)'
- en: 'Figure 1-1: An innocuous calendar application, or something else?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 1-1: 一个无害的日历应用，还是其他什么东西？'
- en: 'To see that this app does more than meets the eye, we can examine process arguments.
    When the Calendar 2 application, *CalendarFree.app*, was executed, it would spawn
    a an embedded child program from within the *Coinstash_XMRSTAK* framework named
    *xmr-stak* with the following arguments:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这个应用程序的功能，我们可以检查进程参数。当Calendar 2应用程序 *CalendarFree.app* 被执行时，它会从 *Coinstash_XMRSTAK*
    框架中生成一个嵌入的子程序，名为 *xmr-stak*，并传入以下参数：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Based on values like "--currency" and "monero", even casual readers should be
    able to tell that *xmr-stak* is a cryptocurrency miner. Although *xmr-stak* is
    a legitimate command line application, its surreptitious deployment via a free
    Calendar application hosted on Apple’s Mac App Store crosses a line.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据诸如“--currency”和“monero”这样的值，即使是普通读者也应该能够判断出 *xmr-stak* 是一个加密货币矿工。尽管 *xmr-stak*
    是一个合法的命令行应用程序，但它通过一个托管在苹果Mac App Store上的免费日历应用悄然部署，已越过了界限。
- en: '> NOTE'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注意'
- en: '*After I published a detailed blog post about this application,*^([7](#chapter1-7))
    *Apple removed the app and updated the App Store’s Terms and Conditions to explicitly
    ban on-device mining.*^([8](#chapter1-8))'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*在我发布了关于这个应用的详细博客文章后，*^([7](#chapter1-7)) *苹果删除了该应用，并更新了App Store的条款和条件，明确禁止设备上的挖矿行为。*^([8](#chapter1-8))'
- en: Finally, extracting a process’s arguments can aid you if you decide the process
    is suspicious and requires further analysis. For example, in early 2023, I discovered
    a malicious updater with ties to the prolific Genieo malware family that had remained
    undetected for almost five years.^([9](#chapter1-9)) It turns out, though, that
    the persistent updater, named *iWebUpdate*, won’t execute its core logic unless
    it’s invoked with the correct arguments (such as update, along with C= and then
    a client identifier).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，提取进程的参数可以帮助你在判断进程可疑并需要进一步分析时。例如，在2023年初，我发现了一款与广泛传播的Genieo恶意软件家族有关的恶意更新程序，这个程序已经未被发现近五年。^([9](#chapter1-9))
    然而，事实证明，这个名为*iWebUpdate*的持续更新程序，除非用正确的参数调用（例如更新以及C=和客户端标识符），否则不会执行其核心逻辑。
- en: This means that if you’re attempting to analyze the *iWebUpdate* binary in a
    debugger and execute it without the expected arguments, it will simply exit. While
    static analysis methods such as reverse engineering could reveal these required
    arguments, it’s far simpler to extract them from the persistently running updater
    process on an infected system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你尝试在调试器中分析 *iWebUpdate* 二进制文件并执行它而没有预期的参数，它将直接退出。虽然静态分析方法如逆向工程可以揭示这些必需的参数，但从受感染系统上持续运行的更新进程中提取它们要简单得多。
- en: So, how do you retrieve the arguments of an arbitrary process? One way is via
    the sysctl API invoked with KERN_PROCARGS2. The *enumerateProcesses* project takes
    this approach in the aptly named getArguments function. Given an arbitrary process
    ID, this function will extract and return its arguments. The function is rather
    involved, so I’ll break it into sections, starting with the calls to the sysctl
    API ([Listing 1-7](chapter1.xhtml#Lis1-7)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何提取一个任意进程的参数呢？一种方法是通过调用带有 KERN_PROCARGS2 的 sysctl API。*enumerateProcesses*
    项目在名为 getArguments 的函数中采用了这种方法。给定一个任意的进程ID，这个函数将提取并返回该进程的参数。这个函数相当复杂，因此我将它分成几个部分来讲解，首先是对
    sysctl API 的调用（[Listing 1-7](chapter1.xhtml#Lis1-7)）。
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 1-7: Allocating a buffer for process arguments'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 1-7: 为进程参数分配缓冲区'
- en: This API requires an output buffer to hold the process arguments, so we first
    invoke it with KERN_ARGMAX to determine their maximum size ❶. Here, we specify
    this information in a management information base (MIB) array, whose number of
    elements are also passed as an argument to sysctl. Then we allocate a buffer of
    the correct size ❷.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API需要一个输出缓冲区来保存进程参数，因此我们首先通过调用 KERN_ARGMAX 来确定它们的最大大小 ❶。在这里，我们将这些信息指定在一个管理信息基础（MIB）数组中，数组的元素数量也作为参数传递给
    sysctl。然后我们分配一个正确大小的缓冲区 ❷。
- en: With the buffer allocated, we can now reinvoke the sysctl API. First, though,
    we reinitialize the MIB array with values such as KERN_PROCARGS2 and the ID of
    the process whose arguments we’re interested in obtaining ([Listing 1-8](chapter1.xhtml#Lis1-8)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 分配了缓冲区后，我们现在可以重新调用sysctl API。但首先，我们需要使用诸如 KERN_PROCARGS2 和我们想要获取其参数的进程ID等值重新初始化MIB数组（[示例
    1-8](chapter1.xhtml#Lis1-8)）。
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 1-8: Retrieving a process’s arguments'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-8：获取进程的参数
- en: After this call, the buffer will contain the process arguments, among other
    things. [Table 1-1](chapter1.xhtml#tab1-1) describes the structure of the buffer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调用之后，缓冲区将包含进程参数等信息。[表格 1-1](chapter1.xhtml#tab1-1)描述了该缓冲区的结构。
- en: 'Table 1-1: The Format of a KERN_PROCARGS2 Buffer'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1-1：KER_PROCARGS2 缓冲区的格式
- en: '| Number of arguments | Process path | Arguments |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 参数数量 | 进程路径 | 参数 |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| int argc | <full path of process> | char* argv[0], argv[1], and so on |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| int argc | <进程的完整路径> | char* argv[0], argv[1]，依此类推 |'
- en: First, we can extract the number of arguments (traditionally called argc). You
    can skip over the process path to get to the beginning of the arguments (traditionally
    called argv), unless you have been unable to obtain the process path in another
    way. Each argument is NULL terminated, making extraction straightforward. The
    code in [Listing 1-9](chapter1.xhtml#Lis1-9) shows how to do this by saving each
    argument as a string object in an array. Note that the arguments variable is the
    now-populated buffer passed to the sysctl API in [Listing 1-9](chapter1.xhtml#Lis1-9).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以提取参数的数量（通常称为argc）。你可以跳过进程路径，直接进入参数的开始位置（通常称为argv），除非你以其他方式无法获得进程路径。每个参数都是NULL终止的，这使得提取过程非常直接。[示例
    1-9](chapter1.xhtml#Lis1-9)中的代码展示了如何将每个参数作为字符串对象保存到数组中。注意，参数变量是现在已经填充的缓冲区，该缓冲区传递给了[sysctl
    API](chapter1.xhtml#Lis1-9)。
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 1-9: Parsing process arguments'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-9：解析进程参数
- en: The code first extracts the number of arguments (found at the start of the argument’s
    buffer) ❶. Then it skips over this value ❷, the bytes of the path ❸, and any trailing
    NULL bytes ❹. Now the parser pointer is at the start of the actual arguments (argv),
    which the code extracts one by one ❺. It’s worth noting that the first argument,
    argv[0], will always be the program path unless the process has surreptitiously
    modified itself.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先提取参数的数量（位于参数缓冲区的开始位置）❶。然后跳过这个值❷、路径的字节❸以及任何后续的NULL字节❹。现在，解析器指针指向实际参数（argv）的起始位置，代码将逐一提取这些参数❺。值得注意的是，除非进程偷偷修改了自身，argv[0]始终是程序路径。
- en: 'If we execute the *enumerateProcesses* project, it should display the following
    information when it encounters the aforementioned xmr-stak process (shown here
    with a process ID of 14026), which surreptitiously mines cryptocurrency if an
    unsuspecting user has launched *CalendarFree.app*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行*enumerateProcesses*项目，当遇到前述的xmr-stak进程（此处显示其进程ID为14026）时，它应该显示以下信息。如果一个毫无察觉的用户启动了*CalendarFree.app*，该进程会偷偷进行加密货币挖矿：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It’s rather unusual for a process to be launched with such extensive arguments.
    Additionally, these arguments clearly allude to the fact that the process is a
    cryptocurrency miner. We can bolster this conclusion with the fact that its parent,
    *CalendarFree.app*, consumes massive amounts of CPU power, as you’ll see later
    in this chapter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 进程启动时带有如此大量的参数是相当不寻常的。此外，这些参数明显暗示该进程是一个加密货币矿工。我们可以通过以下事实进一步加强这个结论：其父进程*CalendarFree.app*消耗了大量的CPU资源，稍后你将在本章看到这一点。
- en: Process Hierarchies
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程层级
- en: '*Process hierarchies* are the relationships between processes (for example,
    between a parent and its children). When detecting malware, you’ll need an accurate
    representation of these relationships for several reasons. First, process hierarchies
    can help you detect initial infections. Process hierarchies can also reveal difficult-to-detect
    malware that is leveraging system binaries in a nefarious manner.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程层级*是进程之间的关系（例如，父进程与子进程之间）。在检测恶意软件时，你需要准确地表示这些关系，原因有几个。首先，进程层级可以帮助你检测初始感染。进程层级还可以揭示那些难以检测的恶意软件，它们以不正当的方式利用系统二进制文件。'
- en: 'Let’s look at an example. In 2019, the Lazarus advanced persistent threat (APT)
    group was observed using macro-laden Office documents to target macOS users. If
    a user opened the document and allowed the macros to run, the code would download
    and execute malware known as Yort. Here is a snippet of the macro used in the
    attack:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。2019年，Lazarus 高级持续威胁（APT）组织被发现利用含有宏的 Office 文档攻击 macOS 用户。如果用户打开该文档并允许宏运行，代码将下载并执行名为
    Yort 的恶意软件。以下是该攻击中使用的宏的代码片段：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As the macro code isn’t obfuscated, it is easy to understand. After downloading
    a file from *https://<wbr>nzssdm<wbr>.com<wbr>/assets<wbr>/mt<wbr>.dat* to the
    */tmp* directory via curl ❶, it sets permissions to executable ❷ and then executes
    the downloaded file, *mt.dat* ❸. [Figure 1-2](chapter1.xhtml#fig1-2) illustrates
    this attack from the perspective of a process hierarchy.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于宏代码没有被混淆，因此很容易理解。它首先通过 curl ❶ 从 *https://<wbr>nzssdm<wbr>.com<wbr>/assets<wbr>/mt<wbr>.dat*
    下载一个文件到 */tmp* 目录，然后设置文件的执行权限 ❷，接着执行下载的文件 *mt.dat* ❸。[图 1-2](chapter1.xhtml#fig1-2)
    从进程层级的角度说明了这次攻击。
- en: '![](../images/Figure1-2.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure1-2.jpg)'
- en: 'Figure 1-2: A simplified process hierarchy of a Lazarus group attack'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：Lazarus 组攻击的简化进程层级
- en: Although this diagram is slightly simplified (omitting forks and using symbolic
    values for process IDs), it accurately depicts the fact that curl, chmod, and
    the malware all appear as child processes of Microsoft Word. Do Word documents
    normally spawn curl to download and launch binaries? Of course not! Even if you
    can’t tell what exactly these child processes are doing, the fact that an Office
    document spawns them is a clear indicator of an attack. Moreover, without a process
    hierarchy, detecting this aspect of the infection would be relatively difficult,
    as curl and chmod are legitimate system binaries.^([10](#chapter1-10))
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该图略显简化（省略了分叉并使用了进程ID的符号值），但它准确地描述了 curl、chmod 和恶意软件作为 Microsoft Word 的子进程的事实。Word
    文档通常会启动 curl 来下载并启动二进制文件吗？当然不会！即使你无法确切知道这些子进程在做什么，但 Office 文档启动它们这一事实是攻击的明显标志。而且，没有进程层级结构，检测到这种感染的这一方面将相对困难，因为
    curl 和 chmod 都是合法的系统二进制文件。^([10](#chapter1-10))
- en: Finding the Parent
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找父进程
- en: 'Process hierarchies are built from the child up, through the parent, grandparent,
    and so on. At face value, we can easily generate a hierarchy for a given process
    via the e_ppid member of its kp_eproc structure, found in the kinfo_proc structure.
    These structures, found in *sys/sysctl.h*, are shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 进程层级是从子进程向上构建的，通过父进程、祖父进程等。表面上看，我们可以通过其 kp_eproc 结构中的 e_ppid 成员轻松生成一个给定进程的层级，这个结构可以在
    kinfo_proc 结构中找到。以下是这些结构，它们位于 *sys/sysctl.h* 中：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The e_ppid is the parent process ID, and we can extract it via the sysctl API,
    as in the getParent function in the *enumerateProcesses* project ([Listing 1-10](chapter1.xhtml#Lis1-10)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: e_ppid 是父进程ID，我们可以通过 sysctl API 提取它，如 *enumerateProcesses* 项目中的 getParent 函数所示（[列表
    1-10](chapter1.xhtml#Lis1-10)）。
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 1-10: Extracting a parent’s process ID'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-10：提取父进程的进程ID
- en: The code first initializes various arguments, including an array with values
    that instruct the system to return information about a specified process. The
    sysctl API will fulfill this request, returning a populated kinfo_proc structure.
    We then extract the process’s parent ID from it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先初始化各种参数，包括一个数组，数组中的值指示系统返回有关指定进程的信息。sysctl API 会响应这个请求，返回一个已填充的 kinfo_proc
    结构。然后我们从中提取进程的父进程ID。
- en: 'Here is the output from *enumerateProcesses* when it encounters the instance
    of curl spawned by a malicious document:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 *enumerateProcesses* 在遇到由恶意文档启动的 curl 实例时的输出：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code was readily able to identify the parent process as Microsoft Word.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码能够轻松识别父进程为 Microsoft Word。
- en: 'Unfortunately, the process hierarchies built using this e_ppid value often
    aren’t this useful because the value often reports a parent process ID of 1, which
    maps to *launchd*, the process tasked with starting each and every process. To
    observe this behavior, launch an application such as Calculator via Spotlight,
    Finder, or the Dock. Then use the ps utility with the ppid command line, passing
    it the process’s ID. You should see that its parent ID (PPID) is, in fact, 1:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用这个 e_ppid 值构建的进程层级通常并不那么有用，因为该值通常报告父进程ID为 1，这对应于 *launchd*，负责启动每个进程的进程。为了观察这一行为，可以通过
    Spotlight、Finder 或 Dock 启动像计算器这样的应用程序。然后使用 ps 工具并结合 ppid 命令行，将进程ID传递给它。你应该看到它的父进程ID（PPID）实际上是
    1：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The *enumerateProcesses* utility reports the same rather unhelpful information:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*enumerateProcesses*工具报告了相同的、并不特别有用的信息：'
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although *launchd* technically is the parent, it doesn’t give us the information
    we need to detect malicious activity. We’re more interested in the process *responsible*
    for starting the child.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然*launchd*技术上是父进程，但它并没有提供我们需要的信息来检测恶意活动。我们更关心的是负责启动子进程的进程。
- en: Returning the Process Responsible for Spawning Another
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回负责生成另一个进程的进程
- en: To return the process responsible for spawning another process, we can leverage
    a private Apple API, responsibility_get_pid_responsible_for_pid. It takes a process
    ID and returns the parent it deems responsible for the child. Though the internals
    of this private API are beyond the scope of this discussion, it essentially queries
    the kernel, which maintains a record of the responsible parent within an internal
    process structure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了返回负责生成另一个进程的进程，我们可以利用一个私有的Apple API，responsibility_get_pid_responsible_for_pid。它接受一个进程ID并返回它认为对子进程负责的父进程。尽管这个私有API的内部实现超出了本讨论的范围，但它本质上是查询内核，内核在内部进程结构中维护着负责父进程的记录。
- en: As it’s not a public API, we must dynamically resolve it using the dlsym API.
    [Listing 1-11](chapter1.xhtml#Lis1-11), from the getResponsibleParent function
    in the *enumerateProcesses* project, shows the code that implements this task.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不是一个公开API，我们必须通过dlsym API动态解析它。[清单 1-11](chapter1.xhtml#Lis1-11)，来自*enumerateProcesses*项目中的getResponsibleParent函数，展示了实现这一任务的代码。
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 1-11: Dynamically resolving a private function'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-11：动态解析私有函数
- en: This code resolves the function by name, storing the result into a function
    pointer named getRPID. Because this function takes a pid_t as its only argument
    and returns the responsible process ID as a pid_t as well, you can see the function
    pointer declared as pid_t (*getRPID)(pid_t pid).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过名称解析函数，并将结果存储在一个名为getRPID的函数指针中。因为这个函数只接受一个pid_t类型的参数，并且返回一个pid_t类型的负责进程ID，所以你可以看到该函数指针被声明为pid_t
    (*getRPID)(pid_t pid)。
- en: After checking to make sure the function was indeed found, we can invoke it
    via the function pointer, as shown in [Listing 1-12](chapter1.xhtml#Lis1-12).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查确认确实找到了函数后，我们可以通过函数指针调用它，如[清单 1-12](chapter1.xhtml#Lis1-12)所示。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 1-12: Invoking a resolved function'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-12：调用已解析的函数
- en: 'Now, when *enumerateProcesses* encounters a child process, such as one of Safari’s
    XPC Web Content renders (shown as *Safari Web Content* or *com.apple.WebKit.WebContent*),
    the code in *enumerateProcesses* looks up both the parent and the responsible
    process:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当*enumerateProcesses*遇到子进程时，例如Safari的XPC Web内容渲染器（显示为*Safari Web Content*或*com.apple.WebKit.WebContent*），*enumerateProcesses*中的代码会查找父进程和负责进程：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It accomplishes the former by checking the process’s e_ppid and the latter by
    calling the responsibility_get_pid_responsible_for_pid API. In this case, the
    responsible process provides more context and so is more valuable for building
    accurate process hierarchies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过检查进程的e_ppid来完成前者，通过调用responsibility_get_pid_responsible_for_pid API来完成后者。在这种情况下，负责的进程提供了更多的上下文，因此在构建准确的进程层级时更有价值。
- en: 'Unfortunately, for user-launched applications (which could include malware),
    this responsible parent may simply be the process itself. To see this, launch
    the Calculator application by double-clicking its application icon in Finder.
    Then run *enumerateProcesses* once again:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于用户启动的应用程序（这可能包括恶意软件），这个负责父进程可能只是进程本身。要查看这一点，只需通过在Finder中双击其应用程序图标来启动计算器应用程序。然后再次运行*enumerateProcesses*：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Rather unhelpfully, the utility identifies the responsible parent as Calculator
    itself. Luckily, there is one more place we can look for this information, though
    we must step back in time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具并没有提供太有用的信息，它将负责父进程标识为计算器本身。幸运的是，还有一个地方可以找到这些信息，不过我们必须回溯到过去。
- en: Retrieving Information with Application Services APIs
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用应用服务API检索信息
- en: Although officially deprecated, Apple’s Application Services APIs function on
    the latest versions of macOS, and various Apple daemons still use them. The ProcessInformationCopyDictionary
    Application Services API returns a dictionary containing a host of information,
    including a process’s true parent.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管官方已废弃，Apple的应用服务API在最新版本的macOS中仍然有效，并且各种Apple守护进程仍在使用它们。ProcessInformationCopyDictionary应用服务API返回一个字典，其中包含大量信息，包括进程的真实父进程。
- en: Rather than taking a process ID as an argument, this API takes a process serial
    number (psn). Process serial numbers are a predecessor to the more familiar process
    IDs. The process serial type is ProcessSerialNumber, which is defined in *include/MacTypes.h*.
    To retrieve a process serial number from a given process ID, use the GetProcessForPID
    function, as shown in [Listing 1-13](chapter1.xhtml#Lis1-13).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 并不是以进程 ID 作为参数，而是以进程序列号（psn）作为参数。进程序列号是进程 ID 的前身。进程序列类型是 ProcessSerialNumber，在
    *include/MacTypes.h* 中定义。要从给定的进程 ID 获取进程序列号，可以使用 GetProcessForPID 函数，参见[列表 1-13](chapter1.xhtml#Lis1-13)。
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 1-13: Retrieving a process’s serial number'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-13：检索进程的序列号
- en: The function takes a process ID and an out pointer to a ProcessSerialNumber,
    which it populates with the process’s serial number.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个进程 ID 和一个指向 ProcessSerialNumber 的输出指针，函数会将进程的序列号填充到该指针中。
- en: You can find the logic to retrieve a parent ID via a serial number in a function
    named getASParent in the *enumerateProcesses* project. [Listing 1-14](chapter1.xhtml#Lis1-14)
    contains a snippet of this function, which also shows it invoking the ProcessInformationCopyDictionary
    function to obtain information about the specified process.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *enumerateProcesses* 项目中的名为 getASParent 的函数里找到通过序列号获取父进程 ID 的逻辑。[列表 1-14](chapter1.xhtml#Lis1-14)
    包含了这个函数的代码片段，展示了它如何调用 ProcessInformationCopyDictionary 函数以获取指定进程的信息。
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 1-14: Obtaining a process’s information dictionary'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-14：获取进程信息字典
- en: One thing to keep in mind is that older APIs that return CoreFoundation objects
    do not use automatic reference counting (ARC). This means that you have to explicitly
    instruct the runtime on how to manage objects to avoid memory leaks. Here, this
    means that the returned process information dictionary from the call to ProcessInformationCopyDictionary
    must be either explicitly released via a call to CFRelease or bridged into an
    NSDictionary object and released into ARC via a call to CFBridgingRelease. The
    code opts for the latter option, as working with NS* objects is easier than working
    with the older CF* objects and avoids having to explicitly free the memory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，返回 CoreFoundation 对象的旧版 API 不使用自动引用计数（ARC）。这意味着必须明确指示运行时如何管理对象，以避免内存泄漏。在这里，这意味着从
    ProcessInformationCopyDictionary 调用返回的进程信息字典必须显式释放，通过调用 CFRelease 进行释放，或者桥接到 NSDictionary
    对象并通过调用 CFBridgingRelease 释放到 ARC 中。代码选择了后者，因为与 NS* 对象打交道比与旧版 CF* 对象打交道更为简便，且避免了显式释放内存的麻烦。
- en: After we’ve bridged the CFDictionaryRef dictionary into an NSDictionary object,
    we can directly access its key-value pairs, including the process’s parent. The
    parent’s process serial number is found in the ParentPSN key. As its type is kCFNumberLongLong
    (long long), you must reconstruct the process serial number manually ([Listing
    1-15](chapter1.xhtml#Lis1-15)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 CFDictionaryRef 字典桥接成 NSDictionary 对象后，就可以直接访问其键值对，包括进程的父进程。父进程的进程序列号存储在
    ParentPSN 键中。由于其类型为 kCFNumberLongLong（long long），因此必须手动重建进程序列号（参见[列表 1-15](chapter1.xhtml#Lis1-15)）。
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 1-15: Reconstructing a parent’s process serial number'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-15：重建父进程序列号
- en: Once we have the parent’s process serial number, we can retrieve details about
    it by reinvoking the ProcessInformationCopyDictionary API (this time, of course,
    with the parent’s process serial number). This provides us with its process ID,
    path, name, and more. Here, we’re most interested in a process ID, which we can
    find within a key named pid.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了父进程的进程序列号，就可以通过重新调用 ProcessInformationCopyDictionary API 获取关于父进程的详细信息（这一次，当然是用父进程的进程序列号）。这样可以得到其进程
    ID、路径、名称等信息。在这里，我们最关注的是进程 ID，可以在名为 pid 的键中找到。
- en: It’s worth noting that obtaining a process serial number will fail for system
    or background processes. Production code should account for this case by, for
    example, checking the return value of GetProcessForPID or seeing whether the ParentPSN
    key is nonexistent or contains a value of zero. Additionally, Application Services
    APIs should not be invoked from background processes, such as daemons or system
    extensions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，获取进程序列号对于系统进程或后台进程来说会失败。生产代码应当考虑这种情况，例如，检查 GetProcessForPID 的返回值，或者检查
    ParentPSN 键是否不存在或其值是否为零。此外，应用程序服务 API 不应从后台进程（如守护进程或系统扩展）中调用。
- en: 'Recall that when we launched Calculator, the previously discussed methods failed
    to ascertain its true parent (instead returning *launchd* or itself). How does
    the Application Services APIs’ approach fare? First, let’s return to the instance
    of Calculator launched via Finder:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当我们启动计算器时，之前讨论的方法未能确定其真正的父进程（而是返回了*launchd*或其自身）。那么，应用程序服务API的方法效果如何呢？首先，让我们回到通过Finder启动的计算器实例：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Success! The code now correctly identifies Finder as the process that instigated
    the Calculator app’s launch. Similarly, if Calculator is launched via the Dock
    or Spotlight’s search bar, the code will be able to identify each of these as
    well.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！现在代码能够正确识别Finder是启动计算器应用程序的进程。同样，如果通过Dock或Spotlight搜索栏启动计算器，代码也能识别这些方式。
- en: You might be wondering why this section discussed so many different methods
    of determining the most useful parent of a process. This is because none of the
    methods are foolproof, so you’ll often need to combine them. To start, using the
    Application Services APIs seems to produce the most relevant results. However,
    calls to GetProcessForPID can fail for certain processes. In this case, it’s wise
    to fall back on responsibility_get_pid_responsible_for_pid. But, as you saw, this
    can sometimes return a parent that is the process itself, which isn’t helpful.
    In that case, you may want to fall back on the good old e_ppid. And though that
    often just reports the parent as *launchd*, it works in many other cases. For
    example, in the Lazarus attack discussed earlier, it correctly identified Word
    as curl’s parent.^([11](#chapter1-11))
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇，为什么本节讨论了这么多不同的方法来确定进程最有用的父进程。这是因为没有一种方法是万无一失的，所以你通常需要将它们结合起来使用。首先，使用应用程序服务API似乎能产生最相关的结果。然而，对GetProcessForPID的调用可能会在某些进程中失败。在这种情况下，明智的做法是回退到responsibility_get_pid_responsible_for_pid。但正如你所见，这有时会返回进程本身作为父进程，这并没有什么帮助。在这种情况下，你可能会想回退到经典的e_ppid。虽然它通常只会报告父进程是*launchd*，但在很多其他情况下它也有效。例如，在之前讨论的Lazarus攻击中，它正确地将Word识别为curl的父进程。^([11](#chapter1-11))
- en: Environment Information
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境信息
- en: 'Now that you know how to generate a true process tree, let’s look at how to
    gather information about a process’s environment. You may be familiar with one
    way to do this: using the launchctl utility, which has a procinfo command line
    option that returns a process’s arguments, code signing information, runtime environment,
    and more. Though earlier we discussed other methods for gathering some of this
    information, launchctl can provide an additional source and includes information
    unavailable through other methods.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何生成真实的进程树了，让我们看看如何收集关于进程环境的信息。你可能熟悉一种方法：使用launchctl工具，它有一个procinfo命令行选项，可以返回进程的参数、代码签名信息、运行时环境等。虽然我们之前讨论过其他收集这些信息的方法，但launchctl可以提供一个额外的来源，并且包括其他方法无法提供的信息。
- en: Unfortunately, launchctl is not open source, nor are its internals documented.
    In this section, we reverse engineer the procinfo option and reimplement its logic
    in our own tools to retrieve information about any process. You’ll find this open
    source implementation in this chapter’s *procInfo* project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，launchctl并不是开源的，它的内部机制也没有文档化。在本节中，我们通过逆向工程procinfo选项，并在我们自己的工具中重新实现其逻辑，以获取任何进程的信息。你可以在本章的*procInfo*项目中找到这个开源实现。
- en: '> NOTE'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注意'
- en: '*The code in this section was inspired by research from Jonathan Levin.*^([12](#chapter1-12))
    *I’ve updated his approach for newer versions of macOS.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*本节中的代码灵感来源于Jonathan Levin的研究。*^([12](#chapter1-12)) *我已根据macOS的新版更新了他的方案。*'
- en: 'Before we walk through the code found in the *procInfo* project, let’s summarize
    the approach: we have to make a call to the launchd bootstrap pipe using the private
    xpc_pipe_interface_routine function. Invoking this function with ROUTINE_DUMP_PROCESS
    (0x2c4) and an XPC dictionary containing both the process ID of the target process
    and a shared-memory out buffer will return the process information you seek. The
    code first declares several variables needed to make the XPC query ([Listing 1-16](chapter1.xhtml#Lis1-16)).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究*procInfo*项目中的代码之前，让我们先总结一下这个方法：我们必须使用私有的xpc_pipe_interface_routine函数调用launchd引导管道。通过ROUTINE_DUMP_PROCESS
    (0x2c4)以及一个包含目标进程的进程ID和共享内存输出缓冲区的XPC字典调用此函数，将返回你所需的进程信息。代码首先声明了几个需要用来发出XPC查询的变量（[列表1-16](chapter1.xhtml#Lis1-16)）。
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 1-16: Declaring required variables'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-16：声明所需变量
- en: These variables include, among others, a function pointer (which will later
    hold the address of the private xpc_pipe_interface_routine) ❶, a pointer to a
    global XPC data structure ❷, and a length extracted from reversing launchctl ❸.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量包括但不限于：一个函数指针（稍后将保存私有的xpc_pipe_interface_routine地址）❶、一个指向全局XPC数据结构的指针❷，以及通过逆向launchctl提取的长度❸。
- en: We then create a shared memory object via a call to the xpc_shmem_create API.
    The XPC call will populate this with information about the target process we’re
    querying ([Listing 1-17](chapter1.xhtml#Lis1-17)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用xpc_shmem_create API创建一个共享内存对象。XPC调用将填充此对象，包含我们正在查询的目标进程的信息（见[列表 1-17](chapter1.xhtml#Lis1-17)）。
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 1-17: Creating a shared memory object'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-17：创建共享内存对象
- en: Next, we create and initialize an XPC dictionary. This dictionary must contain
    the ID of the process we’re querying, as well as the shared memory object we’ve
    just created ([Listing 1-18](chapter1.xhtml#Lis1-18)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建并初始化一个XPC字典。此字典必须包含我们正在查询的进程的ID，以及我们刚刚创建的共享内存对象（见[列表 1-18](chapter1.xhtml#Lis1-18)）。
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 1-18: Initializing an XPC request dictionary'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-18：初始化XPC请求字典
- en: The code then retrieves a global data object of type xpc_global_data* from the
    os_alloc_once_table array ([Listing 1-19](chapter1.xhtml#Lis1-19)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码从os_alloc_once_table数组中检索类型为xpc_global_data*的全局数据对象（见[列表 1-19](chapter1.xhtml#Lis1-19)）。
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 1-19: Extracting global data'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-19：提取全局数据
- en: This object contains an XPC pipe (xpc_bootstrap_pipe) that is required for calls
    to the xpc_pipe_interface_routine function. Because this function is private,
    we must dynamically resolve it from the *libxpc* library ([Listing 1-20](chapter1.xhtml#Lis1-20)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象包含一个XPC管道（xpc_bootstrap_pipe），这是调用xpc_pipe_interface_routine函数所必需的。由于这个函数是私有的，我们必须从*libxpc*库动态解析它（见[列表
    1-20](chapter1.xhtml#Lis1-20)）。
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 1-20: Resolving a function pointer'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-20：解析函数指针
- en: Finally, we’re prepared to make the XPC request. As noted, we use the xpc_pipe_interface_routine
    function, which takes arguments such as the XPC bootstrap pipe, a routine (such
    as ROUTINE_DUMP_PROCESS), and a request dictionary containing specific routine
    information such as a process ID and a shared memory buffer for the routine’s
    output ([Listing 1-21](chapter1.xhtml#Lis1-21)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备进行XPC请求。如前所述，我们使用xpc_pipe_interface_routine函数，该函数接受诸如XPC引导管道、例程（如ROUTINE_DUMP_PROCESS）和包含特定例程信息（如进程ID和例程输出的共享内存缓冲区）的请求字典等参数（见[列表
    1-21](chapter1.xhtml#Lis1-21)）。
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 1-21: Requesting process information via XPC'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-21：通过XPC请求进程信息
- en: If this request succeeds, meaning the result is zero and the response dictionary
    passed into xpc_pipe_interface_routine does not contain the key error, then the
    response dictionary will contain a key-value pair with the key bytes -written.
    Its value is the number of bytes written to the allocated buffer we’ve added to
    the shared memory object. We extract this value in [Listing 1-22](chapter1.xhtml#Lis1-22).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此请求成功，即结果为零且传递给xpc_pipe_interface_routine的响应字典中不包含错误键，那么响应字典将包含一个键值对，键为bytes-written，其值为写入我们添加到共享内存对象中的分配缓冲区的字节数。我们将在[列表
    1-22](chapter1.xhtml#Lis1-22)中提取这个值。
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 1-22: Extracting the size of the response data'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-22：提取响应数据的大小
- en: Now we can directly access the buffer, for example, to create a string object
    containing the entirety of the target process’s information ([Listing 1-23](chapter1.xhtml#Lis1-23)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以直接访问缓冲区，例如，创建一个包含目标进程所有信息的字符串对象（见[列表 1-23](chapter1.xhtml#Lis1-23)）。
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 1-23: Converting process information into a string object'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-23：将进程信息转换为字符串对象
- en: Although we’ve converted this information into a string object, it’s all lumped
    together, so we’ll still have to manually parse relevant pieces. This process
    isn’t covered here, but you can consult the *procInfo* project, which extracts
    the data into a dictionary of key-value pairs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已将这些信息转换为字符串对象，但它们都被集中在一起，因此我们仍然需要手动解析相关部分。这个过程在这里没有覆盖，但你可以参考*procInfo*项目，它将数据提取到一个键值对的字典中。
- en: 'The information returned from *launchd* contains a myriad of useful details!
    To illustrate this, run *procInfo* against DazzleSpy’s persistent component, which
    is installed as *~/.local/softwareupdate* and, in this instance, is running with
    a process ID of 16776:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从*launchd*返回的信息包含了大量有用的细节！为了说明这一点，运行*procInfo*以获取 DazzleSpy 的持久组件，该组件安装在*~/.local/softwareupdate*目录下，并且此实例中正以进程
    ID 16776 运行：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This process information, gathered via a single XPC call, can confirm knowledge
    obtained from other sources and provide new details. For example, if you query
    a launch agent or daemon such as DazzleSpy, the path key in the process information
    response will contain the property list responsible for spawning the item:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单一的 XPC 调用收集的这些进程信息，可以确认从其他来源获得的知识并提供新的细节。例如，如果你查询像 DazzleSpy 这样的启动代理或守护进程，进程信息响应中的路径键将包含负责生成该项的属性列表：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can confirm this fact by manually examining the reported property list (which,
    for DazzleSpy, was *com.apple.softwareupdate.plist*) and noting that the path
    specified does indeed point back to the malware’s binary:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过手动检查报告的属性列表（对于 DazzleSpy，它是 *com.apple.softwareupdate.plist*）来确认这一事实，并注意到指定的路径确实指向了恶意软件的二进制文件：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Having a means of tracing a process ID back to the launch item property list
    that triggered its spawning is quite useful. Why? Well, to achieve persistence,
    the majority of malware installs itself as a launch item. Though legitimate software
    also persists in this manner, these launch items are all worth examining, as you
    have a good chance of finding any persistently installed malware among them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪进程 ID 回到触发其生成的启动项属性列表是非常有用的。为什么？嗯，为了实现持久性，大多数恶意软件会将自己安装为启动项。尽管合法软件也会以这种方式持久化，但所有这些启动项都值得检查，因为你有很大的机会在其中发现任何持久安装的恶意软件。
- en: Code Signing
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码签名
- en: In a nutshell, *code signing* can prove who created an item and verify that
    it hasn’t been tampered with. Any detection algorithm attempting to classify a
    running process as malicious or benign should thus extract this code signing information.
    You should closely examine unsigned processes and those signed in an ad hoc manner,
    because these days, the vast majority of legitimate programs you’ll find running
    on macOS are both signed and notarized.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*代码签名*可以证明某个项是谁创建的，并验证它没有被篡改。因此，任何试图将正在运行的进程分类为恶意或良性的检测算法都应提取这些代码签名信息。你应该密切检查未签名的进程以及那些临时签名的进程，因为如今，你在
    macOS 上运行的大多数合法程序都已经签名并经过公证。
- en: Speaking of validly signed processes, those belonging to well-known software
    developers are most likely benign (supply chain attacks aside). Moreover, if Apple
    proper has signed a process, it won’t be malware (although, as we’ve seen, malware
    could leverage Apple binaries to perform malicious actions, as in the case of
    the Lazarus group’s use of curl to download additional malicious payloads).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 说到有效签名的进程，那些属于知名软件开发商的进程很可能是良性的（供应链攻击除外）。此外，如果是 Apple 正式签署的进程，它就不会是恶意软件（尽管正如我们所见，恶意软件可以利用
    Apple 的二进制文件执行恶意操作，就像 Lazarus 团伙使用 curl 下载额外恶意负载的情况一样）。
- en: Due to its importance, an entire chapter is dedicated solely to the topic of
    code signing. In [Chapter 3](chapter3.xhtml), we discuss the topic comprehensively,
    applying it to running processes as well as to items such as disk images and packages.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其重要性，整个章节专门讨论代码签名的话题。在[第3章](chapter3.xhtml)中，我们全面讨论了这一话题，应用于正在运行的进程以及磁盘镜像和软件包等项目。
- en: Loaded Libraries
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载的库
- en: When attempting to uncover malware by analyzing running processes, you must
    also enumerate any loaded libraries. Stealthy malware, such as ZuRu, doesn’t spawn
    a stand-alone process, but rather is loaded into a subverted, although otherwise
    legitimate, one. In this case, the process’s main executable binary will be benign,
    though modified to reference the malicious library to ensure it is loaded.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试通过分析正在运行的进程来揭示恶意软件时，你还必须枚举任何加载的库。像 ZuRu 这样的隐蔽恶意软件不会生成独立进程，而是被加载到一个被篡改的、但在其他方面仍然合法的进程中。在这种情况下，进程的主要可执行二进制文件是良性的，尽管被修改为引用恶意库以确保它被加载。
- en: 'Even if the malware does execute as a stand-alone process, you’ll still want
    to enumerate its loaded libraries for the following reasons:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使恶意软件作为独立进程执行，你仍然需要枚举它加载的库，原因如下：
- en: The malware may load additional malicious plug-ins, which you’ll likely want
    to scan or analyze.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件可能会加载额外的恶意插件，你很可能需要扫描或分析它们。
- en: The malware may load legitimate system libraries to perform subversive actions.
    These can provide insight into the malware’s capabilities (for example, it might
    load the system framework used to interface with the mic or webcam).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件可能会加载合法的系统库来执行颠覆性操作。这些可以提供恶意软件能力的洞察（例如，它可能会加载用于与麦克风或摄像头接口的系统框架）。
- en: Unfortunately, due to macOS security features, even signed, notarized third-party
    security tools cannot directly enumerate loaded libraries. Luckily, there are
    indirect ways to do so using built-in macOS utilities such as vmmap. This tool
    possesses several Apple-only entitlements that allow it to read the memory of
    remote processes and provide a mapping that includes any loaded libraries.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于macOS的安全功能，即使是签名过的、已公证的第三方安全工具也不能直接列举加载的库。幸运的是，我们可以通过使用macOS内置工具如vmmap以间接的方式做到这一点。这个工具具有几个仅限Apple的权限，使其能够读取远程进程的内存，并提供包括所有加载库的映射。
- en: 'Run vmmap against the aforementioned ZuRu, which trojanizes a copy of the popular
    iTerm(2) application. It’s a good example, as its malicious logic is implemented
    solely in a dynamic library named *libcrypto.2.dylib*. We’ll execute vmmap with
    the -w flag so that it prints out the full path of ZuRu’s mapped libraries. The
    tool expects a process ID, so we provide it with ZuRu’s (here, 932):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行vmmap针对前述的ZuRu，该程序是一个恶意版本的流行iTerm(2)应用。它是一个很好的示例，因为它的恶意逻辑完全由名为*libcrypto.2.dylib*的动态库实现。我们将使用`-w`标志执行vmmap，这样它就会打印出ZuRu映射的库的完整路径。该工具需要提供一个进程ID，因此我们提供了ZuRu的ID（在此为932）：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this abridged output, you can see mappings of the binary’s main image (iTerm2),
    as well as dynamic libraries such as the dynamic loader *dyld* and the malicious
    library *libcrypto.2.dylib*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段简化的输出中，你可以看到二进制文件的主映像（iTerm2），以及动态库，如动态加载器*dyld*和恶意库*libcrypto.2.dylib*的映射。
- en: 'How did I determine that *libcrypto.2.dylib* was the malicious component? After
    noticing that Jun Bi, rather than the legitimate developer, had signed this copy
    of iTerm2, I compared a list of its loaded libraries with a list of the libraries
    loaded by the original application. There was only one difference: *libcrypto.2.dylib*.
    Static analysis confirmed that this anomalous library was indeed malicious.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我是如何确定*libcrypto.2.dylib*是恶意组件的？在注意到是Jun Bi而非合法开发者签署了这个版本的iTerm2后，我将它加载的库列表与原始应用程序加载的库列表进行了对比。唯一的不同之处就是*libcrypto.2.dylib*。静态分析确认这个异常的库确实是恶意的。
- en: Because we don’t possess the private Apple entitlements needed to read remote
    process memory (which includes all loaded libraries), we’ll simply execute vmmap
    and parse its output. Several of my Objective-See tools, such as TaskExplorer,^([13](#chapter1-13))
    take this approach. You can also find code that implements this process in a function
    named getLibraries in the *enumerateProcesses* project.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有读取远程进程内存所需的Apple私有权限（包括所有加载的库），所以我们将简单地执行vmmap并解析其输出。我的一些Objective-See工具，如`TaskExplorer`，^([13](#chapter1-13))采用了这种方法。你还可以在名为`getLibraries`的函数中找到实现此过程的代码，该函数位于*enumerateProcesses*项目中。
- en: First, we need a helper function capable of executing an external binary and
    returning its output ([Listing 1-24](chapter1.xhtml#Lis1-24)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个能够执行外部二进制文件并返回其输出的辅助函数（[列表 1-24](chapter1.xhtml#Lis1-24)）。
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 1-24: Executing a task and capturing its output'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-24：执行任务并捕获其输出
- en: The execTask function executes a task using the specified parameters via Apple’s
    NSTask API. It waits until the spawned task has completed and returns a dictionary
    containing various key-value pairs, including any output the command generated,
    to stdout. To capture the task’s output, the code initializes a pipe object (NSPipe)
    ❶ and then sets it as the task’s standard output ❷. When the task generates output,
    the code reads off the pipe’s file handle ❸ and appends it to a data buffer. Once
    the task exits, any remaining output is read and the data buffer is saved into
    the results dictionary, which is returned to the caller ❹.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`execTask`函数通过苹果的NSTask API执行一个任务，使用指定的参数。它会等待直到子任务完成，并返回一个包含多个键值对的字典，其中包括任何由命令生成的输出（输出到标准输出）。为了捕获任务的输出，代码初始化一个管道对象（NSPipe）❶，然后将其设置为任务的标准输出❷。当任务生成输出时，代码从管道的文件句柄❸读取数据并将其附加到数据缓冲区中。一旦任务退出，任何剩余的输出都会被读取，数据缓冲区将被保存到结果字典中，并返回给调用者❹。'
- en: The function’s caller, for example, getLibraries, can invoke it with a path
    to any binary, along with any arguments. If needed, we can convert its output
    into a string object ([Listing 1-25](chapter1.xhtml#Lis1-25)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的调用者，例如 `getLibraries`，可以通过传递任何二进制文件的路径以及相关参数来调用它。如果需要，我们可以将其输出转换为字符串对象（[列表
    1-25](chapter1.xhtml#Lis1-25)）。
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 1-25: Converting task output into a string object'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-25：将任务输出转换为字符串对象
- en: We can then parse the vmmap output in many ways, such as line by line or via
    regular expressions. [Listing 1-26](chapter1.xhtml#Lis1-26) shows one technique.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过多种方式解析vmmap输出，例如逐行解析或使用正则表达式。[列表 1-26](chapter1.xhtml#Lis1-26)展示了一种技术。
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 1-26: Parsing the output lines that start with __TEXT'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-26：解析以__TEXT开头的输出行
- en: Here, we search for lines that start with __TEXT, as all dynamically loaded
    libraries in the vmmap output start with memory regions of this type. These lines
    of data also contain the full path of the loaded library, which is what we’re
    really after. [Listing 1-27](chapter1.xhtml#Lis1-27) extracts these paths within
    the for loop shown in [Listing 1-26](chapter1.xhtml#Lis1-26).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们搜索以__TEXT开头的行，因为所有在vmmap输出中动态加载的库都以这种类型的内存区域开头。这些数据行还包含已加载库的完整路径，这正是我们想要的。[列表
    1-27](chapter1.xhtml#Lis1-27) 在[列表 1-26](chapter1.xhtml#Lis1-26)中展示的for循环中提取这些路径。
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 1-27: Extracting the dynamic library’s path'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-27：提取动态库的路径
- en: The code first looks for the *copy-on-write* share mode ("SM=COW"), which precedes
    the path. If found, then, using the offset following the share mode, it extracts
    the path itself. At this point, the dylibs array should contain all dynamic libraries
    loaded by the target process.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先查找*写时复制*共享模式（"SM=COW"），它位于路径之前。如果找到了，接着利用共享模式后面的偏移量提取路径本身。此时，dylibs 数组应该包含目标进程加载的所有动态库。
- en: 'Now let’s execute *enumerateProcesses* while running the same instance of ZuRu
    we saw earlier:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在运行我们之前看到的ZuRu实例时执行*enumerateProcesses*：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, we’re able to extract all loaded libraries in ZuRu’s address
    space, including the malicious *libcrypto.2.dylib*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们能够提取出ZuRu地址空间中加载的所有库，包括恶意的*libcrypto.2.dylib*。
- en: Note that on recent versions of macOS, system frameworks (which are essentially
    a type of dynamically loaded library) have been moved into what is known as the
    *dyld_shared_cache*. However, vmmap will still report the frameworks’ original
    paths. This is a notable point for two main reasons. First, if you want to examine
    the framework’s code, you’ll have to extract it from the shared cache.^([14](#chapter1-14))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最新版本的macOS中，系统框架（本质上是一种动态加载的库）已经被移动到称为*dyld_shared_cache*的地方。然而，vmmap仍然会报告框架的原始路径。这个点值得注意，主要有两个原因。首先，如果你想检查框架的代码，你需要从共享缓存中提取它。^([14](#chapter1-14))
- en: Second, if you’ve implemented logic to detect self-deleting framework libraries,
    you should make an exception for these frameworks. Otherwise, your code will report
    that they’ve been deleted. One simple way to check if a given framework has been
    moved to the cache is to invoke Apple’s *_dyld _shared_cache_contains_path* API.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果你已经实现了检测自删除框架库的逻辑，那么你应该为这些框架库做出例外处理。否则，你的代码会报告它们已经被删除。检查某个框架是否已经被移动到缓存中的一种简单方法是调用苹果的*dyld_shared_cache_contains_path*
    API。
- en: Open Files
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开的文件
- en: 'Just as enumerating loaded libraries can provide insight into the capabilities
    of a process, so can enumerating any open files. This technique could help us
    identify malware known as ColdRoot, a RAT that affords a remote attacker complete
    control over an infected system.^([15](#chapter1-15)) If you list all files opened
    by each process on a system infected with this malware, you’ll encounter a strange
    file named *conx.wol* opened by a process named *com.apple.audio .driver.app*.
    Upon closer examination, it will become obvious that the process does not belong
    to Apple and is in fact malware (ColdRoot), *conx.wol* is the malware’s configuration
    file, and it contains valuable information to defenders, including the address
    of the command-and-control server:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如枚举已加载的库可以提供关于进程能力的洞察一样，枚举任何打开的文件也可以提供类似的帮助。这项技术可以帮助我们识别被称为ColdRoot的恶意软件，这是一种提供远程攻击者对受感染系统完全控制的RAT。^([15](#chapter1-15))
    如果你列出系统上每个进程打开的所有文件，你会发现有一个名为*conx.wol*的奇怪文件，它是由名为*com.apple.audio.driver.app*的进程打开的。仔细检查后，会发现该进程并非苹果的进程，实际上它是恶意软件（ColdRoot），*conx.wol*是该恶意软件的配置文件，并包含对防御者非常重要的信息，包括命令与控制服务器的地址：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Later on, you’ll encounter another file opened by the malware, *adobe_logs.log*,
    which appears to contain captured keystrokes, including a username and password
    for a bank account:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会遇到恶意软件打开的另一个文件，*adobe_logs.log*，它似乎包含捕获的按键信息，包括一个银行账户的用户名和密码：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You might be wondering how you can determine that these files are malicious
    using programmatic methods alone. Truthfully, this would be complicated. It would
    perhaps involve creating a regular expression to look for URLs, IP addresses,
    or what appear to be captured keypresses, such as control characters. However,
    it’s more likely that other detection logic will have already cast this unsigned
    packed malware as suspicious and flagged it for closer examination, ideally by
    a human malware analyst. ColdRoot, for example, is unsigned, packed, and persisted.
    In this case, the code could provide the analyst with both a list of any file
    opened by the suspicious process and the file contents. An analyst could then
    manually confirm that the flagged process was malware and use the files to gain
    a cursory understanding of how it works.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在想，如何仅通过编程方法来确定这些文件是否是恶意的。说实话，这会非常复杂。可能需要创建正则表达式来查找URL、IP地址，或者看起来像是捕获的按键，比如控制字符。然而，更有可能的是，其他检测逻辑已经将这个未签名的打包恶意软件标记为可疑，并将其标记为需要更仔细的检查，理想情况下由人工恶意软件分析师来检查。例如，ColdRoot就是未签名、打包并且持久化的。在这种情况下，代码可以为分析师提供任何由可疑进程打开的文件列表以及文件内容。然后，分析师可以手动确认标记的进程是否为恶意软件，并使用这些文件来初步了解它是如何工作的。
- en: In this section, we discuss two approaches to programmatically enumerating all
    files opened by a process.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们讨论两种通过编程方式枚举进程打开的所有文件的方法。
- en: proc_pidinfo
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: proc_pidinfo
- en: The traditional approach to enumerating the files a process currently has open
    involves the proc_pidinfo API. In short, invoking this API with the PROC_PIDLISTFDS
    flag will return a list of open file descriptors for a given process. Let’s walk
    through a code example that illustrates the use of this API. You can find the
    complete code in a function named getFiles in the *enumerateProcesses* project.
    We start by retrieving a process’s file descriptors ([Listing 1-28](chapter1.xhtml#Lis1-28)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的枚举进程当前打开的文件的方法涉及proc_pidinfo API。简而言之，调用这个API并使用PROC_PIDLISTFDS标志，将返回一个给定进程的打开文件描述符列表。让我们通过一个代码示例来演示如何使用这个API。你可以在*enumerateProcesses*项目中的一个名为getFiles的函数中找到完整的代码。我们首先通过获取进程的文件描述符（[列表
    1-28](chapter1.xhtml#Lis1-28)）开始。
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 1-28: Obtaining a list of a process’s file descriptors'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-28：获取进程文件描述符的列表
- en: The code invokes the proc_pidinfo API with a process ID for a target process,
    the PROC_PIDLISTFDS flag, and a series of zeros to obtain the size of memory needed
    to hold the process’s list of file descriptors ❶. We then allocate a buffer of
    this size to hold pointers of proc_fdinfo structures ❷. Then, to obtain the actual
    list of descriptors, we reinvoke the proc_pidinfo API, this time with the freshly
    allocated buffer and its size ❸.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用目标进程的进程ID、PROC_PIDLISTFDS标志和一系列零值调用proc_pidinfo API，以获取保存进程文件描述符列表所需的内存大小
    ❶。然后，我们分配一个足够大小的缓冲区来保存proc_fdinfo结构的指针 ❷。接着，为了获取实际的描述符列表，我们重新调用proc_pidinfo API，这次传入新分配的缓冲区及其大小
    ❸。
- en: Now that we have a list of open file descriptors, let’s examine each of them.
    Regular files should have descriptors of type PROX_FDTYPE_VNODE. [Listing 1-29](chapter1.xhtml#Lis1-29)
    retrieves the paths of these files.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了打开的文件描述符列表，接下来让我们检查它们。常规文件应具有PROX_FDTYPE_VNODE类型的描述符。[列表 1-29](chapter1.xhtml#Lis1-29)
    提取这些文件的路径。
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Listing 1-29: Extracting the paths from the file descriptors'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-29：从文件描述符中提取路径
- en: Using a for loop, we iterate over the retrieved file descriptors ❶. For each
    descriptor, we check whether it is of type PROX_FDTYPE_VNODE and skip all other
    types ❷. We then invoke the proc_pidfdinfo API with various parameters, such as
    the process ID, the file descriptor, and PROC_PIDFDVNODEPATHINFO, as well as an
    output structure of type vnode_fdinfowithpath and its size ❸. This should return
    information about the specified file descriptor, including its path. Once the
    call completes, we can find the path in the vip_path member of the pvip structure,
    within the vnode_fdinfowithpath structure. We extract the member, convert it into
    a string object, and save it into an array ❹.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for循环，我们遍历检索到的文件描述符 ❶。对于每个描述符，我们检查它是否为PROX_FDTYPE_VNODE类型，并跳过其他类型 ❷。然后，我们调用proc_pidfdinfo
    API，并传入各种参数，例如进程ID、文件描述符和PROC_PIDFDVNODEPATHINFO，以及一个类型为vnode_fdinfowithpath的输出结构及其大小
    ❸。这应该返回关于指定文件描述符的信息，包括它的路径。一旦调用完成，我们可以在vnode_fdinfowithpath结构中的vip_path成员找到路径。我们提取该成员，将其转换为字符串对象，并将其保存到数组中
    ❹。
- en: lsof
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: lsof
- en: Another way of enumerating open files for a process is to mimic macOS’s Activity
    Monitor utility. Though this approach relies on an external macOS executable,
    it often produces a more comprehensive list than the proc_pidinfo approach.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种列举进程打开的文件的方法是模仿 macOS 的 Activity Monitor 工具。虽然这种方法依赖于外部的 macOS 可执行文件，但它通常比
    proc_pidinfo 方法生成更全面的列表。
- en: After selecting a process in Activity Monitor, a user can click the information
    icon and then the Open Files and Ports tab to see all files the process has opened.
    By reverse engineering Activity Monitor, we can learn that it accomplishes this
    behavior behind the scenes by executing lsof, a built-in macOS tool for listing
    open files.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Activity Monitor 中选择一个进程后，用户可以点击信息图标，然后选择“打开文件和端口”标签，查看该进程打开的所有文件。通过逆向工程 Activity
    Monitor，我们可以了解到，它通过执行 lsof 来实现这一行为，lsof 是 macOS 内置的一个列出打开文件的工具。
- en: 'You can confirm that Activity Monitor uses lsof via a process monitor, a tool
    I’ll show you how to create in [Chapter 8](chapter8.xhtml). When a user clicks
    the Open Files and Ports tab, the process monitor will show lsof being executed
    with the command line flags -Fn and -p:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过进程监视器确认 Activity Monitor 使用了 lsof，这个工具我将在[第 8 章](chapter8.xhtml)中教您如何创建。当用户点击“打开文件和端口”标签时，进程监视器将显示执行
    lsof 的命令行标志 -Fn 和 -p：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The -p flag specifies the process’s ID, and the -F flag selects fields to be
    processed. When this flag is followed by n, the tool will print out just the file’s
    path, which is exactly what we want.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: -p 标志指定进程的 ID，而 -F 标志选择要处理的字段。当该标志后跟 n 时，工具只会打印出文件路径，这正是我们想要的。
- en: Let’s follow the approach taken by Activity Monitor and execute the lsof binary
    for a given process, then programmatically parse its output. You can find the
    complete code that implements this approach in a function named getFiles2 in the
    *enumerateProcesses* project. In [Listing 1-30](chapter1.xhtml#Lis1-30), we start
    by executing lsof with the -Fn and -p flags and a process ID.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照 Activity Monitor 的方法执行给定进程的 lsof 二进制文件，然后以编程方式解析其输出。您可以在 *enumerateProcesses*
    项目中找到实现此方法的完整代码，它位于名为 getFiles2 的函数中。在[示例 1-30](chapter1.xhtml#Lis1-30)中，我们首先使用
    -Fn 和 -p 标志以及进程 ID 来执行 lsof。
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 1-30: Programmatically executing lsof'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-30：以编程方式执行 lsof
- en: We reuse the execTask function created in [Listing 1-24](chapter1.xhtml#Lis1-24)
    to run the command. However, because command line arguments are passed to external
    processes as strings, we must first convert the target process ID to a string.
    Recall that the execTask function will wait until the spawned task has completed,
    capture any output, and return it to the caller. [Listing 1-31](chapter1.xhtml#Lis1-31)
    shows one approach to parsing lsof’s output.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用在[示例 1-24](chapter1.xhtml#Lis1-24)中创建的 execTask 函数来运行该命令。然而，由于命令行参数作为字符串传递给外部进程，我们必须首先将目标进程
    ID 转换为字符串。回想一下，execTask 函数会等待直到被启动的任务完成，捕获任何输出并返回给调用者。[示例 1-31](chapter1.xhtml#Lis1-31)展示了一种解析
    lsof 输出的方法。
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 1-31: Parsing output from lsof'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-31：解析 lsof 输出
- en: The output is stored in a dictionary named results, and you can access it via
    the key STDOUT ❶. You can split the output on newline characters in order to process
    it line by line ❷. Then iterate over each line, looking for those that contain
    a filepath (which are prefixed with n) ❸, and save them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输出存储在名为 results 的字典中，您可以通过键 STDOUT ❶ 访问它。您可以按换行符拆分输出，以便逐行处理 ❷。然后遍历每一行，查找包含文件路径的行（这些行以
    n 为前缀） ❸，并将其保存。
- en: Other Information
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他信息
- en: 'There is, of course, other information you might want to extract from running
    processes to help you with the detection of malicious code on a macOS system.
    This chapter wraps up with a few examples that examine the following details about
    a process: its execution state, its execution architecture, its start time, and
    its CPU utilization. You might also want to determine its network state, a topic
    covered in [Chapter 4](chapter4.xhtml).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可能还想从正在运行的进程中提取其他信息，以帮助您检测 macOS 系统中的恶意代码。本章通过一些示例来总结，探讨进程的以下细节：其执行状态、执行架构、启动时间以及
    CPU 使用率。您还可能希望确定其网络状态，相关内容将在[第 4 章](chapter4.xhtml)中讲解。
- en: Execution State
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行状态
- en: Imagine you have retrieved a list of process IDs. You’ll likely want to query
    the process further (for example, to build a process ancestry tree or compute
    code signing information). But what if the process has already exited, as in the
    case of a short-lived shell command? This is pertinent information, and at the
    very least, you’ll want to understand why any attempts to further query the process
    fail.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经获取了一个进程ID的列表。你可能还想进一步查询这个进程（例如，构建进程的祖先树或计算代码签名信息）。但是，如果该进程已经退出，比如在短暂的 shell
    命令情况下，怎么办呢？这是一个重要的信息，至少，你会想理解为什么任何进一步查询该进程的尝试会失败。
- en: A trivial way to determine whether a process is dead is to attempt to send it
    a signal. One way to do this is via the kill system API with a signal type of
    0, as shown in [Listing 1-32](chapter1.xhtml#Lis1-32).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 确定一个进程是否已经终止的一个简单方法是尝试向它发送一个信号。你可以通过 kill 系统 API，并设置信号类型为 0 来做到这一点，正如在[清单 1-32](chapter1.xhtml#Lis1-32)中所示。
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 1-32: Checking whether a process is dead'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-32：检查进程是否已终止
- en: This won’t kill any living processes; in fact, it’s totally harmless. However,
    if a process has exited, the API will set errno to ESRCH (no such process).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会杀死任何存活的进程；实际上，它是完全无害的。然而，如果一个进程已经退出，API 会将 errno 设置为 ESRCH（没有此进程）。
- en: What if the process is zombie-fied? You can use the sysctl API to populate a
    kinfo_proc structure, as in [Listing 1-33](chapter1.xhtml#Lis1-33).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程已经变成僵尸进程怎么办？你可以使用 sysctl API 来填充一个 kinfo_proc 结构，正如在[清单 1-33](chapter1.xhtml#Lis1-33)中所示。
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Listing 1-33: Checking whether a process is a zombie'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-33：检查进程是否为僵尸进程
- en: This structure contains a flag named p_stat. If that flag has the SZOMB bit
    set, you know the process is a zombie.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构包含一个名为 p_stat 的标志。如果该标志设置了 SZOMB 位，那么你就知道该进程是一个僵尸进程。
- en: Execution Architecture
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行架构
- en: 'With the introduction of Apple Silicon, macOS now supports both Intel (x86_64)
    and ARM (ARM64) binaries. Because many analysis tools are specific to a file’s
    architecture, identifying this information for a process is important. Moreover,
    although developers have recompiled most legitimate software to run natively on
    Apple Silicon, malware is still playing catch-up; a surprising amount of it is
    still distributed as Intel binaries. Some examples of malware discovered in 2022
    that are distributed solely as Intel binaries include DazzleSpy, rShell, oRat,
    and CoinMiner:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Apple Silicon 的引入，macOS 现在支持 Intel（x86_64）和 ARM（ARM64）二进制文件。因为许多分析工具是针对文件架构的，所以识别进程的架构信息非常重要。此外，尽管开发者已经重新编译了大多数合法软件，以原生方式运行在
    Apple Silicon 上，但恶意软件仍在赶超；令人惊讶的是，它仍然有相当一部分是以 Intel 二进制文件形式分发的。2022 年发现的一些仅以 Intel
    二进制文件形式分发的恶意软件示例包括 DazzleSpy、rShell、oRat 和 CoinMiner：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: For this reason, you might want to look a little more closely at Intel binaries
    than at ARM or universal binaries.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能想要比 ARM 或通用二进制文件更仔细地查看 Intel 二进制文件。
- en: Unfortunately, identifying architecture information is not as straightforward
    as simply checking the host’s CPU type, because on Apple Silicon systems, Intel
    binaries can still execute, albeit translated via Rosetta. Instead, you can follow
    the process taken by Activity Monitor. [Listing 1-34](chapter1.xhtml#Lis1-34)
    shows this approach, which you can find in the getArchitecture function in the
    *enumerateProcesses* project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，识别架构信息并不像仅仅检查主机的 CPU 类型那样简单，因为在 Apple Silicon 系统上，Intel 二进制文件仍然可以执行，尽管是通过
    Rosetta 转译的。相反，你可以跟踪活动监视器所采用的方法。[清单 1-34](chapter1.xhtml#Lis1-34)展示了这种方法，你可以在
    *enumerateProcesses* 项目的 getArchitecture 函数中找到它。
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 1-34: Obtaining a process’s architecture'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 1-34：获取进程的架构
- en: This code, as well as Activity Monitor, first uses the "proc_cputype" string
    and the sysctlnametomib and sysctl APIs to determine a running process’s CPU type.
    Note that the array passed to *sysctlnametomib* has a size of CTL_MAXNAME, a constant
    defined by Apple that defines the maximum number of components in an MIB name.
    If the answer is Intel (CPU_TYPE_X86_64), you know the process is running as x86_64.
    However, on Apple Silicon systems, these processes could still be backed by an
    Intel-based binary that was translated into ARM via Rosetta. To detect this scenario,
    Apple checks the process’s p_flags (obtained by a call to sysctl). If these flags
    have the P_TRANSLATED bit set, Activity Monitor sets the architecture to Intel.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以及活动监视器，首先使用 "proc_cputype" 字符串和 sysctlnametomib 和 sysctl API 来确定正在运行的进程的
    CPU 类型。请注意，传递给 *sysctlnametomib* 的数组大小为 CTL_MAXNAME，这是苹果定义的常量，表示 MIB 名称中组件的最大数量。如果返回的是
    Intel（CPU_TYPE_X86_64），则表示该进程以 x86_64 形式运行。然而，在 Apple Silicon 系统上，这些进程仍然可能由基于
    Intel 的二进制文件支持，这些二进制文件通过 Rosetta 转换为 ARM 架构。为了检测这种情况，苹果检查进程的 p_flags（通过调用 sysctl
    获取）。如果这些标志设置了 P_TRANSLATED 位，活动监视器将架构设置为 Intel。
- en: In the *enumerateProcesses* project, you’ll find a function named getArchitecture.
    It takes a process ID and returns its architecture. First, we populate an array
    via the sysctlnametomib API, passing in the name sysctl.proc_cputype ❶. Then,
    after adding the target process ID, we invoke the sysctl API with the initialized
    array to get the CPU type of said process ❷. If the returned CPU type is CPU_TYPE_X86_64,
    the code sets the architecture to Intel ❸. On the other hand, if the CPU type
    for the target process is CPU _TYPE_ARM64, the code defaults to Apple Silicon
    ❹. As noted, the process could still be an Intel-based binary, albeit translated.
    To detect this scenario, the code checks whether the process’s p_flags have the
    P_TRANSLATED bit set. If so, it sets the architecture to Intel ❺.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *enumerateProcesses* 项目中，您会发现一个名为 getArchitecture 的函数。它接受一个进程 ID 并返回其架构。首先，我们通过
    sysctlnametomib API 填充一个数组，传入名称 sysctl.proc_cputype ❶。然后，在添加目标进程 ID 后，我们使用初始化的数组调用
    sysctl API 以获取该进程的 CPU 类型 ❷。如果返回的 CPU 类型是 CPU_TYPE_X86_64，代码将架构设置为 Intel ❸。另一方面，如果目标进程的
    CPU 类型是 CPU_TYPE_ARM64，代码将默认设置为 Apple Silicon ❹。如前所述，该进程仍可能是基于 Intel 的二进制文件，尽管已经被转换。为了检测这种情况，代码会检查进程的
    p_flags 是否设置了 P_TRANSLATED 位。如果是，它将架构设置为 Intel ❺。
- en: Start Time
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动时间
- en: When querying running processes, you may find it useful to know when each process
    was started. This can help determine if a process was started automatically during
    system boot or later, perhaps by the user. Processes started automatically may
    be persistently installed, and if these don’t belong to the operating system,
    you may want to closely examine them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询正在运行的进程时，了解每个进程的启动时间可能会很有帮助。这可以帮助判断一个进程是系统启动时自动启动的，还是稍后由用户启动的。自动启动的进程可能是持续安装的，如果这些进程不属于操作系统，您可能需要仔细检查它们。
- en: To determine a process’s start time, we can once again turn to the trusty sysctl
    API. [Listing 1-35](chapter1.xhtml#Lis1-35) shows the getStartTime function in
    the *enumerateProcesses* project, which accepts a process ID and returns the process’s
    start time.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个进程的启动时间，我们可以再次使用可靠的 sysctl API。[列表 1-35](chapter1.xhtml#Lis1-35) 显示了 *enumerateProcesses*
    项目中的 getStartTime 函数，该函数接受一个进程 ID 并返回该进程的启动时间。
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 1-35: Obtaining the start time of a process'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-35：获取进程的启动时间
- en: We invoke sysctl to populate a kinfo_proc structure for a process ❶. This structure
    will contain a timeval struct aptly named p_starttime ❷. We then convert this
    Unix timestamp into a more manageable date object that we return to the caller
    ❸.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 sysctl 来填充一个 kinfo_proc 结构体 ❶。该结构体将包含一个名为 p_starttime 的 timeval 结构体 ❷。然后，我们将这个
    Unix 时间戳转换为一个更易管理的日期对象，并将其返回给调用者 ❸。
- en: CPU Utilization
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CPU 利用率
- en: Let’s end the chapter by looking at how to compute CPU utilization for a given
    process. Although this isn’t a foolproof heuristic, it may help detect surreptitious
    cryptocurrency miners, which tend to maximize their use of system resources.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看如何计算给定进程的 CPU 利用率来结束这一章。虽然这不是一个万无一失的启发式方法，但它可能有助于检测潜伏的加密货币挖矿程序，这些程序往往会最大化系统资源的使用。
- en: 'To compute CPU utilization, start by invoking the proc_pid_rusage API, which
    returns usage information for a given process ID. This API is declared in *libproc.h*
    as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 CPU 利用率，首先调用 proc_pid_rusage API，该 API 返回给定进程 ID 的使用信息。此 API 在 *libproc.h*
    中声明如下：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The flavor argument can be set to the constant RUSAGE_INFO_V0, and the final
    argument is an output buffer to a resource information buffer, which should be
    of type rusage_info_v0.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`flavor`参数可以设置为常量`RUSAGE_INFO_V0`，最后一个参数是输出缓冲区，用于存储资源信息缓冲区，其类型应为`rusage_info_v0`。'
- en: In [Listing 1-36](chapter1.xhtml#Lis1-36), from the getCPUUsage function in
    the *enumerateProcesses* project, we invoke proc_pid_rusage twice with a delay
    (delta) between invocations. Then we compute the difference between the resource
    information of the first and second calls. This code was inspired by a post on
    Stack Overflow.^([16](#chapter1-16))
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 1-36](chapter1.xhtml#Lis1-36)中，我们在*enumerateProcesses*项目的`getCPUUsage`函数中，调用了`proc_pid_rusage`两次，并且在调用之间设置了延迟（时间差）。然后我们计算第一次和第二次调用之间的资源信息差异。这个代码灵感来自Stack
    Overflow上的一篇帖子。^([16](#chapter1-16))
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 1-36: Computing the CPU time of a process over a delta of five seconds'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-36：计算一个进程在五秒时间差内的CPU时间
- en: You can see the first call to proc_pid_rusage at ❶, followed by another call
    at ❷. Both calls take the same process ID of the target process. We then compute
    the CPU time by subtracting both the user time (ri_user_time) and system time
    (ri_system_time), then adding the results ❸.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在❶看到第一次调用`proc_pid_rusage`，然后在❷看到第二次调用。这两次调用都传入了目标进程的相同进程ID。接着，我们通过减去用户时间（`ri_user_time`）和系统时间（`ri_system_time`）来计算CPU时间，再将结果相加❸。
- en: To compute the CPU *percentage* in use, we first convert this CPU time from
    Mach time to nanoseconds. [Listing 1-37](chapter1.xhtml#Lis1-37) does this with
    the help of the mach_timebase_info function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算正在使用的CPU *百分比*，我们首先将这个CPU时间从Mach时间转换为纳秒。[列表 1-37](chapter1.xhtml#Lis1-37)通过调用`mach_timebase_info`函数实现了这一点。
- en: '[PRE61]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 1-37: Calculating a percentage of CPU usage'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1-37：计算CPU使用百分比
- en: We then divide the CPU time by the specified delay and the number of nanoseconds
    per second times 100 (as we want a percentage).^([17](#chapter1-17))
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将CPU时间除以指定的延迟和每秒的纳秒数乘以100（因为我们需要得到百分比）。^([17](#chapter1-17))
- en: 'Let’s now run *enumerateProcesses*, which contains this code, against the unauthorized
    cryptocurrency miner found in the Calendar 2 application mentioned earlier in
    this chapter:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行包含此代码的*enumerateProcesses*，针对本章早些时候提到的未授权加密货币挖矿工具——Calendar 2应用程序进行检测：
- en: '[PRE62]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As the application is surreptitiously mining, its CPU utilization is a whopping
    370 percent! (On multicore CPUs, CPU utilization can reach values over 100 percent.)
    We can confirm the accuracy of the program by running the built-in macOS ps tool,
    specifying the PID of the Calendar application:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序在偷偷挖矿，它的CPU利用率竟然高达370%！（在多核CPU上，CPU利用率可以超过100%。）我们可以通过运行内置的macOS `ps`工具，指定日历应用程序的PID，来确认程序的准确性：
- en: '[PRE63]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Although the exact percentage will drift over time, ps shows the application
    using roughly the same massive amount of CPU.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管具体的百分比会随着时间的推移发生变化，但`ps`命令显示应用程序大约使用相同数量的CPU。
- en: Conclusion
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you saw how to extract a myriad of useful information from
    running processes, including process hierarchies, code information, and much more.
    With this information, you should be well on your way to detecting any malware
    running on a macOS system. In the next chapter, we’ll focus on programmatically
    parsing and analyzing the Mach-O executable binary that backs each process.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何从正在运行的进程中提取大量有用的信息，包括进程层级、代码信息等等。通过这些信息，你应该能够轻松检测到任何在macOS系统上运行的恶意软件。在下一章，我们将专注于如何以编程方式解析和分析支撑每个进程的Mach-O可执行二进制文件。
- en: Notes
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[  1](#chapter1_1).  To learn more about audit tokens, see Scott Knight, “Audit
    Tokens Explained,” Knight.sc, March 20, 2020, [*https://<wbr>knight<wbr>.sc<wbr>/reverse%20engineering<wbr>/2020<wbr>/03<wbr>/20<wbr>/audit<wbr>-tokens<wbr>-explained<wbr>.html*](https://knight.sc/reverse%20engineering/2020/03/20/audit-tokens-explained.html).'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter1_1).  想要了解更多关于审计令牌的信息，请参见Scott Knight的《审计令牌解释》，Knight.sc，2020年3月20日，[*https://<wbr>knight<wbr>.sc<wbr>/reverse%20engineering<wbr>/2020<wbr>/03<wbr>/20<wbr>/audit<wbr>-tokens<wbr>-explained<wbr>.html*](https://knight.sc/reverse%20engineering/2020/03/20/audit-tokens-explained.html)。'
- en: '[  2](#chapter1_2).  Patrick Wardle, “Analyzing OSX.DazzleSpy,” Objective-See,
    January 25, 2022, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x6D<wbr>.html*](https://objective-see.org/blog/blog_0x6D.html).'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter1_2).  Patrick Wardle，“分析OSX.DazzleSpy”，Objective-See，2022年1月25日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x6D<wbr>.html*](https://objective-see.org/blog/blog_0x6D.html)。'
- en: '[  3](#chapter1_3).  Patrick Wardle, “Ironing Out (the macOS) Details of a
    Smooth Operator (Part II),” Objective-See, April 1, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x74<wbr>.html*](https://objective-see.org/blog/blog_0x74.html).'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter1_3).  Patrick Wardle, “详细解析 (macOS) 平台的平滑操作员 (第二部分)”，Objective-See，2023年4月1日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x74<wbr>.html*](https://objective-see.org/blog/blog_0x74.html)。'
- en: '[  4](#chapter1_4).  Patrick Wardle, “Discharging ElectroRAT,” Objective-See,
    January 5, 2021, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x61<wbr>.html*](https://objective-see.org/blog/blog_0x61.html).'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter1_4).  Patrick Wardle, “释放 ElectroRAT”，Objective-See，2021年1月5日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x61<wbr>.html*](https://objective-see.org/blog/blog_0x61.html)。'
- en: '[  5](#chapter1_5).  Aedan Russel, “ChromeLoader: A Pushy Malvertiser,” Red
    Canary, May 25, 2022, [*https://<wbr>redcanary<wbr>.com<wbr>/blog<wbr>/chromeloader<wbr>/*](https://redcanary.com/blog/chromeloader/).'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter1_5).  Aedan Russel, “ChromeLoader: 一种强势的恶意广告软件”，Red Canary，2022年5月25日，[*https://<wbr>redcanary<wbr>.com<wbr>/blog<wbr>/chromeloader<wbr>/*](https://redcanary.com/blog/chromeloader/)。'
- en: '[  6](#chapter1_6).  Mitch Datka, “CrowdStrike Uncovers New MacOS Browser Hijacking
    Campaign,” *CrowdStrike*, June 2, 2022, [*https://<wbr>www<wbr>.crowdstrike<wbr>.com<wbr>/blog<wbr>/how<wbr>-crowdstrike<wbr>-uncovered<wbr>-a<wbr>-new<wbr>-macos<wbr>-browser<wbr>-hijacking<wbr>-campaign<wbr>/*](https://www.crowdstrike.com/blog/how-crowdstrike-uncovered-a-new-macos-browser-hijacking-campaign/).'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter1_6).  Mitch Datka, “CrowdStrike 发现新的 MacOS 浏览器劫持活动，” *CrowdStrike*，2022年6月2日，
    [*https://<wbr>www<wbr>.crowdstrike<wbr>.com<wbr>/blog<wbr>/how<wbr>-crowdstrike<wbr>-uncovered<wbr>-a<wbr>-new<wbr>-macos<wbr>-browser<wbr>-hijacking<wbr>-campaign<wbr>/*](https://www.crowdstrike.com/blog/how-crowdstrike-uncovered-a-new-macos-browser-hijacking-campaign/)。'
- en: '[  7](#chapter1_7).  Patrick Wardle, “A Surreptitious Cryptocurrency Miner
    in the Mac App Store?,” Objective-See, March 11, 2018, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x2B<wbr>.html*](https://objective-see.org/blog/blog_0x2B.html).'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter1_7).  Patrick Wardle, “Mac App Store 中的隐秘加密货币矿工？”，Objective-See，2018年3月11日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x2B<wbr>.html*](https://objective-see.org/blog/blog_0x2B.html)。'
- en: '[  8](#chapter1_8).  See “App Review Guidelines,” Apple, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/app<wbr>-store<wbr>/review<wbr>/guidelines<wbr>/*](https://developer.apple.com/app-store/review/guidelines/).'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  8](#chapter1_8).  请参阅“App Review Guidelines”，苹果，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/app<wbr>-store<wbr>/review<wbr>/guidelines<wbr>/*](https://developer.apple.com/app-store/review/guidelines/)。'
- en: '[  9](#chapter1_9).  Patrick Wardle, “Where There Is Love, There Is . . . Malware?”
    Objective-See, February 14, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x72<wbr>.html*](https://objective-see.org/blog/blog_0x72.html).'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  9](#chapter1_9).  Patrick Wardle, “爱与. . . 恶意软件并存？” Objective-See，2023年2月14日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x72<wbr>.html*](https://objective-see.org/blog/blog_0x72.html)。'
- en: '[10](#chapter1_10).  For more details about this attack, including a full analysis
    of the payload, see my blog post, “The Mac Malware of 2019: OSX.Yort,” Objective-See,
    January 1, 2020, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x53<wbr>.html#osx<wbr>-yort*](https://objective-see.org/blog/blog_0x53.html#osx-yort).'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[10](#chapter1_10).  有关此攻击的更多细节，包括有效负载的完整分析，请参阅我的博客文章，“2019年Mac恶意软件：OSX.Yort”，Objective-See，2020年1月1日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x53<wbr>.html#osx<wbr>-yort*](https://objective-see.org/blog/blog_0x53.html#osx-yort)。'
- en: '[11](#chapter1_11).  To learn more about process trees on macOS, see Jaron
    Bradley, “Grafting Apple Trees: Building a Useful Process Tree,” presented at
    Objective by the Sea, Maui, HI, March 12, 2020, [*https://<wbr>objectivebythesea<wbr>.org<wbr>/v3<wbr>/talks<wbr>/OBTS<wbr>_v3<wbr>_jBradley<wbr>.pdf*](https://objectivebythesea.org/v3/talks/OBTS_v3_jBradley.pdf).'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[11](#chapter1_11).  要了解更多关于 macOS 上进程树的信息，请参阅 Jaron Bradley, “嫁接苹果树：构建有用的进程树”，在
    Objective by the Sea，夏威夷毛伊岛，2020年3月12日发表，[*https://<wbr>objectivebythesea<wbr>.org<wbr>/v3<wbr>/talks<wbr>/OBTS<wbr>_v3<wbr>_jBradley<wbr>.pdf*](https://objectivebythesea.org/v3/talks/OBTS_v3_jBradley.pdf)。'
- en: '[12](#chapter1_12).  Jonathan Levin, “launchd, I’m Coming for You,” October
    7, 2015, [*http://<wbr>newosxbook<wbr>.com<wbr>/articles<wbr>/jlaunchctl<wbr>.html*](http://newosxbook.com/articles/jlaunchctl.html).'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[12](#chapter1_12).  Jonathan Levin, “launchd，我来了”，2015年10月7日，[*http://<wbr>newosxbook<wbr>.com<wbr>/articles<wbr>/jlaunchctl<wbr>.html*](http://newosxbook.com/articles/jlaunchctl.html)。'
- en: '[13](#chapter1_13).  See [*https://<wbr>objective<wbr>-see<wbr>.com<wbr>/products<wbr>/taskexplorer<wbr>.html*](https://objective-see.com/products/taskexplorer.html).'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[13](#chapter1_13).  请参阅 [*https://<wbr>objective<wbr>-see<wbr>.com<wbr>/products<wbr>/taskexplorer<wbr>.html*](https://objective-see.com/products/taskexplorer.html)。'
- en: '[14](#chapter1_14).  For more on this topic, see Zhuowei Zhang, “Extracting
    Libraries from dyld_shared_cache,” *Worth Doing Badly*, June 24, 2018, [*https://<wbr>worthdoingbadly<wbr>.com<wbr>/dscextract<wbr>/*](https://worthdoingbadly.com/dscextract/).'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[14](#chapter1_14).  有关此主题的更多内容，请参见Zhuowei Zhang，“从dyld_shared_cache中提取库文件”，*Worth
    Doing Badly*，2018年6月24日，[*https://<wbr>worthdoingbadly<wbr>.com<wbr>/dscextract<wbr>/*](https://worthdoingbadly.com/dscextract/)。'
- en: '[15](#chapter1_15).  Patrick Wardle, “Tearing Apart the Undetected (OSX)Coldroot
    RAT,” Objective-See, February 17, 2018, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x2A<wbr>.html*](https://objective-see.org/blog/blog_0x2A.html).'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[15](#chapter1_15).  Patrick Wardle，“拆解未被发现的 (OSX) Coldroot RAT”，Objective-See，2018年2月17日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x2A<wbr>.html*](https://objective-see.org/blog/blog_0x2A.html)。'
- en: '[16](#chapter1_16).  “The cpu_time Obtained by proc_pid_rusage Does Not Meet
    Expectations on the macOS M1 Chip,” Stack Overflow, [*https://<wbr>stackoverflow<wbr>.com<wbr>/questions<wbr>/66328149<wbr>/the<wbr>-cpu<wbr>-time<wbr>-obtained<wbr>-by<wbr>-proc<wbr>-pid<wbr>-rusage<wbr>-does<wbr>-not<wbr>-meet<wbr>-expectations<wbr>-on<wbr>-the<wbr>-macos*](https://stackoverflow.com/questions/66328149/the-cpu-time-obtained-by-proc-pid-rusage-does-not-meet-expectations-on-the-macos).'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[16](#chapter1_16).  “proc_pid_rusage获取的cpu_time在macOS M1芯片上不符合预期”，Stack Overflow，[*https://<wbr>stackoverflow<wbr>.com<wbr>/questions<wbr>/66328149<wbr>/the<wbr>-cpu<wbr>-time<wbr>-obtained<wbr>-by<wbr>-proc<wbr>-pid<wbr>-rusage<wbr>-does<wbr>-not<wbr>-meet<wbr>-expectations<wbr>-on<wbr>-the<wbr>-macos*](https://stackoverflow.com/questions/66328149/the-cpu-time-obtained-by-proc-pid-rusage-does-not-meet-expectations-on-the-macos)。'
- en: '[17](#chapter1_17).  You can read more about the topic of Mach time and conversions
    to nanoseconds in Howard Oakley, “Changing the Clock in Apple Silicon Macs,” *The
    Eclectic Light Company*, September 8, 2020, [*https://<wbr>eclecticlight<wbr>.co<wbr>/2020<wbr>/09<wbr>/08<wbr>/changing<wbr>-the<wbr>-clock<wbr>-in<wbr>-apple<wbr>-silicon<wbr>-macs<wbr>/*](https://eclecticlight.co/2020/09/08/changing-the-clock-in-apple-silicon-macs/).'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[17](#chapter1_17).  你可以在Howard Oakley的文章中阅读更多关于Mach时间和纳秒转换的话题，“更改Apple Silicon
    Mac中的时钟”，*The Eclectic Light Company*，2020年9月8日，[*https://<wbr>eclecticlight<wbr>.co<wbr>/2020<wbr>/09<wbr>/08<wbr>/changing<wbr>-the<wbr>-clock<wbr>-in<wbr>-apple<wbr>-silicon<wbr>-macs<wbr>/*](https://eclecticlight.co/2020/09/08/changing-the-clock-in-apple-silicon-macs/)。'
