- en: '**14**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**14**'
- en: '**SMART ARCHITECTURES**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**智能架构**'
- en: '![Image](../images/f0339-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0339-01.jpg)'
- en: '*Smart computing* means general-purpose computers built into low-power and/or
    mobile devices, such as phones, tablets, TVs, routers, and fridges. Unlike embedded
    systems, they run multiple easily installable and upgradable programs, often known
    as *apps*. Unlike desktop systems, they need to reduce power consumption, as they
    often run from batteries. *Reduced instruction set computing (RISC)* is a good
    fit for these requirements, so RISC architectures are generally found in smart
    systems. This chapter explores the RISC philosophy, smart devices, and the details
    of a particular RISC architecture, RISC-V. It’s shorter than the desktop chapter
    because RISC is simpler than CISC by design.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能计算*意味着内置于低功耗和/或移动设备中的通用计算机，例如手机、平板电脑、电视、路由器和冰箱。与嵌入式系统不同，它们运行多个易于安装和升级的程序，通常被称为*应用程序*。与桌面系统不同，它们需要减少功耗，因为它们通常依赖电池供电。*精简指令集计算（RISC）*非常适合这些要求，因此RISC架构通常出现在智能系统中。本章探讨了RISC理念、智能设备以及特定RISC架构RISC-V的细节。由于RISC在设计上比CISC更简单，本章比桌面系统的章节要短。'
- en: Smart Devices
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能设备
- en: Early mobile phones were embedded systems whose primary purpose was to function
    as voice telephones. They had microcontrollers programmed to manage the telephone
    and user interaction via buttons and simple number-displaying screens. Over time,
    these microprocessors and interaction devices grew, and the firmware was extended
    to include features such as contact books, alarm clocks, and simple games like
    *Snake*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的移动电话是嵌入式系统，其主要目的是作为语音电话使用。它们配备了微控制器，用于管理电话功能和通过按钮与简单数字显示屏进行用户交互。随着时间的推移，这些微处理器和交互设备不断发展，固件也扩展到了包括联系人簿、闹钟和简单游戏，如*蛇*。
- en: Modern smartphones now provide such features, and many more, as software apps
    rather than firmware. They’ve replaced microcontrollers with fully fledged general-purpose
    architectures that typically run an operating system such as LineageOS, Replicant,
    or Android to host apps, much like a desktop PC.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现代智能手机现在提供这样的功能，以及更多功能，作为软件应用而非固件。它们已将微控制器替换为完整的通用架构，通常运行操作系统，如LineageOS、Replicant或Android来托管应用程序，类似于桌面PC。
- en: The prefix *smart* emerged to describe these phones, but it’s now applied to
    anything that used to be an embedded system but has been upgraded to a general-purpose
    computer. For example, smart TVs (the left of [Figure 14-1](ch14.xhtml#ch14fig1))
    and smart fridges have moved beyond microcontrollers and firmware to the point
    where they can easily install and run multiple apps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能*这个前缀最初用于描述这些手机，但现在它被应用于任何曾经是嵌入式系统的设备，但已升级为通用计算机。例如，智能电视（[图14-1](ch14.xhtml#ch14fig1)左侧）和智能冰箱已经超越了微控制器和固件，能够轻松安装和运行多个应用程序。'
- en: The modern consumer internet connection device shown on the right of [Figure
    14-1](ch14.xhtml#ch14fig1) and widely but wrongly known as a “router” is another
    example of a smart computer. Such devices now usually contain an operating system
    running many services, including routing, Wi-Fi, firewalling, and a web server
    (at least to run its configuration page). They should probably be renamed “smart
    routers” for this reason.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧显示的现代消费级互联网连接设备（[图14-1](ch14.xhtml#ch14fig1)右侧），通常但错误地被称为“路由器”，是另一个智能计算机的例子。这些设备现在通常包含运行多个服务的操作系统，包括路由、Wi-Fi、防火墙和Web服务器（至少用于运行其配置页面）。因此，出于这个原因，它们应该被重新命名为“智能路由器”。
- en: '![Image](../images/f0340-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0340-01.jpg)'
- en: '*Figure 14-1: The inside of a Toshiba smart TV (left) and a Zyxel router (right)*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：东芝智能电视内部（左）和Zyxel路由器（右）*'
- en: The “smart home” has been a computing industry ambition for several decades,
    and refers to a home in which most or all of the usual domestic appliances are
    upgraded to networked, general-purpose computers. For example, smart washing machines
    and smart central heating controllers will enable innovative, machine learning–based
    apps to compete against one another to make the best use of energy, given data
    from sensors monitoring the condition of clothes to be washed and the temperatures
    and usages of rooms. Linking these systems will enable automation chains such
    as your smart fridge predicting that the milk will run out later today, and placing
    an automatic order to the local supermarket to deliver more, perhaps via a last-mile
    delivery robot and a smart drop-off box to receive the delivery. Or your heating
    system and fridge could be temporarily turned off while the washing machine is
    turned on, so that it can be powered entirely from the batteries in your parked
    electric car, charged from your solar panels, without needing to use the power
    grid.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “智能家居”是计算机行业多年来的一个目标，指的是将大部分或所有常见家用电器升级为网络化的通用计算机。例如，智能洗衣机和智能中央暖气控制器将使基于机器学习的创新应用竞争，通过传感器监控待洗衣物的状况、房间的温度和使用情况，从而最佳利用能源。将这些系统连接起来将实现自动化链条，比如智能冰箱预测今天晚些时候牛奶会用完，并自动向本地超市下单，可能通过最后一公里的配送机器人和智能投递箱接收货物。或者，在洗衣机开启时，您的加热系统和冰箱可以暂时关闭，从而完全依靠停放的电动汽车电池供电，而电池是通过您的太阳能电池板充电的，无需使用电网电力。
- en: Architectures for smart devices have similar requirements to embedded systems
    around reliability and energy usage. However, they also need more computing power
    than embedded microcontrollers. These requirements are a perfect match for the
    RISC philosophy, so let’s examine this philosophy in more detail.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 智能设备的架构在可靠性和能效方面与嵌入式系统有相似的要求。然而，它们比嵌入式微控制器需要更多的计算能力。这些需求与RISC哲学完美契合，因此让我们更详细地探讨这一哲学。
- en: RISC Philosophy
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RISC哲学
- en: The RISC concept was invented by an American, David Patterson, but most successfully
    commercialized by the British. Patterson’s quantitative approach to architecture
    involved a statistical analysis of the instructions actually being used by real-world
    programs on processors of the 1990s. He found that the more complex instructions
    were used very rarely, in part because compiler back-end designers didn’t know
    or want to learn how to use them. He determined that roughly 90 percent of the
    work was being done by roughly 10 percent of the resources. This led him to the
    central RISC tenet that the silicon occupied by the rarely used instructions would
    be better put to work making the most popular 10 percent of instructions run very
    fast, at the expense of removing the other instructions altogether. Patterson
    and his co-architect, John Hennessy, won the 2017 Turing Award for their research
    on the use of quantitative methods to guide RISC architecture design.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: RISC概念是由美国人David Patterson发明的，但最成功地被英国人商业化。Patterson对架构的定量方法涉及对1990年代处理器上实际使用的指令进行统计分析。他发现，复杂的指令使用非常少，部分原因是编译器后端设计人员不知道或者不愿意学习如何使用这些指令。他确定，大约90%的工作是由大约10%的资源完成的。这使他得出RISC的核心原则，即占据了很少使用的指令的硅芯片，最好用来让最常用的10%的指令运行得非常快速，而其他指令则完全移除。Patterson和他的联合架构师John
    Hennessy因他们利用定量方法指导RISC架构设计的研究，获得了2017年图灵奖。
- en: RISC usually aims for every one of its streamlined set of instructions to be
    executed in a single CPU cycle. With fewer instructions available, RISC assembly
    programs are often quite verbose, but each instruction is simple, fast, and low-power
    to execute. Writing programs in RISC assembly and writing compilers for RISC is
    easy and fun because the instruction set architectures (ISAs) are small, simple,
    and understandable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RISC通常旨在让每一条精简指令都能在一个CPU周期内执行。由于可用的指令较少，RISC汇编程序通常会非常冗长，但每条指令都简单、快速且低功耗。用RISC汇编编写程序和为RISC编写编译器既简单又有趣，因为指令集架构（ISA）小巧、简单且易于理解。
- en: RISC CPUs themselves aren’t necessarily simple, however. While the instruction
    sets are by definition smaller, designers have found alternative ways to make
    efficient use of the available silicon. For example, RISC processors typically
    have many more registers than their CISC counterparts. Extra registers are especially
    useful in RISC because they help separate memory access from arithmetic. In RISC
    programming and RISC compilers, it’s common to try to bring all relevant variables
    into registers at the start of a subroutine, then do the entire function’s computations
    in registers, storing only the result back to main memory. This contrasts with
    CISC, where there can be continual loading and storing throughout the subroutine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，RISC处理器本身不一定简单。虽然指令集的定义较小，但设计师们找到了其他方法来高效利用可用的硅片。例如，RISC处理器通常比CISC处理器拥有更多的寄存器。额外的寄存器在RISC中尤其有用，因为它们有助于将内存访问与算术操作分离。在RISC编程和RISC编译器中，通常会尝试在子程序开始时将所有相关变量加载到寄存器中，然后在寄存器中完成整个函数的计算，仅将结果存回主内存。这与CISC形成对比，CISC中可能会在整个子程序中持续进行加载和存储操作。
- en: Because part of the RISC philosophy is that every instruction should execute
    in exactly one clock cycle, instruction-level parallelism through pipelining,
    branch prediction, and out-of-order execution (OOOE) are massively easier to manage.
    Every instruction has the same fetch-decode-execute step duration, and each phase
    can be triggered regularly in open-loop style. Compare this with CISC architectures,
    where steps of different instructions can take different durations and must closed-loop
    trigger each other to say when they’ve been completed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为RISC哲学的一部分是每条指令都应在恰好一个时钟周期内执行，借助流水线、分支预测和乱序执行（OOOE），指令级并行性更容易管理。每条指令的取指-解码-执行步骤持续时间相同，每个阶段都可以在开放环路方式下定期触发。与CISC架构相比，CISC架构中的不同指令步骤可能需要不同的时长，并且必须通过闭环触发相互作用，以便告知何时完成。
- en: 'RISC was traditionally seen as a very academic philosophy, being beautiful
    in its design, lean and mean in its execution, and generally resisting the temptation
    to make a fast buck by bolting on new features to please specific customers by
    next Thursday. It was often associated with Britain and the British company ARM,
    though it originated at the University of California, Berkeley—located near to
    but separated from Silicon Valley. The stereotypical RISC advocate was more interested
    in beauty and cleverness of design than pragmatism, and for a long time such people
    were laughed at by more commercial-minded Silicon Valley architects. However,
    this is now changing: the beauty of RISC is paying off. Most processors now manufactured
    are RISC. This is largely due to the trend of smart and embedded devices replacing
    desktops, though serious thoughts are now turning to RISC for cloud servers, too.
    In 2020, Apple also moved its desktop machines to the RISC-based M1 architecture.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RISC传统上被视为一种非常学术化的哲学，其设计精美、执行高效，并且通常抵制通过新增功能来取悦特定客户、快速赚钱的诱惑。RISC常与英国及其公司ARM相关联，尽管它起源于加利福尼亚大学伯克利分校——该校靠近硅谷但又与之隔开。典型的RISC倡导者更关注设计的美观和巧妙，而非实用主义，而长期以来，这些人常常被更具商业头脑的硅谷架构师嘲笑。然而，这种情况现在正在发生变化：RISC的美学正在得到回报。如今，大多数制造的处理器都是RISC架构。这主要得益于智能和嵌入式设备取代桌面电脑的趋势，虽然现在对于云服务器的RISC考虑也在逐渐增多。2020年，苹果公司还将其桌面计算机迁移到了基于RISC的M1架构。
- en: '**FROM ACORN TO ARM**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**从ACORN到ARM**'
- en: The British company Acorn used the 6502 in their BBC Micro (“Beeb”), a classic
    piece of British engineering, brilliantly designed but commercially mistimed and
    mispositioned. Like much British technology, the Micro was government-funded,
    in this case via the national broadcaster, the BBC, who wanted a custom-designed,
    mass-market machine to go with an educational TV series.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 英国公司Acorn在其BBC Micro（“Beeb”）中使用了6502芯片，这是一款经典的英国工程作品，设计精妙，但商业时机不对，市场定位失误。像许多英国技术一样，Micro是政府资助的，这里是通过国家广播公司BBC的资助，他们希望为一档教育电视系列节目提供一款定制设计的大众市场计算机。
- en: Hackers today often play at buying a 6502 and building an 8-bit computer around
    it on a breadboard, and that was just what the Beeb designers did. Acorn was founded
    by a bunch of Cambridge people who used that pedigree to convince the establishment
    BBC to choose their design. The BBC gave a huge specification list for what their
    computer needed for their TV series. This had a strong education and science—rather
    than gaming—influence. For example, they didn’t include a joystick port but did
    include options for coprocessors and interfacing to maker-style electronics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如今的黑客们经常尝试购买6502处理器，并围绕它在面包板上搭建8位计算机，这正是Beeb设计师们所做的。Acorn由一群剑桥大学的人创办，他们利用这一背景说服了BBC选择他们的设计。BBC给出了一个巨大的规范清单，列出了他们为电视系列所需的计算机功能。这个清单受到了强烈的教育和科学影响——而非游戏影响。例如，他们没有包括操控杆端口，但却提供了协处理器和与创客风格电子设备连接的选项。
- en: One year after the Beeb’s release, the Commodore 64 appeared, designed to be
    “for the masses, not the classes.” It had superior graphics and sound for game
    playing, and came at a much lower price. The C64 filled the full 64 k[2]B of addressable
    RAM, while the Beeb filled only 32 k[2]B. The C64 had the glorious SID sound chip,
    while the Beeb had only basic square waves, white noise, and amplitude envelopes
    from the poorer SN76489\. Commodore had by this point bought out MOS, so it could
    involve the designers of the 6502 and related chips—including Chuck Peddle—directly
    in its computer designs to exploit its most advanced features.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Beeb发布一年后，Commodore 64问世，设计目标是“面向大众，而非精英阶层”。它在游戏图像和声音方面表现出色，且价格远低于竞争对手。C64填满了64
    k[2]B的可寻址内存，而Beeb只有32 k[2]B。C64配备了出色的SID音频芯片，而Beeb则只能发出简单的方波、白噪声和来自较差的SN76489的振幅包络。到那时，Commodore已收购了MOS，因此它能够直接将6502及相关芯片的设计师——包括Chuck
    Peddle——融入其计算机设计中，充分发挥这些芯片的先进特性。
- en: The C64 quickly made the Beeb seem overspecified and overpriced. However, Acorn
    used the Beeb internally to design their first RISC processor, the Acorn RISC
    Machine (ARM), for their next computer, the Archimedes—a fully 32-bit machine,
    released in 1987\. Archimedes was technically a decade ahead of its time, though
    temporally and culturally it still belonged to the “16/32-bit era.” It was again
    sadly mismarketed, overspecified, and overpriced—for example, having eight-channel
    audio compared to the Amiga’s four, yet no joystick ports or TV output for games.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C64迅速让Beeb显得配置过高且定价过高。然而，Acorn在内部使用Beeb设计了他们的第一款RISC处理器——Acorn RISC Machine
    (ARM)，用于下一代计算机Archimedes，这是一台完全32位的机器，1987年发布。Archimedes在技术上领先其时代十年，尽管从时间和文化角度来看，它仍属于“16/32位时代”。它再次被遗憾地错营销，配置过高且定价过高——例如，尽管它有八声道音频，而Amiga只有四声道，但没有游戏所需的操控杆端口或电视输出。
- en: Acorn went on to spin out a new company, ARM, to focus on its ARM chip designs.
    ARM found success, as its chips now power most of the world’s smartphones, the
    M1 used in Apple’s tablets and desktops, and many smart devices such as the chips
    seen in [Figure 14-1](ch14.xhtml#ch14fig1).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Acorn随后成立了一家公司，ARM，专注于其ARM芯片的设计。ARM取得了成功，因为它的芯片现在为全球大多数智能手机提供动力，包括Apple平板和桌面电脑中使用的M1芯片，以及许多智能设备，如[图14-1](ch14.xhtml#ch14fig1)中看到的芯片。
- en: Computing history could have been very different if the BBC had waited an extra
    year to put a C64 into every UK school. Commodore’s business management faced
    challenges that led to bankruptcy in 1994, but acceptance by the British establishment
    might have provided the stability needed to survive.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果BBC多等一年，把C64引入每所英国学校，计算机历史可能会大不相同。Commodore的企业管理面临的挑战最终导致了1994年破产，但若得到英国官方的支持，或许能够提供必要的稳定性，帮助它度过难关。
- en: A strange legacy has been that Acorn’s OS for Archimedes, RISCOS, is still compatible
    with the latest ARM ISAs. It was painstakingly hand-coded in ARM assembly to squeeze
    power out of early 1990s CPUs, so it now runs blindingly fast on modern devices
    such as the Raspberry Pi. There’s been a resurgence of old Acorn user groups around
    this, in some cases resulting in old friends meeting up for the first time in
    30 years.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一项奇特的遗产是，Acorn为Archimedes开发的操作系统RISCOS，至今仍与最新的ARM指令集架构（ISA）兼容。它是用ARM汇编语言手工编码的，以从1990年代初的CPU中榨取最大性能，因此它现在在现代设备（如树莓派）上运行极为快速。围绕这一点，旧的Acorn用户组出现了复兴，有时甚至促成了30年未见的老朋友重逢。
- en: RISC-V
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RISC-V
- en: ARM’s RISC ISA designs are heavily patented, but others in the industry now
    wish for fully open source RISC ISA alternatives. As with the IBM-Intel-AMD license,
    computer builders want to genericize the ISA and enable multiple implementations
    to drive down processor prices through competition. A large consortium of major
    Silicon Valley companies is therefore now backing Patterson’s latest and fully
    open source RISC ISA family design, called RISC-V (V for, and pronounced, “five”),
    as the next standard for RISC. Note that RISC-V is a family of ISAs, not a hardware
    implementation of these ISAs. Companies may implement the open source ISAs in
    proprietary hardware and compete on implementation quality. There are also fully
    open source implementations by Patterson’s group and other members of the RISC-V
    movement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 的 RISC ISA 设计有大量专利，但业内其他公司现在希望有完全开源的 RISC ISA 替代方案。像 IBM-Intel-AMD 许可协议一样，计算机制造商希望将
    ISA 泛化，并通过多种实现推动竞争，降低处理器价格。因此，一大批硅谷主要公司现在支持 Patterson 最新的、完全开源的 RISC ISA 系列设计，称为
    RISC-V（V 代表 "五" 并发音为“five”），作为 RISC 的下一个标准。请注意，RISC-V 是一系列 ISA，而不是这些 ISA 的硬件实现。公司可以在专有硬件中实现开源
    ISA，并通过实现质量进行竞争。Patterson 的团队和其他 RISC-V 运动成员也提供了完全开源的实现。
- en: '*Understanding the Architecture*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*理解架构*'
- en: RISC-V is designed as a family of ISAs, rather than a single ISA. The family
    includes versions suitable for embedded, mobile, desktop, and server machines,
    including versions for 32-, 64-, and 128-bit ISAs. RISC-V defines a core ISA of
    instructions that all RISC-V systems need to implement. Like x86, RISC-V uses
    per-byte, little-endian addressing. RISC-V uses RISC-style instructions that separate
    memory access from arithmetic logic unit (ALU) operations. It’s not an accumulator
    architecture, and ALU instructions explicitly specify the output register, so
    they usually have three arguments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-V 被设计为一系列指令集架构（ISA），而不是单一的 ISA。这个系列包括适用于嵌入式、移动、桌面和服务器机器的多个版本，其中包括适用于 32
    位、64 位和 128 位 ISA 的版本。RISC-V 定义了一种核心 ISA，其中的指令是所有 RISC-V 系统都需要实现的。像 x86 一样，RISC-V
    使用逐字节的小端寻址方式。RISC-V 使用 RISC 风格的指令，将内存访问与算术逻辑单元（ALU）操作分离。它不是累加器架构，ALU 指令明确指定输出寄存器，因此通常具有三个参数。
- en: As we’ve discussed, the RISC philosophy is to reduce the number of instructions
    as much as possible. This means that some operations that you would usually expect
    to find in an ISA are absent if they can be achieved through other means, such
    as by calling other instructions in slightly odd ways. When such unusual uses
    of instructions are needed, RISC-V assemblers will sometimes provide *pseudo-instructions*
    that look like the classic instructions you expect. The assembler then converts
    them to the underlying, somewhat ugly RISC instructions. To a limited extent,
    some of the complexity of CISC digital logic is thus moved into the assembler,
    while keeping the machine code itself clean.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，RISC 哲学的核心是尽可能减少指令的数量。这意味着，如果某些操作可以通过其他方式实现（例如通过以稍微不同的方式调用其他指令），你通常会发现
    ISA 中缺少某些操作。当需要这种不寻常的指令使用时，RISC-V 汇编器有时会提供看似经典的*伪指令*。然后，汇编器将它们转换为底层的、有些笨拙的 RISC
    指令。到一定程度，某些 CISC 数字逻辑的复杂性被转移到汇编器中，同时保持机器码本身的简洁。
- en: RISC-V registers have standard names and standard conventions for their typical
    uses, such as how to pass arguments to subroutines by storing them in registers.
    For example, the integer registers are always called x0 to x32 (and x0 always
    contains the constant 0). The RISC designers gave the integer registers secondary
    nickname mnemonics, shown in [Table 14-1](ch14.xhtml#ch14tab1), to encourage conventions
    for their use.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-V 寄存器有标准名称，并且对于其典型用途有标准约定，例如如何通过将参数存储在寄存器中来传递参数给子例程。例如，整型寄存器始终被称为 x0 到
    x32（其中 x0 始终包含常数 0）。RISC 设计者为整型寄存器赋予了次要的助记符别名，如[表 14-1](ch14.xhtml#ch14tab1)所示，以鼓励它们的使用约定。
- en: '**Table 14-1:** RISC-V Integer Registers'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-1：** RISC-V 整型寄存器'
- en: '| **Name** | **Mnemonic** | **Intended convention** |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **助记符** | **预期约定** |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| x0 | zero | Value is always zero |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| x0 | zero | 值始终为零 |'
- en: '| x1 | ra | Return address for subroutine calls |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| x1 | ra | 子例程调用的返回地址 |'
- en: '| x2 | sp | Stack pointer |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| x2 | sp | 栈指针 |'
- en: '| x3 | gp | Global pointer |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| x3 | gp | 全局指针 |'
- en: '| x4 | tp | Thread pointer |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| x4 | tp | 线程指针 |'
- en: '| x5–x7 | t0–t2 | Temporary |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| x5–x7 | t0–t2 | 临时寄存器 |'
- en: '| x8–x9 | s0–s1 | Saved |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| x8–x9 | s0–s1 | 保存寄存器 |'
- en: '| x10–x14 | a0–a7 | Arguments for subroutine calls |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| x10–x14 | a0–a7 | 子例程调用的参数 |'
- en: '| x18–x27 | s2–s11 | Saved |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| x18–x27 | s2–s11 | 保存寄存器 |'
- en: '| x28–x31 | t3–t6 | Temporary |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| x28–x31 | t3–t6 | 临时 |'
- en: As with instructions and pseudo-instructions, this is designed to keep the underlying
    architecture very clean and simple, while also providing the ability to think
    and code in terms of some CISC-like styles, if and only if the programmer wants
    to do that.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与指令和伪指令一样，这样的设计旨在保持底层架构非常简洁，同时也提供了思考和编程的能力，允许采用类似CISC的风格，但仅限于程序员希望这样做的情况下。
- en: There may be a further 32 optional floating-point registers, also given mnemonics,
    which you can see in [Table 14-2](ch14.xhtml#ch14tab2).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还会有另外32个可选的浮点寄存器，同样也有助记符，你可以在[表14-2](ch14.xhtml#ch14tab2)中查看。
- en: The intended calling conventions for registers starting with *t* and *s* are
    temporary and safe—the same concepts seen but less standardized in the x86 calling
    conventions from [Chapter 13](ch13.xhtml).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以*t*和*s*开头的寄存器的调用约定是临时的和安全的——这一概念在[第13章](ch13.xhtml)中的x86调用约定中也有所体现，但没有那么标准化。
- en: '**Table 14-2:** RISC-V Floating-Point Registers'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14-2：** RISC-V浮点寄存器'
- en: '| **Name** | **Mnemonic** | **Intended convention** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **助记符** | **预定约定** |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| f0–7 | ft0–7 | Floating-point temporaries |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| f0–7 | ft0–7 | 浮点暂存器 |'
- en: '| f8–9 | fs0–1 | Floating-point saved registers |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| f8–9 | fs0–1 | 浮点保存寄存器 |'
- en: '| f10–11 | fa0–1 | Floating-point arguments/return values |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| f10–11 | fa0–1 | 浮点参数/返回值 |'
- en: '| f12–17 | fa2–7 | Floating-point arguments |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| f12–17 | fa2–7 | 浮点参数 |'
- en: '| f18–27 | fs2–11 | Floating-point saved registers |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| f18–27 | fs2–11 | 浮点保存寄存器 |'
- en: '| f28–31 | ft8–11 | Floating-point temporaries |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| f28–31 | ft8–11 | 浮点暂存器 |'
- en: As with x86, the user can’t access internal registers directly. These internal
    registers include a program counter and status register.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 和x86一样，用户无法直接访问内部寄存器。这些内部寄存器包括程序计数器和状态寄存器。
- en: '*Programming Core RISC-V*'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*编程核心RISC-V*'
- en: Now we’ve seen the basic structures, let’s use them in some instructions to
    write RISC-V programs. As with the other architectures we’ve studied, we’ll first
    introduce data moves and control flow. RISC-V then has various optional extensions,
    including arithmetic, which we’ll also explore.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到基本结构，让我们在一些指令中使用它们来编写RISC-V程序。与我们学习的其他架构一样，我们将首先介绍数据移动和控制流。然后，RISC-V有各种可选扩展，包括算术运算，我们也会进行探讨。
- en: '**Data Moves**'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**数据移动**'
- en: 'As a RISC system, data movement involving primary memory is cleanly separated
    from all other operations, which are performed only on data in registers. Loading
    from memory to registers, and storing to memory from registers, is done by the
    following instructions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个RISC系统，涉及主存的数据移动与所有其他操作的清晰分离，其他操作仅在寄存器中的数据上执行。从内存加载到寄存器，以及从寄存器存储到内存，是通过以下指令完成的：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that like NASM and Arduino assembly, RISC-V assembly writes the destination
    register first, followed by the inputs. You can see the RISC nature of the `lw`
    and `sw` instructions in the requirement for all three operands, even when the
    third operand is a 0 and thus isn’t being used, rather than providing a second
    form of these instructions with only two operands.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，像NASM和Arduino汇编一样，RISC-V汇编首先写目标寄存器，然后是输入寄存器。你可以在`lw`和`sw`指令中看到RISC特点，它要求所有三个操作数，即使第三个操作数是0，因此没有被使用，而不是提供这两条指令的另一种形式，只有两个操作数。
- en: 'For convenience, a pseudo-instruction is provided to load content from a labeled
    address:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，提供了一个伪指令来从带标签的地址加载内容：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This actually gets assembled to two instructions. First, an `la` obtains the
    address of the label, and then an `lw` loads the content of that address.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上会被汇编成两条指令。首先，`la`获取标签的地址，然后`lw`加载该地址的内容。
- en: Importantly, unlike in CISC, these instructions aren’t reused to copy data between
    registers. This clean separation of memory access instructions from between-register
    operations is often considered to be a defining feature of RISC. We’ll discuss
    how this is done in the “Arithmetic” section on [page 347](ch14.xhtml#ch14lev1sec2).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，与CISC不同，这些指令不会被重用来在寄存器之间复制数据。内存访问指令和寄存器间操作的清晰分离通常被认为是RISC的一个定义特征。我们将在[第347页](ch14.xhtml#ch14lev1sec2)的“算术”部分讨论这如何实现。
- en: '**Control Flow**'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**控制流**'
- en: 'Unconditional jumps come in two forms:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无条件跳转有两种形式：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Conditional jumps include:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转包括：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Subroutines are called by “jump and link.” The “link” here refers to saving
    the program counter in a register. For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 子程序通过“跳转和链接”来调用。这里的“链接”指的是将程序计数器保存在一个寄存器中。例如：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is why x1 is nicknamed ra, for return address.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么x1被昵称为ra，代表返回地址（return address）。
- en: 'There isn’t a return instruction because returning can be done, RISC-style,
    by reusing the jump instruction, jumping to what was previously saved in x1:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因为可以通过重用跳转指令实现返回，所以没有返回指令，RISC 风格的返回是跳转到之前保存在 x1 中的地址：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That said, a `ret` pseudo-instruction may be provided and assembled into the
    appropriate `jalr` instruction.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`ret` 伪指令可能会被提供并汇编成相应的 `jalr` 指令。
- en: 'Using `ret` enables you to call and return from a single subroutine, with the
    return address kept in x1\. To call nested functions, however, you’ll also need
    a stack. The convention is to have the register x2 (sp) be the stack pointer.
    Here we push a 4-byte word to the stack:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ret` 允许你从单个子程序调用并返回，返回地址保存在 x1 中。然而，要调用嵌套函数，你还需要一个堆栈。约定是将寄存器 x2（sp）作为堆栈指针。这里我们将一个
    4 字节的字推入堆栈：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `addi` instruction means “add immediate,” in this case adding a constant
    (–4) to the stack pointer. (“Immediate” means that an operand contains the value
    itself, rather than an address or register containing the value.) Likewise, here
    we pop from the stack:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`addi` 指令表示“加立即数”，在本例中是将常量（–4）加到堆栈指针。“立即数”意味着操作数本身包含值，而不是包含值的地址或寄存器。同样，这里我们从堆栈弹出：'
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this is done, RISC-style, by reusing existing instructions. Unlike
    CISC style, there are no additional stack instructions such as `push` and `pop`.
    Rather, you have to manage the stack yourself with the reduced instruction set.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，RISC 风格下通过重用现有指令来完成此操作。与 CISC 风格不同，RISC 风格没有像 `push` 和 `pop` 这样的额外堆栈指令。相反，你必须自己管理堆栈，并使用简化的指令集。
- en: '*Extending RISC-V*'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*扩展 RISC-V*'
- en: 'RISC-V also defines many plug-ins or libraries of additional instructions that
    can be implemented optionally. Each of these extensions is given a single-letter
    code, including:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-V 还定义了许多插件或附加指令库，可以选择性地实现。每个扩展都被赋予一个单字母代码，包括：
- en: '**I**     Basic integer add/subtract/shift/bitwise logic'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**I**     基本整数加/减/移位/位运算逻辑'
- en: '**M**     Integer multiplication and division'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**M**     整数乘法和除法'
- en: '**B**     Bitwise Booleans'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**B**     位运算布尔值'
- en: '**F**     Single-precision floating point'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**F**     单倍精度浮点数'
- en: '**D**     Double-precision floating point'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**D**     双倍精度浮点数'
- en: '**Q**     Quad-precision floating point'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Q**     四倍精度浮点数'
- en: To specify a particular ISA, we write “RV” for RISC-V, then the word length,
    then the extensions used. For example, RV64IMF means “RISC-V, 64-bit, with extensions
    I, M, and F.” This design is intended to allow RISC-V to span all applications
    from embedded systems (such as RV8I) to high-end scientific computing clusters.
    Further standard extensions may be proposed as new letters or as arbitrary strings
    beginning with a Z, and local experimental extensions may be proposed as arbitrary
    strings beginning with an X.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定特定的 ISA，我们写“RV”表示 RISC-V，然后是字长，再然后是使用的扩展。例如，RV64IMF 表示“RISC-V，64 位，带有 I、M
    和 F 扩展。”这个设计旨在使 RISC-V 能够涵盖从嵌入式系统（例如 RV8I）到高端科学计算集群的所有应用。可能会提出新的标准扩展，作为新的字母或以
    Z 开头的任意字符串，而本地实验性扩展可能会作为以 X 开头的任意字符串提出。
- en: '**Arithmetic**'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术运算**'
- en: 'Integer arithmetic is performed with three operands. For example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 整数运算使用三个操作数。例如：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Bitwise Boolean operations are similar:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算布尔操作类似：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unusual cases such as division by zero and overflows are reported in the status
    register, which can be queried by further instructions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类似除以零和溢出等特殊情况会报告在状态寄存器中，后续指令可以查询该寄存器。
- en: 'In a RISC architecture, register-to-register operations belong to arithmetic
    rather than to data transfer in order to reduce the number of instructions and
    variations. Thus, there are no extra instructions for placing constants in registers
    or copying data between registers. Instead, we treat these as addition operations,
    with the always-zero x0 register used as one of the operands. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RISC 架构中，寄存器到寄存器的操作属于算术运算，而不是数据传输，以减少指令和变体的数量。因此，没有额外的指令用于将常量放入寄存器或在寄存器之间复制数据。相反，我们将这些视为加法操作，始终为零的
    x0 寄存器作为其中一个操作数。例如：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The RISC-V assembler developed by the mainline RISC-V project includes alternative
    pseudo-instructions for these operations, for programmer convenience:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主流 RISC-V 项目开发的 RISC-V 汇编器包括这些操作的替代伪指令，以方便程序员使用：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These are assembled behind the scenes into the appropriate addition instructions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在后台被汇编成相应的加法指令。
- en: '**Floating Point**'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**浮点数**'
- en: 'Floating-point instructions begin with `f` and act on the floating-point registers,
    f0 to f31, such as:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点指令以 `f` 开头，作用于浮点寄存器 f0 到 f31，例如：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are also instructions to load, store, and compare floats, and convert
    them to and from integers:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些指令用于加载、存储、比较浮点数，并将它们转换为整数，或从整数转换回来：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here the `.s` and `.w` stand for single and word precision. There’s also `d`
    for double. These suffixes are similar to, and perhaps borrowed from, the 68000
    discussed in [Chapter 11](ch11.xhtml). As with integers, RISC style can be seen
    in the clear separation of memory access (load and store) from the arithmetic
    performed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `.s` 和 `.w` 分别代表单精度和字长精度。还有 `d` 代表双精度。这些后缀类似于，甚至可能借鉴自在[第11章](ch11.xhtml)中讨论的68000。与整数一样，RISC风格可以从明确区分内存访问（加载和存储）与执行的算术操作中看出来。
- en: Different RISC-V Implementations
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同的RISC-V实现
- en: As I’ve mentioned, RISC-V is a specification of a family of ISAs of the machine
    code interface between the programmer and the CPU. It doesn’t specify how the
    instructions should be implemented. Architects are free to design their own implementations
    of RISC-V as CPUs from digital logic (or from anything else).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，RISC-V是一个机器代码接口的ISA家族规范，位于程序员与CPU之间。它并不规定指令应如何实现。架构师可以自由设计他们自己的RISC-V实现作为CPU，基于数字逻辑（或其他任何方式）。
- en: 'So far, there are three major open source hardware implementations of RISC-V.
    These are fully open source hardware in the sense that anyone can download, edit,
    and fabricate the files describing the CPU layouts, free of charge. The implementations
    are:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，RISC-V有三个主要的开源硬件实现。这些实现完全开源，任何人都可以免费下载、编辑并制造描述CPU布局的文件，且无需支付费用。具体实现如下：
- en: '**Berkeley Educational cores** These are deliberately simple implementations
    of some limited RISC-V ISAs for educational use, being easier to understand and
    modify. They include non-pipelined and simple pipelined versions.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**伯克利教育核心** 这些是一些有限的RISC-V ISA的简化实现，专为教育用途设计，目的是更容易理解和修改。它们包括非流水线版本和简易流水线版本。'
- en: '**Rocket** This is a family of CPU implementations using professional-quality
    pipelining. It’s a family rather than a single CPU because there are versions
    for different word lengths and for most of the ISA extensions. The Rocket chip
    generator program can generate a particular chip design and layout for most RISC-V
    descriptors.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**火箭** 这是一系列使用专业质量流水线的CPU实现。它是一个系列而非单一CPU，因为有不同字长和大多数ISA扩展的版本。Rocket芯片生成器程序可以为大多数RISC-V描述符生成特定的芯片设计和布局。'
- en: '**BOOM (Berkeley Out-of-Order Machine)** This is a high-performing implementation,
    using state-of-the-art OOOE. It’s a platform for much active research on OOOE
    and other hardware speedups.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**BOOM（伯克利乱序机器）** 这是一种高性能实现，使用最先进的乱序执行（OOOE）。它是进行OOOE及其他硬件加速研究的平台。'
- en: RISC-V Toolchain and Community
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RISC-V工具链与社区
- en: 'RISC-V is more than just an architecture: it’s an open source community and
    ecosystem. For the first time in architecture history, a fully open source architecture
    and toolchain now exists that allows anyone in the world to download it, hack
    it, and burn it onto cheap field programmable gate arrays (FPGAs). These kinds
    of technologies used to be the preserve of a tiny group of professionals working
    at architecture companies, where they were closely guarded secrets. Now anyone
    can access and play with the same kinds of tools as those big companies. As a
    result of this opening up of the tool-chain, together with the pressure to develop
    radically new architectures due to the end of Moore’s law(s), there are now over
    700 architecture start-up companies in Silicon Valley, and more around the world.
    Hennessy and Patterson’s 2017 Turing Award lecture declared a “new golden age”
    of architecture for the 2020s, and they encouraged everyone to get involved with
    this community.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-V不仅仅是一个架构：它是一个开源社区和生态系统。历史上第一次出现了完全开源的架构和工具链，任何人都可以下载、修改并烧录到廉价的现场可编程门阵列（FPGA）上。这类技术过去是架构公司中一小部分专业人士的专属领域，且是严格保密的。现在，任何人都可以使用与这些大公司相同的工具。由于工具链的开放，再加上摩尔定律的终结带来的压力，迫使人们开发全新的架构，目前硅谷已有超过700家架构初创公司，全球更多。Hennessy和Patterson在2017年图灵奖讲座中宣布了2020年代架构的“新黄金时代”，并鼓励大家加入这个社区。
- en: To get involved yourself, you’ll need to download the RISC-V community’s tools
    and tutorials. RISC-V development is *de facto* led by Patterson’s group at the
    University of Berkeley, near Silicon Valley. This group has produced a standard
    set of tools that the community uses to design and build structures from transistor
    layouts all the way up to full CPUs. RISC-V development is usually done in the
    program Chisel, and indeed Chisel is developed by many of the same people as RISC-V.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 若要亲自参与，您需要下载RISC-V社区的工具和教程。RISC-V的开发由位于硅谷附近伯克利大学的Patterson团队*事实上*主导。该团队已制作了一套标准工具，社区用来从晶体管布局到完整的CPU构建设计结构。RISC-V的开发通常在程序Chisel中进行，事实上Chisel是由与RISC-V相同的一些人开发的。
- en: Smart Computer Design
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能计算机设计
- en: For smart computing applications, it’s usually desirable to place a RISC CPU
    on the same silicon as all the other components, such as memory and I/O, needed
    to make a complete computer. Such a chip is known as a *system-on-chip (SoC)*.
    This is a superficially similar idea to embedded microcontrollers, but with substantially
    larger and more powerful designs. An SoC is then typically mounted on a very small
    PCB together with only analog electronics for power management and physical I/O
    connectors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于智能计算应用，通常希望将RISC CPU与所有其他组件（如内存和I/O）放置在同一硅片上，以构建完整的计算机。这样的芯片称为*系统芯片（SoC）*。这与嵌入式微控制器在表面上相似，但设计大且更为强大。SoC通常被安装在一个非常小的PCB上，配有仅用于电源管理和物理I/O连接的模拟电子元件。
- en: 'Computer designers are now taking RISC-V chip designs and putting them onto
    SoCs and hardware boards. There are several commercial and research systems using
    silicon fabrications of RISC-V, including the following examples:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机设计师现在正在将RISC-V芯片设计应用到SoC和硬件板上。有多个商业和研究系统使用RISC-V的硅制造技术，以下是一些例子：
- en: '**HiFive** This closed source, commercial RISC-V product, designed by SiFive,
    was the first practical RISC-V hardware available to the public. It’s a $50 Raspberry
    Pi–style board that uses an OOOE implementation, capable of running Linux for
    applications, similar to the Raspberry Pi.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**HiFive** 这款由SiFive设计的闭源商业RISC-V产品是首个面向公众的实用RISC-V硬件。它是一块价值50美元的类Raspberry
    Pi风格板，采用OOOE实现，能够运行Linux进行应用，类似于Raspberry Pi。'
- en: '**Mango Pi** This is a RISC-V board with similar small form factor and capabilities
    to the Raspberry Pi Zero.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mango Pi** 这是一款RISC-V板，具有与Raspberry Pi Zero类似的小型外形和功能。'
- en: '**lowRISC** This is an ongoing project to design and produce a fully open source
    hardware computer as an SoC, based on a Rocket CPU. To make a full computer, all
    the other non-CPU components also need to be designed as open source hardware,
    in particular I/O and devices for communications, such as USB and Ethernet controllers.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**lowRISC** 这是一个正在进行的项目，旨在设计和生产基于Rocket CPU的完全开源硬件计算机作为SoC。为了制造完整的计算机，所有其他非CPU组件也需要作为开源硬件进行设计，特别是I/O和通信设备，如USB和以太网控制器。'
- en: '**ROMA** This is the first laptop design based on RISC-V. It was released by
    Xcalibyte in 2022.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**ROMA** 这是基于RISC-V的首款笔记本设计。由Xcalibyte于2022年发布。'
- en: Beyond RISC CPUs, smart computing requirements have also led to developments
    in memory and I/O. Let’s look at some of the most common resulting computer design
    elements here.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了RISC CPU，智能计算的需求还推动了内存和I/O的相关发展。让我们来看看一些由此产生的常见计算机设计元素。
- en: '*Low-Power DRAM*'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*低功耗DRAM*'
- en: The DRAM used in phones and other mobile devices is of a special low-power (LP)
    type known as *LP-DRAM*. LP-DRAM is designed to reduce battery usage at the cost
    of some loss of speed and convenience. Primarily, this is achieved by turning
    off the power to large areas of memory that aren’t in use. This destroys their
    volatile contents but greatly reduces power consumption, as no electricity is
    needed to continually refresh the memory. The main cost is a delay in reactivating
    these regions when they’re needed again. For example, your phone’s batteries will
    last longer on an LP-DRAM machine if you close down all unnecessary apps, because
    the operating system will then free the memory they were using, which can be turned
    off to save power.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 手机和其他移动设备中使用的DRAM是一种特殊的低功耗（LP）类型，称为*LP-DRAM*。LP-DRAM的设计目的是通过减少电池使用来牺牲一定的速度和便利性。这主要是通过关闭不使用的大块内存电源来实现的。这会破坏它们的易失性内容，但大大减少了功耗，因为不需要持续刷新内存。主要的成本是当这些区域再次需要时，重新激活它们的延迟。例如，当你关闭所有不必要的应用时，你手机的电池会在LP-DRAM机器上使用更久，因为操作系统会释放它们占用的内存，这些内存可以关闭以节省电力。
- en: Like DRAM, LP-DRAM has been through many standards iterations. Various additional
    innovations beyond power switching include operating on reduced voltages such
    as 1.8 V, scaling the refresh rate as a function of temperature to reduce unnecessary
    refresh work, and multiple levels of shutdowns. The latter may be used to differentiate
    between a user putting their phone away in their pocket for many hours versus
    temporarily freeing memory from an app while continuing to use the rest of the
    phone.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与DRAM类似，LP-DRAM也经历了多个标准迭代。除了功率切换外，还包括在降低电压（如1.8 V）下工作，按照温度调整刷新率以减少不必要的刷新工作，以及多个级别的关机模式。后者可以用于区分用户将手机放入口袋长时间不使用，或者在继续使用手机其他部分时暂时释放某个应用的内存。
- en: '*Cameras*'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*摄像头*'
- en: Camera sensors, as shown in [Figure 14-2](ch14.xhtml#ch14fig2), are active pixel
    sensors made from CMOS-like chips.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头传感器，如[图14-2](ch14.xhtml#ch14fig2)所示，是由类似CMOS的芯片构成的主动像素传感器。
- en: '![Image](../images/f0351-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0351-01.jpg)'
- en: '*Figure 14-2: A camera sensor (left) and a close-up showing its pixels (right)*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：左侧为摄像头传感器，右侧为其像素的特写图*'
- en: Camera sensors are formed from 2D arrays of light sensors (pixels) created through
    photolithography, like chips. Usually each pixel contains three subpixels for
    sensing red, green, and blue light, as in displays.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头传感器是由通过光刻工艺创建的二维光传感器阵列（像素）构成的，类似于芯片。通常每个像素包含三个子像素，用于感应红色、绿色和蓝色光，就像显示屏一样。
- en: '*Touchscreens*'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*触摸屏*'
- en: The touchscreen used in a phone or tablet is produced as a distinct, transparent
    layer from the display screen placed beneath it. Like chips, touch-screens are
    produced via photolithography; layers of different materials are laid down in
    a pixel grid of small half-capacitors, as shown in [Figure 14-3](ch14.xhtml#ch14fig3).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 手机或平板使用的触摸屏是作为一层透明的独立层，与其下方的显示屏分开生产的。像芯片一样，触摸屏通过光刻工艺生产；不同材料的层被铺设成小半电容的像素网格，正如[图14-3](ch14.xhtml#ch14fig3)所示。
- en: '![Image](../images/f0351-02.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0351-02.jpg)'
- en: '*Figure 14-3: A touchscreen made from an array of half-capacitors, with 2D
    addressing*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：由半电容器阵列构成的触摸屏，具有二维寻址*'
- en: Human skin acts as the other half of the capacitor when in close proximity to
    these pixels, making the grid touch-sensitive.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当人类皮肤接近这些像素时，皮肤作为电容器的另一半，使得网格具有触摸敏感性。
- en: To enable the touchscreen to act as a layer above a visible display, we need
    to build these half-capacitors and the wires connected to them from a material
    that’s both conductive (a metal) and also transparent to human-visible red, green,
    and blue light. This is a difficult requirement, because metals generally reflect
    all frequencies of light. Indium tin oxide (ITO) is a very unusual compound, based
    on the rare element indium, that happens to have the desired property, so it’s
    used in most touchscreens.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让触摸屏能够作为显示屏上方的一层工作，我们需要用一种既导电（是金属）又对人眼可见的红、绿、蓝光透明的材料来构建这些半电容器及其连接的电线。这是一个非常难的要求，因为金属通常会反射所有光频。氧化铟锡（ITO）是一种非常特殊的化合物，基于稀有元素铟，恰好具有这种所需的性质，因此它被广泛应用于大多数触摸屏。
- en: '**NOT SO DIFFERENT AFTER ALL?**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**最终并没有那么不同吗？**'
- en: Unlike CISC, RISC doesn’t add extra instructions to make life easier for the
    programmer, who instead must often make use of sequences of more basic, general-purpose
    instructions with particular operands. This can make manual RISC assembly programming
    less interesting than CISC programming, but RISC assemblers can provide pseudo-instructions
    that function similarly to CISC instructions but are assembled into sequences
    of multiple RISC instructions. It’s also possible to build CISC architectures
    that do similar but in digital logic, fetching CISC-style instructions but decoding
    them into *sequences* of RISC instructions that are then executed in RISC style.
    Such designs look internally quite similar to the CISC microcode structures, suggesting
    that CISC and RISC don’t have to be so different after all.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与CISC不同，RISC并不会添加额外的指令来简化程序员的工作，程序员往往必须利用更基本的、通用的指令序列以及特定的操作数。这可能会使手动编写RISC汇编程序比CISC程序更不那么有趣，但RISC汇编器可以提供伪指令，这些指令的功能类似于CISC指令，但会被汇编成多个RISC指令的序列。也可以构建类似的CISC架构，通过数字逻辑方式获取CISC风格的指令，再将其解码成*RISC指令序列*，然后按RISC风格执行。这样的设计在内部看起来与CISC微代码结构非常相似，表明CISC和RISC其实并不需要那么不同。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Smart devices are replacing embedded systems in many applications as the cost
    and power consumption of general-purpose computing falls and battery technology
    improves. RISC architectures are a good fit for smart computing needs, as their
    simplicity can reduce physical size, cost, and power requirements.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 随着通用计算成本和功耗的下降以及电池技术的进步，智能设备正在取代许多应用中的嵌入式系统。RISC架构非常适合智能计算需求，因为其简单性可以降低物理体积、成本和功耗要求。
- en: RISC architectures use small sets of simple instructions. They typically make
    a clean separation between instructions for memory access and for arithmetic.
    They try to have all instructions execute in the same time in order to simplify
    execution and enable smoother pipelining and OOOE. RISC assembly code is usually
    characterized by its appearance as homogeneous-looking lists of instructions with
    triple operands.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: RISC架构使用一小组简单的指令。它们通常在内存访问和算术指令之间做出明确的区分。它们试图使所有指令在相同的时间内执行，从而简化执行并实现更顺畅的流水线和乱序执行（OOOE）。RISC汇编代码通常以看起来相似的指令列表形式出现，每条指令有三个操作数。
- en: RISC-V is an open source family of RISC ISAs, with both open and closed source
    digital logic implementations and design toolchains available. RISC-V includes
    a core instruction set and various optional extension instruction sets, so variants
    can be used for small, cheap smart devices, and all the way up to higher-power
    servers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: RISC-V是一个开放源代码的RISC指令集架构（ISA）系列，提供开放和闭源的数字逻辑实现以及设计工具链。RISC-V包括一个核心指令集和各种可选的扩展指令集，因此可以用于小型、廉价的智能设备，一直到更高功率的服务器。
- en: Exercises
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**RISC-V Programming**'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**RISC-V编程**'
- en: Install and run the Jupiter RISC-V simulator from *[https://github.com/andrescv/Jupiter](https://github.com/andrescv/Jupiter)*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*[https://github.com/andrescv/Jupiter](https://github.com/andrescv/Jupiter)*安装并运行Jupiter
    RISC-V模拟器。
- en: 'Enter some simple programs from the examples in this chapter. Jupiter requires
    a label called `__start` (with two underscores) to be defined and made global;
    this will be used as the entry point when the program runs. For example:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本章的示例中输入一些简单的程序。Jupiter要求定义并使`__start`（带有两个下划线）成为全局标签；当程序运行时，这将作为入口点。例如：
- en: '[PRE14]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you have data lines in your program, then by default Jupiter assumes a Harvard-style
    segmentation, which requires `.data` and `.txt` sections, such as:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的程序中有数据行，那么默认情况下Jupiter假设采用哈佛式分段，这需要`.data`和`.txt`部分，例如：
- en: '[PRE15]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save and assemble each program (**Run ▸ Assemble**) and run it in the simulator.
    You can place breakpoints at any time with the tick-boxes on the left of the lines,
    and inspect the registers and memory with the GUI on the right. To get back to
    the code, click **Editor** at the top left.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并组装每个程序（**运行 ▸ 组装**），并在模拟器中运行它。你可以随时通过左侧行的勾选框设置断点，并通过右侧的GUI查看寄存器和内存。要返回代码，点击左上角的**编辑器**。
- en: '**Challenging**'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**具有挑战性**'
- en: Try porting previous programs from the Analytical Engine and Manchester Baby
    to run on RISC-V. What’s easier or harder to do in modern RISC-V compared to those
    systems? How does it feel compared to x86?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试将之前的程序从分析机和曼彻斯特宝宝移植到RISC-V上运行。在现代RISC-V系统上与那些系统相比，哪些事情变得更容易或更困难？与x86相比感觉如何？
- en: Obtain a physical RISC-V board and use its tools and documents to run the same
    programs on it.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一块物理RISC-V板，并使用其工具和文档在上面运行相同的程序。
- en: '**More Challenging**'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**更具挑战性**'
- en: Want to make a real, working CPU in your bedroom? Using RISC-V and Chisel, you
    can.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 想在你的卧室里制作一台真正可工作的CPU吗？使用RISC-V和Chisel，你可以做到。
- en: A full Chisel tutorial can be found at *[https://github.com/ucb-bar/chisel-tutorial](https://github.com/ucb-bar/chisel-tutorial)*.
    Install Chisel and work through this tutorial.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在*[https://github.com/ucb-bar/chisel-tutorial](https://github.com/ucb-bar/chisel-tutorial)*找到完整的Chisel教程。安装Chisel并完成该教程。
- en: All of the microcircuits used in Rocket and BOOM—including ALU, FPU, and control
    unit—are available as Chisel libraries. Download and build some of these and experiment
    with how they work.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rocket和BOOM中使用的所有微电路——包括ALU、FPU和控制单元——都可以作为Chisel库使用。下载并构建其中一些，尝试了解它们的工作原理。
- en: The Rocket Chip Generator (*[https://github.com/chipsalliance/rocket-chip](https://github.com/chipsalliance/rocket-chip)*)
    is a tool that takes a RISC-V CPU descriptor code such as RV64IMFP as input, and
    outputs Chisel and Verilog files (or a C++ simulation) for the desired CPU. Install
    and run Rocket Chip. Study the outputs to find out how the microcircuits you looked
    at in the previous problem are used in the generated CPU.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rocket Chip生成器 (*[https://github.com/chipsalliance/rocket-chip](https://github.com/chipsalliance/rocket-chip)*)
    是一个工具，接受RISC-V CPU描述代码（如RV64IMFP）作为输入，并输出所需CPU的Chisel和Verilog文件（或C++模拟）。安装并运行Rocket
    Chip。研究输出结果，找出你在前一个问题中查看的微电路如何在生成的CPU中使用。
- en: Torture (*[https://github.com/ucb-bar/riscv-torture](https://github.com/ucb-bar/riscv-torture)*)
    is a tool provided by the RISC-V community to test correct RISC-V execution in
    hardware designs, and to help locate errors. Install it, introduce a deliberate
    error to a Rocket Chip design, and use the tool to study the error.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Torture (*[https://github.com/ucb-bar/riscv-torture](https://github.com/ucb-bar/riscv-torture)*)
    是RISC-V社区提供的一个工具，用于测试硬件设计中RISC-V执行的正确性，并帮助定位错误。安装该工具，故意在Rocket Chip设计中引入一个错误，并使用该工具来研究错误。
- en: Buy a cheap FPGA board and use the RISC-V documentation and mailing list archives
    to figure out how to burn your Rocket Chip netlist onto it to make a real physical
    CPU.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 买一个便宜的FPGA开发板，使用RISC-V文档和邮件列表档案，弄清楚如何将你的Rocket Chip网表烧录到板子上，制作一个真正的物理CPU。
- en: Join the RISC-V community discussions at *[https://riscv.org](https://riscv.org)*
    and study the open lowRISC designs at *[https://github.com/lowrisc](https://github.com/lowrisc)*.
    Use them to find an interesting piece of work that needs doing and contribute
    it to the RISC-V community.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加入RISC-V社区讨论，访问 *[https://riscv.org](https://riscv.org)*，并研究开放的lowRISC设计，网址是
    *[https://github.com/lowrisc](https://github.com/lowrisc)*。利用这些资源，找到需要完成的有趣工作并为RISC-V社区做出贡献。
- en: Further Reading
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For a detailed RISC-V tutorial, see Edson Borin, *An Introduction to Assembly
    Programming with RISC-V*, *[https://riscv-programming.org/book/riscv-book.html](https://riscv-programming.org/book/riscv-book.html)*.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想了解详细的RISC-V教程，请参考Edson Borin的 *《RISC-V汇编编程导论》*，网址是 *[https://riscv-programming.org/book/riscv-book.html](https://riscv-programming.org/book/riscv-book.html)*。
- en: 'For the definitive RISC-V manual, see Andrew Waterman and Krste Asanović (eds.),
    *The RISC-V Instruction Set Manual Volume I: User-Level ISA* (Berkeley: RISC-V
    Foundation), *[https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf)*.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要获得权威的RISC-V手册，请参考Andrew Waterman和Krste Asanović（编辑），*RISC-V指令集手册第一卷：用户级ISA*（伯克利：RISC-V基金会），*[https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf)*。
