- en: '**14**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SMART ARCHITECTURES**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0339-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Smart computing* means general-purpose computers built into low-power and/or
    mobile devices, such as phones, tablets, TVs, routers, and fridges. Unlike embedded
    systems, they run multiple easily installable and upgradable programs, often known
    as *apps*. Unlike desktop systems, they need to reduce power consumption, as they
    often run from batteries. *Reduced instruction set computing (RISC)* is a good
    fit for these requirements, so RISC architectures are generally found in smart
    systems. This chapter explores the RISC philosophy, smart devices, and the details
    of a particular RISC architecture, RISC-V. It’s shorter than the desktop chapter
    because RISC is simpler than CISC by design.'
  prefs: []
  type: TYPE_NORMAL
- en: Smart Devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Early mobile phones were embedded systems whose primary purpose was to function
    as voice telephones. They had microcontrollers programmed to manage the telephone
    and user interaction via buttons and simple number-displaying screens. Over time,
    these microprocessors and interaction devices grew, and the firmware was extended
    to include features such as contact books, alarm clocks, and simple games like
    *Snake*.
  prefs: []
  type: TYPE_NORMAL
- en: Modern smartphones now provide such features, and many more, as software apps
    rather than firmware. They’ve replaced microcontrollers with fully fledged general-purpose
    architectures that typically run an operating system such as LineageOS, Replicant,
    or Android to host apps, much like a desktop PC.
  prefs: []
  type: TYPE_NORMAL
- en: The prefix *smart* emerged to describe these phones, but it’s now applied to
    anything that used to be an embedded system but has been upgraded to a general-purpose
    computer. For example, smart TVs (the left of [Figure 14-1](ch14.xhtml#ch14fig1))
    and smart fridges have moved beyond microcontrollers and firmware to the point
    where they can easily install and run multiple apps.
  prefs: []
  type: TYPE_NORMAL
- en: The modern consumer internet connection device shown on the right of [Figure
    14-1](ch14.xhtml#ch14fig1) and widely but wrongly known as a “router” is another
    example of a smart computer. Such devices now usually contain an operating system
    running many services, including routing, Wi-Fi, firewalling, and a web server
    (at least to run its configuration page). They should probably be renamed “smart
    routers” for this reason.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0340-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The inside of a Toshiba smart TV (left) and a Zyxel router (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: The “smart home” has been a computing industry ambition for several decades,
    and refers to a home in which most or all of the usual domestic appliances are
    upgraded to networked, general-purpose computers. For example, smart washing machines
    and smart central heating controllers will enable innovative, machine learning–based
    apps to compete against one another to make the best use of energy, given data
    from sensors monitoring the condition of clothes to be washed and the temperatures
    and usages of rooms. Linking these systems will enable automation chains such
    as your smart fridge predicting that the milk will run out later today, and placing
    an automatic order to the local supermarket to deliver more, perhaps via a last-mile
    delivery robot and a smart drop-off box to receive the delivery. Or your heating
    system and fridge could be temporarily turned off while the washing machine is
    turned on, so that it can be powered entirely from the batteries in your parked
    electric car, charged from your solar panels, without needing to use the power
    grid.
  prefs: []
  type: TYPE_NORMAL
- en: Architectures for smart devices have similar requirements to embedded systems
    around reliability and energy usage. However, they also need more computing power
    than embedded microcontrollers. These requirements are a perfect match for the
    RISC philosophy, so let’s examine this philosophy in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: RISC Philosophy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RISC concept was invented by an American, David Patterson, but most successfully
    commercialized by the British. Patterson’s quantitative approach to architecture
    involved a statistical analysis of the instructions actually being used by real-world
    programs on processors of the 1990s. He found that the more complex instructions
    were used very rarely, in part because compiler back-end designers didn’t know
    or want to learn how to use them. He determined that roughly 90 percent of the
    work was being done by roughly 10 percent of the resources. This led him to the
    central RISC tenet that the silicon occupied by the rarely used instructions would
    be better put to work making the most popular 10 percent of instructions run very
    fast, at the expense of removing the other instructions altogether. Patterson
    and his co-architect, John Hennessy, won the 2017 Turing Award for their research
    on the use of quantitative methods to guide RISC architecture design.
  prefs: []
  type: TYPE_NORMAL
- en: RISC usually aims for every one of its streamlined set of instructions to be
    executed in a single CPU cycle. With fewer instructions available, RISC assembly
    programs are often quite verbose, but each instruction is simple, fast, and low-power
    to execute. Writing programs in RISC assembly and writing compilers for RISC is
    easy and fun because the instruction set architectures (ISAs) are small, simple,
    and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: RISC CPUs themselves aren’t necessarily simple, however. While the instruction
    sets are by definition smaller, designers have found alternative ways to make
    efficient use of the available silicon. For example, RISC processors typically
    have many more registers than their CISC counterparts. Extra registers are especially
    useful in RISC because they help separate memory access from arithmetic. In RISC
    programming and RISC compilers, it’s common to try to bring all relevant variables
    into registers at the start of a subroutine, then do the entire function’s computations
    in registers, storing only the result back to main memory. This contrasts with
    CISC, where there can be continual loading and storing throughout the subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Because part of the RISC philosophy is that every instruction should execute
    in exactly one clock cycle, instruction-level parallelism through pipelining,
    branch prediction, and out-of-order execution (OOOE) are massively easier to manage.
    Every instruction has the same fetch-decode-execute step duration, and each phase
    can be triggered regularly in open-loop style. Compare this with CISC architectures,
    where steps of different instructions can take different durations and must closed-loop
    trigger each other to say when they’ve been completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'RISC was traditionally seen as a very academic philosophy, being beautiful
    in its design, lean and mean in its execution, and generally resisting the temptation
    to make a fast buck by bolting on new features to please specific customers by
    next Thursday. It was often associated with Britain and the British company ARM,
    though it originated at the University of California, Berkeley—located near to
    but separated from Silicon Valley. The stereotypical RISC advocate was more interested
    in beauty and cleverness of design than pragmatism, and for a long time such people
    were laughed at by more commercial-minded Silicon Valley architects. However,
    this is now changing: the beauty of RISC is paying off. Most processors now manufactured
    are RISC. This is largely due to the trend of smart and embedded devices replacing
    desktops, though serious thoughts are now turning to RISC for cloud servers, too.
    In 2020, Apple also moved its desktop machines to the RISC-based M1 architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FROM ACORN TO ARM**'
  prefs: []
  type: TYPE_NORMAL
- en: The British company Acorn used the 6502 in their BBC Micro (“Beeb”), a classic
    piece of British engineering, brilliantly designed but commercially mistimed and
    mispositioned. Like much British technology, the Micro was government-funded,
    in this case via the national broadcaster, the BBC, who wanted a custom-designed,
    mass-market machine to go with an educational TV series.
  prefs: []
  type: TYPE_NORMAL
- en: Hackers today often play at buying a 6502 and building an 8-bit computer around
    it on a breadboard, and that was just what the Beeb designers did. Acorn was founded
    by a bunch of Cambridge people who used that pedigree to convince the establishment
    BBC to choose their design. The BBC gave a huge specification list for what their
    computer needed for their TV series. This had a strong education and science—rather
    than gaming—influence. For example, they didn’t include a joystick port but did
    include options for coprocessors and interfacing to maker-style electronics.
  prefs: []
  type: TYPE_NORMAL
- en: One year after the Beeb’s release, the Commodore 64 appeared, designed to be
    “for the masses, not the classes.” It had superior graphics and sound for game
    playing, and came at a much lower price. The C64 filled the full 64 k[2]B of addressable
    RAM, while the Beeb filled only 32 k[2]B. The C64 had the glorious SID sound chip,
    while the Beeb had only basic square waves, white noise, and amplitude envelopes
    from the poorer SN76489\. Commodore had by this point bought out MOS, so it could
    involve the designers of the 6502 and related chips—including Chuck Peddle—directly
    in its computer designs to exploit its most advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: The C64 quickly made the Beeb seem overspecified and overpriced. However, Acorn
    used the Beeb internally to design their first RISC processor, the Acorn RISC
    Machine (ARM), for their next computer, the Archimedes—a fully 32-bit machine,
    released in 1987\. Archimedes was technically a decade ahead of its time, though
    temporally and culturally it still belonged to the “16/32-bit era.” It was again
    sadly mismarketed, overspecified, and overpriced—for example, having eight-channel
    audio compared to the Amiga’s four, yet no joystick ports or TV output for games.
  prefs: []
  type: TYPE_NORMAL
- en: Acorn went on to spin out a new company, ARM, to focus on its ARM chip designs.
    ARM found success, as its chips now power most of the world’s smartphones, the
    M1 used in Apple’s tablets and desktops, and many smart devices such as the chips
    seen in [Figure 14-1](ch14.xhtml#ch14fig1).
  prefs: []
  type: TYPE_NORMAL
- en: Computing history could have been very different if the BBC had waited an extra
    year to put a C64 into every UK school. Commodore’s business management faced
    challenges that led to bankruptcy in 1994, but acceptance by the British establishment
    might have provided the stability needed to survive.
  prefs: []
  type: TYPE_NORMAL
- en: A strange legacy has been that Acorn’s OS for Archimedes, RISCOS, is still compatible
    with the latest ARM ISAs. It was painstakingly hand-coded in ARM assembly to squeeze
    power out of early 1990s CPUs, so it now runs blindingly fast on modern devices
    such as the Raspberry Pi. There’s been a resurgence of old Acorn user groups around
    this, in some cases resulting in old friends meeting up for the first time in
    30 years.
  prefs: []
  type: TYPE_NORMAL
- en: RISC-V
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ARM’s RISC ISA designs are heavily patented, but others in the industry now
    wish for fully open source RISC ISA alternatives. As with the IBM-Intel-AMD license,
    computer builders want to genericize the ISA and enable multiple implementations
    to drive down processor prices through competition. A large consortium of major
    Silicon Valley companies is therefore now backing Patterson’s latest and fully
    open source RISC ISA family design, called RISC-V (V for, and pronounced, “five”),
    as the next standard for RISC. Note that RISC-V is a family of ISAs, not a hardware
    implementation of these ISAs. Companies may implement the open source ISAs in
    proprietary hardware and compete on implementation quality. There are also fully
    open source implementations by Patterson’s group and other members of the RISC-V
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: '*Understanding the Architecture*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: RISC-V is designed as a family of ISAs, rather than a single ISA. The family
    includes versions suitable for embedded, mobile, desktop, and server machines,
    including versions for 32-, 64-, and 128-bit ISAs. RISC-V defines a core ISA of
    instructions that all RISC-V systems need to implement. Like x86, RISC-V uses
    per-byte, little-endian addressing. RISC-V uses RISC-style instructions that separate
    memory access from arithmetic logic unit (ALU) operations. It’s not an accumulator
    architecture, and ALU instructions explicitly specify the output register, so
    they usually have three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve discussed, the RISC philosophy is to reduce the number of instructions
    as much as possible. This means that some operations that you would usually expect
    to find in an ISA are absent if they can be achieved through other means, such
    as by calling other instructions in slightly odd ways. When such unusual uses
    of instructions are needed, RISC-V assemblers will sometimes provide *pseudo-instructions*
    that look like the classic instructions you expect. The assembler then converts
    them to the underlying, somewhat ugly RISC instructions. To a limited extent,
    some of the complexity of CISC digital logic is thus moved into the assembler,
    while keeping the machine code itself clean.
  prefs: []
  type: TYPE_NORMAL
- en: RISC-V registers have standard names and standard conventions for their typical
    uses, such as how to pass arguments to subroutines by storing them in registers.
    For example, the integer registers are always called x0 to x32 (and x0 always
    contains the constant 0). The RISC designers gave the integer registers secondary
    nickname mnemonics, shown in [Table 14-1](ch14.xhtml#ch14tab1), to encourage conventions
    for their use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-1:** RISC-V Integer Registers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Mnemonic** | **Intended convention** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x0 | zero | Value is always zero |'
  prefs: []
  type: TYPE_TB
- en: '| x1 | ra | Return address for subroutine calls |'
  prefs: []
  type: TYPE_TB
- en: '| x2 | sp | Stack pointer |'
  prefs: []
  type: TYPE_TB
- en: '| x3 | gp | Global pointer |'
  prefs: []
  type: TYPE_TB
- en: '| x4 | tp | Thread pointer |'
  prefs: []
  type: TYPE_TB
- en: '| x5–x7 | t0–t2 | Temporary |'
  prefs: []
  type: TYPE_TB
- en: '| x8–x9 | s0–s1 | Saved |'
  prefs: []
  type: TYPE_TB
- en: '| x10–x14 | a0–a7 | Arguments for subroutine calls |'
  prefs: []
  type: TYPE_TB
- en: '| x18–x27 | s2–s11 | Saved |'
  prefs: []
  type: TYPE_TB
- en: '| x28–x31 | t3–t6 | Temporary |'
  prefs: []
  type: TYPE_TB
- en: As with instructions and pseudo-instructions, this is designed to keep the underlying
    architecture very clean and simple, while also providing the ability to think
    and code in terms of some CISC-like styles, if and only if the programmer wants
    to do that.
  prefs: []
  type: TYPE_NORMAL
- en: There may be a further 32 optional floating-point registers, also given mnemonics,
    which you can see in [Table 14-2](ch14.xhtml#ch14tab2).
  prefs: []
  type: TYPE_NORMAL
- en: The intended calling conventions for registers starting with *t* and *s* are
    temporary and safe—the same concepts seen but less standardized in the x86 calling
    conventions from [Chapter 13](ch13.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-2:** RISC-V Floating-Point Registers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Mnemonic** | **Intended convention** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| f0–7 | ft0–7 | Floating-point temporaries |'
  prefs: []
  type: TYPE_TB
- en: '| f8–9 | fs0–1 | Floating-point saved registers |'
  prefs: []
  type: TYPE_TB
- en: '| f10–11 | fa0–1 | Floating-point arguments/return values |'
  prefs: []
  type: TYPE_TB
- en: '| f12–17 | fa2–7 | Floating-point arguments |'
  prefs: []
  type: TYPE_TB
- en: '| f18–27 | fs2–11 | Floating-point saved registers |'
  prefs: []
  type: TYPE_TB
- en: '| f28–31 | ft8–11 | Floating-point temporaries |'
  prefs: []
  type: TYPE_TB
- en: As with x86, the user can’t access internal registers directly. These internal
    registers include a program counter and status register.
  prefs: []
  type: TYPE_NORMAL
- en: '*Programming Core RISC-V*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ve seen the basic structures, let’s use them in some instructions to
    write RISC-V programs. As with the other architectures we’ve studied, we’ll first
    introduce data moves and control flow. RISC-V then has various optional extensions,
    including arithmetic, which we’ll also explore.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Moves**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As a RISC system, data movement involving primary memory is cleanly separated
    from all other operations, which are performed only on data in registers. Loading
    from memory to registers, and storing to memory from registers, is done by the
    following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that like NASM and Arduino assembly, RISC-V assembly writes the destination
    register first, followed by the inputs. You can see the RISC nature of the `lw`
    and `sw` instructions in the requirement for all three operands, even when the
    third operand is a 0 and thus isn’t being used, rather than providing a second
    form of these instructions with only two operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, a pseudo-instruction is provided to load content from a labeled
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This actually gets assembled to two instructions. First, an `la` obtains the
    address of the label, and then an `lw` loads the content of that address.
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, unlike in CISC, these instructions aren’t reused to copy data between
    registers. This clean separation of memory access instructions from between-register
    operations is often considered to be a defining feature of RISC. We’ll discuss
    how this is done in the “Arithmetic” section on [page 347](ch14.xhtml#ch14lev1sec2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Flow**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unconditional jumps come in two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Conditional jumps include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Subroutines are called by “jump and link.” The “link” here refers to saving
    the program counter in a register. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is why x1 is nicknamed ra, for return address.
  prefs: []
  type: TYPE_NORMAL
- en: 'There isn’t a return instruction because returning can be done, RISC-style,
    by reusing the jump instruction, jumping to what was previously saved in x1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That said, a `ret` pseudo-instruction may be provided and assembled into the
    appropriate `jalr` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `ret` enables you to call and return from a single subroutine, with the
    return address kept in x1\. To call nested functions, however, you’ll also need
    a stack. The convention is to have the register x2 (sp) be the stack pointer.
    Here we push a 4-byte word to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addi` instruction means “add immediate,” in this case adding a constant
    (–4) to the stack pointer. (“Immediate” means that an operand contains the value
    itself, rather than an address or register containing the value.) Likewise, here
    we pop from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is done, RISC-style, by reusing existing instructions. Unlike
    CISC style, there are no additional stack instructions such as `push` and `pop`.
    Rather, you have to manage the stack yourself with the reduced instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: '*Extending RISC-V*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'RISC-V also defines many plug-ins or libraries of additional instructions that
    can be implemented optionally. Each of these extensions is given a single-letter
    code, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**I**     Basic integer add/subtract/shift/bitwise logic'
  prefs: []
  type: TYPE_NORMAL
- en: '**M**     Integer multiplication and division'
  prefs: []
  type: TYPE_NORMAL
- en: '**B**     Bitwise Booleans'
  prefs: []
  type: TYPE_NORMAL
- en: '**F**     Single-precision floating point'
  prefs: []
  type: TYPE_NORMAL
- en: '**D**     Double-precision floating point'
  prefs: []
  type: TYPE_NORMAL
- en: '**Q**     Quad-precision floating point'
  prefs: []
  type: TYPE_NORMAL
- en: To specify a particular ISA, we write “RV” for RISC-V, then the word length,
    then the extensions used. For example, RV64IMF means “RISC-V, 64-bit, with extensions
    I, M, and F.” This design is intended to allow RISC-V to span all applications
    from embedded systems (such as RV8I) to high-end scientific computing clusters.
    Further standard extensions may be proposed as new letters or as arbitrary strings
    beginning with a Z, and local experimental extensions may be proposed as arbitrary
    strings beginning with an X.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Integer arithmetic is performed with three operands. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Bitwise Boolean operations are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unusual cases such as division by zero and overflows are reported in the status
    register, which can be queried by further instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a RISC architecture, register-to-register operations belong to arithmetic
    rather than to data transfer in order to reduce the number of instructions and
    variations. Thus, there are no extra instructions for placing constants in registers
    or copying data between registers. Instead, we treat these as addition operations,
    with the always-zero x0 register used as one of the operands. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The RISC-V assembler developed by the mainline RISC-V project includes alternative
    pseudo-instructions for these operations, for programmer convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These are assembled behind the scenes into the appropriate addition instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating Point**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Floating-point instructions begin with `f` and act on the floating-point registers,
    f0 to f31, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also instructions to load, store, and compare floats, and convert
    them to and from integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here the `.s` and `.w` stand for single and word precision. There’s also `d`
    for double. These suffixes are similar to, and perhaps borrowed from, the 68000
    discussed in [Chapter 11](ch11.xhtml). As with integers, RISC style can be seen
    in the clear separation of memory access (load and store) from the arithmetic
    performed.
  prefs: []
  type: TYPE_NORMAL
- en: Different RISC-V Implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I’ve mentioned, RISC-V is a specification of a family of ISAs of the machine
    code interface between the programmer and the CPU. It doesn’t specify how the
    instructions should be implemented. Architects are free to design their own implementations
    of RISC-V as CPUs from digital logic (or from anything else).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, there are three major open source hardware implementations of RISC-V.
    These are fully open source hardware in the sense that anyone can download, edit,
    and fabricate the files describing the CPU layouts, free of charge. The implementations
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Berkeley Educational cores** These are deliberately simple implementations
    of some limited RISC-V ISAs for educational use, being easier to understand and
    modify. They include non-pipelined and simple pipelined versions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rocket** This is a family of CPU implementations using professional-quality
    pipelining. It’s a family rather than a single CPU because there are versions
    for different word lengths and for most of the ISA extensions. The Rocket chip
    generator program can generate a particular chip design and layout for most RISC-V
    descriptors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**BOOM (Berkeley Out-of-Order Machine)** This is a high-performing implementation,
    using state-of-the-art OOOE. It’s a platform for much active research on OOOE
    and other hardware speedups.'
  prefs: []
  type: TYPE_NORMAL
- en: RISC-V Toolchain and Community
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RISC-V is more than just an architecture: it’s an open source community and
    ecosystem. For the first time in architecture history, a fully open source architecture
    and toolchain now exists that allows anyone in the world to download it, hack
    it, and burn it onto cheap field programmable gate arrays (FPGAs). These kinds
    of technologies used to be the preserve of a tiny group of professionals working
    at architecture companies, where they were closely guarded secrets. Now anyone
    can access and play with the same kinds of tools as those big companies. As a
    result of this opening up of the tool-chain, together with the pressure to develop
    radically new architectures due to the end of Moore’s law(s), there are now over
    700 architecture start-up companies in Silicon Valley, and more around the world.
    Hennessy and Patterson’s 2017 Turing Award lecture declared a “new golden age”
    of architecture for the 2020s, and they encouraged everyone to get involved with
    this community.'
  prefs: []
  type: TYPE_NORMAL
- en: To get involved yourself, you’ll need to download the RISC-V community’s tools
    and tutorials. RISC-V development is *de facto* led by Patterson’s group at the
    University of Berkeley, near Silicon Valley. This group has produced a standard
    set of tools that the community uses to design and build structures from transistor
    layouts all the way up to full CPUs. RISC-V development is usually done in the
    program Chisel, and indeed Chisel is developed by many of the same people as RISC-V.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Computer Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For smart computing applications, it’s usually desirable to place a RISC CPU
    on the same silicon as all the other components, such as memory and I/O, needed
    to make a complete computer. Such a chip is known as a *system-on-chip (SoC)*.
    This is a superficially similar idea to embedded microcontrollers, but with substantially
    larger and more powerful designs. An SoC is then typically mounted on a very small
    PCB together with only analog electronics for power management and physical I/O
    connectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computer designers are now taking RISC-V chip designs and putting them onto
    SoCs and hardware boards. There are several commercial and research systems using
    silicon fabrications of RISC-V, including the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HiFive** This closed source, commercial RISC-V product, designed by SiFive,
    was the first practical RISC-V hardware available to the public. It’s a $50 Raspberry
    Pi–style board that uses an OOOE implementation, capable of running Linux for
    applications, similar to the Raspberry Pi.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mango Pi** This is a RISC-V board with similar small form factor and capabilities
    to the Raspberry Pi Zero.'
  prefs: []
  type: TYPE_NORMAL
- en: '**lowRISC** This is an ongoing project to design and produce a fully open source
    hardware computer as an SoC, based on a Rocket CPU. To make a full computer, all
    the other non-CPU components also need to be designed as open source hardware,
    in particular I/O and devices for communications, such as USB and Ethernet controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ROMA** This is the first laptop design based on RISC-V. It was released by
    Xcalibyte in 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond RISC CPUs, smart computing requirements have also led to developments
    in memory and I/O. Let’s look at some of the most common resulting computer design
    elements here.
  prefs: []
  type: TYPE_NORMAL
- en: '*Low-Power DRAM*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The DRAM used in phones and other mobile devices is of a special low-power (LP)
    type known as *LP-DRAM*. LP-DRAM is designed to reduce battery usage at the cost
    of some loss of speed and convenience. Primarily, this is achieved by turning
    off the power to large areas of memory that aren’t in use. This destroys their
    volatile contents but greatly reduces power consumption, as no electricity is
    needed to continually refresh the memory. The main cost is a delay in reactivating
    these regions when they’re needed again. For example, your phone’s batteries will
    last longer on an LP-DRAM machine if you close down all unnecessary apps, because
    the operating system will then free the memory they were using, which can be turned
    off to save power.
  prefs: []
  type: TYPE_NORMAL
- en: Like DRAM, LP-DRAM has been through many standards iterations. Various additional
    innovations beyond power switching include operating on reduced voltages such
    as 1.8 V, scaling the refresh rate as a function of temperature to reduce unnecessary
    refresh work, and multiple levels of shutdowns. The latter may be used to differentiate
    between a user putting their phone away in their pocket for many hours versus
    temporarily freeing memory from an app while continuing to use the rest of the
    phone.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cameras*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Camera sensors, as shown in [Figure 14-2](ch14.xhtml#ch14fig2), are active pixel
    sensors made from CMOS-like chips.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0351-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: A camera sensor (left) and a close-up showing its pixels (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: Camera sensors are formed from 2D arrays of light sensors (pixels) created through
    photolithography, like chips. Usually each pixel contains three subpixels for
    sensing red, green, and blue light, as in displays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Touchscreens*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The touchscreen used in a phone or tablet is produced as a distinct, transparent
    layer from the display screen placed beneath it. Like chips, touch-screens are
    produced via photolithography; layers of different materials are laid down in
    a pixel grid of small half-capacitors, as shown in [Figure 14-3](ch14.xhtml#ch14fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0351-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: A touchscreen made from an array of half-capacitors, with 2D
    addressing*'
  prefs: []
  type: TYPE_NORMAL
- en: Human skin acts as the other half of the capacitor when in close proximity to
    these pixels, making the grid touch-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the touchscreen to act as a layer above a visible display, we need
    to build these half-capacitors and the wires connected to them from a material
    that’s both conductive (a metal) and also transparent to human-visible red, green,
    and blue light. This is a difficult requirement, because metals generally reflect
    all frequencies of light. Indium tin oxide (ITO) is a very unusual compound, based
    on the rare element indium, that happens to have the desired property, so it’s
    used in most touchscreens.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOT SO DIFFERENT AFTER ALL?**'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike CISC, RISC doesn’t add extra instructions to make life easier for the
    programmer, who instead must often make use of sequences of more basic, general-purpose
    instructions with particular operands. This can make manual RISC assembly programming
    less interesting than CISC programming, but RISC assemblers can provide pseudo-instructions
    that function similarly to CISC instructions but are assembled into sequences
    of multiple RISC instructions. It’s also possible to build CISC architectures
    that do similar but in digital logic, fetching CISC-style instructions but decoding
    them into *sequences* of RISC instructions that are then executed in RISC style.
    Such designs look internally quite similar to the CISC microcode structures, suggesting
    that CISC and RISC don’t have to be so different after all.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smart devices are replacing embedded systems in many applications as the cost
    and power consumption of general-purpose computing falls and battery technology
    improves. RISC architectures are a good fit for smart computing needs, as their
    simplicity can reduce physical size, cost, and power requirements.
  prefs: []
  type: TYPE_NORMAL
- en: RISC architectures use small sets of simple instructions. They typically make
    a clean separation between instructions for memory access and for arithmetic.
    They try to have all instructions execute in the same time in order to simplify
    execution and enable smoother pipelining and OOOE. RISC assembly code is usually
    characterized by its appearance as homogeneous-looking lists of instructions with
    triple operands.
  prefs: []
  type: TYPE_NORMAL
- en: RISC-V is an open source family of RISC ISAs, with both open and closed source
    digital logic implementations and design toolchains available. RISC-V includes
    a core instruction set and various optional extension instruction sets, so variants
    can be used for small, cheap smart devices, and all the way up to higher-power
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RISC-V Programming**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Install and run the Jupiter RISC-V simulator from *[https://github.com/andrescv/Jupiter](https://github.com/andrescv/Jupiter)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter some simple programs from the examples in this chapter. Jupiter requires
    a label called `__start` (with two underscores) to be defined and made global;
    this will be used as the entry point when the program runs. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have data lines in your program, then by default Jupiter assumes a Harvard-style
    segmentation, which requires `.data` and `.txt` sections, such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and assemble each program (**Run ▸ Assemble**) and run it in the simulator.
    You can place breakpoints at any time with the tick-boxes on the left of the lines,
    and inspect the registers and memory with the GUI on the right. To get back to
    the code, click **Editor** at the top left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try porting previous programs from the Analytical Engine and Manchester Baby
    to run on RISC-V. What’s easier or harder to do in modern RISC-V compared to those
    systems? How does it feel compared to x86?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain a physical RISC-V board and use its tools and documents to run the same
    programs on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Want to make a real, working CPU in your bedroom? Using RISC-V and Chisel, you
    can.
  prefs: []
  type: TYPE_NORMAL
- en: A full Chisel tutorial can be found at *[https://github.com/ucb-bar/chisel-tutorial](https://github.com/ucb-bar/chisel-tutorial)*.
    Install Chisel and work through this tutorial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the microcircuits used in Rocket and BOOM—including ALU, FPU, and control
    unit—are available as Chisel libraries. Download and build some of these and experiment
    with how they work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Rocket Chip Generator (*[https://github.com/chipsalliance/rocket-chip](https://github.com/chipsalliance/rocket-chip)*)
    is a tool that takes a RISC-V CPU descriptor code such as RV64IMFP as input, and
    outputs Chisel and Verilog files (or a C++ simulation) for the desired CPU. Install
    and run Rocket Chip. Study the outputs to find out how the microcircuits you looked
    at in the previous problem are used in the generated CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Torture (*[https://github.com/ucb-bar/riscv-torture](https://github.com/ucb-bar/riscv-torture)*)
    is a tool provided by the RISC-V community to test correct RISC-V execution in
    hardware designs, and to help locate errors. Install it, introduce a deliberate
    error to a Rocket Chip design, and use the tool to study the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buy a cheap FPGA board and use the RISC-V documentation and mailing list archives
    to figure out how to burn your Rocket Chip netlist onto it to make a real physical
    CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join the RISC-V community discussions at *[https://riscv.org](https://riscv.org)*
    and study the open lowRISC designs at *[https://github.com/lowrisc](https://github.com/lowrisc)*.
    Use them to find an interesting piece of work that needs doing and contribute
    it to the RISC-V community.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a detailed RISC-V tutorial, see Edson Borin, *An Introduction to Assembly
    Programming with RISC-V*, *[https://riscv-programming.org/book/riscv-book.html](https://riscv-programming.org/book/riscv-book.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the definitive RISC-V manual, see Andrew Waterman and Krste Asanović (eds.),
    *The RISC-V Instruction Set Manual Volume I: User-Level ISA* (Berkeley: RISC-V
    Foundation), *[https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
