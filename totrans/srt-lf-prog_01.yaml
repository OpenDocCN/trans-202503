- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: THE INTERNAL LANGUAGE OF COMPUTERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的内部语言**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: The whole point of language is to be able to communicate information. Your job
    as a programmer is to give instructions to computers. They don’t understand our
    language, so you have to learn theirs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的核心是能够传递信息。作为程序员，你的工作就是向计算机提供指令。计算机不理解我们的人类语言，因此你必须学习它们的语言。
- en: Human language is the product of thousands of years of evolution. We don’t know
    a lot about how it evolved, since early language development wasn’t advanced to
    the point that history could be recorded. (Apparently nobody wrote ballads about
    language development.) Computer languages are a different story, as they’re a
    fairly recent invention that occurred long after the development of human language,
    which enables us to write about them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人类语言是经过数千年进化的产物。我们对它如何进化了解不多，因为早期语言发展并未达到足以记录历史的程度。（显然没有人写过关于语言发展的歌谣。）计算机语言则是另一个故事，它们是相对较新的发明，远在计算机语言出现之前，人类语言已经发展完善，正因如此我们能够写出关于它们的内容。
- en: Human and computer languages share many of the same elements, such as written
    symbols and rules for their proper arrangement and usage. One thing that they
    don’t share is nonwritten language forms; computers have written language only.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 人类语言和计算机语言有许多相同的元素，比如书面符号和其正确排列与使用的规则。它们不同的是，计算机语言没有非书面语言形式；计算机仅使用书面语言。
- en: In this chapter, you’ll start to learn the language of computers. This process
    happens in stages just like with human language. We have to start with letters
    before building up to words and sentences. Fortunately, computer languages are
    much simpler than their human counterparts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将开始学习计算机语言。这个过程就像人类语言一样，是分阶段进行的。我们必须从字母开始，逐步构建到单词和句子。幸运的是，计算机语言比人类语言简单得多。
- en: '**What Is Language?**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**什么是语言？**'
- en: Language is a convenient shortcut. It allows us to communicate complex concepts
    without having to demonstrate them. It also allows concepts to be conveyed at
    a distance, even via intermediaries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 语言是一种便捷的捷径。它使我们能够在不需要展示复杂概念的情况下进行交流。它还允许概念通过中介传达，甚至可以跨越距离。
- en: Every language—whether written, spoken, or expressed in a series of gestures
    or by banging two rocks together—is meaning *encoded* as a set of symbols. Encoding
    meaning as symbols isn’t enough, though. Language only works if all communicating
    parties have the same *context*, so they can assign the same meaning to the same
    symbols. For example, the word *Toto* might suggest the dog from *The Wizard of
    Oz* to many people, while others might think of the Japanese manufacturer of heated
    toilet seats. I recently encountered much confusion while discussing clothing
    with my French exchange student. It turns out that the common interpretation of
    the word *camisole* in America is undershirt, but in France it’s straitjacket!
    In both of these examples, the same symbols can be distinguished only by context,
    and that context is not always readily discernible. Computer languages have this
    issue too.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每一种语言——无论是书面语言、口语，还是通过一系列手势或敲击两块石头来表达——都是作为符号集合来*编码*的意义。然而，单纯将意义编码为符号是不够的。语言只有在所有交流方拥有相同的*语境*时才有效，这样他们才能将相同的意义赋予相同的符号。例如，*Toto*
    这个词可能会让许多人联想到《绿野仙踪》中的狗，而其他人则可能想到日本的加热马桶盖制造商。我最近在与我的法国交换生讨论服装时遇到了许多困惑。原来，在美国，“*camisole*”这个词通常是指背心，而在法国却是指紧身衣！在这两个例子中，相同的符号只能通过语境来区分，而这个语境并不总是容易辨别的。计算机语言也有这个问题。
- en: '**Written Language**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**书面语言**'
- en: 'Written language is a sequence of symbols. We form words by placing symbols
    in a particular order. For example, in English we can form the word *yum* by placing
    three symbols (that is, letters) in order from left to right as follows: *y u
    m*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 书面语言是符号的序列。我们通过将符号按照特定顺序排列来形成单词。例如，在英语中，我们可以通过将三个符号（即字母）按照从左到右的顺序排列，形成单词*yum*，即：*y
    u m*。
- en: There are many possible symbols and combinations. There are 26 basic symbols
    (A–Z) in English—if we ignore things like upper- and lowercase, punctuation, ligatures,
    and so on—which native English speakers learn as toddlers. Other languages have
    different types and numbers of symbols. Some languages, such as Chinese and Japanese
    as written in kanji, have a very large number of symbols where each symbol is
    a word unto itself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可能的符号和组合。英语中有26个基本符号（A–Z）——如果我们忽略大小写、标点、连字等——这是英语母语者在幼儿时期学到的。其他语言有不同类型和数量的符号。一些语言，如汉字书写的中文和日文汉字，拥有大量的符号，每个符号本身就是一个词。
- en: 'Languages also use different ordering, such as reading right to left in Hebrew
    and vertically in Chinese. Symbol order is important: *d o g* is not the same
    as *g o d*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 语言还使用不同的排列顺序，比如希伯来语从右到左阅读，中文则是竖直排列。符号的顺序很重要：*d o g*与*g o d*是不同的。
- en: 'Although style can in some ways be considered a language unto itself, we don’t
    distinguish symbols based on typeface: a, *a*, and **a** are all the same symbol.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管风格在某些方面可以被视为一种独立的语言，但我们不会根据字体来区分符号：a、*a*和**a**都是相同的符号。
- en: 'Three components frame the technology of written language, including computer
    language:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个组成部分构成了书面语言技术，包括计算机语言：
- en: The containers that hold symbols
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储符号的容器
- en: The symbols that are allowed in the containers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器中允许使用的符号
- en: The ordering of the containers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的排列顺序
- en: Some languages include more complicated rules that constrain the permitted symbols
    in containers based on the symbols in other containers. For example, some symbols
    can’t occupy adjacent containers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有些语言包含更复杂的规则，限制了基于其他容器中符号的符号在容器中的合法性。例如，一些符号不能占据相邻的容器。
- en: '**The Bit**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**比特**'
- en: We’ll begin with the container. This might be called a *character* in a human
    language and a *bit* for computers. The term *bit* is an awkward marriage between
    *binary* and *digit*. It’s awkward because *binary* is a word for something with
    two parts, whereas *digit* is a word for one of the 10 symbols (0–9) that make
    up our everyday number system. You’ll learn why we use bits in the next chapter;
    for now, it’s enough to know that they’re cheap and easy to build.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从容器开始讲解。这在自然语言中可能称为*字符*，在计算机中则称为*比特*。术语*比特*是*二进制*和*数字*两个词的结合。之所以称为“尴尬的结合”，是因为*二进制*指的是包含两个部分的事物，而*数字*是指我们日常数字系统中的10个符号（0-9）之一。你将在下一章了解为什么我们使用比特；目前，只需要知道它们便宜且容易构建。
- en: 'A bit is binary, which means a bit container can hold only one of two symbols,
    kind of like the dot and dash from Morse code. Morse code uses just two symbols
    to represent complex information by stringing those symbols together in different
    combinations. The letter *A* is dot-dash, for example. *B* is dash-dot-dot-dot,
    *C* is dash-dot-dash-dot, and so on. The order of the symbols is important just
    like in a human language: dash-dot means *N*, not *A*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 比特是二进制的，这意味着一个比特容器只能容纳两个符号中的一个，有点像摩尔斯电码中的点和划。摩尔斯电码通过将这两个符号按不同组合串联起来来表示复杂的信息。例如，字母*A*是点划，*B*是划点点点，*C*是划点划点，依此类推。符号的顺序非常重要，就像在人类语言中一样：划点代表*N*，而不是*A*。
- en: The concept of symbols is abstract. It really doesn’t matter what they stand
    for; they could be off and on, day and night, or duck and goose. But remember,
    language doesn’t work without context. Things would get weird fast if a sender
    thought they were saying *U* (dot-dot-dash), but the recipient heard *duck-duck-goose*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的概念是抽象的。它们代表什么其实并不重要；它们可以是开和关、白天和夜晚，或者是鸭子和鹅。但请记住，语言没有上下文是无法工作的。如果发送者认为他们在说*U*（点点划），而接收者听到的是*鸭鸭鹅*，那就会很奇怪了。
- en: In the remainder of this chapter, you’ll learn about some of the common ways
    in which meaning is assigned to bits for computing. Keep in mind that there is
    a lot of make-believe involved—for example, you may run into things like, “Let’s
    pretend that this bit means blue.” Programming actually works that way, so even
    though you’ll be learning some standard bit uses, don’t be afraid to invent your
    own when appropriate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，你将学习计算中常见的将意义赋予比特的几种方式。记住，过程中有很多假设——例如，你可能会遇到类似“假设这个比特代表蓝色”的说法。编程实际上就是这么运作的，因此，尽管你将学习一些标准的比特使用方式，适当时也不要害怕创造你自己的方式。
- en: '**Logic Operations**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**逻辑运算**'
- en: One use of bits is to represent the answers to yes/no questions such as “Is
    it cold?” or “Do you like my hat?” We use the terms *true* for yes and *false*
    for no. Questions like “Where’s the dog party?” don’t have a yes/no answer and
    can’t be represented by a single bit.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 位的一个用途是表示是/否问题的答案，例如“天气冷吗？”或“你喜欢我的帽子吗？”我们用*真*表示“是”，用*假*表示“否”。像“狗派对在哪里？”这样的问题没有是/否的答案，不能用单个位来表示。
- en: In human language, we often combine several yes/no clauses into a single sentence.
    We might say, “Wear a coat if it is cold or if it is raining” or “Go skiing if
    it is snowing and it’s not a school day.” Another way of saying those things might
    be “Wear coat is true if cold is true or raining is true” and “Skiing is true
    if snowing is true and school day is not true.” These are *logic operations* that
    each produce a new bit based on the contents of other bits.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在人类语言中，我们经常将几个是/否的条款合并成一个句子。我们可能会说，“如果天气冷或下雨就穿上外套”或“如果下雪并且不是上学日，就去滑雪。” 另一种说法可能是“如果冷为真或下雨为真，则穿外套为真”，以及“如果下雪为真且上学日不为真，则滑雪为真。”这些是*逻辑操作*，它们根据其他位的内容产生一个新的位。
- en: '***Boolean Algebra***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***布尔代数***'
- en: Just as algebra is a set of rules for operating on numbers, *Boolean algebra*,
    invented in the 1800s by English mathematician George Boole, is a set of rules
    that we use to operate on bits. As with regular algebra, the associative, commutative,
    and distributive rules also apply.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代数是一组操作数字的规则一样，*布尔代数* 是由 19 世纪英国数学家乔治·布尔发明的一组操作位的规则。与常规代数一样，结合律、交换律和分配律也适用。
- en: 'There are three basic Boolean operations, *NOT*, *AND*, and *OR*, as well as
    one composite operation, *XOR* (short for “exclusive-or”), as described here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种基本的布尔操作，*非*、*与* 和 *或*，以及一种复合操作，*异或*（“exclusive-or”的缩写），如下面所述：
- en: '**NOT** This operation means “the opposite.” For example, if a bit is false,
    *NOT* that bit would be true. If a bit is true, *NOT* that bit would be false.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**非** 这个操作表示“相反”。例如，如果一个位为假，*非* 该位将为真。如果一个位为真，*非* 该位将为假。'
- en: '**AND** This operation involves 2 or more bits. In a 2-bit operation, the result
    is true only if both the first *AND* second bit are true. When more than 2 bits
    are involved, the result is true only if *all* bits are true.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**与** 这个操作涉及两个或更多的位。在一个 2 位操作中，只有当第一个*与*第二个位都为真时，结果才为真。当有超过两个位时，只有当*所有*位都为真时，结果才为真。'
- en: '**OR** This operation also involves 2 or more bits. In a 2-bit operation, the
    result is true if the first *OR* second bit is true; otherwise, the result is
    false. With more than 2 bits, the result is true if any bit is true.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**或** 这个操作也涉及两个或更多的位。在一个 2 位操作中，如果第一个*或*第二个位为真，则结果为真；否则，结果为假。如果有超过两个位，只有当任意一个位为真时，结果才为真。'
- en: '**XOR** The result of an *exclusive-or* operation is true if the first and
    second bits have different values. It’s either but not both. Because “exclusive-or”
    is a mouthful, we often use the abbreviation XOR (pronounced “ex-or”).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**异或** *异或* 操作的结果为真，当且仅当第一个和第二个位具有不同的值。它要么为真，要么为假，但不是两者都有。由于“异或”这个词太长，我们通常使用缩写
    XOR（发音为“ex-or”）。'
- en: '[Figure 1-1](ch01.xhtml#ch01fig01) summarizes these Boolean operations graphically
    in what are known as *truth tables*. The *inputs* are outside of the boxes and
    the *outputs* are inside. In these tables, T stands for True and F stands for
    False.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](ch01.xhtml#ch01fig01) 以图形方式总结了这些布尔操作，即所谓的*真值表*。*输入* 在框外，*输出* 在框内。在这些表格中，T
    代表真，F 代表假。'
- en: '![Image](../images/01fig01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig01.jpg)'
- en: '*Figure 1-1: Truth tables for Boolean operations*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：布尔操作的真值表*'
- en: '[Figure 1-2](ch01.xhtml#ch01fig02) shows how this works for the NOT and AND
    operations. We can find the output by tracing a path from the input or inputs.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](ch01.xhtml#ch01fig02) 显示了该如何操作 NOT 和 AND 操作。我们可以通过从输入或多个输入追踪路径来找到输出。'
- en: '![Image](../images/01fig02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig02.jpg)'
- en: '*Figure 1-2: Using truth tables*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：使用真值表*'
- en: As you can see, the NOT operation simply reverses the state of the input. On
    the other hand, the AND operation returns true only when both inputs are true.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，非操作只是反转输入的状态。另一方面，AND 操作只有在两个输入都为真时才返回真。
- en: '**NOTE**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The XOR operation is built from other operations. For example, the XOR of
    2 bits,* a *and* b, *is the same thing as* (a OR b) AND NOT (a AND b). *This shows
    that basic Boolean operations can be combined in different ways to yield the same
    result.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*异或操作是由其他操作构建的。例如，2个位的异或，*a* 和 *b*，*等同于*（a 或 b）与 非（a 和 b）相与。*这表明基本的布尔操作可以以不同的方式组合，以得到相同的结果。*'
- en: '***De Morgan’s Law***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***德·摩根定律***'
- en: In the 1800s, British mathematician Augustus De Morgan added a law that applies
    only to Boolean algebra, the eponymous *De Morgan’s law*. This law states that
    the operation *a AND b* is equivalent to the operation *NOT*(*NOT a OR NOT b*),
    as shown in [Figure 1-3](ch01.xhtml#ch01fig03).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在19世纪，英国数学家奥古斯都·德·摩根（Augustus De Morgan）提出了一条只适用于布尔代数的定律——同名的*德·摩根定律*。该定律指出，操作*a
    AND b*等价于操作*NOT*(*NOT a OR NOT b*)，如[图 1-3](ch01.xhtml#ch01fig03)所示。
- en: '![Image](../images/01fig03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig03.jpg)'
- en: '*Figure 1-3: The truth table for De Morgan’s law*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：德·摩根定律的真值表*'
- en: Notice that the results of *a AND b* in the second column are identical to the
    results listed in the final *NOT*(*NOT a OR NOT b*) column. This means that with
    enough NOT operations, we can replace AND operations with OR operations (and vice
    versa). This is useful because computers operate on real-world input that’s not
    under their control. While it would be nice if inputs were of the form *cold*
    or *raining*, they’re often *NOT cold* or *NOT raining*. Similar to double negatives
    in languages such as English (“We didn’t not go skiing”), De Morgan’s law is a
    tool that lets us operate on these *negative logic* propositions in addition to
    the *positive logic* that we’ve already seen. [Figure 1-4](ch01.xhtml#ch01fig04)
    illustrates the coat-wearing decision for both positive and negative logic forms.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第二列的*a AND b*结果与最后一列*NOT*(*NOT a OR NOT b*)中的结果是相同的。这意味着通过足够的NOT操作，我们可以将AND操作替换为OR操作（反之亦然）。这一点非常有用，因为计算机处理的现实世界输入并不在它们的控制之下。虽然如果输入是*冷*或*下雨*的形式会很好，但它们往往是*NOT
    cold*或*NOT raining*。类似于英语等语言中的双重否定（“我们没去滑雪”），德·摩根定律是一个工具，它让我们不仅可以对已经看到的*正逻辑*进行操作，还可以对这些*负逻辑*命题进行操作。[图
    1-4](ch01.xhtml#ch01fig04)展示了正负逻辑形式下穿外套的决策。
- en: '![Image](../images/01fig04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig04.jpg)'
- en: '*Figure 1-4: Positive and negative logic*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：正负逻辑*'
- en: On the left (positive logic) side, we can make our decision using a single OR
    operation. On the right (negative logic) side, De Morgan’s law allows us to make
    our decision using a single AND operation. Without De Morgan’s law, we’d have
    to implement the negative logic case as *NOT* not-cold *OR NOT* not-raining. Although
    that works, there is a cost in price and performance to each operation, so minimizing
    operations minimizes costs. The hardware that performs the NOT operation costs
    real money and, as you’ll learn in the next chapter, cascading operations slows
    things down.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧（正逻辑）我们可以通过单一的OR操作来做决定。在右侧（负逻辑），德·摩根定律允许我们通过单一的AND操作来做决定。如果没有德·摩根定律，我们将不得不将负逻辑的情况实现为*NOT*不冷*OR
    NOT*不下雨。虽然这样可以工作，但每个操作都有价格和性能上的成本，所以减少操作可以减少成本。执行NOT操作的硬件需要真正的金钱，正如你将在下一章学到的，级联操作会拖慢速度。
- en: De Morgan tells us that this is equivalent to “cold and raining,” which is much
    simpler.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 德·摩根告诉我们，这等同于“冷和下雨”，这样更简单。
- en: '**Representing Integers Using Bits**'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用位表示整数**'
- en: Let’s move up the food chain and learn how to use bits to represent numbers.
    Numbers are more complicated than logic but much simpler than words.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们往上走一步，学习如何使用位来表示数字。数字比逻辑更复杂，但比语言简单得多。
- en: '***Representing Positive Numbers***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表示正数***'
- en: 'We commonly use the *decimal* number system because it corresponds to our anatomy.
    Ten different symbols called *digits* can go into the containers: 0123456789\.
    Containers are stacked right to left. Each container has a name that is separate
    from its contents; we call the rightmost container the ones, next is the tens,
    then the hundreds, thousands, and so on. These names are aliases for powers of
    10; 10⁰ is one, 10¹ is ten, 10² is one hundred, 10³ is one thousand. This system
    is called *base-10* since 10 is the base holding up the exponents. The value of
    a number is derived from the sum of the product of each container value and the
    value of its contents. For example, the number 5,028 is the sum of 5 thousands,
    0 hundreds, 2 tens, and 8 ones, or 5 × 10³ + 0 × 10² + 2 × 10¹ + 8 × 10⁰, as shown
    in [Figure 1-5](ch01.xhtml#ch01fig05).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用 *十进制* 数字系统，因为它与我们的生理结构相对应。十个不同的符号，称为 *数字*，可以进入容器：0123456789。容器是从右向左堆叠的。每个容器都有一个与其内容不同的名称；我们称最右边的容器为个位数，接下来是十位数，百位数，千位数，依此类推。这些名称是
    10 的幂的别名；10⁰ 是一，10¹ 是十，10² 是一百，10³ 是一千。这个系统被称为 *十进制*，因为 10 是支撑指数的基数。一个数字的值是每个容器值与其内容值乘积的和。例如，数字
    5,028 是 5 千、0 百、2 十和 8 个一的和，即 5 × 10³ + 0 × 10² + 2 × 10¹ + 8 × 10⁰，如 [图 1-5](ch01.xhtml#ch01fig05)
    所示。
- en: '![Image](../images/01fig05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig05.jpg)'
- en: '*Figure 1-5: The number 5,028 in decimal notation*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-5: 数字 5,028 的十进制表示*'
- en: 'We can use a similar approach to make numbers using bits. Since we’re using
    bits instead of digits, we only have two symbols: 0 and 1\. But that’s not a problem.
    In decimal, we add a container whenever we run out of room; we can fit a 9 in
    a single container but need two containers for 10\. That works in binary too;
    we just need a new container for anything greater than a 1\. The rightmost container
    would still be the ones, but what’s the next one? It’s the *twos*. The value of
    a container in decimal where there are 10 symbols is 10 times that of the one
    on the right. Thus, in binary where there are two symbols, the container value
    is two times that of the one on the right. That’s all there is to it! The container
    values are powers of 2, which means it’s a *base-2* system instead of base-10.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的方法来构造二进制数字。由于我们使用的是位（bit）而非数字，我们只有两个符号：0 和 1。但这并不成问题。在十进制中，每当容器空间不足时，我们会增加一个新的容器；我们可以将
    9 放入一个容器，但需要两个容器才能表示 10。在二进制中也是如此；我们只需要为任何大于 1 的数字增加一个新容器。最右边的容器仍然表示个位数，但下一个是什么呢？它是
    *二位数*。在十进制中，每个容器的值是其右边容器值的 10 倍。因此，在二进制中，每个容器的值是其右边容器值的 2 倍。就这么简单！容器的值是 2 的幂，这意味着它是一个
    *二进制* 系统，而不是十进制系统。
- en: '[Table 1-1](ch01.xhtml#ch01tab01) lists some of the powers of 2\. We can use
    it as a reference to understand the binary representation of the number 5,028.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01.xhtml#ch01tab01)列出了 2 的一些幂。我们可以将其作为参考来理解数字 5,028 的二进制表示。'
- en: '**Table 1-1:** Powers of 2'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1:** 2 的幂'
- en: '| **Expansion** | **Power** | **Decimal** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **扩展** | **幂** | **十进制** |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 2 ÷ 2 | 2⁰ | 1 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 2 ÷ 2 | 2⁰ | 1 |'
- en: '| 2 | 2¹ | 2 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 2¹ | 2 |'
- en: '| 2 × 2 | 2² | 4 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 | 2² | 4 |'
- en: '| 2 × 2 × 2 | 2³ | 8 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 | 2³ | 8 |'
- en: '| 2 × 2 × 2 × 2 | 2⁴ | 16 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 | 2⁴ | 16 |'
- en: '| 2 × 2 × 2 × 2 × 2 | 2⁵ | 32 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 | 2⁵ | 32 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 | 2⁶ | 64 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 | 2⁶ | 64 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2⁷ | 128 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2⁷ | 128 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2⁸ | 256 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2⁸ | 256 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2⁹ | 512 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2⁹ | 512 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(10) | 1,024 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(10) | 1,024 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(11) | 2,048 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(11) | 2,048 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(12) | 4,096 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(12) | 4,096 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(13) | 8,192 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(13) | 8,192 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(14) | 16,384 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(14) | 16,384 |'
- en: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(15) | 32,768
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 | 2^(15) | 32,768
    |'
- en: Each number in the far-right column of [Table 1-1](ch01.xhtml#ch01tab01) represents
    the value of a binary container. [Figure 1-6](ch01.xhtml#ch01fig06) shows how
    the number 5,028 can be written in binary, using essentially the same process
    that we used earlier for decimal notation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01.xhtml#ch01tab01)中最右列的每个数字代表二进制容器的值。[图 1-6](ch01.xhtml#ch01fig06)展示了如何将数字
    5,028 以二进制表示，基本上使用了我们之前用于十进制表示的相同过程。'
- en: '![Image](../images/01fig06.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig06.jpg)'
- en: '*Figure 1-6: The number 5,028 in binary*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-6：二进制中的数字 5,028*'
- en: 'The result of the conversion to binary is:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为二进制的结果是：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, the number 5,028 in binary has one 4,096 (2^(12)), zero 2,048s
    (2^(11)), zero 1,024s (2^(10)), one 512 (2⁹), one 256 (2⁸), and so on to make
    up 1001110100100\. Performing the same sort of calculation that we do for decimal
    numbers, we write 1 × 2^(12) + 0 × 2^(11) + 0 × 2^(10) + 1 × 2⁹ + 1 × 2⁸ + 1 ×
    2⁷ + 0 × 2⁶ + 1 × 2⁵ + 0 × 2⁴ + 0 × 2³ + 1 × 2² + 0 × 2¹ + 0 × 2⁰. Substituting
    the decimal numbers from [Table 1-1](ch01.xhtml#ch01tab01), we get 4,096 + 512
    + 256 + 128 + 32 + 4, which is equal to 5,028.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数字 5,028 的二进制表示包含一个 4,096（2^(12)），零个 2,048（2^(11)），零个 1,024（2^(10)），一个
    512（2⁹），一个 256（2⁸），依此类推，组成了 1001110100100。进行与十进制数相同的计算，我们写成 1 × 2^(12) + 0 × 2^(11)
    + 0 × 2^(10) + 1 × 2⁹ + 1 × 2⁸ + 1 × 2⁷ + 0 × 2⁶ + 1 × 2⁵ + 0 × 2⁴ + 0 × 2³ +
    1 × 2² + 0 × 2¹ + 0 × 2⁰。用[表 1-1](ch01.xhtml#ch01tab01)中的十进制数字替换，我们得到 4,096 +
    512 + 256 + 128 + 32 + 4，结果为 5,028。
- en: We would say that 5,028 is a four-digit number in decimal. In binary it’s a
    13-bit number.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会说，5,028 是一个四位的十进制数字。在二进制中，它是一个 13 位的数字。
- en: The number of digits determines the range of values that we can represent in
    decimal. For example, 100 different values in the range 0–99 can be represented
    by two digits. Likewise, the number of bits determines the range of values we
    can represent in binary. For example, 2 bits can represent four values in the
    range 0–3\. [Table 1-2](ch01.xhtml#ch01tab02) summarizes both the number and range
    of values that we can represent with different numbers of bits.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的位数决定了我们在十进制中能够表示的值的范围。例如，100个不同的值，范围从 0 到 99，可以用两位数表示。同样，位数决定了我们在二进制中能够表示的值的范围。例如，2
    位可以表示 0 到 3 范围内的四个值。[表 1-2](ch01.xhtml#ch01tab02)总结了不同位数下我们可以表示的值的数量和范围。
- en: '**Table 1-2:** Ranges of Binary Number Values'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-2：** 二进制数值范围'
- en: '| **Number of bits** | **Number of values** | **Range of values** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **位数** | **值的数量** | **值的范围** |'
- en: '| --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 4 | 16 | 0...15 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 16 | 0...15 |'
- en: '| 8 | 256 | 0...255 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 256 | 0...255 |'
- en: '| 12 | 4,096 | 0...4,095 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4,096 | 0...4,095 |'
- en: '| 16 | 65,536 | 0...65,535 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 65,536 | 0...65,535 |'
- en: '| 20 | 1,048,576 | 0...1,058,575 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 1,048,576 | 0...1,058,575 |'
- en: '| 24 | 16,777,216 | 0...16,777,215 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 16,777,216 | 0...16,777,215 |'
- en: '| 32 | 4,294,967,296 | 0...4,294,967,295 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 4,294,967,296 | 0...4,294,967,295 |'
- en: '| 64 | 18,446,744,073,709,551,616 | 0...18,446,744,073,709,551,615 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 18,446,744,073,709,551,616 | 0...18,446,744,073,709,551,615 |'
- en: The rightmost bit in a binary number is called the *least significant bit* and
    the leftmost bit is called the *most significant bit*, because changing the value
    of the rightmost bit has the smallest effect on the value of the number and changing
    the value of the leftmost bit has the greatest effect. Computer people are fond
    of three-letter acronyms, or TLAs as we call them, so these are commonly referred
    to as the *LSB* and *MSB*. [Figure 1-7](ch01.xhtml#ch01fig07) shows an example
    of the number 5,028 held in 16 bits.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数中最右边的位称为*最低有效位*，而最左边的位称为*最高有效位*，因为改变最右边的位对数字的值影响最小，而改变最左边的位对数字的值影响最大。计算机领域的人喜欢使用三字母缩略词，或者我们称之为
    TLA，因此这些通常被称为*LSB*和*MSB*。[图 1-7](ch01.xhtml#ch01fig07)展示了在 16 位中表示的数字 5,028 的示例。
- en: '![Image](../images/01fig07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig07.jpg)'
- en: '*Figure 1-7: MSB and LSB*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-7：MSB 和 LSB*'
- en: You’ll notice that while the binary representation of 5,028 takes 13 bits, [Figure
    1-7](ch01.xhtml#ch01fig07) shows it in 16 bits. Just like in decimal, we can always
    use more containers than the minimum required by adding *leading zeros* on the
    left. In decimal, 05,028 has the same value as 5,028\. Binary numbers are often
    represented this way because computers are built around blocks of bits.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，虽然数字 5,028 的二进制表示使用了 13 位，[图 1-7](ch01.xhtml#ch01fig07)中它却是用 16 位表示的。就像在十进制中一样，我们总是可以使用比最少要求更多的容器，只需在左边添加*前导零*。在十进制中，05,028
    与 5,028 的值是相同的。二进制数通常这样表示，因为计算机是基于位块构建的。
- en: '***Binary Addition***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制加法***'
- en: Now that you know how to represent numbers using binary, let’s look at how to
    do simple arithmetic with binary numbers. In decimal addition, we add up each
    digit from right (least significant digit) to left (most significant digit), and
    if the result is greater than 9, we carry the 1\. Similarly, we add together each
    bit in a binary number, going from the least significant to the most significant
    bit, and if the result is greater than 1, we carry the 1.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用二进制表示数字，让我们来看看如何用二进制数字进行简单的算术运算。在十进制加法中，我们从右边（最低有效位）到左边（最高有效位）逐位相加，如果结果大于9，我们就进1。同样，在二进制中，我们逐位加上每个比特，从最低有效位到最高有效位，如果结果大于1，我们就进1。
- en: Addition is actually a bit easier in binary because there are only 4 possible
    combinations of 2 bits compared to 100 combinations of 2 digits. For example,
    [Figure 1-8](ch01.xhtml#ch01fig08) shows how to add 1 and 5 using binary numbers,
    showing the number being carried above each column.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，二进制加法要容易一些，因为两个比特有4种可能的组合，而两个数字有100种组合。例如，[图 1-8](ch01.xhtml#ch01fig08)展示了如何使用二进制数加1和5，并显示了每一列上方的进位数字。
- en: '![Image](../images/01fig08.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig08.jpg)'
- en: '*Figure 1-8: Binary addition*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-8：二进制加法*'
- en: 'The number 1 is 001 in binary, while the number 5 is 101 because (1 × 4) +
    (0 × 2) + (1 × 1) = 5\. To add the binary numbers 001 and 101 together, we start
    with the least significant bit in the rightmost column. Adding the binary numbers
    1 and 1 in that column gives us 2, but we don’t have a symbol for 2 in binary.
    But we know that 2 is actually 10 in binary ([1 × 2] + [0 × 1] = 2), so we put
    0 as the sum and carry the 1 to the next digit. Because the middle bits are zeros,
    we only have 1, which we carried over from before, as the sum. Then we add the
    digits in the leftmost column: 0 plus 1 is simply 1 in binary. The final result
    is the binary 110, or 6 in decimal notation, which is what you would get by adding
    1 and 5.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数字1的二进制表示是001，而数字5的二进制表示是101，因为（1 × 4）+（0 × 2）+（1 × 1）= 5。为了将二进制数字001和101相加，我们从最右边的列（最低有效位）开始。在该列中加1和1得到2，但我们在二进制中没有表示2的符号。但我们知道2的二进制表示是10（[1
    × 2] + [0 × 1] = 2），因此我们将0作为和，并将1进位到下一位。由于中间的比特是0，我们只有之前进位过来的1作为和。然后，我们将最左边的列中的数字相加：0加1就是二进制中的1。最终结果是二进制的110，或十进制的6，这就是1和5相加的结果。
- en: You might notice that the rules for binary addition can be expressed in terms
    of the logical operations that we discussed previously, as [Figure 1-9](ch01.xhtml#ch01fig09)
    illustrates. We’ll see in [Chapter 2](ch02.xhtml#ch02) that this is in fact how
    computer hardware does binary addition.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，二进制加法的规则可以通过我们之前讨论的逻辑运算来表达，正如[图 1-9](ch01.xhtml#ch01fig09)所示。我们将在[第2章](ch02.xhtml#ch02)中看到，实际上计算机硬件就是通过这种方式进行二进制加法的。
- en: '![Image](../images/01fig09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig09.jpg)'
- en: '*Figure 1-9: Binary addition using logical operations*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-9：使用逻辑运算进行二进制加法*'
- en: When we add 2 bits together, the value of the result is the XOR of the 2 bits,
    and the value of the carry is the AND of the 2 bits. You can see that this is
    true in [Figure 1-9](ch01.xhtml#ch01fig09), where adding 1 and 1 in binary results
    in 10\. This means that the carry value is 1, which is what you get by performing
    the expression (1 *AND* 1). Likewise, the expression (1 *XOR* 1) yields 0, which
    is the value that we assign to the bit position itself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将2个比特加在一起时，结果的值是这2个比特的异或（XOR），进位的值是这2个比特的与（AND）。你可以在[图 1-9](ch01.xhtml#ch01fig09)中看到这一点，其中1和1的二进制相加结果为10。这意味着进位值是1，这是通过执行表达式（1
    *AND* 1）得到的。类似地，表达式（1 *XOR* 1）得到0，这就是我们为该比特位置分配的值。
- en: Adding 2 bits is an operation that rarely happens in isolation. Referring back
    to [Figure 1-8](ch01.xhtml#ch01fig08), it appears that we’re adding 2 bits together
    in each column, but we’re really adding 3 because of the carry. Fortunately, we
    don’t need to learn anything new to add 3 bits together (because A + B + C is
    the same as (A + B) + C, according to the associative rule), so we can add 3 bits
    together using a pair of 2-bit adds.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 两个比特的加法操作很少单独发生。回到[图 1-8](ch01.xhtml#ch01fig08)，看起来我们在每一列中加了2个比特，但实际上我们加的是3个，因为有进位。幸运的是，我们不需要学习任何新知识来加3个比特（因为A
    + B + C等同于(A + B) + C，根据结合律），所以我们可以通过一对2比特加法来完成3比特的加法。
- en: What happens when the result of addition doesn’t fit in the number of bits that
    we have? This results in *overflow*, which happens whenever we have a carry from
    the most significant bit. For example, if we have 4-bit numbers, and add 1001
    (9[10]) to 1000 (8[10]), the result should be 10001 (17[10]), but it will end
    up being 0001 (1[10]) because there’s no place for the most significant bit. As
    we’ll see in more detail later, computers have a *condition code register*, which
    is a place that holds odd pieces of information. One of these is an *overflow
    bit*, which holds the carry value from the most significant bit. We can look at
    this value to determine whether or not overflow occurred.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当加法结果超出我们拥有的位数时会发生什么？这会导致*溢出*，每当我们从最高有效位（MSB）进位时，就会发生溢出。例如，如果我们有4位数字，并且将1001（9[10]）加到1000（8[10]），结果应该是10001（17[10]），但是它会变成0001（1[10]），因为没有地方存放最高有效位。正如我们稍后会更详细地看到的，计算机有一个*条件码寄存器*，它是一个存储奇怪信息的地方。这里面有一个*溢出位*，它保存来自最高有效位的进位值。我们可以查看这个值来判断是否发生了溢出。
- en: You’re probably aware that you can subtract one number from another by adding
    the negative of that number. We’ll learn how to represent negative numbers in
    the next section. Borrowing beyond the most significant bit is called *underflow*.
    Computers have a condition code for this too.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，你可以通过加上那个数字的负数来从一个数字中减去另一个数字。我们将在下一节中学习如何表示负数。超过最高有效位的借位被称为*下溢*。计算机也有一个对应的条件码来表示这一点。
- en: '***Representing Negative Numbers***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表示负数***'
- en: All of the numbers we represented using binary in the last section were positive.
    But lots of real-world problems involve both positive and negative numbers. Let’s
    see how we can use bits to represent negative numbers. For example, let’s assume
    that we have 4 bits to play with. As you learned in the last section, 4 bits can
    represent 16 numbers in the range of 0 through 15\. Just because we can hold 16
    numbers in 4 bits doesn’t mean that those numbers have to be 0 through 15\. Remember,
    language works through meaning and context. That means that we can devise new
    contexts in which we can interpret bits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们表示的所有数字都是正数。但很多现实世界的问题涉及到正数和负数。让我们看看如何用位来表示负数。例如，假设我们有4个位可用。如你在上一节中学到的，4个位可以表示0到15之间的16个数字。仅仅因为4个位能表示16个数字，并不意味着这些数字必须是0到15之间的。记住，语言是通过意义和上下文来运作的。这意味着我们可以创造新的上下文来解释位。
- en: '**Sign and Magnitude**'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**符号和大小**'
- en: A *sign* is commonly used to distinguish negative numbers from positive ones.
    The sign has two values, plus and minus, so it can be represented using a bit.
    We’ll arbitrarily use the leftmost bit (MSB) for the sign, leaving us 3 bits that
    can represent a number between 0 and 7\. If the sign bit is 0, we treat that number
    as positive. If it’s 1, we treat it as negative. This lets us represent 15 different
    positive and negative numbers in total, not 16, because there is both a positive
    0 and a negative 0\. [Table 1-3](ch01.xhtml#ch01tab03) shows how this allows us
    to represent the numbers between –7 and +7.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号*通常用于区分负数和正数。符号有两个值，正和负，因此可以使用一位来表示。我们任意选择最左边的位（MSB）作为符号，剩下3个位可以表示0到7之间的数字。如果符号位是0，我们将这个数字视为正数。如果是1，我们将其视为负数。这使我们能够表示15个不同的正负数字，而不是16个，因为存在正零和负零。[表
    1-3](ch01.xhtml#ch01tab03)展示了这如何帮助我们表示-7到+7之间的数字。'
- en: This is called *sign and magnitude* representation because there’s a bit that
    represents a sign and bits that represent the magnitude, or how far the value
    is from zero.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这叫做*符号和大小*表示法，因为有一个位表示符号，其他位表示大小，或者说表示值距离零的远近。
- en: Sign and magnitude representation is not used much for two reasons. First, bits
    cost money to build, so we don’t want to waste them by having two different representations
    for zero; we’d much rather use that bit combination to represent another number.
    Second, arithmetic using XOR and AND doesn’t work using this representation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 符号和大小表示法由于两个原因不常用。首先，构建位需要成本，因此我们不想通过为零使用两种不同的表示来浪费它们；我们宁愿用这些位组合来表示另一个数字。第二，使用异或（XOR）和与（AND）进行算术运算时，这种表示法不起作用。
- en: '**Table 1-3:** Sign and Magnitude Binary Numbers'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-3：** 符号和大小二进制数'
- en: '| **Sign** | **2²** | **2¹** | **2⁰** | **Decimal** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **2²** | **2¹** | **2⁰** | **十进制** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `1` | `1` | `1` | +7 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | +7 |'
- en: '| `0` | `1` | `1` | `0` | +6 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `0` | +6 |'
- en: '| `0` | `1` | `0` | `1` | +5 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` | +5 |'
- en: '| `0` | `1` | `0` | `0` | +4 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | +4 |'
- en: '| `0` | `0` | `1` | `1` | +3 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `1` | +3 |'
- en: '| `0` | `0` | `1` | `0` | +2 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | +2 |'
- en: '| `0` | `0` | `0` | `1` | +1 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `1` | +1 |'
- en: '| `0` | `0` | `0` | `0` | +0 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | +0 |'
- en: '| `1` | `0` | `0` | `0` | –0 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | –0 |'
- en: '| `1` | `0` | `0` | `1` | –1 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` | –1 |'
- en: '| `1` | `0` | `1` | `0` | –2 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` | –2 |'
- en: '| `1` | `0` | `1` | `1` | –3 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | –3 |'
- en: '| `1` | `1` | `0` | `0` | –4 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `0` | –4 |'
- en: '| `1` | `1` | `0` | `1` | –5 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | –5 |'
- en: '| `1` | `1` | `1` | `0` | –6 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `0` | –6 |'
- en: '| `1` | `1` | `1` | `1` | –7 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | –7 |'
- en: Let’s say that we want to add +1 to –1\. We’d expect to get 0, but using sign
    and magnitude representation we get a different result, as shown in [Figure 1-10](ch01.xhtml#ch01fig10).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想把 +1 加到 -1 上。我们期望得到 0，但使用符号和大小表示法时我们得到了不同的结果，如[图1-10](ch01.xhtml#ch01fig10)所示。
- en: '![Image](../images/01fig10.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig10.jpg)'
- en: '*Figure 1-10: Sign and magnitude addition*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-10：符号和大小加法*'
- en: As you can see, 0001 represents positive 1 in binary, because its sign bit is
    0\. The 1001 represents –1 in binary, because the sign bit is 1\. Adding these
    together using XOR and AND arithmetic gives us 1010\. This evaluates to –2 in
    decimal notation, which is not the sum of +1 and –1.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，0001表示二进制中的正1，因为其符号位是0。1001表示二进制中的负1，因为符号位是1。使用XOR和AND算术将它们相加，得到1010。它的十进制值是-2，这不是+1和-1的和。
- en: We could make sign and magnitude arithmetic work by using more complicated logic,
    but there’s value in keeping things as simple as possible. Let’s explore a few
    other ways of representing numbers to find a better approach.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用更复杂的逻辑来使符号和大小算术运算正常工作，但将事情保持尽可能简单也是有价值的。让我们探索几种不同的数字表示方式，找到更好的方法。
- en: '**One’s Complement**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一的补码**'
- en: Another way to get negative numbers is to take positive numbers and flip all
    the bits, which is called *one’s complement* representation. We partition the
    bits in a manner similar to sign and magnitude. In this context, we get a complement
    using the NOT operation. [Table 1-4](ch01.xhtml#ch01tab04) shows –7 through 7
    using one’s complement.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 获取负数的另一种方法是将正数的所有位反转，这就是所谓的*一的补码*表示法。我们将位分区的方式类似于符号和大小。在这个过程中，我们通过NOT操作得到补码。[表1-4](ch01.xhtml#ch01tab04)展示了使用一的补码表示的从–7到7的数值。
- en: '**Table 1-4:** One’s Complement Binary Numbers'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1-4：** 一的补码二进制数'
- en: '| **Sign** | **2²** | **2¹** | **2⁰** | **Decimal** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **2²** | **2¹** | **2⁰** | **十进制** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `1` | `1` | `1` | +7 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | +7 |'
- en: '| `0` | `1` | `1` | `0` | +6 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `0` | +6 |'
- en: '| `0` | `1` | `0` | `1` | +5 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` | +5 |'
- en: '| `0` | `1` | `0` | `0` | +4 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | +4 |'
- en: '| `0` | `0` | `1` | `1` | +3 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `1` | +3 |'
- en: '| `0` | `0` | `1` | `0` | +2 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | +2 |'
- en: '| `0` | `0` | `0` | `1` | +1 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `1` | +1 |'
- en: '| `0` | `0` | `0` | `0` | +0 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | +0 |'
- en: '| `1` | `1` | `1` | `1` | –0 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | –0 |'
- en: '| `1` | `1` | `1` | `0` | –1 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `0` | –1 |'
- en: '| `1` | `1` | `0` | `1` | –2 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | –2 |'
- en: '| `1` | `1` | `0` | `0` | –3 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `0` | –3 |'
- en: '| `1` | `0` | `1` | `1` | –4 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | –4 |'
- en: '| `1` | `0` | `1` | `0` | –5 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` | –5 |'
- en: '| `1` | `0` | `0` | `1` | –6 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` | –6 |'
- en: '| `1` | `0` | `0` | `0` | –7 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | –7 |'
- en: As you can see, flipping each bit of 0111 (+7) yields 1000 (–7).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将0111（+7）的每一位反转得到1000（–7）。
- en: One’s complement representation still has the problem of two different representations
    for zero. It still doesn’t let us perform addition easily, either. To get around
    this, we use *end-around carry* to add 1 to the LSB if there is a carry out of
    the most significant position in order to get the correct result. [Figure 1-11](ch01.xhtml#ch01fig11)
    illustrates how this works.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一的补码表示法仍然存在两个零的不同表示问题。它仍然不能轻松进行加法运算。为了解决这个问题，我们使用*环绕进位*，如果从最高有效位有进位，则将进位加到最低有效位以得到正确的结果。[图1-11](ch01.xhtml#ch01fig11)展示了这一过程是如何工作的。
- en: '![Image](../images/01fig11.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig11.jpg)'
- en: '*Figure 1-11: One’s complement addition*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-11：一的补码加法*'
- en: To add +2 and –1 using one’s complement, we perform binary addition of 0010
    and 1110 as we would normally. Because adding the digits in the most significant
    bit (sign bit) results in 10, we bring down 0 and carry the 1 as the end-around
    carry for each digit. But we only have 4 bits to work with, so when we get to
    the MSB, we bring the carry back to the first bit to give us 0001, or +1, which
    is the correct sum of +2 and –1\. As you can see, making this work adds a significant
    amount of complexity.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用反补码表示法加上 +2 和 -1，我们按通常的方式对 0010 和 1110 进行二进制加法。由于在最高有效位（符号位）加法的结果是 10，我们将
    0 带下来，并将 1 作为每一位的进位。但我们只有 4 位可用，因此当我们到达最高有效位时，我们将进位带回到第一位，得到 0001，即 +1，这就是 +2
    和 -1 的正确和。如你所见，要使这一过程可行需要增加大量的复杂性。
- en: While this works, it still isn’t a great solution because we need additional
    hardware to add the end-around carry bit.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可行，但仍然不是一个很好的解决方案，因为我们需要额外的硬件来处理进位位。
- en: Neither sign and magnitude nor one’s complement representation is used in modern
    computers. Arithmetic using these methods doesn’t work without extra hardware,
    and extra hardware costs money. Let’s see if we can come up with a representation
    that solves this problem.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机不使用符号和大小或反补码表示法。这些方法的算术运算没有额外的硬件是无法正常工作的，而额外的硬件需要花费金钱。让我们看看能否找到一种能解决这个问题的表示法。
- en: '**Two’s Complement**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**二进制补码**'
- en: What would happen if we didn’t add any special hardware and just stuck with
    the XOR and AND operations? Let’s figure out what bit pattern, when added to +1,
    would result in 0 and call that –1\. If we stick with 4-bit numbers, +1 is 0001\.
    Adding 1111 to it results in 0000, as shown in [Figure 1-12](ch01.xhtml#ch01fig12),
    so we’ll use that bit pattern to represent –1.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不添加任何特殊硬件，只使用 XOR 和 AND 操作，会发生什么情况？我们来弄清楚，当 +1 加上某个比特模式时，结果是 0，并称之为 -1。假设我们使用
    4 位数字，+1 为 0001。将 1111 加到它上面，结果是 0000，如[图 1-12](ch01.xhtml#ch01fig12)所示，因此我们将使用这个比特模式来表示
    -1。
- en: '![Image](../images/01fig12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig12.jpg)'
- en: '*Figure 1-12: Finding –1*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-12：找到 -1*'
- en: This is called *two’s complement* representation, and it’s the most commonly
    used binary representation for signed integers. We can obtain the negative of
    a number by complementing the number (that is, doing a NOT of each bit) and then
    adding 1, throwing away any carry from the MSB. The complement of +1, 0001, is
    1110, and adding 1 gives us 1111 for –1\. Likewise, +2 is 0010, its complement
    is 1101, and adding 1 gives us 1110 to represent –2\. [Table 1-5](ch01.xhtml#ch01tab05)
    shows –8 through 7 using two’s complement representation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的 *二进制补码* 表示法，它是最常用的有符号整数二进制表示法。我们可以通过对一个数字进行补码（即对每一位进行 NOT 操作）然后加 1 来得到该数字的负数，同时丢弃最高有效位的进位。+1
    的补码是 0001，补码是 1110，再加 1 就得到 1111 表示 -1。同样，+2 是 0010，它的补码是 1101，再加 1 就得到 1110 来表示
    -2。[表 1-5](ch01.xhtml#ch01tab05)展示了使用二进制补码表示法的 -8 到 +7。
- en: '**Table 1-5:** Two’s Complement Binary Numbers'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-5：** 二进制补码数字'
- en: '| **Sign** | **2²** | **2¹** | **2⁰** | **Decimal** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **2²** | **2¹** | **2⁰** | **十进制** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `0` | `1` | `1` | `1` | +7 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `1` | +7 |'
- en: '| `0` | `1` | `1` | `0` | +6 |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `1` | `0` | +6 |'
- en: '| `0` | `1` | `0` | `1` | +5 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `1` | +5 |'
- en: '| `0` | `1` | `0` | `0` | +4 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `1` | `0` | `0` | +4 |'
- en: '| `0` | `0` | `1` | `1` | +3 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `1` | +3 |'
- en: '| `0` | `0` | `1` | `0` | +2 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `1` | `0` | +2 |'
- en: '| `0` | `0` | `0` | `1` | +1 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `1` | +1 |'
- en: '| `0` | `0` | `0` | `0` | +0 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `0` | `0` | `0` | +0 |'
- en: '| `1` | `1` | `1` | `1` | –1 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `1` | –1 |'
- en: '| `1` | `1` | `1` | `0` | –2 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `1` | `0` | –2 |'
- en: '| `1` | `1` | `0` | `1` | –3 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `1` | –3 |'
- en: '| `1` | `1` | `0` | `0` | –4 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `1` | `0` | `0` | –4 |'
- en: '| `1` | `0` | `1` | `1` | –5 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `1` | –5 |'
- en: '| `1` | `0` | `1` | `0` | –6 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `1` | `0` | –6 |'
- en: '| `1` | `0` | `0` | `1` | –7 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `1` | –7 |'
- en: '| `1` | `0` | `0` | `0` | –8 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `0` | `0` | `0` | –8 |'
- en: Let’s try this using 0 to see if two’s complement fixes the issue of duplicate
    representations for zero. If we take 0000 and flip every bit, we get 1111 as its
    complement. Adding 1 to 1111 gives us [1]0000, but because this is a 5-bit number
    that exceeds the number of bits available to us, we can disregard the 1 in the
    carry bit. This leaves us with 0000, which is what we started with, so zero has
    only one representation in two’s complement.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着使用 0 来看看二进制补码是否解决了零的重复表示问题。如果我们将 0000 反转每一位，得到 1111 作为它的补码。将 1 加到 1111
    上，我们得到 [1]0000，但因为这是一个 5 位数字，超出了可用的位数，所以我们可以忽略进位中的 1。这样，我们剩下的就是 0000，这是我们最开始的值，因此零在二进制补码中只有一个表示。
- en: Programmers need to know how many bits are required to hold the numbers they
    need. This will eventually become second nature. In the meantime, you can refer
    to [Table 1-6](ch01.xhtml#ch01tab06), which shows the range of values that we
    can represent using two’s complement numbers of various sizes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员需要知道表示所需数字需要多少位。这将最终成为第二天性。与此同时，你可以参考[表 1-6](ch01.xhtml#ch01tab06)，它展示了我们可以使用不同大小的二进制补码表示的值的范围。
- en: '**Table 1-6:** Ranges of Two’s Complement Binary Number Values'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-6:** 二进制补码数值范围'
- en: '| **Number of bits** | **Number of values** | **Range of values** |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **位数** | **值的数量** | **值的范围** |'
- en: '| --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 4 | 16 | –8...7 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 16 | –8...7 |'
- en: '| 8 | 256 | –128...127 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 256 | –128...127 |'
- en: '| 12 | 4,096 | 2,048...2,047 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4,096 | 2,048...2,047 |'
- en: '| 16 | 65,536 | –32,768...32,767 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 65,536 | –32,768...32,767 |'
- en: '| 20 | 1,048,576 | –524,288...524,287 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 1,048,576 | –524,288...524,287 |'
- en: '| 24 | 16,777,216 | –8,388,608...8,388,607 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 16,777,216 | –8,388,608...8,388,607 |'
- en: '| 32 | 4,294,967,296 | –2,147,483,648...2,137,483,647 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 4,294,967,296 | –2,147,483,648...2,137,483,647 |'
- en: '| 64 | 18,446,744,073,709,551,616 | –9,223,372,036,854,775,808 ...9,223,372,036,854,775,807
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 64 | 18,446,744,073,709,551,616 | –9,223,372,036,854,775,808 ...9,223,372,036,854,775,807
    |'
- en: As you can see from [Table 1-6](ch01.xhtml#ch01tab06), as the number of bits
    increases, the range of values that can be represented increases exponentially.
    It’s important to keep in mind that we always need context to determine whether
    a 4-bit number that we’re looking at is a 15 instead of a –1 using two’s complement,
    a –7 using sign and magnitude, or a –0 using one’s complement. You have to know
    which representation you’re using.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从[表 1-6](ch01.xhtml#ch01tab06)中可以看出，随着位数的增加，可以表示的值范围呈指数级增长。重要的是要记住，我们始终需要上下文来确定我们看到的一个4位数字是二进制补码表示的15，而不是–1，是符号和幅度表示的–7，还是一补码表示的–0。你必须知道你正在使用哪种表示方法。
- en: '**Representing Real Numbers**'
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**表示实数**'
- en: So far, we’ve managed to represent whole numbers using binary. But what about
    real numbers? Real numbers include a decimal point in base 10\. We need some way
    to represent the equivalent binary point in base 2\. Once again, this can be accomplished
    by interpreting bits in different contexts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够使用二进制表示整数。那么，如何表示实数呢？实数在十进制中包含一个小数点。我们需要某种方法来表示二进制中等效的小数点。再次说明，这可以通过在不同的上下文中解释位来实现。
- en: '***Fixed-Point Representation***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***定点表示***'
- en: One way to represent fractions using binary is by choosing an arbitrary place
    for a binary point, the binary equivalent of the decimal point. If we have 4 bits,
    for example, we can pretend that two of them are to the right of the binary point,
    representing four fractional values, and two are to the left, representing four
    whole values. This is called a *fixed-point* representation, because the location
    of the binary point is fixed. [Table 1-7](ch01.xhtml#ch01tab07) shows how this
    would work.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制表示小数的一种方法是选择一个任意位置作为二进制点，即小数点的二进制等价物。例如，如果我们有4位，我们可以假设其中两位位于二进制点的右侧，表示四个小数值，另外两位位于左侧，表示四个整数值。这种表示方法称为*定点*表示，因为二进制点的位置是固定的。[表
    1-7](ch01.xhtml#ch01tab07)展示了这种表示方法如何工作。
- en: '**Table 1-7:** Fixed-Point Binary Numbers'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-7:** 定点二进制数'
- en: '| **Whole** |  | **Fraction** | **Value** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **整数** |  | **小数** | **值** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | . | 0 | 0 | 0 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | . | 0 | 0 | 0 |'
- en: '| 0 | 0 | . | 0 | 1 | ¼ |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | . | 0 | 1 | ¼ |'
- en: '| 0 | 0 | . | 1 | 0 | ½ |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | . | 1 | 0 | ½ |'
- en: '| 0 | 0 | . | 1 | 1 | ¾ |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | . | 1 | 1 | ¾ |'
- en: '| 0 | 1 | . | 0 | 0 | 1 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | . | 0 | 0 | 1 |'
- en: '| 0 | 1 | . | 0 | 1 | 1¼ |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | . | 0 | 1 | 1¼ |'
- en: '| 0 | 1 | . | 1 | 0 | 1½ |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | . | 1 | 0 | 1½ |'
- en: '| 0 | 1 | . | 1 | 1 | 1¾ |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | . | 1 | 1 | 1¾ |'
- en: '| 1 | 0 | . | 0 | 0 | 2 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | . | 0 | 0 | 2 |'
- en: '| 1 | 0 | . | 0 | 1 | 2¼ |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | . | 0 | 1 | 2¼ |'
- en: '| 1 | 0 | . | 1 | 0 | 2½ |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | . | 1 | 0 | 2½ |'
- en: '| 1 | 0 | . | 1 | 1 | 2¾ |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | . | 1 | 1 | 2¾ |'
- en: '| 1 | 1 | . | 0 | 0 | 3 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | . | 0 | 0 | 3 |'
- en: '| 1 | 1 | . | 0 | 1 | 3¼ |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | . | 0 | 1 | 3¼ |'
- en: '| 1 | 1 | . | 1 | 0 | 3½ |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | . | 1 | 0 | 3½ |'
- en: '| 1 | 1 | . | 1 | 1 | 3¾ |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | . | 1 | 1 | 3¾ |'
- en: The whole numbers to the left of the point should look familiar from binary
    notation. Similar to what we saw with integers, we have four values from the 2
    bits to the right of the point; they represent fourths instead of the familiar
    tenths from decimal.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 小数点左侧的整数应该看起来很熟悉，来自二进制表示。与我们在整数中看到的类似，我们从点右边的2位中得到四个值，它们表示的是四分之一，而不是十进制中的熟悉的十分之一。
- en: While this approach works pretty well, it’s not often used in general-purpose
    computers because it takes way too many bits to represent a useful range of numbers.
    Certain special-purpose computers, called *digital signal processors* (*DSP*),
    still use fixed-point numbers. And, as you’ll see in [Chapter 11](ch11.xhtml#ch11),
    fixed-point numbers are useful in certain applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法效果相当不错，但它并不常用于通用计算机，因为它需要使用大量位数来表示有用的数字范围。某些特殊用途计算机，如*数字信号处理器*（*DSP*），仍然使用定点数。而且，正如你将在[第11章](ch11.xhtml#ch11)中看到的那样，定点数在某些应用中仍然是有用的。
- en: General-purpose computers are built to solve general-purpose problems, which
    involve a wide range of numbers. You can get an idea of this range by skimming
    a physics textbook. For example, there are tiny numbers such as Planck’s constant
    (6.63 × 10^(–34) joule-seconds) and huge numbers such as Avogadro’s constant (6.02
    × 10^(23) molecules/mole). This is a range of 10^(57), which comes out to about
    2^(191). That’s almost 200 bits! Bits just aren’t cheap enough to use a few hundred
    of them to represent every number, so we need a different approach.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通用计算机被设计用来解决通用问题，这些问题涉及范围广泛的数字。你可以通过快速浏览一本物理学教材来了解这个范围。例如，有像普朗克常数（6.63 × 10^(–34)
    焦耳·秒）这样的极小数字，也有像阿伏伽德罗常数（6.02 × 10^(23) 分子/摩尔）这样的巨大数字。这是一个10^(57)的范围，约等于2^(191)，也就是接近200位！位数并不便宜，无法用几百位表示每一个数字，因此我们需要一种不同的方法。
- en: '***Floating-Point Representation***'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***浮点数表示法***'
- en: We solve this using a binary version of the scientific notation used to represent
    the wide range of numbers that includes Planck’s and Avogadro’s constants. Scientific
    notation represents a large range of numbers by (how else?) creating a new context
    for interpretation. It uses a number with a single digit to the left of the decimal
    point, called the *mantissa*, multiplied by 10 raised to some power, called the
    *exponent*. Computers use the same system, except that the mantissa and exponent
    are binary numbers and 2 is used instead of 10.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用科学计数法的二进制版本来解决这个问题，这种表示方法用于表示包括普朗克常数和阿伏伽德罗常数在内的广泛数字范围。科学计数法通过（还有其他方法吗？）为解释创建一个新的上下文来表示大范围的数字。它使用一个十进制点左侧的数字，称为*尾数*，乘以10的某个幂，称为*指数*。计算机使用相同的系统，只不过尾数和指数是二进制数字，并且使用2而不是10。
- en: 'This is called *floating-point* representation, which is confusing because
    the binary (or decimal) point is always in the same place: between the ones and
    halves (tenths in decimal). The “float” is just another way of saying “scientific
    notation,” which allows us to write 1.2 × 10^(–3) instead of 0.0012.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的*浮点数*表示法，它之所以令人困惑，是因为二进制（或十进制）小数点总是位于相同的位置：在“1”和“2”之间（在十进制中是十位和分位之间）。
    “浮点”只是另一种说法，即“科学计数法”，它让我们可以写成1.2 × 10^(–3)，而不是0.0012。
- en: Note that we don’t need any bits to indicate that the base is 2, because the
    floating-point definition says that it’s there by default. By separating the significant
    digits from the exponents, the floating-point system allows us to represent very
    small or very large numbers without having to store all those zeros.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要任何位来表示基数是2，因为浮点数定义默认就假设基数是2。通过将有效数字与指数分开，浮点数系统允许我们表示非常小或非常大的数字，而无需存储所有那些零。
- en: '[Table 1-8](ch01.xhtml#ch01tab08) shows a 4-bit floating-point representation
    with 2 bits of mantissa and 2 bits of exponent.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-8](ch01.xhtml#ch01tab08)展示了一个4位浮点数表示法，其中2位为尾数，2位为指数。'
- en: '**Table 1-8:** Floating-Point Binary Numbers'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-8：** 浮点二进制数字'
- en: '| **Mantissa** |  | **Exponent** | **Value** |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **尾数** |  | **指数** | **值** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | . | 0 | 0 | 0 (0 × 2⁰) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | . | 0 | 0 | 0 (0 × 2⁰) |'
- en: '| 0 | 0 | . | 0 | 1 | 0 (0 × 2¹) |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | . | 0 | 1 | 0 (0 × 2¹) |'
- en: '| 0 | 0 | . | 1 | 0 | 0 (0 × 2¹) |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | . | 1 | 0 | 0 (0 × 2¹) |'
- en: '| 0 | 0 | . | 1 | 1 | 0 (0 × 2³) |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | . | 1 | 1 | 0 (0 × 2³) |'
- en: '| 0 | 1 | . | 0 | 0 | 0.5 (½ × 2⁰) |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | . | 0 | 0 | 0.5 (½ × 2⁰) |'
- en: '| 0 | 1 | . | 0 | 1 | 1.0 (½ × 2¹) |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | . | 0 | 1 | 1.0 (½ × 2¹) |'
- en: '| 0 | 1 | . | 1 | 0 | 2.0 (½ × 2²) |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | . | 1 | 0 | 2.0 (½ × 2²) |'
- en: '| 0 | 1 | . | 1 | 1 | 4.0 (½ × 2³) |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | . | 1 | 1 | 4.0 (½ × 2³) |'
- en: '| 1 | 0 | . | 0 | 0 | 1.0 (1 × 2⁰) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | . | 0 | 0 | 1.0 (1 × 2⁰) |'
- en: '| 1 | 0 | . | 0 | 1 | 2.0 (1 × 2¹) |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | . | 0 | 1 | 2.0 (1 × 2¹) |'
- en: '| 1 | 0 | . | 1 | 0 | 4.0 (1 × 2²) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | . | 1 | 0 | 4.0 (1 × 2²) |'
- en: '| 1 | 0 | . | 1 | 1 | 8.0 (1 × 2³) |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | . | 1 | 1 | 8.0 (1 × 2³) |'
- en: '| 1 | 1 | . | 0 | 0 | 1.5 (1½ × 2⁰) |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | . | 0 | 0 | 1.5 (1½ × 2⁰) |'
- en: '| 1 | 1 | . | 0 | 1 | 3.0 (1½ × 2¹) |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | . | 0 | 1 | 3.0 (1½ × 2¹) |'
- en: '| 1 | 1 | . | 1 | 0 | 6.0 (1½ × 2²) |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | . | 1 | 0 | 6.0 (1½ × 2²) |'
- en: '| 1 | 1 | . | 1 | 1 | 12.0 (1½ × 2³) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | . | 1 | 1 | 12.0 (1½ × 2³) |'
- en: While this example uses only a few bits, it reveals some inefficiencies present
    in this floating-point system. First, you’ll notice that there are a lot of wasted
    bit combinations. For example, there are four ways to represent 0 and two ways
    to represent 1.0, 2.0, and 4.0\. Second, there aren’t bit patterns for every possible
    number; the exponent makes numbers farther apart as they get bigger. One of the
    side effects is that, while we can add 0.5 and 0.5 to get 1.0, we can’t add 0.5
    and 6.0 because there’s no bit pattern that represents 6.5\. (There is a whole
    subbranch of mathematics, called *numerical analysis*, that involves keeping track
    of how inaccurate calculations are.)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子只使用了几个比特，但它揭示了这个浮点系统中存在的一些低效之处。首先，你会注意到有很多浪费的比特组合。例如，有四种方式表示0，有两种方式表示1.0、2.0和4.0。其次，并不是每个可能的数字都有对应的比特模式；随着数字变大，指数会让数字之间的距离变得更远。其副作用之一是，虽然我们可以将0.5和0.5相加得到1.0，但我们无法将0.5和6.0相加，因为没有比特模式表示6.5。（有一个数学分支，叫做*数值分析*，专门研究如何跟踪计算结果的准确性。）
- en: '***The IEEE Floating-Point Standard***'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***IEEE浮点标准***'
- en: Strange as it is, the floating-point system is the standard way to represent
    real numbers in computing. More bits are used than in [Table 1-8](ch01.xhtml#ch01tab08),
    and there are two signs, one for the mantissa and a hidden one that is part of
    the exponent. There are also a lot of tricks to make sure that things like rounding
    work as well as possible and to minimize the number of wasted bit combinations.
    A standard called *IEEE 754* spells all of this out. IEEE stands for the Institute
    of Electrical and Electronic Engineers, which is a professional organization whose
    activities include producing standards.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管奇怪，浮点系统仍然是计算机中表示实数的标准方法。使用的比特比[表 1-8](ch01.xhtml#ch01tab08)中更多，并且有两个符号，一个用于尾数，另一个是隐藏的符号，属于指数部分。此外，还有许多技巧确保诸如舍入等操作尽可能精确，并尽量减少浪费的比特组合。一个叫做*IEEE
    754*的标准详细规定了所有这些内容。IEEE代表电气和电子工程师协会，这是一个专业组织，其活动包括制定标准。
- en: We want to maximize our precision given the available bits. One clever trick
    is called *normalization*, which adjusts the mantissa so that there are no leading
    (that is, on the left) zeros. Every left adjustment of the mantissa requires a
    corresponding adjustment of the exponent. A second trick, from Digital Equipment
    Corporation (DEC), doubles the accuracy by throwing away the leftmost bit of the
    mantissa since we know that it will always be 1, which makes room for one more
    bit.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在可用的比特数下最大化精度。一个聪明的技巧叫做*归一化*，它调整尾数，以确保没有前导零（即左边的零）。每次左移尾数都需要相应调整指数。第二个技巧，来自数字设备公司（DEC），通过丢弃尾数的最左边的比特来提高精度，因为我们知道它总是1，从而为另一个比特腾出空间。
- en: 'You don’t need to know all of the gory details of IEEE 754 (yet). But you should
    know about two types of floating-point numbers that you’ll run into a lot: single
    precision and double precision. Single-precision numbers use 32 bits and can represent
    numbers approximately in the range ±10^(±38) with about 7 digits of accuracy.
    Double-precision numbers use 64 bits and can represent a wider range of numbers,
    approximately ±10^(±308), with about 15 digits of accuracy. [Figure 1-13](ch01.xhtml#ch01fig13)
    shows how they’re laid out.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要了解IEEE 754的所有细节（暂时）。但你应该了解你经常会遇到的两种浮点数类型：单精度和双精度。单精度数字使用32个比特，能够表示大约±10^(±38)范围内的数字，精度大约为7位数字。双精度数字使用64个比特，能够表示更广泛的数字范围，大约是±10^(±308)，精度为约15位数字。[图
    1-13](ch01.xhtml#ch01fig13)展示了它们的布局。
- en: '![Image](../images/01fig13.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig13.jpg)'
- en: '*Figure 1-13: IEEE floating-point number formats*'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-13：IEEE浮点数格式*'
- en: Both formats have a sign bit for the mantissa—the *S* in [Figure 1-13](ch01.xhtml#ch01fig13).
    You can see that double-precision numbers have three more exponent bits than single
    precision, giving eight times the range. Double-precision numbers also have 29
    more mantissa bits than single-precision ones, yielding greater accuracy. This
    all comes at the cost of taking twice as many bits as single-precision numbers,
    however.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 两种格式都有尾数的符号位——[图 1-13](ch01.xhtml#ch01fig13)中的*S*。你可以看到，双精度数字比单精度多了三个指数位，范围是单精度的八倍。双精度数字的尾数位比单精度多29个，从而提供了更高的精度。然而，这一切的代价是，双精度数字占用了比单精度数字多两倍的比特。
- en: You might have noticed that there is no explicit sign bit for the exponent.
    The designers of IEEE 754 decided that the exponent values of all 0s and all 1s
    would have special meaning so the actual exponent had to be crammed into the remaining
    bit patterns. They did this by using a *biased* (offset) exponent value. For single-precision
    numbers, the bias is 127, which means that the bit pattern for 127 (01111111)
    represents an exponent of 0\. The bit pattern for 1 (00000001) represents an exponent
    of –126, and 254 (11111110) represents +127\. Double precision is similar except
    that the bias is 1023.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，指数没有明确的符号位。IEEE 754的设计者决定，所有0和所有1的指数值将具有特殊意义，因此实际的指数值必须被塞进剩余的比特模式中。他们通过使用*偏置*（偏移）指数值来实现这一点。对于单精度数字，偏置值为127，这意味着127的比特模式（01111111）表示指数为0。1的比特模式（00000001）表示指数为-126，而254（11111110）表示指数为+127。双精度与此类似，只是偏置值为1023。
- en: One other handy part of IEEE 754 is that it has special bit patterns to represent
    things like division by zero, which evaluates to positive or negative infinity.
    It also specifies a special value called *NaN*, which stands for “not a number”—so
    if you find yourself in the NaNny state, it probably means that you did some illegal
    arithmetic operation. These special bit patterns use the reserved exponent values
    discussed previously.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 754的另一个方便之处在于，它有特殊的比特模式来表示像除以零这种运算，它的结果是正无穷大或负无穷大。它还定义了一个特殊值，叫做*NaN*，表示“不是一个数字”——所以，如果你发现自己处于NaN状态，可能意味着你进行了非法的算术运算。这些特殊的比特模式使用了前面讨论的保留指数值。
- en: '**Binary-Coded Decimal System**'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制编码十进制系统**'
- en: You’ve just seen some of the more common ways to represent numbers in binary,
    but there are many alternative systems. One is *binary-coded decimal* (*BCD*),
    in which we use 4 bits to represent each decimal digit. For example, the number
    12 in binary is 1100\. But in BCD, it’s 0001 0010, where 0001 represents 1 in
    the tens digit and 0010 represents 2 in the ones digit. This is a much more familiar
    and comfortable representation for people who are used to working in decimal.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到了几种常见的二进制数字表示方式，但还有许多其他的替代系统。其中一种是*二进制编码十进制*（*BCD*），我们使用4个比特来表示每个十进制数字。例如，数字12在二进制中是1100。但在BCD中，它是0001
    0010，其中0001表示十位上的1，0010表示个位上的2。这对习惯于使用十进制的人来说，是一种更为熟悉且舒适的表示方式。
- en: Computers used to know how to operate on BCD numbers, but that system is no
    longer mainstream. However, it does crop up in many places, so it’s worth knowing
    about. In particular, many devices with which computers interact, such as displays
    and accelerometers, use BCD.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机曾经能够处理BCD（Binary-Coded Decimal）数字，但这个系统现在已经不再是主流。然而，它在许多地方仍然会出现，所以了解它是值得的。特别是，许多计算机交互的设备，如显示器和加速度计，都使用BCD。
- en: The main reason the BCD system has fallen out of favor is that it doesn’t use
    bits as efficiently as binary. You can see that BCD needs more bits than binary
    to represent a number. While bits are much cheaper than they used to be, they’re
    not so cheap that we want to throw away 6 out of every 16 bit combinations, as
    that would be equivalent to wasting a whopping 37.5 percent of available bits.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: BCD系统逐渐被淘汰的主要原因是它没有像二进制那样高效地使用比特。可以看到，BCD需要比二进制更多的比特来表示一个数字。尽管比特变得比以前便宜了，但它们也没有便宜到我们愿意丢弃每16个比特组合中的6个，因为那相当于浪费了37.5%的可用比特。
- en: '**Easier Ways to Work with Binary Numbers**'
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更简便的二进制数字处理方式**'
- en: It’s a well-known fact that manipulating binary numbers leads to blindness;
    it can be visually exhausting! People have come up with a few ways to make binary
    numbers easier to read. We’ll look at a few of them here.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，操作二进制数字会导致视力受损；它会让人视觉疲劳！人们已经想出了一些方法，让二进制数字更容易阅读。我们将在这里介绍其中的一些方法。
- en: '***Octal Representation***'
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***八进制表示***'
- en: One eyeball-friendly approach is *octal representation*. *Octal* means base-8,
    and the idea behind octal representation is to group bits in threes. As you should
    know by now, 3 bits can be used to represent 2³, or eight values from 0 through
    7\. Let’s say that we have some monster binary number like 100101110001010100\.
    This hurts my eyeballs. [Figure 1-14](ch01.xhtml#ch01fig14) shows how to transform
    it into octal representation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一种对眼睛友好的方法是*八进制表示*。*八进制*表示的是基数为8，八进制表示的思想是将比特按三位一组。正如你现在应该知道的，3个比特可以表示2³，即从0到7的八个值。假设我们有一个像100101110001010100这样的庞大二进制数字。它让我的眼睛很难受。[图
    1-14](ch01.xhtml#ch01fig14)展示了如何将它转换成八进制表示。
- en: '![Image](../images/01fig14.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig14.jpg)'
- en: '*Figure 1-14: Octal representation of binary numbers*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-14：二进制数的八进制表示*'
- en: 'As you can see, we divide the bits into groups of three, and we assign the
    octal value to each group to get 456124, which is a lot easier to read. To get
    the octal value of 100, for example, we simply treat it as a binary number: (1
    × 2²) + (0 × 2¹) + (0 × 2⁰) = 4.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将位分成三位一组，然后为每一组分配一个八进制值，得到 456124，这样读起来就容易多了。例如，要得到 100 的八进制值，我们只需将它当作一个二进制数处理：（1
    × 2²）+（0 × 2¹）+（0 × 2⁰）= 4。
- en: '***Hexadecimal Representation***'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***十六进制表示***'
- en: Octal representation is still in use, but not as widely as in the past. *Hexadecimal
    representation* (meaning base-16) has pretty much taken over because the insides
    of computers are built in multiples of 8 bits these days, which is evenly divisible
    by 4 but not by 3.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制表示仍在使用，但不如过去那么广泛。*十六进制表示*（即基数为 16）几乎已经取代了它，因为现在计算机的内部结构是以 8 位为单位的，这样就可以整除
    4，但不能整除 3。
- en: It was easy to repurpose some of the symbols from our familiar digits for binary
    because we needed only two of them, the 0 and 1\. We needed only 8 of the 10 for
    octal. But we need 16 for hexadecimal, which is more than we have. We need a symbol
    to represent 10, another for 11, all the way up through 15\. We *make believe*
    (I told you that we’d be doing that) that the symbols abcdef (or ABCDEF) represent
    the values 10 through 16\. For example, let’s say we have another scary binary
    number like 11010011111111000001\. [Figure 1-15](ch01.xhtml#ch01fig15) shows how
    to convert it into hexadecimal.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二进制，我们很容易重新利用我们熟悉的符号，因为我们只需要两个符号：0 和 1。对于八进制，我们只需要 8 个数字中的 8 个。但是对于十六进制，我们需要
    16 个符号，这比我们现有的还要多。我们需要一个符号表示 10，另一个符号表示 11，一直到 15。我们*假装*（我告诉过你我们要这么做）字母 abcdef（或
    ABCDEF）代表 10 到 16 的值。例如，假设我们有一个看起来吓人的二进制数字 11010011111111000001。[图 1-15](ch01.xhtml#ch01fig15)
    展示了如何将其转换为十六进制。
- en: '![Image](../images/01fig15.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig15.jpg)'
- en: '*Figure 1-15: Hexadecimal representation of binary numbers*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-15：二进制数的十六进制表示*'
- en: In this example, we divide the bits into groups of four. Then we assign one
    of the 16 symbol values (0123456789abcdef) to each group. For example, 1101 (the
    first group of 4 bits) would be `d` because it evaluates to 1(2³) + 1(2²) + 0(2¹)
    + 1(2⁰) = 13 in decimal notation and `d` represents the number 13\. We map the
    next group of 4 bits (0011) to another symbol, and so on. For example, 11010011111111000001
    converts to d3fc1 in hexadecimal. [Table 1-9](ch01.xhtml#ch01tab09) shows a handy
    list of hexadecimal values that you can refer to until they become second nature.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将位分成四个一组。然后，我们为每一组分配一个 16 个符号中的值（0123456789abcdef）。例如，1101（第一组 4 位）会被分配为
    `d`，因为它的值是 1(2³) + 1(2²) + 0(2¹) + 1(2⁰) = 13，十进制表示的 13 用 `d` 来表示。我们将接下来的 4 位（0011）映射到另一个符号，依此类推。例如，11010011111111000001
    转换为 d3fc1 的十六进制值。[表 1-9](ch01.xhtml#ch01tab09) 列出了一个方便的十六进制值列表，你可以参考直到它变得得心应手。
- en: '**Table 1-9:** Binary-to-Hexadecimal Conversion'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-9：二进制到十六进制的转换**'
- en: '| **Binary** | **Hexadecimal** | **Binary** | **Hexadecimal** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十六进制** | **二进制** | **十六进制** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0000` | 0 | `1000` | 8 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `0000` | 0 | `1000` | 8 |'
- en: '| `0001` | 1 | `1001` | 9 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `0001` | 1 | `1001` | 9 |'
- en: '| `0010` | 2 | `1010` | a |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `0010` | 2 | `1010` | a |'
- en: '| `0011` | 3 | `1011` | b |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `0011` | 3 | `1011` | b |'
- en: '| `0100` | 4 | `1100` | c |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `0100` | 4 | `1100` | c |'
- en: '| `0101` | 5 | `1101` | d |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `0101` | 5 | `1101` | d |'
- en: '| `0110` | 6 | `1110` | e |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `0110` | 6 | `1110` | e |'
- en: '| `0111` | 7 | `1111` | f |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| `0111` | 7 | `1111` | f |'
- en: '***Representing the Context***'
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***表示上下文***'
- en: 'How do you know how to interpret a number? For example, the number 10 is 2
    if it’s a binary number, 8 if it’s octal, 10 if it’s decimal, and 16 if it’s hexadecimal.
    Math books use subscripts, so we can use those to distinguish between them like
    this: 10[2], 10[8], 10[10], or 10[16]. But subscripts are inconvenient to type
    on a computer keyboard. It would be nice if we could use a consistent notation,
    but unfortunately lots of people think they have a better way and keep inventing
    new ones. The following notations are used by many computer programming languages:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道如何解读一个数字呢？例如，数字 10 如果是二进制就是 2，八进制是 8，十进制是 10，十六进制是 16。数学书籍使用下标，因此我们可以用下标来区分它们，像这样：10[2]、10[8]、10[10]
    或 10[16]。但是，在计算机键盘上输入下标不太方便。如果我们能使用一种一致的表示法，那就好了，可惜很多人认为他们有更好的方法，并不断发明新的表示法。以下是许多计算机编程语言使用的表示法：
- en: A number that begins with a 0 is an octal number—for example, 017.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 0 开头的数字是八进制数字——例如，017。
- en: A number that begins with one of the digits 1 through 9 is a decimal number—for
    example, 123.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以1到9之间的数字开头的数字是十进制数——例如，123。
- en: A number that’s prefixed with 0x is a hexadecimal number—for example, 0x12f.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以0x为前缀的数字是十六进制数——例如，0x12f。
- en: Note that we can’t tell the difference between octal and decimal 0, but that’s
    not important because they have the same value. And few programing languages have
    a notation for binary because it really isn’t used very much anymore and can usually
    be determined by context. Some languages, such as C++, use a 0b prefix to represent
    binary numbers.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们无法区分八进制和十进制的0，但这不重要，因为它们具有相同的值。而且很少有编程语言使用二进制的表示法，因为二进制不再广泛使用，通常可以通过上下文来确定。有些语言，如C++，使用0b前缀来表示二进制数字。
- en: '**Naming Groups of Bits**'
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**位的命名**'
- en: Computers are not just unorganized buckets of bits. The people who design them
    have to make decisions about the number of bits and their organization for cost
    reasons. Just as with number representations, many ideas have been tried, and
    only some have survived.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不仅仅是无组织的位桶。设计计算机的人必须根据成本原因对位数和组织结构做出决策。就像数字表示一样，许多方案曾被尝试过，只有一些方案得以存活。
- en: Bits are too small a unit to be very useful, so they’re organized into larger
    chunks. For example, the Honeywell 6000 series of computers used 36-bit chunks
    as its basic organization and allowed those to be partitioned into 18-, 9-, or
    6-bit chunks or combined into 72-bit chunks. The DEC PDP-8, the first commercial
    minicomputer (introduced in 1965), used 12-bit chunks. Over time the world has
    settled on 8-bit chunks as a fundamental unit, which we call a *byte*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 位太小，不足以十分有用，因此它们被组织成更大的块。例如，霍尼韦尔6000系列计算机使用36位块作为其基本组织方式，并允许将这些块分为18位、9位或6位块，或合并成72位块。DEC
    PDP-8是第一台商业化的迷你计算机（于1965年推出），使用12位块。随着时间的推移，世界逐渐选择了8位块作为基本单元，我们称之为*字节（byte）*。
- en: Chunks of different sizes have names to make them easier to reference. [Table
    1-10](ch01.xhtml#ch01tab10) summarizes the names and sizes of some of the common
    units in use today.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 不同大小的块有名称，以便于引用。[表 1-10](ch01.xhtml#ch01tab10)总结了当前使用的某些常见单位的名称和大小。
- en: '**Table 1-10:** Names for Bit Collections'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-10：** 位集合的名称'
- en: '| **Name** | **Number of bits** |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **位数** |'
- en: '| --- | --- |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Nibble | 4 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 半字节 | 4 |'
- en: '| Byte | 8 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 8 |'
- en: '| Half word | 16 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 半字 | 16 |'
- en: '| Long word | 32 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 长字 | 32 |'
- en: '| Double word | 64 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 双字 | 64 |'
- en: You might be wondering why we have half, long, and double words but no plain
    words. *Word* is used to describe the natural size of things in a particular computer
    design. The natural size refers to the largest chunk that can be operated on quickly.
    For example, although you could access bytes, half words, and long words on the
    DEC PDP-11, it had a 16-bit internal organization, making the natural size 16
    bits. Programming languages such as C and C++ allow variables to be declared as
    `int` (short for *integer*), which makes them the natural size. You can also declare
    variables using a set of supported specific sizes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会疑惑为什么我们有半字、长字和双字，但却没有普通字。*字（Word）*用于描述在特定计算机设计中事物的自然大小。自然大小指的是可以快速操作的最大数据块。例如，虽然你可以在DEC
    PDP-11上访问字节、半字和长字，但它的内部组织是16位的，因此自然大小是16位。像C和C++这样的编程语言允许将变量声明为`int`（即*整数*的缩写），使其成为自然大小。你还可以使用一组支持的特定大小来声明变量。
- en: There are some standard terms that make it easy to refer to big numbers. Well,
    there was a standard, and now it’s been replaced with a new one. Engineers have
    a habit of finding words that mean something close to what they want, and then
    using them as if they mean what they want. For example, in the metric system *kilo*
    means thousand, *mega* means million, *giga* means billion, and *tera* means trillion.
    These terms have been borrowed but changed a little because we use base-2 in computing
    instead of base-10\. When we talk about a *kilobit* or *kilobyte* (*K* or *KB*)
    in computing, however, we don’t actually mean a thousand. We mean the closest
    thing to a thousand in base-2, which would be 1,024, or 2^(10). The same goes
    for *megabyte* (*M* or *MB*), which is 2^(20); *giga* (*G* or *GB*), which is
    2^(30); and *tera* (*T* or *TB*), which is 2^(40).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些标准术语使得引用大数字变得容易。曾经有一个标准，但现在它已经被新的标准取代。工程师们有个习惯，他们总是找到一些接近自己需要表达的词汇，并把它们用作自己想要的意思。例如，在公制系统中，*kilo*表示千，*mega*表示百万，*giga*表示十亿，*tera*表示万亿。我们借用了这些术语，但稍作改变，因为我们在计算中使用的是二进制而非十进制。当我们在计算中提到*千比特*或*千字节*（*K*或*KB*）时，实际上我们并不是指一千。我们指的是接近一千的二进制数，即1,024，或者2^(10)。*兆字节*（*M*或*MB*）同理，表示2^(20)；*千兆*（*G*或*GB*）表示2^(30)；*太字节*（*T*或*TB*）表示2^(40)。
- en: 'But sometimes we do mean the base-10 version. You need to know the context
    in order to know which interpretation to apply. Traditionally, the base-10 version
    was used to refer to the size of disk drives. An American lawyer feigned ignorance
    about this and sued *(Safier v. WDC)*, claiming that a disk drive was smaller
    than advertised. (In my opinion, this was just as dumb as the lawsuits claiming
    that 2 × 4 lumber doesn’t actually measure 2 inches by 4 inches, despite the fact
    that those have always been the dimensions of the unplaned, unfinished lumber.)
    This led to the creation of new IEC standard prefixes: *kibi (KiB)* for 2^(10),
    *mebi (MiB)* for 2^(20), *gibi (GiB)* for 2^(30), and *tebi (TiB)* for 2^(40).
    These are slowly catching on, although “kibis” sounds like dog food to me.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时我们确实指的是十进制版本。你需要了解上下文，才能知道应用哪种解释。传统上，十进制版本用来表示磁盘驱动器的大小。一位美国律师假装不知道这一点，并对*(Safier
    v. WDC)*提起诉讼，声称磁盘驱动器比广告上标明的要小。（依我看，这就像那些声称2×4木材实际上并不是2英寸×4英寸的诉讼一样愚蠢，尽管这些木材的尺寸一直都是未经刨平的未加工木材的尺寸。）这导致了新的IEC标准前缀的创建：*kibi
    (KiB)*表示2^(10)，*mebi (MiB)*表示2^(20)，*gibi (GiB)*表示2^(30)，*tebi (TiB)*表示2^(40)。这些前缀虽然慢慢被接受，但“kibis”对我来说听起来像狗粮。
- en: The term *character* is often used interchangeably with *byte* because, as we’ll
    see in the next section, characters’ codes have typically been designed to fit
    in bytes. Now, with better support for non-English languages, there’s often a
    need to talk about multibyte characters.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符*这一术语常常与*字节*互换使用，因为正如我们在下一节中看到的，字符的编码通常是为了适应字节而设计的。现在，随着对非英语语言的更好支持，我们经常需要讨论多字节字符。'
- en: '**Representing Text**'
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**表示文本**'
- en: At this point, you’ve learned that bits are all we have to work with in computers
    and that we can use bits to represent other things, such as numbers. It’s time
    to take it to the next level and use numbers to represent other things, such as
    the letters and other symbols on your keyboard.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经了解了计算机中我们所能操作的唯一元素——比特，并且知道我们可以用比特来表示其他事物，比如数字。现在是时候将其提升到一个新层次，使用数字来表示其他事物，例如键盘上的字母和符号。
- en: '***The American Standard Code for Information Interchange***'
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***美国信息交换标准代码***'
- en: There were several competing ideas for representing text, just like we saw for
    number representations. The winner, from back in 1963, is called the *American
    Standard Code for Information Interchange (ASCII)*, which assigns 7-bit numeric
    values to all of the symbols on the keyboard. For example, 65 means capital `A`,
    66 means capital `B`, and so on. The losing idea was IBM’s *Extended Binary-Coded
    Decimal Interchange Code (EBCDIC)*, which was based on the encoding used for punched
    cards. And, yes, the “BCD” part of EBCDIC stands for the same binary-coded decimal
    that we saw earlier. [Table 1-11](ch01.xhtml#ch01tab11) shows the ASCII code chart.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在数字表示中看到的那样，关于文本表示也有多个竞争的方案。最终获胜的方案来自1963年，叫做*美国信息交换标准代码（ASCII）*，它为键盘上的所有符号分配了7位的数字值。例如，65代表大写字母`A`，66代表大写字母`B`，以此类推。失败的方案是IBM的*扩展二进制编码十进制交换码（EBCDIC）*，该编码基于打孔卡片使用的编码方式。没错，EBCDIC中的“BCD”部分指的就是我们之前见过的二进制编码十进制。
    [表1-11](ch01.xhtml#ch01tab11)展示了ASCII代码表。
- en: '**Table 1-11:** ASCII Code Chart'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1-11：** ASCII代码表'
- en: '| **Dec** | **Hex** | **Char** | **Dec** | **Hex** | **Char** | **Dec** | **Hex**
    | **Char** | **Dec** | **Hex** | **Char** |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **十进制** | **十六进制** | **字符** | **十进制** | **十六进制** | **字符** | **十进制** | **十六进制**
    | **字符** | **十进制** | **十六进制** | **字符** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 00 | NUL | 32 | 20 | SP | 64 | 40 | @ | 96 | 60 | ` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 00 | NUL | 32 | 20 | SP | 64 | 40 | @ | 96 | 60 | ` |'
- en: '| 1 | 01 | SOH | 33 | 21 | ! | 65 | 41 | A | 97 | 61 | a |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 01 | SOH | 33 | 21 | ! | 65 | 41 | A | 97 | 61 | a |'
- en: '| 2 | 02 | STX | 34 | 22 | “ | 66 | 42 | B | 98 | 62 | b |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 02 | STX | 34 | 22 | “ | 66 | 42 | B | 98 | 62 | b |'
- en: '| 3 | 03 | ETX | 35 | 23 | # | 67 | 43 | C | 99 | 63 | c |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 03 | ETX | 35 | 23 | # | 67 | 43 | C | 99 | 63 | c |'
- en: '| 4 | 04 | EOT | 36 | 24 | $ | 68 | 44 | D | 100 | 64 | d |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 04 | EOT | 36 | 24 | $ | 68 | 44 | D | 100 | 64 | d |'
- en: '| 5 | 05 | ENQ | 37 | 25 | % | 69 | 45 | E | 101 | 65 | e |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 05 | ENQ | 37 | 25 | % | 69 | 45 | E | 101 | 65 | e |'
- en: '| 6 | 06 | ACK | 38 | 26 | & | 70 | 46 | F | 102 | 66 | f |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 06 | ACK | 38 | 26 | & | 70 | 46 | F | 102 | 66 | f |'
- en: '| 7 | 07 | BEL | 39 | 27 | ’ | 71 | 47 | G | 103 | 67 | g |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 07 | BEL | 39 | 27 | ’ | 71 | 47 | G | 103 | 67 | g |'
- en: '| 8 | 08 | BS | 40 | 28 | ( | 72 | 48 | H | 104 | 68 | h |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 08 | BS | 40 | 28 | ( | 72 | 48 | H | 104 | 68 | h |'
- en: '| 9 | 09 | HT | 41 | 29 | ) | 73 | 49 | I | 105 | 69 | i |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 09 | HT | 41 | 29 | ) | 73 | 49 | I | 105 | 69 | i |'
- en: '| 10 | 0A | NL | 42 | 2A | * | 74 | 4A | J | 106 | 6A | j |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 0A | NL | 42 | 2A | * | 74 | 4A | J | 106 | 6A | j |'
- en: '| 11 | 0B | VT | 43 | 2B | + | 75 | 4B | K | 107 | 6B | k |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 0B | VT | 43 | 2B | + | 75 | 4B | K | 107 | 6B | k |'
- en: '| 12 | 0C | FF | 44 | 2C | , | 76 | 4C | L | 108 | 6C | l |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 0C | FF | 44 | 2C | , | 76 | 4C | L | 108 | 6C | l |'
- en: '| 13 | 0D | CR | 45 | 2D | - | 77 | 4D | M | 109 | 6D | m |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 0D | CR | 45 | 2D | - | 77 | 4D | M | 109 | 6D | m |'
- en: '| 14 | 0E | SO | 46 | 2E | . | 78 | 4E | N | 110 | 6E | n |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 0E | SO | 46 | 2E | . | 78 | 4E | N | 110 | 6E | n |'
- en: '| 15 | 0F | SI | 47 | 2F | / | 79 | 4F | O | 111 | 6F | o |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 0F | SI | 47 | 2F | / | 79 | 4F | O | 111 | 6F | o |'
- en: '| 16 | 10 | DLE | 48 | 30 | 0 | 80 | 50 | P | 112 | 70 | p |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 10 | DLE | 48 | 30 | 0 | 80 | 50 | P | 112 | 70 | p |'
- en: '| 17 | 11 | DC1 | 49 | 31 | 1 | 81 | 51 | Q | 113 | 71 | q |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 11 | DC1 | 49 | 31 | 1 | 81 | 51 | Q | 113 | 71 | q |'
- en: '| 18 | 12 | DC2 | 50 | 32 | 2 | 82 | 52 | R | 114 | 72 | r |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 12 | DC2 | 50 | 32 | 2 | 82 | 52 | R | 114 | 72 | r |'
- en: '| 19 | 13 | DC3 | 51 | 33 | 3 | 83 | 53 | S | 115 | 73 | s |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 13 | DC3 | 51 | 33 | 3 | 83 | 53 | S | 115 | 73 | s |'
- en: '| 20 | 14 | DC4 | 52 | 34 | 4 | 84 | 54 | T | 116 | 74 | t |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 14 | DC4 | 52 | 34 | 4 | 84 | 54 | T | 116 | 74 | t |'
- en: '| 21 | 15 | NAK | 53 | 35 | 5 | 85 | 55 | U | 117 | 75 | u |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 15 | NAK | 53 | 35 | 5 | 85 | 55 | U | 117 | 75 | u |'
- en: '| 22 | 16 | SYN | 54 | 36 | 6 | 86 | 56 | V | 118 | 76 | v |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 16 | SYN | 54 | 36 | 6 | 86 | 56 | V | 118 | 76 | v |'
- en: '| 23 | 17 | ETB | 55 | 37 | 7 | 87 | 57 | W | 119 | 77 | w |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 17 | ETB | 55 | 37 | 7 | 87 | 57 | W | 119 | 77 | w |'
- en: '| 24 | 18 | CAN | 56 | 38 | 8 | 88 | 58 | X | 120 | 78 | x |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 18 | CAN | 56 | 38 | 8 | 88 | 58 | X | 120 | 78 | x |'
- en: '| 25 | 19 | EM | 57 | 39 | 9 | 89 | 59 | Y | 121 | 79 | y |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 19 | EM | 57 | 39 | 9 | 89 | 59 | Y | 121 | 79 | y |'
- en: '| 26 | 1A | SUB | 58 | 3A | : | 90 | 5A | Z | 122 | 7A | z |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 26 | 1A | SUB | 58 | 3A | : | 90 | 5A | Z | 122 | 7A | z |'
- en: '| 27 | 1B | ESC | 59 | 3B | ; | 91 | 5B | [ | 123 | 7B | { |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 27 | 1B | ESC | 59 | 3B | ; | 91 | 5B | [ | 123 | 7B | { |'
- en: '| 28 | 1C | FS | 60 | 3C | < | 92 | 5C | \ | 124 | 7C | &#124; |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 1C | FS | 60 | 3C | < | 92 | 5C | \ | 124 | 7C | &#124; |'
- en: '| 29 | 1D | GS | 61 | 3D | = | 93 | 5D | ] | 125 | 7D | } |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 29 | 1D | GS | 61 | 3D | = | 93 | 5D | ] | 125 | 7D | } |'
- en: '| 30 | 1E | RS | 62 | 3E | > | 94 | 5E | ^ | 126 | 7E | ~ |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 1E | RS | 62 | 3E | > | 94 | 5E | ^ | 126 | 7E | ~ |'
- en: '| 31 | 1F | US | 63 | 3F | ? | 95 | 5F | _ | 127 | 7F | DEL |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 31 | 1F | US | 63 | 3F | ? | 95 | 5F | _ | 127 | 7F | DEL |'
- en: Let’s find the letter *A* in this table. You can see that it has a decimal value
    of 65, which is 0x41 in hexadecimal—that’s also 0101 in octal. As it turns out,
    ASCII character codes are one place where octal is still used a lot, for historical
    reasons.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这个表格中找到字母 *A*。你可以看到它的十进制值是 65，对应的十六进制是 0x41——这在八进制中是 0101。事实证明，ASCII 字符编码仍然在一些地方大量使用八进制，出于历史原因。
- en: You’ll notice a lot of funny codes in the ASCII table. They’re called *control
    characters* because they control things as opposed to printing. [Table 1-12](ch01.xhtml#ch01tab12)
    shows what they stand for.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 ASCII 表格中有许多奇怪的代码。它们被称为 *控制字符*，因为它们控制的是某些功能，而不是用于打印。[表 1-12](ch01.xhtml#ch01tab12)
    显示了它们所代表的含义。
- en: '**Table 1-12:** ASCII Control Characters'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-12：** ASCII 控制字符'
- en: '| NUL | null | SOH | start of heading |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| NUL | null | SOH | heading 开始 |'
- en: '| STX | start of text | ETX | end of text |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| STX | 文本开始 | ETX | 文本结束 |'
- en: '| EOT | end of transmission | ENQ | enquiry |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| EOT | 结束传输 | ENQ | 请求 |'
- en: '| ACK | acknowledge | BEL | bell |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| ACK | 确认 | BEL | 响铃 |'
- en: '| BS | backspace | HT | horizontal tab |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| BS | 退格 | HT | 水平制表符 |'
- en: '| NL | new line | VT | vertical tab |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| NL | 换行 | VT | 垂直制表符 |'
- en: '| FF | form feed | CR | carriage return |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| FF | 换页 | CR | 回车 |'
- en: '| SO | shift out | SI | shift in |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| SO | shift out | SI | shift in |'
- en: '| DLE | data link escape | DC1 | device control #1 |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| DLE | 数据链路转义 | DC1 | 设备控制 #1 |'
- en: '| DC2 | device control #2 | DC3 | device control #3 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| DC2 | 设备控制 #2 | DC3 | 设备控制 #3 |'
- en: '| DC4 | device control #4 | NAK | negative acknowledgment |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| DC4 | 设备控制 #4 | NAK | 否定确认 |'
- en: '| SYN | synchronous idle | ETB | end of transmission block |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| SYN | 同步空闲 | ETB | 传输块结束符 |'
- en: '| CAN | cancel | EM | end of medium |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| CAN | 取消 | EM | 结束符 |'
- en: '| SUB | substitute | ESC | escape |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| SUB | 替代 | ESC | 转义 |'
- en: '| FS | file separator | GS | group separator |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| FS | 文件分隔符 | GS | 组分隔符 |'
- en: '| RS | record separator | US | unit separator |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| RS | 记录分隔符 | US | 单位分隔符 |'
- en: '| SP | space | DEL | delete |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| SP | 空格 | DEL | 删除 |'
- en: Many of these were intended for communications control. For example, `ACK` (acknowledgment)
    means “I got the message,” and `NAK` (negative acknowledgment) means “I didn’t
    get the message.”
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标准中的许多是为通信控制而设计的。例如，`ACK`（确认）意味着“我收到了消息”，而`NAK`（否定确认）意味着“我没有收到消息”。
- en: '***The Evolution of Other Standards***'
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他标准的发展***'
- en: ASCII worked for a while because it contained the characters necessary for the
    English language. Most of the early computers were American, and the ones that
    weren’t were British. The need to support other languages grew as computers became
    more widely available. The *International Standards Organization (ISO)* adopted
    ISO-646 and ISO-8859, which are basically ASCII with some extensions for the accent
    symbols and other diacritical marks used in European languages. The *Japanese
    Industrial Standards (JIS)* committee came up with JIS X 0201 for Japanese characters.
    There are also Chinese standards, Arabic standards, and more.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII在一段时间内有效，因为它包含了英语所需的字符。大多数早期的计算机都是美国制造的，而那些不是的则是英国制造的。随着计算机的普及，需要支持其他语言的需求逐渐增长。*国际标准化组织
    (ISO)* 采用了ISO-646和ISO-8859标准，基本上是ASCII的扩展，增加了欧洲语言中使用的重音符号和其他附加符号。*日本工业标准 (JIS)*
    委员会则提出了JIS X 0201标准，用于日文字符。此外，还有中文标准、阿拉伯文标准等。
- en: One reason for all of the different standards is that they were created at a
    time when bits were a lot more expensive than they are today, so characters were
    packed into 7 or 8 bits. As the price of bits began to fall, a newer standard
    called *Unicode* was crafted that assigned 16-bit codes to characters. At the
    time, it was believed that 16 bits would be enough to hold all of the characters
    in all languages on Earth with room to spare. Unicode has since been extended
    to 21 bits (of which 1,112,064 values are valid), which we think will do the job,
    but even that might not last given our propensity to create new cat emojis.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 产生这些不同标准的一个原因是它们是在比特比现在昂贵得多的时代创建的，因此字符被压缩成7或8个比特。随着比特的价格下降，一个新的标准叫做*Unicode*被制定出来，它为字符分配了16位代码。那时，人们认为16位足以容纳地球上所有语言的字符，并且还会有足够的空间。Unicode后来被扩展到21位（其中1,112,064个值是有效的），我们认为这个标准能够满足需求，但即便如此，考虑到我们创造新猫表情的倾向，这个标准也许并不能长久。
- en: '***Unicode Transformation Format 8-bit***'
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Unicode转换格式8位***'
- en: Computers use 8 bits to store an ASCII character because they’re not designed
    to handle 7-bit quantities. Again, while bits are a whole lot cheaper than they
    used to be, they’re not so cheap that we want to use 16 of them to store a single
    letter when we can get by with using just 8\. Unicode addresses this problem by
    having different encodings for the character codes. An *encoding* is a bit pattern
    that represents another bit pattern. That’s right—we’re using abstractions like
    bits to create numbers that represent characters and then using other numbers
    to represent those numbers! You see what I meant by make-believe? There’s one
    encoding in particular called *Unicode Transformation Format–8 bit* (*UTF-8*),
    invented by American computer scientist Ken Thompson and Canadian programmer Rob
    Pike, that we use most commonly for its efficiency and backward compatibility.
    UTF-8 uses 8 bits for each ASCII character so that it doesn’t consume any additional
    space for ASCII data. It encodes non-ASCII characters in a way that doesn’t break
    programs that expect ASCII.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用8位存储ASCII字符，因为它们并未设计来处理7位数据。再次强调，尽管比以前便宜很多，位并不便宜到我们愿意用16个来存储一个字母，而当我们可以只用8个时就足够了。Unicode通过为字符编码提供不同的编码来解决这个问题。*编码*是代表另一个位模式的位模式。没错——我们正在使用像位这样的抽象来创建表示字符的数字，然后使用其他数字来表示这些数字！你明白我说的“虚构”是什么意思了吗？有一种特定的编码叫做*Unicode
    Transformation Format–8位*（*UTF-8*），由美国计算机科学家Ken Thompson和加拿大程序员Rob Pike发明，它因其效率和向后兼容性而被广泛使用。UTF-8为每个ASCII字符使用8位，因此不会为ASCII数据占用额外空间。它以一种不破坏期望ASCII的程序的方式编码非ASCII字符。
- en: UTF-8 encodes characters as a sequence of 8-bit chunks, often called *octets*.
    A clever aspect of UTF-8 is that the number of most significant ones in the first
    chunk yields the length of the sequence, and it’s easy to recognize the first
    chunk. This is useful because it allows programs to easily find character boundaries.
    The ASCII characters all fit in 7 bits, so they take one chunk apiece, which is
    pretty convenient for us English speakers because it’s more compact than for other
    languages that need non-ASCII symbols. [Figure 1-16](ch01.xhtml#ch01fig16) illustrates
    how UTF-8 encodes characters compared to Unicode.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8将字符编码为一系列8位的块，通常称为*八位字节*。UTF-8的一个巧妙之处在于，第一块中最重要的1的数量决定了序列的长度，并且很容易识别第一块。这非常有用，因为它使程序能够轻松找到字符边界。所有的ASCII字符都适合7位，所以它们每个只需要一个块，这对我们讲英语的人来说非常方便，因为比起需要非ASCII符号的其他语言，它更紧凑。[图1-16](ch01.xhtml#ch01fig16)展示了UTF-8如何与Unicode相比编码字符。
- en: '![Image](../images/01fig16-2.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig16-2.jpg)'
- en: '*Figure 1-16: Examples of UTF-8 encoding*'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-16：UTF-8编码示例*'
- en: In [Figure 1-16](ch01.xhtml#ch01fig16), we can see that the numeric code for
    the letter *A* is identical in ASCII and Unicode. To encode *A* in UTF-8, we say
    that whatever codes that fit in 7 bits get a single UTF-8 chunk with the MSB set
    to 0\. This is why there’s a leading 0 in the UTF-8 for the letter *A*. Next we
    see the Unicode for the π symbol, which does not fit in 7 bits but does fit into
    11\. To encode π in UTF-8, we use two 8-bit chunks with the first chunk starting
    with 110 and the second with 10, which leaves 5 and 6 bits left over in each chunk
    respectively to hold the remaining code. Finally, we see the Unicode for ♣, which
    fits in 16 bits and so takes three UTF-8 chunks.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图1-16](ch01.xhtml#ch01fig16)中，我们可以看到字母*A*的数字代码在ASCII和Unicode中是相同的。为了在UTF-8中编码*A*，我们可以说，任何适合7位的代码都将得到一个UTF-8块，并且MSB（最高有效位）设置为0。这就是为什么字母*A*在UTF-8中有一个前导0的原因。接下来，我们看到π符号的Unicode，它不适合7位，但适合11位。为了在UTF-8中编码π，我们使用两个8位块，第一个块以110开头，第二个块以10开头，这样每个块分别留有5位和6位来容纳剩余的代码。最后，我们看到♣的Unicode，它适合16位，因此需要三个UTF-8块。
- en: '**Using Characters to Represent Numbers**'
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用字符表示数字**'
- en: UTF-8 uses numbers to represent numbers that represented numbers made from bits
    that represented characters. But we’re not done yet! Now we’re going to use characters
    to represent some of those numbers. People wanted to send more than text between
    computers in the early days of computer-to-computer communication; they wanted
    to send binary data. But doing this wasn’t straightforward because, as we saw
    earlier, many of the ASCII values were reserved for control characters, and they
    weren’t handled consistently between systems. Also, some systems supported transmission
    of only 7-bit characters.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8 使用数字表示由位表示的数字，再用这些数字表示字符。但这还没完！接下来我们将使用字符来表示其中一些数字。计算机间通信的早期，人们不仅仅想发送文本，还希望传输二进制数据。但这并不简单，因为正如我们之前看到的，许多
    ASCII 值被保留用于控制字符，并且在不同的系统间处理不一致。此外，一些系统仅支持传输 7 位字符。
- en: '***Quoted-Printable Encoding***'
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Quoted-Printable 编码***'
- en: '*Quoted-Printable encoding*, also known as QP encoding, is a mechanism that
    allows 8-bit data to be communicated over a path that only supports 7-bit data.
    It was created for email attachments. This encoding allows any 8-bit byte value
    to be represented by three characters: the character = followed by a pair of hexadecimal
    numbers, one for each nibble of the byte. Of course, in doing this, the = now
    has special meaning and so must be represented using =3D, its value from [Table
    1-11](ch01.xhtml#ch01tab11).'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*Quoted-Printable 编码*，也称为 QP 编码，是一种允许 8 位数据通过仅支持 7 位数据的路径进行通信的机制。它是为电子邮件附件创建的。这种编码方式允许任何
    8 位字节值由三个字符表示：字符 = 后跟一对十六进制数字，每个字节的半字节对应一个数字。当然，采用这种方式时，= 字符具有特殊含义，因此必须用 =3D 来表示，这个值来源于
    [表 1-11](ch01.xhtml#ch01tab11)。'
- en: Quoted-Printable encoding has a few extra rules. The tab and space characters
    must be represented as =09 and =20, respectively, if they occur at the end of
    a line. Lines of encoded data can’t be more than 76 characters in length. An =
    at the end of a line is a soft line break that is removed when the data is decoded
    by the recipient.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Quoted-Printable 编码有一些额外的规则。如果制表符和空格字符出现在行尾，它们必须分别表示为 =09 和 =20。编码数据的行不能超过 76
    个字符。行尾的 = 是软换行符，在接收方解码时会被去除。
- en: '***Base64 Encoding***'
  id: totrans-396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Base64 编码***'
- en: While Quoted-Printable encoding works, it’s not very efficient because it takes
    three characters to represent a byte. *Base64* encoding is more efficient, which
    was really important when computer-to-computer communication was much slower than
    it is today. Base64 encoding packs 3 bytes of data into 4 characters. The 24 bits
    of data in the three bytes is partitioned into four 6-bit chunks, each of which
    is assigned a printing character, as shown in [Table 1-13](ch01.xhtml#ch01tab13).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Quoted-Printable 编码是可行的，但它效率不高，因为需要三个字符来表示一个字节。*Base64* 编码更加高效，这在计算机间通信速度远低于今天时尤为重要。Base64
    编码将 3 个字节的数据压缩成 4 个字符。这三个字节的 24 位数据被分成四个 6 位的块，每个块都被分配一个可打印字符，如 [表 1-13](ch01.xhtml#ch01tab13)
    所示。
- en: '**Table 1-13:** Base64 Character Encoding'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-13：** Base64 字符编码'
- en: '| **Number** | **Character** | **Number** | **Character** | **Number** | **Character**
    | **Number** | **Character** |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| **数字** | **字符** | **数字** | **字符** | **数字** | **字符** | **数字** | **字符** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| 0 | A | 16 | Q | 32 | g | 48 | w |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 0 | A | 16 | Q | 32 | g | 48 | w |'
- en: '| 1 | B | 17 | R | 33 | h | 49 | x |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 1 | B | 17 | R | 33 | h | 49 | x |'
- en: '| 2 | C | 18 | S | 34 | i | 50 | y |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 2 | C | 18 | S | 34 | i | 50 | y |'
- en: '| 3 | D | 19 | T | 35 | j | 51 | z |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 3 | D | 19 | T | 35 | j | 51 | z |'
- en: '| 4 | E | 20 | U | 36 | k | 52 | 0 |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 4 | E | 20 | U | 36 | k | 52 | 0 |'
- en: '| 5 | F | 21 | V | 37 | l | 53 | 1 |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 5 | F | 21 | V | 37 | l | 53 | 1 |'
- en: '| 6 | G | 22 | W | 38 | m | 54 | 2 |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 6 | G | 22 | W | 38 | m | 54 | 2 |'
- en: '| 7 | H | 23 | X | 39 | n | 55 | 3 |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 7 | H | 23 | X | 39 | n | 55 | 3 |'
- en: '| 8 | I | 24 | Y | 40 | o | 56 | 4 |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 8 | I | 24 | Y | 40 | o | 56 | 4 |'
- en: '| 9 | J | 25 | Z | 41 | p | 57 | 5 |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 9 | J | 25 | Z | 41 | p | 57 | 5 |'
- en: '| 10 | K | 26 | a | 42 | q | 58 | 6 |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 10 | K | 26 | a | 42 | q | 58 | 6 |'
- en: '| 11 | L | 27 | b | 43 | r | 59 | 7 |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 11 | L | 27 | b | 43 | r | 59 | 7 |'
- en: '| 12 | M | 28 | c | 44 | s | 60 | 8 |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 12 | M | 28 | c | 44 | s | 60 | 8 |'
- en: '| 13 | N | 29 | d | 45 | t | 61 | 9 |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 13 | N | 29 | d | 45 | t | 61 | 9 |'
- en: '| 14 | O | 30 | e | 46 | u | 62 | + |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 14 | O | 30 | e | 46 | u | 62 | + |'
- en: '| 15 | P | 31 | f | 47 | v | 63 | / |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 15 | P | 31 | f | 47 | v | 63 | / |'
- en: The bytes 0, 1, 2 would be encoded as `AAEC`. [Figure 1-17](ch01.xhtml#ch01fig17)
    shows how this is accomplished.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 字节 0、1、2 会被编码为 `AAEC`。[图 1-17](ch01.xhtml#ch01fig17) 展示了这一过程。
- en: '![Image](../images/01fig17.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig17.jpg)'
- en: '*Figure 1-17: Base64 encoding*'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-17：Base64 编码*'
- en: This encoding converts every set of 3 bytes to four characters. But there’s
    no guarantee that the data will be a multiple of 3 bytes in length. This is solved
    with *padding* characters; a `=` would be tacked on to the end if there were only
    2 bytes at the end and `==` if there were only 1 byte.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码将每组三个字节转换为四个字符。但无法保证数据的长度会是3字节的倍数。这个问题通过*填充*字符解决；如果最后只有2个字节，则会在末尾加上`=`，如果只有1个字节，则会加上`==`。
- en: This encoding is still commonly used for email attachments.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码仍然广泛用于电子邮件附件中。
- en: '***URL Encoding***'
  id: totrans-422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***URL编码***'
- en: You saw above that the Quoted-Printable encoding gave special power to the =
    character, and that the encoding included a mechanism for representing the = without
    its special powers. An almost identical scheme is used in web page URLs.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，Quoted-Printable编码赋予了=字符特殊的含义，并且该编码包含了表示=字符而不触发特殊含义的机制。一个几乎相同的方案在网页URL中也有使用。
- en: If you’ve ever examined a web page URL, you may have noticed character sequences
    such as *%26* and *%2F*. These exist because certain characters have special meaning
    in the context of a URL. But sometimes we need to use those characters as *literals*—in
    other words, without those special meanings.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经查看过网页URL，可能会注意到像*%26*和*%2F*这样的字符序列。这是因为某些字符在URL的上下文中有特殊含义。但有时我们需要将这些字符作为*字面量*使用——换句话说，就是不带有这些特殊含义。
- en: As we saw in the last section, characters are represented as a sequence of 8-bit
    chunks. Each chunk can be represented by two hexadecimal characters, as [Figure
    1-16](ch01.xhtml#ch01fig16) demonstrated. *URL encoding*, also known as *percent-encoding*,
    replaces a character with a % followed by its hexadecimal representation.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节看到的，字符是通过一系列8位块表示的。每个块可以通过两个十六进制字符表示，如[图1-16](ch01.xhtml#ch01fig16)所示。*URL编码*，也称为*百分号编码*，将字符替换为%后跟其十六进制表示。
- en: For example, the forward slash character (/) has special meaning in a URL. It
    has an ASCII value of 47, which is 2F in hex. If we need to use a / in a URL without
    triggering its special meaning, we replace it with %2F. (And because we’ve just
    given a special meaning to the % character, it needs to be replaced by %25 if
    we literally mean %.)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，正斜杠字符（/）在URL中有特殊含义。它的ASCII值为47，在十六进制中是2F。如果我们需要在URL中使用/而不触发其特殊含义，我们可以将其替换为%2F。（由于我们刚刚赋予了%字符特殊含义，如果我们字面意思是指%本身，就需要将其替换为%25。）
- en: '**Representing Colors**'
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**表示颜色**'
- en: Another common use of numbers is to represent colors. You already know that
    numbers can be used to represent coordinates on a graph. Computer graphics involves
    making pictures by plotting blobs of color on the equivalent of electronic graph
    paper. The blob plotted at each coordinate pair is called a *picture element*
    or, more commonly, *pixel*.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 数字的另一个常见用途是表示颜色。你已经知道数字可以用来表示图表上的坐标。计算机图形学通过在相当于电子图表纸上的坐标点上绘制颜色块来制作图像。绘制在每个坐标对上的颜色块被称为*图像元素*，更常见的叫法是*像素*。
- en: Computer monitors generate color by mixing red, green, and blue lights using
    the aptly named *RGB color model*. The colors can be represented by a *color cube*,
    in which each axis represents a *primary* color, as shown in [Figure 1-18](ch01.xhtml#ch01fig18).
    A value of 0 means that a particular light is off, and 1 means that it’s as bright
    as it can get.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机显示器通过混合红色、绿色和蓝色光来生成颜色，这种方法被称为*RGB颜色模型*。这些颜色可以通过一个*颜色立方体*来表示，其中每个轴代表一种*基础*颜色，如[图1-18](ch01.xhtml#ch01fig18)所示。值为0表示某种光线关闭，值为1表示光线亮度最大。
- en: '![Image](../images/01fig18.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig18.jpg)'
- en: '*Figure 1-18: An RGB color cube*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-18：RGB颜色立方体*'
- en: You can see that the color is black if no lights are on and white if all of
    the lights are fully up, meaning they’re at maximum brightness. A shade of red
    results if only the red light is on. Mixing red and green creates yellow. Gray
    results from setting all three lights to the same level. This way of mixing colors
    is called an *additive* color system, as adding the primaries produces different
    colors. [Figure 1-19](ch01.xhtml#ch01fig19) shows the coordinates of a few colors
    in the color cube.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，如果没有光亮，颜色是黑色；如果所有光线都完全亮起，颜色是白色，意味着它们的亮度达到了最大值。如果只有红色光亮起，则呈现红色。红色和绿色混合会产生黄色。将所有三种光调到相同的水平则会得到灰色。这种混色方式称为*加色*系统，因为加入基础颜色会产生不同的颜色。[图1-19](ch01.xhtml#ch01fig19)展示了颜色立方体中几种颜色的坐标。
- en: '![Image](../images/01fig19.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig19.jpg)'
- en: '*Figure 1-19: RGB color cube examples*'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-19：RGB颜色立方体示例*'
- en: If you’ve tried your hand at painting, you’re probably more familiar with a
    *subtractive* color system, in which the primaries are cyan, magenta, and yellow.
    A subtractive color system produces colors by removing wavelengths from white
    light rather than by adding colored light as in the additive system. While neither
    color system can produce all of the colors that your eye can see, the subtractive
    system can produce more than the additive system. A whole set of *prepress* technologies
    exists to make it possible for artists to work on computer monitors and still
    have their designs look correct when printed in magazines. If you’re really interested
    in color, read *A Field Guide to Digital Color* by Maureen Stone.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试过绘画，你可能更熟悉一种*减色*颜色系统，其中原色是青色、品红和黄色。减色系统通过从白光中去除波长来产生颜色，而不是像加色系统那样通过添加彩色光来产生颜色。虽然没有一种颜色系统能够产生人眼能看到的所有颜色，但减色系统能够产生比加色系统更多的颜色。为了让艺术家能够在计算机显示器上工作，并且保证设计在杂志上打印出来时仍然看起来正确，已经存在一整套*印前*技术。如果你真的对颜色感兴趣，可以阅读Maureen
    Stone的*数字颜色领域指南*。
- en: The human eye is a very messy piece of machinery that evolved for survival,
    not computing. It can distinguish around 10 million colors, but it’s not linear;
    doubling the light level doesn’t necessarily translate to doubling perceived brightness.
    Even worse, the eye’s response changes slowly over time in response to overall
    light level. This is called *dark adaptation*. And the response is different for
    different colors; the eye is very sensitive to changes in green but relatively
    insensitive to changes in blue, a phenomenon that was exploited in the National
    Television System Committee (NTSC) standard. Modern computers have settled on
    rounding up 10 million to the nearest power of 2 and using 24 bits to represent
    color. These 24 bits are divided up into three 8-bit fields, one for each of the
    color primaries.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 人眼是一种非常混乱的机械装置，它是为了生存进化的，而不是为了计算。人眼能够区分大约1000万种颜色，但它并不是线性的；光强翻倍并不一定会使感知的亮度翻倍。更糟糕的是，人眼对整体光照水平的反应随时间变化缓慢，这种现象被称为*暗适应*。并且，不同颜色的反应不同；眼睛对绿色变化非常敏感，而对蓝色的变化相对不敏感，这种现象在国家电视系统委员会（NTSC）标准中得到了利用。现代计算机已经决定将1000万四舍五入到最接近的2的幂，并使用24位来表示颜色。这24位被分为三个8位字段，每个字段代表一种颜色原色。
- en: You might have noticed that there is no name for 24 bits in [Table 1-10](ch01.xhtml#ch01tab10).
    That’s because modern computers aren’t designed to operate on 24-bit units (although
    there were a few 24-bit machines, such as the Honeywell DDP-224). As a result,
    colors get packed into the nearest standard size, which is 32 bits (*long word*),
    as shown in [Figure 1-20](ch01.xhtml#ch01fig20).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，[表 1-10](ch01.xhtml#ch01tab10)中没有24位的名称。这是因为现代计算机并不是为24位单元设计的（尽管曾有一些24位机器，比如
    Honeywell DDP-224）。因此，颜色被打包成最接近的标准大小，即32位（*长字*），如[图 1-20](ch01.xhtml#ch01fig20)所示。
- en: '![Image](../images/01fig20.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/01fig20.jpg)'
- en: '*Figure 1-20: RGB color packing*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-20：RGB 颜色打包*'
- en: 'You can see that this scheme leaves 8 unused bits for every color. That’s a
    lot, considering that computer monitors today have in excess of 8 million pixels.
    We can’t just let those bits go to waste, so what can we do with them? The answer
    is that we can use them for something that’s missing from our discussion of color
    above: *transparency*, meaning how much you can “see through” the color. So far,
    we’ve only discussed opaque colors, but those can’t be used for rose-colored glasses,
    for example.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这种方案为每种颜色留出了8个未使用的位。考虑到现代计算机显示器上像素超过800万，这个数量是相当可观的。我们不能让这些位浪费掉，那么我们能做些什么呢？答案是，我们可以用它们做一些在上述颜色讨论中缺失的东西：*透明度*，即你能“透过”颜色看到多少。到目前为止，我们只讨论了不透明颜色，但例如玫瑰色眼镜就不能仅用不透明颜色表示。
- en: '***Adding Transparency***'
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加透明度***'
- en: In early animated movies, each frame was drawn by hand. Not only was this very
    labor-intensive, but there was also a lot of visual “jitter,” because it was impossible
    to exactly reproduce the background on each frame. American animators John Bray
    (1879–1978) and Earl Hurd (1880–1940) solved this problem with their invention
    of *cel animation* in 1915\. In cel animation, moving characters were drawn on
    transparent sheets of celluloid, which could then be moved over a static background
    image.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的动画电影中，每一帧都是手绘的。这不仅非常费力，而且还存在大量的视觉“抖动”，因为不可能在每一帧中精确重现背景。美国动画师John Bray（1879–1978）和Earl
    Hurd（1880–1940）通过他们在1915年发明的*底片动画*解决了这个问题。在底片动画中，移动的角色是画在透明的赛璐璐片上，然后可以将其移到静态背景图像上。
- en: Although computer animation traces its roots back to the 1940s, it really took
    off in the 1970s and 1980s. Computers weren’t fast enough back then to do everything
    that movie directors wanted (and likely never will be because, well, directors).
    And a mechanism was needed to combine objects generated by different algorithms.
    Like cel animation, transparency allows for *compositing*, or combining together
    images from different sources. You’re probably familiar with this concept if you’ve
    ever played with an image editor like GIMP or Photoshop.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管计算机动画的起源可以追溯到20世纪40年代，但它在70年代和80年代才真正起飞。当时的计算机速度不足以完成电影导演所期望的一切（可能永远也做不到，因为，嗯，导演们）。并且需要一种机制来将由不同算法生成的对象结合起来。就像传统的手绘动画一样，透明度允许*合成*，即将来自不同来源的图像结合在一起。如果你曾经使用过像GIMP或Photoshop这样的图像编辑器，你可能对这个概念非常熟悉。
- en: In 1984, Tom Duff and Thomas Porter at Lucasfilm invented a way to implement
    transparency and compositing that has since become standard. They added a transparency
    value called *alpha* (α) to each pixel. The α is a mathematical value between
    0 and 1, where 0 means that a color is completely transparent and 1 means that
    a color is completely opaque. A set of *compositing algebra* equations define
    how colors with different alphas combine to produce new colors.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 1984年，Tom Duff和Thomas Porter在Lucasfilm发明了一种实现透明度和合成的方法，这一方法至今已成为标准。他们为每个像素添加了一个透明度值，称为*alpha*（α）。α是一个介于0和1之间的数学值，其中0表示颜色完全透明，1表示颜色完全不透明。一组*合成代数*方程式定义了具有不同alpha值的颜色如何组合以产生新颜色。
- en: Duff and Porter’s implementation is clever. Since they’re not using a floating-point
    system, they represent an α value of 1 using 255, taking advantage of those extra
    8 bits in [Figure 1-20](ch01.xhtml#ch01fig20). Rather than storing red, green,
    and blue, Duff and Porter store the color values multiplied by α. For example,
    if the color were medium red, it would have a value of 200 for red and 0 for green
    and blue. The red value would be 200 if it were opaque because the α would be
    1 (with an α value represented by 255). But the α of a medium red color that was
    half transparent would be 0.5, so the stored value for red would be 200 × 0.5
    = 100 and the stored α would be 127 (255 × 0.5 = 127). [Figure 1-21](ch01.xhtml#ch01fig21)
    shows the storage arrangement for pixels with α.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Duff和Porter的实现非常巧妙。由于他们没有使用浮动点系统，他们用255表示α值为1，利用了[图1-20](ch01.xhtml#ch01fig20)中额外的8位。Duff和Porter不是存储红色、绿色和蓝色，而是存储颜色值乘以α。例如，如果颜色是中等红色，则红色为200，绿色和蓝色为0。如果它是完全不透明的，红色值为200，因为α为1（α值表示为255）。但是，半透明的中等红色的α为0.5，因此存储的红色值为200
    × 0.5 = 100，存储的α为127（255 × 0.5 = 127）。[图1-21](ch01.xhtml#ch01fig21)显示了带α值的像素存储方式。
- en: '![Image](../images/01fig21.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/01fig21.jpg)'
- en: '*Figure 1-21: RGBα color packing*'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-21：RGBα颜色打包*'
- en: Compositing images, therefore, involves multiplying the color values by α. Storing
    colors in premultiplied form means we don’t have to do these multiplications every
    time a pixel is used.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，合成图像涉及将颜色值乘以α。将颜色以预乘形式存储意味着我们不需要在每次使用像素时都进行这些乘法运算。
- en: '***Encoding Colors***'
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编码颜色***'
- en: Because web pages are primarily *text* documents, meaning they’re a sequence
    of human-readable characters often in UTF-8, we need a way of representing colors
    using text.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网页主要是*文本*文档，即一系列可读字符，通常采用UTF-8编码，我们需要一种使用文本表示颜色的方法。
- en: 'We do this in a manner similar to URL encoding, specifying colors using *hex
    triplets*. A hex triplet is a # followed by six hexadecimal values formatted as
    #rrggbb where rr is the red value, gg is the green value, and bb is the blue value.
    For example, #ffff00 would be yellow, #000000 would be black, and #ffffff would
    be white. Each of the three 8-bit color values is converted to a two-character
    hexadecimal representation.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以类似于 URL 编码的方式来做这件事，通过使用*十六进制三元组*来指定颜色。十六进制三元组是一个#符号，后跟六个十六进制值，格式为#rrggbb，其中rr是红色值，gg是绿色值，bb是蓝色值。例如，#ffff00表示黄色，#000000表示黑色，#ffffff表示白色。每一个8位的颜色值都会被转换为两个字符的十六进制表示。
- en: Although α is also available in web pages, there is no concise format for its
    representation. It uses yet another set of schemes entirely.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管α在网页中也可用，但没有简洁的格式来表示它。它使用的是另一套完全不同的方案。
- en: '**Summary**'
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned that although bits are conceptually simple, they
    can be used to represent complex things like very large numbers, characters, and
    even colors. You learned how to represent decimal numbers in binary, perform simple
    arithmetic using binary numbers, and represent negative numbers and fractions.
    You also learned different standards for encoding letters and characters using
    bits.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了尽管比特从概念上来看很简单，但它们可以用来表示复杂的事物，如非常大的数字、字符，甚至颜色。你学习了如何将十进制数字表示为二进制，如何使用二进制进行简单的算术运算，以及如何表示负数和分数。你还学习了使用比特对字母和字符进行编码的不同标准。
- en: There’s a geek joke that goes, “There are 10 types of people in the world—those
    who understand binary and those who don’t.” You should now be in the first of
    those categories.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个极客笑话说：“世界上有两种人——理解二进制的人和不理解的人。”现在你应该属于前者。
- en: In [Chapter 2](ch02.xhtml#ch02), you’ll learn some hardware basics that will
    help you understand the physical components of a computer and why computers use
    bits in the first place.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml#ch02)中，你将学习一些硬件基础知识，这将帮助你理解计算机的物理组成部分，以及为什么计算机首先使用比特。
