<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_181"/><strong><span class="big">10</span><br/>ROBUST DEVICE ARCHITECTURE</strong></h2>
<div class="image1"><img alt="Image" height="252" src="../images/common.jpg" width="252"/></div>
<p class="noindent">Robustness is <em>the</em> key feature for components in industries like automotive, aerospace, and industrial automation. Neither dirt and dust nor freezing or broiling temperatures should be able to do any harm to those devices. Products in this category are built to survive over a long lifetime. They’re designed with the requirement of <em>physical robustness</em> as a high priority.</p>
<p class="indent">However, since connectivity and communication are increasing even in those rather conservative areas, a new concern has emerged: <em>digital robustness</em>. Threats like network-based DoS attacks aim for temporary service interruption that can be critical for real-time systems depending on timely system reactions. Therefore, the protection goal of <em>availability</em> rises in importance for such embedded systems.</p>
<p class="indent">In this chapter, I highlight the relevance of robust device architectures for connected devices facing increasing network stress. I discuss the impact on real-time systems and essential functions of embedded devices. Afterward, we’ll look at strategies for coping with DoS attacks on embedded systems on the hardware, OS, and application level. This chapter’s case study then takes a look at the real-time and robustness behavior of a Linux-based embedded system under various conditions.</p>
<h3 class="h3" id="ch00lev1_80"><span epub:type="pagebreak" id="page_182"/><strong>Devices Under Network Stress</strong></h3>
<p class="noindent">Almost every device has some kind of network interface, whether it’s Wi-Fi, Ethernet, or a domain-specific networking standard like the CAN bus. Threats like cut cables and jammers blocking wireless communication channels are well known. Because they lead to the physical loss of the communication medium’s availability, messages sent over affected channels will be lost and won’t reach the initially connected device. While this issue affects overall system communication, the resources of the device itself are not impacted, and (even if perfectly designed) the device won’t be able to help in this situation.</p>
<p class="indent">The threats covered in this chapter are of a slightly different nature. They’re initiated over a network connection, but in contrast to targeting the communication channels, they have an impact on a device’s operations and resources. This can be as simple as a wrong packet on the wrong port, causing a sloppily engineered industrial device to drop everything and jump into an undocumented update mode while bringing its control function to a halt. Overloading a device with a large number of messages, however, is more often the main threat.</p>
<p class="indent">Such device weaknesses can be provoked on numerous occasions that happen more frequently with rising network complexity, the introduction of security management processes by operators, and an increased attack surface. Let’s consider some typical cases.</p>
<h4 class="h4" id="ch00lev2_110"><strong><em>Malfunctioning Neighbor Devices</em></strong></h4>
<p class="noindent">The more complex and heterogeneous a system, the higher the probability that a device goes wild someday and broadcasts tons of messages to all participants in the same network. The constant and eventually high-volume traffic is able to unintentionally reveal the unreliability of connected devices in this domain.</p>
<h4 class="h4" id="ch00lev2_111"><strong><em>Protocol Fuzzing</em></strong></h4>
<p class="noindent"><em>Fuzzing</em> is a security testing technique that repeatedly generates randomly mutated, malformed inputs and feeds them to a device with the goal of exhibiting unconsidered corner cases. Developers often apply fuzzing to test their own devices. Systems integrators, operators, and researchers also use fuzzing to analyze the robustness and security of devices, and to uncover undesired behavior.</p>
<h4 class="h4" id="ch00lev2_112"><strong><em>Network and Vulnerability Scanning</em></strong></h4>
<p class="noindent">IT environments are used to being scanned regularly for open network ports, vulnerable client machines, and misconfigured server instances. Environments like industrial production sites are much less likely to be subject to such IT security methods, but they will be in the future. Components should <span epub:type="pagebreak" id="page_183"/>be able to handle such scans and not show unexpected behavior, such as temporary deviations in processing speeds or even complete device failure.</p>
<h4 class="h4" id="ch00lev2_113"><strong><em>Flooding Attacks</em></strong></h4>
<p class="noindent">As soon as an attacker has access to a network, they’re able to send packets to connected devices. Certain tools can initiate network-based DoS attacks with a one-liner that even script kiddies can easily perform. Truly robust devices shouldn’t be affected by such attacks and should continue operating properly.</p>
<h4 class="h4" id="ch00lev2_114"><strong><em>Robust Architectures</em></strong></h4>
<p class="noindent">Many cases of low robustness against unusual network communication are due to bugs that should be discovered during functional and security testing, which is a mandatory part of the secure development process described in <a href="ch01.xhtml#ch01">Chapter 1</a>. However, some devices’ DoS vulnerabilities arise from the architectural decisions you may have made for your device.</p>
<p class="indent">If you’re part of an engineering team that’s proud of its ruggedized products, take a step forward and also make digital robustness a high-priority feature. The following sections provide advice for engineering digital robustness.</p>
<h3 class="h3" id="ch00lev1_81"><strong>Essential Device Functions</strong></h3>
<p class="noindent">It’s easy to say that a flooding attack shouldn’t impact a device’s functionality, but the practical implementation of protection measures requires more detailed considerations than you might expect. It’s clear that communication capabilities might suffer from high message load and might be reduced or even completely lost, which influences every device feature that depends on data received from other entities and possibly operations that need to transfer data from your device to other network participants. These impacts are inevitable from a device’s perspective and require corresponding mitigation measures.</p>
<p class="indent">Part 4-2 of the industrial standard IEC 62443 covers technical security requirements for industrial components, and it includes the specific requirement CR 7.1 that deals with DoS protection on embedded systems. Its central demand is that a device should maintain its <em>essential functions</em> even under a DoS attack and while operating in a <em>degraded mode</em>. If you want to fulfill this requirement, the obvious question you have to pose first is, “What actually are my device’s essential functions?”</p>
<p class="indent">Let’s consider three generic types of devices and their possible essential functions.</p>
<h4 class="h4" id="ch00lev2_115"><strong><em>Sensors</em></strong></h4>
<p class="noindent"><em>Sensors</em> measure environment parameters. No matter whether it’s tracking temperature, distance, pH value, or fill level, the sensor’s task is to capture <span epub:type="pagebreak" id="page_184"/>the current situation and communicate it to a control or monitoring system. However, if the communication channel and/or corresponding device resources can be overloaded and communication capabilities are lost, the sensor should still be able to collect its data.</p>
<p class="indent">In this case, the essential function could be the correct sensing and storage of the acquired values. From a product engineering perspective, this could lead to a new requirement—namely, a sufficiently large data buffer and recovery procedure for when communication is working again.</p>
<h4 class="h4" id="ch00lev2_116"><strong><em>Actuators</em></strong></h4>
<p class="noindent"><em>Actuators</em> like drives, valves, engines, or even lasers influence the physical world. They’re usually parameterized by a central controller instance, which communicates with the actuator—for example, over an Ethernet network.</p>
<p class="indent">Let’s assume a drive is operating at 1,000 revolutions per minute when suddenly a DoS attack on its network interface starts. Should the essential function (turning the drive at a certain speed) keep operating? From a security and an availability perspective, that could make sense. However, safety experts might argue that the system isn’t in a safe state anymore and should react with a shutdown to avoid unsafe behavior.</p>
<h4 class="h4" id="ch00lev2_117"><strong><em>Controllers</em></strong></h4>
<p class="noindent"><em>Control devices</em> for automotive, industrial automation, or critical infrastructures usually follow the simple principles illustrated in <a href="ch10.xhtml#ch10fig01">Figure 10-1</a>: receive inputs, process them by a given program, maybe do some communication, and then set the new output signals.</p>
<div class="image"><img alt="Image" height="332" id="ch10fig01" src="../images/10fig01.jpg" width="729"/></div>
<p class="figcap"><em>Figure 10-1: The typical execution cycle of a control device</em></p>
<p class="indent">Afterward, the cycle begins anew. However, in case of network stress, the communication slot could consume too much time and resources. Again, you need to define your strategy: it might be reasonable to say that cycle execution (except for communication) is the essential function that should keep running, even if the device is stressed over the network interface. If network communication itself is essential, the question would be whether it’s absolutely required for every single cycle or whether at least once within 10 cycles would be acceptable, for example.</p>
<p class="indent"><span epub:type="pagebreak" id="page_185"/>If the defined requirements can’t be fulfilled at runtime, the system should probably come to a stop. A good example of such devices might be automotive components that read pedal sensor values and control the engine accordingly. Architects and developers of these control units have to specify the devices’ essential functions in order to prepare them for the case that the sensor communication or its corresponding task fails—for whatever reason.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Defining a device’s essential functions is a fundamental design decision that can have significant influences on the device’s software and hardware architecture. Be sure to consider this topic early and seriously.</em></p>
</div>
<h3 class="h3" id="ch00lev1_82"><strong>Real-Time Systems</strong></h3>
<p class="noindent">Digital robustness is relevant for almost every product, as device failures often lead to financial losses for operators. However, it’s especially desirable for <em>real-time embedded systems</em>. These devices are not only required to maintain the availability of their services but also have to make sure that, upon an initial event, the results of the device operation are <em>available before a given deadline</em>.</p>
<p class="indent">Although high-performance processors and super-fast reaction times can be the results of such a requirement, those features aren’t mandatory. The only important constraint is that a system’s response is provided <em>before the time limit is over</em>, be it a microsecond or half a minute.</p>
<p class="indent">Real-time systems have three categories that differ in terms of the impact of missed deadlines: soft, firm, and hard real-time systems.</p>
<h4 class="h4" id="ch00lev2_118"><strong><em>Soft Real-Time Systems</em></strong></h4>
<p class="noindent"><em>Soft real-time systems</em> can tolerate missing deadlines even frequently. However, the usefulness and value of delayed results are continuously decreasing. If the deadline is missed significantly, the results might turn out to be worthless. Application examples include weather stations, live audio transmission, and video gaming.</p>
<h4 class="h4" id="ch00lev2_119"><strong><em>Firm Real-Time Systems</em></strong></h4>
<p class="noindent">A missed deadline in a <em>firm real-time system</em> leads to a defect or a degraded quality of service. However, misses that happen only infrequently might be tolerable. An example of such a system could be a pick-and-place robot. If its controller misses a deadline, the currently processed component might be broken or placed the wrong way, but after handling this single failure, the device is able to continue normal operation.</p>
<h4 class="h4" id="ch00lev2_120"><strong><em>Hard Real-Time Systems</em></strong></h4>
<p class="noindent"><em>Hard real-time systems</em> have to satisfy the highest requirements. For these systems, any missed deadline is critical. Depending on the application, it might <span epub:type="pagebreak" id="page_186"/> even lead to catastrophic consequences. Typical examples are engine control units in planes or trains, high-quality manufacturing processes, and medical devices like pacemakers.</p>
<h4 class="h4" id="ch00lev2_121"><strong><em>Impact of DoS Attacks</em></strong></h4>
<p class="noindent">If your device falls into one of these real-time groups, you have to consider the potential corresponding impacts of DoS attacks, or even accidentally occurring network stress, during your threat and risk assessment and mitigate the resulting weaknesses accordingly.</p>
<h3 class="h3" id="ch00lev1_83"><strong>Resource Exhaustion and Prevention Strategies</strong></h3>
<p class="noindent">Network-based DoS attacks, like flooding, aim for <em>temporary resource exhaustion</em> on the target device. In a simple scenario, an attacker can achieve this by utilizing most of the available network bandwidth to send packets to a target device. The victim device receives all the packets and has to process them. The required processing power depends on the type and content of the network packets.</p>
<p class="indent">However, if the accumulation of network packets reaches a level that fills all internal buffers and the device is not able to process the packets faster than they arrive at its network interface, CPU resource exhaustion occurs. The device isn’t able to perform its queuing tasks anymore, including its essential functions.</p>
<div class="note">
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>The cause of resource exhaustion doesn’t have to be a deliberate attack. A careless network scan with</em> <span class="codeitalic">nmap</span> <em>might be enough to temporarily provoke resource exhaustion on your device, as shown in this chapter’s case study.</em></p>
</div>
<p class="indentb">Overall prevention of resource exhaustion isn’t always possible in practice and depends on specific device parameters and attacker capabilities. However, a strong separation between essential functions and secondary operations is a solid architecture that can keep operating in a degraded mode, even under significant network stress. A given set of device resources can be distributed among critical and rather less critical operations by using two basic strategies:</p>
<p class="hanga"><strong>Fixed resource allocation</strong>    A static allocation of resources to tasks has the advantage of providing a transparent and clear segregation of duties. However, fixed limits lead to inefficiencies at runtime, when a resource isn’t consumed by its allocated task and another task would benefit from using that resource but isn’t allowed to.</p>
<p class="hanga"><strong>Dynamic resource allocation</strong>    To foster efficient resource use, resources can be allocated to specific tasks at runtime, based on task attributes that are used to derive a priority metric.</p>
<p class="indentt">These approaches should be considered during the design of your device’s hardware architecture and the selection of the main processing units. <span epub:type="pagebreak" id="page_187"/>Moreover, the choice and configuration of your OS can have significant impacts on your device’s robustness.</p>
<h3 class="h3" id="ch00lev1_84"><strong>Hardware-Level Implementation Options</strong></h3>
<p class="noindent">A device’s hardware architecture defines its basic computing resource conditions. During its development, ICs for various purposes are selected, including microcontrollers, multicore SoCs, and FPGAs, but also dedicated chips like Ethernet PHYs that handle network communication on the physical layer.</p>
<p class="indent">If robustness against network flooding is one of your main concerns and you take that into account at an early stage of your development process, you can design your device’s hardware architecture in a way that significantly reduces the risk of network-based DoS attacks.</p>
<h4 class="h4" id="ch00lev2_122"><strong><em>Dedicated Preprocessing Unit</em></strong></h4>
<p class="noindent"><a href="ch10.xhtml#ch10fig02">Figure 10-2</a> shows the basic concept when introducing a dedicated preprocessing unit for network traffic. The main idea behind this architecture is the physical separation of the main application’s processor and the network processing, or at least parts of it.</p>
<div class="image"><img alt="Image" height="104" id="ch10fig02" src="../images/10fig02.jpg" width="635"/></div>
<p class="figcap"><em>Figure 10-2: An architecture with network traffic preprocessing</em></p>
<p class="indent">One specific example of such an architecture is a <em>communication preprocessor</em> that implements a TCP/IP stack and takes care of processing network packets and their payload. The communication of relevant data between the main processor and the preprocessing unit is carried out over a preferably simple interface. In case of a flooding attack or just very high network load for unknown reasons, the communication unit is likely to run into resource exhaustion, but the application processor behind it will not be impacted and will be able to perform the device’s essential functions.</p>
<p class="indent">The use of a <em>hardware packet filtering unit</em> is a second example of this approach. Here, the network stack remains on the main processing unit, and the preprocessor is used only to filter the stream of network packets arriving at the device’s network interface. Rules for filtering might, for example, include rate limits to guarantee that your application processor receives only the number of packets it’s able to handle.</p>
<p class="indent">Such an architecture could be implemented by specific networking ICs that provide this functionality, but, at the time of writing, these are rather uncommon in embedded systems. For devices hosting an FPGA, the MAC controller could be implemented in digital logic followed by a custom packet-filtering core before handing network data to the main CPU.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_188"/><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>Be careful when designing the communication between a main processor and a preprocessing unit. If the former shows a heavy dependency on the latter, the device might fail despite the solid architecture.</em></p>
</div>
<h4 class="h4" id="ch00lev2_123"><strong><em>Multicore Architectures</em></strong></h4>
<p class="noindent">If digital robustness appears too late on the list of requirements and the hardware design is already fixed, you might be lucky if you’ve opted for a multicore SoC as the main processing unit in your device. Admittedly, individual cores in multicore chips are not completely separated and independent of one another; they share resources like buses, cache memories, and the like. However, a well-considered distribution of tasks among cores, as shown in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>, can reduce the probability of a DoS event.</p>
<div class="image"><img alt="Image" height="353" id="ch10fig03" src="../images/10fig03.jpg" width="802"/></div>
<p class="figcap"><em>Figure 10-3: Using multicore architectures for robustness</em></p>
<p class="indent">An increasing number of SoCs for embedded systems implement <em>asymmetric multiprocessing (AMP)</em>. They include one or more high-performance cores that are meant to run feature-rich OSs, such as Linux, and one or more smaller cores that, for example, excel at real-time applications. One approach toward increased robustness could be the allocation of essential functions like control tasks to the dedicated real-time core, as indicated by <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>a. Similar structures are possible on SoCs that combine hard processors with soft cores that reside within an FPGA fabric.</p>
<p class="indent">If your device runs on a <em>symmetric multiprocessing (SMP)</em> SoC—which means it has two, four, eight, or even more cores of the same type—you still have options to improve robustness. The architecture in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>b is meant to separate networking tasks from essential functions by binding their processes to dedicated cores. This concept is known as <em>core pinning</em>, or <em>processor affinity</em>, and has to be supported by your OS.</p>
<div class="note">
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>Again, (communication) dependencies between processes on different cores might break the intended separation and should be conceptualized with care.</em></p>
</div>
<h3 class="h3" id="ch00lev1_85"><span epub:type="pagebreak" id="page_189"/><strong>Operating System Capabilities</strong></h3>
<p class="noindent">A central duty of an OS is the management of CPU cores, memory regions, and a diverse set of hardware interfaces. The component handling the difficult task of allocating processing time during runtime is called the <em>scheduler</em>. It’s absolutely reasonable to consider capabilities and responsibilities of OSs and schedulers when talking about preventing resource exhaustion.</p>
<h4 class="h4" id="ch00lev2_124"><strong><em>Operating System Options</em></strong></h4>
<p class="noindent">When it comes to selecting an OS, device engineers have basically four options: bare-metal software without an OS, a real-time OS, a fully fledged OS, or a hypervisor-based OS combination.</p>
<h5 class="h5" id="ch00lev3_28"><strong>Bare-Metal Software Without an OS</strong></h5>
<p class="noindent">In simple devices and applications, an OS might not even be necessary. Events and corresponding resource allocation can be handled by polling loops or interrupt service routines.</p>
<h5 class="h5" id="ch00lev3_29"><strong>Real-Time OS</strong></h5>
<p class="noindent">An RTOS is a rather low-complexity OS that is specifically meant for real-time applications that have a high interest in reliability. Its scheduler manages resources based on task priorities: tasks with a higher priority can interrupt currently running ones that have a lower priority.</p>
<p class="indent">In such a system, it’s important not to configure networking-related tasks as the top priority, because doing so could lead to network-induced DoS situations. In practice, you can find a variety of RTOSs in the field, including commercial ones like QNX or VxWorks, but also open source variants such as FreeRTOS, RIOT, or Zephyr.</p>
<h5 class="h5" id="ch00lev3_30"><strong>Fully Fledged OS</strong></h5>
<p class="noindent">Many modern, feature-rich devices rely on open source libraries and tools that handle, for example, network communication, presentation of user interfaces, or data-processing tasks. Those devices are usually based on a fully fledged OS like Linux. However, such complex and not fully deterministic OSs share a disadvantage: the lack of proper real-time capabilities. In the next section, I’ll discuss a possibility that makes Linux more real-time capable.</p>
<h5 class="h5" id="ch00lev3_31"><strong>Hypervisor-Based OS Combination</strong></h5>
<p class="noindent">Some manufacturers want to combine the real-time advantages of RTOSs with the many libraries and capabilities of Linux. In these cases, a further abstraction layer is introduced below those OSs: a <em>hypervisor</em> takes over the task of hardware resource allocation and thereby plays an important role in separating essential functions (probably running on top of an RTOS) from the supporting functionalities implemented within Linux. These setups further increase the complexity of your product’s software architecture.</p>
<h4 class="h4" id="ch00lev2_125"><span epub:type="pagebreak" id="page_190"/><strong><em>Linux with a Real-Time Patch</em></strong></h4>
<p class="noindent">In its typical configuration for desktop and server systems, Linux doesn’t offer reliable real-time capabilities. However, for several years, the real-time community has maintained a kernel patch known as <code>PREEMPT_RT</code>. It includes a variety of changes to the Linux kernel that share the common goal of enabling <em>preemption</em> of kernel threads and in-kernel primitives, which means that nondeterminism in task scheduling is reduced and computing resource allocation comes closer to a purely priority-based system. In current Linux kernel versions, you can activate real-time support with the <code>CONFIG_PREEMPT_RT</code> configuration option.</p>
<p class="indentb">Thread scheduling in Linux happens based on a scheduling policy and a static scheduling priority. “Normal” threads are scheduled with policies like <code>SCHED_OTHER</code>, <code>SCHED_IDLE</code>, or <code>SCHED_BATCH</code> and a priority of 0. Threads that have to fulfill real-time requirements are scheduled with one of the following policies:</p>
<p class="hanga"><span class="codestrong">SCHED_FIFO</span>    This scheduler follows the <em>first-in first-out (FIFO) principle</em>, which means that a running thread is executed until it is preempted by a thread with a higher static priority.</p>
<p class="hanga"><span class="codestrong">SCHED_RR</span>    The classic <em>round-robin (RR)</em> scheduling approach is similar to <code>SCHED_FIFO</code> except that threads are allowed to run for only a defined maximum amount of time. Afterward, the thread is interrupted and added to the end of the queue for threads with the same priority. Threads with higher priority may preempt those with lower priority.</p>
<p class="hanga"><span class="codestrong">SCHED_DEADLINE</span>    In contrast to the other schedulers, this one is based on <em>global earliest deadline first (GEDF)</em>. It doesn’t rely on static priorities but assigns them dynamically. Its decisions are based on a thread’s absolute deadline and its total computation time.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Although</em> <span class="codeitalic">PREEMPT_RT</span> <em>makes Linux behave more like a real-time OS, it’s still a complex piece of software that’s not suitable for many hard real-time requirements.</em></p>
</div>
<h3 class="h3" id="ch00lev1_86"><strong>Application and Protocol Considerations</strong></h3>
<p class="noindent">While this chapter is primarily concerned with the robust device architecture on the hardware and OS level, I don’t want to ignore the application and communication levels. Many DoS situations in the real world arise from sloppy software and protocol design.</p>
<p class="indent">Such issues can be introduced in various phases of the development process. A protocol specification might already lack a solid definition of correct behavior in corner cases—for example, minimum or maximum values of message parameters. Further, even simple bugs in software, such as missing bounds checking, can lead to undesired side effects like endless loops or deadlocks under certain circumstances. Then, if security testing is performed only superficially, devices leave production with firmware that gives attackers the opportunity to trigger a DoS event with as little effort as a single network packet.</p>
<p class="indent"><span epub:type="pagebreak" id="page_191"/>The following sections provide practical suggestions for tackling this complex issue. The important possibility you should be looking for is an attacker’s ability to <em>force a state transition</em> within your device that results in a DoS.</p>
<h4 class="h4" id="ch00lev2_126"><strong><em>Identify Logical Flaws</em></strong></h4>
<p class="noindent">Protocol design is a complex task, but many companies take this path and develop their own, proprietary message and communication format. If you find yourself in such a situation, be sure to do your best to eliminate logical flaws in your protocol.</p>
<p class="indent">First, you can do that on the concept level by asking questions like these: What is the range of validity for each value in our messages? Is a network participant able to force our device into an undefined state? Are the validity and plausibility of message values verified before they’re used? Second, testing your protocol implementation with messages that only partially fulfill the specification or even try to manipulate your device’s state on purpose can be helpful for discovering vulnerabilities.</p>
<h4 class="h4" id="ch00lev2_127"><strong><em>Implement Input and Sender Validation</em></strong></h4>
<p class="noindent">In many embedded system scenarios, an adversary is able to communicate directly with a device—for example, over the network. Even if official client software <em>should</em> be used for interacting with your device, attackers might simply craft their own manipulated messages, so devices shouldn’t trust any packet arriving at their network interface.</p>
<p class="indent">Critical commands, such as switching into update mode and halting all operations, should be allowed only after the authenticity of the sender has been verified successfully. Therefore, a developer’s default attitude should be to <em>expect</em> malicious input and implement suitable input validation and filtering mechanisms accordingly, whether on the firewall level or within the application that processes a message’s payload.</p>
<h4 class="h4" id="ch00lev2_128"><strong><em>Analyze Active Protection Measures</em></strong></h4>
<p class="noindent">Sometimes attackers can misuse active protection measures to force a device into a DoS state. For example, your login process might be hardened to prohibit brute-force attacks by allowing only 10 login attempts. After reaching that limit, the device changes into a locked mode from which it can be reactivated only by a recovery procedure. While this might be an absolutely reasonable security measure, it also allows attackers to force a DoS situation, even for legitimate users, by entering the wrong user credentials 10 times.</p>
<p class="indent">Firewall configurations that block IPs based on their amount of traffic have similar mechanisms. In that case, attackers might spoof sender IP addresses of valid devices and trigger the protection feature by sending a large number of packets. As a result, the communication attempts of legitimate devices will be blocked afterward.</p>
<h4 class="h4" id="ch00lev2_129"><span epub:type="pagebreak" id="page_192"/><strong><em>Introduce Chaos Engineering and Fuzzing</em></strong></h4>
<p class="noindent">The human imagination is limited. It’s unrealistic to assume that developers will anticipate all potential issues that might lead to a DoS event on your device. Two testing methods push the limits in this regard, however.</p>
<p class="indent"><em>Chaos engineering</em> is a kind of reliability and resilience testing for IT systems that introduces “chaos” into an IT infrastructure in the form of random failures of services or applications. In the area of embedded system testing, this “chaos” can be crashed processes or the loss of communication channels in order to analyze the device’s behavior under adverse circumstances.</p>
<p class="indent">The discipline of <em>fuzzing</em> might be applied to communication protocols, but also on input data like the configuration files or certificates that a device processes. It can be used to create a large number of test messages or test files by cleverly mutating input data many times. In this way, you can discover cases that lead to a DoS state that would have been very hard to find by manual, human analysis.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>All that said, keep in mind that your product development team’s mindset and awareness can be decisive factors in detecting DoS vulnerabilities early in your development process.</em></p>
</div>
<h3 class="h3" id="ch00lev1_87"><strong>Case Study: Robustness Options on an STM32MP157F Device</strong></h3>
<p class="noindent">In this case study, I’ll analyze the real-time and robustness capabilities of an STM32MP157F device. I’ll shed light on corresponding measurement methods and tools used to simulate CPU and network stress on a device.</p>
<h4 class="h4" id="ch00lev2_130"><strong><em>Basic System Properties</em></strong></h4>
<p class="noindent">Regarding hardware-level options, the STM32MP157F device at hand provides two Cortex-A7 cores running at 800 MHz and a dedicated Cortex-M4 core at 209 MHz for real-time applications. This basic information allows us to conclude that both pinning tasks to one of the A7 cores and moving essential software applications to the separated M4 core would be possible. In principle, using the M4 core as a preprocessing unit for Ethernet traffic might even be an option, but that’s probably not the first solution I would pursue, and it would require further feasibility analysis based on the SoC’s architecture.</p>
<p class="indent">The MAC unit included in the STM32MP157F’s Ethernet peripheral supports data transfer rates of 10, 100, and 1,000Mbps. After looking into ST’s <em>Reference Manual RM0436</em> for STM32MP157F devices, it becomes clear that this module even comes with hardware-assisted packet filtering. Received packets can be filtered based on their source and destination MAC addresses, the virtual local area network (VLAN) tag in the Ethernet frame of a packet, the source and destination IP address, and the source and destination port of TCP and UDP messages. Unfortunately, the module doesn’t have any kind of rate-limiting feature, which would be useful for DoS protection.</p>
<p class="indent"><span epub:type="pagebreak" id="page_193"/>The third part of this initial analysis concerns the Linux OS running on my STM32MP157F device. As previously described, Linux can be patched or configured to behave similarly to a real-time system. With the command and output shown in <a href="ch10.xhtml#ch10list01">Listing 10-1</a>, I checked whether my Linux system, which was created by Yocto based on ST’s <code>st-image-core</code> image, comes with real-time scheduling capabilities.</p>
<pre class="pre"># <span class="codestrong1">uname -a</span>&#13;
Linux stm32mp1 5.15.67 #1 SMP PREEMPT ...</pre>
<p class="list-title" id="ch10list01"><em>Listing 10-1: The Linux kernel properties of my system</em></p>
<p class="indent">The string <code>SMP</code> points out that the Linux system at hand was configured at compile time to support symmetric multicore architectures like the A7 dual core of the STM32MP157F, while <code>PREEMPT</code> indicates that the Linux kernel was compiled with the <code>CONFIG_PREEMPT</code> option. The system runs a <em>low-latency kernel</em>, which means that kernel code not executed in a critical section can be interrupted by higher-priority tasks. However, this configuration shouldn’t be confused with the <code>PREEMPT_RT</code> indicator, which represents a fully preemptible Linux kernel enabled by <code>CONFIG_PREEMPT_RT</code>.</p>
<h4 class="h4" id="ch00lev2_131"><strong><em>Measurements on a Low-Latency Kernel</em></strong></h4>
<p class="noindent">You can measure a device’s latency behavior in two ways. If you have internal access to the device’s Linux system, you can run software that analyzes the scheduling behavior of that Linux system. On the other hand, for example, if you analyze a third-party component, you might be forced to regard the device under testing as a black box. In such a case, you can observe the device’s latency behavior only with respect to input and output signals—for example, with an oscilloscope or a logic analyzer. While the former approach is more suitable for showing the principle capabilities of a device, the latter can yield results that are much closer to a specific use case.</p>
<p class="indent">In this case study, I use the <code>cyclictest</code> tool to analyze the system’s real-time capabilities because I have access to the device’s Linux console and I don’t yet have a specific application in mind. This tool measures the latency between the programmed and the actual execution of a real-time task scheduled with <code>SCHED_FIFO</code>. <a href="ch10.xhtml#ch10list02">Listing 10-2</a> shows a sample test and its results.</p>
<pre class="pre"># <span class="codestrong1">cyclictest --mlockall --smp --interval=200 --distance=0 --priority=80</span>&#13;
    <span class="codestrong1">--loops=40000</span>&#13;
...&#13;
&#13;
T: 0 (  874) P:80 I:200 C:  38735 Min:   15 Act:   47 Avg:   36 Max:  158&#13;
T: 1 (  875) P:80 I:200 C:  38596 Min:   15 Act:   42 Avg:   35 Max:  165</pre>
<p class="list-title" id="ch10list02"><em>Listing 10-2: The task latency in idle mode</em></p>
<p class="indent">The <code>--mlockall</code> parameter is used to reduce overhead and influences from the tool itself, while <code>--smp</code> is necessary for testing on a multicore system. The measuring thread is executed every 200 <em>µ</em>s as set by the <code>--interval</code> <span epub:type="pagebreak" id="page_194"/>option, and there’s no difference between the measuring periods of the various threads, as denoted by <code>--distance=0</code>. The measuring tasks are executed 40,000 times (<code>--loops=40000</code>) with a task priority of 80 (<code>--priority=80</code>).</p>
<p class="indent">The result output shows two lines, one for each CPU core. The letters <code>P</code>, <code>I</code>, and <code>C</code> stand for the priority setting, measuring interval, and count of performed measurements, respectively. The values on the right show the minimal, actual, average, and maximum observed latency. The rightmost number is the most important one because it indicates worst-case latencies for scheduled tasks that may or may not be tolerable for you.</p>
<p class="indent">In the current state, the given Linux system with a <code>PREEMPT</code> low-latency kernel shows maximum latencies of 158 and 165 <em>µ</em>s. However, if I use a second device on the same network to apply a SYN flooding attack—for example, by running <code>hping3 --syn --flood</code> <span class="codeitalic">device-ip</span>, the maximum latency is affected significantly, as shown in <a href="ch10.xhtml#ch10list03">Listing 10-3</a>.</p>
<pre class="pre"># <span class="codestrong1">cyclictest --mlockall --smp --interval=200 --distance=0 --priority=80</span>&#13;
    <span class="codestrong1">--loops=40000</span>&#13;
...      &#13;
&#13;
T: 0 (  902) P:80 I:200 C:  14253 Min:   15 Act: 2406 Avg:  409 Max: 5475&#13;
T: 1 (  903) P:80 I:200 C:  40000 Min:   15 Act:   15 Avg:   23 Max:  185</pre>
<p class="list-title" id="ch10list03"><em>Listing 10-3: The effect of SYN flooding on task latency</em></p>
<p class="indent">In such a situation, even with a low-latency kernel, task latency might rise to over 5 ms, a multiple of the actual task interval. Clearly, this could be critical if your application has to fulfill real-time requirements. <a href="ch10.xhtml#ch10list04">Listing 10-4</a> shows a sample measurement result while a simple port scan was performed with <code>nmap</code> <span class="codeitalic">device-ip</span>.</p>
<pre class="pre"># <span class="codestrong1">cyclictest --mlockall --smp --interval=200 --distance=0 --priority=80</span>&#13;
    <span class="codestrong1">--loops=40000</span>&#13;
...            &#13;
&#13;
T: 0 (  932) P:80 I:200 C:  37581 Min:   14 Act:   41 Avg:   46 Max: 6573&#13;
T: 1 (  933) P:80 I:200 C:  39086 Min:   15 Act:   46 Avg:   34 Max:  199</pre>
<p class="list-title" id="ch10list04"><em>Listing 10-4: The effect of a SYN scan with</em> <span class="codeitalic1">nmap</span> <em>on task latency</em></p>
<p class="indent">In conclusion, we can see that the low-latency kernel of the standard Linux distribution for the STM32MP157F device isn’t able to provide strong real-time features. Even short periods of intense network traffic can affect the system’s reaction times.</p>
<h4 class="h4" id="ch00lev2_132"><strong><em>Measurements on a Real-Time Kernel</em></strong></h4>
<p class="noindent">If robustness is one of your top requirements, you might want to look for a Linux distribution that implements a fully preemptible kernel to fulfill real-time constraints. Luckily, ST provides the Yocto layer <code>meta-st-x-linux-rt</code> for the STM32MP157F device. After adding it to my build system, I only <span epub:type="pagebreak" id="page_195"/>have to set <code>MACHINE=stm32mp15-rt</code> and re-create the build environment before I can use <code>bitbake</code> to generate the <code>st-image-core</code> image and a Linux kernel with <code>CONFIG_PREEMPT_RT</code> enabled.</p>
<p class="indent">After booting the new image, I double-checked that the kernel actually provides real-time capabilities. The output in <a href="ch10.xhtml#ch10list05">Listing 10-5</a> shows the typical <code>PREEMPT_RT</code> feature as desired.</p>
<pre class="pre"># <span class="codestrong1">uname -a</span>&#13;
Linux stm32mp15-rt 5.15.67-rt49 #1 SMP PREEMPT_RT ...</pre>
<p class="list-title" id="ch10list05"><em>Listing 10-5: The Linux kernel features including real-time capabilities</em></p>
<p class="indent">Again, you can test the system’s real-time behavior with <code>cyclictest</code> as in the previous section. <a href="ch10.xhtml#ch10list06">Listing 10-6</a> shows the positive effects of the real-time kernel.</p>
<pre class="pre"># <span class="codestrong1">cyclictest --mlockall --smp --interval=200 --distance=0 --priority=80</span>&#13;
    <span class="codestrong1">--loops=40000</span>&#13;
...&#13;
&#13;
T: 0 ( 1195) P:80 I:200 C:  40000 Min:   15 Act:   17 Avg:   19 Max:   64&#13;
T: 1 ( 1196) P:80 I:200 C:  39838 Min:   16 Act:   25 Avg:   18 Max:   72</pre>
<p class="list-title" id="ch10list06"><em>Listing 10-6: The task latency of the real-time kernel in idle mode</em></p>
<p class="indent">In comparison to the low-latency kernel’s values in <a href="ch10.xhtml#ch10list02">Listing 10-2</a>, 158 and 165 <em>µ</em>s, the maximum latency was significantly reduced to 64 and 72 <em>µ</em>s, respectively. The results shown in <a href="ch10.xhtml#ch10list07">Listing 10-7</a> indicate even better behavior.</p>
<pre class="pre"># <span class="codestrong1">cyclictest --mlockall --smp --interval=200 --distance=0 --priority=80</span>&#13;
    <span class="codestrong1">--loops=40000</span>&#13;
...     &#13;
&#13;
T: 0 ( 1186) P:80 I:200 C:  40000 Min:   15 Act:   29 Avg:   24 Max:   91&#13;
T: 1 ( 1187) P:80 I:200 C:  39800 Min:   16 Act:   34 Avg:   19 Max:   77</pre>
<p class="list-title" id="ch10list07"><em>Listing 10-7: The effect of SYN flooding on the real-time kernel’s latency</em></p>
<p class="indent">The maximum latency of the Linux system doesn’t exceed 100 <em>µ</em>s, even in the face of a SYN flooding attack performed with <code>hping3</code>.</p>
<p class="indent">You can observe a similar effect in <a href="ch10.xhtml#ch10list08">Listing 10-8</a>, which was captured while running network scans on the device under test.</p>
<pre class="pre"># <span class="codestrong1">cyclictest --mlockall --smp --interval=200 --distance=0 --priority=80</span>&#13;
    <span class="codestrong1">--loops=40000</span>&#13;
...       &#13;
&#13;
T: 0 ( 1189) P:80 I:200 C:  40000 Min:   15 Act:   17 Avg:   20 Max:   78&#13;
T: 1 ( 1190) P:80 I:200 C:  39837 Min:   16 Act:   23 Avg:   19 Max:   73</pre>
<p class="list-title" id="ch10list08"><em>Listing 10-8: The effect of a SYN scan with</em> <span class="codeitalic1">nmap</span> <em>on the real-time kernel’s latency</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_196"/>While common <code>nmap</code> commands provoked worst-case latencies of more than 6 ms for the standard image with its low-latency kernel, the real-time kernel analyzed in this section can be incited to raise maximum latencies by only less than 15 <em>µ</em>s compared to the idle state.</p>
<p class="indent">What all this amounts to is that a low-latency Linux kernel doesn’t guarantee any robustness, and even a fully preemptible Linux kernel comes only close to real-time behavior. If this is a viable option for you, make sure to understand that you trade performance for determinism when switching to the real-time Linux kernel. Further, features like the SoC’s dynamic power management and frequency scaling might be deactivated to reach real-time behavior.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>All the presented measurements of maximum latency have to be regarded as only rough estimations. Your device could run into an even worse condition that leads to even higher maximum reaction times.</em></p>
</div>
<h4 class="h4" id="ch00lev2_133"><strong><em>Real-Time Coprocessor</em></strong></h4>
<p class="noindent">If you’re aiming to fulfill hard real-time requirements, Linux is likely not your best choice. However, the STM32MP157F provides an additional Cortex-M4 core for exactly that purpose. The development and build process of dedicated M4 firmware is beyond the scope of this case study, but you can use ST’s STM32CubeIDE or your favorite customized makefile for that purpose.</p>
<p class="indent">Let’s assume you’ve created a firmware file <em>m4_fw.elf</em> that contains your real-time application. Typically, you would place that file in the <em>/lib/firmware/</em> directory, as it’s firmware for a coprocessor. <a href="ch10.xhtml#ch10list09">Listing 10-9</a> shows the basic initialization of Linux’s <code>remoteproc</code> framework to prepare M4 firmware execution.</p>
<pre class="pre"># <span class="codestrong1">echo -n "/lib/firmware/" &gt; /sys/module/firmware_class/parameters/path</span>&#13;
# <span class="codestrong1">echo -n "m4_fw.elf" &gt; /sys/class/remoteproc/remoteproc0/firmware</span></pre>
<p class="list-title" id="ch10list09"><em>Listing 10-9: Initializing M4 firmware using the</em> <span class="codeitalic1">remoteproc</span> <em>framework</em></p>
<p class="indent">In the first step, the firmware path <em>/lib/firmware/</em> is written to the corresponding <code>sysfs</code> node. Afterward, the name of the specific firmware file, <em>m4_fw.elf</em> in this case, is passed to the remote processor instance <code>remoteproc0</code>, representing the M4 real-time core.</p>
<p class="indent">At this point, nothing runs. The output in <a href="ch10.xhtml#ch10list010">Listing 10-10</a> confirms that the M4 is still offline. To start the provided firmware, the <code>start</code> keyword has to be written to <code>remoteproc0/state</code>.</p>
<pre class="pre"># <span class="codestrong1">cat /sys/class/remoteproc/remoteproc0/state</span>&#13;
offline&#13;
# <span class="codestrong1">echo start &gt; /sys/class/remoteproc/remoteproc0/state</span>&#13;
... remoteproc remoteproc0: powering up m4&#13;
... remoteproc remoteproc0: Booting fw image m4_fw.elf, size 456520&#13;
...  remoteproc0#vdev0buffer: assigned reserved memory node ...&#13;
... virtio_rpmsg_bus virtio0: rpmsg host is online&#13;
...  remoteproc0#vdev0buffer: registered virtio0 (type 7)&#13;
<span epub:type="pagebreak" id="page_197"/>... remoteproc remoteproc0: remote processor m4 is now up&#13;
# <span class="codestrong1">cat /sys/class/remoteproc/remoteproc0/state</span>&#13;
running</pre>
<p class="list-title" id="ch10list010"><em>Listing 10-10: Starting M4 firmware using the</em> <span class="codeitalic1">remoteproc</span> <em>framework</em></p>
<p class="indent">Subsequently, the core is powered up, and execution of the real-time application begins. Now, even if the Linux system suffers from high network load and is running out of resources, the real-time firmware will continue operating at its CPU’s clock frequency of 209 MHz unperturbed. Also, the state of <code>remoteproc0</code> has changed to <code>running</code>, accordingly.</p>
<p class="indent">As shown in <a href="ch10.xhtml#ch10list011">Listing 10-11</a>, the Linux system is able to stop the firmware execution by writing <code>stop</code> to <code>remoteproc0/state</code>.</p>
<pre class="pre"># <span class="codestrong1">echo stop &gt; /sys/class/remoteproc/remoteproc0/state</span>&#13;
... remoteproc remoteproc0: warning: remote FW shutdown without ack&#13;
... remoteproc remoteproc0: stopped remote processor m4</pre>
<p class="list-title" id="ch10list011"><em>Listing 10-11: Stopping M4 firmware using the</em> <span class="codeitalic1">remoteproc</span> <em>framework</em></p>
<p class="indent">If necessary for your application, Linux’s remote processor messaging (RPMsg) framework enables the exchange of information between the main CPUs and the coprocessor. However, make sure to avoid strong dependencies of the real-time application on the Linux system as this might cause your whole device to stumble, again.</p>
<h3 class="h3" id="ch00lev1_88"><strong>Summary</strong></h3>
<p class="noindent">Many industries regard robustness as a fundamental feature for all their devices. However, when it comes to highly interconnected and automated systems, both customers and manufacturers typically have difficulty specifying their understanding of digital robustness.</p>
<p class="indent">This chapter bridged the gap between the real-time world of embedded systems and the security protection goal of availability. The most important takeaways for device engineers and architects should be that they must consider potential digital stress on the network and other interfaces, essential functions of their devices that should work properly even under attack, and architecture decisions that support true real-time behavior.</p>
<p class="indent">Options for achieving a robust device architecture range from the integration of dedicated hardware resources to the separation of duties within multicore SoCs to the careful selection and configuration of a device’s OS. But, again, as shown in this chapter’s case study, nothing replaces the practical evaluation of your device’s behavior during idle and potential situations of stress.<span epub:type="pagebreak" id="page_198"/></p>
</div></body></html>