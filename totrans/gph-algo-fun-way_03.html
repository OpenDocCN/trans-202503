<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label="19"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch2">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">NEIGHBORS AND NEIGHBORHOODS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Almost every algorithm in this book requires interacting with a node’s <i>neighbors</i>. The idea of a neighbor is intuitively quite familiar; in an undirected graph, the neighbors of a given node are those nodes with which it shares an edge. The terminology for neighbors is a little more complex in directed graphs, where there are different types of neighbors depending on whether the edge is incoming or outgoing.</p>&#13;
<p class="TX">Identifying the set of neighbors for a given node is a foundational step in most graph algorithms, such as searching for paths through a new graph, and many real-world tasks. When planning a trip through a transportation network, for example, we might ask which cities we can reach directly from the current one.</p>&#13;
<p class="TX">This chapter introduces the formal definition of neighbors and presents some basic functions we’ll use throughout the book. It also introduces <span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label="20"/>two example neighbor-based metrics: a node’s degree and its clustering coefficient. These metrics provide insights about a node’s neighborhood that help us analyze the characteristics of graphs. A node’s degree tells us its number of connections and its clustering coefficient tells us about the interconnectedness of its neighbors.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-16"/><samp class="SANS_Futura_Std_Bold_B_11">Neighbors in Undirected Graphs</samp></h3>&#13;
<p class="TNI1">Many metrics and algorithms require determining the set of nodes in immediate proximity to a given node <i>v</i>. In an undirected graph, the <i>neighbors</i> of node <i>v</i> are all nodes connected to <i>v</i> by an edge. <a href="#fig2-1">Figure 2-1</a> shows an example graph and lists the neighbors for each node. Node 0 has three neighbors (1, 3, and 4), while node 3 has only one neighbor (0).</p>&#13;
<figure class="IMG"><img id="fig2-1" class="img40" src="../images/f02001.jpg" alt="Six nodes are labeled 0 through 5. Each node is a circle and edges are lines joining a pair of circles. Each node also lists its set of neighbors. For example, node 0 is labeled with the set {1, 3, 4}." width="656" height="385"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: An undirected graph with neighbors listed for each node</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can add a short helper function to our <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> class to compute the set of neighbors in an undirected graph, as shown in <a href="#list2-1">Listing 2-1</a>.</p>&#13;
<span id="list2-1"/>&#13;
<pre><code>def get_neighbors(self) -&gt; set:  &#13;
    neighbors: set = set()&#13;
    for edge in self.edges.values():&#13;
        neighbors.add(edge.to_node)&#13;
    return neighbors&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: Determining the set of neighboring nodes in an undirected graph</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> function in <a href="#list2-1">Listing 2-1</a> creates an empty <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> data structure, then iterates through each of the node’s edges and adds the corresponding neighbor to the set.</p>&#13;
<p class="TX">Consider a graph representing a social network, where each person is a node and an undirected edge between node <i>v</i> and node <i>u</i> indicates those two people are friends. We might use a node’s neighbors to compose a guest list for a party, or to model how a rumor spreads within the network.</p>&#13;
<p class="TX">As another application of determining a node’s neighbors, consider the age-old question, “Who was in a movie with that particular star?” This is a question we will consider in more detail later in the chapter. We can build a co-occurrence graph that represents which actors appear together in a movie. Each node represents a single person. An edge indicates that two people have <span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label="21"/>appeared in the same movie together. Since this relationship is always symmetric, we use an undirected graph to model these co-occurrences.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-17"/><samp class="SANS_Futura_Std_Bold_B_11">Neighbors in Directed Graphs</samp></h3>&#13;
<p class="TNI1">In directed graphs, we could consider several types of nodes to be neighbors: the nodes at the end of outgoing edges from <i>v</i>, the nodes at the beginning of incoming edges to <i>v</i>, or the nodes on either side of a directed edge. To resolve this ambiguity, we divide neighbors for such graphs into two main types. <i>In-neighbors</i> are all nodes that have edges with <i>v</i> as the destination; in other words, the edge is incoming from node <i>v</i>’s perspective. In a directed social network where friendships are not symmetrical, for example, <i>v</i>’s in-neighbors are the friends who would tell them the latest gossip. <i>Out-neighbors</i> are all nodes to which <i>v</i> has an outgoing edge, representing the friends to which <i>v</i> would pass gossip.</p>&#13;
<p class="TX">The code we add to <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> class for computing out-neighbors in a directed graph is identical to the code presented in <a href="#list2-1">Listing 2-1</a> for undirected graphs, except for the name of the function, as shown in <a href="#list2-2">Listing 2-2</a>.</p>&#13;
<span id="list2-2"/>&#13;
<pre><code>def get_out_neighbors(self) -&gt; set:  &#13;
    neighbors: set = set()&#13;
    for edge in self.edges.values():&#13;
        neighbors.add(edge.to_node)&#13;
    return neighbors&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Determining the set of out-neighbors in a directed graph</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_out_neighbors()</samp> function iterates through all the edges and collects the destination nodes in a set that it then returns. The social equivalent would be compiling a list of people to whom one person sends messages.</p>&#13;
<p class="TX">In contrast, the code for computing the set of in-neighbors requires us to search through every node in the graph, because we do not maintain lists of edges pointing <i>into</i> a given node, as shown in <a href="#list2-3">Listing 2-3</a>. This code is called from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class so that it has access to the full list of nodes.</p>&#13;
<span id="list2-3"/>&#13;
<pre><code>def get_in_neighbors(self, target: int) -&gt; set:  &#13;
    neighbors: set = set()&#13;
    for node in self.nodes:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if target in node.edges:&#13;
            neighbors.add(node.index)&#13;
    return neighbors&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Determining the set of in-neighbors</samp></p>&#13;
<p class="TX">Like other neighbor algorithms, the code constructs the neighbors from an initially empty set. The function iterates over each node and checks whether the target node has an entry in that node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> dictionary <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If the target node has an entry in the node’s edges dictionary, the neighbor is added to the set.</p>&#13;
<p class="TX">What happens if we run <a href="#list2-3">Listing 2-3</a> on an undirected graph? Not only does the function not fail, but it also produces the correct set of neighbors. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_22" aria-label="22"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_in_neighbors()</samp> function considers the same neighboring nodes as the code in <a href="#list2-1">Listing 2-1</a>, but from the opposite side of the edge. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">get_in_neighbors()</samp> is significantly less efficient than <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> on an undirected graph because it iterates over all nodes in the graph and not just the ones connected to the target node.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h-18"/><samp class="SANS_Futura_Std_Bold_B_11">Self-Loops</samp></h3>&#13;
<p class="TNI1">One additional complexity when defining neighbors is the potential for <i>self-loops</i>, in which an edge links a node to itself. For example, in <a href="#fig2-2">Figure 2-2</a>, node 1 has an edge to itself.</p>&#13;
<figure class="IMG"><img id="fig2-2" class="img30" src="../images/f02002.jpg" alt="A graph with four nodes. Node 1 has an arrow from the node back to itself." width="378" height="294"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: A graph with a self-loop</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Self-loops work like circular roads that return to their starting points. More topically, we can visualize them in the context of my conversations about this very book. If we use a weighted graph to represent the number of conversations I had with various people, the largest weighted edge would be a self-loop indicating the number of times I mumbled to myself while trying to work something out.</p>&#13;
<p class="TX">In the adjacency list representation, a self-loop is represented by the inclusion of an edge whose destination matches its origin. In the adjacency matrix representation, a self-loop for node <i>v</i> is represented by a nonzero value along the diagonal of the matrix (row = <i>v</i>, column = <i>v</i>).</p>&#13;
<p class="TX">If node <i>v</i> has a self-loop, we consider it a neighbor of itself. In the case of a directed graph, this means node <i>v</i> is both its own in-neighbor and its own out-neighbor, since the edge starts and ends at node <i>v</i>.</p>&#13;
<p class="TX">Throughout this book, we use the common computer science convention of allowing self-loops only in directed graphs. While many algorithms can handle undirected graphs with self-loops, and most of the rest can easily be adapted to do so, these loops often do not make sense in the context of the problems that the undirected graphs are modeling. For example, the graph-coloring problem examined in <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span> requires us to assign different colors to any two nodes connected by an edge. Self-loops make no sense in such a problem formulation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h-19"/><samp class="SANS_Futura_Std_Bold_B_11">Degree</samp></h3>&#13;
<p class="TNI1">One useful statistic for understanding a node’s connectivity is its <i>degree</i>, the number of times edges connect to a node. <a href="#fig2-3">Figure 2-3</a> shows an example <span role="doc-pagebreak" epub:type="pagebreak" id="pg_23" aria-label="23"/>undirected graph where each node is labeled with its degree. Node 0 has a degree of 3, while node 5 has a degree of 2.</p>&#13;
<figure class="IMG"><img id="fig2-3" class="img40" src="../images/f02003.jpg" alt="A graph with six nodes labeled with their degrees. Node zero is connected to nodes one, three, and four and labeled with degree 3." width="515" height="335"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: An undirected graph with each node’s degree shown</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In social networks, a node’s degree would indicate the number of friends that person has. We can use this as a rough proxy for how popular or well-connected that person is.</p>&#13;
<p class="TX">From a mathematical standpoint, edges forming self-loops in undirected graphs are counted twice for the degree, since they contact the node on each end. While we do not use self-loops in undirected graphs for the algorithms in this book, we will include this check for completeness when computing degree in <span class="Xref"><a href="chapter18.xhtml">Chapter 18</a></span>.</p>&#13;
<p class="TX">In directed graphs, we break the concept of degrees into two separate measures, as we do for neighbors. A node’s <i>out-degree</i> measures the number of connections out of that node, while its <i>in-degree</i> measures the number of edges from other nodes into the given node. In a social network, your in-degrees and out-degrees could represent the number of people with whom you share news and the number of people who share news with you, respectively. Good confidants are friends with a high in-degree and a low out-degree. Good sources of gossip have both a high in-degree, to collect tidbits, and a high out-degree, indicating their willingness to pass those tidbits along.</p>&#13;
<p class="TX">Edges forming self-loops in directed graphs have the same <i>origin</i> and <i>destination</i>. They count once toward the in-degree and once toward the out-degree. For example, <a href="#fig2-4">Figure 2-4</a> shows a directed graph and the degrees for each node. The left-hand side of the figure shows each node’s out-degree, while the right-hand side shows their in-degrees.</p>&#13;
<figure class="IMG"><img id="fig2-4" class="img100" src="../images/f02004.jpg" alt="Two graphs with six nodes each. In both, node 0 has outgoing arrows to nodes 1 and 3 and an incoming arrow from node 4. In the graph on the left, node 0 has a label of 2. In the graph on the right, Node 0 has a label of 1." width="1236" height="495"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-4: A directed graph labeling each node’s out-degree (a) and in-degree (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_24" aria-label="24"/>Computing a node’s in-degree or out-degree in a connected graph requires counting the number of incoming or outgoing edges. To do so, we can adapt the neighbor computation code from the previous section by keeping a counter instead of building a set.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h-20"/><samp class="SANS_Futura_Std_Bold_B_11">Clustering Coefficient</samp></h3>&#13;
<p class="TNI1">The <i>clustering coefficient</i> of a node (sometimes called the <i>local clustering coefficient</i>) is a metric that characterizes how interconnected the node’s neighbors are with each other. In the context of a social network, the clustering coefficient effectively asks, “To what extent are my friends also friends with each other?” At zero, the metric indicates that none of our friends like each other, leading to extremely awkward parties. At the other extreme, a value of one indicates that every one of our friends is connected to every other friend.</p>&#13;
<p class="TX">Formally, the clustering coefficient for a node <i>v</i> in an undirected graph is the fraction of possible edges among <i>v</i>’s neighbors that exist. We find the set of all neighbors (all nodes that share an edge with <i>v</i>), count how many of those neighbors share an edge with each other, and divide that by the total number of possible edges within that set. If node <i>v</i> has <i>k</i> neighbors, there could be up to <i>k</i> (<i>k</i> – 1) / 2 possible edges between them.</p>&#13;
<p class="TX">Nodes with one or fewer neighbors need special treatment because their neighbors have zero possible connections. If someone has no friends, it makes no sense to compute the percentage of their friends who like each other. For simplicity, we return a value of 0 in these cases, reflecting the lack of local connections.</p>&#13;
<p class="TX">We can define a function to compute the clustering coefficient of a given node with index <samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp> in an undirected graph, as shown in <a href="#list2-4">Listing 2-4</a>.</p>&#13;
<span id="list2-4"/>&#13;
<pre><code>def clustering_coefficient(g: Graph, ind: int) -&gt; float: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> neighbors: set = g.nodes[ind].get_neighbors()&#13;
    num_neighbors: int = len(neighbors)&#13;
&#13;
    count: int = 0&#13;
    for n1 in neighbors:&#13;
        for edge in g.nodes[n1].get_edge_list():&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if edge.to_node &gt; n1 and edge.to_node in neighbors:&#13;
                count += 1&#13;
&#13;
    total_possible = (num_neighbors * (num_neighbors - 1)) / 2.0&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if total_possible == 0.0:&#13;
        return 0.0&#13;
    return count / total_possible&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Code to compute the local clustering coefficient</samp></p>&#13;
<p class="TX">The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp> function starts by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> function <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> from <a href="#list2-1">Listing 2-1</a> to generate the set of all neighboring nodes. It then uses a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to check each unique pair of neighbors. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop iterates over the node’s neighbors, and the second iterates over the neighbor’s edges.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_25" aria-label="25"/>For each edge that includes the neighboring node, the code checks that the node on the other side of the edge has an index greater than the current neighbor node and is also a neighbor of the original node <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. The first check is necessary to avoid double-counting the neighbors. Undirected edges appear twice in the adjacency lists but should be counted only once. Each edge (<i>u</i>, <i>v</i>) is counted only when <i>u</i> &lt; <i>v</i>. If the edge passes this test, it is counted.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp> function finishes by returning the fraction of total possible edges among neighbors that are observed, taking care to avoid a divide-by-zero if a node has one or zero neighbors <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX"><a href="#fig2-5">Figure 2-5</a> shows an example graph that lists the clustering coefficient for each node.</p>&#13;
<figure class="IMG"><img id="fig2-5" class="img40" src="../images/f02005.jpg" alt="Each node in this six-node graph is labeled with its clustering coefficient. Node 0 is connected to nodes 1, 3, and 4. Of those neighbors, only nodes 1 and 4 share a connection. node 0 has a coefficient of 1/3." width="528" height="356"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-5: A graph with clustering coefficients</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Node 0 has three neighbors (1, 3, and 4), which can have three edges among themselves, but only a single pair of its neighbors (1 and 4) are connected, giving it a clustering coefficient of 1/3. In contrast, node 5 has two neighbors that share an edge, giving it a clustering coefficient of 1. Node 3 has only one neighbor and is therefore assigned a value of 0.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-21"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Computing the Average Clustering Coefficient</samp></h4>&#13;
<p class="TNI1">The clustering coefficient tells us only about the characteristics of the graph around a single node. We can extend the insights provided by computing the <i>average local clustering coefficient</i> for all nodes of the graph, which provides a numerical measure of the local interconnectedness of an undirected graph.</p>&#13;
<p class="TX">We can calculate this measure for an undirected graph by computing the clustering coefficient for each neighbor, then taking the average, as shown in the following code:</p>&#13;
<pre><code>def ave_clustering_coefficient(g: Graph) -&gt; float:&#13;
    total: float = 0.0&#13;
    for n in range(g.num_nodes):&#13;
        total += clustering_coefficient(g, n)&#13;
&#13;
    if g.num_nodes == 0:&#13;
        return 0.0&#13;
    return total / g.num_nodes&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_26" aria-label="26"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">ave_clustering_coefficient()</samp> function loops through each node, calls <samp class="SANS_TheSansMonoCd_W5Regular_11">clustering_coefficient()</samp> on that node, and adds the result to a running total. As long as the function has seen at least one node, it returns the total divided by the number of nodes. For example, the graph in <a href="#fig2-5">Figure 2-5</a> has a local clustering coefficient of approximately 0.5278.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-22"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Limitations</samp></h4>&#13;
<p class="TNI1">The clustering coefficient only provides information about the neighboring nodes’ connectivity relative to a single given node, without telling us anything about those nodes’ connectivity in general. For example, consider the graph in <a href="#fig2-6">Figure 2-6</a>. Node 0 has a clustering coefficient of 1, indicating that all its neighbors are mutually connected. However, this doesn’t tell us anything about the network one step farther away, much less <i>all</i> its neighbors’ connections.</p>&#13;
<figure class="IMG"><img id="fig2-6" class="img40" src="../images/f02006.jpg" alt="A six-node graph. Node 0 is connected directly to nodes 1 and 2. Nodes 3, 4, and 5 all connect to node 1 and to each other; they are shaded to indicate they are not part of node 0’s clustering coefficient calculation.]" width="586" height="419"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-6: The interconnections of node 0 and its immediate neighbors versus those neighbors’ connections</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="#fig2-6">Figure 2-6</a>, node 1 has many additional connections that are not considered by the clustering coefficient because they are not directly connected to node 0’s neighbors. These connections are shown in gray, while immediate neighbors are shown in black. In this case, node 1 is part of two different sets of interconnected nodes, {0, 1, 2} and {1, 3, 4, 5}.</p>&#13;
<p class="TX">In our social network example, this means that the clustering coefficient cannot tell us about our friends’ friends. Our friends may get along with each other but also be part of other groups. Practically speaking, the local clustering coefficient can tell us if the people we invited to our party will get along, but it cannot tell us whether there is a bigger party they’ll go to instead. For example, if both nodes 0 and 4 from <a href="#fig2-6">Figure 2-6</a> throw a party, node 1 would enjoy either event but would have more friends at node 4’s party.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h-23"/><samp class="SANS_Futura_Std_Bold_B_11">Generating Neighborhood Subgraphs</samp></h3>&#13;
<p class="TNI1">We can extend the idea of neighbors to determine a <i>neighborhood subgraph</i> in an undirected graph, which includes both the neighboring nodes and the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_27" aria-label="27"/>edges between them. We define two types of neighborhoods in undirected graphs depending on whether we want to include the original node. An <i>open-neighborhood</i> subgraph of node <i>v</i> consists of the neighbors of <i>v</i> and the edges between them. A <i>closed-neighborhood</i> subgraph of node <i>v</i> consists of node <i>v</i> and all its neighbors, as well as the edges between those nodes.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-24"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">We can create a function within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class to generate the open- or closed-neighborhood subgraph around a given node (with index <samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>) in an undirected graph. This function operates by determining the neighboring nodes and using them to seed a new graph, then adding the appropriate edges:</p>&#13;
<pre><code>def make_undirected_neighborhood_subgraph(self, ind: int, closed: bool):  &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if not self.undirected:&#13;
        raise ValueError&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> nodes_to_use: set = self.nodes[ind].get_neighbors()&#13;
    if closed:&#13;
        nodes_to_use.add(ind)&#13;
&#13;
    index_map = {}&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> for new_index, old_index in enumerate(nodes_to_use):&#13;
        index_map[old_index] = new_index&#13;
&#13;
    g_new: Graph = Graph(len(nodes_to_use), undirected=True)&#13;
    for n in nodes_to_use:&#13;
        for edge in self.nodes[n].get_edge_list():&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if edge.to_node in nodes_to_use and edge.to_node &gt; n:&#13;
                ind1_new = index_map[n]&#13;
                ind2_new = index_map[edge.to_node]&#13;
                g_new.insert_edge(ind1_new, ind2_new, edge.weight)&#13;
&#13;
    return g_new&#13;
</code></pre>&#13;
<p class="TX">The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_undirected_neighborhood_subgraph()</samp> function starts by checking if the graph is undirected and, if not, raising a <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueError</samp> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. While this is not strictly necessary and the code will produce some results for directed graphs, it helps ensure the function is used as designed. Next, the code extracts the target node’s set of neighbors with the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_neighbors()</samp> function from <a href="#list2-1">Listing 2-1</a> <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. This set, <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>, comprises all the nodes that will be used in the subgraph. If the subgraph is a closed-neighborhood subgraph, the code adds the target node itself to that set.</p>&#13;
<p class="TX">The code for generating neighborhood subgraphs is complicated slightly by the way the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class indexes the nodes. Since our graph uses numeric indices in the range [0, |<i>V</i> | – 1], where |<i>V</i> | is the number of nodes, any subgraph might use different indices for a given node. To account for this, the code builds a dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">index_map</samp> that maps the old node index to the new node index <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. This allows the generated subgraph to use numeric <span role="doc-pagebreak" epub:type="pagebreak" id="pg_28" aria-label="28"/>indices without gaps. As we will see later in <a href="#fig2-8">Figure 2-8</a>, we can use alternate information, like the label, to preserve the identities of the nodes.</p>&#13;
<p class="TX">Finally, the code creates the new graph, using a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to do so. This code mirrors the local clustering coefficient code from <a href="#list2-4">Listing 2-4</a>. The first <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop iterates over the nodes in <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp>, while the second iterates over that node’s edges. By testing that the neighboring node’s index (<samp class="SANS_TheSansMonoCd_W5Regular_11">edge.to_node</samp>) is greater than the index of the current node <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>, the function guarantees it will insert each undirected edge only once <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. A new edge is added only if both nodes are in <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes_to_use</samp> and the other node has not already been processed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> function handles correctly inserting the undirected edge using the new node indices.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-25"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1">Consider what happens when we build a neighborhood subgraph from the graph in <a href="#fig2-7">Figure 2-7</a>. Returning to the earlier example of the movie star network, this graph could represent the seven stars (Alice, Bob, Carl, Dan, Edward, Fiona, and Gwen) who appear in the world-famous <i>Graph Theory</i> series of action thrillers: <i>Graph Theory</i> (with stars Alice and Bob), <i>Graph Theory 2: A New Node</i> (with stars Bob and Carl), <i>Graph Theory 3: The Lost Edge</i> (with stars Bob, Fiona, and Gwen), and so forth. Each node is labeled with the first letter of the star’s name and maps their connections to their co-stars.</p>&#13;
<figure class="IMG"><img id="fig2-7" class="img50" src="../images/f02007.jpg" alt="A graph with seven nodes. Node 1 is connected to nodes 0, 2, 5, and 6." width="724" height="313"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-7: An undirected graph representing the stars of the</samp> <samp class="SANS_Futura_Std_Book_11">Graph Theory</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">series</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To understand more about the appearances of Bob and his co-stars, we create a closed-neighborhood subgraph around Bob (node 1). This represents the stars with whom Bob has shared the screen and captures the interactions among them. <a href="#fig2-8">Figure 2-8</a> shows the operation to build this graph. The left column shows the full graph, with the current node being processed indicated by a dashed circle, and the right column shows the new subgraph at that point. As noted earlier, the subgraph’s nodes use different indices; in this case, we might store the star’s name in the node’s label.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_29" aria-label="29"/>&#13;
<figure class="IMG"><img id="fig2-8" class="img70" src="../images/f02008.jpg" alt="Six rows indicating the steps of the neighborhood construction algorithm, labeled with letters a through f from top to bottom." width="1435" height="2370"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-8: The steps to construct a closed-neighborhood subgraph around Bob</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_30" aria-label="30"/><a href="#fig2-8">Figure 2-8(a)</a> begins by creating a new graph containing just Bob and his co-stars. The set of neighbors includes everyone with whom Bob has appeared on-screen. Alice is included from their appearance together in the original <i>Graph Theory</i> film, while the links to stars Fiona and Gwen come from the third, and best reviewed, installment in the series.</p>&#13;
<p class="TX">The indexing also changes in the new graph. As shown in the figure, three of the people are given the same indices (nodes 0, 1, and 2), while two are assigned new indices (5 and 6). The node index for Fiona changes from 5 to 3 in the subgraph, and from 6 to 4 for Gwen. In <span class="Xref"><a href="appendix_A.xhtml">Appendix A</a></span>, we’ll discuss how to expand the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> structure to use string-based labels, which obviate the need for this index remapping.</p>&#13;
<p class="TX">After setting up the new graph, we iterate one by one through the people under consideration (Bob and his co-stars) and add new edges to the subgraph. When considering node 0 in <a href="#fig2-8">Figure 2-8(b)</a>, we add only one of their two edges, (0, 1). This is because both Alice and Bob are being considered. In contrast, Edward (node 4) was only in the disastrous spin-off attempt <i>The Golden Vertex</i> with Alice. Since Edward never appeared on-screen with Bob, he is not part of Bob’s neighborhood subgraph.</p>&#13;
<p class="TX">When we get to Bob, who represents the franchise staple, we add edges to three new co-stars in <a href="#fig2-8">Figure 2-8(c)</a>. We do not add an edge back to Alice because we have already processed that node and its edges. The code continues through Carl in <a href="#fig2-8">Figure 2-8(d)</a>, Fiona in <a href="#fig2-8">Figure 2-8(e)</a>, and Gwen in <a href="#fig2-8">Figure 2-8(f)</a>. Since Edward and Dan didn’t co-star with Bob, they are not in the list of neighbors and are never considered. The final subgraph is shown on the right-hand side of <a href="#fig2-8">Figure 2-8(f)</a>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-26"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">A graph’s neighbors provide fundamental information about the local structure and interconnections around a given node. For the most part, the formal definitions of these terms are conveniently intuitive. When traversing a graph, we ask which nodes are neighbors of the current node and are thus reachable. Neighbors will form the basis of our discussion of graph search algorithms in later chapters, as many of these algorithms share the core loop of iterating over a node’s edges and seeing which other nodes share them.</p>&#13;
<p class="TX">Concepts like a node’s degree and its local clustering coefficient provide concrete metrics about its immediate neighbors and neighborhood. These example metrics are only a fraction of the multitude of ways to quantify the properties of a graph. Numerous metrics have been developed to analyze the properties of real-world graphs, from their level of interconnectedness to their width. A comprehensive review of all graph metrics is well outside the scope of this book, but upcoming chapters discuss some additional analytics.</p>&#13;
<p class="TX">In the next chapter, we consider another foundational graph algorithm concept: paths. Paths provide a description of movements throughout the graph and allow us to record how to traverse from one node to another.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>