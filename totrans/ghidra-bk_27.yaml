- en: '## **22'
  prefs: []
  type: TYPE_NORMAL
- en: PATCHING BINARIES**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Occasionally when reverse engineering a binary, you may decide that you want
    to modify the behavior of the original binary. Behavioral modification is usually
    accomplished by patching the binary to insert, remove, or modify existing instructions.
    Many motivations exist for making such modifications—some more controversial than
    others—including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a malware sample to eliminate anti-debug techniques that prevent the
    malware from being studied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patching vulnerabilities in software for which you have no source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing an application’s splash screen or string content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying game logic for the purposes of cheating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlocking hidden features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing licensing checks or other anti-piracy protections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we have no intention of teaching you how to do anything unethical,
    but we discuss the high-level challenges of modifying a binary to reflect any
    changes that you have made within Ghidra. [Chapter 14](ch14.xhtml#ch14) introduced
    the `setByte` API function, and [Chapter 21](ch21.xhtml#ch21) showed how different
    styles of emulation scripts were able to modify the content of a program loaded
    into Ghidra. These techniques modify the content that has been imported into Ghidra
    and have no effect whatsoever on the original binary file that Ghidra processed
    during the import process. To complete the patching process, you’ll learn how
    to get Ghidra to write changes back to a file on disk. We also discuss the challenges
    that different types of patches might pose.
  prefs: []
  type: TYPE_NORMAL
- en: '**Planning Your Patch**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The patching process typically involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine the type of patch you intend to make. This will often be determined
    by your rationale for patching, as discussed previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the exact program location(s) that needs to be patched. This typically
    involves some amount of research and analysis of the program to be patched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plan the content of your patch. Content changes may require new data, new machine
    code, or both. In any case, your changes must be well thought out to prevent the
    program from exhibiting any unintended behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Ghidra to replace existing program content (data or code) with your replacement
    content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Ghidra to verify that your changes appear to be correctly implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Ghidra to export your changes into a new binary file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the new binary file behaves as intended, repeating from step 2 as
    necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In some patching scenarios, many of these steps will be almost trivial; in others,
    they will be much more challenging. In the sections that follow, we review those
    steps that Ghidra can help you with and discuss situations that may push you or
    Ghidra to your limits. We’ll start with step 2 and review some of the ways that
    Ghidra helps you locate items of interest in a patching context.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Things to Change**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exact nature of your patch will dictate what you need to patch. Custom­izing
    splash screens or strings requires that you locate the original data that needs
    changing. Changing the logic of a program requires modifying or inserting code
    to change the program’s behavior. In this case, a significant amount of reverse
    engineering may be required just to find any program locations that need to be
    modified. Many of Ghidra’s capabilities that facilitate these activities have
    been covered in previous chapters. Let’s review some of the capabilities useful
    for patching.
  prefs: []
  type: TYPE_NORMAL
- en: '***Searching Memory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When your patch involves modifying program data, your primary means of identifying
    where to apply your patches will be some form of memory search. The most general
    memory search is the CodeBrowser’s Search ▸ Memory menu option (hotkey S), shown
    in [Figure 22-1](ch22.xhtml#fig22_1) (with Advanced options expanded). The Search
    Memory dialog was previously discussed in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-1: The Search Memory dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: The Search Memory dialog is most useful in a patching context when you are searching
    for specific, known data within the binary, such as known strings or hex sequences.
    A successful search will reposition all linked displays to the location of the
    matching bytes, or in the case of Search All, open a new dialog containing a list
    of all addresses at which the matched content may be found. For very large binaries,
    it may be useful to limit the scope of your search to specific regions (Instructions,
    Defined Data, Undefined Data, and so on) within the program that are likely to
    contain a match by deselecting any uninteresting code unit types.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*While Search ▸ Memory provides the most configurable general-purpose search
    capability in Ghidra, it is a search across the raw byte content of the database,
    and other search types may be more suited to the type of data you are looking
    for. For example, Search ▸ Memory is the wrong choice if you want to search within
    the body of comments that you have entered into the program. Refer to “[Search
    Program Text](ch06.xhtml#ch06lev115)” on [page 115](ch06.xhtml#page_115) for more
    information on searching within the disassembly listing itself.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Searching for Direct References***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 20](ch20.xhtml#ch20), we used Search ▸ For Direct References to
    scan the program’s binary content for all occurrences of a specific address. The
    most common use for this search type is to locate pointers to interesting data
    when Ghidra has failed to create a cross-reference to the data. In a patching
    context, this is most often used to fully understand and update all references
    to a data or code location to maintain proper relationships between code and data
    in the patched binary.
  prefs: []
  type: TYPE_NORMAL
- en: '***Searching for Instruction Patterns***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ghidra’s Search ▸ For Instruction Patterns feature finds a specific sequence
    of instructions by matching a pattern. When defining an instruction pattern, you
    need to strike a delicate balance between patterns that are too specific and patterns
    that are too general. Let’s look at an example to illustrate this idea. Assume
    we have a listing that includes a `cleanup_and_exit` function that exits the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The function `do_testing` conducts a series of tests ➋. If any of the tests
    fail, the `cleanup_and_exit` function ➊ is called and execution ends. If all tests
    succeed, some very interesting code ➌ will execute. Our patching challenge is
    to determine where we need to patch to ensure that all of the tests pass so that
    we can reach the interesting code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we load the binary into Ghidra, we can search for all calls to `cleanup_and_exit`
    to determine what we need to patch in order for all of the tests to pass regardless
    of the number of tests. We have several options to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: We could just go to that function and patch it to return so that a failed test
    doesn’t exit the program but rather continues. This isn’t an optimal solution
    because the function is also used for a legitimate exit at the end of the program
    after it completes the interesting work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could use search functionality or XREFs to `cleanup_and_exit`. This would
    give us all of the calls, but we wish to patch only some of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could identify an instruction pattern that the calls have in common and use
    Search ▸ For Instruction Patterns to find the correct calls to patch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this search functionality, we need to identify a useful pattern. Each
    test we are trying to pass takes the following form in the Listing window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try searching for that sequence by selecting the instruction sequence
    and Search ▸ For Instruction Patterns. This automatically populates the Instruction
    Pattern Search dialog, as shown in [Figure 22-2](ch22.xhtml#fig22_2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-2: Instruction Pattern Search dialog with all fields selected*'
  prefs: []
  type: TYPE_NORMAL
- en: If we click Search All, we see only one result (the specific location that we
    selected when we started the search), as shown in [Figure 22-3](ch22.xhtml#fig22_3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-3: Instruction pattern search results from all fields selected*'
  prefs: []
  type: TYPE_NORMAL
- en: Our issue is that we are including operands that do not remain constant between
    the test cases. For example, the operand to the first call is the address of a
    specific test function. We can deselect individual components (mnemonics and operands)
    of any instruction in the pattern to make it more general, as shown in [Figure
    22-4](ch22.xhtml#fig22_4). Anything that has been deselected is treated as a wildcard
    in subsequent searches.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-4: Instruction Pattern Search dialog with some operands deselected*'
  prefs: []
  type: TYPE_NORMAL
- en: If we click Search All with operand fields disabled, we see the three results
    shown in [Figure 22-5](ch22.xhtml#fig22_5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-5: Instruction pattern search results with some operands deselected*'
  prefs: []
  type: TYPE_NORMAL
- en: The search still fails to identify the call to `test_multiple_10`, which uses
    a `JZ` rather than a `JNZ` instruction. Deselecting the mnemonic field for the
    `JNZ` instruction and rerunning the search yields the results shown in [Figure
    22-6](ch22.xhtml#fig22_6), which includes the four calls we wish to patch and
    does not include the final call to `cleanup_and_exit` that we do not want to patch.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-6: Instruction pattern search results with* `JNZ` *and some operands
    deselected*'
  prefs: []
  type: TYPE_NORMAL
- en: This search functionality has a number of uses beyond locating candidate instruction
    patterns for patching. It can be used for vulnerability analysis, finding specific
    functionality, and other searches to identify instruction patterns important to
    reverse engineers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding Specific Behaviors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A program’s behavior is defined by the instructions that it executes combined
    with the data on which it executes. When your patching task involves modifying
    a program’s behavior, locating the exact behavior that you want to modify is usually
    much more difficult than locating data that you wish to change. Because we can
    never predict the exact instruction sequence that a compiler might generate for
    any source code, it is challenging to use Ghidra’s automated search features to
    pinpoint an exact location to apply a code patch. Locating specific behaviors
    boils down to plain-old analysis of the functions in the program using techniques
    covered throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Other than a careful analysis of all functions in the binary or a careful traversal
    of the call tree, beginning with a well-known function such as `main`, the two
    most common techniques for identifying functions of interest are relying on the
    function’s name (assuming the binary has symbols) and using cross-references from
    “interesting” data to backtrack to potentially interesting functions. For example,
    if we are interested in locating the authentication-related functions within a
    binary, we might search for common strings associated with authentication such
    as `"Please enter your` `password:``"` and `"Authentication failed"`. Strings
    similar to these often bookend an authentication process, and locating functions
    that reference these strings may significantly reduce our search space for other
    authentication-related functions.
  prefs: []
  type: TYPE_NORMAL
- en: Here again, the nature of the data that might lead you to find interesting functions
    will depend on your particular patching scenario. Regardless of the approaches
    you use to locate a function that is a candidate for your patch, you should always
    verify that the function does in fact implement the behavior you wish to modify.
    In particular, you should always be wary of the names that programmers assign
    to functions, as there is no requirement for a function’s behavior to match its
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying Your Patch**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At long last, your hard work and perseverance have paid off, and you have located
    the code or data that you wish to modify. What now? Assuming you have already
    developed the replacement content that you intend to patch into the binary, and
    know precisely where you want to place it, it’s time to exercise the Ghidra features
    that modify the program.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to consider is the size of your new content relative
    to the content you are replacing. If the new content’s size is less than or equal
    to the original content’s size, you are in good shape because your patch will
    fit within the memory footprint of the original content. However, things get a
    bit tricky when your patch is larger than the original content, and we will dedicate
    some time to this case shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '***Making Basic Changes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whether you have a pile of bytes in hand or need some help from an assembler,
    you’ll eventually need to get your content into Ghidra. For short runs of bytes,
    you may find it easier to use Ghidra’s built-in byte editor or assembler. For
    longer runs, you’ll probably want to automate. The next few sections describe
    some of Ghidra’s byte-level editing features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Byte Viewer**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Ghidra Byte Viewer (Window ▸ Bytes), shown in [Figure 22-7](ch22.xhtml#fig22_7),
    provides a standard hex dump view of the raw byte content at the current listing
    location, synchronized with every other linked window.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-7: The Ghidra Byte Viewer*'
  prefs: []
  type: TYPE_NORMAL
- en: The Byte Viewer can also double as a hex editor by toggling the Edit Mode tool
    ➊, and it’s a convenient option when you need to change a few bytes at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Inconveniently, Ghidra will not allow you to edit any bytes that are part of
    an existing instruction. The workaround for this limitation is to clear the associated
    instruction in the Listing window (right-click Clear Code Bytes or press hotkey
    C). The Byte Viewer Options tool ➋ is used to open the dialog shown in [Figure
    22-8](ch22.xhtml#fig22_8), which allows you to customize your Byte Viewer display.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-8: Byte Viewer Options dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the Ascii option adds an ASCII dump to the Byte Viewer (see [Figure
    22-9](ch22.xhtml#fig22_9)), which then doubles as an ASCII editor while in edit
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-9: Byte Viewer with ASCII dump enabled*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished entering your new values, you should toggle out of Edit
    Mode and return to the Listing window to verify that your changes are correct.
  prefs: []
  type: TYPE_NORMAL
- en: '##### **Scripting Your Changes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless your patch is very short, the most efficient means of modifying the
    original bytes in Ghidra is to have a script do it for you. Given a patch in the
    form of a byte array, and the start address of the patch, the following function
    applies the patch within Ghidra:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may include this function in a script that creates the array of patch bytes
    from a source of your choosing (for example, by declaring an initialized array
    or by loading the contents of a file). The `clearListing` call ➊ is necessary
    as Ghidra will not allow you to modify bytes that are part of an existing instruction
    or data item. Once the script completes, you will need to manually format the
    patched bytes as either code or data and verify the correctness of your patch.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the Assembler**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When you want to patch the code in a binary, you will most likely find yourself
    thinking in terms of replacing one assembly language instruction with another
    (for example, replacing `CALL _exit` with `NOP`), which is not necessarily incorrect
    but tends to gloss over some of the complexities associated with patching code.
    When the time comes to actually apply your patch to the program, you can’t paste
    in your replacement assembly language statements; instead, you must paste in the
    corresponding machine code bytes, which means you’ll probably want to use an assembler
    to generate machine code versions of all your replacement instructions.
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to use an external editor to write your replacement assembly
    statements, assemble them with an external assembler (for example, `nasm` or `as`),
    extract the raw machine code,^([1](footnotes.xhtml#ch22fn1)) and finally patch
    them into the program, perhaps using a script as discussed earlier. An alternative
    approach is to use Ghidra’s built-in assembler capability, which is accessed by
    right-clicking any instruction and selecting the Patch Instruction menu option.
  prefs: []
  type: TYPE_NORMAL
- en: Just as SLEIGH specifications tell Ghidra how to translate machine code into
    assembly language, they also enable Ghidra to perform assembly-to-machine-code
    translations—that is, act like an assembler. The first time you choose the Patch
    Instruction option for a given architecture, Ghidra will build an assembler based
    on that architecture’s SLEIGH specification. You will initially be presented with
    a message similar to the one shown in [Figure 22-10](ch22.xhtml#fig22_10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-10: The Assembler Rating dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ghidra developers have run tests on the accuracy of Ghidra-generated assemblers.
    If a processor’s assembler has been tested, it is assigned one of the following
    ratings (in decreasing order of accuracy): platinum, gold, silver, bronze, and
    poor. Any untested assemblers are marked *unrated*. More information about Ghidra
    assembler ratings, along with the current rating for all available assemblers,
    may be found in Ghidra Help.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you dismiss the Assembler Rating dialog, Ghidra builds the required assembler
    capability from the current processor’s SLEIGH specification. While you wait for
    the assembler to be built, Ghidra displays the informative wait dialog similar
    to the one shown in [Figure 22-11](ch22.xhtml#fig22_11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-11: The Assemble wait dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: Once your assembler has been built, Ghidra replaces the selected instruction
    in the Listing window with two text input boxes (see [Figure 22-12](ch22.xhtml#fig22_12))
    that allow you to edit the instruction’s mnemonic and operands. The ESC key discards
    your changes before they are assembled, while the ENTER key assembles your new
    instruction and replaces the old instruction’s machine code bytes with those of
    the new instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-12: Assembling a new instruction*'
  prefs: []
  type: TYPE_NORMAL
- en: Because they derive from the same specification as the corresponding disassembler,
    Ghidra’s assemblers recognize the same assembly syntax used in the Ghidra Listing
    window. Ghidra’s assemblers are case sensitive and provide auto-completion options
    as you enter your new instructions. After you enter an instruction, Ghidra returns
    you to the normal Listing window view, and you can reselect Patch Instruction
    if there are additional instructions you want to modify. For short patches, Ghidra’s
    assembler offers a convenient way to simultaneously assemble your instructions
    and modify the program.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instruction Replacement Pitfalls**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While Ghidra’s assembler makes quick work of modifying a single instruction,
    the new replacement instruction can be shorter, longer, or the same size as the
    old instruction. The third case, in which the replacement and original instructions
    are the same size, is not interesting. (The first two problems can arise only
    on architectures without a fixed instruction size, such as x86.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the first case, in which your replacement instruction is shorter than
    the original instruction, as reflected in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a 4-byte `ADD` instruction ➊ is being replaced by a 2-byte `NOP`
    ➌. Ghidra’s assembler has done its best to fill the available space by inserting
    an x86 prefix byte (`66`) ➋ ahead of the x86 opcode for `NOP` (`90`). Unfortunately,
    the replacement instruction is still too short to account for the two remaining
    bytes ➍ of the original instruction, one of which translates to a `HLT` (use the
    hotkey D to disassemble it), and the other that Ghidra can’t disassemble, indicating
    that it does not represent a valid instruction. If you were to patch the original
    binary in this way and run it, it would almost certainly crash upon reaching this
    location.
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra provides no clues—other than the `??` characters that appear in the listing—that
    a problem may exist, as Ghidra does not understand your motivation for making
    this change and the “correct” solution depends on your particular use case. If
    you are modifying instructions within the listing without the intention to export,
    you could use Ghidra’s fallthrough override option from the right-click context
    menu to bypass the unneeded bytes.^([2](footnotes.xhtml#ch22fn2)) Alternatively,
    you can ask Ghidra to disassemble the undefined bytes, but it’s highly unlikely
    that they will disassemble into an instruction that you will find useful. The
    most common solution in this situation is to replace all excess bytes from the
    original instruction with `NOP`s ➎ to pad to the start of the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your replacement instruction is longer than the original instruction,
    it introduces a new set of challenges, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the goal of the patch is to read 256 (`0x100`) bytes rather than
    1 byte. The original, 2-byte `PUSH` instruction ➊ that places the third argument
    to `read` (the length argument) onto the stack is replaced by a 5-byte `PUSH`
    ➌ to push a larger constant. The additional bytes in the replacement instruction
    completely overwrite the instruction that was responsible for the second argument
    to `read` (the read buffer) ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting code not only fails to provide `read` with enough arguments, but
    also passes an integer where a pointer is expected. As with the previous example,
    this will almost certainly cause the patched program to crash. Potential solutions
    to this particular patching problem are nontrivial and are discussed in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '#### ***Making Nontrivial Changes***'
  prefs: []
  type: TYPE_NORMAL
- en: The moment the size of your patch grows larger than the instruction(s) or data
    that you are replacing, your life gets more complicated. In most cases, this doesn’t
    mean that your patch will be impossible to implement, but considerably more thought
    and effort will be needed to implement the patch properly. In this section, we
    discuss several approaches for handling this “patch is too large” problem, based
    on whether the patch contains code or data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oversized Code Patches**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When your patch is too big to fit on top of the instructions you want to modify,
    you have no choice but to locate or create an unused region of sufficient size,
    patch your code into this empty region, and then insert a jump (known as a *hook*)
    at the original patch location to transfer control to your actual patch. In most
    cases, you will also need to append a jump to your replacement code to transfer
    control back to an appropriate location in the hooked function. [Figure 22-13](ch22.xhtml#fig22_13)
    shows the notional flow of a patched function with a jump hook installed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-13: Function with installed patch*'
  prefs: []
  type: TYPE_NORMAL
- en: The available unused space for your oversized code patch must
  prefs: []
  type: TYPE_NORMAL
- en: Be at least as large as your patch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reside at an address that will be executable at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be initialized from file content; otherwise, your patch won’t get loaded at
    runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The easiest place to begin your search for large, unused, executable blocks
    of bytes is with any *code caves* that may be present in the binary. A code cave
    exists when an executable section in a binary, such as the `.text` section, is
    padded to adhere to section alignment requirements mandated by the executable
    file’s format. Code caves are very common in Windows PE binaries, as they frequently
    require every section of the binary to be a multiple of 512 bytes in size.
  prefs: []
  type: TYPE_NORMAL
- en: The first place to look for a code cave is usually the end of the `.text` section.
    You can easily navigate to the end of the `.text` section (or any other section)
    by double-clicking the section name in the CodeBrowser’s Program Trees window
    and then scrolling to the end of the Listing window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our sample PE binary, the Listing window shows the following at the end
    of the `.text` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The listing tells us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The bytes are unclassified by Ghidra (`??`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bytes are initialized to `00h`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.text` section ends at address `140012dff`, which satisfies the file alignment
    requirement that the section is a multiple of 512 bytes in size (`140012e00` is
    a multiple of `0x200`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigating to the previous instruction by scrolling up (or choosing the I tool
    in the CodeBrowser with search direction set to Up), we arrive at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `RET` ➊ is the last meaningful instruction in this particular binary, and
    we can now compute the size of this binary’s code cave as `0x140012e00 - 0x140012cbf
    = 0x141` (or 321 bytes). This means that we can easily patch as many as 321 bytes
    of new code into this binary. Assuming that we patched our new code in at address
    `0x140012cbf`, we would need to patch a jump to `0x140012cbf` somewhere in the
    binary’s existing code to ensure that execution flow eventually reaches our patch.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a code cave can’t be found, or isn’t large enough to hold your patch,
    you will need to get a little creative in order to find enough space to fit your
    patch. Depending on the compiler options used to build the binary, you may be
    able to spread your patch across space gathered from *inter-function alignment
    gaps*. Inter-function alignment gaps exist when compilers choose to align the
    start of every function to an address that is a multiple of 2 (often 16). When
    function alignment is being forced, there will be an average of `align` / 2 bytes
    and as many as `align` – 1 bytes of padding inserted between each function in
    the binary. The following listing shows an optimal (from a patching perspective)
    alignment gap (`align` = 16) between two adjacent functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All of the bytes from `1400010a1` ➊ through `1400010af` ➋ may be safely overwritten
    with patch code.
  prefs: []
  type: TYPE_NORMAL
- en: Additional methods exist for squeezing patch code into a binary—some involving
    expanding existing program sections or injecting entirely new ones. Any technique
    that manipulates sections in such a manner also requires you to update the binary’s
    section headers to make sure they remain consistent with any modifications that
    have been made. Accordingly, these techniques are very file-format specific and
    require a detailed understanding of file header data structures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Oversized Data Patches**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Patching data is easier than patching code in some respects, and more difficult
    in others. For structured data types, your primary concerns are correct size and
    byte ordering of each member of the structure, and since the size of a structure
    is determined at compile time, you don’t need to worry about oversized replacement
    structures. When patching string data, it is recommended that any replacement
    data fit entirely within the footprint of the original string. If your new string
    is larger than the original string, you may be fortunate to find a few bytes of
    padding between the end of the string and the next data item, but you must be
    careful not to corrupt any data that the program depends upon. If your data simply
    does not fit into the memory footprint of the original data, you will be forced
    to find a new location for it, but moving data properly can be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: All global data items are referred to by their offsets from the program’s code
    or data sections. To relocate a data item, in addition to finding sufficient unused
    space, you’ll need to locate every reference to the original data item and patch
    it to refer to the new data item. Ghidra cross-references go a long way toward
    identifying every reference to a global, but will fail to identify derived pointers
    (pointers resulting from pointer arithmetic).
  prefs: []
  type: TYPE_NORMAL
- en: Once all of your patches have been entered in Ghidra and you’re happy with the
    resulting program listing, you’ll want to push your changes into the original
    binary to verify that your patches behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '### **Exporting Files**'
  prefs: []
  type: TYPE_NORMAL
- en: To confirm that any of your changes will have the desired effect on the binary’s
    behavior, you’ll need to update the original binary to reflect your changes. In
    this section, we discuss some of Ghidra’s export features as they relate to patching.
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra’s File ▸ Export Program menu option offers the capability to export a
    program’s information in any of several formats. The resulting Export dialog is
    shown in [Figure 22-14](ch22.xhtml#fig22_14).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-14: The Ghidra Export dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: The Export dialog is also accessible from the Project Manager by right-clicking
    the file you wish to export and selecting Export from the context menu. In the
    dialog, you are asked to specify the export format and the output file location,
    and to indicate whether you wish to limit the scope of your export to a range
    you have selected in the CodeBrowser. Some export formats offer additional options
    for more fine-grained control over the export process.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ghidra Export Formats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ghidra supports the following export formats, though only one (binary) is particularly
    useful for binary patching:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ascii** The Ascii export format can be used to save a textual representation
    of the program, similar to what is displayed in the Listing window, with options
    to choose which fields to include in the output file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary** The Binary export format, which produces a binary file, is the most
    useful for patching applications and is discussed in its own section.'
  prefs: []
  type: TYPE_NORMAL
- en: '**C/C++** The C/C++ export format is used to save the Decompiler-generated
    source representation of the program along with declarations for all types known
    to the Data Type Manager. This option is also available from the Decompiler window.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ghidra Zip File** A Ghidra *zip* file is a serialized Java object representation
    of your program suitable for import into other Ghidra instances.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML** The HTML export format generates an HTML representation of the program
    listing. Options similar to those available in the Ascii exporter allow you to
    choose which fields to include in the output file. Labels and cross-references
    are represented as hyperlinks to provide a basic navigational capability throughout
    the generated output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intel Hex** The Intel Hex format defines an ASCII representation for binary
    data, commonly used for programming EEPROM.'
  prefs: []
  type: TYPE_NORMAL
- en: '**XML** The XML exporter outputs the contents of the program in a structured
    XML format, with options to choose which program constructs should be included
    in the generated file. This functionality is also available for individual functions
    in the Decompiler window to facilitate debugging function decompilation. Although
    Ghidra includes a corresponding XML loader, this exporter includes the following
    warning: “Warning: XML is lossy and intended only for transferring data to external
    tools. GZF is the recommended format for saving and sharing program data.”'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Binary Export Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ghidra’s Binary export is used to write a program’s underlying binary content
    to a file. All of the program’s initialized memory blocks (see Window ▸ Memory
    Map) are concatenated to form the output file. Whether the output file is identical
    to the original file that was imported depends on the loader module used to import
    the file. The Raw Binary loader is guaranteed to re-create the original input
    file because it loads every byte of the original file into a single memory block.
    Other loaders may or may not load every file byte (for example, the PE loader
    does, while the ELF loader does not).
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to apply any changes you have made with Ghidra, you need
    to ensure that the file you generate contains your patches and that it will execute.
    If you are patching a PE file, a Binary export will generate a patched version
    of the original binary. Similarly, if you imported your program using the Raw
    Binary loader, a Binary export will generate a patched version of the original
    binary. Of course, as discussed in [Chapter 17](ch17.xhtml#ch17), when using the
    Raw Binary loader, you may need to perform most of the memory layout for the program
    manually, so there is a trade-off. Fortunately, it’s possible to script up a solution
    that works with any loader.
  prefs: []
  type: TYPE_NORMAL
- en: '***Script-Assisted Export***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rather than performing an exhaustive test of every Ghidra loader to understand
    whether the memory blocks created by the loader span the entire range of file
    bytes, we can create a Ghidra script that will save a patched version of our program
    for us. This script provides a loader-agnostic capability for generating patched
    files with Ghidra. It will always process the entire range of original file bytes
    regardless of the current memory map layout known to Ghidra.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The script begins by obtaining the program’s list of `FileBytes` ➊. A `FileBytes`
    object encapsulates all of the bytes from the imported program file and tracks
    both the original and modified value of each byte in the file. As Ghidra allows
    you to import several files into a single program, this script processes only
    the bytes from the first file you imported into the program (first range of file
    bytes) ➋.
  prefs: []
  type: TYPE_NORMAL
- en: After prompting for an output file ➌, the `FileBytes` object and open `OutputStream`
    are passed to our `writePatchFile` function to handle the finer details of generating
    the patched executable.
  prefs: []
  type: TYPE_NORMAL
- en: To present a mapped memory view of a program, Ghidra loaders may process a program’s
    relocation table entries in a manner similar to a runtime loader. The result of
    this processing is that program locations marked for fixup (locations that have
    relocation table entries) are modified by Ghidra from their original file values
    to proper relocated values. When we generate the patched version of the binary,
    we do not want to include any bytes that Ghidra has modified for relocation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `writePatchFile` function, shown next, begins by generating the set of
    addresses that are patched at runtime (and by Ghidra) in accordance with the program’s
    relocation table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After obtaining an iterator over the program’s relocation table ➊, the `AddressSourceInfo`
    for each relocation entry is obtained ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `AddressSourceInfo` object provides a mapping of a program address to the
    disk file and the offset into that file from which the corresponding program byte
    was loaded. The file offset of each relocation byte is added to a set of offsets
    ➌ to be ignored when generating the final patched file. The function concludes
    by calling the `saveBytes` function ➍ to write the final patched version of the
    current program file. The `saveBytes` function is shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The function iterates over the entire range of file bytes ➊ to determine whether
    to save the original or modified byte to the output file.
  prefs: []
  type: TYPE_NORMAL
- en: At each file offset, methods of the `FileBytes` class are used to obtain the
    original byte value ➋, loaded from the imported file, and the current byte value
    ➌, which may have been modified by Ghidra or the Ghidra user. If the original
    value differs from the current value *and* the byte is not associated with a relocation
    entry, the modified byte is written to the output file ➍; otherwise, the original
    byte is written to the output file ➎.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up this section, let’s look at an example of patching a binary and confirming
    that the patch runs as we expect it to.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example: Patching a Binary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at an example that demonstrates patching in context. Assume that
    you have a piece of malware that checks for a debugger and, if one is present,
    exits without allowing you to examine its behavior. The following source code
    outlines that functionality in a trivial program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code checks for a debugger ➊ and exits if it finds one. Otherwise, it goes
    about its nefarious business. The following shows the output of the program running
    alone (without a debugger):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program runs under a debugger, we see a different response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we load the binary into Ghidra, we see the following in the Listing window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The Decompiler window provides the following corresponding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To patch this binary to bypass the check, you could `NOP` the call to the `is_debugger_present`
    function, change the test condition, or change the contents of the `is_debugger_present`
    function. If you use the Patch Instruction option from the right-click context
    menu, it is easy to replace the `JZ` with a `JNZ` (effectively flipping the condition
    to run only if it is being debugged), as shown in [Figure 22-15](ch22.xhtml#fig22_15).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-15: Patch Instruction option after replacing* `JZ` *with* `JNZ`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This would result in the following code in the Decompiler window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then export the file as a binary using our export script and run it again,
    we see the following two listings, which demonstrate the behavior we were hoping
    to accomplish with our patch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: While there are many external tools (for example, `VBinDiff`) available to confirm
    that only 1 byte was changed within the file for this example, you can also use
    Ghidra's internal tools to reach the same conclusion. The next chapter focuses
    on methods to accomplish this goal.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regardless of your particular motivation for patching a binary, your patch will
    require careful planning and deployment. Ghidra provides everything you need to
    plan your patch; to draft your patch using hex editing, Ghidra’s built-in assembler,
    or scripting; to view the effects of each change; and to possibly revert changes
    using Undo before generating a patch version of your original binary. The next
    chapter demonstrates how you can use Ghidra to compare the unpatched and patched
    versions of your binaries as well as discusses Ghidra’s capabilities for more
    advanced binary differencing and version tracking.
  prefs: []
  type: TYPE_NORMAL
