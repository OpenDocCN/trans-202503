- en: '## **22'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **22'
- en: PATCHING BINARIES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**修补二进制文件**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: 'Occasionally when reverse engineering a binary, you may decide that you want
    to modify the behavior of the original binary. Behavioral modification is usually
    accomplished by patching the binary to insert, remove, or modify existing instructions.
    Many motivations exist for making such modifications—some more controversial than
    others—including the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在反向工程一个二进制文件时，你可能会决定修改原始二进制的行为。行为修改通常通过修补二进制文件来完成，方法是插入、删除或修改现有的指令。进行此类修改的动机有很多—其中一些比较有争议—包括以下几点：
- en: Modifying a malware sample to eliminate anti-debug techniques that prevent the
    malware from being studied
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改恶意软件样本以消除防调试技术，防止恶意软件被研究
- en: Patching vulnerabilities in software for which you have no source code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修补没有源代码的软件漏洞
- en: Customizing an application’s splash screen or string content
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义应用程序的启动画面或字符串内容
- en: Modifying game logic for the purposes of cheating
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改游戏逻辑以进行作弊
- en: Unlocking hidden features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁隐藏功能
- en: Bypassing licensing checks or other anti-piracy protections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过许可检查或其他反盗版保护措施
- en: In this chapter, we have no intention of teaching you how to do anything unethical,
    but we discuss the high-level challenges of modifying a binary to reflect any
    changes that you have made within Ghidra. [Chapter 14](ch14.xhtml#ch14) introduced
    the `setByte` API function, and [Chapter 21](ch21.xhtml#ch21) showed how different
    styles of emulation scripts were able to modify the content of a program loaded
    into Ghidra. These techniques modify the content that has been imported into Ghidra
    and have no effect whatsoever on the original binary file that Ghidra processed
    during the import process. To complete the patching process, you’ll learn how
    to get Ghidra to write changes back to a file on disk. We also discuss the challenges
    that different types of patches might pose.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们并不打算教授任何不道德的行为，但我们讨论了修改二进制文件以反映你在 Ghidra 中所做更改的高层次挑战。[第14章](ch14.xhtml#ch14)
    介绍了 `setByte` API 函数，[第21章](ch21.xhtml#ch21) 展示了不同风格的仿真脚本如何修改加载到 Ghidra 中的程序内容。这些技术修改了导入到
    Ghidra 中的内容，对原始二进制文件没有任何影响。为了完成修补过程，你将学会如何让 Ghidra 将更改写回磁盘上的文件。我们还将讨论不同类型补丁可能带来的挑战。
- en: '**Planning Your Patch**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**规划你的补丁**'
- en: 'The patching process typically involves the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 修补过程通常涉及以下步骤：
- en: Determine the type of patch you intend to make. This will often be determined
    by your rationale for patching, as discussed previously.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定你打算进行的修补类型。这通常由你修补的理由决定，如前所述。
- en: Identify the exact program location(s) that needs to be patched. This typically
    involves some amount of research and analysis of the program to be patched.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定需要修补的程序位置。这通常需要对程序进行一定的研究和分析。
- en: Plan the content of your patch. Content changes may require new data, new machine
    code, or both. In any case, your changes must be well thought out to prevent the
    program from exhibiting any unintended behavior.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规划补丁的内容。内容更改可能需要新的数据、新的机器代码或两者兼具。在任何情况下，你的更改必须经过深思熟虑，以防程序出现任何意外行为。
- en: Use Ghidra to replace existing program content (data or code) with your replacement
    content.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Ghidra 替换现有的程序内容（数据或代码）为你的替代内容。
- en: Use Ghidra to verify that your changes appear to be correctly implemented.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Ghidra 验证你的更改是否已正确实施。
- en: Use Ghidra to export your changes into a new binary file.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Ghidra 将你的更改导出为一个新的二进制文件。
- en: Verify that the new binary file behaves as intended, repeating from step 2 as
    necessary.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证新的二进制文件是否按预期行为运行，必要时重复第 2 步。
- en: In some patching scenarios, many of these steps will be almost trivial; in others,
    they will be much more challenging. In the sections that follow, we review those
    steps that Ghidra can help you with and discuss situations that may push you or
    Ghidra to your limits. We’ll start with step 2 and review some of the ways that
    Ghidra helps you locate items of interest in a patching context.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些修补场景中，许多步骤可能显得几乎微不足道；而在其他场景中，它们将更加具有挑战性。在接下来的章节中，我们将回顾 Ghidra 可以帮助你完成的步骤，并讨论可能将你或
    Ghidra 推向极限的情况。我们将从第 2 步开始，回顾 Ghidra 在修补过程中帮助你找到感兴趣项的几种方式。
- en: '**Finding Things to Change**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**寻找要更改的内容**'
- en: The exact nature of your patch will dictate what you need to patch. Custom­izing
    splash screens or strings requires that you locate the original data that needs
    changing. Changing the logic of a program requires modifying or inserting code
    to change the program’s behavior. In this case, a significant amount of reverse
    engineering may be required just to find any program locations that need to be
    modified. Many of Ghidra’s capabilities that facilitate these activities have
    been covered in previous chapters. Let’s review some of the capabilities useful
    for patching.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁的具体性质将决定你需要修补的内容。定制启动画面或字符串需要你定位需要更改的原始数据。改变程序的逻辑需要修改或插入代码来改变程序的行为。在这种情况下，可能需要大量的逆向工程，仅仅是为了找到需要修改的程序位置。Ghidra的许多功能都可以帮助完成这些任务，前面章节中已经介绍过。让我们回顾一下对于补丁制作有用的一些功能。
- en: '***Searching Memory***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搜索内存***'
- en: When your patch involves modifying program data, your primary means of identifying
    where to apply your patches will be some form of memory search. The most general
    memory search is the CodeBrowser’s Search ▸ Memory menu option (hotkey S), shown
    in [Figure 22-1](ch22.xhtml#fig22_1) (with Advanced options expanded). The Search
    Memory dialog was previously discussed in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的补丁涉及修改程序数据时，你识别应用补丁位置的主要方式将是某种形式的内存搜索。最常见的内存搜索是CodeBrowser的“搜索 ▸ 内存”菜单选项（快捷键
    S），如[图 22-1](ch22.xhtml#fig22_1)所示（展开了高级选项）。“搜索内存”对话框在[第6章](ch06.xhtml#ch06)中已讨论过。
- en: '![image](Images/fig22-1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-1.jpg)'
- en: '*Figure 22-1: The Search Memory dialog*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-1：搜索内存对话框*'
- en: The Search Memory dialog is most useful in a patching context when you are searching
    for specific, known data within the binary, such as known strings or hex sequences.
    A successful search will reposition all linked displays to the location of the
    matching bytes, or in the case of Search All, open a new dialog containing a list
    of all addresses at which the matched content may be found. For very large binaries,
    it may be useful to limit the scope of your search to specific regions (Instructions,
    Defined Data, Undefined Data, and so on) within the program that are likely to
    contain a match by deselecting any uninteresting code unit types.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “搜索内存”对话框在补丁制作的上下文中最为有用，尤其是在你要查找二进制文件中已知的特定数据时，如已知的字符串或十六进制序列。成功的搜索将使所有相关显示重新定位到匹配字节的位置，或者在“搜索所有”情况下，打开一个新对话框，列出所有可以找到匹配内容的地址。对于非常大的二进制文件，可能需要将搜索范围限制在程序中的特定区域（如指令、已定义数据、未定义数据等），通过取消选择任何无关的代码单元类型来减少搜索的范围。
- en: '**NOTE**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*While Search ▸ Memory provides the most configurable general-purpose search
    capability in Ghidra, it is a search across the raw byte content of the database,
    and other search types may be more suited to the type of data you are looking
    for. For example, Search ▸ Memory is the wrong choice if you want to search within
    the body of comments that you have entered into the program. Refer to “[Search
    Program Text](ch06.xhtml#ch06lev115)” on [page 115](ch06.xhtml#page_115) for more
    information on searching within the disassembly listing itself.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然“搜索 ▸ 内存”提供了Ghidra中最为灵活的一般性搜索功能，但它是对数据库原始字节内容的搜索，其他类型的搜索可能更适合你正在查找的数据类型。例如，如果你想在你输入到程序中的注释内容中进行搜索，那么“搜索
    ▸ 内存”就不适合你。有关在反汇编列表中搜索的更多信息，请参见[“搜索程序文本”](ch06.xhtml#ch06lev115)，[第115页](ch06.xhtml#page_115)。*'
- en: '***Searching for Direct References***'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搜索直接引用***'
- en: In [Chapter 20](ch20.xhtml#ch20), we used Search ▸ For Direct References to
    scan the program’s binary content for all occurrences of a specific address. The
    most common use for this search type is to locate pointers to interesting data
    when Ghidra has failed to create a cross-reference to the data. In a patching
    context, this is most often used to fully understand and update all references
    to a data or code location to maintain proper relationships between code and data
    in the patched binary.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第20章](ch20.xhtml#ch20)中，我们使用“搜索 ▸ 直接引用”扫描程序的二进制内容，查找特定地址的所有出现位置。此类搜索最常见的用途是定位指向感兴趣数据的指针，尤其是在Ghidra未能为这些数据创建交叉引用时。在补丁制作的上下文中，这通常用于全面理解并更新所有数据或代码位置的引用，以保持补丁二进制文件中代码和数据之间的正确关系。
- en: '***Searching for Instruction Patterns***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***搜索指令模式***'
- en: 'Ghidra’s Search ▸ For Instruction Patterns feature finds a specific sequence
    of instructions by matching a pattern. When defining an instruction pattern, you
    need to strike a delicate balance between patterns that are too specific and patterns
    that are too general. Let’s look at an example to illustrate this idea. Assume
    we have a listing that includes a `cleanup_and_exit` function that exits the program:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra的“搜索 ▸ 查找指令模式”功能通过匹配模式来查找特定的指令序列。定义指令模式时，需要在过于具体的模式和过于通用的模式之间找到微妙的平衡。让我们看一个例子来说明这个概念。假设我们有一个列出包含`cleanup_and_exit`函数的清单，该函数会退出程序：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function `do_testing` conducts a series of tests ➋. If any of the tests
    fail, the `cleanup_and_exit` function ➊ is called and execution ends. If all tests
    succeed, some very interesting code ➌ will execute. Our patching challenge is
    to determine where we need to patch to ensure that all of the tests pass so that
    we can reach the interesting code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`do_testing`执行一系列测试 ➋。如果任何测试失败，`cleanup_and_exit`函数 ➊ 会被调用，程序执行结束。如果所有测试都通过，某些非常有趣的代码
    ➌ 将被执行。我们的修补挑战是确定需要在哪些地方修补，以确保所有测试都通过，从而使我们能够执行有趣的代码。
- en: 'If we load the binary into Ghidra, we can search for all calls to `cleanup_and_exit`
    to determine what we need to patch in order for all of the tests to pass regardless
    of the number of tests. We have several options to consider:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将二进制文件加载到Ghidra中，我们可以搜索所有对`cleanup_and_exit`的调用，以确定需要修补什么，以确保所有测试都通过，无论测试数量如何。我们有几个选项需要考虑：
- en: We could just go to that function and patch it to return so that a failed test
    doesn’t exit the program but rather continues. This isn’t an optimal solution
    because the function is also used for a legitimate exit at the end of the program
    after it completes the interesting work.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以直接进入该函数并修补它，使其返回，以便失败的测试不会退出程序，而是继续执行。这不是一个最佳解决方案，因为该函数也用于在程序完成有趣的工作后，合法地退出程序。
- en: We could use search functionality or XREFs to `cleanup_and_exit`. This would
    give us all of the calls, but we wish to patch only some of them.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用搜索功能或XREFs来查找`cleanup_and_exit`。这将给我们所有的调用，但我们只希望修补其中的一些。
- en: We could identify an instruction pattern that the calls have in common and use
    Search ▸ For Instruction Patterns to find the correct calls to patch.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以识别出这些调用所共有的指令模式，并使用“搜索 ▸ 查找指令模式”来找到需要修补的正确调用。
- en: 'To use this search functionality, we need to identify a useful pattern. Each
    test we are trying to pass takes the following form in the Listing window:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此搜索功能，我们需要确定一个有用的模式。我们尝试通过的每个测试在“清单”窗口中都有以下形式：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s try searching for that sequence by selecting the instruction sequence
    and Search ▸ For Instruction Patterns. This automatically populates the Instruction
    Pattern Search dialog, as shown in [Figure 22-2](ch22.xhtml#fig22_2).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过选择指令序列并点击“搜索 ▸ 查找指令模式”来尝试搜索该序列。这将自动填充指令模式搜索对话框，如[图 22-2](ch22.xhtml#fig22_2)所示。
- en: '![image](Images/fig22-2.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-2.jpg)'
- en: '*Figure 22-2: Instruction Pattern Search dialog with all fields selected*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-2：选择所有字段的指令模式搜索对话框*'
- en: If we click Search All, we see only one result (the specific location that we
    selected when we started the search), as shown in [Figure 22-3](ch22.xhtml#fig22_3).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击“搜索所有”，我们将看到只有一个结果（即我们在开始搜索时选择的特定位置），如[图 22-3](ch22.xhtml#fig22_3)所示。
- en: '![image](Images/fig22-3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-3.jpg)'
- en: '*Figure 22-3: Instruction pattern search results from all fields selected*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-3：选择所有字段后的指令模式搜索结果*'
- en: Our issue is that we are including operands that do not remain constant between
    the test cases. For example, the operand to the first call is the address of a
    specific test function. We can deselect individual components (mnemonics and operands)
    of any instruction in the pattern to make it more general, as shown in [Figure
    22-4](ch22.xhtml#fig22_4). Anything that has been deselected is treated as a wildcard
    in subsequent searches.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的问题是，我们包含了一些在测试案例之间不会保持不变的操作数。例如，第一个调用的操作数是某个特定测试函数的地址。我们可以取消选择任何指令模式中的单个组成部分（助记符和操作数），使其变得更加通用，如[图
    22-4](ch22.xhtml#fig22_4)所示。任何被取消选择的部分都会在随后的搜索中被视为通配符。
- en: '![image](Images/fig22-4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-4.jpg)'
- en: '*Figure 22-4: Instruction Pattern Search dialog with some operands deselected*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-4：选择部分操作数的指令模式搜索对话框*'
- en: If we click Search All with operand fields disabled, we see the three results
    shown in [Figure 22-5](ch22.xhtml#fig22_5).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击禁用操作数字段的“搜索所有”按钮，我们将看到[图 22-5](ch22.xhtml#fig22_5)中显示的三个结果。
- en: '![image](Images/fig22-5.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-5.jpg)'
- en: '*Figure 22-5: Instruction pattern search results with some operands deselected*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-5：指令模式搜索结果，部分操作数被取消选择*'
- en: The search still fails to identify the call to `test_multiple_10`, which uses
    a `JZ` rather than a `JNZ` instruction. Deselecting the mnemonic field for the
    `JNZ` instruction and rerunning the search yields the results shown in [Figure
    22-6](ch22.xhtml#fig22_6), which includes the four calls we wish to patch and
    does not include the final call to `cleanup_and_exit` that we do not want to patch.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索仍未能识别到对`test_multiple_10`的调用，该调用使用的是`JZ`指令而不是`JNZ`指令。取消选择`JNZ`指令的助记符字段并重新运行搜索，得到的结果如[图
    22-6](ch22.xhtml#fig22_6)所示，其中包括了我们希望补丁的四个调用，并且没有包括我们不想补丁的最终调用`cleanup_and_exit`。
- en: '![image](Images/fig22-6.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-6.jpg)'
- en: '*Figure 22-6: Instruction pattern search results with* `JNZ` *and some operands
    deselected*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-6：指令模式搜索结果，带有`JNZ`并且部分操作数被取消选择*'
- en: This search functionality has a number of uses beyond locating candidate instruction
    patterns for patching. It can be used for vulnerability analysis, finding specific
    functionality, and other searches to identify instruction patterns important to
    reverse engineers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种搜索功能不仅用于定位补丁候选指令模式。它还可以用于漏洞分析、查找特定功能以及其他搜索，以识别对逆向工程师重要的指令模式。
- en: '***Finding Specific Behaviors***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***查找特定行为***'
- en: A program’s behavior is defined by the instructions that it executes combined
    with the data on which it executes. When your patching task involves modifying
    a program’s behavior, locating the exact behavior that you want to modify is usually
    much more difficult than locating data that you wish to change. Because we can
    never predict the exact instruction sequence that a compiler might generate for
    any source code, it is challenging to use Ghidra’s automated search features to
    pinpoint an exact location to apply a code patch. Locating specific behaviors
    boils down to plain-old analysis of the functions in the program using techniques
    covered throughout this book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的行为由它执行的指令和执行这些指令时使用的数据共同定义。当你的补丁任务涉及修改程序行为时，定位你想要修改的确切行为通常比定位你希望更改的数据要困难得多。因为我们永远无法预测编译器可能为任何源代码生成的确切指令序列，所以使用
    Ghidra 的自动化搜索功能来精准定位应用代码补丁的位置是具有挑战性的。定位特定行为归根结底还是要通过本书中介绍的各种技术对程序中的函数进行常规分析。
- en: Other than a careful analysis of all functions in the binary or a careful traversal
    of the call tree, beginning with a well-known function such as `main`, the two
    most common techniques for identifying functions of interest are relying on the
    function’s name (assuming the binary has symbols) and using cross-references from
    “interesting” data to backtrack to potentially interesting functions. For example,
    if we are interested in locating the authentication-related functions within a
    binary, we might search for common strings associated with authentication such
    as `"Please enter your` `password:``"` and `"Authentication failed"`. Strings
    similar to these often bookend an authentication process, and locating functions
    that reference these strings may significantly reduce our search space for other
    authentication-related functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对二进制文件中所有函数的仔细分析或从一个熟悉的函数（如`main`）开始进行调用树的仔细遍历外，识别感兴趣函数的两种最常见方法是依赖于函数的名称（假设二进制文件有符号信息）以及利用来自“感兴趣”数据的交叉引用反向追溯到可能感兴趣的函数。例如，如果我们想定位二进制文件中的身份验证相关函数，我们可以搜索与身份验证相关的常见字符串，如`"请输入您的`
    `密码："`和`"身份验证失败"`。类似的字符串通常出现在身份验证过程的开头和结尾，找到引用这些字符串的函数可以显著减少我们搜索其他身份验证相关函数的范围。
- en: Here again, the nature of the data that might lead you to find interesting functions
    will depend on your particular patching scenario. Regardless of the approaches
    you use to locate a function that is a candidate for your patch, you should always
    verify that the function does in fact implement the behavior you wish to modify.
    In particular, you should always be wary of the names that programmers assign
    to functions, as there is no requirement for a function’s behavior to match its
    name.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，可能会导致你找到感兴趣函数的数据的性质，取决于你特定的补丁场景。无论你使用何种方法定位一个函数作为补丁的候选，你都应始终验证该函数是否真正实现了你希望修改的行为。特别是，你应该始终对程序员为函数指定的名称保持警惕，因为函数的行为并不一定与其名称相符。
- en: '**Applying Your Patch**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用你的补丁**'
- en: At long last, your hard work and perseverance have paid off, and you have located
    the code or data that you wish to modify. What now? Assuming you have already
    developed the replacement content that you intend to patch into the binary, and
    know precisely where you want to place it, it’s time to exercise the Ghidra features
    that modify the program.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 终于，你的辛勤工作和坚持不懈得到了回报，你找到了你希望修改的代码或数据。接下来怎么办？假设你已经开发了要替换到二进制中的内容，并且知道你准确的位置，现在是时候使用
    Ghidra 的功能来修改程序了。
- en: The first thing you need to consider is the size of your new content relative
    to the content you are replacing. If the new content’s size is less than or equal
    to the original content’s size, you are in good shape because your patch will
    fit within the memory footprint of the original content. However, things get a
    bit tricky when your patch is larger than the original content, and we will dedicate
    some time to this case shortly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要考虑的是新内容相对于你要替换的内容的大小。如果新内容的大小小于或等于原始内容的大小，那么你就很顺利，因为你的补丁会适应原始内容的内存占用。然而，当你的补丁大于原始内容时，事情就会变得有点棘手，我们稍后会专门讨论这种情况。
- en: '***Making Basic Changes***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***进行基本更改***'
- en: Whether you have a pile of bytes in hand or need some help from an assembler,
    you’ll eventually need to get your content into Ghidra. For short runs of bytes,
    you may find it easier to use Ghidra’s built-in byte editor or assembler. For
    longer runs, you’ll probably want to automate. The next few sections describe
    some of Ghidra’s byte-level editing features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你手头有一堆字节，还是需要借助汇编器的帮助，最终你都需要将内容导入 Ghidra。对于短小的字节序列，你可能会觉得使用 Ghidra 内置的字节编辑器或汇编器更为方便。对于较长的字节序列，你可能会想要自动化处理。接下来的几节将介绍
    Ghidra 的一些字节级编辑功能。
- en: '**Byte Viewer**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字节查看器**'
- en: The Ghidra Byte Viewer (Window ▸ Bytes), shown in [Figure 22-7](ch22.xhtml#fig22_7),
    provides a standard hex dump view of the raw byte content at the current listing
    location, synchronized with every other linked window.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 字节查看器（窗口 ▸ 字节），如 [图 22-7](ch22.xhtml#fig22_7) 所示，提供了当前列出位置的原始字节内容的标准十六进制转储视图，并与每个其他链接的窗口同步。
- en: '![image](Images/fig22-7.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-7.jpg)'
- en: '*Figure 22-7: The Ghidra Byte Viewer*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-7：Ghidra 字节查看器*'
- en: The Byte Viewer can also double as a hex editor by toggling the Edit Mode tool
    ➊, and it’s a convenient option when you need to change a few bytes at a time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 字节查看器也可以通过切换编辑模式工具 ➊ 作为十六进制编辑器使用，这是当你需要一次修改几个字节时的一个便捷选项。
- en: Inconveniently, Ghidra will not allow you to edit any bytes that are part of
    an existing instruction. The workaround for this limitation is to clear the associated
    instruction in the Listing window (right-click Clear Code Bytes or press hotkey
    C). The Byte Viewer Options tool ➋ is used to open the dialog shown in [Figure
    22-8](ch22.xhtml#fig22_8), which allows you to customize your Byte Viewer display.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不便之处在于，Ghidra 不允许你编辑任何现有指令的一部分。解决这一限制的方法是，在列表窗口中清除相关指令（右键点击清除代码字节或按快捷键 C）。字节查看器选项工具
    ➋ 用于打开 [图 22-8](ch22.xhtml#fig22_8) 所示的对话框，在此你可以自定义字节查看器的显示。
- en: '![image](Images/fig22-8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-8.jpg)'
- en: '*Figure 22-8: Byte Viewer Options dialog*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-8：字节查看器选项对话框*'
- en: Selecting the Ascii option adds an ASCII dump to the Byte Viewer (see [Figure
    22-9](ch22.xhtml#fig22_9)), which then doubles as an ASCII editor while in edit
    mode.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 ASCII 选项会将 ASCII 转储添加到字节查看器中（见 [图 22-9](ch22.xhtml#fig22_9)），这样在编辑模式下它就会同时充当
    ASCII 编辑器。
- en: '![image](Images/fig22-9.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-9.jpg)'
- en: '*Figure 22-9: Byte Viewer with ASCII dump enabled*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-9：启用 ASCII 转储的字节查看器*'
- en: Once you have finished entering your new values, you should toggle out of Edit
    Mode and return to the Listing window to verify that your changes are correct.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了新值的输入，应该退出编辑模式并返回到列表窗口，验证你的更改是否正确。
- en: '##### **Scripting Your Changes**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **脚本化你的更改**'
- en: 'Unless your patch is very short, the most efficient means of modifying the
    original bytes in Ghidra is to have a script do it for you. Given a patch in the
    form of a byte array, and the start address of the patch, the following function
    applies the patch within Ghidra:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的补丁非常短，否则在 Ghidra 中修改原始字节的最有效方法是让脚本为你完成。给定一个字节数组形式的补丁，以及补丁的起始地址，以下函数将在 Ghidra
    中应用补丁：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may include this function in a script that creates the array of patch bytes
    from a source of your choosing (for example, by declaring an initialized array
    or by loading the contents of a file). The `clearListing` call ➊ is necessary
    as Ghidra will not allow you to modify bytes that are part of an existing instruction
    or data item. Once the script completes, you will need to manually format the
    patched bytes as either code or data and verify the correctness of your patch.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此功能包含在一个脚本中，该脚本根据你选择的来源创建补丁字节数组（例如，通过声明已初始化的数组或加载文件内容）。`clearListing`调用
    ➊ 是必要的，因为Ghidra不允许你修改已经是现有指令或数据项一部分的字节。脚本完成后，你需要手动将补丁字节格式化为代码或数据，并验证补丁的正确性。
- en: '**Using the Assembler**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用汇编器**'
- en: When you want to patch the code in a binary, you will most likely find yourself
    thinking in terms of replacing one assembly language instruction with another
    (for example, replacing `CALL _exit` with `NOP`), which is not necessarily incorrect
    but tends to gloss over some of the complexities associated with patching code.
    When the time comes to actually apply your patch to the program, you can’t paste
    in your replacement assembly language statements; instead, you must paste in the
    corresponding machine code bytes, which means you’ll probably want to use an assembler
    to generate machine code versions of all your replacement instructions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在二进制文件中打补丁时，你很可能会考虑用另一条汇编语言指令替换原有指令（例如，将`CALL _exit`替换为`NOP`），这并不一定是错误的，但通常忽略了与补丁代码相关的一些复杂性。实际上，当你准备将补丁应用到程序时，你不能直接粘贴替换的汇编语言语句；你必须粘贴相应的机器码字节，这意味着你可能需要使用汇编器来生成所有替换指令的机器码版本。
- en: One approach is to use an external editor to write your replacement assembly
    statements, assemble them with an external assembler (for example, `nasm` or `as`),
    extract the raw machine code,^([1](footnotes.xhtml#ch22fn1)) and finally patch
    them into the program, perhaps using a script as discussed earlier. An alternative
    approach is to use Ghidra’s built-in assembler capability, which is accessed by
    right-clicking any instruction and selecting the Patch Instruction menu option.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用外部编辑器编写替换的汇编语句，使用外部汇编器（例如，`nasm`或`as`）进行汇编，提取原始机器码^([1](footnotes.xhtml#ch22fn1))，最后将其打补丁到程序中，可能会像之前讨论的那样使用脚本。另一种方法是使用Ghidra内置的汇编器功能，可以通过右键单击任何指令并选择“补丁指令”菜单选项来访问。
- en: Just as SLEIGH specifications tell Ghidra how to translate machine code into
    assembly language, they also enable Ghidra to perform assembly-to-machine-code
    translations—that is, act like an assembler. The first time you choose the Patch
    Instruction option for a given architecture, Ghidra will build an assembler based
    on that architecture’s SLEIGH specification. You will initially be presented with
    a message similar to the one shown in [Figure 22-10](ch22.xhtml#fig22_10).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像SLEIGH规范告诉Ghidra如何将机器代码转换为汇编语言一样，它们还使Ghidra能够执行汇编到机器代码的转换——也就是说，像一个汇编器一样工作。第一次为特定架构选择“补丁指令”选项时，Ghidra会基于该架构的SLEIGH规范构建一个汇编器。最初，你将看到类似于[图22-10](ch22.xhtml#fig22_10)所示的消息。
- en: '![image](Images/fig22-10.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-10.jpg)'
- en: '*Figure 22-10: The Assembler Rating dialog*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图22-10：汇编器评分对话框*'
- en: 'The Ghidra developers have run tests on the accuracy of Ghidra-generated assemblers.
    If a processor’s assembler has been tested, it is assigned one of the following
    ratings (in decreasing order of accuracy): platinum, gold, silver, bronze, and
    poor. Any untested assemblers are marked *unrated*. More information about Ghidra
    assembler ratings, along with the current rating for all available assemblers,
    may be found in Ghidra Help.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra的开发者已经对Ghidra生成的汇编器的准确性进行了测试。如果一个处理器的汇编器已经过测试，它将被分配以下之一的评分（按准确性递减顺序）：铂金、黄金、白银、青铜和差。任何未测试的汇编器将标记为*未评分*。有关Ghidra汇编器评分的更多信息，以及所有可用汇编器的当前评分，可以在Ghidra帮助文档中找到。
- en: Once you dismiss the Assembler Rating dialog, Ghidra builds the required assembler
    capability from the current processor’s SLEIGH specification. While you wait for
    the assembler to be built, Ghidra displays the informative wait dialog similar
    to the one shown in [Figure 22-11](ch22.xhtml#fig22_11).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你关闭汇编器评分对话框，Ghidra会根据当前处理器的SLEIGH规范构建所需的汇编器功能。在等待汇编器构建的过程中，Ghidra会显示类似于[图22-11](ch22.xhtml#fig22_11)所示的等待对话框。
- en: '![image](Images/fig22-11.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-11.jpg)'
- en: '*Figure 22-11: The Assemble wait dialog*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图22-11：汇编等待对话框*'
- en: Once your assembler has been built, Ghidra replaces the selected instruction
    in the Listing window with two text input boxes (see [Figure 22-12](ch22.xhtml#fig22_12))
    that allow you to edit the instruction’s mnemonic and operands. The ESC key discards
    your changes before they are assembled, while the ENTER key assembles your new
    instruction and replaces the old instruction’s machine code bytes with those of
    the new instruction.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的汇编器构建完成，Ghidra 会将列表窗口中选中的指令替换为两个文本输入框（见 [图 22-12](ch22.xhtml#fig22_12)），允许你编辑指令的助记符和操作数。按
    ESC 键会丢弃你的更改，在指令汇编之前，按 ENTER 键则会汇编新指令，并用新指令的机器码字节替换原指令的字节。
- en: '![image](Images/fig22-12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-12.jpg)'
- en: '*Figure 22-12: Assembling a new instruction*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-12：汇编新指令*'
- en: Because they derive from the same specification as the corresponding disassembler,
    Ghidra’s assemblers recognize the same assembly syntax used in the Ghidra Listing
    window. Ghidra’s assemblers are case sensitive and provide auto-completion options
    as you enter your new instructions. After you enter an instruction, Ghidra returns
    you to the normal Listing window view, and you can reselect Patch Instruction
    if there are additional instructions you want to modify. For short patches, Ghidra’s
    assembler offers a convenient way to simultaneously assemble your instructions
    and modify the program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们源自与对应反汇编器相同的规范，Ghidra 的汇编器识别 Ghidra 列表窗口中使用的相同汇编语法。Ghidra 的汇编器区分大小写，并且在输入新指令时提供自动补全选项。输入指令后，Ghidra
    会将你带回正常的列表窗口视图，如果有其他指令需要修改，你可以重新选择“Patch Instruction”。对于小型补丁，Ghidra 的汇编器提供了一种方便的方法，可以同时汇编指令并修改程序。
- en: '**Instruction Replacement Pitfalls**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指令替换陷阱**'
- en: While Ghidra’s assembler makes quick work of modifying a single instruction,
    the new replacement instruction can be shorter, longer, or the same size as the
    old instruction. The third case, in which the replacement and original instructions
    are the same size, is not interesting. (The first two problems can arise only
    on architectures without a fixed instruction size, such as x86.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Ghidra 的汇编器能迅速修改单个指令，但新的替换指令可能比原指令更短、更长，或者与原指令相同大小。第三种情况，即替换指令和原指令大小相同，并不有趣。（前两种问题仅会出现在没有固定指令大小的架构上，例如
    x86。）
- en: 'Consider the first case, in which your replacement instruction is shorter than
    the original instruction, as reflected in the following listing:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第一种情况，其中替换指令比原指令短，如下列表所示：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, a 4-byte `ADD` instruction ➊ is being replaced by a 2-byte `NOP`
    ➌. Ghidra’s assembler has done its best to fill the available space by inserting
    an x86 prefix byte (`66`) ➋ ahead of the x86 opcode for `NOP` (`90`). Unfortunately,
    the replacement instruction is still too short to account for the two remaining
    bytes ➍ of the original instruction, one of which translates to a `HLT` (use the
    hotkey D to disassemble it), and the other that Ghidra can’t disassemble, indicating
    that it does not represent a valid instruction. If you were to patch the original
    binary in this way and run it, it would almost certainly crash upon reaching this
    location.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个 4 字节的 `ADD` 指令 ➊ 被一个 2 字节的 `NOP` ➌ 替换。Ghidra 的汇编器尽力通过在 x86 `NOP` 操作码（`90`）前插入一个
    x86 前缀字节（`66`）➋ 来填充可用空间。不幸的是，替换指令仍然太短，无法完全填补原指令的剩余两个字节 ➍，其中一个转化为 `HLT`（按 D 键反汇编查看），另一个是
    Ghidra 无法反汇编的，表示它不是有效指令。如果你用这种方式修补原始二进制并运行，它几乎肯定会在到达该位置时崩溃。
- en: Ghidra provides no clues—other than the `??` characters that appear in the listing—that
    a problem may exist, as Ghidra does not understand your motivation for making
    this change and the “correct” solution depends on your particular use case. If
    you are modifying instructions within the listing without the intention to export,
    you could use Ghidra’s fallthrough override option from the right-click context
    menu to bypass the unneeded bytes.^([2](footnotes.xhtml#ch22fn2)) Alternatively,
    you can ask Ghidra to disassemble the undefined bytes, but it’s highly unlikely
    that they will disassemble into an instruction that you will find useful. The
    most common solution in this situation is to replace all excess bytes from the
    original instruction with `NOP`s ➎ to pad to the start of the next instruction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra除了列出中的`??`字符外，并不会提示可能存在的问题，因为Ghidra并不了解你做出此更改的动机，且“正确”的解决方案依赖于你特定的使用案例。如果你在不打算导出的情况下修改列表中的指令，你可以使用Ghidra的“穿透覆盖”选项（右键菜单中的选项）来绕过不需要的字节。^([2](footnotes.xhtml#ch22fn2))
    或者，你可以请求Ghidra反汇编未定义的字节，但它们不太可能被反汇编成你会发现有用的指令。在这种情况下，最常见的解决方案是用`NOP`指令替换掉原始指令中多余的字节
    ➎，并填充到下一个指令的起始位置。
- en: 'When your replacement instruction is longer than the original instruction,
    it introduces a new set of challenges, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的替换指令比原始指令更长时，它会引入一系列新的挑战，如下所示：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the goal of the patch is to read 256 (`0x100`) bytes rather than
    1 byte. The original, 2-byte `PUSH` instruction ➊ that places the third argument
    to `read` (the length argument) onto the stack is replaced by a 5-byte `PUSH`
    ➌ to push a larger constant. The additional bytes in the replacement instruction
    completely overwrite the instruction that was responsible for the second argument
    to `read` (the read buffer) ➋.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，补丁的目标是读取256（`0x100`）字节，而不是1字节。原始的2字节`PUSH`指令 ➊，将第三个参数（长度参数）推送到`read`函数的栈上，被一个5字节的`PUSH`指令
    ➌替换，以推送一个更大的常量。替换指令中的额外字节完全覆盖了负责`read`函数第二个参数（读取缓冲区） ➋的原始指令。
- en: The resulting code not only fails to provide `read` with enough arguments, but
    also passes an integer where a pointer is expected. As with the previous example,
    this will almost certainly cause the patched program to crash. Potential solutions
    to this particular patching problem are nontrivial and are discussed in the next
    section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果代码不仅无法为`read`提供足够的参数，还将一个整数传递给预期为指针的地方。与之前的例子一样，这几乎肯定会导致补丁程序崩溃。解决这个特定补丁问题的潜在方案并不简单，我们将在下一节中讨论。
- en: '#### ***Making Nontrivial Changes***'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***进行非平凡的修改***'
- en: The moment the size of your patch grows larger than the instruction(s) or data
    that you are replacing, your life gets more complicated. In most cases, this doesn’t
    mean that your patch will be impossible to implement, but considerably more thought
    and effort will be needed to implement the patch properly. In this section, we
    discuss several approaches for handling this “patch is too large” problem, based
    on whether the patch contains code or data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的补丁大小超过你要替换的指令或数据时，你的工作变得更加复杂。在大多数情况下，这并不意味着你的补丁无法实现，但需要更多的思考和努力来正确实现补丁。在本节中，我们将讨论几种处理“补丁过大”问题的方法，取决于补丁是包含代码还是数据。
- en: '**Oversized Code Patches**'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**超大代码补丁**'
- en: When your patch is too big to fit on top of the instructions you want to modify,
    you have no choice but to locate or create an unused region of sufficient size,
    patch your code into this empty region, and then insert a jump (known as a *hook*)
    at the original patch location to transfer control to your actual patch. In most
    cases, you will also need to append a jump to your replacement code to transfer
    control back to an appropriate location in the hooked function. [Figure 22-13](ch22.xhtml#fig22_13)
    shows the notional flow of a patched function with a jump hook installed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的补丁过大，无法直接覆盖你想要修改的指令时，你只能选择定位或创建一个足够大的未使用区域，将代码补丁放入这个空白区域，然后在原始补丁位置插入一个跳转（称为*钩子*）来将控制权转移到实际的补丁位置。在大多数情况下，你还需要在替换代码后追加一个跳转，以便将控制权转移回钩子函数中的适当位置。[图
    22-13](ch22.xhtml#fig22_13)展示了安装了跳转钩子的补丁函数的大致流程。
- en: '![image](Images/fig22-13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig22-13.jpg)'
- en: '*Figure 22-13: Function with installed patch*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 22-13：安装补丁的函数*'
- en: The available unused space for your oversized code patch must
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的未使用空间必须足够容纳你的超大代码补丁
- en: Be at least as large as your patch
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少要与补丁一样大
- en: Reside at an address that will be executable at runtime
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于运行时可执行的地址上
- en: Be initialized from file content; otherwise, your patch won’t get loaded at
    runtime
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件内容初始化；否则，您的补丁在运行时将无法加载。
- en: The easiest place to begin your search for large, unused, executable blocks
    of bytes is with any *code caves* that may be present in the binary. A code cave
    exists when an executable section in a binary, such as the `.text` section, is
    padded to adhere to section alignment requirements mandated by the executable
    file’s format. Code caves are very common in Windows PE binaries, as they frequently
    require every section of the binary to be a multiple of 512 bytes in size.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找大型未使用可执行字节块的最简单方法是检查二进制文件中可能存在的 *代码洞*。当二进制文件中的可执行部分（如 `.text` 部分）被填充以遵守可执行文件格式规定的部分对齐要求时，就会形成代码洞。代码洞在
    Windows PE 二进制文件中非常常见，因为它们通常要求每个部分的大小都是 512 字节的倍数。
- en: The first place to look for a code cave is usually the end of the `.text` section.
    You can easily navigate to the end of the `.text` section (or any other section)
    by double-clicking the section name in the CodeBrowser’s Program Trees window
    and then scrolling to the end of the Listing window.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找代码洞的第一个地方通常是 `.text` 部分的末尾。您可以通过在 CodeBrowser 的 Program Trees 窗口中双击该部分名称，然后滚动到
    Listing 窗口的末尾，轻松导航到 `.text` 部分的末尾（或任何其他部分）。
- en: 'In our sample PE binary, the Listing window shows the following at the end
    of the `.text` section:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例 PE 二进制文件中，Listing 窗口显示了 `.text` 部分末尾的以下内容：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The listing tells us the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显示了以下内容：
- en: The bytes are unclassified by Ghidra (`??`).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些字节在 Ghidra 中被标记为未分类（`??`）。
- en: The bytes are initialized to `00h`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些字节已初始化为 `00h`。
- en: The `.text` section ends at address `140012dff`, which satisfies the file alignment
    requirement that the section is a multiple of 512 bytes in size (`140012e00` is
    a multiple of `0x200`).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text` 部分结束于地址 `140012dff`，这满足文件对齐要求，即该部分的大小是 512 字节的倍数（`140012e00` 是 `0x200`
    的倍数）。'
- en: 'Navigating to the previous instruction by scrolling up (or choosing the I tool
    in the CodeBrowser with search direction set to Up), we arrive at the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向上滚动（或在 CodeBrowser 中选择 I 工具，并将搜索方向设置为“向上”），我们到达了以下位置：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `RET` ➊ is the last meaningful instruction in this particular binary, and
    we can now compute the size of this binary’s code cave as `0x140012e00 - 0x140012cbf
    = 0x141` (or 321 bytes). This means that we can easily patch as many as 321 bytes
    of new code into this binary. Assuming that we patched our new code in at address
    `0x140012cbf`, we would need to patch a jump to `0x140012cbf` somewhere in the
    binary’s existing code to ensure that execution flow eventually reaches our patch.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`RET` ➊ 是该二进制文件中最后一条有意义的指令，我们现在可以计算该二进制文件代码洞的大小为 `0x140012e00 - 0x140012cbf
    = 0x141`（或 321 字节）。这意味着我们可以轻松地将多达 321 字节的新代码补丁到该二进制文件中。假设我们在地址 `0x140012cbf` 打上新代码补丁，我们需要在二进制文件现有的代码中某个地方补上跳转到
    `0x140012cbf`，以确保执行流最终能够到达我们的补丁。'
- en: 'When a code cave can’t be found, or isn’t large enough to hold your patch,
    you will need to get a little creative in order to find enough space to fit your
    patch. Depending on the compiler options used to build the binary, you may be
    able to spread your patch across space gathered from *inter-function alignment
    gaps*. Inter-function alignment gaps exist when compilers choose to align the
    start of every function to an address that is a multiple of 2 (often 16). When
    function alignment is being forced, there will be an average of `align` / 2 bytes
    and as many as `align` – 1 bytes of padding inserted between each function in
    the binary. The following listing shows an optimal (from a patching perspective)
    alignment gap (`align` = 16) between two adjacent functions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当找不到代码洞或代码洞不够大以容纳您的补丁时，您需要发挥一些创造力，找到足够的空间来适应您的补丁。根据构建二进制文件时使用的编译选项，您可能能够通过 *函数间对齐间隙*
    来分散您的补丁。函数间对齐间隙是指编译器将每个函数的起始地址对齐到 2 的倍数（通常是 16）时所产生的间隙。当强制函数对齐时，每个函数之间将插入 `align`
    / 2 字节，最多插入 `align` - 1 字节的填充。以下列表显示了两个相邻函数之间的最佳（从补丁的角度来看）对齐间隙（`align` = 16）：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All of the bytes from `1400010a1` ➊ through `1400010af` ➋ may be safely overwritten
    with patch code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `1400010a1` ➊ 到 `1400010af` ➋ 的所有字节可以安全地用补丁代码覆盖。
- en: Additional methods exist for squeezing patch code into a binary—some involving
    expanding existing program sections or injecting entirely new ones. Any technique
    that manipulates sections in such a manner also requires you to update the binary’s
    section headers to make sure they remain consistent with any modifications that
    have been made. Accordingly, these techniques are very file-format specific and
    require a detailed understanding of file header data structures.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Oversized Data Patches**'
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Patching data is easier than patching code in some respects, and more difficult
    in others. For structured data types, your primary concerns are correct size and
    byte ordering of each member of the structure, and since the size of a structure
    is determined at compile time, you don’t need to worry about oversized replacement
    structures. When patching string data, it is recommended that any replacement
    data fit entirely within the footprint of the original string. If your new string
    is larger than the original string, you may be fortunate to find a few bytes of
    padding between the end of the string and the next data item, but you must be
    careful not to corrupt any data that the program depends upon. If your data simply
    does not fit into the memory footprint of the original data, you will be forced
    to find a new location for it, but moving data properly can be difficult.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: All global data items are referred to by their offsets from the program’s code
    or data sections. To relocate a data item, in addition to finding sufficient unused
    space, you’ll need to locate every reference to the original data item and patch
    it to refer to the new data item. Ghidra cross-references go a long way toward
    identifying every reference to a global, but will fail to identify derived pointers
    (pointers resulting from pointer arithmetic).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Once all of your patches have been entered in Ghidra and you’re happy with the
    resulting program listing, you’ll want to push your changes into the original
    binary to verify that your patches behave as expected.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '### **Exporting Files**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: To confirm that any of your changes will have the desired effect on the binary’s
    behavior, you’ll need to update the original binary to reflect your changes. In
    this section, we discuss some of Ghidra’s export features as they relate to patching.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra’s File ▸ Export Program menu option offers the capability to export a
    program’s information in any of several formats. The resulting Export dialog is
    shown in [Figure 22-14](ch22.xhtml#fig22_14).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-14.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-14: The Ghidra Export dialog*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The Export dialog is also accessible from the Project Manager by right-clicking
    the file you wish to export and selecting Export from the context menu. In the
    dialog, you are asked to specify the export format and the output file location,
    and to indicate whether you wish to limit the scope of your export to a range
    you have selected in the CodeBrowser. Some export formats offer additional options
    for more fine-grained control over the export process.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 导出对话框也可以通过在项目管理器中右键点击您希望导出的文件并从上下文菜单中选择“导出”来访问。在对话框中，您需要指定导出格式和输出文件位置，并指示是否希望将导出的范围限制为您在CodeBrowser中选择的范围。某些导出格式提供额外的选项，以便更细粒度地控制导出过程。
- en: '***Ghidra Export Formats***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Ghidra导出格式***'
- en: 'Ghidra supports the following export formats, though only one (binary) is particularly
    useful for binary patching:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 支持以下导出格式，尽管其中只有一个（二进制）对于二进制修补特别有用：
- en: '**Ascii** The Ascii export format can be used to save a textual representation
    of the program, similar to what is displayed in the Listing window, with options
    to choose which fields to include in the output file.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ascii** Ascii导出格式可用于保存程序的文本表示，类似于在Listing窗口中显示的内容，并提供选择要包含在输出文件中的字段的选项。'
- en: '**Binary** The Binary export format, which produces a binary file, is the most
    useful for patching applications and is discussed in its own section.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制** 二进制导出格式会生成一个二进制文件，是修补应用程序时最有用的格式，并且在其独立部分中进行了讨论。'
- en: '**C/C++** The C/C++ export format is used to save the Decompiler-generated
    source representation of the program along with declarations for all types known
    to the Data Type Manager. This option is also available from the Decompiler window.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**C/C++** C/C++导出格式用于保存反编译器生成的程序源代码表示，并包含所有已知数据类型的声明。此选项也可以从反编译器窗口中访问。'
- en: '**Ghidra Zip File** A Ghidra *zip* file is a serialized Java object representation
    of your program suitable for import into other Ghidra instances.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ghidra Zip 文件** Ghidra *zip*文件是程序的序列化Java对象表示，适用于导入到其他Ghidra实例中。'
- en: '**HTML** The HTML export format generates an HTML representation of the program
    listing. Options similar to those available in the Ascii exporter allow you to
    choose which fields to include in the output file. Labels and cross-references
    are represented as hyperlinks to provide a basic navigational capability throughout
    the generated output.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTML** HTML导出格式生成程序列表的HTML表示。与Ascii导出器中类似的选项使您可以选择要包含在输出文件中的字段。标签和交叉引用作为超链接表示，提供基本的导航功能，以便于在生成的输出中进行浏览。'
- en: '**Intel Hex** The Intel Hex format defines an ASCII representation for binary
    data, commonly used for programming EEPROM.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**Intel Hex** Intel Hex格式定义了一个二进制数据的ASCII表示，通常用于编程EEPROM。'
- en: '**XML** The XML exporter outputs the contents of the program in a structured
    XML format, with options to choose which program constructs should be included
    in the generated file. This functionality is also available for individual functions
    in the Decompiler window to facilitate debugging function decompilation. Although
    Ghidra includes a corresponding XML loader, this exporter includes the following
    warning: “Warning: XML is lossy and intended only for transferring data to external
    tools. GZF is the recommended format for saving and sharing program data.”'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**XML** XML导出器以结构化的XML格式输出程序内容，并提供选择应包含哪些程序构造在生成文件中的选项。此功能也可用于反编译器窗口中的单个函数，以便于调试函数反编译。尽管Ghidra包括相应的XML加载器，但该导出器包含以下警告：“警告：XML是有损的，仅用于将数据传输到外部工具。建议使用GZF格式来保存和共享程序数据。”'
- en: '***The Binary Export Format***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制导出格式***'
- en: Ghidra’s Binary export is used to write a program’s underlying binary content
    to a file. All of the program’s initialized memory blocks (see Window ▸ Memory
    Map) are concatenated to form the output file. Whether the output file is identical
    to the original file that was imported depends on the loader module used to import
    the file. The Raw Binary loader is guaranteed to re-create the original input
    file because it loads every byte of the original file into a single memory block.
    Other loaders may or may not load every file byte (for example, the PE loader
    does, while the ELF loader does not).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to apply any changes you have made with Ghidra, you need
    to ensure that the file you generate contains your patches and that it will execute.
    If you are patching a PE file, a Binary export will generate a patched version
    of the original binary. Similarly, if you imported your program using the Raw
    Binary loader, a Binary export will generate a patched version of the original
    binary. Of course, as discussed in [Chapter 17](ch17.xhtml#ch17), when using the
    Raw Binary loader, you may need to perform most of the memory layout for the program
    manually, so there is a trade-off. Fortunately, it’s possible to script up a solution
    that works with any loader.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '***Script-Assisted Export***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rather than performing an exhaustive test of every Ghidra loader to understand
    whether the memory blocks created by the loader span the entire range of file
    bytes, we can create a Ghidra script that will save a patched version of our program
    for us. This script provides a loader-agnostic capability for generating patched
    files with Ghidra. It will always process the entire range of original file bytes
    regardless of the current memory map layout known to Ghidra.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The script begins by obtaining the program’s list of `FileBytes` ➊. A `FileBytes`
    object encapsulates all of the bytes from the imported program file and tracks
    both the original and modified value of each byte in the file. As Ghidra allows
    you to import several files into a single program, this script processes only
    the bytes from the first file you imported into the program (first range of file
    bytes) ➋.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: After prompting for an output file ➌, the `FileBytes` object and open `OutputStream`
    are passed to our `writePatchFile` function to handle the finer details of generating
    the patched executable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: To present a mapped memory view of a program, Ghidra loaders may process a program’s
    relocation table entries in a manner similar to a runtime loader. The result of
    this processing is that program locations marked for fixup (locations that have
    relocation table entries) are modified by Ghidra from their original file values
    to proper relocated values. When we generate the patched version of the binary,
    we do not want to include any bytes that Ghidra has modified for relocation purposes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The `writePatchFile` function, shown next, begins by generating the set of
    addresses that are patched at runtime (and by Ghidra) in accordance with the program’s
    relocation table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After obtaining an iterator over the program’s relocation table ➊, the `AddressSourceInfo`
    for each relocation entry is obtained ➋.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'An `AddressSourceInfo` object provides a mapping of a program address to the
    disk file and the offset into that file from which the corresponding program byte
    was loaded. The file offset of each relocation byte is added to a set of offsets
    ➌ to be ignored when generating the final patched file. The function concludes
    by calling the `saveBytes` function ➍ to write the final patched version of the
    current program file. The `saveBytes` function is shown in the following listing:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function iterates over the entire range of file bytes ➊ to determine whether
    to save the original or modified byte to the output file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: At each file offset, methods of the `FileBytes` class are used to obtain the
    original byte value ➋, loaded from the imported file, and the current byte value
    ➌, which may have been modified by Ghidra or the Ghidra user. If the original
    value differs from the current value *and* the byte is not associated with a relocation
    entry, the modified byte is written to the output file ➍; otherwise, the original
    byte is written to the output file ➎.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up this section, let’s look at an example of patching a binary and confirming
    that the patch runs as we expect it to.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Example: Patching a Binary**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at an example that demonstrates patching in context. Assume that
    you have a piece of malware that checks for a debugger and, if one is present,
    exits without allowing you to examine its behavior. The following source code
    outlines that functionality in a trivial program:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code checks for a debugger ➊ and exits if it finds one. Otherwise, it goes
    about its nefarious business. The following shows the output of the program running
    alone (without a debugger):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the program runs under a debugger, we see a different response:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we load the binary into Ghidra, we see the following in the Listing window:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Decompiler window provides the following corresponding code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To patch this binary to bypass the check, you could `NOP` the call to the `is_debugger_present`
    function, change the test condition, or change the contents of the `is_debugger_present`
    function. If you use the Patch Instruction option from the right-click context
    menu, it is easy to replace the `JZ` with a `JNZ` (effectively flipping the condition
    to run only if it is being debugged), as shown in [Figure 22-15](ch22.xhtml#fig22_15).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig22-15.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: '*Figure 22-15: Patch Instruction option after replacing* `JZ` *with* `JNZ`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'This would result in the following code in the Decompiler window:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we then export the file as a binary using our export script and run it again,
    we see the following two listings, which demonstrate the behavior we were hoping
    to accomplish with our patch:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用导出脚本将文件导出为二进制并重新运行它，我们会看到以下两个列表，这些列表展示了我们希望通过补丁实现的行为：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: While there are many external tools (for example, `VBinDiff`) available to confirm
    that only 1 byte was changed within the file for this example, you can also use
    Ghidra's internal tools to reach the same conclusion. The next chapter focuses
    on methods to accomplish this goal.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多外部工具（例如，`VBinDiff`）可以用来确认在这个示例中文件仅改变了 1 个字节，但你也可以使用 Ghidra 的内部工具来得出相同的结论。下一章将重点介绍实现这一目标的方法。
- en: '**Summary**'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Regardless of your particular motivation for patching a binary, your patch will
    require careful planning and deployment. Ghidra provides everything you need to
    plan your patch; to draft your patch using hex editing, Ghidra’s built-in assembler,
    or scripting; to view the effects of each change; and to possibly revert changes
    using Undo before generating a patch version of your original binary. The next
    chapter demonstrates how you can use Ghidra to compare the unpatched and patched
    versions of your binaries as well as discusses Ghidra’s capabilities for more
    advanced binary differencing and version tracking.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你补丁二进制文件的具体动机是什么，你的补丁都需要仔细规划和部署。Ghidra 提供了你所需要的一切来规划补丁；通过十六进制编辑、Ghidra 内置的汇编器或脚本来草拟补丁；查看每次更改的效果；以及在生成原始二进制补丁版本之前，可能通过撤销操作来还原更改。下一章将演示如何使用
    Ghidra 比较未打补丁和已打补丁的二进制文件版本，并讨论 Ghidra 在更高级的二进制差异比较和版本跟踪方面的功能。
