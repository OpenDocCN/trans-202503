- en: '**6**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DECIPHERING SECRET MESSAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/circle.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ve probably sent secret, encoded notes to your friends to try to hide the
    messages from your parents or teachers. In this chapter, we’ll be doing something
    similar as we create a Secret Messages app.
  prefs: []
  type: TYPE_NORMAL
- en: Our previous app, the Hi-Lo guessing game, was all about numbers—too high, too
    low, or just right. By contrast, our Secret Messages app will focus on text. You’ll
    learn to work with text strings and manipulate character values in Java to produce
    the encoded messages.
  prefs: []
  type: TYPE_NORMAL
- en: The Caesar Cipher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app will encode and decode secret messages using the *Caesar cipher*, an
    algorithm developed more than 2,000 years ago that uses letter substitutions to
    encode messages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0126-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: A Caesar cipher disk, showing a key value of 13*'
  prefs: []
  type: TYPE_NORMAL
- en: The Caesar cipher is named for the  Roman emperor Julius Caesar (100–44 BCE).
    Historians say Caesar liked to encode his private messages, such as notes to his
    military generals, by “shifting” the letters of the alphabet. For example, the
    cipher disk shown in [Figure 6-1](ch6.xhtml#ch6fig1) shifts the alphabet by 13
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the disk, the outer letters align with the inner letters they should be
    substituted with, so an *A* becomes an *N*, a *B* becomes an *O*, and so on. This
    is the cipher that created the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Secret messages are so cool!
  prefs: []
  type: TYPE_NORMAL
- en: Frperg zrffntrf ner fb pbby!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line is the *plaintext*: the original, readable version of the message.
    The second line is the *ciphertext*, the encoded version of the same message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try decoding this message back to its original plaintext by reversing the substitution:
    find each inner letter and substitute it with the corresponding outer letter.'
  prefs: []
  type: TYPE_NORMAL
- en: Not all Caesar ciphers are symmetric like this one. *Symmetric* means that the
    same process can be used for both encoding and decoding a message. For example,
    *F* becomes *S* when encoding by adding 13, and *S* becomes *F* when decoding
    by subtracting 13, and you can use the same disk and *key*—the number used to
    shift the letters—for both processes. The number to shift the letters by (in this
    case 13) is called a key because knowing it “unlocks” the cipher. The Secret Messages
    app we’ll build will allow us to use any key value.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Secret Messages App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll build the Secret Messages app just like we did the Hi-Lo guessing game:
    first, we’ll create a command line version, then a GUI for the desktop, and, finally,
    an Android mobile app. The command line version will look fairly simple, as shown
    in [Figure 6-2](ch6.xhtml#ch6fig2), but it will allow us to test the secret message
    algorithm quickly and easily.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0126-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: The command line version of the Secret Messages app*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 6-2](ch6.xhtml#ch6fig2), the program asks the user
    to enter a message to encode or decode, followed by a secret key value. The program
    then responds with the encoded message. Note that when we start coding the app,
    the entire message will be encoded, including spaces and punctuation. In the final
    version, we’ll add some logic to encode only letters, as shown in [Figure 6-2](ch6.xhtml#ch6fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating the Secret Messages Project in Eclipse*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s begin by opening Eclipse. If you still have files open from previous projects,
    close those files now. To create a new Java Project, go to **File** ▸ **New**
    ▸ **Java Project** and name the project *SecretMessages*. Click **Finish**.
  prefs: []
  type: TYPE_NORMAL
- en: In the Package Explorer pane, expand the *SecretMessages* project folder to
    see the *src* folder. Right-click the *src* folder and go to **New** ▸ **Class**
    to create a new Java source code file, which you’ll also name *SecretMessages*.
    Select the checkbox to create a `main()` method, as shown in [Figure 6-3](ch6.xhtml#ch6fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0127-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: Create a new Java project, with a new class file called* SecretMessages,
    *and select the checkbox to create a main() method stub.*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Finish**, and you’ll see the *SecretMessages.java* file in the main
    window in Eclipse. Let’s get started coding the Secret Messages app!
  prefs: []
  type: TYPE_NORMAL
- en: '*Beginning to Code SecretMessages.java*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the top of the *SecretMessages.java* file, above the `public class SecretMessages`
    declaration, add the `import` statement for `java.util.Scanner` so we can ask
    the user for input:'
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.Scanner;
  prefs: []
  type: TYPE_NORMAL
- en: public class SecretMessages {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: ➊ Scanner scan = new Scanner(System.in);
  prefs: []
  type: TYPE_NORMAL
- en: ➋ System.out.println("Enter a message to encode or decode:");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main()` method, at ➊, we set up a `Scanner` object named `scan`.
    Then, at ➋, we prompt the user to enter a message to encode or decode.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the user prompt, we’ll create a `String` variable, called `message`,
    to accept the line of text the user enters:'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Enter a message to encode or decode:");
  prefs: []
  type: TYPE_NORMAL
- en: String message = scan.nextLine();
  prefs: []
  type: TYPE_NORMAL
- en: Then, we get the user’s next full line of input, up to an ENTER or RETURN character,
    using the `nextLine()` method of the `scan` object, and we store it in the string
    `message`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the app can ask the user for a message and scan that message into a
    variable. Now we need to learn how to manipulate the characters inside a string
    to create an encoded version of the message. Save your file before continuing
    to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '*Messing with Strings*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Up to this point, the Secret Messages app looks pretty similar to the Hi-Lo
    guessing game app. We set up an input scanner, prompt the user for some input,
    scan the console for the user’s response, and then capture the input in a variable.
    What’s going to make the Secret Messages app different is its ability to work
    with the characters inside the string.
  prefs: []
  type: TYPE_NORMAL
- en: The Caesar cipher command line app will take a lot of steps to complete, so
    we’ll build our app in *iterations*. That means that instead of writing out the
    whole app all at once and hoping the code works in the end, we’ll create our app
    bit by bit, or one iteration at a time, and test it as we go along so that we’ll
    have a functioning app at each point. Each iteration might not have all the features
    we need, but we’ll eventually get to the complete, full-featured app.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll need to use text processing to manipulate the inputted string into an
    output string. To begin working with strings of text in Java, we’ll build a simple
    message reverser. In other words, we’ll take the message the user entered and
    then give it back to them with the letters in reverse order. So, for example,
    `"Meet me at the arcade at 5pm"` would become `"mp5 ta edacra eht ta em teeM"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a variable called `output` for the reversed string and set
    it equal to an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: String message = scan.nextLine();
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need a loop to run through the characters in the message. We can choose
    a `for` loop for convenience, because we know the number of characters in the
    message. (Later, we’ll use the `message.length()` method to tell us how many characters
    the message contains.) A `for` loop declaration in Java needs to do three things:
    *initialize* a loop variable, test a *condition* to keep going, and *update* the
    loop variable before the next iteration. We place semicolons between each of the
    three parts to separate them. The syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: for ( initialization; condition; update ) { body }
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, open JShell and enter this code to create a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: jshell> for ( int x = 0; x < 10; x++ ) { System.out.println(x); }
  prefs: []
  type: TYPE_NORMAL
- en: This loop will print the numbers `0` through `9`. The initialization sets the
    first looping variable `x` to `0`. The condition tests to make sure `x` is less
    than `10` before proceeding. Finally, the update adds 1 to `x` after each pass
    through the loop. `x++` uses a shortcut called the *increment operator* because
    it increments, or adds 1 to, `x` each time through the loop. `x++` is equivalent
    to the statement `x = x` `+` `1`. In this example, the `for` loop prints the value
    of `x` each time through the loop, repeating 10 times and stopping when `x` is
    no longer less than `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to reverse the characters in the message string, we might initialize a
    variable to the position number, or *index*, of the last character in the string
    and then loop through the characters from last to first (in reverse order), going
    backward through the string. In our example, this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = message.length()-1; x >= 0; x-- ) { }
  prefs: []
  type: TYPE_NORMAL
- en: The character positions in a string in Java are numbered from `0` (the index
    of the first character) to the length minus 1\. The first character is at index
    `0`, and the *n*th character in a string is at index (*n* − 1).
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-4](ch6.xhtml#ch6fig4), the first 10 characters of our sample message
    are shown. The index of each character in the string is shown below the character.
    The first letter, `M`, is at index `0`, the first `e` is at index `1`, and so
    on. Notice that spaces count as characters—there are two spaces shown here, at
    indexes `4` and `7`. The 10th character in the message is at index `9`, the letter
    `t`. This continues all the way to the last character in the message, at index
    `message.length()-1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0129-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: The characters in a message labeled with their indexes*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to start our reversed message at the end of the string, so we initialize
    `x` to the `message.length()-1`, the index of the last character in the message.
    The condition is `x >=` `0` because we want to keep going all the way down to
    the first character of the message, at index `0`. Finally, the update is `x--`
    because we’re stepping backward through the string. The opposite of `x++`, `x--`
    uses the *decrement operator*, which decreases the value of `x` by 1 each time.
    Come back into Eclipse and begin writing the `for` loop just below the previous
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = message.length()-1; x >= 0; x-- ) {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the character at a specific position in a string, we use the `charAt()`
    (“character at”) method and give it the index location of the character we want.
    To append or add a character to a string, we use the `+` operator. Putting those
    together, we can build the reverse version of the string `message` and store it
    in the string `output`:'
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = message.length()-1; x >= 0; x-- ) {
  prefs: []
  type: TYPE_NORMAL
- en: output += message.charAt(x);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The body of the `for` loop is a single line. We’re getting the character at
    the `x`th index of `message` and adding it to `output`. Remember to use open and
    close braces around the body of the `for` loop, because we’ll want to add more
    lines inside the loop as the app grows.
  prefs: []
  type: TYPE_NORMAL
- en: Now we just need to show the output message to the screen, which we can do with
    `System.out.println(output)`. The full message-reversing iteration of the app
    is shown in [Listing 6-1](ch6.xhtml#ch6list1).
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.Scanner;
  prefs: []
  type: TYPE_NORMAL
- en: public class SecretMessages {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: Scanner scan = new Scanner(System.*in*);
  prefs: []
  type: TYPE_NORMAL
- en: System.*out*.println("Enter a message to encode or decode:");
  prefs: []
  type: TYPE_NORMAL
- en: String message = scan.nextLine();
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = message.length()-1; x >= 0; x-- ) {
  prefs: []
  type: TYPE_NORMAL
- en: output += message.charAt(x);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.*out*.println(output);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-1: The first iteration of the Secret Messages app reverses the characters
    in the user’s message.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can run the program in Eclipse and test it with your own message, as shown
    in [Figure 6-5](ch6.xhtml#ch6fig5). This isn’t our finished Secret Messages app,
    but it does make the message harder to read and easy to decode.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0131-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: Run the program and enter your own message to reverse in the console
    window at the bottom of the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: You can even decode a message by copying the encoded, reversed message and pasting
    it into the program, as shown in [Figure 6-6](ch6.xhtml#ch6fig6). So you can type
    a message, encode it, and paste it into a message to a friend, and then they can
    decode it by pasting the encoded message into the same program. You’ve built your
    first secret message encoder!
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0131-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Copy and paste an encoded message into the running program to
    decode it.*'
  prefs: []
  type: TYPE_NORMAL
- en: This version of the app is simple enough that you can read the messages without
    running them through the program, so it’s not a very secure way to send messages
    to your friends. But you did learn how to loop through a string of text using
    a `for` loop, how to get the string’s `length()`, how to access a specific character
    at a given index or position in the string using `charAt()`, and how to add characters
    to the end of a string using the `+` operator. In the next section, you’ll learn
    how to change the values of the individual characters in the message to make it
    harder to read, but still easy for our program to decode.
  prefs: []
  type: TYPE_NORMAL
- en: Characters and Values in Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building a better secret message encoder requires the ability to work with character
    values in strings of text. For the Caesar cipher, we need to be able to shift
    those values—for example, changing an *A* to an *N*, and an *N* to an *A*. To
    do this, you need to understand how characters are stored in a computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, individual characters, such as `''A''`, can be stored in their own
    data type: `char`. Notice that we use single quotation marks to contain character
    values. The `charAt()` method of a string returns a `char` value representing
    a single character. Java uses 16-bit Unicode characters. *Unicode* is an international
    character set containing thousands of characters and symbols from all over the
    world that are represented as numeric values. The `char` type is a way to store
    Unicode characters, such as `''A''`, `''ñ''`, and `''ç''`, by their numeric values.'
  prefs: []
  type: TYPE_NORMAL
- en: We can add to a Unicode `char` value in the same way we can add to an `int`
    variable. With the Secret Messages app, we want to add the `char` value for `'A'`
    (`65`) to the key (`13`) to get the new `char` value (`78`), which represents
    the encoded letter (`'N'`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our second iteration of the app, let’s begin coding the Caesar cipher by
    setting up a `char` variable called `key` and storing the value `13` in it. We’ll
    add this below the `String output` line:'
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: char key = 13;
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to modify the `for` loop to go from the beginning of the string
    to the end. We’re starting at index `0` this time and moving through the string
    while `x` is less than `message.length()`. Each time we repeat the loop, we’re
    adding 1 to `x`, the character position. Here is the new `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: char key = 13;
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, instead of adding the original characters of the `message` string
    to the `output` string, we need to add the key value to each character, making
    sure we get a `char` value that we can add to the output string:'
  prefs: []
  type: TYPE_NORMAL
- en: output += (char)(message.charAt(x) + key);
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added the key value to each character in the `message` string, and then
    we’ve taken that sum and cast it to a `char`. Putting `char` in parentheses before
    an expression forces the value to its right to fit into a `char` data type, or
    *casts* the value to that type. We have to cast the output value to `(char)` here
    because in Java, the right side of this equation may result in an `int` value
    by default. [Listing 6-2](ch6.xhtml#ch6list2) shows the program with these changes.
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.Scanner;
  prefs: []
  type: TYPE_NORMAL
- en: public class SecretMessages {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: Scanner scan = new Scanner(System.in);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Enter a message to encode or decode:");
  prefs: []
  type: TYPE_NORMAL
- en: String message = scan.nextLine();
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: char key = 13;
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  prefs: []
  type: TYPE_NORMAL
- en: output += (char)(message.charAt(x) + key);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(output);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-2: The Secret Messages app is still short at just 14 lines, but
    it encodes strings of text now!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the program at this point and enter a message, you should see output
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: Secret messages are so cool!
  prefs: []
  type: TYPE_NORMAL
- en: '`rp□r?-zr??ntr?-n□r-?|-p||y.'
  prefs: []
  type: TYPE_NORMAL
- en: The message is encoded, but it’s not quite what we were expecting. First of
    all, we’re encoding all characters, including spaces and punctuation marks. Second,
    we’re not wrapping around to the front of the alphabet yet, because we’re *always*
    adding 13 to every character, not taking into account the fact that the letters
    at the end need to wrap back around to the beginning of the alphabet, resulting
    in odd symbols and unprintable characters in the output message. We’ll cover both
    of these issues in the next section. Before moving on, save your program.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding Just the Letters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our second iteration of the Secret Messages app gave us an encoded message,
    but it lacks some features that we want in the final app. The upgrades needed
    to create the final app will require some logic in the form of `if` statements
    and conditions to encode only letters (not spaces or punctuation) and to make
    the alphabet wrap around during encoding. We’ll tackle these improvements in our
    third iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to perform some tests on each character in the input message
    instead of just adding the character directly to the output message. Let’s change
    the body of the `for` loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  prefs: []
  type: TYPE_NORMAL
- en: char input = message.charAt(x);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The character stored in `input` will be the first character in `message`, then
    the second, and so on. We need to test each character one by one to check whether
    it’s a character that we want to encode. We want to encode letters by adding the
    key value to them and wrapping to the front of the alphabet if necessary. Otherwise,
    if the character is a space or punctuation, we’ll leave the character unchanged
    and add it to the output message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the following `if` statement in the body of our `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: char input = message.charAt(x);
  prefs: []
  type: TYPE_NORMAL
- en: if (input >= 'A' && input <= 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: In the condition inside the `if` statement, we can use either `65` (the value
    of `'A'`) or the character literal `'A'` itself. The condition tests whether the
    character stored in `input` is greater than or equal to `'A'` and less than or
    equal to `'Z'`—in other words, whether `input` contains an uppercase letter. If
    this condition is `true`, we want to add the key value to `input` to shift it,
    producing the Caesar cipher value to substitute for that letter. Notice that this
    is only for uppercase letters—lowercase letters will require a separate test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the body of the `if` statement, we’ll add the key value to the `input`
    character to encode the letter. This is also where we’ll handle wrapping around
    to the front of the alphabet if the key value shifts a letter past `''Z''`. So
    the code inside the `for` loop will become:'
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  prefs: []
  type: TYPE_NORMAL
- en: char input = message.charAt(x);
  prefs: []
  type: TYPE_NORMAL
- en: if (input >= 'A' && input <= 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ input += key;
  prefs: []
  type: TYPE_NORMAL
- en: ➋ if (input > 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: ➌ input -= 26;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ output += input;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: After getting the next character from the message and checking to make sure
    it’s an uppercase letter, we encode the letter by adding the key to it ➊. Then,
    we check whether adding the key value pushed the letter past `Z` ➋. If so, at
    ➌ we subtract `26` (the number of letters in the English alphabet) from the encoded
    `input` value to wrap it back around to the front of the alphabet. Finally, we
    can add the resulting `input` character to the `output` string ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the program now, you can encode an all-uppercase message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: SECRET MESSAGES ARE SO COOL!
  prefs: []
  type: TYPE_NORMAL
- en: FRPERG  ZRFFNTRF  NER FB  PBBY!
  prefs: []
  type: TYPE_NORMAL
- en: Notice the punctuation and spaces stay the same, and all uppercase letters are
    shifted by 13 characters, wrapping around so that `S` becomes `F`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding the lowercase letters is logically identical to handling the uppercase
    letters. You can copy and paste the same `if` statement code, but change the `A`
    and `Z` to lowercase letters. Don’t forget to add an `else` before the second
    `if` statement. Try it yourself; but if you get stuck, the complete code is provided
    in [Listing 6-3](ch6.xhtml#ch6list3) in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**ENCODING MESSAGES IN OTHER LANGUAGES**'
  prefs: []
  type: TYPE_NORMAL
- en: The version of the program we’re writing will only work consistently for basic
    Latin characters from *A* to *Z* and *a* to *z*. If your preferred language is
    not English, however, you can adjust the program as long as Unicode has the alphabet
    or symbols of your language grouped together in a contiguous set, one after the
    other. You can test for the first and last character of your preferred language
    just like the English encoder/decoder in this chapter. If your language either
    isn’t provided in a complete set or uses some of the basic Latin alphabet plus
    certain other characters (like how Spanish uses the ñ and French uses the ç, along
    with other accented characters), you could add the key to any character as we
    did in [Listing 6-2](ch6.xhtml#ch6list2). Optionally, you could leave spaces in
    the message by testing with the `Character.isSpace()` method and encode everything
    except spaces. Play with different methods for the alphabet or language of your
    choice to find the encoding scheme that works best for you. Change the program
    and make it do something new—that’s the best way to learn!
  prefs: []
  type: TYPE_NORMAL
- en: Closing the Scanner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s one touch we can add here that you may recall from [Chapter 2](ch2.xhtml#ch2).
    The `Scanner` variable `scan` should have a yellow underline, indicating a warning
    in Eclipse telling you there is a resource leak. When you hover your mouse over
    the warning, it pops up with the message `''scan'' is never closed`. Remember
    that we need to close all input/output resources, such as `Scanner` objects, when
    we’re finished using them. To do so, we’ll add the command `scan.close()` right
    after the final `System.out.println` in the `main()` method of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(output);
  prefs: []
  type: TYPE_NORMAL
- en: scan.close();
  prefs: []
  type: TYPE_NORMAL
- en: Adding this line removes the resource leak warning. See [Listing 6-3](ch6.xhtml#ch6list3)
    for a fully functional Caesar cipher encoder and decoder with a key value of `13`.
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.Scanner;
  prefs: []
  type: TYPE_NORMAL
- en: public class SecretMessages {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: Scanner scan = new Scanner(System.*in*);
  prefs: []
  type: TYPE_NORMAL
- en: System.*out*.println("Enter a message to encode or decode:");
  prefs: []
  type: TYPE_NORMAL
- en: String message = scan.nextLine();
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: char key = 13;
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  prefs: []
  type: TYPE_NORMAL
- en: char input = message.charAt(x);
  prefs: []
  type: TYPE_NORMAL
- en: if (input >= 'A' && input <= 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= 'a' && input <= 'z')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'z')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: output += input;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.*out*.println(output);
  prefs: []
  type: TYPE_NORMAL
- en: scan.close();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-3: This version of the app is a fully functional Caesar cipher encoder
    and decoder with a key value of 13*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it out by first running the program and encoding a message. Then copy the
    encoded output and run the program again; when prompted, paste the encoded message
    and press ENTER. The program will respond with the original, decoded message.
    Here are two sample runs of the program in which I’ve copied the encoded output
    from the first message to use as the input for the second run:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: Secret messages are so cool!
  prefs: []
  type: TYPE_NORMAL
- en: Frperg zrffntrf ner fb pbby!
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: Frperg zrffntrf ner fb pbby!
  prefs: []
  type: TYPE_NORMAL
- en: Secret messages are so cool!
  prefs: []
  type: TYPE_NORMAL
- en: Because the Caesar cipher is symmetric, running the program on an encoded message
    decodes the message back to its original plaintext. This means you can run this
    program as it’s written in [Listing 6-3](ch6.xhtml#ch6list3) to encode a message,
    send the encoded version to a friend who also has the encoder program, and have
    them decode your message instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this means *anyone* running the program (or anyone who figures
    out the cipher) can decode your messages just as quickly as you can. For our next
    iteration, let’s make the code a little more interesting by allowing the user
    to set their own key value. Then, you can pick a different key to send messages
    to different people, or you can use a new key every time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Custom Key Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The secret message encoder works well with a key value of `13`, but what if
    we want to encode and decode messages using a different key value, such as `3`
    (the classical Caesar cipher shift) or `5` or `25`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need to prompt the user for a key value in addition to the message. We
    can do that by adding a prompt before the line that creates the `char` key variable:'
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Enter a secret key (-25 to 25):");
  prefs: []
  type: TYPE_NORMAL
- en: char key = 13;
  prefs: []
  type: TYPE_NORMAL
- en: We’re allowing negative key values as a convenience for decoding messages. If
    you use a key value of `5` to encode your message and send it to a friend, your
    friend can use a key value of `-5` to decode the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user responds with their desired secret key value, we can scan the
    line of input they provide, parse the integer value out of the line of input,
    and store the value in an `int` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Enter a secret key (-25 to 25):");
  prefs: []
  type: TYPE_NORMAL
- en: int keyVal = Integer.parseInt(scan.nextLine());
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, instead of using `13` as the `key` variable, we’ll change the variable
    key to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: int keyVal = Integer.parseInt(scan.nextLine());
  prefs: []
  type: TYPE_NORMAL
- en: char key = (char) keyVal;
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’re casting the `keyVal` entered to a `char` and storing that value
    in the variable `key`, since we can’t store an integer directly into a `char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle negative key values for the decoding process, we’ll need to make
    a change to the logic inside the `if` statements. We have to check whether *subtracting*
    a value (or adding a negative key) would shift the letter past the beginning of
    the alphabet (or less than `''A''`). If that happens, we can shift the letter
    back into the range from `A` to `Z` by *adding* `26`. Add the following code to
    the `if` statement for uppercase letters:'
  prefs: []
  type: TYPE_NORMAL
- en: if (input >= 'A' && input <= 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'A')
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: If we input a negative `key`, we check whether we shifted before `A` and add
    `26` to wrap back around to the end of the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to do the same for the lowercase logic inside the `else-if` statement
    that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= 'a' && input <= 'z')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'z')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'a')
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'After these changes, you’ll be able to run the program to encode and decode
    messages with your own, custom key. Your program should work like the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: You've written a really cool app in Java!
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a secret key (-25 to 25):'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: Fvb'cl dypaalu h ylhssf jvvs hww pu Qhch!
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: Fvb'cl dypaalu h ylhssf jvvs hww pu Qhch!
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a secret key (-25 to 25):'
  prefs: []
  type: TYPE_NORMAL
- en: '-7'
  prefs: []
  type: TYPE_NORMAL
- en: You've written a really cool app in Java!
  prefs: []
  type: TYPE_NORMAL
- en: The first time we ran the program, we used a key of `7`. So, to decode the secret
    message, we ran the program again with the key value `-7`, revealing the original
    plaintext message.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Encoding Digits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have encoded letters, but if we encode a message like the following,
    any digits remain unencoded, in their original plaintext:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: Meet me at the arcade at 5pm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a secret key (-25 to 25):'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: Ummb um ib bpm izkilm ib 5xu.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `5` in `5pm` remains a `5` in the output message. If we want to encode
    numbers as well as letters, we need to add one more section of logic to the `for`
    loop. We’ll need to check whether a character falls between `0` and `9` and then
    encode that character as a different digit. We’ll also have to remember to wrap
    back around to the front or back of the set of 10 digits. We’ll have to handle
    this differently from wrapping around in the set of 26 letters since we’re dealing
    with numbers now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add another `else-if` statement right after the `else-if` that
    handles lowercase letters:'
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= 'a' && input <= 'z')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'z')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'a')
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= '0' && input <= '9')
  prefs: []
  type: TYPE_NORMAL
- en: output += input;
  prefs: []
  type: TYPE_NORMAL
- en: This part looks similar to the previous two `if` conditions, except that we’re
    using the digits `'0'` through `'9'`, instead of the letters `'A'` to `'Z'`, as
    the range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line, inside the brace for the `if` statement, looks a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= '0' && input <= '9')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += (keyVal % 10);
  prefs: []
  type: TYPE_NORMAL
- en: First, we’re using the *integer* version of the secret key, `keyVal`, which
    the user entered earlier in the program. Second, we’ve used the modulo operator
    (`%`) to keep the shift value for digits between `-10` and `+10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to test whether adding the `keyVal` pushed a digit past `9` or
    before `0`, just as we checked whether encoding a letter pushed it past `Z` or
    before `A`. But, instead of subtracting `26` to wrap back around to the beginning
    of the alphabet, we need to subtract `10` to keep a digit between `0` and `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= '0' && input <= '9')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += (keyVal % 10);
  prefs: []
  type: TYPE_NORMAL
- en: if (input > '9')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 10;
  prefs: []
  type: TYPE_NORMAL
- en: if (input < '0')
  prefs: []
  type: TYPE_NORMAL
- en: input += 10;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: output += input;
  prefs: []
  type: TYPE_NORMAL
- en: If encoding a digit pushes it past `9`, we subtract `10`. And, if decoding moves
    a digit below `0`, we add `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can encode both numbers and letters in the messages we send:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: Meet me at the arcade at 5pm and bring $2 to play Pac-Man :)
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a secret key (-25 to 25):'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: Tlla tl ha aol hyjhkl ha 2wt huk iypun $9 av wshf Whj-Thu :)
  prefs: []
  type: TYPE_NORMAL
- en: The `5` in `5pm` is correctly shifted by seven and wraps back around to `2wt`
    in the encoded message. The `2` in `$2` is shifted by seven to `$9`. You can test
    the preceding secret message by decoding it with a key of `-7`, and you should
    get the original plaintext message back, including the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The full, final text-based version of the Secret Messages app is given in [Listing
    6-4](ch6.xhtml#ch6list4).
  prefs: []
  type: TYPE_NORMAL
- en: import java.util.Scanner;
  prefs: []
  type: TYPE_NORMAL
- en: public class SecretMessages {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: Scanner scan = new Scanner(System.in);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Enter a message to encode or decode:");
  prefs: []
  type: TYPE_NORMAL
- en: String message = scan.nextLine();
  prefs: []
  type: TYPE_NORMAL
- en: String output = "";
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Enter a secret key (-25 to 25):");
  prefs: []
  type: TYPE_NORMAL
- en: int keyVal = Integer.parseInt(scan.nextLine());
  prefs: []
  type: TYPE_NORMAL
- en: char key = (char) keyVal;
  prefs: []
  type: TYPE_NORMAL
- en: for ( int x = 0; x < message.length(); x++ ) {
  prefs: []
  type: TYPE_NORMAL
- en: char input = message.charAt(x);
  prefs: []
  type: TYPE_NORMAL
- en: if (input >= 'A' && input <= 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'Z')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'A')
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= 'a' && input <= 'z')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += key;
  prefs: []
  type: TYPE_NORMAL
- en: if (input > 'z')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 26;
  prefs: []
  type: TYPE_NORMAL
- en: if (input < 'a')
  prefs: []
  type: TYPE_NORMAL
- en: input += 26;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else if (input >= '0' && input <= '9')
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: input += (keyVal % 10);
  prefs: []
  type: TYPE_NORMAL
- en: if (input > '9')
  prefs: []
  type: TYPE_NORMAL
- en: input -= 10;
  prefs: []
  type: TYPE_NORMAL
- en: if (input < '0')
  prefs: []
  type: TYPE_NORMAL
- en: input += 10;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: output += input;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.*out*.println(output);
  prefs: []
  type: TYPE_NORMAL
- en: scan.close();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-4: The finished command line version of the Secret Messages app*'
  prefs: []
  type: TYPE_NORMAL
- en: This Secret Messages app can be a fun way to share scrambled messages back and
    forth with friends. But some of your friends may not have Eclipse or the Java
    JDK installed on their computer. Wouldn’t it be nice to be able to share the Secret
    Messages app with them too? In the next section, we’ll see how to run a command
    line Java app without opening Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: Running Command Line Apps Without Eclipse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve built two command line apps so far, but we’ve always run them from inside
    Eclipse. Eclipse provides a convenient console emulator to let us see how a command
    line app would look and feel, but what if we wanted to run the app from an actual
    command line, such as the Command Prompt in Windows or the Terminal on macOS?
    Or what if we wanted to send one of our command line apps to a friend who doesn’t
    have Eclipse installed on their computer?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, most people have at least the JRE, or Java Runtime Environment,
    installed on their computers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Finding Your Workspace Folders*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To run the app you’ve written and compiled in Eclipse, first start by finding
    your Eclipse *workspace* folder. Open it in File Explorer (or Finder), as shown
    in [Figure 6-7](ch6.xhtml#ch6fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0141-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: My* workspace *folder has folders inside it for each of the projects
    we’ve built so far, plus some Eclipse default folders.*'
  prefs: []
  type: TYPE_NORMAL
- en: Open the *SecretMessages* project folder inside your workspace, and you’ll see
    a few files and folders inside it, as shown in [Figure 6-8](ch6.xhtml#ch6fig8).
    The *src* folder has your source code files (ending in *.java*), and the *bin*
    folder has the compiled version of your app (ending in *.class*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0142-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: Find the* bin *folder inside the* SecretMessages *project folder.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Opening a Command Line Window*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, open a command line window. On Windows, you can do this by pressing the
    **Start** button, going to the search bar, and typing `cmd` (short for *command*)
    and pressing ENTER. On macOS, use the Spotlight search bar to find Terminal, or
    from a new Finder window, go to **Applications** ▸ **Utilities** ▸ **Terminal**.
    On Linux, open the Terminal application or use Search to find Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: We need to browse into the *bin* folder described earlier from the command line
    or Terminal prompt. Type `cd` (“change directory”) followed by a space in your
    terminal window. Then, to change directories into the *bin* folder for your app,
    drag the *bin* folder from your File Explorer or Finder window and drop it into
    the Command Prompt or Terminal window, as shown in [Figure 6-9](ch6.xhtml#ch6fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0142-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: You can drag and drop the* bin *folder from File Explorer or Finder
    into the command line window to easily copy the directory path.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the full path appears after the `cd` command and looks something
    like the following (your *workspace/SecretMessages/bin* folder will be in a slightly
    different location from mine, of course):'
  prefs: []
  type: TYPE_NORMAL
- en: cd "C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin"
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS, the command will be:'
  prefs: []
  type: TYPE_NORMAL
- en: cd /Users/BrysonPayne/Desktop/workspace_ch06/SecretMessages/bin
  prefs: []
  type: TYPE_NORMAL
- en: 'Press ENTER after this command, and the terminal will change the prompt to
    show you that you’re now inside the *bin* folder. On Windows, this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>_
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re inside the *bin* folder, where the file *SecretMessages.class* has
    been compiled. To run the program contained in the *SecretMessages.class* bytecode
    file, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>java SecretMessages
  prefs: []
  type: TYPE_NORMAL
- en: 'Spelling, capitalization, and spacing all matter in the command, so you’ll
    need to match the name you gave your Java class precisely. If you typed the command
    correctly, the app should run, and you can test it with a message and secret key
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: C:\Users\Bryson Payne\workspace_ch06\SecretMessages\bin>java SecretMessages
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a message to encode or decode:'
  prefs: []
  type: TYPE_NORMAL
- en: I'm running my app directly from the command line terminal!
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a secret key (-25 to 25):'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: U'y dgzzuzs yk mbb pudqofxk rday ftq oayymzp xuzq fqdyuzmx!
  prefs: []
  type: TYPE_NORMAL
- en: You can run the app again by retyping the line `java SecretMessages` or by pressing
    the up arrow key on your keyboard and pressing ENTER. [Figure 6-10](ch6.xhtml#ch6fig10)
    shows a couple of runs encoding and decoding a message from a Windows command
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/f0143-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: Now that you can run your Java app from the command line, you
    can encode and decode messages on any computer with Java installed, with or without
    Eclipse.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to run the app on your computer, you can share the *SecretMessages.class*
    file with your friends to exchange encoded messages. If their computer has Java
    (JDK or JRE) installed, all they’ll have to do is open their command line program,
    change directories into the folder containing the *SecretMessages.class* file,
    and run the same `java SecretMessages` command. To exchange messages, just agree
    on a key value to use. You can choose to use the same key every time or use different
    key values with different friends! Remember, though, this message app is just
    for fun—anyone with this program, or with a little time on their hands, can break
    a simple Caesar cipher. We’ll see how to break Caesar ciphers easily in [Chapter
    7](ch7.xhtml#ch7).
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Secret Messages app provided a fun way to delve into the world of manipulating
    characters and strings of text in Java. Among the new things you learned in this
    chapter were:'
  prefs: []
  type: TYPE_NORMAL
- en: • Using the Caesar cipher to encode and decode simple messages
  prefs: []
  type: TYPE_NORMAL
- en: • Understanding the `char` data type for storing single Unicode characters
  prefs: []
  type: TYPE_NORMAL
- en: • Getting a specific character in a string with the `charAt()` method
  prefs: []
  type: TYPE_NORMAL
- en: • Accessing a specific location in a string using the index, or position number,
    of a character in the string
  prefs: []
  type: TYPE_NORMAL
- en: • Adding strings and characters together using the `+` operator
  prefs: []
  type: TYPE_NORMAL
- en: • Looping through a string with a `for` loop, using its `length()` function
    to get the number of characters
  prefs: []
  type: TYPE_NORMAL
- en: • Understanding how the computer stores characters and other data represented
    by number values
  prefs: []
  type: TYPE_NORMAL
- en: • Running command line apps directly from the command line, without Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: Programming Challenges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try these programming challenge exercises to review and practice what you’ve
    learned, as well as to expand your programming skills by trying something new.
    Visit the book’s website at *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    to download sample solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '*#1: Looping the Loop*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve built a fun message encoder/decoder app that will let us send and receive
    secret texts, emails, tweets, and so on. For your first programming challenge,
    add a loop to the Secret Messages app that will allow you to keep encoding and
    decoding messages as many times as you like.
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to use the same key every time, or you can ask the user for a
    new key each time. If you ask the user to enter a secret key each time through
    the loop, you can enable them to encode and decode messages, one after the other
    (entering `8`, for example, to encode a message to a friend, and `-8` to decode
    a message from that same friend).
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to prompt the user to enter a new message to encode or
    decode or tell them to press ENTER to quit. Then, use an `if` statement to check
    whether the user entered a message or just pressed ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: Give it a shot!
  prefs: []
  type: TYPE_NORMAL
- en: '**HINT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*message.length() will be greater than zero if the user typed something.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*#2: Reversing and Encoding*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s make our messages even harder to decipher by reversing the message before
    we encode it with the Caesar cipher. This double-encoding version of the app will
    combine the message-reversing approach of the first version in [Listing 6-1](ch6.xhtml#ch6list1)
    on [page 130](ch6.xhtml#page_130) with the Caesar cipher features of the final
    version from [Listing 6-4](ch6.xhtml#ch6list4) on [page 140](ch6.xhtml#page_140).
  prefs: []
  type: TYPE_NORMAL
- en: Reversing the order of the message is another example of symmetric encryption—doing
    it once reverses the message, and doing it again restores the message. Combining
    the string reversal with the Caesar cipher shift doesn’t make the program much
    more difficult, but it can make your messages even more confusing to an eavesdropper.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your app correctly encodes and decodes messages, and remember that
    your friends will need the new version of the program to be able to decipher your
    new, doubly scrambled messages! Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: '*#3: Safely Handling Keys with try and catch*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A final improvement you could make to the Secret Messages app would be to safely
    handle bad numeric input when the user enters a key value. Remember the `try-catch`
    statement?
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `try-catch` blocks to this app can be a bit tricky. In addition to
    adding the exception-handling code to prevent the user from crashing the program
    by giving a bad number (for example, by entering text instead of a number when
    prompted for the key value), you’ll need to think about what the app should do
    when bad input is provided. Should it tell the user their key was invalid and
    use a predefined key instead (say, `13`)? Or should it create a loop that will
    keep asking the user for a valid key?
  prefs: []
  type: TYPE_NORMAL
- en: Try coding it both ways and pick the one you like best!
  prefs: []
  type: TYPE_NORMAL
