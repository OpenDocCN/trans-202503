<html><head></head><body>
<section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_45" title="45"/>3</span><br/>&#13;
<span class="ChapterTitle">Reliable TCP Data Streams</span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" src="image_fi/book_art/chapterart.png"/>&#13;
</figure>&#13;
<p class="ChapterIntro">TCP allows you to reliably stream data between nodes on a network. This chapter takes a deeper dive into the protocol, focusing on the aspects directly influenced by the code we’ll write to establish TCP connections and transmit data over those connections. This knowledge should help you debug network-related issues in your programs. </p>&#13;
<p>We’ll start by covering the TCP handshake process, its sequence numbers, acknowledgments, retransmissions, and other features. Next, we’ll implement the steps of a TCP session in Go, from dialing, listening, and accepting to the session termination. Then, we’ll discuss time-outs and temporary errors, how to detect them, and how to use them to keep our users happy. Finally, we’ll cover the early detection of unreliable network connections. Go’s standard library allows you to write robust TCP-based networking applications. But it doesn’t hold your hand. If you aren’t mindful of managing incoming data or properly closing connections, you’ll experience insidious bugs in your programs.</p>&#13;
<h2 id="h1-500884c03-0001"><span epub:type="pagebreak" id="Page_46" title="46"/>What Makes TCP Reliable?</h2>&#13;
<p class="BodyFirst">TCP is reliable because it overcomes the effects of packet loss or receiving packets out of order. <em>Packet loss</em> occurs when data fails to reach its destination—typically because of data transmission errors (such as wireless network interference) or network congestion. <em>Network congestion</em> happens when nodes attempt to send more data over a network connection than the connection can handle, causing the nodes to discard the excess packets. For example, you can’t send data at a rate of 1 gigabit per second (Gbps) over a 10 megabit-per-second (Mbps) connection. The 10Mbps connection quickly becomes saturated, and nodes involved in the flow of the data drop the excess data.</p>&#13;
<p>TCP adapts its data transfer rate to make sure it transmits data as fast as possible while keeping dropped packets to a minimum, even if the network conditions change—for example, the Wi-Fi signal fades, or the destination node becomes overwhelmed with data. This process, called <em>flow control</em>, does its best to make up for the deficiencies of the underlying network media. TCP cannot send good data over a bad network and is at the mercy of the network hardware. </p>&#13;
<p>TCP also keeps track of received packets and retransmits unacknowledged packets, as necessary. Recipients can also receive packets out of sequence if, for example, data is rerouted in transit. Remember from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> that routing protocols use metrics to determine how to route packets. These metrics may change as network conditions change. There is no guarantee that all packets you send take the same route for the duration of the TCP session. Thankfully, TCP organizes unordered packets and processes them in sequence. </p>&#13;
<p>Together with flow control and retransmission, these properties allow TCP to overcome packet loss and facilitate the delivery of data to the recipient. As a result, TCP eliminates the need for you to concern yourself with these errors. You are free to focus on the data you send and receive. </p>&#13;
<h2 id="h1-500884c03-0002">Working with TCP Sessions</h2>&#13;
<p class="BodyFirst">A <em>TCP session</em> allows you to deliver a stream of data of any size to a recipient and receive confirmation that the recipient received the data. This saves you from the inefficiency of sending a large amount of data across a network, only to find out at the end of the transmission that the recipient didn’t receive it. </p>&#13;
<p>Much like the occasional head nod that people use to indicate they’re listening to someone speaking, streaming allows you to receive feedback from the recipient while the transfer is taking place so that you can correct any errors in real time. In fact, you can think of a TCP session as you would a conversation between two nodes. It starts with a greeting, progresses into the conversation, and concludes with a farewell.</p>&#13;
<p>As we discuss the specifics of TCP, I want you to understand that Go takes care of the implementation details for you. Your code will take advantage of the <code>net</code> package’s interfaces when working with TCP connections.</p>&#13;
<h3 id="h2-500884c03-0001"><span epub:type="pagebreak" id="Page_47" title="47"/>Establishing a Session with the TCP Handshake</h3>&#13;
<p class="BodyFirst">A TCP connection uses a three-way handshake to introduce the client to the server and the server to the client. The handshake creates an established TCP session over which the client and server exchange data. <a href="#figure3-1" id="figureanchor3-1">Figure 3-1</a> illustrates the three messages sent in the handshake process. </p>&#13;
<figure>&#13;
<img alt="f03001" src="image_fi/500884c03/f03001.png"/>&#13;
<figcaption><p><a id="figure3-1">Figure 3-1</a>: The three-way handshake process leading to an established TCP session</p></figcaption>&#13;
</figure>&#13;
<p>Before it can establish a TCP session, the server must listen for incoming connections. (I use the terms <em>server</em> and <em>client</em> in this chapter to refer to the listening node and dialing node, respectively. TCP itself doesn’t have a concept of a client and server, but an established session between two nodes, whereby one node reaches out to another node to establish the session.) </p>&#13;
<p>As the first step of the handshake, the client sends a packet with the <em>synchronize (SYN) flag</em> to the server. This SYN packet informs the server of the client’s capabilities and preferred window settings for the rest of the conversation. We’ll discuss the receive window shortly. Next, the server responds with its own packet, with both the <em>acknowledgment (ACK) </em>and SYN flags set. The ACK flag tells the client that the server acknowledges receipt of the client’s SYN packet. The server’s SYN packet tells the client what settings it’s agreed to for the duration of the conversation. Finally, the client replies with an ACK packet to acknowledge the server’s SYN packet, completing the three-way handshake.</p>&#13;
<p>Completion of the three-way handshake process establishes the TCP session, and nodes may then exchange data. The TCP session remains idle until either side has data to transmit. Unmanaged and lengthy idle TCP sessions may result in wasteful consumption of memory. We’ll cover techniques for managing idle connections in your code later in this chapter.</p>&#13;
<p>When you initiate a connection in your code, Go will return either a connection object or an error. If you receive a connection object, the TCP handshake succeeded. You do not need to manage the handshake yourself.</p>&#13;
<h3 id="h2-500884c03-0002">Acknowledging Receipt of Packets by Using Their Sequence Numbers</h3>&#13;
<p class="BodyFirst">Each TCP packet contains a <em>sequence number</em>, which the receiver uses to acknowledge receipt of each packet and properly order the packets for presentation to your Go application (<a href="#figure3-2" id="figureanchor3-2">Figure 3-2</a>). </p>&#13;
<span epub:type="pagebreak" id="Page_48" title="48"/><figure>&#13;
<img alt="f03002" src="image_fi/500884c03/f03002.png"/>&#13;
<figcaption><p><a id="figure3-2">Figure 3-2</a>: Client and server exchanging sequence numbers</p></figcaption>&#13;
</figure>&#13;
<p>The client’s operating system determines the initial sequence number<em> </em>(X in <a href="#figure3-2">Figure 3-2</a>) and sends it to the server in the client’s SYN packet during the handshake. The server acknowledges receipt of the packet by including this sequence number in its ACK packet to the client. Likewise, the server shares its generated sequence number Y in its SYN packet to the client. The client replies with its ACK to the server.</p>&#13;
<p>An ACK packet uses the sequence number to tell the sender, “I’ve received all packets up to and including the packet with this sequence number.” One ACK packet can acknowledge the receipt of one or more packets from the sender. The sender uses the sequence number in the ACK packet to determine whether it needs to retransmit any packets. For example, if a sender transmits a bunch of packets with sequence numbers up through 100 but then receives an ACK from the receiver with sequence number 90, the sender knows it needs to retransmit packets from sequence numbers 91 to 100.</p>&#13;
<p>While writing and debugging network programs, it’s often necessary to view the traffic your code sends and receives. To capture and inspect TCP packets, I strongly recommend you familiarize yourself with Wireshark (<a class="LinkURL" href="https://www.wireshark.org/">https://www.wireshark.org/</a>). This program will go a long way toward helping you understand how your code influences the data sent over the network. To learn more, see <em>Practical Packet Analysis</em>, 3rd Edition, by Chris Sanders (No Starch, 2017). </p>&#13;
<p>If you view your application’s network traffic in Wireshark, you may notice <em>selective acknowledgments (SACKs)</em>. These are ACK packets used to acknowledge the receipt of a <em>subset</em> of sent packets. For example, let’s assume the sender transmitted a hundred packets but only packets 1 to 59 and 81 to 100 made it to the receiver. The receiver could send a SACK to inform the sender what subset of packets it received.</p>&#13;
<p>Here again, Go handles the low-level details. Your code will not need to concern itself with sequence numbers and acknowledgments.</p>&#13;
<h3 id="h2-500884c03-0003">Receive Buffers and Window Sizes</h3>&#13;
<p class="BodyFirst">Since TCP allows a single ACK packet to acknowledge the receipt of more than one incoming packet, the receiver must advertise to the sender how much space it has available in its receive buffer before it sends an acknowledgment. A <em>receive buffer</em> is a block of memory reserved for incoming data <span epub:type="pagebreak" id="Page_49" title="49"/>on a network connection. The receive buffer allows the node to accept a certain amount of data from the network without requiring an application to immediately read the data. Both the client and the server maintain their own per-connection receive buffer. When your Go code reads data from a network connection object, it reads the data from the connection’s receive buffer.</p>&#13;
<p>ACK packets include a particularly important piece of information: the <em>window size</em>, which is the number of bytes the sender can transmit to the receiver without requiring an acknowledgment. If the client sends an ACK packet to the server with a window size of 24,537, the server knows it can send 24,537 bytes to the client before expecting the client to send another ACK packet. A window size of zero indicates that the receiver’s buffer is full and can no longer receive additional data. We’ll discuss this scenario a bit later in this chapter.</p>&#13;
<p>Both the client and the server keep track of each other’s window size and do their best to completely fill each other’s receive buffers. This method—of receiving the window size in an ACK packet, sending data, receiving an updated window size in the next ACK, and then sending more data—is known as a <em>sliding window</em>, as shown in <a href="#figure3-3" id="figureanchor3-3">Figure 3-3</a>. Each side of the connection offers up a window of data that can it can receive at any one time.</p>&#13;
<figure>&#13;
<img alt="f03003" src="image_fi/500884c03/f03003.png"/>&#13;
<figcaption><p><a id="figure3-3">Figure 3-3</a>: A client’s ACKs advertising the amount of data it can receive</p></figcaption>&#13;
</figure>&#13;
<p>In this snippet of communication, the client sends an ACK for previously received data. This ACK includes a window size of 3,072 bytes. The server now knows that it can send up to 3,072 bytes before it requires an ACK from the client. The server sends three packets with 1,024 bytes each to fill the client’s receive buffer. The client then sends another ACK with an updated window size of 2,048 bytes. This means that the application running on the client read 2,048 bytes from the receive buffer before the client sent its acknowledgment to the server. The server then sends two more packets of 1,024 bytes to fill the client’s receive buffer and waits for another ACK.</p>&#13;
<p><span epub:type="pagebreak" id="Page_50" title="50"/>Here again, all you need to concern yourself with is reading and writing to the connection object Go gives you when you establish a TCP connection. If something goes wrong, Go will surely let you know by returning an error.</p>&#13;
<h3 id="h2-500884c03-0004">Gracefully Terminating TCP Sessions</h3>&#13;
<p class="BodyFirst">Like the handshake process, gracefully terminating a TCP session involves exchanging a sequence of packets. Either side of the connection may initiate the termination sequence by sending a <em>finish (FIN)</em> packet. In <a href="#figure3-4" id="figureanchor3-4">Figure 3-4</a>, the client initiates the termination by sending a FIN packet to the server. </p>&#13;
<figure>&#13;
<img alt="f03004" src="image_fi/500884c03/f03004.png"/>&#13;
<figcaption><p><a id="figure3-4">Figure 3-4</a>: The client initiates a TCP session termination with the server.</p></figcaption>&#13;
</figure>&#13;
<p>The client’s connection state changes from ESTABLISHED to FIN_WAIT_1, which indicates the client is in the process of tearing down the connection from its end and is waiting for the server’s acknowledgment. The server acknowledges the client’s FIN and changes its connection state from ESTABLISHED to CLOSE_WAIT. The server sends its own FIN packet, changing its state to LAST_ACK, indicating it’s waiting for a final acknowledgment from the client. The client acknowledges the server’s FIN and enters a TIME_WAIT state, whose purpose is to allow the client’s final ACK packet to reach the server. The client waits for twice the maximum segment lifetime (the segment lifetime arbitrarily defaults to two minutes, per RFC 793, but your operating system may allow you to tweak this value), then changes its connection state to CLOSED without any further input required from the server. The <em>maximum segment lifetime</em> is the duration a TCP segment can remain in transit before the sender considers it abandoned. Upon receiving the client’s last ACK packet, the server immediately changes its connection state to CLOSED, fully terminating the TCP session.</p>&#13;
<p>Like the initial handshake, Go handles the details of the TCP connection teardown process when you close a connection object.</p>&#13;
<h3 id="h2-500884c03-0005"><span epub:type="pagebreak" id="Page_51" title="51"/>Handling Less Graceful Terminations</h3>&#13;
<p class="BodyFirst">Not all connections politely terminate. In some cases, the application that opened a TCP connection may crash or abruptly stop running for some reason. When this happens, the TCP connection is immediately closed. Any packets sent from the other side of the former connection will prompt the closed side of the connection to return a <em>reset (RST) packet</em>. The RST packet informs the sender that the receiver’s side of the connection closed and will no longer accept data. The sender should close its side of the connection knowing the receiver ignored any packets it did not acknowledge.</p>&#13;
<p>Intermediate nodes, such as firewalls, can send RST packets to each node in a connection, effectively terminating the socket from the middle.</p>&#13;
<h2 id="h1-500884c03-0003">Establishing a TCP Connection by Using Go’s Standard Library</h2>&#13;
<p class="BodyFirst">The <code>net</code> package in Go’s standard library includes good support for creating TCP-based servers and clients capable of connecting to those servers. Even so, it’s your responsibility to make sure you handle the connection appropriately. Your software should be attentive to incoming data and always strive to gracefully shut down the connection. Let’s write a TCP server that can listen for incoming TCP connections, initiate connections from a client, accept and asynchronously handle each connection, exchange data, and terminate the connection.</p>&#13;
<h3 id="h2-500884c03-0006">Binding, Listening for, and Accepting Connections</h3>&#13;
<p class="BodyFirst">To create a TCP server capable of listening for incoming connections (called a <em>listener</em>), use the <code>net.Listen</code> function. This function will return an object that implements the <code>net.Listener</code> interface. <a href="#listing3-1" id="listinganchor3-1">Listing 3-1</a> shows the creation of a listener.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "net"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestListener(t *testing.T) {&#13;
  <span class="CodeAnnotation">1</span>listener, err := net.Listen("<span class="CodeAnnotation">2</span>tcp", "<span class="CodeAnnotation">3</span>127.0.0.1:0")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
   <span class="CodeAnnotationHang">4</span>  defer func() { _ = listener.Close() }()&#13;
&#13;
    t.Logf("bound to %q", <span class="CodeAnnotation">5</span>listener.Addr())&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-1">Listing 3-1</a>: Creating a listener on 127.0.0.1 using a random port (<em>listen_test.go</em>)</p>&#13;
<p><span epub:type="pagebreak" id="Page_52" title="52"/>The <code>net.Listen</code> function accepts a network type <span class="CodeAnnotation">2</span> and an IP address and port separated by a colon <span class="CodeAnnotation">3</span>. The function returns a <code>net.Listener</code> interface <span class="CodeAnnotation">1</span> and an <code>error</code> interface. If the function returns successfully, the listener is bound to the specified IP address and port. <em>Binding</em> means that the operating system has exclusively assigned the port on the given IP address to the listener. The operating system allows no other processes to listen for incoming traffic on bound ports. If you attempt to bind a listener to a currently bound port, <code>net.Listen</code> will return an error. </p>&#13;
<p>You can choose to leave the IP address and port parameters empty. If the port is zero or empty, Go will randomly assign a port number to your listener. You can retrieve the listener’s address by calling its <code>Addr</code> method <span class="CodeAnnotation">5</span>. Likewise, if you omit the IP address, your listener will be bound to all unicast and anycast IP addresses on the system. Omitting both the IP address and port, or passing in a colon for the second argument to <code>net.Listen</code>, will cause your listener to bind to all unicast and anycast IP addresses using a random port.</p>&#13;
<p>In most cases, you should use <code>tcp</code> as the network type for <code>net.Listener</code>’s first argument. You can restrict the listener to just IPv4 addresses by passing in <code>tcp4</code> or exclusively bind to IPv6 addresses by passing in <code>tcp6</code>.</p>&#13;
<p>You should always be diligent about closing your listener gracefully by calling its <code>Close</code> method <span class="CodeAnnotation">4</span>, often in a <code>defer</code> if it makes sense for your code. Granted, this is a test case, and Go will tear down the listener when the test completes, but it’s good practice nonetheless. Failure to close the listener may lead to memory leaks or deadlocks in your code, because calls to the listener’s <code>Accept</code> method may block indefinitely. Closing the listener immediately unblocks calls to the <code>Accept</code> method.</p>&#13;
<p><a href="#listing3-2" id="listinganchor3-2">Listing 3-2</a> demonstrates how a listener can accept incoming TCP connections.</p>&#13;
<pre><code>   <span class="CodeAnnotationHang">1</span>  for {&#13;
      <span class="CodeAnnotation">2</span>conn, err := <span class="CodeAnnotation">3</span>listener.Accept()&#13;
        if err != nil {&#13;
            return err&#13;
        }&#13;
&#13;
       <span class="CodeAnnotationHang">4</span>  go func(c net.Conn) {&#13;
       <span class="CodeAnnotationHang">5</span>      defer c.Close()&#13;
&#13;
            // Your code would handle the connection here.&#13;
        }(conn)&#13;
    }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-2">Listing 3-2</a>: Accepting and handling incoming TCP connection requests</p>&#13;
<p>Unless you want to accept only a single incoming connection, you need to use a <code>for</code> loop <span class="CodeAnnotation">1</span> so your server will accept each incoming connection, handle it in a goroutine, and loop back around, ready to accept the next connection. Serially accepting connections is perfectly acceptable and efficient, but beyond that point, you should use a goroutine to handle each connection. You could certainly write serialized code after accepting a <span epub:type="pagebreak" id="Page_53" title="53"/>connection if your use case demands it, but it would be woefully inefficient and fail to take advantage of Go’s strengths. We start the <code>for</code> loop by calling the listener’s <code>Accept</code> method <span class="CodeAnnotation">2</span>. This method will block until the listener detects an incoming connection and completes the TCP handshake process between the client and the server. The call returns a <code>net.Conn</code> interface <span class="CodeAnnotation">3</span> and an <code>error</code>. If the handshake failed or the listener closed, for example, the error interface would be non-<code>nil</code>.</p>&#13;
<p>The connection interface’s underlying type is a pointer to a <code>net.TCPConn</code> object because you’re accepting TCP connections. The connection interface represents the server’s side of the TCP connection. In most cases, <code>net.Conn</code> provides all methods you’ll need for general interactions with the client. However, the <code>net.TCPConn</code> object provides additional functionality we’ll cover in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> should you require more control.</p>&#13;
<p>To concurrently handle client connections, you spin off a goroutine to asynchronously handle each connection <span class="CodeAnnotation">4</span> so your listener can ready itself for the next incoming connection. Then you call the connection’s <code>Close</code> method <span class="CodeAnnotation">5</span> before the goroutine exits to gracefully terminate the connections by sending a FIN packet to the server.</p>&#13;
<h3 id="h2-500884c03-0007">Establishing a Connection with a Server</h3>&#13;
<p class="BodyFirst">From the client’s side, Go’s standard library <code>net</code> package makes reaching out and establishing a connection with a server a simple matter. <a href="#listing3-3" id="listinganchor3-3">Listing 3-3</a> is a test that demonstrates the process of initiating a TCP connection with a server listening to 127.0.0.1 on a random port.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "io"&#13;
    "net"&#13;
    "testing"&#13;
)&#13;
&#13;
func TestDial(t *testing.T) {&#13;
    // Create a listener on a random port.&#13;
    listener, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    done := make(chan struct{})&#13;
   <span class="CodeAnnotationHang">1</span>  go func() {&#13;
        defer func() { done &lt;- struct{}{} }()&#13;
&#13;
        for {&#13;
            conn, err := <span class="CodeAnnotation">2</span>listener.Accept()&#13;
            if err != nil {&#13;
                t.Log(err)&#13;
                return&#13;
            }&#13;
&#13;
<span epub:type="pagebreak" id="Page_54" title="54"/>           <span class="CodeAnnotationHang">3</span>  go func(c net.Conn) {&#13;
                defer func() {&#13;
                    c.Close()&#13;
                    done &lt;- struct{}{}&#13;
                }()&#13;
&#13;
                buf := make([]byte, 1024)&#13;
                for {&#13;
                    n, err := <span class="CodeAnnotation">4</span>c.Read(buf)&#13;
                    if err != nil {&#13;
                        if err != io.EOF {&#13;
                            t.Error(err)&#13;
                        }&#13;
                        return&#13;
                    }&#13;
&#13;
                    t.Logf("received: %q", buf[:n])&#13;
                }&#13;
            }(conn)&#13;
        }&#13;
    }()&#13;
&#13;
  <span class="CodeAnnotationHang">5</span>conn, err := net.Dial("<span class="CodeAnnotation">6</span>tcp", <span class="CodeAnnotation">7</span>listener.Addr().String())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
   <span class="CodeAnnotationHang">8</span>  conn.Close()&#13;
    &lt;-done&#13;
   <span class="CodeAnnotationHang">9</span>  listener.Close()&#13;
    &lt;-done&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-3">Listing 3-3</a>: Establishing a connection to 127.0.0.1 (<em>dial_test.go</em>)</p>&#13;
<p>You start by creating a listener on the IP address 127.0.0.1, which the client will connect to. You omit the port number altogether, so Go will randomly pick an available port for you. Then, you spin off the listener in a goroutine <span class="CodeAnnotation">1</span> so you can work with the client’s side of the connection later in the test. The listener’s goroutine contains code like <a href="#listing3-2">Listing 3-2</a>’s for accepting incoming TCP connections in a loop, spinning off each connection into its own goroutine. (We often call this goroutine a <em>handler</em>. I’ll explain the implementation details of the handler shortly, but it will read up to 1024 bytes from the socket at a time and log what it received.)</p>&#13;
<p>The standard library’s <code>net</code>.<code>Dial</code> function is like the <code>net.Listen</code> function in that it accepts a network <span class="CodeAnnotation">6</span> like <code>tcp</code> and an IP address and port combination <span class="CodeAnnotation">7</span>—in this case, the IP address and port of the listener to which it’s trying to connect. You can use a hostname in place of an IP address and a service name, like <em>http</em>, in place of a port number. If a hostname resolves to more than one IP address, Go will attempt a connection to each one in order until a connection succeeds or all IP addresses have been exhausted. Since IPv6 addresses include colon delimiters, you must enclose an IPv6 address <span epub:type="pagebreak" id="Page_55" title="55"/>in square brackets. For example, <code>"[2001:ed27::1]:https"</code> specifies port 443 at the IPv6 address 2001:ed27::1. <code>Dial</code> returns a connection object <span class="CodeAnnotation">5</span> and an <code>error</code> interface value.</p>&#13;
<p>Now that you’ve established a successful connection to the listener, you initiate a graceful termination of the connection from the client’s side <span class="CodeAnnotation">8</span>. After receiving the FIN packet, the <code>Read</code> method <span class="CodeAnnotation">4</span> returns the <code>io.EOF</code> error, indicating to the listener’s code that you closed your side of the connection. The connection’s handler <span class="CodeAnnotation">3</span> exits, calling the connection’s <code>Close</code> method on the way out. This sends a FIN packet to your connection, completing the graceful termination of the TCP session.</p>&#13;
<p>Finally, you close the listener <span class="CodeAnnotation">9</span>. The listener’s <code>Accept</code> method <span class="CodeAnnotation">2</span> immediately unblocks and returns an error. This error isn’t necessarily a failure, so you simply log it and move on. It doesn’t cause your test to fail. The listener’s goroutine <span class="CodeAnnotation">1</span> exits, and the test completes.</p>&#13;
<h4 id="h3-500884c03-0001">Understanding Time-outs and Temporary Errors</h4>&#13;
<p class="BodyFirst">In a perfect world, your connection attempts will immediately succeed, and all read and write attempts will never fail. But you need to hope for the best and prepare for the worst. You need a way to determine whether an error is temporary or something that warrants termination of the connection altogether. The <code>error</code> interface doesn’t provide enough information to make that determination. Thankfully, Go’s <code>net</code> package provides more insight if you know how to use it. </p>&#13;
<p>Errors returned from functions and methods in the <code>net</code> package typically implement the <code>net.Error</code> interface, which includes two notable methods: <code>Timeout</code> and <code>Temporary</code>. The <code>Timeout</code> method returns <code>true</code> on Unix-based operating systems and Windows if the operating system tells Go that the resource is temporarily unavailable, the call would block, or the connection timed out. We’ll touch on time-outs and how you can use them to your advantage a bit later in this chapter. The <code>Temporary</code> method returns <code>true</code> if the error's <code>Timeout</code> function returns <code>true</code>, the function call was interrupted, or there are too many open files on the system, usually because you’ve exceeded the operating system’s resource limit.</p>&#13;
<p>Since the functions and methods in the <code>net</code> package return the more general <code>error</code> interface, you’ll see the code in this chapter use type assertions to verify you received a <code>net.Error</code>, as in <a href="#listing3-4" id="listinganchor3-4">Listing 3-4</a>.</p>&#13;
<pre><code>if nErr, ok := err.(net.Error); ok &amp;&amp; !nErr.Temporary() { return err }</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-4">Listing 3-4</a>: Asserting a <var>net.Error</var> to check whether the error was temporary</p>&#13;
<p>Robust network code won’t rely exclusively on the <code>error</code> interface. Rather, it will readily use <code>net.Error</code>’s methods, or even dive in further and assert the underlying <code>net.OpError</code> struct, which contains more details about the connection, such as the operation that caused the error, the network type, the source address, and more. I encourage you to read the <code>net.OpError</code> documentation (available at <a class="LinkURL" href="https://golang.org/pkg/net/#OpError/">https://golang.org/pkg/net/#OpError/</a>) to learn more about specific errors beyond what the <code>net.Error</code> interface provides.</p>&#13;
<h4 id="h3-500884c03-0002"><span epub:type="pagebreak" id="Page_56" title="56"/>Timing Out a Connection Attempt with the DialTimeout Function</h4>&#13;
<p class="BodyFirst">Using the <code>Dial</code> function has one potential problem: you are at the mercy of the operating system to time out each connection attempt. For example, if you use the <code>Dial</code> function in an interactive application and your operating system times out connection attempts after two hours, your application’s user may not want to wait that long, much less give your app a five-star rating. </p>&#13;
<p>To keep your applications predictable and your users happy, it’d be better to control time-outs yourself. For example, you may want to initiate a connection to a low-latency service that responds quickly if it’s available. If the service isn’t responding, you’ll want to time out quickly and move onto the next service. </p>&#13;
<p>One solution is to explicitly define a per-connection time-out duration and use the <code>DialTimeout</code> function instead. <a href="#listing3-5" id="listinganchor3-5">Listing 3-5</a> implements this solution.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "net"&#13;
    "syscall"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func <span class="CodeAnnotation">1</span>DialTimeout(network, address string, timeout time.Duration,&#13;
) (net.Conn, error) {&#13;
    d := net.Dialer{&#13;
       <span class="CodeAnnotationHang">2</span>  Control: func(_, addr string, _ syscall.RawConn) error {&#13;
            return &amp;net.DNSError{&#13;
                Err:         "connection timed out",&#13;
                Name:        addr,&#13;
                Server:      "127.0.0.1",&#13;
                IsTimeout:   true,&#13;
                IsTemporary: true,&#13;
            }&#13;
        },&#13;
        Timeout: timeout,&#13;
    }&#13;
    return d.Dial(network, address)&#13;
}&#13;
&#13;
func TestDialTimeout(t *testing.T) {&#13;
    c, err := DialTimeout("tcp", "10.0.0.1:http", <span class="CodeAnnotation">3</span>5*time.Second)&#13;
    if err == nil {&#13;
        c.Close()&#13;
        t.Fatal("connection did not time out")&#13;
    }&#13;
    nErr, ok := <span class="CodeAnnotation">4</span>err.(net.Error)&#13;
    if !ok {&#13;
        t.Fatal(err)&#13;
    }&#13;
<span epub:type="pagebreak" id="Page_57" title="57"/>    if <span class="CodeAnnotation">5</span>!nErr.Timeout() {&#13;
        t.Fatal("error is not a timeout")&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-5">Listing 3-5</a>: Specifying a time-out duration when initiating a TCP connection (<em>dial_timeout_test.go</em>)</p>&#13;
<p>Since the <code>net.DialTimeout</code> function <span class="CodeAnnotation">1</span> does not give you control of its <code>net.Dialer</code> to mock the dialer’s output, you’re using our own implementation that matches the signature. Your <code>DialTimeout</code> function overrides the <code>Control</code> function <span class="CodeAnnotation">2</span> of the <code>net.Dialer</code> to return an error. You’re mocking a DNS time-out error.</p>&#13;
<p>Unlike the <code>net.Dial</code> function, the <code>DialTimeout</code> function includes an additional argument, the time-out duration <span class="CodeAnnotation">3</span>. Since the time-out duration is five seconds in this case, the connection attempt will time out if a connection isn’t successful within five seconds. In this test, you dial 10.0.0.0, which is a non-routable IP address, meaning your connection attempt assuredly times out. For the test to pass, you need to first use a type assertion to verify you’ve received a <code>net.Error</code><span class="CodeAnnotation">4</span> before you can check its <code>Timeout</code> method <span class="CodeAnnotation">5</span>.</p>&#13;
<p>If you dial a host that resolves to multiple IP addresses, Go starts a connection race between each IP address, giving the primary IP address a head start. The first connection to succeed persists, and the remaining contenders cancel their connection attempts. If all connections fail or time out, <code>net.DialTimeout</code> returns an error.</p>&#13;
<h4 id="h3-500884c03-0003">Using a Context with a Deadline to Time Out a Connection</h4>&#13;
<p class="BodyFirst">A more contemporary solution to timing out a connection attempt is to use a context from the standard library’s <code>context</code> package. A <em>context</em> is an object that you can use to send cancellation signals to your asynchronous processes. It also allows you to send a cancellation signal after it reaches a deadline or after its timer expires. </p>&#13;
<p>All cancellable contexts have a corresponding <code>cancel</code> function returned upon instantiation. The <code>cancel</code> function offers increased flexibility since you can optionally cancel the context before the context reaches its deadline. You could also pass along its <code>cancel</code> function to hand off cancellation control to other bits of your code. For example, you could monitor for specific signals from your operating system, such as the one sent to your application when a user presses the <span class="KeyCaps">ctrl</span>-C key combination, to gracefully abort connection attempts and tear down existing connections before terminating your application. </p>&#13;
<p><a href="#listing3-6" id="listinganchor3-6">Listing 3-6</a> illustrates a test that accomplishes the same functionality as <code>DialTimeout</code>, using <code>context</code> instead.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "context"&#13;
    "net"&#13;
    "syscall"&#13;
<span epub:type="pagebreak" id="Page_58" title="58"/>    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestDialContext(t *testing.T) {&#13;
    <span class="CodeAnnotationHang">1</span> dl := time.Now().Add(5 * time.Second)&#13;
    <span class="CodeAnnotationHang">2</span> ctx, cancel := context.WithDeadline(context.Background(), dl)&#13;
    <span class="CodeAnnotationHang">3</span> defer cancel()&#13;
&#13;
    var d net.Dialer // DialContext is a method on a Dialer&#13;
    d.Control = <span class="CodeAnnotation">4</span>func(_, _ string, _ syscall.RawConn) error {&#13;
        // Sleep long enough to reach the context's deadline.&#13;
        time.Sleep(5*time.Second + time.Millisecond)&#13;
        return nil&#13;
    }&#13;
    conn, err := d.DialContext(<span class="CodeAnnotation">5</span>ctx, "tcp", "10.0.0.0:80")&#13;
    if err == nil {&#13;
        conn.Close()&#13;
        t.Fatal("connection did not time out")&#13;
    }&#13;
    nErr, ok := err.(net.Error)&#13;
    if !ok {&#13;
        t.Error(err)&#13;
    } else {&#13;
        if !nErr.Timeout() {&#13;
            t.Errorf("error is not a timeout: %v", err)&#13;
        }&#13;
    }&#13;
   <span class="CodeAnnotationHang">6</span>  if ctx.Err() != context.DeadlineExceeded {&#13;
        t.Errorf("expected deadline exceeded; actual: %v", ctx.Err())&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-6">Listing 3-6</a>: Using a context with a deadline to time out the connection attempt (<em>dial_context_test.go</em>)</p>&#13;
<p>Before you make a connection attempt, you create the context with a deadline of five seconds into the future <span class="CodeAnnotation">1</span>, after which the context will automatically cancel. Next, you create the context and its <code>cancel</code> function by using the <code>context.WithDeadline</code> function <span class="CodeAnnotation">2</span>, setting the deadline in the process. It’s good practice to defer the <code>cancel</code> function <span class="CodeAnnotation">3</span> to make sure the context is garbage collected as soon as possible. Then, you override the dialer’s <code>Control</code> function <span class="CodeAnnotation">4</span> to delay the connection just long enough to make sure you exceed the context’s deadline. Finally, you pass in the context as the first argument to the <code>DialContext</code> function <span class="CodeAnnotation">5</span>. The sanity check <span class="CodeAnnotation">6</span> at the end of the test makes sure that reaching the deadline canceled the context, not an erroneous call to <code>cancel</code>.</p>&#13;
<p>As with <code>DialTimeout</code>, if a host resolves to multiple IP addresses, Go starts a connection race between each IP address, giving the primary IP address a head start. The first connection to succeed persists, and the remaining contenders cancel their connection attempts. If all connections fail or the context reaches its deadline, <code>net.Dialer.DialContext</code> returns an error.</p>&#13;
<h4 id="h3-500884c03-0004"><span epub:type="pagebreak" id="Page_59" title="59"/>Aborting a Connection by Canceling the Context</h4>&#13;
<p class="BodyFirst">Another advantage to using a context is the <code>cancel</code> function itself. You can use it to cancel the connection attempt on demand, without specifying a deadline, as shown in <a href="#listing3-7" id="listinganchor3-7">Listing 3-7</a>.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "context"&#13;
    "net"&#13;
    "syscall"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestDialContextCancel(t *testing.T) {&#13;
    ctx, cancel := <span class="CodeAnnotation">1</span>context.WithCancel(context.Background())&#13;
    sync := make(chan struct{})&#13;
&#13;
   <span class="CodeAnnotationHang">2</span>  go func() {&#13;
        defer func() { sync &lt;- struct{}{} }()&#13;
&#13;
        var d net.Dialer&#13;
        d.Control = func(_, _ string, _ syscall.RawConn) error {&#13;
            time.Sleep(time.Second)&#13;
            return nil&#13;
        }&#13;
        conn, err := d.DialContext(ctx, "tcp", "10.0.0.1:80")&#13;
        if err != nil {&#13;
            t.Log(err)&#13;
            return&#13;
        }&#13;
&#13;
        conn.Close()&#13;
        t.Error("connection did not time out")&#13;
    }()&#13;
&#13;
   <span class="CodeAnnotationHang">3</span>  cancel()&#13;
    &lt;-sync&#13;
&#13;
    if ctx.Err() != <span class="CodeAnnotation">4</span>context.Canceled {&#13;
        t.Errorf("expected canceled context; actual: %q", ctx.Err())&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-7">Listing 3-7</a>: Directly canceling the context to abort the connection attempt </p>&#13;
(<em>dial_cancel_test.go</em>)&#13;
<p>Instead of creating a context with a deadline and waiting for the deadline to abort the connection attempt, you use <code>context.WithCancel</code> to return a context and a function to cancel the context <span class="CodeAnnotation">1</span>. Since you’re manually canceling the context, you create a closure and spin it off in a goroutine to handle the connection attempt <span class="CodeAnnotation">2</span>. Once the dialer is attempting to connect to and handshake with the remote node, you call the <code>cancel</code> function <span class="CodeAnnotation">3</span><span epub:type="pagebreak" id="Page_60" title="60"/>to cancel the context. This causes the <code>DialContext</code> method to immediately return with a non-<code>nil</code> error, exiting the goroutine. You can check the context’s <code>Err</code> method to make sure the call to cancel was what resulted in the canceled context, as opposed to a deadline in <a href="#listing3-6">Listing 3-6</a>. In this case, the context’s <code>Err</code> method should return a <code>context.Canceled</code> error <span class="CodeAnnotation">4</span>.</p>&#13;
<h4 id="h3-500884c03-0005">Canceling Multiple Dialers </h4>&#13;
<p class="BodyFirst">You can pass the same context to multiple <code>DialContext</code> calls and cancel all the calls at the same time by executing the context’s <code>cancel</code> function. For example, let’s assume you need to retrieve a resource via TCP that is on several servers. You can asynchronously dial each server, passing each dialer the same context. You can then abort the remaining dialers after you receive a response from one of the servers.</p>&#13;
<p>In <a href="#listing3-8" id="listinganchor3-8">Listing 3-8</a>, you pass the same context to multiple dialers. When you receive the first response, you cancel the context and abort the remaining dialers.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "context"&#13;
    "net"&#13;
    "sync"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestDialContextCancelFanOut(t *testing.T) {&#13;
   <span class="CodeAnnotationHang">1</span>  ctx, cancel := context.WithDeadline(&#13;
        context.Background(),&#13;
        time.Now().Add(10*time.Second),&#13;
    )&#13;
&#13;
    listener, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer listener.Close()&#13;
&#13;
   <span class="CodeAnnotationHang">2</span>  go func() {&#13;
            // Only accepting a single connection.&#13;
            conn, err := listener.Accept()&#13;
            if err == nil {&#13;
                conn.Close()&#13;
            }&#13;
    }()&#13;
&#13;
   <span class="CodeAnnotationHang">3</span>  dial := func(ctx context.Context, address string, response chan int,&#13;
        id int, wg *sync.WaitGroup) {&#13;
        defer wg.Done()&#13;
&#13;
        var d net.Dialer&#13;
<span epub:type="pagebreak" id="Page_61" title="61"/>        c, err := d.DialContext(ctx, "tcp", address)&#13;
        if err != nil {&#13;
            return&#13;
        }&#13;
        c.Close()&#13;
&#13;
        select {&#13;
        case &lt;-ctx.Done():&#13;
        case response &lt;- id:&#13;
        }&#13;
    }&#13;
&#13;
    res := make(chan int)&#13;
    var wg sync.WaitGroup&#13;
&#13;
   <span class="CodeAnnotationHang">4</span>  for i := 0; i &lt; 10; i++ {&#13;
        wg.Add(1)&#13;
        go dial(ctx, listener.Addr().String(), res, i+1, &amp;wg)&#13;
    }&#13;
&#13;
   <span class="CodeAnnotationHang">5</span>  response := &lt;-res&#13;
    cancel()&#13;
    wg.Wait()&#13;
    close(res)&#13;
&#13;
    if ctx.Err() != <span class="CodeAnnotation">6</span>context.Canceled {&#13;
        t.Errorf("expected canceled context; actual: %s",&#13;
            ctx.Err(),&#13;
        )&#13;
    }&#13;
&#13;
    t.Logf("dialer %d retrieved the resource", response)&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-8">Listing 3-8</a>: Canceling all outstanding dialers after receiving the first response (<em>dial_fanout_test.go</em>)</p>&#13;
<p>You create a context by using <code>context.WithDeadline</code><span class="CodeAnnotation">1</span> because you want to have three potential results when checking the context’s <code>Err</code> method: <code>context.Canceled</code>, <code>context.DeadlineExceeded</code>, or <code>nil</code>. You expect <code>Err</code> will return the <code>context.Canceled</code> error, since your test aborts the dialers with a call to the <code>cancel</code> function.</p>&#13;
<p>First, you need a listener. This listener accepts a single connection and closes it after the successful handshake <span class="CodeAnnotation">2</span>. Next, you create your dialers. Since you’re spinning up multiple dialers, it makes sense to abstract the dialing code to its own function <span class="CodeAnnotation">3</span>. This anonymous function dials out to the given address by using <code>DialContext</code>. If it succeeds, it sends the dialer’s ID across the response channel, provided you haven’t yet canceled the context. You spin up multiple dialers by calling <code>dial</code> in separate goroutines using a <code>for</code> loop <span class="CodeAnnotation">4</span>. If <code>dial</code> blocks on the call to <code>DialContext</code> because another dialer won the race, you cancel the context, either by way of the <code>cancel</code> function or the deadline, causing the dial function to exit early. You use a wait group to make sure the test doesn’t proceed until all <code>dial</code> goroutines terminate after you cancel the context. </p>&#13;
<p><span epub:type="pagebreak" id="Page_62" title="62"/>Once the goroutines are running, one will win the race and make a successful connection to the listener. You receive the winning dialer’s ID on the <code>res</code> channel <span class="CodeAnnotation">5</span>, then abort the losing dialers by canceling the context. At this point, the call to <code>wg.Wait</code> blocks until the aborted dialer goroutines return. Finally, you make sure it was your call to <code>cancel</code> that caused the cancelation of the context <span class="CodeAnnotation">6</span>. Calling <code>cancel</code> does not guarantee that <code>Err</code> will return <code>context.Canceled</code>. The deadline can cancel the context, at which point calls to <code>cancel</code> become a no-op and <code>Err</code> will return <code>context.DeadlineExceeded</code>. In practice, the distinction may not matter to you, but it’s there if you need it.</p>&#13;
<h3 id="h2-500884c03-0008">Implementing Deadlines</h3>&#13;
<p class="BodyFirst">Go’s network connection objects allow you to include deadlines for both read and write operations. Deadlines allow you to control how long network connections can remain idle, where no packets traverse the connection. You can control the <code>Read</code> deadline by using the <code>SetReadDeadline</code> method on the connection object, control the <code>Write</code> deadline by using the <code>SetWriteDeadline</code> method, or both by using the <code>SetDeadline</code> method. When a connection reaches its read deadline, all currently blocked and future calls to a network connection’s <code>Read</code> method immediately return a time-out error. Likewise, a network connection’s <code>Write</code> method returns a time-out error when the connection reaches its write deadline.</p>&#13;
<p>Go’s network connections don’t set any deadline for reading and writing operations by default, meaning your network connections may remain idle for a long time. This could prevent you from detecting network failures, like an unplugged cable, in a timely manner, because it’s tougher to detect network issues between two nodes when no traffic is in flight.</p>&#13;
<p>The server in <a href="#listing3-9" id="listinganchor3-9">Listing 3-9</a> implements a deadline on its connection object.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "io"&#13;
    "net"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestDeadline(t *testing.T) {&#13;
    sync := make(chan struct{})&#13;
&#13;
    listener, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    go func() {&#13;
        conn, err := listener.Accept()&#13;
        if err != nil {&#13;
            t.Log(err)&#13;
            return&#13;
<span epub:type="pagebreak" id="Page_63" title="63"/>        }&#13;
        defer func() {&#13;
            conn.Close()&#13;
            close(sync) // read from sync shouldn't block due to early return&#13;
        }()&#13;
&#13;
       <span class="CodeAnnotationHang">1</span>  err = conn.SetDeadline(time.Now().Add(5 * time.Second))&#13;
        if err != nil {&#13;
            t.Error(err)&#13;
            return&#13;
        }&#13;
&#13;
        buf := make([]byte, 1)&#13;
        _, err = conn.Read(buf) // blocked until remote node sends data&#13;
        nErr, ok := err.(net.Error)&#13;
        if !ok || <span class="CodeAnnotation">2</span>!nErr.Timeout() {&#13;
            t.Errorf("expected timeout error; actual: %v", err)&#13;
        }&#13;
&#13;
        sync &lt;- struct{}{}&#13;
&#13;
       <span class="CodeAnnotationHang">3</span>  err = conn.SetDeadline(time.Now().Add(5 * time.Second))&#13;
        if err != nil {&#13;
            t.Error(err)&#13;
            return&#13;
        }&#13;
&#13;
        _, err = conn.Read(buf)&#13;
        if err != nil {&#13;
            t.Error(err)&#13;
        }&#13;
    }()&#13;
&#13;
    conn, err := net.Dial("tcp", listener.Addr().String())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer conn.Close()&#13;
&#13;
    &lt;-sync&#13;
    _, err = conn.Write([]byte("1"))&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    buf := make([]byte, 1)&#13;
    _, err = conn.Read(buf) // blocked until remote node sends data&#13;
    if err != <span class="CodeAnnotation">4</span>io.EOF {&#13;
        t.Errorf("expected server termination; actual: %v", err)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-9">Listing 3-9</a>: A server-enforced deadline terminates the network connection (<em>deadline_test.go</em>).</p>&#13;
<p><span epub:type="pagebreak" id="Page_64" title="64"/>Once the server accepts the client’s TCP connection, you set the connection’s read deadline <span class="CodeAnnotation">1</span>. Since the client won’t send data, the call to <code>Read</code> will block until the connection exceeds the read deadline. After five seconds, <code>Read</code> returns an error, which you verify is a time-out <span class="CodeAnnotation">2</span>. Any future reads to the connection object will immediately result in another time-out error. However, you can restore the functionality of the connection object by pushing the deadline forward again <span class="CodeAnnotation">3</span>. After you’ve done this, a second call to <code>Read</code> succeeds. The server closes its end of the network connection, which initiates the termination process with the client. The client, currently blocked on its <code>Read</code> call, returns <code>io.EOF</code><span class="CodeAnnotation">4</span> when the network connection closes.</p>&#13;
<p>We typically use deadlines to provide a window of time during which the remote node can send data over the network connection. When you read data from the remote node, you push the deadline forward. The remote node sends more data, and you push the deadline forward again, and so on. If you don’t hear from the remote node in the allotted time, you can assume that either the remote node is gone and you never received its FIN or that it is idle.</p>&#13;
<h4 id="h3-500884c03-0006">Implementing a Heartbeat</h4>&#13;
<p class="BodyFirst">For long-running network connections that may experience extended idle periods at the application level, it’s wise to implement a heartbeat between nodes to advance the deadline. This allows you to quickly identify network issues and promptly reestablish a connection as opposed to waiting to detect the network error when your application goes to transmit data. In this way, you can help make sure your application always has a good network connection when it needs it. </p>&#13;
<p>For our purposes, a <em>heartbeat</em> is a message sent to the remote side with the intention of eliciting a reply, which we can use to advance the deadline of our network connection. Nodes send these messages at a regular interval, like a heartbeat. Not only is this method portable over various operating systems, but it also makes sure the application using the network connection is responding, since the application implements the heartbeat. Also, this technique tends to play well with firewalls that may block TCP keepalives. We’ll discuss keepalives in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>.</p>&#13;
<p>To start, you’ll need a bit of code you can run in a goroutine to ping at regular intervals. You don’t want to needlessly ping the remote node when you recently received data from it, so you need a way to reset the ping timer. <a href="#listing3-10" id="listinganchor3-10">Listing 3-10</a> is a simple implementation from a file named <em>ping.go</em> that meets those requirements.</p>&#13;
<p>I use <em>ping</em> and <em>pong</em> messages in my heartbeat examples, where the reception of a ping message—the challenge—tells the receiver it should reply with a pong message—the response. The challenge and response messages are arbitrary. You could use anything you want to here, provided the remote node knows your intention is to elicit its reply.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
<span epub:type="pagebreak" id="Page_65" title="65"/>    "context"&#13;
    "io"&#13;
    "time"&#13;
)&#13;
&#13;
const defaultPingInterval = 30 * time.Second&#13;
&#13;
func Pinger(ctx context.Context, w io.Writer, reset &lt;-chan time.Duration) {&#13;
    var interval time.Duration&#13;
    select {&#13;
    case &lt;-ctx.Done():&#13;
        return&#13;
   <span class="CodeAnnotationHang">1</span>  case interval = &lt;-reset: // pulled initial interval off reset channel&#13;
    default:&#13;
    }&#13;
    if interval &lt;= 0 {&#13;
        interval = defaultPingInterval&#13;
    }&#13;
&#13;
   <span class="CodeAnnotationHang">2</span>  timer := time.NewTimer(interval)&#13;
    defer func() {&#13;
        if !timer.Stop() {&#13;
            &lt;-timer.C&#13;
        }&#13;
    }()&#13;
&#13;
    for {&#13;
        select {&#13;
       <span class="CodeAnnotationHang">3</span>  case &lt;-ctx.Done():&#13;
            return&#13;
       <span class="CodeAnnotationHang">4</span>  case newInterval := &lt;-reset:&#13;
            if !timer.Stop() {&#13;
                &lt;-timer.C&#13;
            }&#13;
            if newInterval &gt; 0 {&#13;
                interval = newInterval&#13;
            }&#13;
       <span class="CodeAnnotationHang">5</span>  case &lt;-timer.C:&#13;
            if _, err := w.Write([]byte("ping")); err != nil {&#13;
                // track and act on consecutive timeouts here&#13;
                return&#13;
            }&#13;
        }&#13;
&#13;
       <span class="CodeAnnotationHang">6</span>  _ = timer.Reset(interval)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-10">Listing 3-10</a>: A function that pings a network connection at a regular interval (<em>ping.go</em>)</p>&#13;
<p>The <code>Pinger</code> function writes ping messages to a given writer at regular intervals. Because it’s meant to run in a goroutine, <code>Pinger</code> accepts a context as its first argument so you can terminate it and prevent it from leaking. Its remaining arguments include an <code>io.Writer</code> interface and a channel to signal a <span epub:type="pagebreak" id="Page_66" title="66"/>timer reset. You create a buffered channel and put a duration on it to set the timer’s initial interval <span class="CodeAnnotation">1</span>. If the interval isn’t greater than zero, you use the default ping interval.</p>&#13;
<p>You initialize the timer to the interval <span class="CodeAnnotation">2</span> and set up a deferred call to drain the timer’s channel to avoid leaking it, if necessary. The endless <code>for</code> loop contains a <code>select</code> statement, where you block until one of three things happens: the context is canceled, a signal to reset the timer is received, or the timer expires. If the context is canceled <span class="CodeAnnotation">3</span>, the function returns, and no further pings will be sent. If the code selects the <code>reset</code> channel <span class="CodeAnnotation">4</span>, you shouldn’t send a ping, and the timer resets <span class="CodeAnnotation">6</span> before iterating on the <code>select</code> statement again.</p>&#13;
<p>If the timer expires <span class="CodeAnnotation">5</span>, you write a ping message to the writer, and the timer resets before the next iteration. If you wanted, you could use this <code>case</code> to keep track of any consecutive time-outs that occur while writing to the writer. To do this, you could pass in the context’s <code>cancel</code> function and call it here if you reach a threshold of consecutive time-outs.</p>&#13;
<p><a href="#listing3-11" id="listinganchor3-11">Listing 3-11</a> illustrates how to use the <code>Pinger</code> function introduced in <a href="#listing3-10">Listing 3-10</a> by giving it a writer and running it in a goroutine. You can then read pings from the reader at the expected intervals and reset the ping timer with different intervals.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "context"&#13;
    "fmt"&#13;
    "io"&#13;
    "time"&#13;
)&#13;
&#13;
func ExamplePinger() {&#13;
    ctx, cancel := context.WithCancel(context.Background())&#13;
    r, w := io.Pipe() // in lieu of net.Conn&#13;
    done := make(chan struct{})&#13;
   <span class="CodeAnnotationHang">1</span>  resetTimer := make(chan time.Duration, 1)&#13;
    resetTimer &lt;- time.Second // initial ping interval&#13;
&#13;
    go func() {&#13;
        Pinger(ctx, w, resetTimer)&#13;
        close(done)&#13;
    }()&#13;
&#13;
    receivePing := func(d time.Duration, r io.Reader) {&#13;
        if d &gt;= 0 {&#13;
            fmt.Printf("resetting timer (%s)\n", d)&#13;
            resetTimer &lt;- d&#13;
        }&#13;
&#13;
        now := time.Now()&#13;
        buf := make([]byte, 1024)&#13;
        n, err := r.Read(buf)&#13;
<span epub:type="pagebreak" id="Page_67" title="67"/>        if err != nil {&#13;
            fmt.Println(err)&#13;
        }&#13;
&#13;
        fmt.Printf("received %q (%s)\n",&#13;
            buf[:n], time.Since(now).Round(100*time.Millisecond))&#13;
    }&#13;
&#13;
   <span class="CodeAnnotationHang">2</span>  for i, v := range []int64{0, 200, 300, 0, -1, -1, -1} {&#13;
        fmt.Printf("Run %d:\n", i+1)&#13;
        receivePing(time.Duration(v)*time.Millisecond, r)&#13;
    }&#13;
&#13;
    cancel()&#13;
    &lt;-done // ensures the pinger exits after canceling the context&#13;
&#13;
    // Output:&#13;
   <span class="CodeAnnotationHang">3</span>  // Run 1:&#13;
    // resetting timer (0s)&#13;
    // received "ping" (1s)&#13;
   <span class="CodeAnnotationHang">4</span>  // Run 2:&#13;
    // resetting timer (200ms)&#13;
    // received "ping" (200ms)&#13;
   <span class="CodeAnnotationHang">5</span>  // Run 3:&#13;
    // resetting timer (300ms)&#13;
    // received "ping" (300ms)&#13;
   <span class="CodeAnnotationHang">6</span>  // Run 4:&#13;
    // resetting timer (0s)&#13;
    // received "ping" (300ms)&#13;
   <span class="CodeAnnotationHang">7</span>  // Run 5:&#13;
    // received "ping" (300ms)&#13;
    // Run 6:&#13;
    // received "ping" (300ms)&#13;
    // Run 7:&#13;
    // received "ping" (300ms)&#13;
&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-11">Listing 3-11</a>: Testing the pinger and resetting its ping timer interval (<em>ping_example_test.go</em>)</p>&#13;
<p>In this example, you create a buffered channel <span class="CodeAnnotation">1</span> that you’ll use to signal a reset of the <code>Pinger</code>’s timer. You put an initial ping interval of one second on the <code>resetTimer</code> channel before passing the channel to the <code>Pinger</code> function. You’ll use this duration to initialize the <code>Pinger</code>’s timer and dictate when to write the ping message to the writer.</p>&#13;
<p>You run through a series of millisecond durations in a loop <span class="CodeAnnotation">2</span>, passing each to the <code>receivePing</code> function. This function resets the ping timer to the given duration and then waits to receive the ping message on the given reader. Finally, it prints to stdout the time it takes to receive the ping message. Go checks stdout against the expected output in the example.</p>&#13;
<p>During the first iteration <span class="CodeAnnotation">3</span>, you pass in a duration of zero, which tells the <code>Pinger</code> to reset its timer by using the previous duration—one second in this example. As expected, the reader receives the ping message after one <span epub:type="pagebreak" id="Page_68" title="68"/>second. The second iteration <span class="CodeAnnotation">4</span> resets the ping timer to 200 ms. Once this expires, the reader receives the ping message. The third run resets the ping timer to 300 ms <span class="CodeAnnotation">5</span>, and the ping arrives at the 300 ms mark.</p>&#13;
<p>You pass in a zero duration for run 4 <span class="CodeAnnotation">6</span>, preserving the 300 ms ping timer from the previous run. I find the technique of using zero durations to mean “use the previous timer duration” useful because I do not need to keep track of the initial ping timer duration. I can simply initialize the timer with the duration I want to use for the remainder of the TCP session and reset the timer by passing in a zero duration every time I need to preempt the transmission of the next ping message. Changing the ping timer duration in the future involves the modification of a single line as opposed to every place I send on the <code>resetTimer</code> channel.</p>&#13;
<p>Runs 5 to 7 <span class="CodeAnnotation">7</span> simply listen for incoming pings without resetting the ping timer. As expected, the reader receives a ping at 300 ms intervals for the last three runs.</p>&#13;
<p>With <a href="#listing3-10">Listing 3-10</a> saved to a file named <em>ping.go</em> and <a href="#listing3-11">Listing 3-11</a> saved to a file named <em>ping_example_test.go</em>, you can run the example by executing the following:</p>&#13;
<pre><code>$ <b>go test ping.go ping_example_test.go</b></code></pre>&#13;
<h4 id="h3-500884c03-0007">Advancing the Deadline by Using the Heartbeat</h4>&#13;
<p class="BodyFirst">Each side of a network connection could use a <code>Pinger</code> to advance its deadline if the other side becomes idle, whereas the previous examples showed only a single side using a <code>Pinger</code>. When either node receives data on the network connection, its ping timer should reset to stop the delivery of an unnecessary ping. <a href="#listing3-12" id="listinganchor3-12">Listing 3-12</a> is a new file named <em>ping_test.go</em> that shows how you can use incoming messages to advance the deadline.</p>&#13;
<pre><code>package ch03&#13;
&#13;
import (&#13;
    "context"&#13;
    "io"&#13;
    "net"&#13;
    "testing"&#13;
    "time"&#13;
)&#13;
&#13;
func TestPingerAdvanceDeadline(t *testing.T) {&#13;
    done := make(chan struct{})&#13;
    listener, err := net.Listen("tcp", "127.0.0.1:")&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
&#13;
    begin := time.Now()&#13;
    go func() {&#13;
        defer func() { close(done) }()&#13;
<span epub:type="pagebreak" id="Page_69" title="69"/>        conn, err := listener.Accept()&#13;
        if err != nil {&#13;
            t.Log(err)&#13;
            return&#13;
        }&#13;
        ctx, cancel := context.WithCancel(context.Background())&#13;
        defer func() {&#13;
            cancel()&#13;
            conn.Close()&#13;
        }()&#13;
&#13;
        resetTimer := make(chan time.Duration, 1)&#13;
        resetTimer &lt;- time.Second&#13;
        go Pinger(ctx, conn, resetTimer)&#13;
&#13;
        err = conn.SetDeadline(time.Now().Add(<span class="CodeAnnotation">1</span>5 * time.Second))&#13;
        if err != nil {&#13;
            t.Error(err)&#13;
            return&#13;
        }&#13;
&#13;
        buf := make([]byte, 1024)&#13;
        for {&#13;
            n, err := conn.Read(buf)&#13;
            if err != nil {&#13;
                return&#13;
            }&#13;
            t.Logf("[%s] %s", &#13;
                time.Since(begin).Truncate(time.Second), buf[:n])&#13;
&#13;
           <span class="CodeAnnotationHang">2</span>  resetTimer &lt;- 0&#13;
            err = <span class="CodeAnnotation">3</span>conn.SetDeadline(time.Now().Add(5 * time.Second))&#13;
            if err != nil {&#13;
                t.Error(err) &#13;
                return&#13;
            }&#13;
        }&#13;
    }()&#13;
&#13;
    conn, err := net.Dial("tcp", listener.Addr().String())&#13;
    if err != nil {&#13;
        t.Fatal(err)&#13;
    }&#13;
    defer conn.Close()&#13;
&#13;
    buf := make([]byte, 1024)&#13;
   <span class="CodeAnnotationHang">4</span>  for i := 0; i &lt; 4; i++ { // read up to four pings&#13;
        n, err := conn.Read(buf)&#13;
        if err != nil {&#13;
            t.Fatal(err)&#13;
        }&#13;
        t.Logf("[%s] %s", time.Since(begin).Truncate(time.Second), buf[:n])&#13;
    }&#13;
    _, err = <span class="CodeAnnotation">5</span>conn.Write([]byte("PONG!!!")) // should reset the ping timer&#13;
    if err != nil {&#13;
<span epub:type="pagebreak" id="Page_70" title="70"/>        t.Fatal(err)&#13;
    }&#13;
   <span class="CodeAnnotationHang">6</span>  for i := 0; i &lt; 4; i++ { // read up to four more pings&#13;
        n, err := conn.Read(buf)&#13;
        if err != nil {&#13;
            if err != io.EOF {&#13;
                t.Fatal(err)&#13;
            }&#13;
            break&#13;
        }&#13;
        t.Logf("[%s] %s", time.Since(begin).Truncate(time.Second), buf[:n])&#13;
    }&#13;
    &lt;-done&#13;
    end := time.Since(begin).Truncate(time.Second)&#13;
    t.Logf("[%s] done", end)&#13;
    if end != <span class="CodeAnnotation">7</span>9*time.Second {&#13;
        t.Fatalf("expected EOF at 9 seconds; actual %s", end)&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing3-12">Listing 3-12</a>: Receiving data advances the deadline (<em>ping_test.go</em>)</p>&#13;
<p>You start a listener that accepts a connection, spins off a <code>Pinger</code> set to ping every second, and sets the initial deadline to five seconds <span class="CodeAnnotation">1</span>. From a client’s perspective, it receives four pings followed by an <code>io.EOF</code> when the server reaches its deadline and terminates its side of the connection. However, a client can advance the server’s deadline by sending the server data <span class="CodeAnnotation">5</span> before the server reaches its deadline.</p>&#13;
<p>If the server reads data from its connection, it can be confident the network connection is still good. Therefore, it can inform the <code>Pinger</code> to reset <span class="CodeAnnotation">2</span> its timer and push the connection’s deadline forward <span class="CodeAnnotation">3</span>. To preempt the termination of the socket, the client listens for four ping messages <span class="CodeAnnotation">4</span> from the server before sending an emphatic pong message <span class="CodeAnnotation">5</span>. This should buy the client five more seconds until the server reaches its deadline. The client reads four more pings <span class="CodeAnnotation">6</span> and then waits for the inevitable. You check that a total of nine seconds <span class="CodeAnnotation">7</span> has elapsed by the time the server terminates the connection, indicating the client’s pong successfully triggered the reset of the ping timer.</p>&#13;
<p>In practice, this method of advancing the ping timer cuts down on the consumption of bandwidth by unnecessary pings. There is rarely a need to challenge the remote side of a network connection if you just received data on the connection.</p>&#13;
<p>The strings <code>"ping"</code> and <code>"pong"</code> are arbitrary. You could use smaller payloads, such as a single byte, for the same purpose, provided both sides of the network connection agree upon what values constitute a ping and a pong.</p>&#13;
<h2 id="h1-500884c03-0004"><span epub:type="pagebreak" id="Page_71" title="71"/>What You’ve Learned</h2>&#13;
<p class="BodyFirst">We covered a lot of ground in this chapter. We started with a dive into TCP’s handshake, sequences, and acknowledgments, the sliding window, and connection terminations. Then, we covered the process of establishing TCP connections using Go’s standard library. We talked about temporary errors, time-outs, listening for incoming connections, and dialing remote services. Finally, we covered techniques to help you detect and timely correct network integrity issues.</p>&#13;
<p>I strongly recommend picking up <em>Practical Packet Analysis</em> by Chris Sanders (No Starch Press, 2017) and installing Wireshark. Manipulating your network code and seeing how it affects TCP traffic in Wireshark is a fantastic way to gain a deeper understanding of both TCP and Go’s networking packages. The next chapter covers sending and receiving data over TCP connections. Wireshark will help you gain a deeper understanding of data you send, including each payload’s effects on the sliding window. Familiarizing yourself with it now will pay dividends.</p>&#13;
</section>&#13;
</body></html>