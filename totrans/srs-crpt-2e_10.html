<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_139" aria-label="139"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch7">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">KEYED HASHING</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">The hash functions in <span class="chapterintro_Xref"><a href="chapter6.xhtml">Chapter 6</a></span> take a message and return its hash value—typically a short string of 256 or 512 bits. Anyone can compute the hash value of a message and verify that a particular message hashes to a particular value. When you want only specific people to compute hashes, however, you’ll hash with secret keys using <i>keyed</i> hash functions.</p>&#13;
<p class="TX">Keyed hashing forms the basis of two types of cryptographic algorithms: <i>message authentication codes (MACs)</i>, which authenticate a message and protect its integrity, and <i>pseudorandom functions (PRFs)</i>, which produce random-looking hash-sized values. We’ll look at the similarities between MACs and PRFs in the first section of this chapter before reviewing how MACs and PRFs work. Some MACs and PRFs are based on hash functions, some are based on block ciphers, and others are original designs. Finally, we’ll discuss examples of attacks on otherwise-secure MACs.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_140" aria-label="140"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-47"/><samp class="SANS_Futura_Std_Bold_B_11">Message Authentication Codes</samp></h3>&#13;
<p class="TNI">A MAC protects a message’s integrity and authenticity by creating a value <i>T</i> = <b>MAC</b>(<i>K</i>, <i>M</i>), called the authentication tag of the message, <i>M</i> (often confusingly called the MAC of <i>M</i>). Just as you can decrypt a message if you know a cipher’s key, you can validate that a message hasn’t been modified if you know a MAC’s key.</p>&#13;
<p class="TX">For example, say Alex and Bill share a key, <i>K</i>, and Alex sends a message, <i>M</i>, to Bill along with its authentication tag, <i>T</i> = <b>MAC</b>(<i>K</i>, <i>M</i>). Upon receiving the message and its authentication tag, Bill recomputes <b>MAC</b>(<i>K</i>, <i>M</i>) and checks that it’s equal to the authentication tag received. Because only Alex could have computed this value, Bill knows that the message wasn’t corrupted in transit (confirming its integrity), whether accidentally or maliciously, and that Alex sent that message (confirming its authenticity).</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-84"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">MACs in Secure Communication</samp></h4>&#13;
<p class="TNI">Secure communication systems often combine a cipher and a MAC to protect a message’s confidentiality, integrity, and authenticity. For example, the protocols in Internet Protocol Security (IPsec), SSH, and TLS generate a MAC for each transmitted network packet.</p>&#13;
<p class="TX">Not all communication systems use MACs. Sometimes an authentication tag can add unacceptable overhead to each packet, typically in the range of 64 to 128 bits. For example, the old GSM mobile telephony standard encrypted packets encoding voice calls but didn’t authenticate them. An attacker could modify the encrypted audio signal, and the recipient wouldn’t notice.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-85"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Forgery and Chosen-Message Attacks</samp></h4>&#13;
<p class="TNI">What does it mean for a MAC to be secure? First, as with a cipher, the secret key should remain secret. If a MAC is secure, an attacker shouldn’t be able to create a tag of some message if they don’t know the key. We call a fabricated message/tag pair a <i>forgery</i>, and recovering a key is a specific case of a more general class of <i>forgery attacks</i>. The security notion that posits that forgeries should be impossible to find is <i>unforgeability</i>. It should also be impossible to recover the secret key from a list of tags; otherwise, attackers could forge tags using the key.</p>&#13;
<p class="TX">What can an attacker do to break a MAC? In other words, what’s the attack model? The most basic attack model is the <i>known-message attack</i>, which passively collects messages and their associated tags (for example, by eavesdropping on a network). But real attackers can often launch <i>active</i> attacks because they can choose the messages to be authenticated and therefore get the MAC of the message they want. The standard model is thus <i>chosen-message attacks</i>, wherein attackers get tags for messages of their choice.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_141" aria-label="141"/>&#13;
<h4 class="H2" id="sec4"><span id="h2-86"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replay Attacks</samp></h4>&#13;
<p class="TNI">MACs aren’t safe from attacks involving <i>replays</i> of tags. For example, if you were to eavesdrop on Alex and Bill’s communications, you could capture a message and its tag sent by Alex to Bill and later send them again to Bill pretending to be Alex. To prevent such <i>replay attacks</i>, protocols include a message number in each message. This number is incremented for each new message and authenticated along with the message by the MAC. The receiving party gets messages numbered 1, 2, 3, 4, and so on. Thus, if an attacker tries to send message 1 again, the receiver notices that this message is out of order and that it’s a potential replay of the earlier message 1.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H1" id="sec5"><span id="h1-48"/><samp class="SANS_Futura_Std_Bold_B_11">Pseudorandom Functions</samp></h3>&#13;
<p class="TNI">A PRF uses a secret key to return <b>PRF</b>(<i>K</i>, <i>M</i>), such that the output looks random. Because the key is secret, the output values are unpredictable to an attacker.</p>&#13;
<p class="TX">Unlike MACs, PRFs are not meant to be used on their own but as part of a cryptographic algorithm or protocol. For example, you can use PRFs to create block ciphers within the Feistel construction—see “<span class="Xref">How to Construct Block Ciphers</span>” in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. Key derivation schemes use PRFs to generate cryptographic keys from a master key or password, and identification schemes use PRFs to generate a response from a random challenge. (Basically, a server sends a random challenge message, <i>M</i>, and the client returns <b>PRF</b>(<i>K</i>, <i>M</i>) in its response to prove that it knows <i>K</i>.) The 5G telephony standard uses a PRF to authenticate a SIM card and its service provider, and a similar PRF generates the encryption key and MAC key to be used during a phone call. The TLS protocol uses a PRF to generate key material from a master secret as well as session-specific random values. There’s even a PRF in the noncryptographic <samp class="SANS_TheSansMonoCd_W5Regular_11">hash()</samp> function built into the Python language to compare objects.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-87"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRF Security</samp></h4>&#13;
<p class="TNI">To be secure, a pseudorandom function should have no pattern that sets its outputs apart from truly random values. An attacker who doesn’t know the key, <i>K</i>, shouldn’t be able to distinguish the outputs of <b>PRF</b>(<i>K</i>, <i>M</i>) from random values. Viewed differently, an attacker shouldn’t have any means of knowing whether they’re talking to a PRF algorithm or to a random function. The erudite phrase for that security notion is “ indistinguishability from a random function.” (To learn more about the theoretical foundations of PRFs, see Volume 1, Section 3.6 of Goldreich’s <i>Foundations of Cryptography</i>.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-88"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">PRFs Are Stronger Than MACs</samp></h4>&#13;
<p class="TNI">PRFs and MACs are keyed hashes, but PRFs are fundamentally stronger than MACs because MACs have weaker security requirements. Whereas you <span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label="142"/>would consider a MAC secure if an attacker can’t forge tags—that is, if they can’t guess the MAC’s outputs—a PRF is secure only if its outputs are indistinguishable random strings. If you can’t distinguish a PRF’s outputs from random strings, this implies their values can’t be guessed; in other words, any secure PRF is also a secure MAC.</p>&#13;
<p class="TX">The converse is not true, however: a secure MAC isn’t necessarily a secure PRF. For example, say you start with a secure PRF, <b>PRF1</b>, and you want to build a second PRF, <b>PRF2</b>, from it, like this:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg142-1.jpg" alt="" width="1384" height="52"/></figure>&#13;
<p class="TX">Because <b>PRF2</b>’s output is defined as <b>PRF1</b>’s output followed by one 0 bit, it doesn’t look as random as a true random string, and you can distinguish its outputs by that last 0 bit. Hence, <b>PRF2</b> is not a secure PRF. However, because <b>PRF1</b> is secure, <b>PRF2</b> would still make a secure MAC. If you were able to forge a tag, <i>T</i> = <b>PRF2</b>(<i>K</i>, <i>M</i>), for some <i>M</i>, then you’d also be able to forge a tag for <b>PRF1</b>, which you know to be impossible in the first place because PRF1 is a secure MAC. Thus, PRF2 is a keyed hash that’s a secure MAC but not a secure PRF.</p>&#13;
<p class="TX">But don’t worry: you won’t find such MAC constructions in real applications. In fact, many of the deployed or standardized MACs are also secure PRFs and are often used as either. For example, TLS uses the algorithm HMAC-SHA-256 both as a MAC and as a PRF.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H1" id="sec8"><span id="h1-49"/><samp class="SANS_Futura_Std_Bold_B_11">How to Create Keyed Hashes from Unkeyed Hashes</samp></h3>&#13;
<p class="TNI">Throughout cryptography’s history, MACs and PRFs have rarely been designed from scratch but rather have been built from existing algorithms, usually hash functions or block ciphers. It might seem obvious that you can produce a keyed hash function by feeding an (unkeyed) hash function a key and a message, but this is easier said than done.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2" id="sec9"><span id="h2-89"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Secret-Prefix Construction</samp></h4>&#13;
<p class="TNI">The first technique we’ll examine, the <i>secret-prefix construction</i>, turns a normal hash function into a keyed hash by prepending the key to the message and returning <b>Hash</b>(<i>K</i> || <i>M</i>). This approach is insecure when the hash function is vulnerable to length-extension attacks (see “<span class="Xref">The Length-Extension Attack</span>” in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>) and when the hash supports keys of different lengths.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h5 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insecurity Against Length-Extension Attacks</samp></h5>&#13;
<p class="TNI">Recall from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> that hash functions of the SHA-2 family allow attackers to compute the hash of a partially unknown message when given a hash of a shorter version of that message. In formal terms, the length-extension attack allows attackers to compute <b>Hash</b>(<i>K</i> || <i>M</i><sub>1</sub> || <i>M</i><sub>2</sub>) given only <b>Hash</b>(<i>K</i> || <i>M</i><sub>1</sub>) and neither <i>M</i><sub>1</sub> nor <i>K</i>. These functions allow attackers to forge valid MAC tags for free because they shouldn’t be able to guess <span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label="143"/>the MAC of <i>M</i><sub>1</sub> || <i>M</i><sub>2</sub> given only the MAC of <i>M</i><sub>1</sub>. This fact makes the secret-prefix construction insecure as a MAC and PRF when, for example, using it with SHA-256 or SHA-512. It’s a weakness of Merkle–Damg<span class="accent">å</span>rd to allow length-extension attacks, and none of the SHA-3 finalists do. The ability to thwart length-extension attacks was mandatory for SHA-3 submissions (see <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Insecurity with Different Key Lengths</samp></h5>&#13;
<p class="TNI">The secret-prefix construction is also insecure when allowing the use of keys of different lengths. For example, if the key <i>K</i> is the 24-bit hexadecimal string 123abc and <i>M</i> is def00, then <b>Hash</b>() processes the value <i>K</i> || <i>M</i> = 123abcdef00. If <i>K</i> is instead the 16-bit string 123a and <i>M</i> is bcdef000, then <b>Hash</b>() processes <i>K</i> || <i>M</i> = 123abcdef00, too. Therefore, the result of the secret-prefix construction <b>Hash</b>(<i>K</i> || <i>M</i>) is the same for both keys.</p>&#13;
<p class="TX">This problem is independent of the underlying hash; you can fix it by hashing the key’s length along with the key and the message—for example, by encoding the key’s bit length as a 16-bit integer, <i>L</i>, and then hashing <b>Hash</b>(<i>L</i> || <i>K</i> || <i>M</i>). You shouldn’t have to do this, however, as modern hash functions such as BLAKE2 and SHA-3 include a keyed mode that avoids these pitfalls and yields a secure PRF and thus a secure MAC as well.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Secret-Suffix Construction</samp></h4>&#13;
<p class="TNI">Instead of hashing the key before the message as in the secret-prefix construction, you can hash it <i>after</i>. And that’s exactly how the <i>secret-suffix construction</i> works by building a PRF from a hash function as <b>Hash</b>(<i>M</i> || <i>K</i>).</p>&#13;
<p class="TX">Putting the key at the end makes quite a difference. The length-extension attack that works against secret-prefix MACs won’t work against the secret suffix. Applying length extension to a secret-suffix MAC results in <b>Hash</b>(<i>M</i><sub>1</sub> || <i>K</i> || <i>M</i><sub>2</sub>) from <b>Hash</b>(<i>M</i><sub>1</sub> || <i>K</i>), but this isn’t a valid attack because <b>Hash</b>(<i>M</i><sub>1</sub> || <i>K</i> || <i>M</i><sub>2</sub>) isn’t a valid secret-suffix MAC; the key needs to be at the end.</p>&#13;
<p class="TX">However, the secret-suffix construction is weaker against another type of attack. Say you’ve got a collision for the hash <b>Hash</b>(<i>M</i><sub>1</sub>) = <b>Hash</b>(<i>M</i><sub>2</sub>), where <i>M</i><sub>1</sub> and <i>M</i><sub>2</sub> are two distinct messages, possibly of different sizes. In the case of an M–D hash function such as SHA-256, this implies that <b>Hash</b>(<i>M</i><sub>1</sub> || <i>P</i><sub>1</sub> || <i>K</i>) and <b>Hash</b>(<i>M</i><sub>2</sub> || <i>P</i><sub>2</sub> || <i>K</i>) will be equal too, where <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub> are the padding data added to complete a block. After processing <i>M</i><sub>1</sub> || <i>P</i><sub>1</sub>, the hash function’s state is the same as after processing <i>M</i><sub>2</sub> || <i>P</i><sub>2</sub>. Adding K to each instance preserves the equality of the state, leading to a collision regardless of <i>K</i>’s value.</p>&#13;
<p class="TX">To exploit this property, an attacker:</p>&#13;
<p class="NLF">  1.  Finds two colliding messages, <i>M</i><sub>1</sub> and <i>M</i><sub>2</sub></p>&#13;
<p class="NL">  2.  Requests the MAC tag of <i>M</i><sub>1</sub>, <b>Hash</b>(<i>M</i><sub>1</sub> || <i>K</i>)</p>&#13;
<p class="NLL">  3.  Guesses that <b>Hash</b>(<i>M</i><sub>2</sub> || <i>K</i>) is the same, thereby forging a valid tag and breaking the MAC’s security</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label="144"/>&#13;
<h4 class="H2" id="sec13"><span id="h2-91"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The HMAC Construction</samp></h4>&#13;
<p class="TNI">The <i>hash-based MAC (HMAC)</i> construction allows you to build a MAC from a hash function, which is more secure than either secret prefix or secret suffix. HMAC yields a secure PRF as long as the underlying hash is collision resistant, but even if that isn’t the case, HMAC still yields a secure PRF if the hash’s compression function is a PRF. The secure communication protocols IPsec, SSH, and TLS have all used HMAC. (You’ll find HMAC specifications in the NIST FIPS 198-1 standard and in RFC 2104.)</p>&#13;
<p class="TX">HMAC uses a hash function, <b>Hash</b>, to compute a MAC tag, as <a href="chapter7.xhtml#fig7-1">Figure 7-1</a> shows and according to the following expression:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg144-1.jpg" alt="" width="1388" height="44"/></figure>&#13;
<p class="TX">The value <i>opad</i> (outer padding) is the hexadecimal string <samp class="SANS_TheSansMonoCd_W5Regular_11">5c5c5c. . .5c</samp> as long as <b>Hash</b>’s block size. The key, <i>K</i>, is usually shorter than one block that’s filled with <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes and XORed with <i>opad</i>. For example, if <i>K</i> is the 1-byte string <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>, then <i>K</i> <span class="symbol">⊕</span> <i>opad</i> = <i>opad</i>. (The same is true if <i>K</i> is the all-zero string of any length up to a block’s length.) <i>K</i> <span class="symbol">⊕</span> <i>opad</i> is the first block processed by the outer call to <b>Hash</b>—namely, the leftmost <b>Hash</b> in the preceding equation, or the bottom hash in <a href="chapter7.xhtml#fig7-1">Figure 7-1</a>.</p>&#13;
<figure class="IMG"><img id="fig7-1" class="img1" src="../images/fig7-1.jpg" alt="" width="1308" height="489"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The HMAC hash-based MAC construction for a hash function based on a compression function</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The value <i>ipad</i> (inner padding) is a string (363636 . . . 36) as long as the <b>Hash</b>’s block size and completed with 00 bytes. The resulting block is the first processed by the inner call to <b>Hash</b>—namely, the rightmost <b>Hash</b> in the equation, or the top hash in <a href="chapter7.xhtml#fig7-1">Figure 7-1</a>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The envelope method is a more secure construction than secret prefix or secret suffix. It’s expressed as</i> <b><i>Hash</i></b><i>(</i><span class="note_Italic">K</span> <i>||</i> <span class="note_Italic">M</span> <i>||</i> <span class="note_Italic">K</span><i>), a</i> <span class="note_Italic">sandwich MAC</span><i>, but it’s theoretically less secure than HMAC.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label="145"/>If SHA-256 is the hash function used as <b>Hash</b>, then you call the HMAC instance HMAC-SHA-256. More generally, you call HMAC-<i>Hash</i> an HMAC instance using the hash function <i>Hash</i>. That means if someone asks you to use HMAC, you should always ask, “Which hash function?”</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Generic Attack Against Hash-Based MACs</samp></h4>&#13;
<p class="TNI">There is one attack that works against all MACs based on an iterated hash function. Recall the attack in “<span class="Xref">The Secret-Suffix Construction</span>” on <span class="Xref"><a href="#sec12">page 143</a></span> where we used a hash collision to get a collision of MACs. You can use the same strategy to attack a secret-prefix MAC or HMAC, though the consequences are less devastating.</p>&#13;
<p class="TX"><a href="chapter7.xhtml#fig7-2">Figure 7-2</a> illustrates the secret-prefix MAC <b>Hash</b>(<i>K</i> || <i>M</i>).</p>&#13;
<figure class="IMG"><img id="fig7-2" class="img1" src="../images/fig7-2.jpg" alt="" width="1383" height="496"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: The principle of the generic forgery attack on hash-based MACs</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If the digest is <i>n</i> bits, you can find two messages, <i>M</i><sub>1</sub> and <i>M</i><sub>2</sub>, such that <b>Hash</b>(<i>K</i> || <i>M</i><sub>1</sub>) = <b>Hash</b>(<i>K</i> || <i>M</i><sub>2</sub>), by requesting approximately 2<i><sup>n</sup></i><sup>/2</sup> MAC tags to the system holding the key. (Recall the birthday attack from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.) If the hash lends itself to length extension, as SHA-256 does, you can then use <i>M</i><sub>1</sub> and <i>M</i><sub>2</sub> to forge MACs by choosing some arbitrary data, <i>M</i><sub>3</sub>, and then querying the MAC oracle for <b>Hash</b>(<i>K</i> || <i>M</i><sub>1</sub> || <i>M</i><sub>3</sub>), which is the MAC of message <i>M</i><sub>1</sub> || <i>M</i><sub>3</sub>. As it turns out, this is also the MAC of message <i>M</i><sub>2</sub> || <i>M</i><sub>3</sub> because the hash’s internal state of <i>M</i><sub>1</sub> and <i>M</i><sub>3</sub> and <i>M</i><sub>2</sub> and <i>M</i><sub>3</sub> is the same. You’ve successfully forged a MAC tag. (The effort becomes infeasible as <i>n</i> grows beyond, say, 128 bits.)</p>&#13;
<p class="TX">This attack works even if the hash function isn’t vulnerable to length extension, and it works for HMAC, too. This is because all that’s required is an internal collision in the hash function and not necessarily in the complete hash. The cost of the attack depends on both the size of the chaining value and the MAC’s length: if a MAC’s chaining value is 512 bits and its tags are 128 bits, a 2<sup>64</sup> computation would find a MAC collision but probably not a collision in the internal state, since finding such a collision requires 2<sup>512/2</sup> = 2<sup>256</sup> operations on average.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label="146"/>&#13;
<h3 class="H1" id="sec15"><span id="h1-50"/><samp class="SANS_Futura_Std_Bold_B_11">How to Create Keyed Hashes from Block Ciphers</samp></h3>&#13;
<p class="TNI">The compression functions in many hash functions are built on block ciphers (see <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>). For example, HMAC-SHA-256 PRF is a series of calls to SHA-256’s compression function, which is a block cipher that repeats a sequence of rounds. In other words, HMAC-SHA-256 is a block cipher inside a compression function inside a hash inside the HMAC construction. So why not use a block cipher directly rather than build such a layered construction?</p>&#13;
<p class="TX"><i>Cipher-based MAC (CMAC)</i> is such a construction: it creates a MAC given only a block cipher, such as AES. Though less popular than HMAC, CMAC is deployed in many systems, including the Internet Key Exchange (IKE) protocol, which is part of the IPsec suite. IKE, for example, generates key material using the AES-CMAC-PRF-128 construction as a core algorithm (or CMAC based on AES with 128-bit output). CMAC is specified in RFC 4493.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Breaking CBC-MAC</samp></h4>&#13;
<p class="TNI">CMAC was designed in 2005 as an improved version of <i>CBC-MAC</i>, a simpler block cipher–based MAC derived from the cipher block chaining (CBC) block cipher mode of operation (see “<span class="Xref">Modes of Operation</span>” in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>).</p>&#13;
<p class="TX">CBC-MAC, the ancestor of CMAC, is simple: to compute the tag of a message, <i>M</i>, given a block cipher, <b>E</b>, encrypt <i>M</i> in CBC mode with an all-zero initial value (IV) and discard all but the last ciphertext block. That is, compute</p>&#13;
<p class="Equation"><i>C</i><sub>1</sub> = <b>E</b>(<i>K</i>, <i>M</i><sub>1</sub>), <i>C</i><sub>2</sub> = <b>E</b>(<i>K</i>, <i>M</i><sub>2</sub> <span class="symbol">⊕</span> <i>C</i><sub>1</sub>), <i>C</i><sub>3</sub> = <b>E</b>(<i>K</i>, <i>M</i><sub>3</sub> <span class="symbol">⊕</span> <i>C</i><sub>2</sub>)</p>&#13;
<p class="Continued">and so on for each of <i>M</i>’s blocks and keep only the last <i>C</i><span class="ePub-I-SUB">i</span>—your CBC-MAC tag for <i>M</i>—simple, and simple to attack.</p>&#13;
<p class="TX">To understand why CBC-MAC is insecure, consider the CBC-MAC tag, <i>T</i><sub>1</sub> = <b>E</b>(<i>K</i>, <i>M</i><sub>1</sub>), of a single-block message, <i>M</i><sub>1</sub>, and the tag, <i>T</i><sub>2</sub> = <b>E</b>(<i>K</i>, <i>M</i><sub>2</sub>), of another single-block message, <i>M</i><sub>2</sub>. Given these two pairs, (<i>M</i><sub>1</sub>, <i>T</i><sub>1</sub>) and (<i>M</i><sub>2</sub>, <i>T</i><sub>2</sub>), you can deduce that <i>T</i><sub>2</sub> is also the tag of the two-block message <i>M</i><sub>1</sub> || (<i>M</i><sub>2</sub> <span class="symbol">⊕</span> <i>T</i><sub>1</sub>). If you apply CBC-MAC to <i>M</i><sub>1</sub> || (<i>M</i><sub>2</sub> <span class="symbol">⊕</span> <i>T</i><sub>1</sub>) and compute <i>C</i><sub>1</sub> = <b>E</b>(<i>K</i>, <i>M</i><sub>1</sub>) = <i>T</i><sub>1</sub> followed by <i>C</i><sub>2</sub> = <b>E</b>(<i>K</i>, (<i>M</i><sub>2</sub> <span class="symbol">⊕</span> <i>T</i><sub>1</sub>) <span class="symbol">⊕</span> <i>T</i><sub>1</sub>) = <b>E</b>(<i>K</i>, <i>M</i><sub>2</sub>) = <i>T</i><sub>2</sub>, you can create a third message/tag pair from two message/tag pairs without knowing the key. That is, you can forge CBC-MAC tags, thereby breaking CBC-MAC’s security.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-94"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing CBC-MAC</samp></h4>&#13;
<p class="TNI">CMAC fixes CBC-MAC by processing the last block using a different key from the preceding blocks. To do this, CMAC first derives two keys, <i>K</i><sub>1</sub> and <i>K</i><sub>2</sub>, from the main key, <i>K</i>, such that <i>K</i>, <i>K</i><sub>1</sub>, and <i>K</i><sub>2</sub> are distinct. CMAC processes the last block using either <i>K</i><sub>1</sub> or <i>K</i><sub>2</sub>, while the preceding blocks use <i>K</i>.</p>&#13;
<p class="TX">To determine <i>K</i><sub>1</sub> and <i>K</i><sub>2</sub>, CMAC first computes a temporary value, <i>L</i> = <b>E</b>(0, <i>K</i>), where 0 acts as the key of the block cipher and <i>K</i> acts as the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label="147"/>plaintext block. Then CMAC sets <i>K</i><sub>1</sub> to (<i>L</i> &lt;&lt; 1) if <i>L</i>’s most significant bit (MSB) is 0 and to (<i>L</i> &lt;&lt; 1) <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp> if <i>L</i>’s MSB is 1. (The hexadecimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp>, or 135 in decimal, is chosen for its mathematical properties when data blocks are 128 bits; a different value is needed when blocks aren’t 128 bits.) The key <i>K</i><sub>2</sub> is set to (<i>K</i><sub>1</sub> &lt;&lt; 1) if <i>K</i><sub>1</sub>’s MSB is 0 and to <i>K</i><sub>2</sub> = (<i>K</i><sub>1</sub> &lt;&lt; 1) <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">87</samp> otherwise.</p>&#13;
<p class="TX">Given <i>K</i><sub>1</sub> and <i>K</i><sub>2</sub>, CMAC works like CBC-MAC, except for the last block. If the final message chunk <i>M</i><span class="ePub-I-SUB">n</span> is exactly the size of a block, CMAC returns <b>E</b>(<i>K</i>, <i>M</i><span class="ePub-I-SUB">n</span> <span class="symbol">⊕</span> <i>C</i><span class="ePub-I-SUB">n</span> <sub>− 1</sub> <span class="symbol">⊕</span> <i>K</i><sub>1</sub>) as a tag, as <a href="chapter7.xhtml#fig7-3">Figure 7-3</a> illustrates.</p>&#13;
<figure class="IMG"><img id="fig7-3" class="img7" src="../images/fig7-3.jpg" alt="" width="621" height="332"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The CMAC block cipher–based MAC construction when the message is a sequence of integral blocks</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If <i>M</i><span class="ePub-I-SUB">n</span> has fewer bits than a block, CMAC pads it with a 1 bit and 0s and returns <b>E</b>(<i>K</i>, <i>M</i><span class="ePub-I-SUB">n</span> <span class="symbol">⊕</span> <i>C</i><span class="ePub-I-SUB">n</span> <sub>− 1</sub> <span class="symbol">⊕</span> <i>K</i><sub>2</sub>) as a tag, as in <a href="chapter7.xhtml#fig7-4">Figure 7-4</a>.</p>&#13;
<figure class="IMG"><img id="fig7-4" class="img7" src="../images/fig7-4.jpg" alt="" width="624" height="335"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: The CMAC block cipher–based MAC construction when the last block of the message has to be padded with 1 bit and zeros to fill a block</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first case uses only <i>K</i><sub>1</sub> and the second only <i>K</i><sub>2</sub>, but both use the main key <i>K</i> to process the message chunks that precede the final one.</p>&#13;
<p class="TX">Unlike the CBC encryption mode, CMAC doesn’t take an IV as a parameter and is deterministic: for the same key, CMAC always returns the same tag for a given message, <i>M</i>, because the computation of <b>CMAC</b>(<i>M</i>) isn’t randomized—and that’s fine because unlike encryption, MAC computation doesn’t have to be randomized to be secure, which eliminates the burden of having to choose random IV.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label="148"/>&#13;
<h3 class="H1" id="sec18"><span id="h1-51"/><samp class="SANS_Futura_Std_Bold_B_11">Dedicated MAC Designs</samp></h3>&#13;
<p class="TNI">You’ve seen how to recycle hash functions and block ciphers to build PRFs that are secure as long as their underlying hash or cipher is secure. Schemes such as HMAC and CMAC simply combine available hash functions or block ciphers to yield a secure PRF or MAC. Reusing available algorithms is convenient, but is it the most efficient approach?</p>&#13;
<p class="TX">Intuitively, PRFs and MACs should require less work to be secure than unkeyed hash functions—their use of a secret key prevents attackers from playing with the algorithm because they don’t have the key. Also, PRFs and MACs expose only a short tag to attackers, unlike block ciphers, which expose a ciphertext as long as the message. Hence, PRFs and MACs shouldn’t need the maximum power of hash functions or block ciphers—this is the point of <i>dedicated design</i>, that is, algorithms created solely to serve as PRFs or MACs.</p>&#13;
<p class="TX">The sections that follow focus on two such algorithms: Poly1305 and SipHash. I’ll explain their design principles and why they’re (most likely) secure.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Poly1305</samp></h4>&#13;
<p class="TNI">The Poly1305 algorithm (pronounced <i>poly</i>-<i>thirteen</i>-<i>o-five</i>) was designed in 2005 by Daniel J. Bernstein (creator of the Salsa20 stream cipher from <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> and the ChaCha cipher that inspired the BLAKE and BLAKE2 hash functions from <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>). Poly1305 is optimized to be superfast on modern CPUs, and as I write this, it’s one of the algorithms supported in TLS 1.3 and in OpenSSH, among many other applications. Unlike Salsa20, the design of Poly1305 is built on techniques dating back to the 1970s—namely, universal hash functions and the Wegman–Carter construction.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h5 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Universal Hash Functions</samp></h5>&#13;
<p class="TNI">The Poly1305 MAC uses a <i>universal hash function</i>. Such a hash function is weaker than a cryptographic hash function but much faster. Universal hash functions don’t have to be collision resistant, for example.</p>&#13;
<p class="TX">Like a PRF, a universal hash is parameterized by a secret key: given a message, <i>M</i>, and key, <i>K</i>, we’ll write <b>UH</b>(<i>K</i>, <i>M</i>) for the output of a universal hash function denoted <b>UH</b>. A universal hash function has only one security requirement: for any two messages <i>M</i><sub>1</sub> and <i>M</i><sub>2</sub>, and a random key <i>K</i>, the probability that <b>UH</b>(<i>K</i>, <i>M</i><sub>1</sub>) equals <b>UH</b>(<i>K</i>, <i>M</i><sub>2</sub>) must be negligible. Unlike a PRF, a universal hash doesn’t need to be pseudorandom; there simply should be no pair (<i>M</i><sub>1</sub>, <i>M</i><sub>2</sub>) that gives the same hash for many different keys. Because their security requirements are easier to satisfy, universal hash functions require fewer operations and are considerably faster than PRFs.</p>&#13;
<p class="TX">You can use a universal hash as a MAC to authenticate no more than one message, however. For example, consider the universal <i>polynomial-evaluation</i> hash used in Poly1305. (See the seminal 1974 article “Codes Which Detect Deception” by Edgar Gilbert, Jessie MacWilliams, and Neil <span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label="149"/>Sloane for more on this notion.) This kind of polynomial-evaluation hash is parameterized by a prime number, <i>p</i>, and takes as input a key consisting of two numbers, <i>R</i> and <i>K</i>, in the range [1, <i>p</i>) and a message, <i>M</i>, consisting of <i>n</i> blocks (<i>M</i><sub>1</sub>, <i>M</i><sub>2</sub>, . . . , <i>M</i><span class="ePub-I-SUB">n</span>). You then compute the output of the universal hash as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg149-1.jpg" alt="" width="1388" height="49"/></figure>&#13;
<p class="TX">In this equation, the plus sign (+) denotes the addition of positive integers, <i>K</i> <i><sup>i</sup></i> is the number <i>K</i> raised to the power <i>i</i>, and “mod <i>p</i>” denotes the reduction modulo <i>p</i> of the result (that is, the remainder of the division of the result by <i>p</i>; for example, 12 mod 10 = 2, 10 mod 10 = 0, 8 mod 10 = 8, and so on).</p>&#13;
<p class="TX">Because you want the hashing operation to be as fast as possible, universal hash-based MACs often work with message blocks of 128 bits and with a prime number, <i>p</i>, that’s slightly larger than 2<sup>128</sup>, such as 2<sup>128</sup> + 51. The 128-bit width allows for very fast implementations by efficiently using the 32- and 64-bit arithmetic units of common CPUs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Limitations</samp></h5>&#13;
<p class="TNI">Universal hashes have one weakness: because a universal hash securely authenticates only one message, an attacker could break the preceding polynomial-evaluation MAC by requesting the tags of only two messages. Specifically, they could request the tag for a message where all blocks are zero—<i>M</i><sub>1</sub> = <i>M</i><sub>2</sub> = . . . = 0—to obtain the tag <b>UH</b>(<i>R</i>, <i>K</i>, 0) = <i>R</i>, thus finding the secret value <i>R</i>. Alternatively, they could request the tags for a message where <i>M</i><sub>1</sub> = 1 and where <i>M</i><sub>2</sub> = <i>M</i><sub>3</sub> = . . . = 0 (whose tag is <i>T</i> = <i>R</i> + <i>K</i>), which allows them to find <i>K</i> by subtracting <i>R</i> from <i>T</i>. Now the attacker knows the whole key (<i>R</i>, <i>K</i>) and can forge MACs for any message.</p>&#13;
<p class="TX">Fortunately, there’s a way to go from single-message security to multimessage security.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wegman–Carter MACs</samp></h5>&#13;
<p class="TNI">The trick to authenticating multiple messages using a universal hash function arrived thanks to IBM researchers Mark Wegman and Lawrence Carter and their 1981 paper “New Hash Functions and Their Use in Authentication and Set Equality.” The Wegman–Carter construction builds a MAC from a universal hash function and a PRF, using two keys, <i>K</i><sub>1</sub> and <i>K</i><sub>2</sub>, and it returns</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg149-2.jpg" alt="" width="1388" height="52"/></figure>&#13;
<p class="Continued">where <i>N</i> is a nonce that must be used at most once for each key, <i>K</i><sub>2</sub>, and where <b>PRF</b>’s output is as large as that of the universal hash function <b>UH</b>. By adding these two values, <b>PRF</b>’s strong pseudorandom output masks the cryptographic weakness of <b>UH</b>. You can see this as the encryption of the universal hash’s result, where the PRF acts as a stream cipher and prevents <span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label="150"/>the preceding attack by making it possible to authenticate multiple messages with the same key, <i>K</i><sub>1</sub>.</p>&#13;
<p class="TX">To recap, the Wegman–Carter construction <b>UH</b>(<i>K</i><sub>1</sub>, <i>M</i>) + <b>PRF</b>(<i>K</i><sub>2</sub>, <i>N</i>) gives a secure MAC if you assume the following:</p>&#13;
<ul class="ul">&#13;
<li class="BL"><b>UH</b> is a secure universal hash.</li>&#13;
<li class="BL"><b>PRF</b> is a secure PRF.</li>&#13;
<li class="BL">Each nonce <i>N</i> is used only once for each key <i>K</i><sub>2</sub>.</li>&#13;
<li class="BL">The output values of <b>UH</b> and <b>PRF</b> are long enough to ensure high enough security.</li>&#13;
</ul>&#13;
<p class="TX">Now let’s see how Poly1305 leverages the Wegman–Carter construction to build a secure and fast MAC.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h5 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Poly1305-AES</samp></h5>&#13;
<p class="TNI">Poly1305 was initially proposed as Poly1305-AES, combining the Poly1305 universal hash with the AES block cipher. Poly1305-AES is much faster than HMAC-based MACs, or even than CMACs, since it computes only one block of AES and processes the message in parallel through a series of simple arithmetic operations.</p>&#13;
<p class="TX">Given 128-bit <i>K</i><sub>1</sub>, <i>K</i><sub>2</sub>, and <i>N</i> and the message <i>M</i>, Poly1305-AES returns the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg150-1.jpg" alt="" width="1393" height="52"/></figure>&#13;
<p class="TX">The mod 2<sup>128</sup> reduction ensures that the result fits in 128 bits. Poly1305 parses the message <i>M</i> as a sequence of 128-bit blocks (<i>M</i><sub>1</sub>, <i>M</i><sub>2</sub>, . . . , <i>M</i><span class="ePub-I-SUB">n</span>) and appends a 129th bit to each block’s most significant bit to make all blocks 129 bits long. (If the last block is smaller than 16 bytes, it’s padded with a 1 bit followed by 0 bits before the final 129th bit.) Next, Poly1305 evaluates the polynomial to compute the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg150-2.jpg" alt="" width="1393" height="50"/></figure>&#13;
<p class="TX">The result of this expression is an integer that’s at most 129 bits long. When you add this to the 128-bit value <b>AES</b>(<i>K</i><sub>2</sub>, <i>N</i>), the result is reduced modulo 2<sup>128</sup> to produce a 128-bit MAC.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>I described the Wegman–Carter as using a PRF, but AES isn’t a PRF, it’s a pseudorandom permutation (PRP). However, that doesn’t matter because the Wegman–Carter construction works well with PRPs and PRFs. This is because if you’re given a function that’s either a PRF or a PRP, it’s hard to determine whether it’s a PRF of a PRP just by looking at the function’s output values. In other words, distinguishing a PRP from a PRF is computationally hard.</i></p>&#13;
<p class="TX">The security analysis of Poly1305-AES (see “The Poly1305-AES Message- Authentication Code” at <i><a href="https://cr.yp.to/mac/poly1305-20050329.pdf">https://<wbr/>cr<wbr/>.yp<wbr/>.to<wbr/>/mac<wbr/>/poly1305<wbr/>-20050329<wbr/>.pdf</a></i>) shows <span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label="151"/>that Poly1305-AES is 128-bit secure as long as AES is a secure block cipher—and everything is implemented correctly, as with any cryptographic algorithm.</p>&#13;
<p class="TX">You can combine the Poly1305 universal hash with algorithms other than AES. For example, Poly1305 was used with the stream cipher ChaCha (see RFC 7539, “ChaCha20 and Poly1305 for IETF Protocols”). There’s no doubt that Poly1305 will continue being used wherever a fast MAC is needed.</p>&#13;
<p class="TX">Although Poly1305 is fast and secure, it has several downsides. For one, its polynomial evaluation is difficult to implement efficiently, especially in the hands of those unfamiliar with the associated mathematical notions. (See examples at <i><a href="https://github.com/floodyberry/poly1305-donna">https://<wbr/>github<wbr/>.com<wbr/>/floodyberry<wbr/>/poly1305<wbr/>-donna</a></i>.) Second, on its own, it’s secure for only one message unless you use the Wegman–Carter construction. But in that case it requires a nonce, and if the nonce is repeated, the algorithm becomes insecure. Finally, Poly1305 is optimized for long messages, but it’s overkill if you process only small messages (say, fewer than 128 bytes). In such cases, SipHash is a good solution.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h4 class="H2" id="sec24"><span id="h2-96"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SipHash</samp></h4>&#13;
<p class="TNI">I designed SipHash in 2012 with Dan Bernstein initially to address a noncryptographic problem: denial-of-service attacks on hash tables. Hash tables are data structures, notably used in programming languages to efficiently store elements internally. Prior to SipHash, hash tables relied on noncryptographic keyed hash functions for which collisions were often easy to find, which could be exploited to slow down the system and perform denial-of-service attacks. We observed that a PRF would address this problem and set out to design SipHash, a PRF suitable for hash tables. Because hash tables process mostly short inputs, SipHash is optimized for short messages. SipHash is a full-blown PRF and MAC that shines where most inputs are short.</p>&#13;
<p class="TX">SipHash uses a trick that makes it more secure than basic sponge functions: instead of XORing message blocks only once before the permutation, SipHash XORs them before and after the permutation, as <a href="chapter7.xhtml#fig7-5">Figure 7-5</a> illustrates. The 128-bit key of SipHash is seen as two 64-bit words, <i>K</i><sub>1</sub> and <i>K</i><sub>2</sub>, XORed to a 256-bit fixed initial state that’s seen as four 64-bit words. Next, the keys are discarded, and computing SipHash boils down to iterating through a core function called SipRound and then XORing message chunks to modify the four-word internal state. Finally, SipHash returns a 64-bit tag by XORing the four-state words together.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_152" aria-label="152"/>&#13;
<figure class="IMG"><img id="fig7-5" class="img1" src="../images/fig7-5.jpg" alt="" width="1161" height="486"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: SipHash-2-4 processing a 15-byte message (a block,</samp> <samp class="SANS_Futura_Std_Book_11">M</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, of 8 bytes and a block,</samp> <samp class="SANS_Futura_Std_Book_11">M</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">2</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, of 7 bytes, plus 1 byte of padding)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The SipRound function uses a bunch of XORs together with additions and word rotations to make the function secure. SipRound transforms a state of four 64-bit words (<i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>) by performing the following operations, top to bottom. The operations on the left and on the right are independent and can be carried out in parallel:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg152-1.jpg" alt="" width="1384" height="462"/></figure>&#13;
<p class="TX">Here, <i>a</i> += <i>b</i> is shorthand for <i>a</i> = <i>a</i> + <i>b</i>, and <i>b</i> &lt;&lt;&lt; = 13 is shorthand for <i>b</i> = <i>b</i> &lt;&lt;&lt; 13 (the 64-bit word <i>b</i> left-rotated 13 bits).</p>&#13;
<p class="TX">These simple operations on 64-bit words are almost all you need to implement to compute SipHash—although you won’t have to implement it yourself. You can find readily available implementations in most languages, such as C, Go, Java, JavaScript, Python, and Rust.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>I wrote</i> <b><i>SipHash</i></b><i>-</i><span class="note_Italic">x</span><i>-</i><span class="note_Italic">y</span> <i>as the SipHash version, meaning it makes</i> <span class="note_Italic">x</span> <i>SipRounds between each message block injection and then</i> <span class="note_Italic">y</span> <i>rounds. More rounds require more operations, which slows down operations but also increases security. The default version is SipHash-2-4 (simply noted as SipHash), and it has so far resisted cryptanalysis. Note that I also defined SipHash128, a version of SipHash producing 128-bit tags.</i></p>&#13;
<p class="TX">Many systems, such as the Rust language, the OpenBSD operating system, and the Bitcoin blockchain, use SipHash internally. The Linux kernel uses SipHash too and also uses HalfSipHash, “SipHash’s insecure younger cousin,” a smaller version with a 64-bit key and 32-bit output (see <i><a href="https://docs.kernel.org/security/siphash.html">https://<wbr/>docs<wbr/>.kernel<wbr/>.org<wbr/>/security<wbr/>/siphash<wbr/>.html</a></i>).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_153" aria-label="153"/>&#13;
<h3 class="H1" id="sec25"><span id="h1-52"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">Like ciphers and unkeyed hash functions, MACs and PRFs that are secure on paper can be vulnerable to attacks when used in a real setting. Let’s discuss two examples.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h4 class="H2" id="sec26"><span id="h2-97"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Timing Attacks on MAC Verification</samp></h4>&#13;
<p class="TNI"><i>Side-channel attacks</i> target the implementation of a cryptographic algorithm rather than the algorithm itself. In particular, <i>timing attacks</i> use an algorithm’s execution time to determine secret information, such as keys, plaintext, and secret random values. Variable-time string comparison induces vulnerabilities not only in MAC verification but also in many other cryptographic and security functionalities.</p>&#13;
<p class="TX">MACs can be vulnerable to timing attacks when a remote system verifies tags in a period of time that depends on the tag’s value, thereby allowing an attacker to determine the correct message tag by trying many incorrect ones to determine the one that takes the longest amount of time to complete. The problem occurs when a server compares the correct tag with an incorrect one by comparing the two strings byte per byte, in order, until the bytes differ. For example, the Python code in <a href="chapter7.xhtml#Lis7-1">Listing 7-1</a> compares two strings byte per byte, in variable time: if the first bytes differ, the function returns after only one comparison; if the strings <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are identical, the function makes <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> comparisons against the length of the strings.</p>&#13;
<span id="Lis7-1"/><pre><code>def compare_mac(x, y, n):&#13;
    if len(x) != len(y):&#13;
        return False&#13;
    if len(x) != n:&#13;
        return False&#13;
    for i in range(n):&#13;
        if x[i] != y[i]:&#13;
            return False&#13;
    return True</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: A comparison of two</samp> <samp class="SANS_Futura_Std_Book_11">n-</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">byte strings, taking variable time</samp></p>&#13;
<p class="TX">To demonstrate the vulnerability of the <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp> function, we’ll write a program that measures the execution time of 100,000 calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp>, first with identical 16-character <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values and then with <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> values that differ in their third byte. The latter comparison should take noticeably less time because <samp class="SANS_TheSansMonoCd_W5Regular_11">compare_mac()</samp> compares fewer bytes than the identical <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, as <a href="chapter7.xhtml#Lis7-2">Listing 7-2</a> shows.</p>&#13;
<span id="Lis7-2"/><pre><code>from time import time&#13;
&#13;
MAC1 = 'abcdefghijklmnop'&#13;
MAC2 = 'abXdefghijklmnop'&#13;
TRIALS = 100000&#13;
&#13;
def compare_mac(x, y, n):&#13;
    if len(x) != len(y):&#13;
        return False&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_154" aria-label="154"/>    if len(x) != n:&#13;
        return False&#13;
    for i in range(n):&#13;
        if x[i] != y[i]:&#13;
            return False&#13;
    return True&#13;
&#13;
# Each call to compare_mac() will look at all 16 characters.&#13;
start = time()&#13;
for i in range(TRIALS):&#13;
    compare_mac(MAC1, MAC1, len(MAC1))&#13;
end = time()&#13;
print("%0.5f" % (end-start))&#13;
&#13;
# Each call to compare_mac() will look at three characters.&#13;
start = time()&#13;
for i in range(TRIALS):&#13;
    compare_mac(MAC1, MAC2, len(MAC1))&#13;
end = time()&#13;
print("%0.5f" % (end-start))</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Measuring timing differences when executing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">compare_mac()</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">from <a href="chapter7.xhtml#Lis7-1">Listing 7-1</a></samp></p>&#13;
<p class="TX">On a MacBook Pro with an ARM M1 chip, an execution of the program in <a href="chapter7.xhtml#Lis7-2">Listing 7-2</a> prints execution times of around 67 and 26 milliseconds, respectively. That difference is significant enough to identify what’s happening within the algorithm. Now move the difference to other offsets in the string, and you’ll observe different execution times for different offsets. If <samp class="SANS_TheSansMonoCd_W5Regular_11">MAC1</samp> is the correct MAC tag and <samp class="SANS_TheSansMonoCd_W5Regular_11">MAC2</samp> is the one tried by the attacker, you can easily identify the position of the first difference, which is the number of correctly guessed bytes.</p>&#13;
<p class="TX">If execution time doesn’t depend on a secret timing, timing attacks won’t work, which is why implementers strive to write <i>constant-time</i> implementations—that is, code that takes exactly the same time to complete for any secret input value. For example, the C function in <a href="chapter7.xhtml#Lis7-3">Listing 7-3</a> compares two buffers of <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> bytes in constant time: the temporary variable <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> is nonzero if and only if there’s a difference somewhere in the two buffers.</p>&#13;
<span id="Lis7-3"/><pre><code>int cmp_const(const void *a, const void *b, const size_t size)&#13;
{&#13;
    const unsigned char *_a = (const unsigned char *) a;&#13;
    const unsigned char *_b = (const unsigned char *) b;&#13;
    unsigned char result = 0;&#13;
    size_t i;&#13;
&#13;
    for (i = 0; i &lt; size; i++) {&#13;
        result |= _a[i] ^ _b[i];&#13;
    }&#13;
&#13;
    return result; /* Returns 0 if *a and *b are equal, nonzero otherwise */&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: A constant-time comparison of two buffers for safer MAC verification</samp></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_155" aria-label="155"/>&#13;
<h4 class="H2" id="sec27"><span id="h2-98"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">When Sponges Leak</samp></h4>&#13;
<p class="TNI">Permutation-based algorithms like SHA-3 and SipHash are simple, are easy to implement, and come with compact implementations, but they’re fragile in the face of side-channel attacks that recover a snapshot of the system’s state. For example, if a process can read the RAM and registers’ values at any time or read a core dump of the memory, an attacker can determine the internal state of SHA-3 in MAC mode, or the internal state of SipHash, and then compute the reverse of the permutation to recover the initial secret state. They can then forge tags for any message, breaking the MAC’s security.</p>&#13;
<p class="TX">Fortunately, this attack won’t work against compression function–based MACs such as HMAC-SHA-256 and keyed BLAKE2 because the attacker requires a snapshot of memory at the exact time when the key is used. The upshot is that if you’re in an environment where parts of a process’s memory may leak, you can use a MAC based on a noninvertible transform compression function rather than on a permutation.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h3 class="H1" id="sec28"><span id="h1-53"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">The venerable HMAC deserves more attention than I have space for here, and even more for the train of thought that led to its wide adoption and eventual demise when combined with a weak hash function. I recommend the 1996 paper “Keying Hash Functions for Message Authentication” by Mihir Bellare, Ran Canetti, and Hugo Krawczyk, which introduced HMAC and its cousin NMAC, and the 2006 follow-up paper by Bellare called “New Proofs for NMAC and HMAC: Security Without Collision-Resistance,” which proves that HMAC doesn’t need a collision-resistant hash but only a hash with a compression function that is a PRF. On the offensive side, the 2007 paper “Full Key-Recovery Attacks on HMAC/NMAC-MD4 and NMAC-MD5” by Pierre-Alain Fouque, Ga<span class="accent">ë</span>tan Leurent, and Phong Nguyen shows how to attack HMAC and NMAC when they’re built on top of a brittle hash function such as MD4 or MD5. (HMAC-MD5 and HMAC-SHA-1 aren’t totally broken, but the risk is high enough.)</p>&#13;
<p class="TX">The Wegman–Carter MACs are also worth more attention, both for their practical interest and for their underlying theory. The seminal papers by Wegman and Carter are available at <i><a href="https://cr.yp.to/bib/entries.html">https://<wbr/>cr<wbr/>.yp<wbr/>.to<wbr/>/bib<wbr/>/entries<wbr/>.html</a></i>. Other state-of-the-art designs include UMAC and VMAC, which are among the fastest MACs on long messages.</p>&#13;
<p class="TX">One type of MAC not discussed in this chapter is <i>Pelican</i>, which uses the AES block cipher reduced to four rounds (down from 10 in the full block cipher) to authenticate chunks of messages within a simplistic construction, as described in <i><a href="https://eprint.iacr.org/2005/088">https://<wbr/>eprint<wbr/>.iacr<wbr/>.org<wbr/>/2005<wbr/>/088</a></i>. Pelican is more of a curiosity, though, and it’s rarely used in practice.</p>&#13;
<p class="TX">Last but not least, if you’re interested in finding vulnerabilities in cryptographic software, look for uses of CBC-MAC or for weaknesses caused by HMAC handling keys of arbitrary sizes—taking <b>Hash</b>(<i>K</i>) as the key <span role="doc-pagebreak" epub:type="pagebreak" id="pg_156" aria-label="156"/>rather than <i>K</i> if <i>K</i> is too long, thus making <i>K</i> and <b>Hash</b>(<i>K</i>) <i>equivalent keys</i>. Or just look for systems that don’t use MAC when they should—a frequent occurrence.</p>&#13;
<p class="TX">In <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, we’ll combine MACs with ciphers to protect a message’s authenticity, integrity, <i>and</i> confidentiality. We’ll also do this without MACs, thanks to authenticated ciphers, which combine the functionality of a basic cipher with that of a MAC by returning a tag along with each ciphertext.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>