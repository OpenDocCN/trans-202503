- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MCP23017 and MCP23008 GPIO Expanders
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Most SBCs and MCUs provide anywhere from three to a couple dozen digital I/O
    pins. Sometimes, you’ll need more digital I/O than the standard complement. Even
    on those MCUs that provide a couple dozen pins or more, most of them are multifunction.
    If you use them for their alternate purposes, you may find that you don’t have
    enough remaining pins for digital I/O. This is where a GPIO expander comes in
    handy.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many different ICs you can purchase to provide GPIO expansion
    on the I²C bus, the MCP23008 and MCP23017 (collectively MCP230*xx*) are popular;
    they’re available in DIP (through-hole) packages, and there’s considerable library
    code available for them. The MCP23008 supports 8 GPIO pins while the MCP23017
    supports 16, but these 2 ICs are otherwise identical.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the MCP23017 and MCP23008 devices, their electrical connections,
    and how to program them. It describes the internal device registers (and how to
    use them). It also provides some sample programs to demonstrate the ICs’ operation.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 The MCP23017 and MCP23008 Pinouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MCP23017 has the pinout depicted in [Figure 13-1](#figure13-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-1: MCP23017 pinout'
  prefs: []
  type: TYPE_NORMAL
- en: The MCP23008 has the pinout shown in [Figure 13-2](#figure13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-2: MCP23008 pinout'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 13-1](#table13-1) shows what the pins on each device mean.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-1: MCP230*xx* Pin Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pin** | **MCP23008** | **MCP23017** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | SCL (I²C clock) | GPIO 0, port B |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | SDA (I²C data) | GPIO 1, port B |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | A2 (address selection) | GPIO 2, port B |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | A1 (address selection) | GPIO 3, port B |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | A0 (address selection) | GPIO 4, port B |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Reset (active low) | GPIO 5, port B |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | NC (no connection) | GPIO 6, port B |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | INT (interrupt on input) | GPIO 7, port B |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Vss (ground) | Vdd (1.8 V, 3.3 V, or 5 V) |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | GPIO 0 | Vss (ground) |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | GPIO 1 | NC (no connection) |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | GPIO 2 | SCL (I²C clock) |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | GPIO 3 | SDA (I²C data) |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | GPIO 4 | NC (no connection) |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | GPIO 5 | A0 (address selection) |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | GPIO 6 | A1 (address selection) |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | GPIO 7 | A2 (address selection) |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | Vdd (1.8 V, 3.3 V, or 5 V) | Reset (active low) |'
  prefs: []
  type: TYPE_TB
- en: '| 19 | n/a | INTB (interrupt on port B) |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | n/a | INTA (interrupt on port A) |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | n/a | GPIO 0, port A |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | n/a | GPIO 1, port A |'
  prefs: []
  type: TYPE_TB
- en: '| 23 | n/a | GPIO 2, port A |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | n/a | GPIO 3, port A |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | n/a | GPIO 4, port A |'
  prefs: []
  type: TYPE_TB
- en: '| 26 | n/a | GPIO 5, port A |'
  prefs: []
  type: TYPE_TB
- en: '| 27 | n/a | GPIO 6, port A |'
  prefs: []
  type: TYPE_TB
- en: '| 28 | n/a | GPIO 7, port A |'
  prefs: []
  type: TYPE_TB
- en: The Vdd pin is the power supply (positive voltage) to the IC. The MCP230*xx*
    can operate at several different logic levels ranging from 1.8 V to 5.5 V (typically
    1.8 V, 3.3 V, or 5.0 V). The Vss pin is the ground connection.
  prefs: []
  type: TYPE_NORMAL
- en: The SCL and SDA are the I²C bus pins. As usual, these are open-drain pins. The
    bus voltages (held via I²C pullup resistors) should be close to Vdd. Note that
    the MCP230*xx* are capable of operating at 100 kHz, 400 kHz, or as high as 1.7
    MHz.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO*x* pins provide the general-purpose I/O expansion. The MCP23008 has
    8 expansion I/O pins, while the MCP23017 has 16 (named *port A* and *port B* with
    8 pins each). When operating as an input, these pins accept voltages up to Vdd.
    When operating as output pins, they produce Vdd on their outputs.
  prefs: []
  type: TYPE_NORMAL
- en: The A0, A1, and A2 pins specify the LO 3 bits of the device address. These should
    be wired to Vdd or Vss to set the device address. The MCP230*xx* ICs support up
    to eight different devices (selected by A0, A1, and A2 as the LO address bits)
    on the I²C bus. Note that the HO 4 address bits are always 0b0100, so the full
    device address falls in the range 0x20 to 0x27 (0x40 to 0x4E when shifted into
    the output byte).
  prefs: []
  type: TYPE_NORMAL
- en: The Reset signal is an active low signal that resets the device. This pin, when
    low, will configure all the pins as inputs and configure the device in *safe mode*
    (least likely to cause hardware problems). Note that the MCP230*xx* devices automatically
    reset themselves when power is applied, so unless a circuit absolutely needs to
    be able to reset the MCP230*xx* during operation, you’ll normally find this pin
    connected to Vdd.
  prefs: []
  type: TYPE_NORMAL
- en: The MCP23008 INT and the MCP23017 INTA and INTB pins signal an interrupt. An
    *interrupt* is an asynchronous signal that alerts the CPU to take some action
    (generally pausing the current execution stream and running a special interrupt
    service routine to handle the event). You can program the INT, INTA, and INTB
    pins to pulse or to be set to some level whenever a change occurs on the MCP230*xx*,
    which is useful for detecting input changes when the system can’t poll the input
    pins on a frequent basis.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2 MCP230*xx* Registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MCP230*xx* ICs are feature-rich devices. Unfortunately, this feature set
    comes at a cost: programming complexity. To program these ICs, you read and write
    various registers. The MCP23008 has 11 internal registers (see [Table 13-2](#table13-2)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-2: MCP23008 Registers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Register number** | **Name** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | IODIR | I/O data direction register |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | IPOL | Input polarity |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | GPINTEN | GPIO interrupt enable register |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | DEFVAL | Default comparison value (for interrupts) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | INTCON | Interrupt control register |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | IOCON | I/O configuration register |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | GPPU | GPIO pullup register |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | INTF | Interrupt flag register |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | INTCAP | Interrupt capture register |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | GPIO | GPIO I/O port register |'
  prefs: []
  type: TYPE_TB
- en: '| 10 (0xA) | OLAT | Output latch register |'
  prefs: []
  type: TYPE_TB
- en: The MCP23017 has 22 internal registers (see [Table 13-3](#table13-3)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-3: MCP23017 Registers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Register number,** **BANK = 0** | **Alternate register number,** **BANK
    = 1** | **Name** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | IODIRA | Port A I/O data direction register |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 16 (0x10) | IODIRB | Port B I/O data direction register |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | IPOLA | Port A input polarity |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 17 (0x11) | IPOLB | Port B input polarity |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2 | GPINTENA | Port A GPIO interrupt enable register |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 18 (0x12) | GPINTENB | Port B GPIO interrupt enable register |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 3 | DEFVALA | Port A default comparison value (for interrupts) |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 19 (0x13) | DEFVALB | Port B default comparison value (for interrupts)
    |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 4 | INTCONA | Port A interrupt control register |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 20 (0x14) | INTCONB | Port B interrupt control register |'
  prefs: []
  type: TYPE_TB
- en: '| 10 (0xA) | 5 | IOCON | I/O configuration register (only single IOCON) |'
  prefs: []
  type: TYPE_TB
- en: '| 11 (0xB) | 21 (0x15) | IOCON | I/O configuration register (same as register
    10/5) |'
  prefs: []
  type: TYPE_TB
- en: '| 12 (0xC) | 6 | GPPUA | Port A GPIO pullup register |'
  prefs: []
  type: TYPE_TB
- en: '| 13 (0xD) | 22 (0x16) | GPPUB | Port B GPIO pullup register |'
  prefs: []
  type: TYPE_TB
- en: '| 14 (0xE) | 7 | INTFA | Port A interrupt flag register |'
  prefs: []
  type: TYPE_TB
- en: '| 15 (0xF) | 23 (0x17) | INTFB | Port B interrupt flag register |'
  prefs: []
  type: TYPE_TB
- en: '| 16 (0x10) | 8 | INTCAPA | Port A interrupt capture register |'
  prefs: []
  type: TYPE_TB
- en: '| 17 (0x11) | 24 (0x18) | INTCAPB | Port B interrupt capture register |'
  prefs: []
  type: TYPE_TB
- en: '| 18 (0x12) | 9 | GPIOA | Port A GPIO |'
  prefs: []
  type: TYPE_TB
- en: '| 19 (0x13) | 25 (0x19) | GPIOB | Port B GPIO |'
  prefs: []
  type: TYPE_TB
- en: '| 20 (0x14) | 10 (0xA) | OLATA | Port A output latch register |'
  prefs: []
  type: TYPE_TB
- en: '| 21 (0x15) | 26 (0x1A) | OLATB | Port B output latch register |'
  prefs: []
  type: TYPE_TB
- en: The MCP23017 supports two sets of register numbers, standard and alternate (or
    “special”). The register number is selected by bit 7 in the IOCON (control) register.
    If this bit is 0 (the power-up/reset state), then the MCP23017 uses the standard
    register numbering. If bit 7 is 1, then the MCP23017 uses the alternate register
    numbering, which separates the two ports into separate register banks (0 to 0xA
    for port A and 0x10 to 0x1A for port B).
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.1 Accessing MCP230*xx* Registers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because the MCP230*xx* devices have multiple registers, writing and reading
    data to and from these devices are a little more complex than with simpler devices
    like the MCP4725\. The (typical) protocol for writing a single byte to a register
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmit the I²C address byte (a value in the range 0x40 to 0x46). This is always
    a write operation, so the LO bit of the address byte will always be 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the register address to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the register data (to write to the MCP230*xx* register) on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put a stop condition on the bus to terminate the transfer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The (typical) protocol for reading a single byte from a register is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmit the I²C address byte (a value in the range 0x40 to 0x46). This is always
    a write operation, so the LO bit of the address byte will always be 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the register address to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put a (re)start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmit the I²C address byte (a value in the range 0x41 to 0x47). This is a
    read operation, so the LO bit of the address byte will be 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the register data from the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put a stop condition on the bus to terminate the transfer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This chapter discusses additional forms of this protocol for block reads and
    writes; see section 13.2.6, “Sequential Register Operations,” later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.2 MCP230*xx* Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At power-up, the MCP230*xx* devices enter the following state:'
  prefs: []
  type: TYPE_NORMAL
- en: IOCON bit 7 is set to 0 to select standard register numbers on the MCP23017.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All GPIO pins are programmed as inputs (see section 13.2.3, “Programming the
    Data Direction”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All pullup resistors are turned off (see section 13.2.4, “Programming Input
    Pullup Resistors”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All interrupts are disabled (see section 13.5.5, “Enabling Interrupts on the
    MCP230*xx*”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the MCP23017, port A and B interrupts will be handled independently (should
    they be enabled).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MCP230*xx* is programmed for sequential register operations (see section
    13.2.6, “Sequential Register Operations”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SDA slew rate control is enabled (see section 13.2.7, “Slew Rate Control”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The INTx pin(s) are active outputs (not open drain; see section 13.2.8, “Reading
    General-Purpose Input/Output Pins on the MCP230*xx*”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupt output pins are active-low (low signal when an interrupt occurs; see
    section 13.5.5, “Enabling Interrupts on the MCP230*xx*”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IOCON register (I/O configuration) handles most of this initialization.
    [Table 13-4](#table13-4) lists the bits in IOCON and their functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-4: IOCON Register Functions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit** | **Default on power-up or reset** | **Name** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 0 | BANK | MCP23017 only. Selects standard register numbering (BANK =
    0) or alternate register numbering (BANK = 1). |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 0 | MIRROR | MCP23017 only. INTA/B mirror function. If MIRROR = 0, then
    the INTA and INTB pins operate independently. If MIRROR = 1, then the two pins
    are internally wired together. See “INT*x* Pin Polarity” under section 13.5.2
    for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0 | SEQOP | If SEQOP = 1, then successive data read/write operations
    read and write the same register number. If SEQOP = 0, then the register number
    is incremented after each operation (mainly for MCP23017). |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0 | DISSLW | Slew rate control for SDA pin. If DISSLW = 0, then slew
    rate control is enabled. If DISSLW = 1, then slew rate control is disabled. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0 | N/A | Used only by SPI version of the MCP23S*xx* GPIO expander. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0 | ODR | Open drain control. If ODR = 1, then the INT*x* pins are open-drain
    outputs. If ODR = 0, then the INT*x* pins are active logic outputs. See section
    13.5.5, “Enabling Interrupts on the MCP230*xx*” for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | INTPOL | Sets the polarity of the INT pins. If INTPOL = 0, then the
    INT*x* pins are active low. If INTPOL = 1, then the INT*x* pins are active high.
    This bit sets the polarity only if ODR = 0\. See section 13.5.4, “Open-Drain INT*x*
    Output,” for more information. |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | N/A | Not used. |'
  prefs: []
  type: TYPE_TB
- en: If you decide you want to initialize the MCP230*xx* with something other than
    the default value, you will need to write an appropriate value to the IOCON register.
    Do so immediately after your program begins execution. While it is possible to
    change the configuration during execution, this is rare; most of the time you’ll
    configure the MCP230*xx* once and then not touch the register thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To program the IOCON register, you will need to write 3 bytes to the I²C bus
    (see [Figure 13-3](#figure13-3)):'
  prefs: []
  type: TYPE_NORMAL
- en: Put a start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the device address (0x40 to 0x46) with the LO bit set to 0 (write operation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the IOCON register number 0x0A (or 0x05, if using alternate register numbers)
    to the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the new IOCON register value to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put a stop condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-3: Example IOCON initialization sequence'
  prefs: []
  type: TYPE_NORMAL
- en: On power-up or after a reset operation, the register addresses default to the
    standard register numbers. If you intend to use the alternate register numbers,
    you must write an IOCON value with bit 7 equal to 1 to address 0x0A, the power-on/reset
    IOCON address. After that, any writes to IOCON must happen at register number
    0x05.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if external hardware can reset the MCP230*xx*, then the IOCON register
    will switch back to address 0x0A. This can be a problem if the software isn’t
    aware that the reset operation took place. This is a good argument for leaving
    the MCP230*xx* in standard register number mode.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.3 Programming the Data Direction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GPIO pins on the MCP230*xx* are individually programmable as inputs or outputs.
    The *data direction registers (DDRs)* control the input or output state of each
    pin. The MCP23008 has a single (8-bit) IODIR (register 0), and the MCP23017 has
    two (IODIRA is register 0, and IODIRB is register 1 or 16).
  prefs: []
  type: TYPE_NORMAL
- en: Each bit position in an IODIR*x* register controls the I/O state of the corresponding
    GPIO pin. That is, bit 0 in IODIRA (IODIR on the MCP23008) controls GPA0, bit
    1 in IODIRA controls GPA1, and so on. Likewise, bit 0 in IODIRB controls GPB0,
    bit 1 controls GPB1, and so on. A 1 in a given bit position programs the corresponding
    GPIO pin as an input; a 0 in the bit position programs the corresponding GPIO
    pin as an output.
  prefs: []
  type: TYPE_NORMAL
- en: When the MCP230*xx* powers up or when the reset line is brought low, the IC
    programs all GPIO pins as inputs (that is, it initializes the IODIR*x* registers
    with all 1 bits). This is the safest initial configuration, as it prevents programming
    a GPIO pin as an output, which might produce an electrical conflict if that pin
    is connected to a line with an active signal.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the MCP230*xx*’s IODIR flexibility, you can program arbitrary bits
    as inputs or outputs. In practice, it’s most convenient (at least on the MCP23017)
    to program each bank of 8 bits as either all inputs or all outputs. Doing so makes
    it more convenient to program the MCP230*xx* ICs. Of course, if your hardware
    design requires that you mix and match I/O directions on a single port, that’s
    perfectly acceptable; the cost is slightly more complex programming requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To send the data direction value to the MCP230*xx* ICs, transmit the sequence
    shown in [Figure 13-4](#figure13-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-4: IODIR*x* initialization sequence'
  prefs: []
  type: TYPE_NORMAL
- en: The third byte of the sequence appearing in [Figure 13-4](#figure13-4) is the
    data direction initialization value.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.4 Programming Input Pullup Resistors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Input pins on the MCP230*xx* are often connected to *dry contact inputs*: switches,
    relay contacts, or other devices that connect two different signal lines. A typical
    dry contact might be a push button, DIP switch, or other SPST switch or relay.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a dry contact will connect an input pin on an MCP230*xx* to ground.
    Closing the contact shunts the input to ground so that a 0 input value appears
    on the corresponding bit in the GPIO*x* register. When the contact is open, the
    input signal *floats*, which is never good; the electronics might interpret a
    floating input as either a logic 0 or 1\. To avoid floating inputs, designers
    typically put a pullup resistor on the input pin. This raises the voltage pin
    to the voltage connected to the pullup resistor (typically Vdd) when the dry contact
    is in the open position. When the dry contact is in the closed position, this
    shunts the input to ground, providing a logic 0 input.
  prefs: []
  type: TYPE_NORMAL
- en: The only problem with pullup resistors is that you’ll need to find space for
    them on a printed circuit or prototype board, as well as time and energy to install
    them. For convenience, the MCP230*xx* parts provide *programmable pullup resistors*
    that allow you to programmatically enable or disable pullup resistors on input
    pins. The GPPU*x* registers provide this capability. Programming a GPPU*x* bit
    with a 1 (and programming that same bit position in IODIR*x* with a 1) will connect
    a 100-kΩ pullup resistor to that pin. Conversely, programming a 0 bit disconnects
    the pullup resistor.
  prefs: []
  type: TYPE_NORMAL
- en: You should program only pullup resistors on GPIO pins connected to dry contact
    inputs. If a logic-level signal connects to a GPIO pin, programming a pullup resistor
    on that same pin might damage the MCP230*xx* or the logic device at the other
    end of the connection. Even if it doesn’t damage the electronics, it could interfere
    with the input signal.
  prefs: []
  type: TYPE_NORMAL
- en: To set the pullup value on the MCP230*xx* ICs, transmit the sequence shown in
    [Figure 13-5](#figure13-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-5: GPPU*x* pullup initialization'
  prefs: []
  type: TYPE_NORMAL
- en: The last byte in the sequence in [Figure 13-5](#figure13-5) is the bitmap value
    for the pullup initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.5 Programming the Input Polarity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve been reading closely, you may have noticed that reading a dry contact
    switch with a pullup resistor in the previous section produced a 0 input when
    the switch was closed (pressed) and a 1 input when the switch was open (unpressed).
    This logic, *active low logic*, is opposite of what you might expect in software.
    Intuition suggests you should get a logic 1 when you press (close) the switch
    and a logic 0 when you release (open) it—that is, you expect *active* *high logic*.
    Although it is easy enough to invert the signal once you’ve read it from the GPIO
    pin, the MCP230*xx* devices provide a special *polarity register* that lets you
    select active high or active low logic signals.
  prefs: []
  type: TYPE_NORMAL
- en: The MCP23008 IPOL and the MCP23017 IPOLA and IPOLB registers let you control
    the polarity of an input pin. If a bit in IPOL*x* is 0, then the corresponding
    bit in the GPIO*x* register will reflect the current state of the input pin. If
    a bit in IPOL*x* is 1, then the corresponding bit in GPIO*x* will reflect the
    inverted state of the input pin.
  prefs: []
  type: TYPE_NORMAL
- en: If an actual input is active low but you want to read it as though it were active
    high, simply program the corresponding bit in IPOL*x* with a 1 to invert the signal
    when you read it. Inverting dry contacts, for example, makes them active high
    inputs so that their logic matches logic-level input signals.
  prefs: []
  type: TYPE_NORMAL
- en: To set the input pin polarities on the MCP230*xx* ICs, transmit the sequence
    shown in [Figure 13-6](#figure13-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-6: IPOL*x* input pin polarity sequence'
  prefs: []
  type: TYPE_NORMAL
- en: The third byte in the sequence appearing in [Figure 13-6](#figure13-6) is the
    polarity initialization value.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.6 Sequential Register Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reading or writing a register value on the MCP230*xx* requires a minimum of
    three 1-byte transmissions on the I²C bus: an I²C address byte, a register number,
    and a data transmission to or from the register. Because I²C transmissions are
    relatively slow (especially when operating at 100 kHz), the MCP230*xx* provides
    a special *sequential register access mode* to reduce the number of I²C bus transactions.
    The SEQOP bit in IOCON (bit 5) controls this mode. If SEQOP contains 0, then the
    MCP230*xx* automatically increments the register number after each data transmission
    and reception on the I²C bus. If SEQOP contains 1, then the MCP230*xx* disables
    the autoincrement mode.'
  prefs: []
  type: TYPE_NORMAL
- en: When the autoincrement mode is active, the controller device can read or write
    multiple data bytes after transmitting a single pair of I²C address and register
    bytes. As long as the controller device does not put a stop condition on the bus,
    successive clock pulses on SCL will continue to read or write successive registers
    on the MCP230*xx*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This autoincrement feature is especially useful on the MCP23017 when the registers
    are in standard (non-banked) mode. In standard mode, the port A and port B registers
    appear in successive locations. This allows you to successively read and write
    registers from both ports as a 16-bit operation. For example, if you want to initialize
    IODIRA and IODIRB at the same time, you would use the following sequence (assuming
    SEQOP is 0, which is the power-on/reset condition):'
  prefs: []
  type: TYPE_NORMAL
- en: Place the start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the address to the I²C bus (0x40 to 0x46) with the LO bit 0 (for write).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write 0 to the I²C bus (IODIRA register address).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the data direction bits for IODIRA to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the data direction bits for IODIRB to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the stop condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Between steps 4 and 5 in this sequence, the MCP23017 automatically incremented
    the register number so that step 5 writes the data direction bits to register
    one (IODIRB), as shown in [Figure 13-7](#figure13-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-7: Autoincrementing register numbers'
  prefs: []
  type: TYPE_NORMAL
- en: This sequence requires writing only 4 bytes to the I²C bus. This is two less
    than the 6 bytes that would have been required to individually write to the IODIRA
    and IODIRB registers using independent transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re not limited to writing just two values using the autoincrement mode.
    You could, for example, write the direction and polarity initialization values
    all at once:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the address to the I²C bus (0x40 to 0x46) with the LO bit 0 (for write).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write 0 to the I²C bus (IODIRA register address).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the data direction bits for IODIRA to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the data direction bits for IODIRB to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the polarity bits for IPOLA to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the polarity bits for IPOLB to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the stop condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In theory, you could also write interrupt initialization values in this sequence,
    though it’s uncommon to use all the interrupt initialization features, so sequential
    writing isn’t always possible. Sadly, the pullup registers don’t appear sequentially
    in a common initialization list, so you wind up having to write their address
    and register values independently.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you’re unlikely to write the initialization bits more often than
    once in a typical application, so the savings for a single initialization won’t
    be that great. However, it is common to read all 16 input bits from the MCP23017
    or to write all 16 output bits. The autoincrement mode is useful for those operations,
    which occur frequently in common applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Register autoincrement mode is not always useful, though. Perhaps you want
    to quickly write the GPIO, GPIOA, or GPIOB register to put some waveform onto
    the output pins, and you:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a start condition on the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the I²C address to the bus with the LO (read) bit equal to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the register number to the bus (for example, 12/0xC for GPIOA).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a byte to the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 4 for each different value to be written to the output pins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a stop condition on the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This code would require SEQOP to be set to 1 to disable autoincrementing the
    register number after step 4.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll have to decide whether it’s better to operate with the autoincrement
    feature turned on or off (by default) in your code. If you’re constantly switching
    between the two modes, it may be more efficient just to operate in non-autoincrement
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.7 Slew Rate Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bit 4 of the IOCON register (DISSLW) controls the I²C SDA slew rate. When enabled
    (0), the slew rate control reduces the speed at which the SDA line rises from
    low to high or falls from high to low (see [Figure 13-8](#figure13-8)). By default,
    this bit is 0, which reduces the signal’s rise and fall time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-8: Slew rate'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the slew rate can reduce noise (due to *ringing*, noise caused by the
    signal temporarily bouncing up and down after a change) on the SDA line. However,
    at higher speeds, reducing the slew rate can introduce errors on its own. You
    would typically enable slew rate control at 100 kHz and disable it at 1 MHz. At
    400 kHz, you would enable it or disable it as necessary, depending on the signal
    noise, which you would have to verify with an oscilloscope. As the MCP230*xx*
    devices enable slew rate control by default, you should turn it off only if there
    are noise problems in your system.
  prefs: []
  type: TYPE_NORMAL
- en: '*13.2.8* Reading General-Purpose Input/Output Pins on the MCP230*xx*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reading the GPIO*x* register(s) on the MCP230*xx* is probably the most common
    software activity. Reading these registers returns the current state of the GPA*x*
    and GPB*x* pins. If the pins were programmed as output, then reading the GPIO*x*
    registers returns the last value written (or default reset state) to the output
    pins, which is the current state of those pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading data from the GPIO*x* registers requires two I²C bus transactions.
    First, write the GPIO*x* register address, and second, read the register value(s):'
  prefs: []
  type: TYPE_NORMAL
- en: Place a start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the device address with the LO bit 0 (write operation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the GPIO, GPIOA, or GPIOB register address (GPIO = 9 on MCP23008, GPIOA
    = 9 or 0x12, and GPIOB = 0x19 or 0x13 on MCP23017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a (repeated) start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the device address with the LO bit 1 (read operation) to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the GPIO bits from the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (optional on MCP23017) Read the second set of GPIO bits (GPIOB) from the I²C
    bus (see [Figure 13-9](#figure13-9)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a stop condition on the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 7 assumes SEQOP bit in IOCON is 0 and the register address written in step
    3 was GPIOA (address 0x12 in standard mode).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-9: GPIO sequential read operation'
  prefs: []
  type: TYPE_NORMAL
- en: Note that if SEQOP in IOCON has been programmed as a 1 (no autoincrementing
    register address), then you can reread the GPIO*x* bits over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: '*13.3* Writing General-Purpose Input/Output Pins on the MCP230*xx*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to write data to output pins on the MCP230*xx*: write the
    data to the GPIO*x* register(s) or write the data to the OLAT*x* register(s).
    Writing to either set of registers will place the output data on the output pins.'
  prefs: []
  type: TYPE_NORMAL
- en: For output purposes, there is no real difference between writing to the GPIO*x*
    and OLAT*x* registers. Internally, the MCP230*xx* converts a write to GPIO*x*
    into a write to OLAT*x*. The two register sets differ when you read from them.
    Reading from GPIO*x*, of course, reads the current state of the GPA*n* and GPB*n*
    input pins. Reading from OLAT*x* returns the last value written to the OLAT*x*
    (or GPIO*x*) registers. This will produce differing results if any pins were programmed
    as inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing to the OLAT*x* (or GPIO*x*) registers is slightly less complex than
    reading from the GPIO*x* registers. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Place a start condition on the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the device address with the LO bit 0 (write operation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the OLAT, OLATA, or OLATB register address (OLAT = 0xA on MCP23008, OLATA
    = 0xA or 0x14, and OLATB = 0x1A or 0x15 on MCP23017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the OLAT bits to the I²C bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the second set of OLAT bits (OLATB) to the I²C bus (see [Figure 13-10](#figure13-10)).
    This is optional on MCP23017 (SEQOP = 0, only).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a stop condition on the bus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This sequence is less complex than reading because you don’t have to do a repeated
    start condition and write a second device address to the bus.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-10: GPIO (OLAT) 16-bit sequential write operation'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output pins on the MCP230*xx* ICs are not capable of driving much
    current. Each pin is capable of sourcing or sinking 25 mA—barely enough to light
    an LED. The entire package is further limited to 150 mA, meaning you cannot connect
    16 LEDs and run them all at 25 mA. To handle more current, you will need to connect
    a transistor or other current amplifier to the output pin. The ULN2308 Darlington
    array—8 Darlington amplifiers in an 18-pin package, each capable of sinking 500
    mA—is a perfect device for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4 Demonstrating Input/Output on an MCP23017
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now you’ve learned enough to actually program the MCP230*xx* devices in polled
    (non-interrupt) mode. The sample Arduino program in this section writes some output
    data to port B on an MCP23017 and reads this data from port A on the same device.
    This program is relatively trivial in terms of functionality, but it demonstrates
    most of what you need to program the device.
  prefs: []
  type: TYPE_NORMAL
- en: The program uses the circuit shown in [Figure 13-11](#figure13-11). The SDA
    and SCL lines on the MCP23017 are wired to the corresponding pins on an Arduino
    Uno Rev3 (or other Arduino-compatible device). Pins A0, A1, and A2 are wired to
    Gnd, so the 7-bit device address will be 0x20\. The reset pin is wired to +5 V
    or +3.3 V, depending on whether you’re running a 3.3-V or 5.0-V system. The port
    A pins are wired to the reversed port B pins. Finally, if your SBC does not provide
    appropriate pullup resistors on the SDA and SCL lines, you will need to put a
    pair of 4.7-kΩ resistors between these two lines and Vdd (+5 V or +3.3 V).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-11: Simple wiring example for the program in [Listing 13-1](#listing13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Note in [Figure 13-11](#figure13-11) that GPB0 is connected to GPA7, GPB1 is
    connected to GPA6, . . . , and GPB7 is connected to GPA0\. So the output bits
    will be reversed when read as inputs. This was done to simplify wiring; the bit
    reversal can be fixed in software.
  prefs: []
  type: TYPE_NORMAL
- en: The program in does not use interrupts, so you can leave the INTA and INTB pins
    floating. Also, don’t forget to wire the Vdd (pin 9) and Vss (pin 10) pins to
    +5 V (or +3.3 V) and Gnd, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `setup()` function initializes the MCP23017 device as appropriate for this
    sample program. Most importantly, it initializes port A pins as inputs and port
    B pins as outputs. It also disables the pullup resistors on the port A input pins,
    because port B is connected directly to port A, and port B’s pins provide TTL
    (5-V) signals.
  prefs: []
  type: TYPE_NORMAL
- en: The `loop()` function simply writes a sequence of byte values to port B, reads
    a byte value from port A, and verifies that the value read is equal (with bit
    reversal due to wiring) to the value that was written (to port B). This function
    prints an error message to the serial port if the two values do not match.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5 Interrupts on the MCP230*xx*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most programmers using the MCP230*xx* on an Arduino system don’t bother using
    the interrupt facilities on those devices. It’s often less work to simply poll
    the device to determine if any input bits have changed rather than to create an
    ISR and program the interrupts on the MCP230*xx*. If you’re programming a system
    that can poll the MCP230*xx* at a sufficiently high frequency without impacting
    the performance of other activities on your system, polling is a reasonable approach.
    However, if real-time concerns mean polling is not an option, the interrupt facilities
    on the MCP230*xx* can be a lifesaver.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.1 Interrupt Actions on the MCP230*xx*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The program in [Listing 13-1](#listing13-1) continuously wrote and read data.
    Because this program was responsible for both writing the data (to port B) and
    reading the data (at port A), the application always knows when data will be available
    on port A (specifically, data will be available immediately after the `loop()`
    function writes the data to port B). In the majority of real-world systems, the
    incoming data usually comes from some external hardware, and the `loop()` function
    wouldn’t intrinsically know when new data has arrived on port A. One solution
    might be to have the `loop()` function continuously read port A and compare the
    value read against the previous reading. When the two values are different, the
    function can assume that external hardware has transmitted a new value and deal
    with it appropriately. This scheme is known as *polling*.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with polling is that it consumes CPU time (to read and compare the
    port B value) even when the external hardware is not transmitting new values.
    During polling, the CPU cannot be used for other operations. A better solution
    would be to have the external hardware notify the CPU that new data is available;
    this notification would interrupt the current CPU’s activities so it can briefly
    deal with the changed data and then resume the interrupted operation after handling
    the new data. The question is, how can the external hardware interrupt the CPU
    whenever it applies new data to port B?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can program the MCP230*xx* devices to produce a signal on the MCP23008
    INT or the MCP23017 INTA or INTB pins whenever a change in state occurs. A change
    in state, known as an *interrupt-on-change (IOC)*, is noted in one of two programmable
    situations:'
  prefs: []
  type: TYPE_NORMAL
- en: A pin changes state (from low to high or from high to low).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pin changes state when compared against the corresponding bit in the DEFVAL
    register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The INT*x* pins reflect the current interrupt state. You would normally connect
    the INT*x* pins to an interrupt input on your SBC. Different SBCs support interrupts
    on different pins. Of course, if you are using a different SBC or a different
    RTOS, you will have to check the documentation for the SBC or RTOS to determine
    which pins are suitable for use as interrupt inputs. This section will assume
    you are using the Arduino libraries; see your SBC or RTOS documentation when using
    a different system.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.2 Interrupt Service Routines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When an interrupt causes the CPU to halt the current program execution, it
    transfers control to a special function: the ISR. The ISR quickly does whatever
    is necessary to handle the hardware event and then returns control to the system,
    which resumes the original, interrupted code. To support ISRs in an application,
    you’ll need to address a few questions. Answers vary by system; the following
    sections give answers for the Arduino.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How and where is the electronic signal input to the system?**'
  prefs: []
  type: TYPE_NORMAL
- en: In most systems, Arduino included, interrupts are digital logic signals input
    on specific CPU or system pins. On the Arduino, selected digital I/O pins can
    serve as interrupt inputs. (See “For More Information” for information on Arduino-brand
    pin selections for interrupts.) For example, the Arduino Uno Rev3 supports interrupts
    on digital I/O pins 2 and 3, and the Teensy 3.1 supports interrupts on any digital
    I/O pin. Not all Arduino devices support pin 2 as an interrupt pin; check your
    documentation when using a different device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**What type of input signals the interrupt?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because digital I/O signals can be low (0) or high (1), you might think that
    interrupts can occur only on these two conditions. In fact, most Arduino systems
    will invoke an interrupt on one of the following conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A low-to-high transition on the interrupt pin
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A high-to-low transition on the interrupt pin
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change (low-to-high or high-to-low) on the interrupt pin
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A low signal on the interrupt pin
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some, but not all, Arduino devices can also invoke an interrupt when the interrupt
    pin is high.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**How do you specify the ISR function?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arduino systems use the `attachInterrupt()` function to associate a particular
    digital I/O pin with an interrupt. The call takes the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this call, `pin` is a digital I/O pin number, `ISR` is the name of a void
    function with no parameters that serves as the interrupt service routine, and
    `mode` is one of the following identifiers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`LOW` Triggers the interrupt whenever the pin is low'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CHANGE` Triggers the interrupt whenever the pin changes value'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RISING` Triggers when the pin goes from low to high'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FALLING` Triggers when the pin goes from high to low'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`HIGH` Triggers the interrupt whenever the pin is high'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only some Arduino-compatible boards allow `HIGH`, so check your board’s documentation
    to see if it supports active high interrupt signaling (for example, the Uno Rev3
    does not support `HIGH`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To use interrupts on other systems, see the documentation for your library,
    OS, or SBC.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**What are the constraints on the ISR function?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most operating systems place constraints on ISRs. Generally, you should assume
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any global variables an ISR modifies should be declared as `volatile`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ISR functions should be short, and execution time should be as minimal as possible.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many systems do not allow interrupts to be nested (that is, they don’t allow
    one interrupt signal to interrupt an executing ISR).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many systems limit the type of library function calls that you can make in an
    ISR.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Please consult your particular OS’s reference manuals for additional information
    about interrupt service routines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Arduino library, for example, places a couple of additional constraints
    on ISRs. In particular, you cannot use the `delay()` or `millis()` functions within
    an ISR. See “For More Information” for links to Arduino interrupt documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**INT*x* pin polarity**'
  prefs: []
  type: TYPE_NORMAL
- en: When the MCP230*xx* detects a pin change that would cause an interrupt, it will
    set the INT*x* pin high or low. The INTPOL bit (bit 1) in the IOCON register determines
    the interrupt polarity. If INTPOL is 1, then the interrupt signal is active high—that
    is, the INT*x* pin will go high when an interrupt occurs. If INTPOL is 0, then
    the interrupt signal is active low and goes low on an interrupt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can select the appropriate interrupt polarity either by using the Arduino
    `attachInterrupt()` `mode` parameter or by setting the interrupt polarity on the
    MCP230*xx*. However, it is important to ensure that the polarity you specify by
    `mode` matches the polarity you specify with the INTPOL bit. The common convention
    is to use active low interrupts and specify either `LOW` or `FALLING` as the `mode`
    parameter value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 13.5.3 Mirroring INT*x* Pins (MCP23017 Only)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MCP23017 provides two independent interrupt pins for port A (INTA pin) and
    port B (INTB pin). This allows you to quickly determine the source of an interrupt
    if both ports A and B can generate interrupts, though at the cost of requiring
    two separate interrupt pins on the CPU. If you want to use only a single pin as
    an interrupt line on your CPU and are willing to use some software to differentiate
    port A and port B interrupts, you can program the MCP23017 to wire the INTA and
    INTB pins together so that an interrupt on either port will send a signal to the
    INTA and INTB pins.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the MIRROR bit (bit 6) with a 1 in the IOCON register achieves this.
    Conversely, programming the MIRROR bit with a 0 (the default condition) routes
    all port A interrupts to INTA and all port B interrupts to INTB.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.4 Open-Drain INT*x* Output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bit 2 of the IOCON register (ODR) controls the INT*x* line open-drain interface.
    If this bit is programmed as a 1, open-drain output is enabled; if it is programmed
    as a 0 (the default), the active logic output in the INT*x* lines is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: The open-drain form allows you to connect the INT lines from multiple MCP230*xx*
    devices together. This mode requires a pullup resistor on the output line. In
    open-drain mode, an interrupt signal will pull the INT*x* pin low, which, presumably,
    signals an interrupt on the controller. The controller will have to poll the various
    MCP230*xx* devices to determine the source of the interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: The active logic output mode puts a logic signal directly on the INT*x* output
    pin. In this mode, the INT*x* pin must exclusively connect to an interrupt on
    the controller device; you cannot tie the interrupt pins together since that would
    create an electrical fault. This mode is best when you have a single MCP230*xx*
    device or if you need separate interrupts for each MCP230*xx* (so you don’t have
    to poll the devices to determine the source of the interrupt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Active logic mode is the default interrupt mode, a design error in MCP230*xx*
    devices. Tying multiple devices’ INT*x* lines together and forgetting to program
    the ODR bit in open-drain mode could create an electrical conflict that could
    damage the MCP230*xx* parts. Moral of the story: always program the ODR bit in
    IOCON correctly! Many designers stick a transistor (such as a 2N7000 MOSFET) on
    the INT*x* pins to force open-drain (open-collector) mode and program ODR in active
    logic mode to drive the transistor. This avoids the possibility of a programming
    error that would damage the MCP230*xx*.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.5 Enabling Interrupts on the MCP230*xx*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the MCP230*xx* parts do not generate any interrupts; you must explicitly
    enable interrupts for the INT*x* pins to become active. You can do so with the
    MCP23008 GPINTEN and MCP23017 GPINTENA and GPINTENB registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MCP230*xx* devices allow you to enable or disable interrupts on a pin-by-pin
    basis. Each bit in a GPINTEN*x* register matches one of the GPIO pins: GPINTENA
    matches GPIOA pins, and GPINTENB matches GPIOB pins on the MCP23017\. If a bit
    in GPINTEN*x* contains 0, then interrupts are disabled for that particular I/O
    pin. If the bit contains 1, then interrupts are enabled for that bit, and interrupts
    are generated based on the bit settings in the INTCON and DEFVAL registers.'
  prefs: []
  type: TYPE_NORMAL
- en: If interrupts are enabled for a particular I/O pin, then the INTCON and DEFVAL
    registers allow you to program the MCP230*xx* to generate an interrupt on a pin
    change or on a particular level. If a specific INTCON bit is 0, then the MCP230*xx*
    will generate an interrupt any time the input bit changes (that is, it will generate
    an interrupt on a low-to-high or on a high-to-low transition). In this case, the
    MCP230*xx* ignores the corresponding bit in DEFVAL. If a specific INTCON bit is
    1, then the MCP230*xx* will generate an interrupt any time the input bit differs
    from the value of the corresponding bit in DEFVAL. This allows you to create level-sensing
    interrupts. If the corresponding bit in DEFVAL is 0, then the MCP230*xx* generates
    interrupts when the input pin is high; if the bit in DEFVAL is 1, then the MCP230*xx*
    generates interrupts when the input pin is low. Note that if the corresponding
    bit in INTCON is 0, or if that bit in GPINTEN*x* is 0, the system ignores the
    bit in DEFVAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it is possible to modify the GPINTEN*x*, INTCON*x*, and DEFVAL*x*
    registers throughout program execution in complex systems, most commonly you initialize
    these registers just once when your program first begins execution. To prevent
    race conditions, you should initialize interrupts in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the DEFVAL*x* register(s), if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the INTCON*x* register(s), if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the GPIO pins to clear any existing interrupts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize the GPINTEN*x* register(s), if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach an ISR to the particular pin using `attachInterrupt()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A sequence like this helps prevent any inadvertent interrupts resulting from
    pre-existing conditions on the input pins or conditions that change during initialization.
    This particular sequence is for an Arduino system, but all other systems have
    a comparable one.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.6 Testing and Clearing Interrupts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The INT*x* pin(s) on the MCP230*xx* indicate only that an interrupt has occurred
    on one (or both) banks. When the system invokes the ISR, you don’t know which
    pin—or pins, if multiple pins change simultaneously—is responsible for the interrupt.
    To determine the exact source(s) of the interrupt, you will need to read the MCP23008
    INTF or MCP23017 INTFA or INTFB register(s).
  prefs: []
  type: TYPE_NORMAL
- en: The bits in the INTF*x* register indicate which bits are responsible for an
    interrupt. When the ISR begins execution, it should read the INTF*x* register(s),
    where a 1 bit in a bit position indicates that the interrupt resulted from a change
    in the specified input bit. The ISR can then read the appropriate GPIO pin to
    determine the state of that pin when the interrupt occurred. For example, if interrupts
    are enabled for any change, reading the GPIO pin will tell you whether a rising
    or falling edge on the pin called the interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, the CPU will invoke the ISR almost immediately after the interrupt
    pin changes state. In practice, it is possible for the ISR invocation to be slightly
    delayed after the interrupt condition occurs; for example, some other high-priority
    code (ISR) could be executing with the interrupts disabled. In that case, the
    ISR will be called only when the current high-priority code re-enables interrupts.
    During this time, it is possible for the state of the I/O pin to change. Therefore,
    by the time the ISR reads the signal on the input pin, the input data could have
    changed, and whatever the ISR reads might be wrong (a common race condition).
    To prevent this from happening, the MCP230*xx* *captures* the state of the pins
    when the interrupt occurs. The MCP230*xx* puts this snapshot of the pins in the
    MCP23008 INTCAP or MCP23017 INTCAPA and INTCAPB registers. Therefore, the ISR
    should actually read the contents of the appropriate INTCAP*x* register to determine
    the pin state that produced the interrupt.
  prefs: []
  type: TYPE_NORMAL
- en: By reading GPIO data (GPIO*x* or INTCAP*x* port), the ISR unfreezes the INTCAP*x*.
    This prepares it to capture the next interrupt pin set. You should always read
    the INTCAP*x* register(s) first in an ISR, since it’s possible to lose captured
    information if another interrupt is pending and you read the GPIO*x* port first
    instead. Typically, there is no real need to read the GPIO*x* register(s) in an
    ISR—the INTCAP*x* register(s) usually provide all the information you need.
  prefs: []
  type: TYPE_NORMAL
- en: Pins configured for interrupt-on-change (in the INTCON*x* registers) will change
    the state that causes the next interrupt after you read the corresponding INTCAP*x*
    register. For example, if an interrupt occurred because a pin changed from high
    to low, the new interrupt condition (low to high) will not be active until you
    clear the interrupt by reading GPIO*x* or INTCAP*x*. If the pin actually toggles
    from high to low, then low to high and high to low again, the MCP230*xx* will
    signal a single interrupt only if the system has not cleared the interrupts between
    these level changes on the input pin.
  prefs: []
  type: TYPE_NORMAL
- en: Pins configured for interrupt-on-level—that is, pins configured to cause an
    interrupt based on the value appearing in a DEFVAL*x* register—continuously generate
    an interrupt signal as long as that level condition exists on the input pin. Reading
    or writing the GPIO*x* or INTCAP*x* register(s) does not reset that particular
    interrupt state until the interrupt condition ceases to exist.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 A Sample Interrupt-Driven MCP230*xx*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading rotary shaft encoders is a common way to demonstrate interrupt programming
    on MCP230*xx* devices. As it turns out, twisting a rotary encoded at a high speed
    can easily result in data loss if the CPU is often busy doing other work, like
    displaying the values read from the rotary encoders. Using an ISR to quickly capture
    the encoder data and make it available for some main thread to process can eliminate
    data loss. This section provides some simple library code that demonstrates how
    to read and display the data from a SparkFun rotary encoder with red and green
    LEDs ([https://www.sparkfun.com/products/15140](https://www.sparkfun.com/products/15140)).
  prefs: []
  type: TYPE_NORMAL
- en: The SparkFun rotary encoder breakout ([https://www.sparkfun.com/products/11722](https://www.sparkfun.com/products/11722))
    makes it easy to breadboard one of these devices into a circuit, as shown in [Figure
    13-12](#figure13-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-12: SparkFun rotary encoder breakout board'
  prefs: []
  type: TYPE_NORMAL
- en: SparkFun rotary encoders have two digital I/O pins labeled A and B, which specify
    rotational changes (see [Figure 13-13](#figure13-13)). You wire these pins through
    a 10-kΩ resistor to +5 V and wire the pin labeled C to Gnd. (If you connect the
    rotary encoder to an MCP230*xx* device, you can use the built-in programmable
    pullup resistor in place of the 10-kΩ resistor.) As you rotate the shaft on the
    encoder, it selectively connects pins A and B to pin C, that is, to Gnd. The pins
    labeled 1, 2, 3, and 4 in [Figure 13-13](#figure13-13) connect to the red and
    green LEDs, a pushbutton switch, and a common for these pins.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting pins A and B to inputs on your SBC allows you to read the state of
    the two pins (high or low). By observing the state of these two pins over time,
    you can tell which direction the shaft is rotating, and at what speed, if you
    are timing the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-13: SparkFun Red/Green rotary encoder'
  prefs: []
  type: TYPE_NORMAL
- en: If you turn the shaft clockwise (CW) at a fixed speed, you will get the waveform
    shown in [Figure 13-14](#figure13-14) on pins A and B.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-14: Rotary encoder output when rotating shaft clockwise'
  prefs: []
  type: TYPE_NORMAL
- en: The output in [Figure 13-14](#figure13-14) is known as a *quadrature output*,
    where two out-of-phase signals determine the rotation direction, producing binary
    outputs similar to those shown in [Table 13-5](#table13-5) over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-5: Clockwise Rotary Encoder Output'
  prefs: []
  type: TYPE_NORMAL
- en: '| Output A | 0 | 0 | 1 | 1 | 0 | 0 | 1 | And so on |'
  prefs: []
  type: TYPE_TB
- en: '| Output B | 1 | 0 | 0 | 1 | 1 | 0 | 0 | And so on |'
  prefs: []
  type: TYPE_TB
- en: If you treat the input pairs as a 2-bit binary value, turning the encoder clockwise
    produces the repeating binary sequence 01 00 10 11 01 00 10 11 . . . over time.
    This is an example of a 2-bit *gray code*, a binary counting sequence where no
    more than a single bit changes between any two successive values (see “For More
    Information”). Gray codes are useful when working with multibit mechanical inputs
    because they are more immune to noise than regular binary codes are.
  prefs: []
  type: TYPE_NORMAL
- en: If you turn the shaft counterclockwise (CCW) at a fixed speed, you will get
    the waveform in [Figure 13-15](#figure13-15) on pins A and B.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c13/f13015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13-15: Rotary encoder output when rotating shaft counterclockwise'
  prefs: []
  type: TYPE_NORMAL
- en: This also produces outputs similar to those shown in [Table 13-6](#table13-6)
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 13-6: Counterclockwise Rotary Encoder Output'
  prefs: []
  type: TYPE_NORMAL
- en: '| Output A | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | And so on |'
  prefs: []
  type: TYPE_TB
- en: '| Output B | 0 | 1 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | And so on |'
  prefs: []
  type: TYPE_TB
- en: 'The gray code output is the binary sequence: 00 01 11 10 00 01 . . .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to interpret the A and B inputs is to use a change in A to indicate
    a rotation of the encoder shaft and then read the B input to determine the direction
    of the rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: A high-to-low transition on A with B low during the transition indicates a CCW
    rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A low-to-high transition on A with B high also indicates a CCW rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A high-to-low transition on A with B high during the transition indicates a
    CW rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A low-to-high transition on A with B low also indicates a CW rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An MCP23008 GPIO expander would allow you to connect up to four of the SparkFun
    Illuminated Red/Green rotary encoders to a system. The encoder used in this section,
    however, connects a single rotary encoder to pins GP0 and GP1 on an MCP23008\.
    Specifically, the encoder’s A pin connects to GP1, and the B pin connects to GP0
    through optional debouncing circuitry. If you also want to control the red and
    green LEDs on the encoder from the MCP23008, you can add some resistors between
    pins on MCP23008 to be programmed as outputs, along with the pins 2 and 3 on the
    rotary encoder. You will also need to connect the pin labeled 1 to Gnd. The resistors
    should probably be between 470 Ω and 1 kΩ. You can turn the red and green LEDs
    on or off by programming those output pins with logic 1s or 0s; programming both
    pins produces a yellow output. The example in this section will ignore the LED
    outputs, but you can easily add code to control them if you want.
  prefs: []
  type: TYPE_NORMAL
- en: The rotary encoder A and B pins are dry contacts. To read logic signals from
    these pins, you would normally add pullup resistors to the circuit (to +5 V or
    +3.3 V, whichever is appropriate). Rather than explicitly adding these resistors,
    the software will enable the GP0 and GP1 pins to use the MCP23008 programmable
    pin pullup resistors.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Listing 13-2](#listing13-2) uses a change on the A pin to cause
    an interrupt. The ISR will read the A and B pin values on GP1 (A) and GP0 (B)
    and increment or decrement a global counter based on the previous and current
    readings of these pins. The main program (that is, the code outside the ISR) uses
    the value of this global variable to determine how many “clicks” the encoder has
    been turned in the clockwise or counterclockwise direction since the application
    began execution.
  prefs: []
  type: TYPE_NORMAL
- en: For the program in [Listing 13-2](#listing13-2), the MCP23008 SCL and SDA lines
    (pins 1 and 2) connect to the Teensy 3.2 SDA0 and SCL0 pins (pins D18 and D19).
    The INT line (pin 8) connects to the Teensy D2 pin. The RESET (pin 6) and Vdd
    (pin 18) pins connect to +3.3 V. The address lines and Vss (pins 3, 4, 5, and
    9) connect to Gnd. Finally, GP1 connects to the rotary encoder A pin, and GP0
    connects to the rotary encoder B pin (the rotary encoder C pin connects to ground).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-2](#listing13-2) programs the MCP23008 to generate an interrupt
    (active low) whenever there is a change on the GPA1 pin. When the ISR reads the
    INTCAP register, GP1 will reflect the value of the A pin *after* the rising or
    falling transition. Therefore, if the ISR reads 0 in the LO 2 bits of INTCAP,
    there has been a falling edge (GP1 is 0) and B is 0\. This indicates a counterclockwise
    rotation. Likewise, if the LO 2 bits of INTCAP are 3 (0b11), then there has been
    a rising edge and B is 1, which also indicates a CCW rotation.'
  prefs: []
  type: TYPE_NORMAL
- en: On a CW rotation, if the ISR reads a 1 in the LO 2 bits of INTCAP, this indicates
    a falling edge on A while B is 1\. If the ISR reads a 2 (0b10) in the LO 2 bits
    of INTCAP, this indicates a rising edge on A while B is low (also a CW rotation).
  prefs: []
  type: TYPE_NORMAL
- en: The ISR simply increments or decrements a global variable (`rotaryPosn`) on
    a CW or CCW rotation, respectively. The main program checks this global variable
    and displays its value whenever it changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 13-2](#listing13-2) contains two functions, `writeReg()` ❶ and `readReg()`
    ❷, that write data to and read data from an MCP23008 register. These functions
    transmit the appropriate I²C bytes to accomplish this. The `mcpReset()` ❸ function
    initializes the MCP23008 to the power-on reset state, which is useful if the code
    is rerun without powering down the MCP23008\. The code also includes an interrupt
    service routine, `ISRFunc()` ❹, along with the usual Arduino `setup()` 5and `loop()`
    6functions.'
  prefs: []
  type: TYPE_NORMAL
- en: When a change occurs on the GP1 pin (because the shaft has rotated), this triggers
    an interrupt, causing the system to call the `ISRFunc()` function. This function
    determines if the shaft has rotated clockwise or counterclockwise and adjusts
    the value of the `rotaryPosn` variable accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The following is some sample output from the program in [Listing 13-2](#listing13-2)
    obtained by twisting the encoder knob back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can determine from the output, the shaft was rotated counterclockwise
    for a short period, decrementing the output value, and then it was turned clockwise
    for a bit, incrementing the output value.
  prefs: []
  type: TYPE_NORMAL
- en: 13.7 MCP230**xx* Library Code*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Because of the complexity, many programmers prefer to use calls to existing
    library code rather than writing directly to the hardware themselves. Arduino
    provides an MCP230*xx* library package to help you out with this. See “For More
    Information” for the links to these libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’d prefer to program the MCP230*xx* on a Raspberry Pi, Adafruit has also
    ported its library to the Pi; see “For More Information” for details. Likewise,
    those links describe where to find an MCP23008 library for Mbed. A quick web search
    will turn up several example Mbed libraries for the MCP23017 (mostly adaptations
    of the Adafruit library). You can also easily search for the dozens of examples
    of MCP230*xx* code scattered across the internet for a wide variety of CPUs, operating
    systems, and programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 13.8 I²C Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although digital I/O functions, like reading a pushbutton, don’t require blazing
    performance, many such activities do require fast processing to properly read
    or write high-frequency digital signals. Unfortunately, high-performance operation
    and I²C bus connections are often mutually exclusive. Because it can sometimes
    take three or four bus transactions to read or write digital data via an MCP230*xx*
    device, it might require 400 μsec to 500 μsec for a single I/O operation at 100
    kHz, yielding a 2-kHz sample rate. This can be too slow for certain operations.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the MCP230*xx* devices can run at 400 kHz and up to 1.7 MHz as
    well as 100 kHz. At 400 kHz, you can achieve (at least) an 8-kHz sample rate,
    and 10 kHz to 20 kHz is not unreasonable with carefully written code. If you’re
    willing to operate the bus at 1 MHz or more, you could even get the sample rate
    up to around 100 kHz, which is suitable for most applications. If you need higher
    performance, you’ll probably want to use something other than the I²C bus, like
    SPI versions of the MCP230*xx*.
  prefs: []
  type: TYPE_NORMAL
- en: 13.9 MCP23S*xx* Parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When searching for information about the MCP23008 and MCP23017 parts, you may
    come across references to the MCP23S08 and MCP23S17 devices. These GPIO expanders
    are nearly identical to the MCP230*xx* parts, except that they were designed for
    use on the SPI bus rather than the I²C bus. Most code written for the MCP23S*xx*
    parts will work fine on the MCP230*xx* devices with minimal modifications: essentially,
    you’d change the code to call I²C library functions rather than SPI library functions
    to write and read data to and from the devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Because the SPI bus operates at a higher frequency than the I²C bus, SPI variants
    can read input data at a higher sampling frequency. For more information, see
    the MCP23*xxx* documentation (which covers both the SPI and I²C parts). Links
    appear in “For More Information.”
  prefs: []
  type: TYPE_NORMAL
- en: 13.10 Chapter Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covered the MCP23017 and MCP23008 GPIO expansion ICs. It described
    the on-chip registers, including the data, data direction, pullup, and polarity
    registers. It described how to read and write digital data via the pins on the
    MCP230*xx*. This chapter also discussed interrupt-driven I/O using the MCP230*xx*
    devices; it presented a short sample program to read a SparkFun rotary encoder
    using an ISR to help avoid missing any pulses from the encoder. Finally, this
    chapter ended by discussing the use of open-software libraries available for the
    MCP230*xx*.*
  prefs: []
  type: TYPE_NORMAL
