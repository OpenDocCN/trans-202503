- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 25 BAT FILES BUILDING BAT FILES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our post-industrial age, manufacturers can build a toaster with relative
    ease, but no one has ever built a toaster that can build another toaster, and
    I’m going out on a very short limb to say no manufacturer ever will. Robots, at
    least in part, can build robots, but cars don’t build cars, and smartphones aren’t
    smart enough to build phones of any intellect. In the realm of software, however,
    code conceives code, programs propagate programs, and bats beget bats.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter isn’t about flying mammal procreation, but instead discusses the
    technique of one bat file creating another bat file. Several languages offer an
    automated code generator, but those typically create a template or a good starting
    point from which to do the interesting coding. Here I’m referring to one bat file
    creating another fully functional and ready-to-execute bat file.
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds like a parlor trick, it isn’t. You might need information from
    one Batch process before you can write the code for a later process. Instead of
    writing the bat file for that second process, you can make the first bat file
    smart enough to write the second with all the needed information. This will also
    allow one bat file to intelligently break up large processes on the fly, dynamically
    creating any number of processes based on the size of the input.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll first jump right into a complete step-by-step example of a bat file building
    a bat file, from the parent bat file to the created child bat file and ultimately
    to the child’s output. I’ll also detail how to populate a dynamically created
    bat file with static data, resolved variables, and yet to be resolved variables.
    I’ll put this all together with a real-world application, demonstrate multigenerational
    bat files, and, most important, discuss useful applications of this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically Creating a Bat File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way to explain how a bat-file-building bat file works is through a
    simple yet (I hope) interesting example, so I’ll start with a demonstration of
    *Mother.bat*. When it executes, it’ll display its name to the console, which is
    nothing new, and then proceed to something that might have sounded like alchemy
    not long ago: building the aptly named *Daughter.bat*, a bat file that will write
    its name to the console along with the name of the bat file that gave it life
    when it itself executes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 25-1](#Lis25-1) isn’t a code snippet; it shows the complete contents
    of *Mother.bat*, the parent bat file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-1: The parent bat file, Mother.bat'
  prefs: []
  type: TYPE_NORMAL
- en: The bat file starts with a setlocal command (as all my bat files do). It turns
    the echo to off, thus keeping the console display clean. The first section of
    code ends with two echo commands, writing the name of the bat file to the console
    followed by a blank line ❶. Since we aren’t in a routine, %~0 resolves to the
    hidden parameter of the path and name of the bat file being executed ([Chapter
    11](chapter11.xhtml)). With the use of two modifiers, %~NX0 extracts just the
    filename and extension from the hidden parameter ([Chapter 17](chapter17.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: The final section of the bat file is where it gets interesting. Six echo commands
    write one line each to build the child bat file. The first echo command ❷ with
    a single redirection character creates the child bat file, writing the setlocal
    command to it. (I’ve mentioned that every bat file I write starts with this command,
    and that also goes for bat files I indirectly write via other bat files.)
  prefs: []
  type: TYPE_NORMAL
- en: Nothing here is executing the setlocal command; this code treats it as simple
    text as it redirects or writes it to *Daughter.bat*. Don’t think of it as a setlocal
    command, but as a *proto*-setlocal command. Three spaces follow the name of the
    echo command; the first space delimits the command itself from the text it’s writing,
    and the next two spaces are part of the text it writes to the file. Functionally,
    the two additional spaces aren’t necessary, but for aesthetics I always indent,
    again even in dynamically created bat files.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple commands performing redirection appear to have two echo commands each.
    Taking the last of these commands ❺ first, the initial echo writes a line to the
    child bat file, a line consisting entirely of the > con echo. text. The caret
    escape character is critical here. Without it, the interpreter would treat the
    greater-than sign after it like a second redirection operator, which obviously
    wouldn’t be good. With the caret, the greater-than sign is just another character
    written to the child bat file.
  prefs: []
  type: TYPE_NORMAL
- en: The two prior commands look quite similar to each other. Both are writing a
    record to *Daughter.bat*; both records will be echo commands writing something
    to the console, and both are using the caret as an escape character for its redirection
    character. There is, however, a critical difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: Each writes distinctive text after the asterisks, but that’s trivial. The first
    command ❸ has a second percent sign in what looks to be the resolution of the
    filename. Don’t be fooled by the subtlety; it’s the crux of this entire chapter.
    The text in the second command ❹ does in fact resolve to the name of the parent
    bat file. But in the first command ❸, the first percent sign is the escape character
    for the second percent sign, meaning that the interpreter resolves the two characters
    to a single percent sign and writes it as a simple text character to the file.
    Thus, the tilde and other characters that come next have no special meaning to
    Batch in this context, so the interpreter also writes them unchanged as text to
    the child bat file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not to put too fine a point on this, but here’s how the interpreter handles
    these similar text strings when writing the child bat file:'
  prefs: []
  type: TYPE_NORMAL
- en: The "%%~NX0" text ❸ becomes "%~NX0".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "%~NX0" text ❹ becomes "Mother.bat".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent bat file writes one last line, which will become a pause command
    ❻, to the child bat file. Finally, an actual pause command ❼ rounds out *Mother.bat*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can execute *Mother.bat*, the bat-file-building bat file shown in [Listing
    25-1](#Lis25-1). The "%~NX0" from the first section of its code ❶ resolves to
    "Mother.bat", and the following appears on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That pause command at the very end of *Mother.bat* holds the console open so
    that we can read this message.
  prefs: []
  type: TYPE_NORMAL
- en: More interesting, *Mother.bat* creates *Daughter.bat*, a fully functional bat
    file. This point cannot be stressed enough; the bat file shown in [Listing 25-2](#Lis25-2)
    was *not* created directly by a human.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 25-2: The child bat file, Daughter.bat'
  prefs: []
  type: TYPE_NORMAL
- en: The child bat file has six records with the two most interesting ones in the
    middle. As expected, the interpreter resolved "%%~NX0" from *Mother.bat* ([Listing
    25-1](#Lis25-1)) to "%~NX0" in the first of these echo commands in *Daughter.bat*.
    This will be important when *Daughter.bat* itself (herself?) executes. Likewise,
    the next echo command in the child bat file contains the "Mother.bat" text, which
    the interpreter resolved from "%~NX0" in the parent bat file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This culminates in the execution of the child bat file, *Daughter.bat*. Run
    it as you would any other bat file, and it writes the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the child bat file executes, the interpreter resolves "%~NX0" in the first
    redirected echo command to "Daughter.bat". The next line of output comes from
    the echo command containing the already resolved "Mother.bat".
  prefs: []
  type: TYPE_NORMAL
- en: As a recap, let’s follow the flow from the parent to the child to the child’s
    output. When the parent bat file executes, "%%~NX0" becomes "%~NX0" in the child
    bat file—again, two percent signs resolve to one due to escaping. Then when the
    child bat file executes, "%~NX0" resolves to "Daughter.bat" in the final output.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast that with "%~NX0" in the parent bat file, which becomes "Mother .bat"
    in the child bat file. At that point it’s hardcoded text, at least from the perspective
    of the child, and when the child bat file executes, it writes "Mother.bat" to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates two important points. First, it’s very possible for
    a bat file to create another fully functional bat file. Second, some text containing
    escape characters can become a *resolvable* variable in the child, not a resolved
    variable. Put another way, the parent can write some text to the child, and when
    the child executes, that text resolves a variable to its value. But this example
    just touches on what’s possible.
  prefs: []
  type: TYPE_NORMAL
- en: No one will confuse this process with the artificial intelligence that might
    someday kill or enslave all of humanity, but I wouldn’t call *Mother.bat* a dumb
    bat file.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can now resolve the hidden parameter in either the parent or child bat file,
    but resolving ordinary variables in either bat file is equally if not more important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables delimited by percent signs and exclamation marks behave a bit differently.
    To demonstrate, the following listing uses two system variables set on all Windows
    computers: computername is the name of the computer, and os is the machine’s operating
    system ([Chapter 21](chapter21.xhtml)). This code creates a small bat file named
    *Dynamic.bat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve encased the first reference to computername in a single set of percent
    signs ❶, and in the next command, I’ve set the first reference to os between a
    single set of exclamation marks. (Either delimiter works for either variable;
    I’m merely comparing and contrasting the two.) Both variables resolve to their
    respective values when these two echo commands execute, perhaps writing the following
    to the dynamic bat file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the next two echo commands ❷ write the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the interpreter encounters %%computername%%, it doesn’t see a variable.
    Since the percent sign is the escape character for itself, each pair resolves
    to a single percent sign, and the text between them isn’t a variable name; it’s
    just along for the ride, at least for now. As detailed in [Chapter 14](chapter14.xhtml),
    escaping the exclamation mark is a bit trickier, but ^^!os^^! similarly resolves
    to !os!.
  prefs: []
  type: TYPE_NORMAL
- en: Execute the child bat file, *Dynamic.bat*, on any computer, and the first pair
    of echo commands write what is now hardcoded text to the console—that is, they
    write the information derived from the machine where the first bat file ran. The
    next two echo commands, however, have two variables that resolve when *Dynamic.bat*
    executes, and their values reflect the computer name and operating system of the
    computer on which this child bat file runs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a real-world application to demonstrate when it makes sense to
    resolve variables as we write them to the child bat file and when it makes sense
    to resolve them as the child executes.
  prefs: []
  type: TYPE_NORMAL
- en: A Real-World Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The prior examples show how you can resolve variables and parameters in a dynamically
    created bat file, but these examples are pedagogical at their core. There’s no
    practical use for a bat file that does nothing more than announce its lineage
    and current status. A real-world bat-file-building bat file will do much more
    and be far more useful.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, it will likely transmit variables from the parent to the child.
    As any bat file executes, it accumulates and modifies variables, but nothing automatically
    imbues those variables to a dynamically created bat file. A simple way of ensuring
    that a variable is preserved in its scion is to write a set command defining that
    variable to the child. When that bat file runs, the set command executes, and
    the variable is available for the remainder of its execution or until it’s reset.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already demonstrated how to write a single line of code with an echo command,
    but you can also write the contents of an entire file into a dynamically created
    bat file with a type command ([Chapter 12](chapter12.xhtml)). Typically, I start
    a child bat file with a prologue static file and end it with an epilogue static
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The prologue static file probably starts with a setlocal command (because most
    bat files should), and it likely sets some variables, but after that the contents
    could be anything. What’s important is that this file contains the hardcoded Batch
    code that’ll begin each bat file the process dynamically creates. Likewise, the
    epilogue static file contains all of the common code needed to complete all child
    bat files. At the very least it usually contains some callable routines and error
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: Static bat files don’t have to come at the beginning and ending of dynamically
    created bat files. You can insert others with multiple type commands interspersed
    with the echo commands. You can even store just a few lines of code in a static
    file to avoid the need for escaping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing contains a template for a real-world bat-building bat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, the redirection ❶ that begins the creation of *Dynamic.bat*
    might look like the first of many echo commands, but this is the first of two
    type commands in the listing. This one writes the entirety of the *StaticPrologue.bat*
    file into the dynamically created bat file.
  prefs: []
  type: TYPE_NORMAL
- en: Two echo commands ❸ demonstrate the technique for maintaining a parent variable
    in the child bat file. The argument of each burgeoning set command has the variable
    name to the left of the equal sign and its resolved value to the right. It looks
    redundant, but this turns into a hardcoded set command assigning a value to a
    variable in the child bat file.
  prefs: []
  type: TYPE_NORMAL
- en: The next echo command ❹ demonstrates a twist on this technique; the new variable
    gets a new name. The child bat file might need to know the path variable used
    by the parent bat file, but we don’t want to impact the child’s own path variable.
    This command writes a set command that will eventually assign the full contents
    of the parent’s path variable to a variable named parentPath when *Dynamic.bat*
    executes.
  prefs: []
  type: TYPE_NORMAL
- en: There are two reasons to use the technique of escaping when creating a dynamic
    bat file. First, percent signs and exclamation marks used to resolve variables
    need escaping—sometimes. It all depends on when we should resolve the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Dynamic.bat* will invoke some executable and then check the return code. In
    this example, let’s assume that the executable is known when we create the dynamic
    bat file. For that reason, I’m simply resolving the variable as %someExe% ❺ and
    writing it directly to the dynamic bat file where it will be hardcoded text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The return code ❻ is a very different story; clearly, we should *not* resolve
    it until this command executes as the dynamic bat file runs, so I’m using escape
    characters for the delimiters. The interpreter sees %%errorlevel%% and writes
    %errorlevel% to the file. Without the escape characters, the variable would have
    simply resolved to its state at the time it was written, likely 0, resulting in
    a perpetually false conditional clause: if 0 neq 0. The escape characters leave
    this as a variable yet to be resolved.'
  prefs: []
  type: TYPE_NORMAL
- en: The second reason to use escaping in a dynamic bat file is when the character
    has some other special significance in Batch. For instance, always escape pipes
    and ampersands when they are to be part of the dynamic code. In this example,
    we need to escape the open ❻ and close ❽ parentheses around the code block, as
    well as the redirection symbol or greater-than sign ❼ inside of the code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that someExe is set to a particular value, the interpreter might write
    the section of code between ❺ and ❽ to the dynamic bat file as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second type command ❾ rounds out this listing and writes the entirety of
    *StaticEpilogue.bat* to the dynamic file. It probably uses the three variables
    that the earlier code explicitly wrote to the dynamic bat file. Given the goto
    command inside the code block, I’m also very confident that there is an :Abort
    label somewhere in this file. Whatever its contents, they’ll complete the dynamic
    bat file.
  prefs: []
  type: TYPE_NORMAL
- en: But the writing of static files to child bat files has one subtle batveat. I’ve
    passed over one very critical command in the code, so critical that I’ve saved
    it for last. Immediately after the first type command writes the static prologue
    data to the dynamically created bat file, a simple echo command ❷ appends a blank
    line to *Dynamic.bat*.
  prefs: []
  type: TYPE_NORMAL
- en: You might assume that I did this to simply separate the static code and the
    coming set commands in the new bat file, and that would’ve been a wonderful justification
    in its own right. After all, a blank line after the set commands ❹ also creates
    some whitespace solely for this purpose, but the first blank line is for much
    more than aesthetics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain the problem that this blank line is fixing, I once shared this bat-building
    bat technique with a co-worker who ended the equivalent of his *StaticPrologue.bat*
    with the setting of a critical variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This data is the very end of the file; there isn’t even a trailing blank line.
    It will be crucial momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the type command in his main bat file, he didn’t write a blank line.
    Instead, he set a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The ultimate result was this line of code in the middle of his dynamic bat
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What looks to be a second set command isn’t a command at all; it’s just more
    text, including the spaces, appended to the intended value of the *actual* set
    command. The result is dynamic code that doesn’t set criticalVar to the intended
    value and doesn’t set someVar at all. It’s pretty obvious that the result is garbage,
    but what caused this?
  prefs: []
  type: TYPE_NORMAL
- en: When the interpreter performs an echo command redirected to a file, it appends
    the text to the very end of the target file. Then the interpreter immediately
    appends the two characters for a carriage return line feed, or more informally,
    it adds a CRLF. (I detailed the CRLF in [Chapter 14](chapter14.xhtml).) The end
    result is that when you view it in an editor, there’s an empty line at the bottom
    of the file. When you redirect multiple echo commands one after another, each
    command appends a line of text and a CRLF so that the next command appends its
    text as a new record.
  prefs: []
  type: TYPE_NORMAL
- en: That works great when you create the file exclusively with dynamically generated
    code via echo commands, but the type command writes an entire file just as it
    is into the target without adding a CRLF. That causes a potential problem if the
    creator of the static bat file didn’t append a CRLF onto the final record of the
    file. (That is, they didn’t position the cursor at the end of the last record,
    hit ENTER, and save the file.) When the interpreter writes the static file missing
    that CRLF to the dynamic bat file and then tries to append a record via an echo
    command, it actually appends that record to the final record of the copied static
    data instead, resulting in the dog’s breakfast we see here. (It also results in
    a frustrated co-worker trying to figure out why a couple variables aren’t resolved
    as expected.)
  prefs: []
  type: TYPE_NORMAL
- en: The echo. command ❷ writes a null or blank record (not even any spaces) and,
    more important, a CRLF. Its inclusion here ensures that if the CRLF is missing
    from the last record of the static file, the code will insert another CRLF in
    the dynamically created bat file, and if it isn’t missing, it writes a null record,
    which nicely separates the sections of code. If you’re really counting on that
    whitespace, write two blank lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems like a never-ending battle to make code bullet-proof and to anticipate
    every possible condition that can break it, but there are two primary means of
    avoiding this issue: ensure that every static file you use ends with a CRLF, or
    write the blank line after every type command that doesn’t complete the child
    bat file. I find it far easier to control this in the code with the latter option,
    but it’s not a bad idea to always do both.'
  prefs: []
  type: TYPE_NORMAL
- en: Multigenerational Bat Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The quote “Give me a lever long enough and a fulcrum on which to place it, and
    I shall move the world” is attributed to Archimedes. I’d like to think that if
    the ancient Greeks had Batch, the great thinker would’ve said, “Give me enough
    escape characters and disk space, and I shall create an infinite bat-file-creating
    bat file.” Undoubtedly, this quote pales in comparison to the original, but escape
    characters can be escaped, and bat files aren’t limited to a single generation
    of offspring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stripped of everything superfluous, this bare-bones version of *Mother.bat*
    will create a child bat file that’ll create a progeny of its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing *Mother.bat* produces *Daughter.bat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that ^> escapes to > and %% escapes to %, but by escaping the escape
    character, ^^^> becomes ^> and %%%% becomes %%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing *Daughter.bat* produces *GrandDaughter.bat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running *GrandDaughter.bat* produces the following output to the console where
    %~NX0 resolves one last time, this time to "GrandDaughter.bat":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I have an admission to make. This last example is nothing more than an egregious
    instance of the author shamelessly showing off—the coder’s equivalent of an endzone
    dance or a geek version of trash talk after a dunk. I’ve been coding in Batch
    for many years, and this is the first time I’ve ever even thought to code a bat
    that builds a bat that builds a bat. I’ve done it here only to show what’s possible
    and am hard-pressed to come up with a real-world application for it, but there
    are many uses for a bat file that creates a second bat file.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the real-world application discussed earlier as a template for
    more complex dynamic bat files. It has all the pieces you’ll need: it assigns
    variables, using existing and new names; it uses escaping to allow variables to
    be resolved later; it escapes other special characters to be used in the child
    bat file; and it uses partial static bat files in tandem with the dynamically
    generated code.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique is great when a process grows to the point where you need to
    break it down into smaller chunks and execute them independently. Perhaps you’ll
    base the breakdown on the size of the input so you can write a bat file to build
    one to many dynamically created bat files after inspecting that input. Put another
    way, you can dynamically create a dynamic number of subprocesses.
  prefs: []
  type: TYPE_NORMAL
- en: The different subprocesses might even end up running on different servers to
    balance the load. You might be able to use static bat files for those subprocesses,
    but when you dynamically generate the other bat files, you can imbue them with
    information gathered during the execution of the original bat file.
  prefs: []
  type: TYPE_NORMAL
- en: Some might protest that you can pass the dynamic information as arguments to
    the second bat file, but that works only if the first bat actually calls the second.
    Some completely different process might execute your dynamically created bat file.
    That process doesn’t have to pass any arguments or even understand the contents
    of the bat file or its function. You can even create a bat file, hold it, and
    execute it at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I showed how a bat file can build another bat file. After a
    detailed demonstration, I discussed how to write resolved variables and resolvable
    variables to a dynamic bat file. I also shared some techniques that I use for
    creating variables in a dynamic bat file and building these bat files with both
    dynamic and static code. You learned situations in which dynamically created bat
    files are most useful and applicable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll demonstrate an intriguing application of a bat-building
    bat. After discussing a very useful technique of automatically restarting an intermittent
    failure, I’ll apply lessons from this chapter to perform an even more difficult
    task, killing and restarting a hung execution. We’ll dynamically create a second
    bat file to call the process susceptible to hanging and monitor it from the first
    bat file. It’s amazing how problems start to find solutions in tools from an expanding
    toolkit.
  prefs: []
  type: TYPE_NORMAL
