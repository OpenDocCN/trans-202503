- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: 25 BAT FILES BUILDING BAT FILES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: In our post-industrial age, manufacturers can build a toaster with relative
    ease, but no one has ever built a toaster that can build another toaster, and
    I’m going out on a very short limb to say no manufacturer ever will. Robots, at
    least in part, can build robots, but cars don’t build cars, and smartphones aren’t
    smart enough to build phones of any intellect. In the realm of software, however,
    code conceives code, programs propagate programs, and bats beget bats.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This chapter isn’t about flying mammal procreation, but instead discusses the
    technique of one bat file creating another bat file. Several languages offer an
    automated code generator, but those typically create a template or a good starting
    point from which to do the interesting coding. Here I’m referring to one bat file
    creating another fully functional and ready-to-execute bat file.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: If this sounds like a parlor trick, it isn’t. You might need information from
    one Batch process before you can write the code for a later process. Instead of
    writing the bat file for that second process, you can make the first bat file
    smart enough to write the second with all the needed information. This will also
    allow one bat file to intelligently break up large processes on the fly, dynamically
    creating any number of processes based on the size of the input.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: I’ll first jump right into a complete step-by-step example of a bat file building
    a bat file, from the parent bat file to the created child bat file and ultimately
    to the child’s output. I’ll also detail how to populate a dynamically created
    bat file with static data, resolved variables, and yet to be resolved variables.
    I’ll put this all together with a real-world application, demonstrate multigenerational
    bat files, and, most important, discuss useful applications of this technique.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically Creating a Bat File
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way to explain how a bat-file-building bat file works is through a
    simple yet (I hope) interesting example, so I’ll start with a demonstration of
    *Mother.bat*. When it executes, it’ll display its name to the console, which is
    nothing new, and then proceed to something that might have sounded like alchemy
    not long ago: building the aptly named *Daughter.bat*, a bat file that will write
    its name to the console along with the name of the bat file that gave it life
    when it itself executes.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 25-1](#Lis25-1) isn’t a code snippet; it shows the complete contents
    of *Mother.bat*, the parent bat file.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 25-1: The parent bat file, Mother.bat'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The bat file starts with a setlocal command (as all my bat files do). It turns
    the echo to off, thus keeping the console display clean. The first section of
    code ends with two echo commands, writing the name of the bat file to the console
    followed by a blank line ❶. Since we aren’t in a routine, %~0 resolves to the
    hidden parameter of the path and name of the bat file being executed ([Chapter
    11](chapter11.xhtml)). With the use of two modifiers, %~NX0 extracts just the
    filename and extension from the hidden parameter ([Chapter 17](chapter17.xhtml)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: bat 文件以 setlocal 命令开始（就像我写的所有 bat 文件一样）。它将 echo 设置为关闭，从而保持控制台显示干净。代码的第一部分以两个
    echo 命令结束，分别将 bat 文件的名称写入控制台，并随后加上一个空行 ❶。由于我们没有进入常规过程，%~0 解析为正在执行的 bat 文件的路径和名称的隐藏参数（[第
    11 章](chapter11.xhtml)）。通过使用两个修饰符，%~NX0 只提取隐藏参数中的文件名和扩展名（[第 17 章](chapter17.xhtml)）。
- en: The final section of the bat file is where it gets interesting. Six echo commands
    write one line each to build the child bat file. The first echo command ❷ with
    a single redirection character creates the child bat file, writing the setlocal
    command to it. (I’ve mentioned that every bat file I write starts with this command,
    and that also goes for bat files I indirectly write via other bat files.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: bat 文件的最后一部分才是最有趣的地方。六个 echo 命令分别写一行来构建子 bat 文件。第一个 echo 命令 ❷ 使用一个重定向字符创建子 bat
    文件，并将 setlocal 命令写入其中。（我提到过，我写的每个 bat 文件都以这个命令开始，这对于通过其他 bat 文件间接写入的 bat 文件同样适用。）
- en: Nothing here is executing the setlocal command; this code treats it as simple
    text as it redirects or writes it to *Daughter.bat*. Don’t think of it as a setlocal
    command, but as a *proto*-setlocal command. Three spaces follow the name of the
    echo command; the first space delimits the command itself from the text it’s writing,
    and the next two spaces are part of the text it writes to the file. Functionally,
    the two additional spaces aren’t necessary, but for aesthetics I always indent,
    again even in dynamically created bat files.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有执行 setlocal 命令；这段代码将其视为简单文本，将其重定向或写入 *Daughter.bat*。不要把它当作 setlocal 命令，而应当视作
    *proto* setlocal 命令。echo 命令后跟三个空格；第一个空格将命令本身与它写入的文本分开，接下来的两个空格是它写入文件的文本的一部分。从功能上讲，这两个额外的空格不是必需的，但出于美学考虑，我总是进行缩进，即使是在动态创建的
    bat 文件中也是如此。
- en: Multiple commands performing redirection appear to have two echo commands each.
    Taking the last of these commands ❺ first, the initial echo writes a line to the
    child bat file, a line consisting entirely of the > con echo. text. The caret
    escape character is critical here. Without it, the interpreter would treat the
    greater-than sign after it like a second redirection operator, which obviously
    wouldn’t be good. With the caret, the greater-than sign is just another character
    written to the child bat file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 执行重定向的多个命令似乎每个都有两个 echo 命令。从这些命令中的最后一个 ❺ 开始，第一个 echo 将一行写入子 bat 文件，这一行完全由 `>
    con echo.` 文本组成。插入符号转义字符在这里至关重要。如果没有它，解释器会把它后面的大于号当作第二个重定向操作符，这显然是不好的。有了插入符号，大于号只是作为另一个字符写入子
    bat 文件。
- en: The two prior commands look quite similar to each other. Both are writing a
    record to *Daughter.bat*; both records will be echo commands writing something
    to the console, and both are using the caret as an escape character for its redirection
    character. There is, however, a critical difference between them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的两个命令看起来非常相似。它们都是将记录写入 *Daughter.bat*；这两条记录都是 echo 命令，将某些内容写入控制台，并且都使用插入符号作为其重定向字符的转义字符。然而，它们之间有一个关键的区别。
- en: Each writes distinctive text after the asterisks, but that’s trivial. The first
    command ❸ has a second percent sign in what looks to be the resolution of the
    filename. Don’t be fooled by the subtlety; it’s the crux of this entire chapter.
    The text in the second command ❹ does in fact resolve to the name of the parent
    bat file. But in the first command ❸, the first percent sign is the escape character
    for the second percent sign, meaning that the interpreter resolves the two characters
    to a single percent sign and writes it as a simple text character to the file.
    Thus, the tilde and other characters that come next have no special meaning to
    Batch in this context, so the interpreter also writes them unchanged as text to
    the child bat file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Not to put too fine a point on this, but here’s how the interpreter handles
    these similar text strings when writing the child bat file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The "%%~NX0" text ❸ becomes "%~NX0".
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "%~NX0" text ❹ becomes "Mother.bat".
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent bat file writes one last line, which will become a pause command
    ❻, to the child bat file. Finally, an actual pause command ❼ rounds out *Mother.bat*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can execute *Mother.bat*, the bat-file-building bat file shown in [Listing
    25-1](#Lis25-1). The "%~NX0" from the first section of its code ❶ resolves to
    "Mother.bat", and the following appears on the console:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That pause command at the very end of *Mother.bat* holds the console open so
    that we can read this message.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: More interesting, *Mother.bat* creates *Daughter.bat*, a fully functional bat
    file. This point cannot be stressed enough; the bat file shown in [Listing 25-2](#Lis25-2)
    was *not* created directly by a human.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 25-2: The child bat file, Daughter.bat'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The child bat file has six records with the two most interesting ones in the
    middle. As expected, the interpreter resolved "%%~NX0" from *Mother.bat* ([Listing
    25-1](#Lis25-1)) to "%~NX0" in the first of these echo commands in *Daughter.bat*.
    This will be important when *Daughter.bat* itself (herself?) executes. Likewise,
    the next echo command in the child bat file contains the "Mother.bat" text, which
    the interpreter resolved from "%~NX0" in the parent bat file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'This culminates in the execution of the child bat file, *Daughter.bat*. Run
    it as you would any other bat file, and it writes the following to the console:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the child bat file executes, the interpreter resolves "%~NX0" in the first
    redirected echo command to "Daughter.bat". The next line of output comes from
    the echo command containing the already resolved "Mother.bat".
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: As a recap, let’s follow the flow from the parent to the child to the child’s
    output. When the parent bat file executes, "%%~NX0" becomes "%~NX0" in the child
    bat file—again, two percent signs resolve to one due to escaping. Then when the
    child bat file executes, "%~NX0" resolves to "Daughter.bat" in the final output.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Contrast that with "%~NX0" in the parent bat file, which becomes "Mother .bat"
    in the child bat file. At that point it’s hardcoded text, at least from the perspective
    of the child, and when the child bat file executes, it writes "Mother.bat" to
    the console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates two important points. First, it’s very possible for
    a bat file to create another fully functional bat file. Second, some text containing
    escape characters can become a *resolvable* variable in the child, not a resolved
    variable. Put another way, the parent can write some text to the child, and when
    the child executes, that text resolves a variable to its value. But this example
    just touches on what’s possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: No one will confuse this process with the artificial intelligence that might
    someday kill or enslave all of humanity, but I wouldn’t call *Mother.bat* a dumb
    bat file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Variable Resolution
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can now resolve the hidden parameter in either the parent or child bat file,
    but resolving ordinary variables in either bat file is equally if not more important.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables delimited by percent signs and exclamation marks behave a bit differently.
    To demonstrate, the following listing uses two system variables set on all Windows
    computers: computername is the name of the computer, and os is the machine’s operating
    system ([Chapter 21](chapter21.xhtml)). This code creates a small bat file named
    *Dynamic.bat*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I’ve encased the first reference to computername in a single set of percent
    signs ❶, and in the next command, I’ve set the first reference to os between a
    single set of exclamation marks. (Either delimiter works for either variable;
    I’m merely comparing and contrasting the two.) Both variables resolve to their
    respective values when these two echo commands execute, perhaps writing the following
    to the dynamic bat file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, the next two echo commands ❷ write the following two lines:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the interpreter encounters %%computername%%, it doesn’t see a variable.
    Since the percent sign is the escape character for itself, each pair resolves
    to a single percent sign, and the text between them isn’t a variable name; it’s
    just along for the ride, at least for now. As detailed in [Chapter 14](chapter14.xhtml),
    escaping the exclamation mark is a bit trickier, but ^^!os^^! similarly resolves
    to !os!.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Execute the child bat file, *Dynamic.bat*, on any computer, and the first pair
    of echo commands write what is now hardcoded text to the console—that is, they
    write the information derived from the machine where the first bat file ran. The
    next two echo commands, however, have two variables that resolve when *Dynamic.bat*
    executes, and their values reflect the computer name and operating system of the
    computer on which this child bat file runs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a real-world application to demonstrate when it makes sense to
    resolve variables as we write them to the child bat file and when it makes sense
    to resolve them as the child executes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: A Real-World Application
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The prior examples show how you can resolve variables and parameters in a dynamically
    created bat file, but these examples are pedagogical at their core. There’s no
    practical use for a bat file that does nothing more than announce its lineage
    and current status. A real-world bat-file-building bat file will do much more
    and be far more useful.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了如何在动态创建的批处理文件中解析变量和参数，但这些示例本质上是教学用的。仅仅用来宣布其来源和当前状态的批处理文件并没有实际用途。一个真实的批处理文件构建批处理文件将会做更多的事情，并且更加有用。
- en: For instance, it will likely transmit variables from the parent to the child.
    As any bat file executes, it accumulates and modifies variables, but nothing automatically
    imbues those variables to a dynamically created bat file. A simple way of ensuring
    that a variable is preserved in its scion is to write a set command defining that
    variable to the child. When that bat file runs, the set command executes, and
    the variable is available for the remainder of its execution or until it’s reset.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它可能会将变量从父级传递到子级。每当批处理文件执行时，它会累积和修改变量，但没有什么是自动将这些变量赋值到动态创建的批处理文件中的。确保变量在其后代文件中保留的简单方法是写入一个`set`命令，将该变量传递给子文件。当该批处理文件运行时，`set`命令执行，变量将可用，直到它被重置或文件执行结束。
- en: I’ve already demonstrated how to write a single line of code with an echo command,
    but you can also write the contents of an entire file into a dynamically created
    bat file with a type command ([Chapter 12](chapter12.xhtml)). Typically, I start
    a child bat file with a prologue static file and end it with an epilogue static
    file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示了如何用`echo`命令写入一行代码，但你也可以使用`type`命令将整个文件的内容写入动态创建的批处理文件中（[第12章](chapter12.xhtml)）。通常，我会用前言静态文件开始一个子批处理文件，并用尾声静态文件结束它。
- en: The prologue static file probably starts with a setlocal command (because most
    bat files should), and it likely sets some variables, but after that the contents
    could be anything. What’s important is that this file contains the hardcoded Batch
    code that’ll begin each bat file the process dynamically creates. Likewise, the
    epilogue static file contains all of the common code needed to complete all child
    bat files. At the very least it usually contains some callable routines and error
    handling.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前言静态文件可能以`setlocal`命令开始（因为大多数批处理文件应该这样做），并且很可能设置了一些变量，但其后内容可以是任何内容。重要的是，这个文件包含硬编码的批处理代码，启动每个动态创建的批处理文件的过程。同样，尾声静态文件包含完成所有子批处理文件所需的公共代码。至少，它通常包含一些可调用的例程和错误处理。
- en: Static bat files don’t have to come at the beginning and ending of dynamically
    created bat files. You can insert others with multiple type commands interspersed
    with the echo commands. You can even store just a few lines of code in a static
    file to avoid the need for escaping.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 静态批处理文件不必仅仅出现在动态创建的批处理文件的开始和结束。你可以插入其他命令，并且将多个`type`命令与`echo`命令交替使用。你甚至可以将少量代码存储在一个静态文件中，以避免使用转义字符。
- en: 'The following listing contains a template for a real-world bat-building bat:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含一个实际批处理文件构建的模板：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At first glance, the redirection ❶ that begins the creation of *Dynamic.bat*
    might look like the first of many echo commands, but this is the first of two
    type commands in the listing. This one writes the entirety of the *StaticPrologue.bat*
    file into the dynamically created bat file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，开始创建*Dynamic.bat*的重定向❶可能像是众多`echo`命令中的第一个，但实际上它是列表中第二个`type`命令的第一个。这个命令将*StaticPrologue.bat*文件的全部内容写入动态创建的批处理文件中。
- en: Two echo commands ❸ demonstrate the technique for maintaining a parent variable
    in the child bat file. The argument of each burgeoning set command has the variable
    name to the left of the equal sign and its resolved value to the right. It looks
    redundant, but this turns into a hardcoded set command assigning a value to a
    variable in the child bat file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`echo`命令❸演示了如何在子批处理文件中保持父级变量。每个逐渐展开的`set`命令的参数都包含变量名，等号左侧是变量名，右侧是解析后的值。看起来有些冗余，但这会变成一个硬编码的`set`命令，将值赋给子批处理文件中的变量。
- en: The next echo command ❹ demonstrates a twist on this technique; the new variable
    gets a new name. The child bat file might need to know the path variable used
    by the parent bat file, but we don’t want to impact the child’s own path variable.
    This command writes a set command that will eventually assign the full contents
    of the parent’s path variable to a variable named parentPath when *Dynamic.bat*
    executes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的 echo 命令 ❹ 展示了这一技术的一个变体；新的变量获得了一个新的名称。子 bat 文件可能需要知道父 bat 文件使用的路径变量，但我们不想影响子文件自身的路径变量。此命令写入一个
    set 命令，最终会将父文件路径变量的完整内容赋值给一个名为 parentPath 的变量，当 *Dynamic.bat* 执行时。
- en: There are two reasons to use the technique of escaping when creating a dynamic
    bat file. First, percent signs and exclamation marks used to resolve variables
    need escaping—sometimes. It all depends on when we should resolve the variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转义技术来创建动态 bat 文件有两个原因。首先，用于解析变量的百分号和感叹号有时需要转义——这取决于我们何时应该解析变量。
- en: '*Dynamic.bat* will invoke some executable and then check the return code. In
    this example, let’s assume that the executable is known when we create the dynamic
    bat file. For that reason, I’m simply resolving the variable as %someExe% ❺ and
    writing it directly to the dynamic bat file where it will be hardcoded text.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dynamic.bat* 将调用某个可执行文件，然后检查返回码。在这个示例中，假设我们在创建动态 bat 文件时就已经知道了可执行文件。因此，我只是将变量解析为
    %someExe% ❺ 并将其直接写入动态 bat 文件中，成为硬编码的文本。'
- en: 'The return code ❻ is a very different story; clearly, we should *not* resolve
    it until this command executes as the dynamic bat file runs, so I’m using escape
    characters for the delimiters. The interpreter sees %%errorlevel%% and writes
    %errorlevel% to the file. Without the escape characters, the variable would have
    simply resolved to its state at the time it was written, likely 0, resulting in
    a perpetually false conditional clause: if 0 neq 0. The escape characters leave
    this as a variable yet to be resolved.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 返回码 ❻ 是一个完全不同的故事；显然，我们*不应该*在命令执行之前解析它，因为动态 bat 文件在运行时会执行此命令，所以我使用了转义字符来处理分隔符。解释器看到
    %%errorlevel%% 并将 %errorlevel% 写入文件。如果没有转义字符，变量会在写入时直接解析为它当时的状态，可能是 0，导致一个永远为假的条件语句：if
    0 neq 0。转义字符将其保留为尚未解析的变量。
- en: The second reason to use escaping in a dynamic bat file is when the character
    has some other special significance in Batch. For instance, always escape pipes
    and ampersands when they are to be part of the dynamic code. In this example,
    we need to escape the open ❻ and close ❽ parentheses around the code block, as
    well as the redirection symbol or greater-than sign ❼ inside of the code block.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转义字符的第二个原因是在字符在 Batch 中有其他特殊意义时。例如，当管道符和与符号要作为动态代码的一部分时，必须始终对它们进行转义。在这个例子中，我们需要转义代码块周围的开括号
    ❻ 和闭括号 ❽，以及代码块内部的重定向符号或大于号 ❼。
- en: 'Assuming that someExe is set to a particular value, the interpreter might write
    the section of code between ❺ and ❽ to the dynamic bat file as:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 someExe 被设置为某个特定值，解释器可能会将 ❺ 和 ❽ 之间的代码段写入动态 bat 文件，如下所示：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second type command ❾ rounds out this listing and writes the entirety of
    *StaticEpilogue.bat* to the dynamic file. It probably uses the three variables
    that the earlier code explicitly wrote to the dynamic bat file. Given the goto
    command inside the code block, I’m also very confident that there is an :Abort
    label somewhere in this file. Whatever its contents, they’ll complete the dynamic
    bat file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 type 命令 ❾ 补充了这个列表，并将整个 *StaticEpilogue.bat* 写入动态文件。它可能使用了之前代码中明确写入动态 bat
    文件的三个变量。考虑到代码块内的 goto 命令，我也很有信心这个文件中某处会有一个 :Abort 标签。不管它的内容是什么，它们都会完成动态 bat 文件的编写。
- en: But the writing of static files to child bat files has one subtle batveat. I’ve
    passed over one very critical command in the code, so critical that I’ve saved
    it for last. Immediately after the first type command writes the static prologue
    data to the dynamically created bat file, a simple echo command ❷ appends a blank
    line to *Dynamic.bat*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，将静态文件写入子 bat 文件时有一个微妙的警告。我忽略了代码中一个非常关键的命令，这么关键，以至于我把它留到了最后。在第一个 type 命令将静态序言数据写入动态创建的
    bat 文件之后，一个简单的 echo 命令 ❷ 会向 *Dynamic.bat* 添加一个空行。
- en: You might assume that I did this to simply separate the static code and the
    coming set commands in the new bat file, and that would’ve been a wonderful justification
    in its own right. After all, a blank line after the set commands ❹ also creates
    some whitespace solely for this purpose, but the first blank line is for much
    more than aesthetics.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为我这样做只是为了简单地分隔新批处理文件中的静态代码和即将到来的设置命令，这本身就是一个很好的理由。毕竟，在设置命令之后的空白行❹也仅为此目的创建了一些空白空间，但是第一个空白行的作用远不止美观。
- en: 'To explain the problem that this blank line is fixing, I once shared this bat-building
    bat technique with a co-worker who ended the equivalent of his *StaticPrologue.bat*
    with the setting of a critical variable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这个空白行修复的问题，我曾经与一个同事分享过这个批处理构建技术，他在其*StaticPrologue.bat*的等效末尾设置了一个关键变量：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This data is the very end of the file; there isn’t even a trailing blank line.
    It will be crucial momentarily.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据是文件的最后；甚至没有尾随的空白行。这很快就会变得至关重要。
- en: 'After the type command in his main bat file, he didn’t write a blank line.
    Instead, he set a variable:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的主批处理文件中的type命令之后，他没有写一个空白行。相反，他设置了一个变量：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The ultimate result was this line of code in the middle of his dynamic bat
    file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是他动态批处理文件中间的这行代码：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What looks to be a second set command isn’t a command at all; it’s just more
    text, including the spaces, appended to the intended value of the *actual* set
    command. The result is dynamic code that doesn’t set criticalVar to the intended
    value and doesn’t set someVar at all. It’s pretty obvious that the result is garbage,
    but what caused this?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像是第二个设置命令实际上并不是命令；它只是更多文本的附加，包括空格，附加到*实际*设置命令的预期值上。结果是动态代码未将criticalVar设置为预期值，并且根本没有设置someVar。显然，结果是垃圾，但是是什么导致了这种情况？
- en: When the interpreter performs an echo command redirected to a file, it appends
    the text to the very end of the target file. Then the interpreter immediately
    appends the two characters for a carriage return line feed, or more informally,
    it adds a CRLF. (I detailed the CRLF in [Chapter 14](chapter14.xhtml).) The end
    result is that when you view it in an editor, there’s an empty line at the bottom
    of the file. When you redirect multiple echo commands one after another, each
    command appends a line of text and a CRLF so that the next command appends its
    text as a new record.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器执行重定向到文件的echo命令时，它将文本追加到目标文件的末尾。然后解释器立即追加两个字符以换行回车，或者更不正式地说，添加一个CRLF。（我在[第14章](chapter14.xhtml)详细描述了CRLF。）最终结果是，在编辑器中查看时，在文件底部会有一个空行。当您连续重定向多个echo命令时，每个命令都会追加一行文本和一个CRLF，以便下一个命令将其文本追加为新记录。
- en: That works great when you create the file exclusively with dynamically generated
    code via echo commands, but the type command writes an entire file just as it
    is into the target without adding a CRLF. That causes a potential problem if the
    creator of the static bat file didn’t append a CRLF onto the final record of the
    file. (That is, they didn’t position the cursor at the end of the last record,
    hit ENTER, and save the file.) When the interpreter writes the static file missing
    that CRLF to the dynamic bat file and then tries to append a record via an echo
    command, it actually appends that record to the final record of the copied static
    data instead, resulting in the dog’s breakfast we see here. (It also results in
    a frustrated co-worker trying to figure out why a couple variables aren’t resolved
    as expected.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你仅通过echo命令动态生成代码创建文件时，这很有效，但是type命令会将整个文件原样写入目标而不添加CRLF。如果静态批处理文件的创建者没有在文件的最后一个记录上附加CRLF，则可能会引发问题。（也就是说，他们没有将光标定位在最后一个记录的末尾，按ENTER键并保存文件。）当解释器将缺少该CRLF的静态文件写入动态批处理文件，然后尝试通过echo命令追加记录时，实际上会将该记录追加到复制的静态数据的最后一个记录上，导致我们在这里看到的一团糟。（这也导致了一位沮丧的同事试图弄清楚为什么一些变量没有按预期解析。）
- en: The echo. command ❷ writes a null or blank record (not even any spaces) and,
    more important, a CRLF. Its inclusion here ensures that if the CRLF is missing
    from the last record of the static file, the code will insert another CRLF in
    the dynamically created bat file, and if it isn’t missing, it writes a null record,
    which nicely separates the sections of code. If you’re really counting on that
    whitespace, write two blank lines.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems like a never-ending battle to make code bullet-proof and to anticipate
    every possible condition that can break it, but there are two primary means of
    avoiding this issue: ensure that every static file you use ends with a CRLF, or
    write the blank line after every type command that doesn’t complete the child
    bat file. I find it far easier to control this in the code with the latter option,
    but it’s not a bad idea to always do both.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Multigenerational Bat Files
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The quote “Give me a lever long enough and a fulcrum on which to place it, and
    I shall move the world” is attributed to Archimedes. I’d like to think that if
    the ancient Greeks had Batch, the great thinker would’ve said, “Give me enough
    escape characters and disk space, and I shall create an infinite bat-file-creating
    bat file.” Undoubtedly, this quote pales in comparison to the original, but escape
    characters can be escaped, and bat files aren’t limited to a single generation
    of offspring.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Stripped of everything superfluous, this bare-bones version of *Mother.bat*
    will create a child bat file that’ll create a progeny of its own:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Executing *Mother.bat* produces *Daughter.bat*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that ^> escapes to > and %% escapes to %, but by escaping the escape
    character, ^^^> becomes ^> and %%%% becomes %%.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing *Daughter.bat* produces *GrandDaughter.bat*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running *GrandDaughter.bat* produces the following output to the console where
    %~NX0 resolves one last time, this time to "GrandDaughter.bat":'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I have an admission to make. This last example is nothing more than an egregious
    instance of the author shamelessly showing off—the coder’s equivalent of an endzone
    dance or a geek version of trash talk after a dunk. I’ve been coding in Batch
    for many years, and this is the first time I’ve ever even thought to code a bat
    that builds a bat that builds a bat. I’ve done it here only to show what’s possible
    and am hard-pressed to come up with a real-world application for it, but there
    are many uses for a bat file that creates a second bat file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the real-world application discussed earlier as a template for
    more complex dynamic bat files. It has all the pieces you’ll need: it assigns
    variables, using existing and new names; it uses escaping to allow variables to
    be resolved later; it escapes other special characters to be used in the child
    bat file; and it uses partial static bat files in tandem with the dynamically
    generated code.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: This technique is great when a process grows to the point where you need to
    break it down into smaller chunks and execute them independently. Perhaps you’ll
    base the breakdown on the size of the input so you can write a bat file to build
    one to many dynamically created bat files after inspecting that input. Put another
    way, you can dynamically create a dynamic number of subprocesses.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The different subprocesses might even end up running on different servers to
    balance the load. You might be able to use static bat files for those subprocesses,
    but when you dynamically generate the other bat files, you can imbue them with
    information gathered during the execution of the original bat file.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Some might protest that you can pass the dynamic information as arguments to
    the second bat file, but that works only if the first bat actually calls the second.
    Some completely different process might execute your dynamically created bat file.
    That process doesn’t have to pass any arguments or even understand the contents
    of the bat file or its function. You can even create a bat file, hold it, and
    execute it at a later time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I showed how a bat file can build another bat file. After a
    detailed demonstration, I discussed how to write resolved variables and resolvable
    variables to a dynamic bat file. I also shared some techniques that I use for
    creating variables in a dynamic bat file and building these bat files with both
    dynamic and static code. You learned situations in which dynamically created bat
    files are most useful and applicable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll demonstrate an intriguing application of a bat-building
    bat. After discussing a very useful technique of automatically restarting an intermittent
    failure, I’ll apply lessons from this chapter to perform an even more difficult
    task, killing and restarting a hung execution. We’ll dynamically create a second
    bat file to call the process susceptible to hanging and monitor it from the first
    bat file. It’s amazing how problems start to find solutions in tools from an expanding
    toolkit.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
