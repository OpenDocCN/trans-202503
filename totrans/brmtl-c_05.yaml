- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Numbers and Variables
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数字与变量
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Now that we have written a trivial program or two, it’s time to get the machine
    to do some real work. In this chapter you will learn how to manipulate numbers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经写了一个简单的程序，是时候让机器做一些实际的工作了。在这一章中，你将学习如何操作数字。
- en: 'As embedded programmers, we are concerned with exactly what the numbers are
    doing. For example, the number 32 could represent the number of sheep in a barnyard,
    or it could energize GPIO pin #4, which turns on the big red warning light. What’s
    worse, our STM32 groups up to 32 different GPIOs into a single number, so while
    32 might tell the device to “turn on the big red light,” 34 could tell it to “turn
    on the big red light and sound the klaxon.” To control our devices, we need to
    know precisely what these numbers are doing. Thus, we will take a deep dive into
    the numbers as seen by the computer.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为嵌入式程序员，我们非常关心这些数字到底在做什么。例如，数字32可以表示一个牧场里的羊的数量，也可以表示GPIO引脚#4的电平，控制开启大红色警告灯。更糟糕的是，我们的STM32将最多32个GPIO引脚组合成一个数字，因此，32可能表示“开启大红灯”，而34可能表示“开启大红灯并发出警报”。为了控制我们的设备，我们需要精确地知道这些数字到底在做什么。因此，我们将深入探讨计算机如何看待这些数字。
- en: Once you know what a number is, you will learn how to work with it by using
    variables to store the information in our program. Next, you’ll practice manipulating
    the bits in the hardware’s I/O registers to turn various functions on or off.
    In the process, you’ll see how the program in Chapter 3 worked behind the scenes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了一个数字是什么，你就可以学会如何使用变量来存储程序中的信息。接下来，你将练习操作硬件的I/O寄存器中的位，来开启或关闭各种功能。在此过程中，你将看到第3章中的程序是如何在后台工作的。
- en: Working with Integers
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作整数
- en: We’ll start with integers, or whole numbers. These are numbers without a decimal
    point, such as 37, 45, –8, and 256.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从整数开始，或者说是从整数开始。整数是没有小数点的数字，例如37、45、-8和256。
- en: '[Table 4-1](#table4-1) lists the operations you can do with numbers in C.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4-1](#table4-1)列出了你可以在C语言中对数字进行的操作。'
- en: 'Table 4-1: Number Operators in C'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1：C语言中的数字操作符
- en: '| **Operator** | **Description** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **描述** |'
- en: '| --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `+` | Add |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加 |'
- en: '| `-` | Subtract |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减 |'
- en: '| `*` | Multiply |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘 |'
- en: '| `/` | Divide (truncates to a whole number) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除（截断为整数） |'
- en: '| `%` | Modulus (returns the remainder after division) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取模（返回除法后的余数） |'
- en: 'The following listing illustrates how these operators work:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的列表展示了这些操作符是如何工作的：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We demonstrate each operation inside a `printf` statement that prints the result.
    To print the result of a calculation using `printf`, put a `%d` in the string
    where you want a number to appear and then list the calculation as a second argument
    to `printf`. Notice that if you want to print a `%` to represent the modulus operation,
    you need to specify it twice.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`printf`语句中展示每一个操作，它会打印出结果。要使用`printf`打印计算结果，请在字符串中放置一个`%d`，表示你想要显示一个数字，然后将计算结果作为第二个参数传给`printf`。请注意，如果你想打印出`%`表示取模操作，你需要将其指定两次。
- en: To view this program’s output, let’s get it into our IDE. Start System Workbench
    for STM32 and then go through the list of steps in Chapter 2 to create a program.
    (A checklist in the appendix summarizes these steps.) This time, however, instead
    of creating a “Hello World” program, we’ll create an empty native C/C++ project,
    so select **C Managed Build** as the template.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此程序的输出，我们需要将其导入到我们的IDE中。启动STM32的System Workbench，然后按照第2章中的步骤创建一个程序。（附录中的检查表总结了这些步骤。）不过这次，我们不是创建一个“Hello
    World”程序，而是创建一个空的本地C/C++项目，因此选择**C托管构建**作为模板。
- en: Under Project Type, choose **Executable**▶**Empty Project**. Next, create the
    program file by selecting **File**▶**New**▶**Source File**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目类型下，选择**可执行文件**▶**空项目**。接下来，通过选择**文件**▶**新建**▶**源文件**来创建程序文件。
- en: Enter the program text into the editing window and then save the file. Build
    the binary and run it as you did in Chapter 2. The program should display its
    output at the bottom of the Console window (see [Figure 4-1](#figure4-1)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序文本输入编辑窗口，然后保存文件。像第2章中那样构建二进制文件并运行它。程序应在控制台窗口的底部显示其输出（见[图4-1](#figure4-1)）。
- en: '![f04001](image_fi/501621c04/f04001.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f04001](image_fi/501621c04/f04001.png)'
- en: 'Figure 4-1: The run result'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：运行结果
- en: As you can see, the program should print the result of each calculation it performs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序应该打印出它执行的每一个计算结果。
- en: Declaring Variables to Hold Integers
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明变量以存储整数
- en: 'Our program performed operations on fixed numbers, but we can also use variables
    to store information that can change. Before any variable can be used, it has
    to be *declared*. The format of a variable declaration is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序对固定的数字进行了操作，但我们也可以使用变量来存储可以变化的信息。在任何变量可以使用之前，必须先*声明*它。变量声明的格式如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For example, using `int` as the type would indicate that the variable is an
    integer. To be precise, it is the type of integer that the computer can most easily
    handle. We will get into other types of integers later in this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`int`作为类型表示该变量是一个整数。准确来说，它是计算机最容易处理的整数类型。我们将在本章稍后讨论其他类型的整数。
- en: 'Variable names begin with a letter and must contain only letters, digits, and
    the underscore. The STM32 firmware library uses the camel case variable naming
    style, where words within the name are capitalized, so to be compatible, we use
    camel case throughout this book:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名以字母开头，且只能包含字母、数字和下划线。STM32固件库采用驼峰命名法，变量名中的单词首字母大写，因此为了兼容，我们在本书中贯穿使用驼峰命名法：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While names can begin with an underscore, such names are considered reserved
    for system functions and should not be used in ordinary programming. Also, never
    use `l` (lowercase *L*) or `O` (uppercase *O*) as a variable name. In case the
    reasons aren’t obvious, consider the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然变量名可以以下划线开头，但这种命名方式被视为系统函数保留名，不应在普通编程中使用。此外，绝不要将`l`（小写*L*）或`O`（大写*O*）用作变量名。如果原因不明显，请考虑以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Technically, you can omit the comment from your variable declaration. However,
    including a comment gives the people who work with the code after you an idea
    of why you declared the variable and what it does. In other words, it helps you
    create a mini-dictionary or glossary.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你可以省略变量声明中的注释。然而，包含注释能够让之后与代码一起工作的人了解你声明该变量的原因及其功能。换句话说，它帮助你创建一个迷你词典或术语表。
- en: Assigning Values to Variables
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为变量赋值
- en: 'Once we’ve declared a variable, we can assign it a value with an assignment
    statement. The general form of an assignment statement is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦声明了一个变量，就可以通过赋值语句为其赋值。赋值语句的一般形式如下：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This tells the computer to compute the value of the expression and store it
    in the variable. Variables can then be used anyplace we put an integer, such as
    a `printf` statement. The following program demonstrates variable declaration,
    assignment, and use:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉计算机计算表达式的值并将其存储在变量中。然后，可以在任何需要整数的地方使用这些变量，例如`printf`语句。以下程序演示了变量声明、赋值和使用：
- en: '**var.c**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**var.c**'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This program creates two variables, `aNumber` and `otherNumber`, and then assigns
    them each a value and prints the sum. Enter this program into System Workbench
    for STM32 now.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序创建了两个变量，`aNumber` 和 `otherNumber`，然后为它们赋值并打印它们的和。现在将此程序输入到System Workbench
    for STM32中。
- en: Initializing Variables
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化变量
- en: When you declare a variable in your program, you tell the C compiler to allocate
    memory space for an integer (`int`). But before you specify a value for it, this
    variable is considered *uninitialized*; it may contain any random garbage value
    left over from the last time the memory was used.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在程序中声明一个变量时，你告诉C编译器为一个整数（`int`）分配内存空间。但在你为它指定值之前，该变量被认为是*未初始化的*；它可能包含任何来自上次内存使用的随机垃圾值。
- en: To see this at work in the program we just wrote, open the debugger and take
    a look at the Variables panel as you step through the program. Before you assign
    them values, our two variables, `aNumber` and `otherNumber`, have values of zero.
    But uninitialized variables could have any value; the fact that they’re zero here
    is pure luck.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们刚刚编写的程序中的工作情况，可以打开调试器，在程序逐步执行时查看变量面板。在赋值之前，我们的两个变量，`aNumber` 和 `otherNumber`，的值是零。但未初始化的变量可能会有任何值；它们在这里是零，纯粹是运气使然。
- en: 'We can initialize a variable at declaration time by adding an assignment to
    it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在声明时为变量添加赋值来初始化它：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a good idea in most cases, as it makes sure our program is working
    with an expected value. Let’s rewrite our program to add these initializers:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这是一个好主意，因为它确保我们的程序使用的是预期的值。让我们重写程序，添加这些初始化器：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we’ve made that change, we can delete the lines that initialize the variables
    later in the program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做出更改，就可以删除程序中稍后初始化变量的行。
- en: Integer Sizes and Representations
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数大小和表示
- en: C has integer types other than `int` that it uses to represent numbers of different
    sizes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言有其他整数类型，除了 `int`，它们用于表示不同大小的数字。
- en: As computers evolved, people discovered that the most efficient way to organize
    memory is in 8-bit groups called *bytes*. The computer lets you combine multiple
    bytes into 2-byte, 4-byte, and 8-byte values, and the `int` type tells C to define
    an integer using the most efficient number of bytes for the computer you are using.
    This may be a 16-bit (2-byte) integer or a 32-bit (4-byte) integer, depending
    on the system. The compiler for our chip, the ARM Cortex-M0 CPU, uses a 32-bit
    integer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着计算机的发展，人们发现最有效的内存组织方式是将内存分为 8 位一组，称为 *字节*。计算机允许你将多个字节组合成 2 字节、4 字节和 8 字节的值，`int`
    类型告诉 C 语言使用适合你所使用计算机的最有效字节数来定义一个整数。这可以是一个 16 位（2 字节）整数，或者 32 位（4 字节）整数，取决于系统。我们芯片的编译器，即
    ARM Cortex-M0 CPU，使用的是 32 位整数。
- en: To make programs even more efficient, C lets you select the type of integer
    you want. For example, you may wish to store numbers in the range of 0 to 100\.
    You don’t need a full-size integer for that, so you can use a `short int`, which
    is like an integer but takes up less space. (Technically, the C standard only
    states that a `short int` is no larger than a regular `int`, but in most implementations
    it is smaller.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使程序更加高效，C 语言让你选择所需的整数类型。例如，你可能只需要存储范围在 0 到 100 之间的数字。对于这种情况，你不需要使用完整大小的整数，因此可以使用
    `short int`，它像整数一样，但占用更少的空间。（严格来说，C 标准只规定 `short int` 不大于常规的 `int`，但在大多数实现中，它通常较小。）
- en: 'The following declares a `short int`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明了一个 `short int`：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A longer-than-normal integer can be declared with the modifier `long`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个比正常整数更长的整数可以使用修饰符 `long` 来声明：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When computers gained the ability to efficiently process even longer numbers,
    people needed an integer type that could contain even more bits than a `long`
    does. The result was the (somewhat silly) `long long` integer:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机获得了高效处理更长数字的能力时，人们需要一种能够容纳比 `long` 更多位数的整数类型。结果就是（有些愚蠢的）`long long` 整数：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The C standard does not define the size of each type of integer. They could
    all be the same size, and you’d still have a standard compiler. However, it does
    guarantee the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准并未定义每种整数类型的大小。它们可能都具有相同的大小，你仍然可以使用标准编译器。然而，它确实保证了以下几点：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `sizeof` operator returns the number of bytes it takes to store a variable
    or type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`sizeof` 运算符返回存储一个变量或类型所需的字节数。'
- en: 'Let’s see how much space each type of integer takes for the compiler on our
    system using a short program to print the sizes of the various flavors of integer:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简短的程序来打印不同整数类型的大小，看看在我们系统上的编译器中每种整数类型占用多少空间：
- en: '**size.c**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**size.c**'
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Earlier, we used `%d` to print a number. In this program, we use `%ld`, because
    `sizeof` returns a `long int` and `%ld` is used to print `long int` numbers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们用 `%d` 打印一个数字。在这个程序中，我们使用 `%ld`，因为 `sizeof` 返回的是一个 `long int`，而 `%ld` 用来打印
    `long int` 类型的数字。
- en: 'The program produces the following output on my system:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序在我的系统上产生以下输出：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From this, we can see that the size of a `long int` is the same as a `long long
    int`. However, that is true only for this compiler on this system (GNU GCC on
    an x86_64 processor). Different compilers might implement things differently.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们可以看出，`long int` 的大小与 `long long int` 的大小相同。然而，这只适用于这个编译器和系统（在 x86_64 处理器上的
    GNU GCC）。不同的编译器可能会有不同的实现方式。
- en: Number Representations
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字表示法
- en: 'Let’s say we have five cows. In English, we could represent that number as
    “five,” “5,” or “V.” Likewise, in C, you can use four number representations:
    decimal, binary, octal, and hexadecimal.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有五头牛。在英语中，我们可以将这个数字表示为“five”，“5”或“V”。同样，在 C 语言中，你可以使用四种数字表示法：十进制、二进制、八进制和十六进制。
- en: 'People typically use decimal (base 10), but computers store numbers in binary
    (base 2) because it’s cheap and easy to make binary circuits. For example, we
    might write the following assignment statement using decimal:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常使用十进制（基数 10），但计算机存储数字是用二进制（基数 2），因为二进制电路便宜且容易制造。例如，我们可以使用十进制写出以下赋值语句：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This same statement could be written in binary like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的语句可以用二进制这样写：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The prefix 0b indicates a binary number follows. (We could use 0B too, but it’s
    harder to read.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀 0b 表示接下来是二进制数。（我们也可以使用 0B，但它更难阅读。）
- en: 'Or, we could use octal (base 8):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用八进制（基数 8）：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we can use hexadecimal (base 16):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用十六进制（基数 16）：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Binary numbers take up a lot of room to write, so to make things more compact,
    we often use hexadecimal notation in programming to represent exact binary values.
    Each single hex digit translates into four binary bits, as shown in [Table 4-2](#table4-2).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数字占用很多空间，因此为了使其更加紧凑，在编程中我们常常使用十六进制表示法来表示精确的二进制值。每一个十六进制数字对应四个二进制位，如[表4-2](#table4-2)所示。
- en: 'Table 4-2: Converting Between Binary and Hex'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2：二进制与十六进制的转换
- en: '| **Binary** | **Hex** | **Binary** | **Hex** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十六进制** | **二进制** | **十六进制** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0000 | 0 | 1000 | 8 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 | 1000 | 8 |'
- en: '| 0001 | 1 | 1001 | 9 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 | 1001 | 9 |'
- en: '| 0010 | 2 | 1010 | A |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 | 1010 | A |'
- en: '| 0011 | 3 | 1011 | B |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 | 1011 | B |'
- en: '| 0100 | 4 | 1100 | C |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 | 1100 | C |'
- en: '| 0101 | 5 | 1101 | D |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 | 1101 | D |'
- en: '| 0110 | 6 | 1110 | E |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 | 1110 | E |'
- en: '| 0111 | 7 | 1111 | F |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 | 1111 | F |'
- en: As you can see, 1111 1100b is the equivalent of the hex value 0xFC. Similarly,
    0xA5 is 1010 0101b. Using this table, you can quickly and easily translate between
    binary and hexadecimal.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，1111 1100b 等同于十六进制值 0xFC。同样地，0xA5 是 1010 0101b。通过使用这个表格，你可以快速且轻松地在二进制和十六进制之间转换。
- en: While the computer stores a number as a set of bits, the meaning of those bits
    is entirely up to us. For example, the bit pattern 0000 0101 could mean 5 if we
    interpret it as a binary number. But 0000 0101 could also mean 10,005\. How did
    I get that number? I made it up. In this case, I arbitrarily picked a strange
    value. Other arbitrary meanings could include “May,” the letter “E,” and “LED0+LED2.”
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管计算机将数字存储为一组位，但这些位的含义完全由我们决定。例如，位模式 0000 0101 如果我们将其解释为二进制数字，则表示 5。但 0000 0101
    也可以表示 10,005。是怎么得到这个数字的？我随便编的。在这种情况下，我随意选择了一个奇怪的值。其他任意的含义可能包括“五月”、字母“E”或“LED0+LED2”。
- en: One less common but still useful bit pattern mapping is shown in [Table 4-3](#table4-3).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不太常见但仍然有用的位模式映射显示在[表4-3](#table4-3)中。
- en: 'Table 4-3: A Bit Pattern to Number Mapping'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3：位模式到数字的映射
- en: '| **Bit pattern** | **Meaning** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **位模式** | **含义** |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 000 | 0 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 000 | 0 |'
- en: '| 001 | 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 001 | 1 |'
- en: '| 011 | 2 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 011 | 2 |'
- en: '| 010 | 3 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 010 | 3 |'
- en: '| 110 | 4 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 4 |'
- en: '| 111 | 5 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 5 |'
- en: '| 101 | 6 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 101 | 6 |'
- en: '| 100 | 7 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 7 |'
- en: At first glance, it looks random. But if you look closely, you’ll see that only
    one bit changes between each number. This makes it ideal for use in encoders (see
    [Figure 4-2](#figure4-2)). It is, in fact, a standard bit pattern encoding called
    *Gray code*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，它看起来是随机的。但如果仔细观察，你会发现每个数字之间只有一位发生变化。这使得它非常适合用在编码器中（参见[图4-2](#figure4-2)）。它实际上是一种标准的位模式编码，称为*格雷码*。
- en: '![f04002](image_fi/501621c04/f04002.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![f04002](image_fi/501621c04/f04002.png)'
- en: 'Figure 4-2: A Gray code encoder'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：一种格雷编码器
- en: Remember that C has no idea how to interpret a bit pattern until you tell it
    how.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，C语言在你告诉它如何解释位模式之前并不知道如何处理这些位模式。
- en: Standard Integers
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准整数
- en: The big problem with the integer types is that nothing in the standard tells
    you how big they are, just their relative sizes. If you want to write to a 32-bit
    device, you have to guess which type of `int` will be the size you want.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型的一个大问题是，标准并没有告诉你它们的大小，只告诉你它们的相对大小。如果你想写入一个32位的设备，你就得猜测哪种`int`类型的大小符合你的要求。
- en: 'Guessing and programming do not mix well together, so people devised systems
    using a technique called *conditional compilation* (see Chapter 12) and other
    tricks to define new types that hold a precise number of bits: `int8_t`, `int16_t`,
    `int32_t`, and `int64_t`. The name of the type specifies the size of the integer.
    For example, the type `int32_t` has 32 bits in it no matter what size the `int`
    is. Like most good ideas, these new types became widely used—so widely used that
    the C standards committee decided to add them to the language with the `stdint`
    library. They are not part of the built-in C types, so you have to include them
    by using the following statement:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测和编程并不容易结合在一起，因此人们发明了使用名为*条件编译*（参见第12章）和其他技巧的系统，用来定义包含精确位数的新类型：`int8_t`、`int16_t`、`int32_t`和`int64_t`。类型的名称指定了整数的大小。例如，`int32_t`类型无论`int`的大小如何，始终包含32位。像大多数好主意一样，这些新类型被广泛使用——如此广泛，以至于C标准委员会决定将它们添加到语言中，并通过`stdint`库实现。它们并不是C的内建类型，所以你需要通过以下声明来包含它们：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Listing 4-1](#listing4-1) shows our new integer types in action.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-1](#listing4-1)展示了我们新整数类型的实际应用。'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 4-1: Integer demonstration'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-1：整数演示
- en: In this program, we use the formatting character `%x` to print the numbers in
    hexadecimal. Specifically, the `%x` format character prints an `int` in hexadecimal,
    but we can also use it for `int8_t`, `int16_t`, and `int32_t` because of some
    behind-the-scenes stuff called *argument promotion*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: C is a somewhat lazy language. Because it’s hard to pass a 16-bit integer to
    `printf` when your processor has 32-bit registers, C takes the `int16_t` and converts,
    or *promotes*, it to an `int32_t` for this one operation, which lets us get away
    with using `%x` for an `int16_t`. Similarly, we can use `%x` for an `int8_t` because
    it will get promoted to an `int32_t` as well. (Strictly speaking, the C standard
    states that promotion *may* occur. It does not require it. This code works on
    our x86_64 machine with this compiler, but it is not portable to other systems.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Now we come to `int64_t`. If C were to change this into an `int` (`int32_t`),
    we’d lose half our number. C can’t do anything to it, so it passes an `int64_t`
    argument as an `int64_t` argument. The format had to change from `%x` (`int`)
    to `%lx` (`int64_t`) to print the longer value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Investigation for the reader: try changing `%lx` to `%x` in the example and
    see what you get.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned Integer Types
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last section, we used signed integer types, which can be either positive
    or negative. Unsigned integer types hold only positive values and are simpler
    than their signed counterparts. The standard unsigned types are `uint8_t`, `uint16_t`,
    `uint32_t`, and `uint64_t`. The type `uint8_t` is an unsigned 8-bit integer that
    can hold numbers from 0 (0000 0000b) to 255 (1111 1111b). The ranges of the unsigned
    integer types are shown in [Table 4-4](#table4-4).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-4: Unsigned Integer Type Ranges'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Low** | **High** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `uint8_t` | 0000 0000 (0) | 1111 1111 (255) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `uint16_t` | 0000 0000 0000 0000 (0) | 1111 1111 1111 1111 (65,535) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `uint32_t` | 0000 0000 0000 0000 0000 0000 0000 0000 (0) | 1111 1111 1111
    1111 1111 1111 1111 1111 (4,294,967,295) |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `uint64_t` | 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
    0000 0000 0000 0000 (0) | 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111
    1111 1111 1111 1111 1111 (18,446,744,073,709,551,615) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: 'Here’s a simple example of using a `uint8_t` variable. This program prints
    three different representations for `smallNumber` without changing its value:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `%u printf` specification tells C we want to print an unsigned `int` (the
    default unsigned integer type). We use the format specification `%o` to print
    in octal and `%x` to print in hexadecimal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this program looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Overflow
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we will explore the limits of our machine. Actually, we will exceed them.
    The biggest `uint8_t` number is 255 (0b1111 1111). What happens when we go beyond
    that and try to print 255 + 1? Let’s try it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: According to this program, the result of adding 1 to the 8-bit unsigned integer
    255 is 256, but the number 256 in binary is 0b1 0000 0000, or 0x100, which can’t
    fit in 8 bits. Either we’ve warped the laws of the universe or something went
    wrong with our program.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据此程序，将8位无符号整数255加1的结果是256，但是256的二进制表示为0b1 0000 0000，或者0x100，在8位中无法容纳。要么我们扭曲了宇宙的法则，要么我们的程序出了问题。
- en: 'To understand what’s going on, let’s take a look at the print statement 1.
    The type of `smallNumber` is `uint8_t`; however, on most 32-bit computers, it’s
    hard, if not impossible, to add two 8-bit integers. Because of the way the computer
    is constructed, you have to add two 32-bit numbers. So, to compute an expression,
    the C compiler does the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解正在发生的事情，让我们看看打印语句1。`smallNumber`的类型是`uint8_t`；然而，在大多数32位计算机上，添加两个8位整数是困难的，如果不是不可能的话，这是因为计算机的构造方式，你必须添加两个32位数。因此，为了计算表达式，C编译器执行以下操作：
- en: Converts `shortNumber` to a `unit32_t` value
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`shortNumber`转换为`unit32_t`值
- en: Adds 1 to the result (of type `uint32_t`)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果（类型为`uint32_t`）加1
- en: Prints the result (256) as a `uint32_t`
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果（256）作为`uint32_t`
- en: The result is a `uint32_t` that can hold the value 256, and that’s what’s printed.
    So, we did not cause an 8-bit overflow (which we wanted to demonstrate). Instead,
    we demonstrated automatic promotion, which we discussed earlier in this chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个可以容纳值为256的`uint32_t`，这就是打印出来的内容。因此，我们没有引起8位溢出（我们本想演示的）。相反，我们演示了自动提升，这在本章前面讨论过。
- en: 'To get the result we want, we need to make a slight adjustment to the program
    to store the result in a `uint8_t` value (I’ve highlighted the changes to our
    program in bold):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到我们想要的结果，我们需要稍微调整程序，将结果存储在`uint8_t`值中（我已经用粗体突出了程序的更改）：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now the result is 0\. Why? Because our calculation returned 0b1111 1111 + 0b000
    0001 = 0b1 **0000 0000**. Only the bold portion was stored due to the limited
    space in which to store the variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果是0。为什么？因为我们的计算返回了0b1111 1111 + 0b000 0001 = 0b1 **0000 0000**。由于变量的存储空间有限，只存储了粗体部分。
- en: '*Overflow* occurs when the result is too big for the machine to handle. In
    this case, the 9-bit result won’t fit in an 8-bit value. Think of a car’s odometer.
    It can display mileage to 999,999\. What happens if someone drives a million miles?'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*溢出*发生在结果对机器处理过大的情况下。在这种情况下，9位结果无法适应8位值。想象一下汽车的里程表。它可以显示999,999英里的里程。如果有人开了一百万英里会发生什么？'
- en: Understanding how the compiler is manipulating the numbers is key to making
    good embedded programs. For example, I once had a GPS that kept altitude as an
    unsigned number. (It was not designed to work on submarines.) I took it on a trip
    to Death Valley, and it died. That’s because when I reached Badwater Basin, elevation
    –282 feet, it couldn’t handle the negative altitude. The GPS’s designers had assumed
    that all altitudes would be greater than zero. After all, the GPS was not designed
    to work underwater. Therefore, using an unsigned integer for altitude was not
    an unreasonable decision—except for users in locations like Badwater Basin, where
    the altitude is negative, causing the GPS to die. This mistake shows why it’s
    important to know the limitations of your numbering system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 了解编译器如何操作数字是编写良好的嵌入式程序的关键。例如，我曾经有过一个将高度作为无符号数的GPS（它不是设计用于潜艇）。我把它带到了死亡谷，它死了。那是因为当我到达Badwater
    Basin时，高程为-282英尺时，它无法处理负高程。GPS的设计者假设所有高度都大于零。毕竟，GPS不是设计用于水下工作的。因此，对于高度使用无符号整数并不是一个不合理的决定——除了像Badwater
    Basin这样的地方的用户，高度是负数，导致GPS死机。这个错误显示了为什么知道你的编号系统的限制是很重要的。
- en: Two’s Complement Representation in Signed Integer Types
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有符号整数类型的二进制补码表示法
- en: 'Signed numbers are represented by using one bit (the leftmost) as a sign bit:
    if the bit is 1, the number is negative. Thus, 8-bit signed integers (`int8_t`)
    can represent numbers from 127 to –128.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号数使用一个位（最左边的位）作为符号位：如果该位为1，则该数为负数。因此，8位有符号整数（`int8_t`）可以表示从127到-128的数字。
- en: Almost all computers today use two’s complement numbers to represent negative
    values. *Two’s complement representation* stores a number as that number pre-subtracted
    from 0.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代计算机使用二进制补码表示负值。*二进制补码表示法*将一个数存储为从0中减去该数的值。
- en: 'For example, –1 can be determined by the following calculation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，-1可以通过以下计算确定：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This works because the computer adds a magic “borrow” bit to the left of the
    number, making the arithmetic look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为计算机会在数字左边添加一个神奇的“借位”位，使得算术运算看起来是这样的：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Two’s complement is similar to a mechanical car odometer. Let’s say you buy
    a brand-new car and its odometer reads 000,000\. If you drove backward, your odometer
    would read 999,999, which is the ten’s complement of –1.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 二的补码类似于机械汽车的里程表。假设你买了一辆崭新的车，里程表显示为 000,000。如果你倒车，里程表会显示 999,999，这是 –1 的十补码。
- en: You may have noticed that the biggest number a `uint8_t` can hold is 255, whereas
    an `int8_t` can store only values up to 127 (half that). That’s because one bit
    is used as the sign bit, leaving only seven bits to store the number part.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`uint8_t` 能表示的最大值是 255，而 `int8_t` 只能存储最大为 127 的值（是其一半）。这是因为一个比特被用作符号位，剩下的七个比特用于存储数字部分。
- en: What happens when we exceed the boundaries with 8-bit signed numbers? I’m going
    to let you investigate that yourself. See what happens with the operations 127
    + 1 and –128 – 1\. Also see what happens with –(–128), the negation of –128.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们超出 8 位有符号数的边界时会发生什么？我让你自己去探索这个问题。看看 127 + 1 和 –128 – 1 会发生什么。还要看看 –(–128)
    会发生什么，即 –128 的取反操作。
- en: Shorthand Operators
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简写操作符
- en: You’ve learned about integers and the simple operations that can be done on
    them, but to let you do arithmetic faster, C provides a number of shorthand operators.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了整数以及可以对它们执行的简单操作，但为了让你更快地进行算术运算，C 语言提供了一些简写操作符。
- en: 'For example, consider adding a value to a number, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑将一个值加到一个数字上，如下所示：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can shorten this operation to the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个操作缩写为以下形式：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can perform similar shortcuts for all the other arithmetic operators.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对所有其他算术操作符执行类似的简化。
- en: 'Additionally, you can condense the operation of adding 1 to a number:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以将将 1 加到数字上的操作简化为：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It can be shortened to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以简化为这样：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To decrement numbers by 1, use the `--` (minus minus) operator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数字减去 1，可以使用 `--`（减减）运算符。
- en: 'There is a caveat. C lets you combine the increment (`++`) and decrement (`--`)
    operations with other statements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个警告。C 语言允许你将递增（`++`）和递减（`--`）操作与其他语句结合使用：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Please don’t do this, as it can cause the program to have undefined behavior.
    For example, consider the following statements:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要这样做，因为这可能会导致程序出现未定义的行为。例如，考虑以下语句：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The second statement tells C to increment `aNumber`, then increment `aNumber`
    again. It then multiplies `aNumber` with itself and increments `aNumber` a third
    time. Finally, it adds this to the result.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句告诉 C 语言递增 `aNumber`，然后再递增一次。接着它将 `aNumber` 与自身相乘，并再次递增 `aNumber`。最后，它将结果加到最终结果中。
- en: Unfortunately, nothing tells C that these operations have to occur in the order
    I’ve listed here. For example, all the increments could come at the beginning,
    making the result (5 × 5 + 5) = 30\. Or they could come one at a time, and we
    would have (3 × 4 + 5) = 17\. For those reasons, be sure to put `++` and `--`
    on lines by themselves.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有任何东西告诉 C 语言这些操作必须按照我在这里列出的顺序进行。例如，所有的递增操作可以放在开头，导致结果为 (5 × 5 + 5) = 30。或者它们可以一次一个地执行，那么结果将是
    (3 × 4 + 5) = 17。因此，务必将 `++` 和 `--` 独立放在一行。
- en: 'One more thing: there are two forms of increment and decrement operations.
    You can place the operator either before or after the variable you would like
    to increment:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点：递增和递减操作有两种形式。你可以将操作符放在你想递增的变量之前或之后：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These do slightly different things. I leave it to the reader to write a small
    program to print the results of the preceding code and figure out what they do—and
    then please never again use `++` combined with another statement.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些会做些略有不同的事情。我留给读者写一个小程序，打印前述代码的结果，并弄明白它们的作用——然后请永远不要再将 `++` 与其他语句结合使用。
- en: Controlling Memory-Mapped I/O Registers Using Bit Operations
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用位操作控制内存映射 I/O 寄存器
- en: We can organize eight bits into a single number, but these bits can also represent
    eight different things. For example, they can be wired to eight different LED
    lights. In fact, when you place values in special memory locations called *memory-mapped
    I/O registers*, these values turn on or off I/O pins. Since there are eight bits
    to the register’s byte, a single register can control eight LEDs. (Or, in our
    case, one LED and seven pins on which we can add more LEDs.)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将八个位组织成一个单一的数字，但这些位也可以表示八个不同的东西。例如，它们可以连接到八个不同的LED灯上。事实上，当你将值放入特殊的内存位置——称为*内存映射I/O寄存器*——时，这些值会打开或关闭I/O引脚。由于寄存器的字节有八个位，一个寄存器可以控制八个LED灯。（或者，在我们的例子中，控制一个LED和七个引脚，我们可以在这些引脚上连接更多的LED灯。）
- en: 'Bits are normally numbered from 7 to 0, with 7 being the leftmost, or most
    significant, bit. Let’s say our LED register is set up as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 位通常从7到0编号，7是最左边或最重要的位。假设我们的LED寄存器设置如下：
- en: '| Bit 7 | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 位7 | 位6 | 位5 | 位4 | 位3 | 位2 | 位1 | 位0 |'
- en: '| Out 7 | Out 6 | Out 5 | Out 4 | Out 3 | Out 2 | Out 1 | LED 0 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 输出 7 | 输出 6 | 输出 5 | 输出 4 | 输出 3 | 输出 2 | 输出 1 | LED 0 |'
- en: 'Say we want to turn on LED #0\. As each LED is off, our register has the value
    0000 0000 in it. To turn on LED #0, we need to flip the final bit to a value of
    1\. To do that, we just add 1 to the register to get 0000 0001\. LED #0 turns
    on and all the others stay off.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们要打开LED #0。由于每个LED都是关闭的，我们的寄存器的值是0000 0000。要打开LED #0，我们需要将最后一位翻转为1。为此，我们只需要将寄存器加1，得到0000
    0001。LED #0亮起，其他LED保持关闭。'
- en: 'But what if the LED was already on? Then our register would contain 0000 0001,
    and when we add 1, we’ll get 2, which in binary is 0000 0010\. Thus, LED #0 turns
    off and OUT #1 turns on. Not what we wanted.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '但如果LED已经亮了呢？那我们的寄存器会包含0000 0001，当我们加1时，得到的结果是2，二进制表示为0000 0010。这样，LED #0会关闭，输出#1会亮起。这不是我们想要的结果。'
- en: The problem here is that the arithmetic operators we’ve been using treat our
    8-bit integer as a single integer. The *bitwise operators* treat the number as
    a set of individual bits, each of which can be turned on, turned off, and tested
    independently.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是我们使用的算术运算符将我们的8位整数视为单一的整数，而*按位操作符*则将数字视为一组独立的位，每个位都可以独立开关和测试。
- en: OR
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 或
- en: The first bitwise operator is *OR* (`|`). The single-bit version of OR gives
    a true (or 1) result if either of its two operands is set to 1\. I’m going to
    show how it operates using a *truth table*. It’s like the addition and multiplication
    tables you used in first grade, only it shows the operation of Boolean operators
    such as OR.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个按位操作符是*或*（`|`）。OR的单比特版本，如果两个操作数中有任何一个是1，则结果为真（或1）。我将通过一个*真值表*来展示它的运作方式。这就像你在一年级时使用的加法和乘法表，只不过它展示了像OR这样的布尔操作符的运算。
- en: 'The truth table for OR looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: OR的真值表如下所示：
- en: '| OR (`&#124;`) | 0 | 1 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 或（`&#124;`） | 0 | 1 |'
- en: '| 0 | 0 | 1 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: 'OR is a bitwise operator, which means that to “OR” two 8-bit values together,
    you perform the operation for each pair of bits in the two values. For example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: OR是一个按位操作符，这意味着为了将两个8位值进行“或”运算，你需要对两个值中的每一对位执行操作。例如：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To set bit 0 (that is, to turn on LED #0), we use the following C code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '要设置位0（即打开LED #0），我们可以使用以下C代码：'
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Alternatively, we can use the following shorthand operator:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用以下简写操作符：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: AND
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与
- en: 'The *AND* (`&`) operator returns a true (1) only if both of its operands are
    true. The following is the AND truth table:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*与*（`&`）操作符只有在两个操作数都为真时才返回真（1）。以下是AND的真值表：'
- en: '| AND (`&`) | 0 | 1 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 与（`&`） | 0 | 1 |'
- en: '| 0 | 0 | 0 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: 'Like OR, the AND operator works on each pair of bits:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 像OR操作符一样，AND操作符作用于每一对位：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To turn off LED #0, we can set bit 0 to a value of 0 with the following operation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '要关闭LED #0，我们可以使用以下操作将位0设置为0：'
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This command “ANDs” our register with a bit pattern that has every bit set *except*
    bit 0, so bit 0 will be cleared and all the other bits will be unchanged. (ANDing
    a bit with 1 keeps its value.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将我们的寄存器与一个位模式进行“与”操作，该模式将除了位0以外的所有位都设为1，因此位0将被清除，其他所有位保持不变。（将一个位与1进行“与”操作可以保持其值。）
- en: NOT
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取反
- en: 'The *invert*, or *NOT*, operator (`~`) takes one operand and inverts it. Thus,
    if the bit is 0, it becomes 1, and if it’s 1, it becomes 0\. The truth table for
    the NOT operator is rather simple:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*取反*（*NOT*）操作符（`~`）接受一个操作数并对其进行取反。因此，如果该位为0，它变为1；如果该位为1，它变为0。NOT操作符的真值表相当简单：'
- en: '|  | 0 | 1 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  | 0 | 1 |'
- en: '| `~` | 1 | 0 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 1 | 0 |'
- en: 'The following example demonstrates how this operator works:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了该操作符的运作方式：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Using the bitwise operators we’ve covered so far, we can already write some
    code to turn off all registers and then turn on and off the LED:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们到目前为止学过的按位操作符，我们已经可以编写代码来关闭所有寄存器，然后打开和关闭 LED：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is exactly what the blink program from Chapter 3 was doing, except that
    the STM library hid these details from us.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是第 3 章中的闪烁程序所做的，只不过 STM 库将这些细节隐藏了起来。
- en: Exclusive OR
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异或
- en: 'The result of the bitwise operator *exclusive OR* (`^`) is true if one or the
    other bit is set, but not both. Here is its truth table:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 按位操作符*异或*（`^`）的结果为真，当且仅当两个对应的位中有一个为 1，而另一个为 0。下面是它的真值表：
- en: '| Exclusive OR (`^`) | 0 | 1 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 异或（`^`） | 0 | 1 |'
- en: '| 0 | 0 | 1 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: 'To see how it works, consider the following example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看它是如何工作的，请考虑以下示例：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Exclusive OR is useful if we want to invert the value of the LED in our `ledRegister`,
    like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 异或在我们想要反转 `ledRegister` 中 LED 的值时非常有用，像这样：
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Inverting an LED makes it blink slowly.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 LED 会让它慢慢闪烁。
- en: Shifting
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移位
- en: 'The *left shift* operator (`<<`) shifts the contents of a variable to the left
    by a given number of bits, filling in zeros for the missing bits. For example,
    consider the following operation:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*左移*操作符（`<<`）将变量的内容向左移动指定的位数，缺失的位填充为零。例如，考虑以下操作：'
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This causes the computer to move the bits two places to the left so that the
    following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致计算机将位向左移动两个位置，结果如下：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'becomes this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 变为如下：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The *right shift* operator (`>>`) is a little more tricky. For unsigned numbers,
    it works just like the left shift, except it shifts the bits in the rightward
    direction. Again, the computer fills in zeros for the missing bits. Thus, `uint8_t
    result = 0xA5 >> 2;` would be computed so that the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*右移*操作符（`>>`）稍微复杂一些。对于无符号数，它的工作方式与左移相似，只不过它将位向右移动。再次强调，计算机会为缺失的位填充零。因此，`uint8_t
    result = 0xA5 >> 2;` 将被计算为如下：'
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'becomes this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 变为如下：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'But when the number is signed, the computer uses the sign bit to supply the
    missing bits. For example, consider the following operation:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当数字是有符号的时，计算机会使用符号位来补充缺失的位。例如，考虑以下操作：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This would be computed such that the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被计算为如下：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'becomes this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 变为如下：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because it’s a signed number shifting right, the missing bits on the right side
    are filled in with copies of the sign bit, so the result is 0xE9, which is –23.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个有符号数字向右移位，右侧缺失的位会用符号位的副本来填充，因此结果是 0xE9，即 -23。
- en: Defining the Meaning of Bits
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义位的含义
- en: Hardware people love defining things in terms of bits. That’s because when the
    signals come out of the chip, they leave from single pins on the hardware that
    have names like GPIO A-3 (which means GPIO register A, bit 3). As the signal on
    a single pin is either *high* (1) or *low* (0), you can represent it with a single
    bit.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件人员喜欢用位来定义事物。这是因为当信号从芯片输出时，它们通过硬件上的单个引脚离开，这些引脚有像 GPIO A-3 这样的名称（表示 GPIO 寄存器
    A，位 3）。由于单个引脚上的信号要么是*高*（1），要么是*低*（0），因此可以用一个单独的位来表示它。
- en: But by the time the programmer sees the signal, it has been bundled with a bunch
    of others into an 8-bit, 16-bit, or 32-bit register. Therefore, we need a way
    of easily translating hardware speak (like “bit 3”) into software speak (such
    as “0x04”). The shift operators, properly used, can be a big help with this translation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但当程序员看到信号时，它已经与其他信号一起被打包成一个 8 位、16 位或 32 位寄存器。因此，我们需要一种方法来轻松地将硬件语言（例如“位 3”）转换成软件语言（如“0x04”）。适当使用移位操作符可以在这方面提供很大的帮助。
- en: 'For example, let’s say we have a light board whose hardware specification is
    the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个硬件规格如下的灯光板：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'MF (bit 7) Master fail: Lights when any other failure light gets lit.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MF（位 7）主故障：当任何其他故障灯亮起时，主故障灯也会亮起。
- en: 'DF (bit 6) Data fail: Incoming data is inconsistent or corrupt.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DF（位 6）数据故障：传入数据不一致或损坏。
- en: 'OL (bit 5) Oil low: The oil level in the accumulator is low.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OL（位 5）油位低：蓄能器中的油位过低。
- en: 'OP (bit 4) Oil pressure: The accumulator oil pressure is low.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OP（位 4）油压：蓄能器油压过低。
- en: 'PW (bit 3) Power failure: The main power supply has failed.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PW（位 3）电源故障：主电源已故障。
- en: 'PF (bit 2) Position fault: The position frame has hit a limit switch and is
    not where it is supposed to be.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PF（位 2）位置故障：位置框架已触及限位开关，当前位置不正确。
- en: 'AP (bit 1) Air pressure: The air compressor has failed.'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AP（位 1）气压：空气压缩机故障。
- en: 'CF (bit 0) Clean filter: The filter to the air compressor needs cleaning.'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CF（位 0）清洁过滤器：空气压缩机的过滤器需要清洁。
- en: 'Each of these bits is connected to a light. The light circuit is wired to the
    GPIO pins of our controller. For example, if we set bit 0 of the GPIO device,
    the “Clean Filter” light will come on:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Even so, it’s still not easy to remember which number goes with which bit.
    Bit 0 is the first value, bit 1 is the second value, and so on. Quick: Which bit
    is represented by the 6th value? There is a nice way of making this easier. Bit
    0 holds value 1, which is equivalent to the expression `(1 << 0)`. Bit 1 is value
    2, which is `(1 << 2)`, and bit 3 is `(1 << 3)`, and so on. From this, it’s easy
    to see that bit 5 is `(1 << 5)`. Using this system, we can define constants to
    represent each bit:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s once again turn on the `CLEAN_FILTER` LED and leave all the others alone,
    this time using our new constant to reference the relevant bit:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice here that we also used the `|=` shorthand operator introduced earlier
    in this chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Values of Two Bits at Once
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s say we want to set the values of both `POWER_FAILURE` and `MASTER_FAIL`.
    We can accomplish that with the following statement:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Since `MASTER_FAIL` has a value of 1 in bit 7, and any nonzero value results
    in a value of 1, the `MASTER_FAIL` bit will be set in the panel.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Turning Off a Bit
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the following pattern to turn off a bit:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To understand how this operation works, let’s go through it in detail using
    the following statement:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s start with the result of `(MASTER_FAIL | POWER_FAIL)`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now we apply the invert or NOT (`~`) operator:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we take a look at the existing value of `ledRegister`. For this example,
    it has `MASTER_FAIL` and `CLEAN_FILTER` set.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we “AND” the results together:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Checking the Values of Bits
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following program shows a typical use of *bit-banging*, the art of turning
    on and off individual bits. It also contains logic to check the values of the
    different bits:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s start by looking at the `printLED` function, which contains a bunch of
    lines that test each individual bit and print a message if it is set. (You’ll
    learn about the `if` statements used to do this in Chapter 5.) To understand the
    logic of the test, take a look at the following statement:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The message will print if the expression on the first line is not equal to
    0\. Because the expression uses the AND operator, each bit in `ledRegister` must
    match the corresponding bit in `MASTER_FAIL` for that bit to have a value of 1\.
    If at least one set of bits both have a value of 1, the `printf` is executed.
    In other words, behind the scenes, the operation looks something like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The entire function will perform a similar test and print every bit that’s set
    in the register. This function is used here because we don’t have a hardware light
    panel and we want to see what’s happening.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the program, we play with the bits. For example, we simulate a power
    failure by turning on the `POWER_FAILURE` and _`MASTER_FAIL` bits. Thus, when
    we print the LEDs now, we get the following message:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The rest of the program sets and clears the various bits to produce the following
    messages:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的其余部分设置和清除各种位，以生成以下消息：
- en: '[PRE65]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered what you can do with simple integers. There’s the usual
    add, subtract, multiply, and divide, but you also saw how a computer stores the
    data and, most importantly, what happens when you run into problems like overflow.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了你可以对简单整数执行的操作。包括常见的加、减、乘、除，但你还学到了计算机如何存储数据，以及最重要的，当遇到溢出等问题时会发生什么。
- en: You also learned about bit manipulation, where you treat an integer as a group
    of 8, 16, or 32 bits. This is very important because embedded programmers frequently
    deal with bitmapped registers. For example, the GPIO register we used to turn
    on and off our LED contains bits for 31 other GPIOs. The other 31 pins are entirely
    unrelated to our LED and have other functions (or they would have if we wired
    them to anything).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了位操作，它将整数视为 8 位、16 位或 32 位的组合。这非常重要，因为嵌入式程序员经常处理位映射寄存器。例如，我们用来开关 LED 的 GPIO
    寄存器包含了其他 31 个 GPIO 的位。其他 31 个引脚与我们的 LED 完全无关，并具有其他功能（或者如果我们将它们接线到其他设备，它们将有其他功能）。
- en: In the next chapter, you’ll learn how to make decisions based on those computations.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何根据这些计算做出决策。
- en: Programming Problems
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程问题
- en: The largest `int16_t` value is 32,767\. Write a program to find out what the
    `int16_t` value of 32,767 + 1 is.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int16_t` 的最大值是 32,767。编写程序找出 32,767 + 1 的 `int16_t` 值。'
- en: 'There is a serial I/O register that contains a 2-bit value for the parity,
    as specified here:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个串行 I/O 寄存器，包含一个 2 位的校验值，如下所示：
- en: '[PRE66]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Write an expression to extract the parity-checking number (in the range 0 to
    3) from the register. The parity is stored in bits 2 and 3 as a 2-bit unsigned
    binary number.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写表达式从寄存器中提取校验和数字（范围为 0 到 3）。校验位存储在第 2 位和第 3 位，作为一个 2 位无符号二进制数。
- en: Write code to set the value to 2 (binary 0x10).
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码将值设置为 2（二进制 0x10）。
