- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numbers and Variables
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have written a trivial program or two, it’s time to get the machine
    to do some real work. In this chapter you will learn how to manipulate numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As embedded programmers, we are concerned with exactly what the numbers are
    doing. For example, the number 32 could represent the number of sheep in a barnyard,
    or it could energize GPIO pin #4, which turns on the big red warning light. What’s
    worse, our STM32 groups up to 32 different GPIOs into a single number, so while
    32 might tell the device to “turn on the big red light,” 34 could tell it to “turn
    on the big red light and sound the klaxon.” To control our devices, we need to
    know precisely what these numbers are doing. Thus, we will take a deep dive into
    the numbers as seen by the computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you know what a number is, you will learn how to work with it by using
    variables to store the information in our program. Next, you’ll practice manipulating
    the bits in the hardware’s I/O registers to turn various functions on or off.
    In the process, you’ll see how the program in Chapter 3 worked behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with integers, or whole numbers. These are numbers without a decimal
    point, such as 37, 45, –8, and 256.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-1](#table4-1) lists the operations you can do with numbers in C.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: Number Operators in C'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Add |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtract |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiply |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Divide (truncates to a whole number) |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Modulus (returns the remainder after division) |'
  prefs: []
  type: TYPE_TB
- en: 'The following listing illustrates how these operators work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We demonstrate each operation inside a `printf` statement that prints the result.
    To print the result of a calculation using `printf`, put a `%d` in the string
    where you want a number to appear and then list the calculation as a second argument
    to `printf`. Notice that if you want to print a `%` to represent the modulus operation,
    you need to specify it twice.
  prefs: []
  type: TYPE_NORMAL
- en: To view this program’s output, let’s get it into our IDE. Start System Workbench
    for STM32 and then go through the list of steps in Chapter 2 to create a program.
    (A checklist in the appendix summarizes these steps.) This time, however, instead
    of creating a “Hello World” program, we’ll create an empty native C/C++ project,
    so select **C Managed Build** as the template.
  prefs: []
  type: TYPE_NORMAL
- en: Under Project Type, choose **Executable**▶**Empty Project**. Next, create the
    program file by selecting **File**▶**New**▶**Source File**.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the program text into the editing window and then save the file. Build
    the binary and run it as you did in Chapter 2. The program should display its
    output at the bottom of the Console window (see [Figure 4-1](#figure4-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04001](image_fi/501621c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: The run result'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the program should print the result of each calculation it performs.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables to Hold Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our program performed operations on fixed numbers, but we can also use variables
    to store information that can change. Before any variable can be used, it has
    to be *declared*. The format of a variable declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For example, using `int` as the type would indicate that the variable is an
    integer. To be precise, it is the type of integer that the computer can most easily
    handle. We will get into other types of integers later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable names begin with a letter and must contain only letters, digits, and
    the underscore. The STM32 firmware library uses the camel case variable naming
    style, where words within the name are capitalized, so to be compatible, we use
    camel case throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While names can begin with an underscore, such names are considered reserved
    for system functions and should not be used in ordinary programming. Also, never
    use `l` (lowercase *L*) or `O` (uppercase *O*) as a variable name. In case the
    reasons aren’t obvious, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Technically, you can omit the comment from your variable declaration. However,
    including a comment gives the people who work with the code after you an idea
    of why you declared the variable and what it does. In other words, it helps you
    create a mini-dictionary or glossary.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning Values to Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we’ve declared a variable, we can assign it a value with an assignment
    statement. The general form of an assignment statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the computer to compute the value of the expression and store it
    in the variable. Variables can then be used anyplace we put an integer, such as
    a `printf` statement. The following program demonstrates variable declaration,
    assignment, and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**var.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This program creates two variables, `aNumber` and `otherNumber`, and then assigns
    them each a value and prints the sum. Enter this program into System Workbench
    for STM32 now.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you declare a variable in your program, you tell the C compiler to allocate
    memory space for an integer (`int`). But before you specify a value for it, this
    variable is considered *uninitialized*; it may contain any random garbage value
    left over from the last time the memory was used.
  prefs: []
  type: TYPE_NORMAL
- en: To see this at work in the program we just wrote, open the debugger and take
    a look at the Variables panel as you step through the program. Before you assign
    them values, our two variables, `aNumber` and `otherNumber`, have values of zero.
    But uninitialized variables could have any value; the fact that they’re zero here
    is pure luck.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can initialize a variable at declaration time by adding an assignment to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good idea in most cases, as it makes sure our program is working
    with an expected value. Let’s rewrite our program to add these initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once we’ve made that change, we can delete the lines that initialize the variables
    later in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Integer Sizes and Representations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C has integer types other than `int` that it uses to represent numbers of different
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: As computers evolved, people discovered that the most efficient way to organize
    memory is in 8-bit groups called *bytes*. The computer lets you combine multiple
    bytes into 2-byte, 4-byte, and 8-byte values, and the `int` type tells C to define
    an integer using the most efficient number of bytes for the computer you are using.
    This may be a 16-bit (2-byte) integer or a 32-bit (4-byte) integer, depending
    on the system. The compiler for our chip, the ARM Cortex-M0 CPU, uses a 32-bit
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: To make programs even more efficient, C lets you select the type of integer
    you want. For example, you may wish to store numbers in the range of 0 to 100\.
    You don’t need a full-size integer for that, so you can use a `short int`, which
    is like an integer but takes up less space. (Technically, the C standard only
    states that a `short int` is no larger than a regular `int`, but in most implementations
    it is smaller.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following declares a `short int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A longer-than-normal integer can be declared with the modifier `long`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When computers gained the ability to efficiently process even longer numbers,
    people needed an integer type that could contain even more bits than a `long`
    does. The result was the (somewhat silly) `long long` integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The C standard does not define the size of each type of integer. They could
    all be the same size, and you’d still have a standard compiler. However, it does
    guarantee the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `sizeof` operator returns the number of bytes it takes to store a variable
    or type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how much space each type of integer takes for the compiler on our
    system using a short program to print the sizes of the various flavors of integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Earlier, we used `%d` to print a number. In this program, we use `%ld`, because
    `sizeof` returns a `long int` and `%ld` is used to print `long int` numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program produces the following output on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see that the size of a `long int` is the same as a `long long
    int`. However, that is true only for this compiler on this system (GNU GCC on
    an x86_64 processor). Different compilers might implement things differently.
  prefs: []
  type: TYPE_NORMAL
- en: Number Representations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we have five cows. In English, we could represent that number as
    “five,” “5,” or “V.” Likewise, in C, you can use four number representations:
    decimal, binary, octal, and hexadecimal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'People typically use decimal (base 10), but computers store numbers in binary
    (base 2) because it’s cheap and easy to make binary circuits. For example, we
    might write the following assignment statement using decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This same statement could be written in binary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The prefix 0b indicates a binary number follows. (We could use 0B too, but it’s
    harder to read.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, we could use octal (base 8):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use hexadecimal (base 16):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Binary numbers take up a lot of room to write, so to make things more compact,
    we often use hexadecimal notation in programming to represent exact binary values.
    Each single hex digit translates into four binary bits, as shown in [Table 4-2](#table4-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-2: Converting Between Binary and Hex'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binary** | **Hex** | **Binary** | **Hex** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 | 0 | 1000 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 0001 | 1 | 1001 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 0010 | 2 | 1010 | A |'
  prefs: []
  type: TYPE_TB
- en: '| 0011 | 3 | 1011 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 0100 | 4 | 1100 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 0101 | 5 | 1101 | D |'
  prefs: []
  type: TYPE_TB
- en: '| 0110 | 6 | 1110 | E |'
  prefs: []
  type: TYPE_TB
- en: '| 0111 | 7 | 1111 | F |'
  prefs: []
  type: TYPE_TB
- en: As you can see, 1111 1100b is the equivalent of the hex value 0xFC. Similarly,
    0xA5 is 1010 0101b. Using this table, you can quickly and easily translate between
    binary and hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: While the computer stores a number as a set of bits, the meaning of those bits
    is entirely up to us. For example, the bit pattern 0000 0101 could mean 5 if we
    interpret it as a binary number. But 0000 0101 could also mean 10,005\. How did
    I get that number? I made it up. In this case, I arbitrarily picked a strange
    value. Other arbitrary meanings could include “May,” the letter “E,” and “LED0+LED2.”
  prefs: []
  type: TYPE_NORMAL
- en: One less common but still useful bit pattern mapping is shown in [Table 4-3](#table4-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-3: A Bit Pattern to Number Mapping'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit pattern** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 000 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 011 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 010 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 7 |'
  prefs: []
  type: TYPE_TB
- en: At first glance, it looks random. But if you look closely, you’ll see that only
    one bit changes between each number. This makes it ideal for use in encoders (see
    [Figure 4-2](#figure4-2)). It is, in fact, a standard bit pattern encoding called
    *Gray code*.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04002](image_fi/501621c04/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: A Gray code encoder'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that C has no idea how to interpret a bit pattern until you tell it
    how.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The big problem with the integer types is that nothing in the standard tells
    you how big they are, just their relative sizes. If you want to write to a 32-bit
    device, you have to guess which type of `int` will be the size you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Guessing and programming do not mix well together, so people devised systems
    using a technique called *conditional compilation* (see Chapter 12) and other
    tricks to define new types that hold a precise number of bits: `int8_t`, `int16_t`,
    `int32_t`, and `int64_t`. The name of the type specifies the size of the integer.
    For example, the type `int32_t` has 32 bits in it no matter what size the `int`
    is. Like most good ideas, these new types became widely used—so widely used that
    the C standards committee decided to add them to the language with the `stdint`
    library. They are not part of the built-in C types, so you have to include them
    by using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 4-1](#listing4-1) shows our new integer types in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Integer demonstration'
  prefs: []
  type: TYPE_NORMAL
- en: In this program, we use the formatting character `%x` to print the numbers in
    hexadecimal. Specifically, the `%x` format character prints an `int` in hexadecimal,
    but we can also use it for `int8_t`, `int16_t`, and `int32_t` because of some
    behind-the-scenes stuff called *argument promotion*.
  prefs: []
  type: TYPE_NORMAL
- en: C is a somewhat lazy language. Because it’s hard to pass a 16-bit integer to
    `printf` when your processor has 32-bit registers, C takes the `int16_t` and converts,
    or *promotes*, it to an `int32_t` for this one operation, which lets us get away
    with using `%x` for an `int16_t`. Similarly, we can use `%x` for an `int8_t` because
    it will get promoted to an `int32_t` as well. (Strictly speaking, the C standard
    states that promotion *may* occur. It does not require it. This code works on
    our x86_64 machine with this compiler, but it is not portable to other systems.)
  prefs: []
  type: TYPE_NORMAL
- en: Now we come to `int64_t`. If C were to change this into an `int` (`int32_t`),
    we’d lose half our number. C can’t do anything to it, so it passes an `int64_t`
    argument as an `int64_t` argument. The format had to change from `%x` (`int`)
    to `%lx` (`int64_t`) to print the longer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Investigation for the reader: try changing `%lx` to `%x` in the example and
    see what you get.'
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned Integer Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last section, we used signed integer types, which can be either positive
    or negative. Unsigned integer types hold only positive values and are simpler
    than their signed counterparts. The standard unsigned types are `uint8_t`, `uint16_t`,
    `uint32_t`, and `uint64_t`. The type `uint8_t` is an unsigned 8-bit integer that
    can hold numbers from 0 (0000 0000b) to 255 (1111 1111b). The ranges of the unsigned
    integer types are shown in [Table 4-4](#table4-4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-4: Unsigned Integer Type Ranges'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Low** | **High** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `uint8_t` | 0000 0000 (0) | 1111 1111 (255) |'
  prefs: []
  type: TYPE_TB
- en: '| `uint16_t` | 0000 0000 0000 0000 (0) | 1111 1111 1111 1111 (65,535) |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32_t` | 0000 0000 0000 0000 0000 0000 0000 0000 (0) | 1111 1111 1111
    1111 1111 1111 1111 1111 (4,294,967,295) |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64_t` | 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
    0000 0000 0000 0000 (0) | 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111
    1111 1111 1111 1111 1111 (18,446,744,073,709,551,615) |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s a simple example of using a `uint8_t` variable. This program prints
    three different representations for `smallNumber` without changing its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `%u printf` specification tells C we want to print an unsigned `int` (the
    default unsigned integer type). We use the format specification `%o` to print
    in octal and `%x` to print in hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we will explore the limits of our machine. Actually, we will exceed them.
    The biggest `uint8_t` number is 255 (0b1111 1111). What happens when we go beyond
    that and try to print 255 + 1? Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: According to this program, the result of adding 1 to the 8-bit unsigned integer
    255 is 256, but the number 256 in binary is 0b1 0000 0000, or 0x100, which can’t
    fit in 8 bits. Either we’ve warped the laws of the universe or something went
    wrong with our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand what’s going on, let’s take a look at the print statement 1.
    The type of `smallNumber` is `uint8_t`; however, on most 32-bit computers, it’s
    hard, if not impossible, to add two 8-bit integers. Because of the way the computer
    is constructed, you have to add two 32-bit numbers. So, to compute an expression,
    the C compiler does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Converts `shortNumber` to a `unit32_t` value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adds 1 to the result (of type `uint32_t`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prints the result (256) as a `uint32_t`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The result is a `uint32_t` that can hold the value 256, and that’s what’s printed.
    So, we did not cause an 8-bit overflow (which we wanted to demonstrate). Instead,
    we demonstrated automatic promotion, which we discussed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the result we want, we need to make a slight adjustment to the program
    to store the result in a `uint8_t` value (I’ve highlighted the changes to our
    program in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now the result is 0\. Why? Because our calculation returned 0b1111 1111 + 0b000
    0001 = 0b1 **0000 0000**. Only the bold portion was stored due to the limited
    space in which to store the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Overflow* occurs when the result is too big for the machine to handle. In
    this case, the 9-bit result won’t fit in an 8-bit value. Think of a car’s odometer.
    It can display mileage to 999,999\. What happens if someone drives a million miles?'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how the compiler is manipulating the numbers is key to making
    good embedded programs. For example, I once had a GPS that kept altitude as an
    unsigned number. (It was not designed to work on submarines.) I took it on a trip
    to Death Valley, and it died. That’s because when I reached Badwater Basin, elevation
    –282 feet, it couldn’t handle the negative altitude. The GPS’s designers had assumed
    that all altitudes would be greater than zero. After all, the GPS was not designed
    to work underwater. Therefore, using an unsigned integer for altitude was not
    an unreasonable decision—except for users in locations like Badwater Basin, where
    the altitude is negative, causing the GPS to die. This mistake shows why it’s
    important to know the limitations of your numbering system.
  prefs: []
  type: TYPE_NORMAL
- en: Two’s Complement Representation in Signed Integer Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Signed numbers are represented by using one bit (the leftmost) as a sign bit:
    if the bit is 1, the number is negative. Thus, 8-bit signed integers (`int8_t`)
    can represent numbers from 127 to –128.'
  prefs: []
  type: TYPE_NORMAL
- en: Almost all computers today use two’s complement numbers to represent negative
    values. *Two’s complement representation* stores a number as that number pre-subtracted
    from 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, –1 can be determined by the following calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because the computer adds a magic “borrow” bit to the left of the
    number, making the arithmetic look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Two’s complement is similar to a mechanical car odometer. Let’s say you buy
    a brand-new car and its odometer reads 000,000\. If you drove backward, your odometer
    would read 999,999, which is the ten’s complement of –1.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the biggest number a `uint8_t` can hold is 255, whereas
    an `int8_t` can store only values up to 127 (half that). That’s because one bit
    is used as the sign bit, leaving only seven bits to store the number part.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we exceed the boundaries with 8-bit signed numbers? I’m going
    to let you investigate that yourself. See what happens with the operations 127
    + 1 and –128 – 1\. Also see what happens with –(–128), the negation of –128.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve learned about integers and the simple operations that can be done on
    them, but to let you do arithmetic faster, C provides a number of shorthand operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider adding a value to a number, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can shorten this operation to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can perform similar shortcuts for all the other arithmetic operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can condense the operation of adding 1 to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be shortened to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To decrement numbers by 1, use the `--` (minus minus) operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a caveat. C lets you combine the increment (`++`) and decrement (`--`)
    operations with other statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Please don’t do this, as it can cause the program to have undefined behavior.
    For example, consider the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The second statement tells C to increment `aNumber`, then increment `aNumber`
    again. It then multiplies `aNumber` with itself and increments `aNumber` a third
    time. Finally, it adds this to the result.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, nothing tells C that these operations have to occur in the order
    I’ve listed here. For example, all the increments could come at the beginning,
    making the result (5 × 5 + 5) = 30\. Or they could come one at a time, and we
    would have (3 × 4 + 5) = 17\. For those reasons, be sure to put `++` and `--`
    on lines by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing: there are two forms of increment and decrement operations.
    You can place the operator either before or after the variable you would like
    to increment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These do slightly different things. I leave it to the reader to write a small
    program to print the results of the preceding code and figure out what they do—and
    then please never again use `++` combined with another statement.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Memory-Mapped I/O Registers Using Bit Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can organize eight bits into a single number, but these bits can also represent
    eight different things. For example, they can be wired to eight different LED
    lights. In fact, when you place values in special memory locations called *memory-mapped
    I/O registers*, these values turn on or off I/O pins. Since there are eight bits
    to the register’s byte, a single register can control eight LEDs. (Or, in our
    case, one LED and seven pins on which we can add more LEDs.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Bits are normally numbered from 7 to 0, with 7 being the leftmost, or most
    significant, bit. Let’s say our LED register is set up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bit 7 | Bit 6 | Bit 5 | Bit 4 | Bit 3 | Bit 2 | Bit 1 | Bit 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Out 7 | Out 6 | Out 5 | Out 4 | Out 3 | Out 2 | Out 1 | LED 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Say we want to turn on LED #0\. As each LED is off, our register has the value
    0000 0000 in it. To turn on LED #0, we need to flip the final bit to a value of
    1\. To do that, we just add 1 to the register to get 0000 0001\. LED #0 turns
    on and all the others stay off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if the LED was already on? Then our register would contain 0000 0001,
    and when we add 1, we’ll get 2, which in binary is 0000 0010\. Thus, LED #0 turns
    off and OUT #1 turns on. Not what we wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the arithmetic operators we’ve been using treat our
    8-bit integer as a single integer. The *bitwise operators* treat the number as
    a set of individual bits, each of which can be turned on, turned off, and tested
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: OR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first bitwise operator is *OR* (`|`). The single-bit version of OR gives
    a true (or 1) result if either of its two operands is set to 1\. I’m going to
    show how it operates using a *truth table*. It’s like the addition and multiplication
    tables you used in first grade, only it shows the operation of Boolean operators
    such as OR.
  prefs: []
  type: TYPE_NORMAL
- en: 'The truth table for OR looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| OR (`&#124;`) | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'OR is a bitwise operator, which means that to “OR” two 8-bit values together,
    you perform the operation for each pair of bits in the two values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To set bit 0 (that is, to turn on LED #0), we use the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the following shorthand operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: AND
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *AND* (`&`) operator returns a true (1) only if both of its operands are
    true. The following is the AND truth table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| AND (`&`) | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Like OR, the AND operator works on each pair of bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn off LED #0, we can set bit 0 to a value of 0 with the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This command “ANDs” our register with a bit pattern that has every bit set *except*
    bit 0, so bit 0 will be cleared and all the other bits will be unchanged. (ANDing
    a bit with 1 keeps its value.)
  prefs: []
  type: TYPE_NORMAL
- en: NOT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *invert*, or *NOT*, operator (`~`) takes one operand and inverts it. Thus,
    if the bit is 0, it becomes 1, and if it’s 1, it becomes 0\. The truth table for
    the NOT operator is rather simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'The following example demonstrates how this operator works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the bitwise operators we’ve covered so far, we can already write some
    code to turn off all registers and then turn on and off the LED:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what the blink program from Chapter 3 was doing, except that
    the STM library hid these details from us.
  prefs: []
  type: TYPE_NORMAL
- en: Exclusive OR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The result of the bitwise operator *exclusive OR* (`^`) is true if one or the
    other bit is set, but not both. Here is its truth table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Exclusive OR (`^`) | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'To see how it works, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Exclusive OR is useful if we want to invert the value of the LED in our `ledRegister`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Inverting an LED makes it blink slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *left shift* operator (`<<`) shifts the contents of a variable to the left
    by a given number of bits, filling in zeros for the missing bits. For example,
    consider the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This causes the computer to move the bits two places to the left so that the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The *right shift* operator (`>>`) is a little more tricky. For unsigned numbers,
    it works just like the left shift, except it shifts the bits in the rightward
    direction. Again, the computer fills in zeros for the missing bits. Thus, `uint8_t
    result = 0xA5 >> 2;` would be computed so that the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'But when the number is signed, the computer uses the sign bit to supply the
    missing bits. For example, consider the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be computed such that the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Because it’s a signed number shifting right, the missing bits on the right side
    are filled in with copies of the sign bit, so the result is 0xE9, which is –23.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Meaning of Bits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hardware people love defining things in terms of bits. That’s because when the
    signals come out of the chip, they leave from single pins on the hardware that
    have names like GPIO A-3 (which means GPIO register A, bit 3). As the signal on
    a single pin is either *high* (1) or *low* (0), you can represent it with a single
    bit.
  prefs: []
  type: TYPE_NORMAL
- en: But by the time the programmer sees the signal, it has been bundled with a bunch
    of others into an 8-bit, 16-bit, or 32-bit register. Therefore, we need a way
    of easily translating hardware speak (like “bit 3”) into software speak (such
    as “0x04”). The shift operators, properly used, can be a big help with this translation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say we have a light board whose hardware specification is
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'MF (bit 7) Master fail: Lights when any other failure light gets lit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DF (bit 6) Data fail: Incoming data is inconsistent or corrupt.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OL (bit 5) Oil low: The oil level in the accumulator is low.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OP (bit 4) Oil pressure: The accumulator oil pressure is low.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PW (bit 3) Power failure: The main power supply has failed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PF (bit 2) Position fault: The position frame has hit a limit switch and is
    not where it is supposed to be.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AP (bit 1) Air pressure: The air compressor has failed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'CF (bit 0) Clean filter: The filter to the air compressor needs cleaning.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each of these bits is connected to a light. The light circuit is wired to the
    GPIO pins of our controller. For example, if we set bit 0 of the GPIO device,
    the “Clean Filter” light will come on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Even so, it’s still not easy to remember which number goes with which bit.
    Bit 0 is the first value, bit 1 is the second value, and so on. Quick: Which bit
    is represented by the 6th value? There is a nice way of making this easier. Bit
    0 holds value 1, which is equivalent to the expression `(1 << 0)`. Bit 1 is value
    2, which is `(1 << 2)`, and bit 3 is `(1 << 3)`, and so on. From this, it’s easy
    to see that bit 5 is `(1 << 5)`. Using this system, we can define constants to
    represent each bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s once again turn on the `CLEAN_FILTER` LED and leave all the others alone,
    this time using our new constant to reference the relevant bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice here that we also used the `|=` shorthand operator introduced earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Values of Two Bits at Once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s say we want to set the values of both `POWER_FAILURE` and `MASTER_FAIL`.
    We can accomplish that with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Since `MASTER_FAIL` has a value of 1 in bit 7, and any nonzero value results
    in a value of 1, the `MASTER_FAIL` bit will be set in the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Turning Off a Bit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the following pattern to turn off a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how this operation works, let’s go through it in detail using
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start with the result of `(MASTER_FAIL | POWER_FAIL)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we apply the invert or NOT (`~`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Next, we take a look at the existing value of `ledRegister`. For this example,
    it has `MASTER_FAIL` and `CLEAN_FILTER` set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we “AND” the results together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Checking the Values of Bits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following program shows a typical use of *bit-banging*, the art of turning
    on and off individual bits. It also contains logic to check the values of the
    different bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s start by looking at the `printLED` function, which contains a bunch of
    lines that test each individual bit and print a message if it is set. (You’ll
    learn about the `if` statements used to do this in Chapter 5.) To understand the
    logic of the test, take a look at the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The message will print if the expression on the first line is not equal to
    0\. Because the expression uses the AND operator, each bit in `ledRegister` must
    match the corresponding bit in `MASTER_FAIL` for that bit to have a value of 1\.
    If at least one set of bits both have a value of 1, the `printf` is executed.
    In other words, behind the scenes, the operation looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The entire function will perform a similar test and print every bit that’s set
    in the register. This function is used here because we don’t have a hardware light
    panel and we want to see what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the program, we play with the bits. For example, we simulate a power
    failure by turning on the `POWER_FAILURE` and _`MASTER_FAIL` bits. Thus, when
    we print the LEDs now, we get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the program sets and clears the various bits to produce the following
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter covered what you can do with simple integers. There’s the usual
    add, subtract, multiply, and divide, but you also saw how a computer stores the
    data and, most importantly, what happens when you run into problems like overflow.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about bit manipulation, where you treat an integer as a group
    of 8, 16, or 32 bits. This is very important because embedded programmers frequently
    deal with bitmapped registers. For example, the GPIO register we used to turn
    on and off our LED contains bits for 31 other GPIOs. The other 31 pins are entirely
    unrelated to our LED and have other functions (or they would have if we wired
    them to anything).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to make decisions based on those computations.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The largest `int16_t` value is 32,767\. Write a program to find out what the
    `int16_t` value of 32,767 + 1 is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is a serial I/O register that contains a 2-bit value for the parity,
    as specified here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write an expression to extract the parity-checking number (in the range 0 to
    3) from the register. The parity is stored in bits 2 and 3 as a 2-bit unsigned
    binary number.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Write code to set the value to 2 (binary 0x10).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
