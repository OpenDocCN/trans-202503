- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARITHMETIC
    TYPES</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll learn about the two kinds of *arithmetic types*: integers
    and floating types. Most operators in C operate on arithmetic types. Because C
    is a system-level language, performing arithmetic operations correctly can be
    difficult, resulting in frequent defects. This is partially because arithmetic
    operations in digital systems with limited range and precision do not always produce
    the same result as they would in ordinary mathematics. Performing basic arithmetic
    correctly is an essential foundation to becoming a professional C programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll dive deep into how arithmetic works in the C language so that you have
    a firm grasp of these fundamental concepts. We’ll also look at how to convert
    one arithmetic type to another, which is necessary for performing operations on
    mixed types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Integers</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 2](chapter2.xhtml), each integer type represents a
    finite range of integers. Signed integer types represent values that can be negative,
    zero, or positive; unsigned integers represent values that can be only zero or
    positive. The range of values that each integer type can represent depends on
    your implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The *value* of an integer object is the ordinary mathematical value stored in
    the object. The *representation* of a value for an integer object is the particular
    encoding of the value in the bits of the object’s allocated storage. We’ll look
    at the representation in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Padding, Width, and
    Precision</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All integer types except <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> may contain unused bits, called *padding*, that allow implementations
    to accommodate hardware quirks (such as skipping over a sign bit in the middle
    of a multiple- word representation) or to optimally align with a target architecture.
    The number of bits used to represent a value of a given type, excluding padding
    but including the sign, is called the *width* and is often denoted by *N*. The
    *precision* is the number of bits used to represent values, excluding sign and
    padding bits.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Ranges</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *representable value* is a value that can be represented in the number of
    bits available to an object of a particular type. Values that cannot be represented
    will be diagnosed by the compiler or converted to a representable but different
    (incorrect) value. The <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    header file defines object-like macros that expand to various limits and parameters
    of the standard integer types. To write portable code, you should use these macros
    rather than integer literals such as +2147483647 (the maximum value representable
    as a 32-bit integer) that represent a specific limit and may change when porting
    to a different implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The C standard imposes only three constraints on integer sizes. First, storage
    for *every* data type occupies an integral number of adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> objects (which may include padding). Second, each integer type must
    support a minimum range of values, allowing you to depend on a portable range
    of values across any implementation. Third, smaller types cannot be wider than
    larger types. So, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>
    cannot be wider than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    but both types may have the same width.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Declarations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>,
    integer types are assumed to be signed (except for <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    which the implementation can define as either a signed or unsigned integer type).
    The following are valid declarations of unsigned integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When declaring signed integer types, you can omit the signed keyword— except
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, which requires
    the keyword to distinguish <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> from plain <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also omit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    when declaring variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long</samp>. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These are all valid signed integer declarations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Integers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Unsigned integers* have ranges that start at 0, and their upper bound is greater
    than that of the corresponding signed integer type. Unsigned integers are frequently
    used for counting items that may have large, nonnegative quantities.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Representation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unsigned integer types are easier to understand and to use than signed integer
    types. They represent values using a pure binary system with no offset: the least
    significant bit has the weight 2⁰, the next least significant has the weight 2¹,
    and so forth. The value of the binary number is the sum of all the weights of
    the set bits. [Table 3-1](chapter3.xhtml#tab3-1) shows some examples of unsigned
    values using an unpadded 8-bit representation.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">8-Bit
    Unsigned Values</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Decimal</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Hexadecimal</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00000000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00000001</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x01</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00101010</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2A</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">255</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b11111111</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> |'
  prefs: []
  type: TYPE_TB
- en: Unsigned integer types do not have a sign bit, allowing for 1-bit greater precision
    than the corresponding signed integer types. Unsigned integer values range from
    0 to a maximum value that depends on the width of the type. This maximum value
    is 2*^N* – 1, where *N* is the width. For example, most x86 architectures use
    32-bit integers with no padding bits, so an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> has a range of 0 to 2^(32) – 1 (4,294,967,295). The constant expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    specifies the implementation-defined upper range for this type. [Table 3-2](chapter3.xhtml#tab3-2)
    shows the constant expressions from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    for each unsigned type and the minimum magnitude required by the standard.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Unsigned
    Integer Minimum Magnitudes</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant expression</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Minimum magnitude</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Maximum
    value for an object of type</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UCHAR_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">255
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">USHRT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">65,535
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">16</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">65,535
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">16</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">4,294,967,295
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">32</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long int</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULLONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">18,446,744,073,709,551,615
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">64</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long int</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Your compiler will replace these values with implementation-defined magnitudes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wraparound</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C23 defines *wraparound* as “the process by which a value is reduced modulo
    2*^N*, where *N* is the width of the resulting type.” Wraparound occurs when you
    perform arithmetic operations that result in values too small (less than 0) or
    too large (greater than 2*^N* – 1) to be represented as a particular unsigned
    integer type. In this case, the value is reduced modulo the number that is one
    greater than the largest value that can be represented in the resulting type.
    Wraparound is well-defined behavior in the C language. Whether it is a defect
    in your code depends on the context. If you are counting something and the value
    wraps, it is likely to be an error. However, the use of wraparound in certain
    algorithms is intentional.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Listing 3-1](chapter3.xhtml#Lis3-1) illustrates wraparound by initializing
    an unsigned integer value <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>
    to its maximum value and incrementing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: Unsigned integer
    wraparound</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting value cannot be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>, so it wraps around to 0\. If the resulting value is decremented, it
    falls outside the range again and will wrap around back to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of wraparound, an unsigned integer expression can never evaluate to
    less than 0\. It’s easy to lose track of this and implement comparisons that are
    always true or always false. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    in the following <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    can never take on a negative value, so this loop will never terminate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This behavior has caused some notable real-world bugs. For example, all six
    power-generating systems on a Boeing 787 are managed by a corresponding generator
    control unit. Boeing’s laboratory testing discovered that an internal software
    counter in the generator control unit wraps around after running continuously
    for 248 days (see the Federal Aviation Administration Rule at *[https://<wbr>www<wbr>.federalregister<wbr>.gov<wbr>/documents<wbr>/2015<wbr>/05<wbr>/01<wbr>/2015<wbr>-10066<wbr>/airworthiness<wbr>-directives<wbr>-the<wbr>-boeing<wbr>-company<wbr>-airplanes](https://www.federalregister.gov/documents/2015/05/01/2015-10066/airworthiness-directives-the-boeing-company-airplanes)*).
    This defect causes all six generator control units on the engine-mounted generators
    to enter fail-safe mode at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid unplanned behavior (such as having your airplane fall from the sky),
    it’s important to check for wraparound by using the limits from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>.
    Be careful when implementing these checks because it’s easy to make mistakes.
    For example, the following code contains a defect, as <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>
    can never be larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the result of adding <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp> is larger than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>, it is reduced modulo
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Therefore, the test is
    useless, and the generated code will unconditionally perform the summation. Quality
    compilers might issue a warning pointing this out, but not all do so. To remedy
    this, you can subtract <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    from both sides of the inequality to form the following effective test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> macro is the
    largest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> is a value
    between 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>. If
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>,
    the result of the subtraction is 0, and if <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    is equal to 0, the result of the subtraction is <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>.
    Because the result of this operation will always fall in the allowable range of
    0 to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>, it can never
    wrap around.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same problem occurs when checking the result of an arithmetic operation
    against 0, the minimum unsigned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Because unsigned integer values can never be negative, the subtraction will
    be performed unconditionally. Quality compilers may warn about this mistake as
    well. Instead of this useless test, you can check for wraparound by testing whether
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">j > i</samp>, the difference
    would wrap around, so the possibility of wraparound is prevented. By eliminating
    the subtraction from the test, the possibility of wraparound is also eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Keep in mind that the width used during wraparound depends on the implementation,
    which means you can obtain different results on different platforms. Your code
    won’t be portable if you fail to account for this.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signed Integers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each unsigned integer type (excluding <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>)
    has a corresponding signed integer type that occupies the same amount of storage.
    Use signed integers to represent negative, zero, and positive values, the range
    of which depends on the number of bits allocated to the type and the representation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Representation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Representing signed integer types is more complicated than representing unsigned
    integer types. Historically, the C language has supported three different schemes
    for representing negative numbers: sign and magnitude, one’s complement, and two’s
    complement.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with C23, only two’s-complement representation is supported. In two’s
    complement representation, the sign bit is given the weight −(2*^N* ^(− 1)), and
    the other value bits have the same weights as for unsigned. The remainder of this
    book assumes the two’s complement representation.
  prefs: []
  type: TYPE_NORMAL
- en: Signed two’s-complement integer types with a width of *N* can represent any
    integer value in the range of –2*^N* ^(– 1) to 2*^N* ^(– 1) – 1\. This means,
    for example, that an 8-bit value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> has a range of –128 to 127\. Compared to other signed integer representations,
    two’s complement can represent an additional *most negative* value. The most negative
    value for an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    is –128, and its absolute value |–128| cannot be represented as this type. This
    leads to some interesting edge cases, which we’ll soon examine in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-3](chapter3.xhtml#tab3-3) shows the constant expressions from <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp> for each signed type
    and the minimum magnitudes required by the standard. Your compiler will replace
    these values with implementation-defined magnitudes.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Signed
    Integer Minimum Magnitudes</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant expression</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Minimum magnitude</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–128
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+127
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">7</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SHRT_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–32,768
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">short
    int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SHRT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+32,767
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–32,768
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+32,767
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–2,147,483,648
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+2,147,483,647
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">31</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LLONG_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–9,223,372,036,854,775,808
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LLONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+9,223,372,036,854,775,807
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">63</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: To negate a value in two’s-complement representation, simply toggle each nonpadding
    bit and then add 1 (with carries as necessary), as shown in [Figure 3-1](chapter3.xhtml#fig3-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f03001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Negating an 8-bit
    value in two’s-complement representation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-4](chapter3.xhtml#tab3-4) shows the binary and decimal representations
    for an 8-bit two’s-complement signed integer type with no padding (that is, *N*
    = 8).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">8-Bit
    Two’s-Complement Values</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Decimal</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Weighting</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Constant</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">0</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">01111110</samp> | <samp class="SANS_Futura_Std_Book_11">126</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">6</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">5</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">4</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">1</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp> | <samp class="SANS_Futura_Std_Book_11">127</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp>
    <samp class="SANS_Futura_Std_Book_11">– 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp> | <samp class="SANS_Futura_Std_Book_11">−128</samp>
    | <samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">) + 0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10000001</samp> | <samp class="SANS_Futura_Std_Book_11">−127</samp>
    | <samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">) + 1</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">11111110</samp> | <samp class="SANS_Futura_Std_Book_11">−2</samp>
    | <samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">) + 126</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp> | <samp class="SANS_Futura_Std_Book_11">−1</samp>
    | <samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">) + 127</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: It is not necessary to know the binary representations of numbers, but as a
    C programmer, you will likely find it useful.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer Overflow</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Integer overflow* occurs when a signed integer operation results in a value
    that cannot be represented in the resulting type. Signed integer overflow and
    unsigned integer wraparound are often confused. The primary difference is that
    signed integer overflow is undefined behavior, while unsigned integer wraparound
    is well-defined behavior. Unsigned integers cannot overflow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following function-like macro that returns the absolute value
    of an arithmetic operand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ll examine macros in detail in [Chapter 9](chapter9.xhtml). For now, think
    of function-like macros as functions that operate on generic types. On the surface,
    this macro appears to correctly implement the absolute value function by returning
    the nonnegative value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    without regard to its sign. We use the conditional (<samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>) operator (which I’ll cover in more detail in the next chapter) to test
    whether the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is
    negative. If so, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is negated
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">-(i)</samp>; otherwise, it evaluates
    to the unmodified value <samp class="SANS_TheSansMonoCd_W5Regular_11">(i)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp>
    as a function-like macro, it can take an argument of any type. This macro can
    overflow when passed a signed integer argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or a larger signed integer type. Of course, invoking this macro with an unsigned
    integer is pointless because unsigned integers can never be negative, so the macro’s
    output would just reproduce the argument. Let’s explore the behavior of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> macro when passed a signed
    integer argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we pass an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp>
    as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp>
    macro. This invocation expands to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro correctly returned the absolute value of <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp>.
    So far, so good. The problem is that the negative of the two’s-complement most
    negative value for a given type cannot be represented in that type, so this use
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> macro results
    in signed integer overflow. Consequently, this implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp>
    is defective and can do anything, including unexpectedly returning a negative
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What should <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS(INT_MIN)</samp>
    return to fix this behavior? Signed integer overflow is undefined behavior in
    C, allowing implementations to silently wrap around (the most common behavior),
    trap, or both (for example, some operations wrap around while other operations
    trap). *Traps* interrupt execution of the program so that no further operations
    are performed. Common architectures like x86 do a combination of both. Because
    the behavior is undefined, no universally correct solution to this problem exists,
    but we can at least test for the possibility of undefined behavior before it occurs
    and take appropriate action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the absolute-value macro useful for a variety of types, we’ll add a
    type-dependent <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp> argument
    to it. The flag represents the <samp class="SANS_TheSansMonoCd_W5Regular_11">*_MIN</samp>
    macro, which matches the type of the first argument. This value is returned in
    the following problematic case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ABSM</samp> macro tests for
    the most negative value and simply returns it if found instead of triggering the
    undefined behavior by negating it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On some systems, the C standard library implements the following <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>-only
    absolute-value function to avoid overflow when the function is passed <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MIN</samp>
    as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is converted
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> and negated.
    (I’ll discuss conversions in more detail later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps surprisingly, the unary minus (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>)
    operator is defined for unsigned integer types. The resulting unsigned integer
    value is reduced modulo the number that is one greater than the largest value
    that the resulting type can represent. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is implicitly converted back to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> as required by the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">-INT_MIN</samp>
    can’t be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, the result is implementation defined, which is why this implementation
    is used only on *some* systems, and even on these systems, the <samp class="SANS_TheSansMonoCd_W5Regular_11">abs</samp>
    function returns an incorrect value.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ABSM</samp>
    function-like macros evaluate their parameters more than once, which can cause
    surprises when their arguments change the program state. These are called *side
    effects* (covered in detail in [Chapter 4](chapter4.xhtml)). Function calls, on
    the other hand, evaluate each argument only once.
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integers have well-defined wraparound behavior. Signed integer overflow,
    or the possibility of it, should always be considered a defect.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bit-Precise Integer
    Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in [Chapter 2](chapter2.xhtml), bit-precise integer types accept an
    operand specifying the width of the integer, so a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp>
    is a signed 32-bit integer and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    _BitInt(32)</samp> is an unsigned 32-bit integer. Bit-precise integer types can
    have *any* width up to <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp>.
    Bit-precise integer types are useful in application domains, such as using 256-bit
    integer values in cryptographic symmetric ciphers like Advanced Encryption Standard
    (AES), calculating Secure Hash Algorithm (SHA)-256 hashes, representing a 24-bit
    color space, or describing the layout of network or serial protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Bit-precise integer types are also very useful when programming field-programmable
    gate arrays (FPGAs). *FPGAs* are integrated circuits often sold off-the-shelf
    that provide customers with the ability to reconfigure the hardware to meet specific
    use-case requirements after the manufacturing process. In the case of FPGA hardware,
    using normal integer types for small value ranges where the full bit-width isn’t
    used is extremely wasteful and creates severe performance and space concerns.
    At the other extreme, FPGAs can support wide integers, essentially providing arbitrary
    precision, and existing FPGA applications make use of large integers—for example,
    up to 2,031 bits. Prior to C23, programmers must pick an integer data type of
    the next larger size and manually perform mask and shifting operations. However,
    this is error prone because integer widths are implementation defined.
  prefs: []
  type: TYPE_NORMAL
- en: A bit-precise signed integer type is designated as <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp>*N*<samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>, where *N* is an integer constant
    expression that specifies the width of the type. Because bit-precise integer types
    are specified including the sign bit, a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(1)</samp>
    is invalid because it has one sign bit and no value bits. Unsigned bit-precise
    integer types do not include a sign bit, so the correct way to specify a 1-bit
    integer is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(1)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types follow
    the usual C standard integer conversion ranks, as detailed in the “Integer Conversion
    Rank” section on [page 65](#pg_65). The usual arithmetic conversions also work
    the same, where the smaller ranked integer is converted to the larger. However,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types are excepted
    from integer promotions.
  prefs: []
  type: TYPE_NORMAL
- en: Overflow occurs when a value exceeds the allowable range of a given data type.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">(_BitInt(3))7</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(_BitInt(3))2</samp>
    overflows, and the result is undefined as with other signed integer types. To
    avoid the overflow, the operation type can be widened to 4 bits by casting one
    of the operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(4)</samp>.
    Unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> wraparound
    is well-defined, and the value wraps around with two’s complement semantics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid overflow, you can cast one of the operands to a sufficient width to
    represent all possible values. For example, the following function casts one of
    the operands to 32 bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This guarantees that the product can be represented.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Constants</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Integer constants* (or *integer literals*) introduce integer values into a
    program. For example, you might use them in a declaration to initialize a counter
    to 0\. C has four kinds of integer constants that use different number systems:
    decimal constants, binary constants, octal constants, and hexadecimal constants.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Decimal constants* always begin with a nonzero digit. For example, the following
    code uses two decimal constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example code, we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>
    to the decimal constant <samp class="SANS_TheSansMonoCd_W5Regular_11">71</samp>
    and assign <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> the decimal
    constant value <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp>. (Formally,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp> is the negation operator
    [<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>] followed by an integer
    constant [<samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>]. However, the
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp> is usable
    as an integer constant expression and therefore effectively indistinguishable
    from an integer constant whose value is –12.) Use decimal constants when introducing
    regular integer values into your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a constant starts with a 0, optionally followed by digits 0 through 7, it
    is an *octal constant*. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">007</samp> octal
    equals <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> decimal, and the
    octal constant <samp class="SANS_TheSansMonoCd_W5Regular_11">0777</samp> equals
    the decimal value 511\. Octal constants are convenient when dealing with 3-bit
    fields such as POSIX file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a *hexadecimal constant* by prefixing a sequence of decimal
    digits and the letters a (or A) through f (or F) with <samp class="SANS_TheSansMonoCd_W5Regular_11">0x</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">0X</samp>. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Use hexadecimal constants when the constant you are introducing is meant to
    represent a bit pattern more than a particular value—for example, when representing
    an address. Idiomatically, most hexadecimal constants are written like <samp class="SANS_TheSansMonoCd_W5Regular_11">0xDEADBEEF</samp>
    because it resembles a typical hex dump. It’s probably a good idea for you to
    write all your hexadecimal constants like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with C23, you can also specify a binary constant by appending a sequence
    of 1 and 0 decimal digits to <samp class="SANS_TheSansMonoCd_W5Regular_11">0b</samp>.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Binary constants can be more readable than octal or hexadecimal constants, especially
    when the value is used as a bitmask.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also append a suffix to your constant to specify its type. Without
    a suffix, a decimal constant is given the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type if it can be represented as a value in that type. If it can’t be represented
    as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, it will be represented
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix
    specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> type,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LL</samp> specifies the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> type. You can combine
    these suffixes with <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>. For example, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ULL</samp> suffix specifies the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp> type.
    Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These suffixes can be either uppercase or lowercase. Uppercase is generally
    preferred for readability, as a lowercase letter l might be mistaken for the number
    1.
  prefs: []
  type: TYPE_NORMAL
- en: '*Bit-precise constants* were added in C23 to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>
    literals. The suffixes <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">uwb</samp> designate a constant
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    _BitInt(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>, respectively. The width <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> is the smallest <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> greater than 1 that
    can accommodate the value and the sign bit (when present).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp> suffix results
    in a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> that includes
    space for the sign bit even if the value of the constant is positive or was specified
    in binary, octal, or hexadecimal notation:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>
    that is then negated; two value bits, one sign bit
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-0x3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>
    that is then negated; two value bits, one sign bit
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>;
    two value bits, one sign bit
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3ub</samp> Yields an unsigned <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-3uwb </samp>Yields an unsigned
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp> that is then negated,
    resulting in wraparound
  prefs: []
  type: TYPE_NORMAL
- en: If we don’t use a suffix and the integer constant isn’t of the required type,
    it may be implicitly converted. (We’ll discuss implicit conversion in the “Arithmetic
    Conversion” section on [page 64](#pg_64).) This may result in a surprising conversion
    or a compiler diagnostic, so it’s best to specify an integer constant of an appropriate
    type. Section 6.4.4.1 of the C standard contains more information on integer constants
    (ISO/IEC 2024).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Floating-Point Representation</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Floating-point representation* is the most common digital representation of
    real numbers. Floating-point representation is a technique that uses scientific
    notation to represent numbers with a mantissa and an exponent for a given base.
    For example, the decimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">123.456</samp>
    can be represented as 1.23456 × 10², while the binary number <samp class="SANS_TheSansMonoCd_W5Regular_11">0b10100.11</samp>
    can be represented as 1.010011 × 2⁴.'
  prefs: []
  type: TYPE_NORMAL
- en: The C standard defines a general floating-point model for floating-point numbers.
    However, it does not require all implementations to use the same representation
    schemes or formats, and it allows implementations to provide values that are not
    in the C model. To keep things simple, we’ll assume conformance to Annex F. Annex
    F includes the most common floating-point formats specified in IEC 60559\. You
    can test the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_IEC_559__</samp>
    macro, or of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_IEC_60559_BFP__</samp>
    macro in newer compilers, to determine whether the implementation conforms to
    Annex F.
  prefs: []
  type: TYPE_NORMAL
- en: This section explains floating types, arithmetic, values, and constants, so
    you will know how and when to use them to emulate math on real numbers and when
    to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating Types and
    Encodings</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'C has three standard floating types: <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> type can be used
    for floating-point data and results that can be adequately represented with the
    precision and exponent range of the type. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    arithmetic to compute <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    results from <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> data is
    particularly vulnerable to roundoff error. The common IEC 60559 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    type encodes values using 1 sign bit, 8 exponent bits, and 23 significand bits.
    The value has a 24-bit significand, which is encoded in 23 bits (with help from
    the exponent field to determine the implicit leading bit).
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type provides
    greater precision and exponent range but requires additional storage. Arithmetic
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type greatly
    increases the reliability of computation of <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    results from <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> data.
    The IEC 60559 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type
    encodes values using 1 sign bit, 11 exponent bits, and 52 significand bits. The
    value has a 53-bit significand, which is encoded in 52 bits (with help from the
    exponent field to determine the implicit leading bit).
  prefs: []
  type: TYPE_NORMAL
- en: These encodings for <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> are illustrated
    in [Figure 3-2](chapter3.xhtml#fig3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f03002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">double</samp> types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate with an example encoding in type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000
    0001</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011 0000 0000 0000
    0000 0000</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: The sign bit is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the
    exponent field is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000 0001</samp>,
    and the significand field is <samp class="SANS_TheSansMonoCd_W5Regular_11">011
    0000 0000 0000 0000 0000</samp>. The sign bit encodes the sign of the number,
    where 0 is used for a positive sign and 1 is used for a negative sign. Consequently,
    the number represented in this example has a negative sign.
  prefs: []
  type: TYPE_NORMAL
- en: Because the exponent field is neither all 0s nor all 1s, the bits in the significand
    field are interpreted as bits to the right of a binary point where an implicit
    1 bit is to the left of the binary point. In this example, the significand of
    the encoded number is <samp class="SANS_TheSansMonoCd_W5Regular_11">1.011 0000
    0000 0000 0000 0000</samp> = 1 + 2^(–2) + 2^(–3) = 1.375.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this all together produces the following real number: –2²(1 + 2^(–2)
    + 2^(–3)) = –5.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">C Floating-Point
    Model</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following formula represents a number in the <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    type using the C model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/eq03001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *s* is the sign, which may be 1 or –1\. The *e* is the exponent, and *f*[1]
    through *f*[24] are the significand bits. Note that the exponent in the C model
    representation is 1 greater than the exponent we determined from the encoding
    because the C model places the (explicit) leading bit to the right of the binary
    point, while the encoding has the (implicit) leading bit to the left of the binary
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following formula represents a number in the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/eq03002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In general, the C model defines floating-point numbers in each floating type
    by the parameters *b*, *p*, *e*[min], and *e*[max]. The parameter *b* is the radix
    (the base for the exponent and the significand digits). The radix *b* for all
    the standard floating types is represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RADIX</samp>
    macro defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp>.
    For Annex F, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RADIX</samp>
    is 2\. The parameter *p* is the number of base-<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    digits in the floating-point significand. The *e*[min] parameter is the minimum
    negative integer such that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    raised to one less than that power is a normalized floating-point number. Finally,
    the *e*[max] parameter is the maximum integer such that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    raised to one less than that power is a representable finite floating-point number,
    provided that representable finite floating-point number is normalized (as it
    will be for all IEC 60559 types). [Table 3-5](chapter3.xhtml#tab3-5) shows the
    actual macro names.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Standard
    Type Characterization Macros in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parameter</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">long
    double</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">p</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MANT_DIG</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MANT_DIG</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MANT_DIG</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">e</samp><samp class="SANS_Futura_Std_Book_SUB_11">min</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MIN_EXP</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MIN_EXP</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MIN_EXP</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">e</samp><samp class="SANS_Futura_Std_Book_SUB_11">max</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MAX_EXP</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MAX_EXP</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MAX_EXP</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Each implementation assigns the <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> type one of the following formats:'
  prefs: []
  type: TYPE_NORMAL
- en: IEC 60559 quadruple (or binary128) format (IEC 60559 added binary128 to its
    basic formats in the 2011 revision)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IEC 60559 binary64-extended format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-IEC 60559 extended format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IEC 60559 double (or binary64) format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended practice for compiler implementers is to match the <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> type with the IEC 60559 binary128 format or an IEC 60559 binary64-extended
    format. IEC 60559 binary64-extended formats include the common 80-bit IEC 60559
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic with the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>
    type should be considered for computations whose reliability might benefit from
    the maximum range and precision that the implementation provides for a standard
    floating type. However, the extra range and precision in the <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> type (compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>)
    varies considerably among implementations, as does the performance (speed) of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> arithmetic. Consequently,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> type is unsuitable
    for data interchange or reproducible results (across implementations) or for portable
    high performance.
  prefs: []
  type: TYPE_NORMAL
- en: Larger types have greater precision but require more storage. Any value that
    can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    can also be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    and any value that can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>.
    The header <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp> defines
    several macros that define the characteristics of floating types.
  prefs: []
  type: TYPE_NORMAL
- en: Annex H of C23 specifies additional floating types that have the arithmetic
    interchange and extended floating-point formats specified in IEC 60559\. These
    include a sequence of types with unbounded precision and range and a 16-bit type.
    Future versions of C may include other floating types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Arithmetic</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Floating-point arithmetic is similar to, and used to model, the arithmetic of
    real numbers. However, there are differences to consider. Unlike in real number
    arithmetic, floating-point numbers are bounded in magnitude and have finite precision.
    Addition and multiplication operations are *not* associative; the distributive
    property *doesn’t* hold, nor do many other properties of real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Floating types cannot represent all real numbers exactly, even when they can
    be represented in a small number of decimal digits. For example, common decimal
    constants such as 0.1 can’t be represented exactly as binary floating-point numbers.
    Floating types may lack the necessary precision for various applications such
    as loop counters or performing financial calculations. See CERT C rule FLP30-C
    (do not use floating-point variables as loop counters) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A floating-point representation whose significand is 0 (all *f*[k] = 0) represents
    a floating-point zero. Zeros are signed according to the sign (*s*), and there
    are two floating-point zero values: +0 and –0\. They are equal but behave differently
    in a few operations. A notable example is <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0/0.0</samp>
    yields positive infinity and <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0/(-0.0)</samp>
    yields negative infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: There are no leading zeros in the significand of a *normalized* floating-point
    number (*f*[1] = 1); leading zeros are removed by adjusting the exponent. These
    are *normal* numbers, and they use the full precision of the significand. Therefore,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> has 24 significant
    bits of precision, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    has 53 significant bits of precision, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> has 113 significant bits of precision (assuming the IEC 60559 binary128
    format).
  prefs: []
  type: TYPE_NORMAL
- en: '*Subnormal* numbers are positive and negative numbers (but not 0) of very small
    magnitude whose normalized representation would result in an exponent that is
    less than the smallest exponent for the type. Their representations have exponent
    *e* = *e*[min] and leading significand bit *f*[1] = 0\. [Figure 3-3](chapter3.xhtml#fig3-3)
    is a number line showing the range of subnormal values around 0\. The precision
    of subnormal numbers is less than that of normalized numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f03003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The domain of subnormal
    numbers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Floating types can also represent values that are not floating-point numbers,
    such as negative and positive infinity and not-a-number (NaN) values. *NaNs* are
    values that do not represent a number.
  prefs: []
  type: TYPE_NORMAL
- en: Having infinity available as a specific value allows operations to continue
    past overflow and divide-by-zero situations and produce a useful result without
    requiring special treatment. Dividing any nonzero number by (positive or negative)
    zero yields an infinity. Operations with infinite values are well-defined in the
    IEEE floating-point standard.
  prefs: []
  type: TYPE_NORMAL
- en: A *quiet NaN* propagates through almost every arithmetic operation without raising
    a floating-point exception and is typically tested after a selected sequence of
    operations. An arithmetic operation with a *signaling NaN* operand generally raises
    a floating-point exception immediately. Floating-point exceptions are an advanced
    topic not covered here. For more information, refer to Annex F of the C standard.
  prefs: []
  type: TYPE_NORMAL
- en: In C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NAN</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">INFINITY</samp> macros in <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">nan</samp> functions in
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp> provide designations
    for IEC 60559 quiet NaNs and infinities. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_SNAN</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_SNAN</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_SNAN</samp>
    macros in <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp> provide
    designations for IEC 60559 signaling NaNs. C Annex F doesn’t require full support
    for signaling NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can identify the class of a floating-point value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp>
    function-like macro, which classifies its argument value as NaN, infinite, normal,
    subnormal, or zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In [Listing 3-2](chapter3.xhtml#Lis3-2), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp>
    macro in the <samp class="SANS_TheSansMonoCd_W5Regular_11">show_classification</samp>
    function to determine whether a floating-point value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is a normal value, subnormal value, zero, infinity, or NaN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: The</samp> <samp
    class="I">fpclassify</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">macro</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The function argument <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    (a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> in this example)
    is passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp>
    macro, which switches on the return value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">show_classification</samp>
    function returns a string corresponding to the class of value stored in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a variety of other classification macros including <samp class="SANS_TheSansMonoCd_W5Regular_11">isinf</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">isnan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">isnormal</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">issubnormal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">iszero</samp>,
    and so forth that may be more useful than the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp>
    macro in many applications.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating Constants</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *floating constant* is a decimal or hexadecimal number that represents a
    real number. You should use floating-point constants to represent floating-point
    values that cannot be changed. The following are some examples of floating-point
    constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following illustrates constants defined two ways: with a decimal floating
    constant and with a hexadecimal floating constant. The hexadecimal constants have
    values that can be represented exactly in their (binary) type. The decimal constants
    require conversion to binary and might be slightly affected by rounding direction
    modes and evaluation methods. (Rounding modes and evaluation methods are not covered
    in this book.) Hexadecimal constants should be used in such cases if you want
    a specific (to the last bit) value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'All floating-point constants have a type. The type is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    if unsuffixed, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> if suffixed
    by the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">F</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> if suffixed by the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The decimal point is mandatory in these examples, but the trailing zero is not.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arithmetic Conversion</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frequently, a value represented in one type (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>)
    must be represented in a different type (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>).
    This might occur when you have an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and need to pass it as an argument to a function that accepts an object of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. When such conversions
    are necessary, you should always ensure that the value is adequately representable
    in the new type. I’ll discuss this further in “Safe Conversions” on [page 70](chapter3.xhtml#pg_70).
  prefs: []
  type: TYPE_NORMAL
- en: Values can be implicitly or explicitly converted from one arithmetic type to
    another. You can use the *cast* operator to perform *explicit* conversions. [Listing
    3-3](chapter3.xhtml#Lis3-3) shows two examples of casts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: Cast operators</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To perform a cast, place a type name in parentheses just before the expression.
    The cast converts the expression to the unqualified version of the type name in
    parentheses. Here, we cast the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>
    to the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. Because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> is of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    this cast is guaranteed to be safe because the value can always be represented
    in a larger integer type of the same signedness.
  prefs: []
  type: TYPE_NORMAL
- en: The second cast in this example casts the result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(ss</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sl)</samp>
    to type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp>. Because
    the value is converted to an unsigned type (<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    short</samp>) with less precision, the result of the conversion might not be equal
    to the original value. (Some compilers might warn about this; others won’t.) In
    this example, the result of the expression (13) can be correctly represented in
    the resulting type.
  prefs: []
  type: TYPE_NORMAL
- en: '*Implicit conversion*, also known as *coercion*, occurs automatically in expressions
    as required. Values are coerced, for example, when operations are performed on
    mixed types. In [Listing 3-3](chapter3.xhtml#Lis3-3), implicit conversions are
    used to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> to the
    type of <samp class="SANS_TheSansMonoCd_W5Regular_11">sl</samp> so that the addition
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sl</samp> can be performed on a
    common type. The rules concerning which values are implicitly converted to which
    types are somewhat complicated and involve three concepts: integer conversion
    rank, integer promotions, and the usual arithmetic conversions.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Conversion
    Rank</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Integer conversion rank* is a standard rank ordering of integer types used
    to determine a common type for computations. Every integer type has an integer
    conversion rank that determines when and how conversions are implicitly performed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The C standard, section 6.3.1.1, paragraph 1 (ISO/IEC 9899:2024), states that
    every integer type has an integer conversion rank where the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: No two signed integer types have the same rank, even if they have the same representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of a signed integer type is greater than the rank of any signed integer
    type with less precision.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>
    is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>, which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">short
    int</samp>, which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of a bit-precise signed integer type is greater than the rank of any
    standard integer type with less width or any bit-precise integer type with less
    width.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of any unsigned integer type equals the rank of the corresponding signed
    integer type, if any.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of any standard integer type is greater than the rank of any extended
    integer type with the same width or bit-precise integer type with the same width.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of any bit-precise integer type relative to an extended integer type
    of the same width is implementation defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> equals
    the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> is less
    than the rank of all other standard integer types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of any enumerated type equals the rank of the compatible integer type.
    Each enumerated type is compatible with <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    a signed integer type, or an unsigned integer type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rank of any extended signed integer type relative to another extended signed
    integer type with the same precision is implementation defined but still subject
    to the other rules for determining the integer conversion rank.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Promotions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *small type* is an integer with a lower conversion rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. *Integer
    promotion* is the process of converting values of small types to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. Integer
    promotions allow you to use an expression of a small type in any expression where
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> may be used. For example, you could use a lower-ranked integer type—typically,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>—on
    the right-hand side of an assignment or as an argument to a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer promotions serve two primary purposes. First, they encourage operations
    to be performed in a natural size (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>)
    for the architecture, which improves performance. Second, they help avoid arithmetic
    errors from the overflow of intermediate values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Without integer promotion, <samp class="SANS_TheSansMonoCd_W5Regular_11">c1
    * c2</samp> would result in an overflow of the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> type on platforms where <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> is represented by an 8-bit two’s-complement value. This is because
    300 is outside the range of values (–128 to 127) that can be represented by an
    object of this type. However, because of integer promotion, <samp class="SANS_TheSansMonoCd_W5Regular_11">c1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c3</samp>
    are implicitly converted to objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, and the multiplication and division operations take place in this
    size. There is no possibility of overflow while performing these operations because
    the resulting values can be represented by this wider type. In this specific example,
    the result of the entire expression is 75, which is within range of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> type, so the value
    is preserved when stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">cresult</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to the first C standard, compilers used one of two approaches for integer
    promotions: the unsigned-preserving approach or the value-preserving approach.
    In the *unsigned-preserving approach*, the compiler promotes small, unsigned types
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. In the *value-preserving
    approach*, if all values of the original type can be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the value of the original small type is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Otherwise, it’s converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. When developing the original version of the standard (C89), the C
    standards committee decided on value-preserving rules, because they produce incorrect
    results less often than the unsigned-preserving approach. If necessary, you can
    override this behavior by using explicit type casts, as in [Listing 3-3](chapter3.xhtml#Lis3-3).'
  prefs: []
  type: TYPE_NORMAL
- en: The result of promoting small unsigned types depends on the precision of the
    integer types, which is implementation defined. For example, the x86-32 and x86-64
    architectures have an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type, a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp> type,
    and a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. For
    implementations that target one of these architectures, values of both <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp>
    are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>,
    because all the values that can be represented in these smaller types can be represented
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>. However,
    16-bit architectures, such as Intel 8086/8088 and the IBM Series/1, have an 8-bit
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type, a 16-bit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">short</samp> type, and a 16-bit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. For implementations that
    target these architectures, values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, while values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    short</samp> are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. This is because all the values that can be represented as an 8-bit
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> type can be
    represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>,
    but some values that can be represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    short</samp> cannot be represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types are exempt
    from integer promotions. Integer promotions might inflate the size of required
    hardware on some platforms, so <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>
    types aren’t subject to the integer promotion rules. For example, in a binary
    expression involving a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(12)</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(3)</samp>,
    the usual arithmetic conversions would not promote either operand to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> before determining the common
    type. Because one type is signed and one is unsigned and because the signed type
    has greater rank than the unsigned type (due to the bit-widths of the types),
    the unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp> will
    be converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(12)</samp>
    as the common type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Usual Arithmetic
    Conversions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *usual arithmetic conversions* are rules for yielding a *common real type*
    for the operands and result of an arithmetic operation. Ignoring complex or imaginary
    types, each operand is converted to the common real type. Many operators that
    accept integer operands (including <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>
    , <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>) perform conversions using the usual arithmetic conversions. The usual
    arithmetic conversions are applied to the promoted operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual arithmetic conversions first check whether one of the operands in
    the balancing conversion is a floating type. If so, it applies the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  If one type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>, the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Otherwise, if one type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Otherwise, if the type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Otherwise, the integer promotions are performed on both operands.
  prefs: []
  type: TYPE_NORMAL
- en: If one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    for example, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    If one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Particularly notable is the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, which converts
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> operand to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, although <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    typically has greater precision than <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'If neither operand is a floating type, the following usual arithmetic conversion
    rules are applied to the promoted integer operands:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  If both operands have the same type, no further conversion is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Otherwise, if both operands have signed integer types or both have unsigned
    integer types, the operand with the type that has the lesser integer conversion
    rank is converted to the type of the operand with greater rank. If one operand
    has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and the
    other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    for example, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Otherwise, if the operand that has the unsigned integer type has a rank
    greater than or equal to the rank of the other operand’s type, then the operand
    with the signed integer type is converted to the type of the operand with the
    unsigned integer type. For example, if one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Otherwise, if the type of the operand with the signed integer type can represent
    all the values of the type of the operand with unsigned integer type, then the
    operand with unsigned integer type is converted to the type of the operand with
    signed integer type. For example, if one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long long</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long long</samp> type can represent all the values of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> type, then the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long long</samp>. This is the case for implementations with a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type and a 64-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp>
    type, such as x86-32 and x86-64.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Otherwise, both operands are converted to the unsigned integer type corresponding
    to the type of the operand with signed integer type.
  prefs: []
  type: TYPE_NORMAL
- en: One consequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>
    being exempt from the integer promotion rules is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>
    operand of a binary operator is not always promoted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> as part of
    the usual arithmetic conversions. Instead, a lower-ranked operand is converted
    to the higher-rank operand type, and the result of the operation is the higher-ranked
    type. For example, given the following declarations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'the <samp class="SANS_TheSansMonoCd_W5Regular_11">a2</samp> operand in the
    following expression is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>
    as part of the multiplication, and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As part of the following multiplication, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a2</samp> is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as part of the following multiplication, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Then,
    provided the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is not greater than 32, it is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(33)</samp>
    and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(33)</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These conversion rules, which evolved as new types were added, take some getting
    used to. The irregularities in these patterns resulted from varying architectural
    properties (notably, the PDP-11’s automatic promotion of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>) coupled with a desire
    to avoid changing the behavior of existing programs and (subject to those constraints)
    a desire for uniformity. When in doubt, use type casts to explicitly force the
    conversions that you intend. That said, try not to overuse explicit conversions
    because casts can disable important diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example of Implicit
    Conversion</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example illustrates the use of integer conversion rank, integer
    promotions, and the usual arithmetic conversions. This code compares the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> value <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    for equality with the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    value <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>. We’ll assume this
    code is being compiled for the x86 architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> has a lower integer
    conversion rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, the value
    stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is promoted to
    an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>
    when used in the comparison. This is accomplished by sign-extending the original
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFF</samp>.
    *Sign extension* is used to convert a signed value to a larger-width object. The
    sign bit is copied into each bit position of the expanded object. This operation
    preserves the sign and magnitude when converting a value from a smaller to a larger
    signed integer type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the usual arithmetic conversions are applied. Because the operands to
    the equal (<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>) operator have
    different signedness and equal rank, the operand with the signed integer type
    is converted to the type of the operand with the unsigned integer type. The comparison
    is then performed as a 32-bit unsigned operation. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>
    has the same values as the promoted and converted value of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>,
    the comparison yields <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    and the code snippet prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This result should no longer be surprising.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safe Conversions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both implicit and explicit conversions (the result of a cast operation) can
    produce values that can’t be represented in the resulting type. It’s preferable
    to perform operations on objects of the same type to avoid conversions. However,
    conversions are unavoidable when a function returns or accepts an object of a
    different type. In those cases, we must ensure that the conversion is performed
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer Conversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Integer conversions* occur when a value of an integer type is converted to
    a different integer type. Conversions to larger types of the same signedness are
    always safe and don’t need to be checked. Most other conversions can produce unexpected
    results if the resulting value cannot be represented in the resulting type. To
    perform these conversions correctly, you must test that the value stored in the
    original integer type is within the range of values that can be represented in
    the resulting integer type. As an example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp>
    function shown in [Listing 3-4](chapter3.xhtml#Lis3-4) accepts a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp> argument <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    that needs to be used in a context in which only a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> is appropriate.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: Safe conversion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To perform this conversion safely, the function checks that <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    in the range [<samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp>] and returns an
    error if it cannot.
  prefs: []
  type: TYPE_NORMAL
- en: The specific range tests vary based on the conversion. See CERT C rule INT31-C
    (“Ensure that integer conversions do not result in lost or misinterpreted data”)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer-Type to Floating-Type
    Conversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Floating types that conform to Annex F support positive and negative infinities,
    so all integer values are in range. The usual IEC 60559 conversion rules apply.
    See CERT C rule FLP36-C (“Preserve precision when converting integral values to
    floating type”) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating-Type to Integer-Type
    Conversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a finite value of a floating type is converted to an integer type (other
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>), the fractional
    part is discarded. If the value of the integral part cannot be represented by
    the integer type, Annex F specifies that the “invalid” floating-point exception
    is raised, and the result is unspecified.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating-Type Demotions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting a floating-point value to a larger floating type is always safe.
    Demoting a floating-point value (that is, converting to a smaller floating type)
    is like converting an integer value to a floating type. Floating types that conform
    to Annex F support positive and negative infinities. Demoting values of floating
    types for these implementations will always succeed because any out-of-range values
    are converted to infinities. See CERT C rule FLP34-C (“Ensure that floating-point
    conversions are within range of the new type”) for more information on floating-point
    conversions.  ## <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about integers and floating types. You also learned
    about implicit and explicit conversions, integer conversion rank, integer promotions,
    and the usual arithmetic conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The use of these basic types, particularly integers, is unavoidable and ubiquitous
    in C programming. Even the “Hello, world!” program returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and prints a string—an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>—which,
    of course, is an integer type. Because integer types are used so often, you can’t
    simply reread this chapter each time you need to use them. You must understand
    their behavior so you can program effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about operators and how to write simple expressions
    to perform operations on these arithmetic types as well as other object types.
  prefs: []
  type: TYPE_NORMAL
