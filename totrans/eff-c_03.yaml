- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ARITHMETIC
    TYPES</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">算术类型</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'In this chapter, you’ll learn about the two kinds of *arithmetic types*: integers
    and floating types. Most operators in C operate on arithmetic types. Because C
    is a system-level language, performing arithmetic operations correctly can be
    difficult, resulting in frequent defects. This is partially because arithmetic
    operations in digital systems with limited range and precision do not always produce
    the same result as they would in ordinary mathematics. Performing basic arithmetic
    correctly is an essential foundation to becoming a professional C programmer.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解两种*算术类型*：整数类型和浮动类型。C 语言中的大多数运算符都作用于算术类型。由于 C 是一种系统级语言，正确执行算术运算可能会很困难，导致频繁出现缺陷。这部分是因为在具有有限范围和精度的数字系统中，算术操作的结果往往与普通数学中的结果不同。正确地进行基本算术运算是成为专业
    C 程序员的基础。
- en: We’ll dive deep into how arithmetic works in the C language so that you have
    a firm grasp of these fundamental concepts. We’ll also look at how to convert
    one arithmetic type to another, which is necessary for performing operations on
    mixed types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨 C 语言中的算术运算，帮助你牢牢掌握这些基本概念。我们还将学习如何将一种算术类型转换为另一种类型，这是进行混合类型操作所必需的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Integers</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">整数</samp>
- en: As mentioned in [Chapter 2](chapter2.xhtml), each integer type represents a
    finite range of integers. Signed integer types represent values that can be negative,
    zero, or positive; unsigned integers represent values that can be only zero or
    positive. The range of values that each integer type can represent depends on
    your implementation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](chapter2.xhtml)中提到的，每种整数类型表示一有限范围的整数。带符号整数类型表示可以为负数、零或正数的值；无符号整数表示仅能为零或正数的值。每种整数类型能够表示的值的范围取决于具体的实现。
- en: The *value* of an integer object is the ordinary mathematical value stored in
    the object. The *representation* of a value for an integer object is the particular
    encoding of the value in the bits of the object’s allocated storage. We’ll look
    at the representation in more detail later.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 整数对象的*值*是存储在对象中的普通数学值。整数对象值的*表示*是该值在对象分配存储空间中的具体编码。我们稍后将详细讨论该表示方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Padding, Width, and
    Precision</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">填充、宽度和精度</samp>
- en: All integer types except <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> may contain unused bits, called *padding*, that allow implementations
    to accommodate hardware quirks (such as skipping over a sign bit in the middle
    of a multiple- word representation) or to optimally align with a target architecture.
    The number of bits used to represent a value of a given type, excluding padding
    but including the sign, is called the *width* and is often denoted by *N*. The
    *precision* is the number of bits used to represent values, excluding sign and
    padding bits.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    外，所有整数类型可能包含未使用的位，这些位被称为*填充*，它们允许实现适应硬件的特殊情况（例如跳过多字表示中的符号位）或与目标架构进行最优对齐。表示给定类型值所使用的位数（不包括填充位，但包括符号位）称为*宽度*，通常表示为*N*。*精度*是表示值所使用的位数，排除符号位和填充位。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Ranges</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">整数范围</samp>
- en: A *representable value* is a value that can be represented in the number of
    bits available to an object of a particular type. Values that cannot be represented
    will be diagnosed by the compiler or converted to a representable but different
    (incorrect) value. The <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    header file defines object-like macros that expand to various limits and parameters
    of the standard integer types. To write portable code, you should use these macros
    rather than integer literals such as +2147483647 (the maximum value representable
    as a 32-bit integer) that represent a specific limit and may change when porting
    to a different implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*可表示的值*是可以在特定类型的对象所能使用的位数内表示的值。无法表示的值将被编译器诊断为错误，或转换为一个可表示但不同（不正确）的值。<samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>头文件定义了类似对象的宏，这些宏展开为标准整数类型的各种限制和参数。为了编写可移植的代码，您应该使用这些宏，而不是像+2147483647（32位整数所能表示的最大值）这样的整数字面量，因为这些字面量表示特定的限制，并且在移植到不同的实现时可能会发生变化。'
- en: The C standard imposes only three constraints on integer sizes. First, storage
    for *every* data type occupies an integral number of adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> objects (which may include padding). Second, each integer type must
    support a minimum range of values, allowing you to depend on a portable range
    of values across any implementation. Third, smaller types cannot be wider than
    larger types. So, for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>
    cannot be wider than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    but both types may have the same width.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C标准仅对整数的大小施加了三项约束。首先，*每个*数据类型的存储空间占据若干个相邻的<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>对象（可能包括填充）。其次，每种整数类型必须支持最小的值范围，这使得您可以依赖跨任何实现的可移植值范围。第三，小类型的宽度不能大于大类型的宽度。因此，例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">short</samp>不能比<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>宽，但两者的宽度可以相同。
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Declarations</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">整数声明</samp>'
- en: 'Unless declared as <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>,
    integer types are assumed to be signed (except for <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    which the implementation can define as either a signed or unsigned integer type).
    The following are valid declarations of unsigned integers:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除非声明为<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>，否则整数类型默认为带符号类型（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>除外，<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>的实现可以定义为带符号或无符号整数类型）。以下是无符号整数的有效声明：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When declaring signed integer types, you can omit the signed keyword— except
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>, which requires
    the keyword to distinguish <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> from plain <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明带符号整数类型时，您可以省略signed关键字——除了<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>，需要该关键字来区分<samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>和普通的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>。
- en: 'You can also omit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    when declaring variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long</samp>. For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long long</samp>的变量时，您也可以省略<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>。例如：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These are all valid signed integer declarations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是有效的带符号整数声明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Integers</samp>
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">无符号整数</samp>
- en: '*Unsigned integers* have ranges that start at 0, and their upper bound is greater
    than that of the corresponding signed integer type. Unsigned integers are frequently
    used for counting items that may have large, nonnegative quantities.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号整数*的范围从0开始，它们的上限大于相应带符号整数类型的上限。无符号整数通常用于计数可能具有大且非负值的项目。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Representation</samp>
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">表示</samp>
- en: 'Unsigned integer types are easier to understand and to use than signed integer
    types. They represent values using a pure binary system with no offset: the least
    significant bit has the weight 2⁰, the next least significant has the weight 2¹,
    and so forth. The value of the binary number is the sum of all the weights of
    the set bits. [Table 3-1](chapter3.xhtml#tab3-1) shows some examples of unsigned
    values using an unpadded 8-bit representation.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数类型比有符号整数类型更容易理解和使用。它们使用纯二进制系统表示值，没有偏移：最低有效位的权重是 2⁰，次低有效位的权重是 2¹，以此类推。二进制数的值是所有设置位的权重之和。[表
    3-1](chapter3.xhtml#tab3-1) 显示了使用未填充的 8 位表示法的无符号值的一些示例。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">8-Bit
    Unsigned Values</samp>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-1：</samp> <samp class="SANS_Futura_Std_Book_11">8
    位无符号值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Decimal</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Hexadecimal</samp> |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">十进制</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">二进制</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">十六进制</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00000000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00000000</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00000001</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x01</samp> |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00000001</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x01</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00101010</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2A</samp> |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">42</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b00101010</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2A</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">255</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b11111111</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">255</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">0b11111111</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> |'
- en: Unsigned integer types do not have a sign bit, allowing for 1-bit greater precision
    than the corresponding signed integer types. Unsigned integer values range from
    0 to a maximum value that depends on the width of the type. This maximum value
    is 2*^N* – 1, where *N* is the width. For example, most x86 architectures use
    32-bit integers with no padding bits, so an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> has a range of 0 to 2^(32) – 1 (4,294,967,295). The constant expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    specifies the implementation-defined upper range for this type. [Table 3-2](chapter3.xhtml#tab3-2)
    shows the constant expressions from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    for each unsigned type and the minimum magnitude required by the standard.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数类型没有符号位，因此它比对应的有符号整数类型能够提供更高的精度（多出 1 位）。无符号整数的值范围从 0 到一个最大值，这个最大值依赖于类型的宽度。该最大值为
    2^*N* – 1，其中 *N* 是宽度。例如，大多数 x86 架构使用 32 位整数且没有填充位，因此一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> 的对象的值范围是 0 到 2^(32) – 1（4,294,967,295）。来自 <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    的常量表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> 指定了该类型的实现定义的最大值范围。[表
    3-2](chapter3.xhtml#tab3-2) 显示了来自 <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    的每个无符号类型的常量表达式及标准要求的最小量级。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp> <samp class="SANS_Futura_Std_Book_11">Unsigned
    Integer Minimum Magnitudes</samp>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-2：</samp> <samp class="SANS_Futura_Std_Book_11">无符号整数最小量级</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant expression</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Minimum magnitude</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Maximum
    value for an object of type</samp> |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">常量表达式</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">最小量级</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">该类型对象的最大值</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UCHAR_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">255
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UCHAR_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">255
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号字符型</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">USHRT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">65,535
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">16</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short int</samp>
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">USHRT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">65,535
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">16</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号短整型</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">65,535
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">16</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">65,535
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">16</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号整型</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">4,294,967,295
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">32</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long int</samp>
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">4,294,967,295
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">32</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号长整型</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULLONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">18,446,744,073,709,551,615
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">64</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long int</samp>
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ULLONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">18,446,744,073,709,551,615
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">64</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号长长整型</samp> |'
- en: Your compiler will replace these values with implementation-defined magnitudes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编译器会将这些值替换为实现定义的数值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Wraparound</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">回绕</samp>
- en: C23 defines *wraparound* as “the process by which a value is reduced modulo
    2*^N*, where *N* is the width of the resulting type.” Wraparound occurs when you
    perform arithmetic operations that result in values too small (less than 0) or
    too large (greater than 2*^N* – 1) to be represented as a particular unsigned
    integer type. In this case, the value is reduced modulo the number that is one
    greater than the largest value that can be represented in the resulting type.
    Wraparound is well-defined behavior in the C language. Whether it is a defect
    in your code depends on the context. If you are counting something and the value
    wraps, it is likely to be an error. However, the use of wraparound in certain
    algorithms is intentional.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C23 定义了*回绕*为“将一个值按 2*^N* 取模，其中 *N* 是结果类型的宽度。”当你执行的算术运算导致值太小（小于 0）或太大（大于 2*^N*
    – 1），无法表示为特定的无符号整数类型时，就会发生回绕。在这种情况下，值会按能够表示的最大值加一的数进行取模。回绕是 C 语言中明确定义的行为。它是否是代码中的缺陷取决于上下文。如果你在计数某个东西并且值发生回绕，很可能是个错误。然而，在某些算法中故意使用回绕是合理的。
- en: The code in [Listing 3-1](chapter3.xhtml#Lis3-1) illustrates wraparound by initializing
    an unsigned integer value <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>
    to its maximum value and incrementing it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-1](chapter3.xhtml#Lis3-1) 中的代码通过将无符号整数值 <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>
    初始化为其最大值并对其进行递增，演示了回绕。'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: Unsigned integer
    wraparound</samp>'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-1：无符号整数回绕</samp>
- en: The resulting value cannot be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>, so it wraps around to 0\. If the resulting value is decremented, it
    falls outside the range again and will wrap around back to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果值不能表示为<samp class="SANS_TheSansMonoCd_W5Regular_11">无符号整数</samp>，因此会回绕到0。如果结果值被递减，它会再次超出范围并回绕回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>。
- en: 'Because of wraparound, an unsigned integer expression can never evaluate to
    less than 0\. It’s easy to lose track of this and implement comparisons that are
    always true or always false. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    in the following <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    can never take on a negative value, so this loop will never terminate:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于回绕，无符号整数表达式永远不会小于0。很容易忽略这一点，实施始终为真或始终为假的比较。例如，以下<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp>永远不会取负值，因此该循环将永远不会终止：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This behavior has caused some notable real-world bugs. For example, all six
    power-generating systems on a Boeing 787 are managed by a corresponding generator
    control unit. Boeing’s laboratory testing discovered that an internal software
    counter in the generator control unit wraps around after running continuously
    for 248 days (see the Federal Aviation Administration Rule at *[https://<wbr>www<wbr>.federalregister<wbr>.gov<wbr>/documents<wbr>/2015<wbr>/05<wbr>/01<wbr>/2015<wbr>-10066<wbr>/airworthiness<wbr>-directives<wbr>-the<wbr>-boeing<wbr>-company<wbr>-airplanes](https://www.federalregister.gov/documents/2015/05/01/2015-10066/airworthiness-directives-the-boeing-company-airplanes)*).
    This defect causes all six generator control units on the engine-mounted generators
    to enter fail-safe mode at the same time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为导致了一些著名的实际世界中的错误。例如，波音787的所有六个发电系统都由相应的发电机控制单元管理。波音的实验室测试发现，发电机控制单元中的一个内部软件计数器在连续运行248天后会发生回绕（参见*
    [https://<wbr>www<wbr>.federalregister<wbr>.gov<wbr>/documents<wbr>/2015<wbr>/05<wbr>/01<wbr>/2015<wbr>-10066<wbr>/airworthiness<wbr>-directives<wbr>-the<wbr>-boeing<wbr>-company<wbr>-airplanes](https://www.federalregister.gov/documents/2015/05/01/2015-10066/airworthiness-directives-the-boeing-company-airplanes)
    *）。这个缺陷导致所有六个发动机上安装的发电机控制单元同时进入安全模式。
- en: 'To avoid unplanned behavior (such as having your airplane fall from the sky),
    it’s important to check for wraparound by using the limits from <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>.
    Be careful when implementing these checks because it’s easy to make mistakes.
    For example, the following code contains a defect, as <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>
    can never be larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免计划外的行为（例如让你的飞机从天空中掉下来），重要的是通过使用来自<samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>的限制来检查回绕。实现这些检查时要小心，因为很容易出错。例如，以下代码存在缺陷，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>永远不会大于<samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the result of adding <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp> is larger than <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>, it is reduced modulo
    <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Therefore, the test is
    useless, and the generated code will unconditionally perform the summation. Quality
    compilers might issue a warning pointing this out, but not all do so. To remedy
    this, you can subtract <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    from both sides of the inequality to form the following effective test:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>相加的结果大于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>，则该结果将通过模运算减少到<samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。因此，这个测试是没有意义的，生成的代码将无条件执行求和。高质量的编译器可能会发出警告指出这一点，但并非所有编译器都会这么做。为了解决这个问题，你可以将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>从不等式的两边减去，从而形成以下有效的测试：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp> macro is the
    largest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> is a value
    between 0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>. If
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> is equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>,
    the result of the subtraction is 0, and if <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    is equal to 0, the result of the subtraction is <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>.
    Because the result of this operation will always fall in the allowable range of
    0 to <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>, it can never
    wrap around.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>宏是可以表示的最大<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>值，而<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>是一个介于0和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>之间的值。如果<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>等于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>，则减法结果为0；如果<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>等于0，减法结果为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>。因为这个操作的结果总是落在0到<samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>的可允许范围内，所以它永远不会发生溢出。
- en: 'The same problem occurs when checking the result of an arithmetic operation
    against 0, the minimum unsigned value:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查算术运算结果是否为0时，同样的问题会出现，这是最小的无符号值：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Because unsigned integer values can never be negative, the subtraction will
    be performed unconditionally. Quality compilers may warn about this mistake as
    well. Instead of this useless test, you can check for wraparound by testing whether
    <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> is greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无符号整数值永远不可能为负，因此减法操作将无条件执行。优质的编译器可能也会对此错误发出警告。与其进行这种无意义的测试，不如通过测试<samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp>是否大于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp>来检查是否发生溢出：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">j > i</samp>, the difference
    would wrap around, so the possibility of wraparound is prevented. By eliminating
    the subtraction from the test, the possibility of wraparound is also eliminated.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">j > i</samp>，则差值会发生溢出，从而防止溢出的发生。通过从测试中去除减法操作，溢出的可能性也随之消除。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">WARNING</samp>
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">警告</samp>
- en: '*Keep in mind that the width used during wraparound depends on the implementation,
    which means you can obtain different results on different platforms. Your code
    won’t be portable if you fail to account for this.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*请记住，溢出时使用的位宽取决于实现，这意味着你在不同平台上可能获得不同的结果。如果你没有考虑到这一点，你的代码将不具备可移植性。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signed Integers</samp>
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">有符号整数</samp>
- en: Each unsigned integer type (excluding <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>)
    has a corresponding signed integer type that occupies the same amount of storage.
    Use signed integers to represent negative, zero, and positive values, the range
    of which depends on the number of bits allocated to the type and the representation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每种无符号整数类型（排除<samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>）都有一个对应的有符号整数类型，且占用相同的存储空间。使用有符号整数表示负数、零和正数，这些值的范围取决于分配给类型的位数和表示方式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Representation</samp>
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">表示</samp>
- en: 'Representing signed integer types is more complicated than representing unsigned
    integer types. Historically, the C language has supported three different schemes
    for representing negative numbers: sign and magnitude, one’s complement, and two’s
    complement.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表示有符号整数类型比表示无符号整数类型更复杂。从历史上看，C语言支持三种不同的负数表示方案：符号和大小表示、反码表示和补码表示。
- en: Starting with C23, only two’s-complement representation is supported. In two’s
    complement representation, the sign bit is given the weight −(2*^N* ^(− 1)), and
    the other value bits have the same weights as for unsigned. The remainder of this
    book assumes the two’s complement representation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从C23开始，仅支持二进制补码表示。在二进制补码表示中，符号位的权重为−(2*^N* ^(− 1))，其他值位的权重与无符号表示相同。本书其余部分假定使用二进制补码表示。
- en: Signed two’s-complement integer types with a width of *N* can represent any
    integer value in the range of –2*^N* ^(– 1) to 2*^N* ^(– 1) – 1\. This means,
    for example, that an 8-bit value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> has a range of –128 to 127\. Compared to other signed integer representations,
    two’s complement can represent an additional *most negative* value. The most negative
    value for an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    is –128, and its absolute value |–128| cannot be represented as this type. This
    leads to some interesting edge cases, which we’ll soon examine in more detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 带符号的二进制补码整数类型，宽度为*N*，可以表示从 –2*^N* ^(– 1) 到 2*^N* ^(– 1) – 1 之间的任何整数值。这意味着，例如，8位类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 的范围是 –128 到 127。与其他带符号整数表示方法相比，二进制补码可以表示一个额外的*最小负值*。8位
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> 的最小负值是 –128，而其绝对值
    |–128| 无法表示为此类型。这导致了一些有趣的边界情况，我们将很快详细讨论。
- en: '[Table 3-3](chapter3.xhtml#tab3-3) shows the constant expressions from <samp
    class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp> for each signed type
    and the minimum magnitudes required by the standard. Your compiler will replace
    these values with implementation-defined magnitudes.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-3](chapter3.xhtml#tab3-3) 显示了 <samp class="SANS_TheSansMonoCd_W5Regular_11"><limits.h></samp>
    中每种带符号类型的常量表达式及标准要求的最小幅度。你的编译器将用实现定义的幅度替换这些值。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp> <samp class="SANS_Futura_Std_Book_11">Signed
    Integer Minimum Magnitudes</samp>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-3：</samp> <samp class="SANS_Futura_Std_Book_11">带符号整数最小幅度</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Constant expression</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Minimum magnitude</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Type</samp>
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">常量表达式</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">最小幅度</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">类型</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–128
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–128
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">7</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+127
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">7</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+127
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">7</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SHRT_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–32,768
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">short
    int</samp> |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SHRT_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–32,768
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">short
    int</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SHRT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+32,767
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SHRT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+32,767
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–32,768
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–32,768
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+32,767
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+32,767
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">15</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–2,147,483,648
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–2,147,483,648
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">31</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+2,147,483,647
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">31</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+2,147,483,647
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">31</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LLONG_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–9,223,372,036,854,775,808
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long int</samp> |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LLONG_MIN</samp> | <samp class="SANS_Futura_Std_Book_11">–9,223,372,036,854,775,808
    // –2</samp><samp class="SANS_Futura_Std_Book_SUP_11">63</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long int</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LLONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+9,223,372,036,854,775,807
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">63</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LLONG_MAX</samp> | <samp class="SANS_Futura_Std_Book_11">+9,223,372,036,854,775,807
    // 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">63</samp> <samp class="SANS_Futura_Std_Book_11">–
    1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>
    |'
- en: To negate a value in two’s-complement representation, simply toggle each nonpadding
    bit and then add 1 (with carries as necessary), as shown in [Figure 3-1](chapter3.xhtml#fig3-1).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在二进制补码表示中取反一个值，只需切换每个非填充位，然后加1（根据需要进位），如[图 3-1](chapter3.xhtml#fig3-1)所示。
- en: '![](../images/f03001.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f03001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Negating an 8-bit
    value in two’s-complement representation</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-1：在二进制补码表示中取反一个 8 位值</samp>
- en: '[Table 3-4](chapter3.xhtml#tab3-4) shows the binary and decimal representations
    for an 8-bit two’s-complement signed integer type with no padding (that is, *N*
    = 8).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-4](chapter3.xhtml#tab3-4)显示了一个没有填充的 8 位二进制补码带符号整数类型的二进制和十进制表示（即，*N* =
    8）。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp> <samp class="SANS_Futura_Std_Book_11">8-Bit
    Two’s-Complement Values</samp>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-4：</samp> <samp class="SANS_Futura_Std_Book_11">8
    位二进制补码值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Binary</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Decimal</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Weighting</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Constant</samp>
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">二进制</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">十进制</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">权重</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">常数</samp>
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000</samp> | <samp class="SANS_Futura_Std_Book_11">0</samp>
    | <samp class="SANS_Futura_Std_Book_11">0</samp> |  |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">0</samp>
    |  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000001</samp> | <samp class="SANS_Futura_Std_Book_11">1</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">0</samp>
    |  |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">01111110</samp> | <samp class="SANS_Futura_Std_Book_11">126</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">6</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">5</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">4</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">3</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">2</samp>
    <samp class="SANS_Futura_Std_Book_11">+ 2</samp><samp class="SANS_Futura_Std_Book_SUP_11">1</samp>
    |  |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">01111111</samp> | <samp class="SANS_Futura_Std_Book_11">127</samp>
    | <samp class="SANS_Futura_Std_Book_11">2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp>
    <samp class="SANS_Futura_Std_Book_11">– 1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp>
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10000000</samp> | <samp class="SANS_Futura_Std_Book_11">−128</samp>
    | <samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">) + 0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp>
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">10000001</samp> | <samp class="SANS_Futura_Std_Book_11">−127</samp>
    | <samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">) + 1</samp> |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">11111110</samp> | <samp class="SANS_Futura_Std_Book_11">−2</samp>
    | <samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">) + 126</samp> |  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">11111111</samp> | <samp class="SANS_Futura_Std_Book_11">−1</samp>
    | <samp class="SANS_Futura_Std_Book_11">−(2</samp><samp class="SANS_Futura_Std_Book_SUP_11">8</samp>
    <samp class="SANS_Futura_Std_Book_SUP_11">−</samp> <samp class="SANS_Futura_Std_Book_SUP_11">1</samp><samp
    class="SANS_Futura_Std_Book_11">) + 127</samp> |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: It is not necessary to know the binary representations of numbers, but as a
    C programmer, you will likely find it useful.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer Overflow</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Integer overflow* occurs when a signed integer operation results in a value
    that cannot be represented in the resulting type. Signed integer overflow and
    unsigned integer wraparound are often confused. The primary difference is that
    signed integer overflow is undefined behavior, while unsigned integer wraparound
    is well-defined behavior. Unsigned integers cannot overflow.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数溢出*发生在有符号整数操作的结果值无法在结果类型中表示时。有符号整数溢出和无符号整数回绕常常被混淆。主要的区别是，有符号整数溢出是未定义行为，而无符号整数回绕是定义良好的行为。无符号整数不会发生溢出。'
- en: 'Consider the following function-like macro that returns the absolute value
    of an arithmetic operand:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类似函数的宏，它返回一个算术操作数的绝对值：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll examine macros in detail in [Chapter 9](chapter9.xhtml). For now, think
    of function-like macros as functions that operate on generic types. On the surface,
    this macro appears to correctly implement the absolute value function by returning
    the nonnegative value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    without regard to its sign. We use the conditional (<samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>) operator (which I’ll cover in more detail in the next chapter) to test
    whether the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is
    negative. If so, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is negated
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">-(i)</samp>; otherwise, it evaluates
    to the unmodified value <samp class="SANS_TheSansMonoCd_W5Regular_11">(i)</samp>.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](chapter9.xhtml)中详细讨论宏。现在，暂时将类似函数的宏视为对通用类型操作的函数。从表面上看，这个宏似乎通过返回 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 的非负值来正确地实现绝对值函数，而不考虑它的符号。我们使用条件运算符（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">? :</samp>）来测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    的值是否为负。如果是，<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 被取反为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-(i)</samp>；否则，返回未修改的值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(i)</samp>。
- en: 'Because we’ve implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp>
    as a function-like macro, it can take an argument of any type. This macro can
    overflow when passed a signed integer argument of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or a larger signed integer type. Of course, invoking this macro with an unsigned
    integer is pointless because unsigned integers can never be negative, so the macro’s
    output would just reproduce the argument. Let’s explore the behavior of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> macro when passed a signed
    integer argument:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> 实现为类似函数的宏，它可以接受任何类型的参数。这个宏在传入有符号整数类型
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 或更大有符号整数类型时可能会发生溢出。当然，使用无符号整数调用这个宏是没有意义的，因为无符号整数永远不会是负数，因此宏的输出将直接复现该参数。让我们来探讨一下当传入有符号整数参数时
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> 宏的行为：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we pass an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp>
    as an argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp>
    macro. This invocation expands to the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们传入一个类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>
    且值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-25</samp> 的对象作为参数给 <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp>
    宏。这个调用展开为：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The macro correctly returned the absolute value of <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp>.
    So far, so good. The problem is that the negative of the two’s-complement most
    negative value for a given type cannot be represented in that type, so this use
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> macro results
    in signed integer overflow. Consequently, this implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp>
    is defective and can do anything, including unexpectedly returning a negative
    value:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 宏正确地返回了 <samp class="SANS_TheSansMonoCd_W5Regular_11">25</samp> 的绝对值。到目前为止，一切正常。问题在于，对于给定类型，二进制补码表示的最小负值的负值不能在该类型中表示，因此这种用法会导致有符号整数溢出。因此，这种实现方式的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> 宏是有缺陷的，可能会出现任何情况，包括意外返回负值：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What should <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS(INT_MIN)</samp>
    return to fix this behavior? Signed integer overflow is undefined behavior in
    C, allowing implementations to silently wrap around (the most common behavior),
    trap, or both (for example, some operations wrap around while other operations
    trap). *Traps* interrupt execution of the program so that no further operations
    are performed. Common architectures like x86 do a combination of both. Because
    the behavior is undefined, no universally correct solution to this problem exists,
    but we can at least test for the possibility of undefined behavior before it occurs
    and take appropriate action.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS(INT_MIN)</samp> 应该返回什么以修正此行为？在
    C 中，带符号整数溢出是未定义行为，允许实现悄无声息地环绕（最常见的行为）、陷阱或两者兼有（例如，某些操作环绕，而其他操作则触发陷阱）。*陷阱*会中断程序的执行，防止进一步的操作。像
    x86 这样的常见架构会同时执行这两种行为。由于该行为未定义，因此没有普遍正确的解决方案，但我们至少可以在发生未定义行为之前测试其可能性并采取适当的措施。
- en: 'To make the absolute-value macro useful for a variety of types, we’ll add a
    type-dependent <samp class="SANS_TheSansMonoCd_W5Regular_11">flag</samp> argument
    to it. The flag represents the <samp class="SANS_TheSansMonoCd_W5Regular_11">*_MIN</samp>
    macro, which matches the type of the first argument. This value is returned in
    the following problematic case:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使绝对值宏对各种类型都能有效，我们将向其添加一个类型相关的 <samp class="SANS_TheSansMonoCd_W5Regular_11">标志</samp>
    参数。该标志代表 <samp class="SANS_TheSansMonoCd_W5Regular_11">*_MIN</samp> 宏，匹配第一个参数的类型。在以下有问题的情况下，这个值会被返回：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ABSM</samp> macro tests for
    the most negative value and simply returns it if found instead of triggering the
    undefined behavior by negating it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ABSM</samp> 宏用于检测最小负值，并在发现时直接返回该值，而不是通过取反触发未定义行为。
- en: 'On some systems, the C standard library implements the following <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>-only
    absolute-value function to avoid overflow when the function is passed <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MIN</samp>
    as an argument:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统上，C 标准库实现了以下 <samp class="SANS_TheSansMonoCd_W5Regular_11">仅适用于整数</samp>
    的绝对值函数，以避免当函数传入 <samp class="SANS_TheSansMonoCd_W5Regular_11">INT_MIN</samp> 作为参数时发生溢出：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> is converted
    to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> and negated.
    (I’ll discuss conversions in more detail later in this chapter.)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，<samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 被转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号整数</samp>并取反。（我将在本章稍后讨论转换的更多细节。）
- en: Perhaps surprisingly, the unary minus (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>)
    operator is defined for unsigned integer types. The resulting unsigned integer
    value is reduced modulo the number that is one greater than the largest value
    that the resulting type can represent. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">i</samp>
    is implicitly converted back to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> as required by the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">-INT_MIN</samp>
    can’t be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, the result is implementation defined, which is why this implementation
    is used only on *some* systems, and even on these systems, the <samp class="SANS_TheSansMonoCd_W5Regular_11">abs</samp>
    function returns an incorrect value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，一元减号（<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>）运算符对于无符号整数类型是有定义的。结果的无符号整数值会对大于结果类型能表示的最大值的数取模。最后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i</samp> 会根据 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    语句的要求隐式地转换回 <samp class="SANS_TheSansMonoCd_W5Regular_11">带符号整数</samp>。由于 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-INT_MIN</samp> 无法表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">带符号整数</samp>，因此结果是实现定义的，这也是为什么该实现仅在*某些*系统上使用，即使在这些系统上，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">abs</samp> 函数也会返回错误的值。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ABSM</samp>
    function-like macros evaluate their parameters more than once, which can cause
    surprises when their arguments change the program state. These are called *side
    effects* (covered in detail in [Chapter 4](chapter4.xhtml)). Function calls, on
    the other hand, evaluate each argument only once.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">ABS</samp>` 和 `<samp class="SANS_TheSansMonoCd_W5Regular_11">ABSM</samp>`
    类似函数的宏会多次评估它们的参数，这可能会在参数改变程序状态时引发意外。这些被称为*副作用*（详见[第4章](chapter4.xhtml)）。另一方面，函数调用每次只评估一次每个参数。'
- en: Unsigned integers have well-defined wraparound behavior. Signed integer overflow,
    or the possibility of it, should always be considered a defect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数具有明确的环绕行为。应始终认为有符号整数溢出或可能发生溢出是一个缺陷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bit-Precise Integer
    Types</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">位精确整数类型</samp>
- en: As noted in [Chapter 2](chapter2.xhtml), bit-precise integer types accept an
    operand specifying the width of the integer, so a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp>
    is a signed 32-bit integer and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    _BitInt(32)</samp> is an unsigned 32-bit integer. Bit-precise integer types can
    have *any* width up to <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp>.
    Bit-precise integer types are useful in application domains, such as using 256-bit
    integer values in cryptographic symmetric ciphers like Advanced Encryption Standard
    (AES), calculating Secure Hash Algorithm (SHA)-256 hashes, representing a 24-bit
    color space, or describing the layout of network or serial protocols.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](chapter2.xhtml)所述，位精确的整数类型接受一个操作数来指定整数的宽度，因此 `<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(32)</samp>`
    是一个有符号32位整数，`<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(32)</samp>`
    是一个无符号32位整数。位精确的整数类型可以有*任何*宽度，最大为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp>`。位精确的整数类型在应用领域中非常有用，例如在加密对称密码（如高级加密标准（AES））中使用256位整数值，计算安全哈希算法（SHA）-256哈希，表示24位色彩空间，或描述网络或串行协议的布局。
- en: Bit-precise integer types are also very useful when programming field-programmable
    gate arrays (FPGAs). *FPGAs* are integrated circuits often sold off-the-shelf
    that provide customers with the ability to reconfigure the hardware to meet specific
    use-case requirements after the manufacturing process. In the case of FPGA hardware,
    using normal integer types for small value ranges where the full bit-width isn’t
    used is extremely wasteful and creates severe performance and space concerns.
    At the other extreme, FPGAs can support wide integers, essentially providing arbitrary
    precision, and existing FPGA applications make use of large integers—for example,
    up to 2,031 bits. Prior to C23, programmers must pick an integer data type of
    the next larger size and manually perform mask and shifting operations. However,
    this is error prone because integer widths are implementation defined.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 位精确整数类型在编程现场可编程门阵列（FPGAs）时也非常有用。*FPGAs* 是一种集成电路，通常现货出售，能够在制造过程后让客户重新配置硬件以满足特定的使用案例要求。在FPGA硬件的情况下，对于小值范围内未完全使用位宽的情况，使用普通的整数类型是极其浪费的，并会产生严重的性能和空间问题。在另一极端，FPGA可以支持宽整数，基本上提供任意精度，并且现有的FPGA应用程序使用了大整数——例如，最多达到2,031位。在C23之前，程序员必须选择下一个更大尺寸的整数数据类型，并手动执行掩码和位移操作。然而，这种做法容易出错，因为整数宽度是由实现定义的。
- en: A bit-precise signed integer type is designated as <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp>*N*<samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>, where *N* is an integer constant
    expression that specifies the width of the type. Because bit-precise integer types
    are specified including the sign bit, a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(1)</samp>
    is invalid because it has one sign bit and no value bits. Unsigned bit-precise
    integer types do not include a sign bit, so the correct way to specify a 1-bit
    integer is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(1)</samp>.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一种位精确的有符号整数类型被指定为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp>*N*<samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>`，其中 *N* 是一个整数常量表达式，指定类型的宽度。由于位精确的整数类型是包括符号位的，因此一个有符号的
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(1)</samp>` 是无效的，因为它只有一个符号位而没有值位。无符号位精确的整数类型不包括符号位，因此指定一个1位整数的正确方式是
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(1)</samp>`。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types follow
    the usual C standard integer conversion ranks, as detailed in the “Integer Conversion
    Rank” section on [page 65](#pg_65). The usual arithmetic conversions also work
    the same, where the smaller ranked integer is converted to the larger. However,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types are excepted
    from integer promotions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> 类型遵循通常的C语言标准整数转换规则，详情请参见[第65页](#pg_65)的“整数转换规则”章节。通常的算术转换也同样适用，小范围的整数会被转换为大范围的整数。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> 类型不参与整数提升。
- en: Overflow occurs when a value exceeds the allowable range of a given data type.
    For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">(_BitInt(3))7</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(_BitInt(3))2</samp>
    overflows, and the result is undefined as with other signed integer types. To
    avoid the overflow, the operation type can be widened to 4 bits by casting one
    of the operands to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(4)</samp>.
    Unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> wraparound
    is well-defined, and the value wraps around with two’s complement semantics.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出发生在值超过给定数据类型允许的范围时。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">(_BitInt(3))7</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(_BitInt(3))2</samp>
    会发生溢出，结果是未定义的，和其他带符号整数类型一样。为了避免溢出，可以通过将其中一个操作数强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(4)</samp>，将操作类型扩展到4位。无符号
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> 的回绕是明确定义的，值会以二进制补码语义进行回绕。
- en: 'To avoid overflow, you can cast one of the operands to a sufficient width to
    represent all possible values. For example, the following function casts one of
    the operands to 32 bits:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免溢出，你可以将其中一个操作数强制转换为足够宽度的类型，以表示所有可能的值。例如，以下函数将其中一个操作数强制转换为32位：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This guarantees that the product can be represented.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以保证结果的乘积能够正确表示。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Constants</samp>
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">整数常量</samp>
- en: '*Integer constants* (or *integer literals*) introduce integer values into a
    program. For example, you might use them in a declaration to initialize a counter
    to 0\. C has four kinds of integer constants that use different number systems:
    decimal constants, binary constants, octal constants, and hexadecimal constants.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数常量*（或*整数字面量*）将整数值引入程序中。例如，你可以在声明中使用它们，将计数器初始化为0。C语言有四种整数常量，使用不同的进制：十进制常量、二进制常量、八进制常量和十六进制常量。'
- en: '*Decimal constants* always begin with a nonzero digit. For example, the following
    code uses two decimal constants:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制常量*总是以非零数字开头。例如，下面的代码使用了两个十进制常量：'
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example code, we initialize <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>
    to the decimal constant <samp class="SANS_TheSansMonoCd_W5Regular_11">71</samp>
    and assign <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> the decimal
    constant value <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp>. (Formally,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp> is the negation operator
    [<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>] followed by an integer
    constant [<samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>]. However, the
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp> is usable
    as an integer constant expression and therefore effectively indistinguishable
    from an integer constant whose value is –12.) Use decimal constants when introducing
    regular integer values into your code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码中，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp> 初始化为十进制常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">71</samp>，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>
    赋值为十进制常量值 <samp class="SANS_TheSansMonoCd_W5Regular_11">-12</samp>。（严格来说，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-12</samp> 是取反操作符 [<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>]
    后跟一个整数常量 [<samp class="SANS_TheSansMonoCd_W5Regular_11">12</samp>]。然而，表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-12</samp> 可以作为整数常量表达式使用，因此与值为–12的整数常量本质上是不可区分的。）在代码中引入常规整数值时，使用十进制常量。
- en: 'If a constant starts with a 0, optionally followed by digits 0 through 7, it
    is an *octal constant*. Here’s an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常量以0开头，并可选地跟随0到7之间的数字，它就是一个*八进制常量*。以下是一个示例：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">007</samp> octal
    equals <samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp> decimal, and the
    octal constant <samp class="SANS_TheSansMonoCd_W5Regular_11">0777</samp> equals
    the decimal value 511\. Octal constants are convenient when dealing with 3-bit
    fields such as POSIX file permissions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，<samp class="SANS_TheSansMonoCd_W5Regular_11">007</samp>八进制等于<samp class="SANS_TheSansMonoCd_W5Regular_11">7</samp>十进制，八进制常量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0777</samp>等于十进制值511。八进制常量在处理像POSIX文件权限这样的3位字段时非常方便。
- en: 'You can also create a *hexadecimal constant* by prefixing a sequence of decimal
    digits and the letters a (or A) through f (or F) with <samp class="SANS_TheSansMonoCd_W5Regular_11">0x</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">0X</samp>. For example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在一系列十进制数字和字母a（或A）到f（或F）前添加<samp class="SANS_TheSansMonoCd_W5Regular_11">0x</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0X</samp>来创建一个*十六进制常量*。例如：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Use hexadecimal constants when the constant you are introducing is meant to
    represent a bit pattern more than a particular value—for example, when representing
    an address. Idiomatically, most hexadecimal constants are written like <samp class="SANS_TheSansMonoCd_W5Regular_11">0xDEADBEEF</samp>
    because it resembles a typical hex dump. It’s probably a good idea for you to
    write all your hexadecimal constants like this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你引入的常量旨在表示比特模式而不是特定值时，使用十六进制常量——例如，在表示地址时。习惯上，大多数十六进制常量写作<samp class="SANS_TheSansMonoCd_W5Regular_11">0xDEADBEEF</samp>，因为它类似于典型的十六进制转储。你最好将所有的十六进制常量都写成这样。
- en: 'Starting with C23, you can also specify a binary constant by appending a sequence
    of 1 and 0 decimal digits to <samp class="SANS_TheSansMonoCd_W5Regular_11">0b</samp>.
    For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从C23开始，你还可以通过将一系列1和0十进制数字附加到<samp class="SANS_TheSansMonoCd_W5Regular_11">0b</samp>后面来指定二进制常量。例如：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Binary constants can be more readable than octal or hexadecimal constants, especially
    when the value is used as a bitmask.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制常量比八进制或十六进制常量更具可读性，特别是在该值作为位掩码使用时。
- en: 'You can also append a suffix to your constant to specify its type. Without
    a suffix, a decimal constant is given the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type if it can be represented as a value in that type. If it can’t be represented
    as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, it will be represented
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    long int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> suffix
    specifies the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> type,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LL</samp> specifies the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> type. You can combine
    these suffixes with <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>. For example, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ULL</samp> suffix specifies the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long long</samp> type.
    Here are some examples:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以给常量添加后缀来指定其类型。如果没有后缀，十进制常量会被赋予<int>类型，前提是它可以在该类型中表示。如果不能表示为<int>类型，它将被表示为<long
    int>或<long long int>类型。<L>后缀指定<long>类型，而<LL>指定<long long>类型。你可以将这些后缀与<U>结合使用，表示<signed>类型。例如，<ULL>后缀指定<unsigned
    long long>类型。以下是一些示例：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These suffixes can be either uppercase or lowercase. Uppercase is generally
    preferred for readability, as a lowercase letter l might be mistaken for the number
    1.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些后缀可以是大写或小写。通常建议使用大写字母以提高可读性，因为小写字母l可能会与数字1混淆。
- en: '*Bit-precise constants* were added in C23 to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>
    literals. The suffixes <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">uwb</samp> designate a constant
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    _BitInt(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>, respectively. The width <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> is the smallest <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp> greater than 1 that
    can accommodate the value and the sign bit (when present).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*精确位常量*在C23中被添加，用来指定<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>字面量。后缀<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wb</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">uwb</samp>分别表示类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">)</samp>和无符号的<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp>常量。宽度<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">N</samp>是大于1的最小值，能够容纳值和符号位（如果存在）。'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp> suffix results
    in a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> that includes
    space for the sign bit even if the value of the constant is positive or was specified
    in binary, octal, or hexadecimal notation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">wb</samp>后缀会导致一个包含符号位的<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>，即使常数值为正或已使用二进制、八进制或十六进制表示：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>
    that is then negated; two value bits, one sign bit
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-3wb</samp> 产生一个<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>，然后对其取反；两个值位，一个符号位
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-0x3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>
    that is then negated; two value bits, one sign bit
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-0x3wb</samp> 产生一个<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>，然后对其取反；两个值位，一个符号位
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3wb</samp> Yields a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>;
    two value bits, one sign bit
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3wb</samp> 产生一个<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>；两个值位，一个符号位
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3ub</samp> Yields an unsigned <samp
    class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">3ub</samp> 产生一个无符号的<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp>
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-3uwb </samp>Yields an unsigned
    <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp> that is then negated,
    resulting in wraparound
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-3uwb </samp>产生一个无符号的<samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp>，然后对其取反，导致环绕现象
- en: If we don’t use a suffix and the integer constant isn’t of the required type,
    it may be implicitly converted. (We’ll discuss implicit conversion in the “Arithmetic
    Conversion” section on [page 64](#pg_64).) This may result in a surprising conversion
    or a compiler diagnostic, so it’s best to specify an integer constant of an appropriate
    type. Section 6.4.4.1 of the C standard contains more information on integer constants
    (ISO/IEC 2024).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用后缀，且整数常量不是所需类型，它可能会被隐式转换。（我们将在“算术转换”部分讨论隐式转换，详见[第64页](#pg_64)。）这可能导致意外的转换或编译器诊断，因此最好指定一个合适类型的整数常量。C标准第6.4.4.1节提供了更多关于整数常量的信息（ISO/IEC
    2024）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Floating-Point Representation</samp>
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">浮点数表示</samp>
- en: '*Floating-point representation* is the most common digital representation of
    real numbers. Floating-point representation is a technique that uses scientific
    notation to represent numbers with a mantissa and an exponent for a given base.
    For example, the decimal number <samp class="SANS_TheSansMonoCd_W5Regular_11">123.456</samp>
    can be represented as 1.23456 × 10², while the binary number <samp class="SANS_TheSansMonoCd_W5Regular_11">0b10100.11</samp>
    can be represented as 1.010011 × 2⁴.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮动点表示法* 是表示实数的最常见的数字表示方式。浮动点表示法是一种使用科学记数法来表示数值的技术，其中包含一个尾数和一个指数，基于给定的进制。例如，十进制数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">123.456</samp> 可以表示为 1.23456 × 10²，而二进制数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0b10100.11</samp> 可以表示为 1.010011
    × 2⁴。'
- en: The C standard defines a general floating-point model for floating-point numbers.
    However, it does not require all implementations to use the same representation
    schemes or formats, and it allows implementations to provide values that are not
    in the C model. To keep things simple, we’ll assume conformance to Annex F. Annex
    F includes the most common floating-point formats specified in IEC 60559\. You
    can test the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_IEC_559__</samp>
    macro, or of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_IEC_60559_BFP__</samp>
    macro in newer compilers, to determine whether the implementation conforms to
    Annex F.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C 标准定义了一个浮动点数的通用模型。然而，它并不要求所有实现都使用相同的表示方案或格式，并且允许实现提供不符合 C 模型的值。为了简化，我们假设符合附录
    F。附录 F 包含 IEC 60559 标准中指定的最常见的浮动点格式。你可以通过测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_IEC_559__</samp>
    宏，或者在较新的编译器中测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">__STDC_IEC_60559_BFP__</samp>
    宏，来确定实现是否符合附录 F。
- en: This section explains floating types, arithmetic, values, and constants, so
    you will know how and when to use them to emulate math on real numbers and when
    to avoid them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了浮动类型、算术运算、值和常量，帮助你了解如何以及何时使用它们来模拟实数运算，以及何时避免使用它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating Types and
    Encodings</samp>
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮动类型和编码</samp>
- en: 'C has three standard floating types: <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言有三种标准的浮动类型：<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> type can be used
    for floating-point data and results that can be adequately represented with the
    precision and exponent range of the type. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    arithmetic to compute <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    results from <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> data is
    particularly vulnerable to roundoff error. The common IEC 60559 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    type encodes values using 1 sign bit, 8 exponent bits, and 23 significand bits.
    The value has a 24-bit significand, which is encoded in 23 bits (with help from
    the exponent field to determine the implicit leading bit).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 类型可以用于浮动点数据和结果，这些数据和结果可以通过该类型的精度和指数范围来充分表示。使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 算术运算从 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    数据计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 结果尤其容易产生舍入误差。常见的
    IEC 60559 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 类型通过使用 1
    位符号位、8 位指数位和 23 位尾数位来编码值。该值有一个 24 位的尾数，编码为 23 位（借助指数字段来确定隐式的领先位）。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type provides
    greater precision and exponent range but requires additional storage. Arithmetic
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type greatly
    increases the reliability of computation of <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    results from <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> data.
    The IEC 60559 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type
    encodes values using 1 sign bit, 11 exponent bits, and 52 significand bits. The
    value has a 53-bit significand, which is encoded in 52 bits (with help from the
    exponent field to determine the implicit leading bit).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>`类型提供了更高的精度和指数范围，但需要额外的存储空间。使用`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>`类型进行算术运算显著提高了从`<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>`数据中计算`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp>`结果的可靠性。IEC 60559标准中的`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>`类型使用1个符号位、11个指数位和52个尾数位对值进行编码。该值的尾数有53位，其中52位由指数域帮助确定隐含的前导1位进行编码。'
- en: These encodings for <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> are illustrated
    in [Figure 3-2](chapter3.xhtml#fig3-2).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对于`<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>`和`<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>`的编码在[图3-2](chapter3.xhtml#fig3-2)中有所说明。
- en: '![](../images/f03002.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f03002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">double</samp> types</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-2：`<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">float</samp>`和`<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">double</samp>`类型</samp>
- en: 'Let’s illustrate with an example encoding in type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明如何在`<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>`类型中进行编码：
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">1000
    0001</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">011 0000 0000 0000
    0000 0000</samp> |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>` | `<samp class="SANS_TheSansMonoCd_W5Regular_11">1000
    0001</samp>` | `<samp class="SANS_TheSansMonoCd_W5Regular_11">011 0000 0000 0000
    0000 0000</samp>` |'
- en: '| --- | --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: The sign bit is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the
    exponent field is <samp class="SANS_TheSansMonoCd_W5Regular_11">1000 0001</samp>,
    and the significand field is <samp class="SANS_TheSansMonoCd_W5Regular_11">011
    0000 0000 0000 0000 0000</samp>. The sign bit encodes the sign of the number,
    where 0 is used for a positive sign and 1 is used for a negative sign. Consequently,
    the number represented in this example has a negative sign.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 符号位是`<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>`，指数域是`<samp class="SANS_TheSansMonoCd_W5Regular_11">1000
    0001</samp>`，尾数域是`<samp class="SANS_TheSansMonoCd_W5Regular_11">011 0000 0000
    0000 0000 0000</samp>`。符号位编码了数字的符号，其中0表示正号，1表示负号。因此，在此示例中表示的数字是负数。
- en: Because the exponent field is neither all 0s nor all 1s, the bits in the significand
    field are interpreted as bits to the right of a binary point where an implicit
    1 bit is to the left of the binary point. In this example, the significand of
    the encoded number is <samp class="SANS_TheSansMonoCd_W5Regular_11">1.011 0000
    0000 0000 0000 0000</samp> = 1 + 2^(–2) + 2^(–3) = 1.375.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指数域既不是全0也不是全1，尾数域中的位被解释为二进制点右侧的位，其中隐含的1位位于二进制点的左侧。在此示例中，编码的数字的尾数为`<samp class="SANS_TheSansMonoCd_W5Regular_11">1.011
    0000 0000 0000 0000 0000</samp>` = 1 + 2^(–2) + 2^(–3) = 1.375。
- en: 'Putting this all together produces the following real number: –2²(1 + 2^(–2)
    + 2^(–3)) = –5.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些内容结合起来得出以下实数：–2²(1 + 2^(–2) + 2^(–3)) = –5。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">C Floating-Point
    Model</samp>
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">C 浮点模型</samp>
- en: 'The following formula represents a number in the <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    type using the C model:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下公式表示使用C模型的`<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>`类型的一个数字：
- en: '![](../images/eq03001.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/eq03001.jpg)'
- en: The *s* is the sign, which may be 1 or –1\. The *e* is the exponent, and *f*[1]
    through *f*[24] are the significand bits. Note that the exponent in the C model
    representation is 1 greater than the exponent we determined from the encoding
    because the C model places the (explicit) leading bit to the right of the binary
    point, while the encoding has the (implicit) leading bit to the left of the binary
    point.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*s* 是符号位，可以是 1 或 -1。*e* 是指数，*f*[1] 到 *f*[24] 是有效数字位。注意，在 C 模型表示中，指数比我们从编码中得到的指数大
    1，因为 C 模型将（显式）前导位放在二进制小数点的右侧，而编码则将（隐式）前导位放在二进制小数点的左侧。'
- en: 'The following formula represents a number in the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下公式表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型的一个数字：
- en: '![](../images/eq03002.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/eq03002.jpg)'
- en: In general, the C model defines floating-point numbers in each floating type
    by the parameters *b*, *p*, *e*[min], and *e*[max]. The parameter *b* is the radix
    (the base for the exponent and the significand digits). The radix *b* for all
    the standard floating types is represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RADIX</samp>
    macro defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp>.
    For Annex F, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RADIX</samp>
    is 2\. The parameter *p* is the number of base-<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    digits in the floating-point significand. The *e*[min] parameter is the minimum
    negative integer such that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    raised to one less than that power is a normalized floating-point number. Finally,
    the *e*[max] parameter is the maximum integer such that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    raised to one less than that power is a representable finite floating-point number,
    provided that representable finite floating-point number is normalized (as it
    will be for all IEC 60559 types). [Table 3-5](chapter3.xhtml#tab3-5) shows the
    actual macro names.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，C 模型通过参数 *b*、*p*、*e*[min] 和 *e*[max] 来定义每种浮动类型中的浮动点数。参数 *b* 是基数（用于指数和有效数字的基数）。所有标准浮动类型的基数
    *b* 由在 <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp> 中定义的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FLT_RADIX</samp> 宏表示。在附录 F 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_RADIX</samp>
    的值为 2。参数 *p* 是浮动点有效数字中基数 *b* 的位数。*e*[min] 参数是最小负整数，使得 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    的该指数减一后得到的值是标准化的浮动点数。最后，*e*[max] 参数是最大整数，使得 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    的该指数减一后得到的值是可表示的有限浮动点数，前提是该可表示的有限浮动点数是标准化的（对于所有 IEC 60559 类型，都会是标准化的）。[表 3-5](chapter3.xhtml#tab3-5)
    显示了实际的宏名称。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp> <samp class="SANS_Futura_Std_Book_11">Standard
    Type Characterization Macros in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 3-5：</samp> <samp class="SANS_Futura_Std_Book_11">标准类型表征宏在</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Parameter</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">long
    double</samp> |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">参数</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">long
    double</samp> |'
- en: '| --- | --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">p</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MANT_DIG</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MANT_DIG</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MANT_DIG</samp>
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">p</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MANT_DIG</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MANT_DIG</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MANT_DIG</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">e</samp><samp class="SANS_Futura_Std_Book_SUB_11">min</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MIN_EXP</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MIN_EXP</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MIN_EXP</samp> |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">e</samp><samp class="SANS_Futura_Std_Book_SUB_11">min</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MIN_EXP</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MIN_EXP</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MIN_EXP</samp> |'
- en: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">e</samp><samp class="SANS_Futura_Std_Book_SUB_11">max</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MAX_EXP</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MAX_EXP</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MAX_EXP</samp> |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_Oblique_I_11">e</samp><samp class="SANS_Futura_Std_Book_SUB_11">max</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_MAX_EXP</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_MAX_EXP</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_MAX_EXP</samp> |'
- en: 'Each implementation assigns the <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> type one of the following formats:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实现为 <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> 类型分配以下格式之一：
- en: IEC 60559 quadruple (or binary128) format (IEC 60559 added binary128 to its
    basic formats in the 2011 revision)
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IEC 60559四倍精度（或binary128）格式（IEC 60559在2011年的修订中将binary128加入了其基本格式）
- en: IEC 60559 binary64-extended format
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IEC 60559 binary64扩展格式
- en: A non-IEC 60559 extended format
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非IEC 60559扩展格式
- en: IEC 60559 double (or binary64) format
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IEC 60559双精度（或binary64）格式
- en: Recommended practice for compiler implementers is to match the <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> type with the IEC 60559 binary128 format or an IEC 60559 binary64-extended
    format. IEC 60559 binary64-extended formats include the common 80-bit IEC 60559
    format.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器实现者的推荐做法是将 <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>
    类型与IEC 60559的binary128格式或IEC 60559的binary64扩展格式匹配。IEC 60559的binary64扩展格式包括常见的80位IEC
    60559格式。
- en: Arithmetic with the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>
    type should be considered for computations whose reliability might benefit from
    the maximum range and precision that the implementation provides for a standard
    floating type. However, the extra range and precision in the <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> type (compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>)
    varies considerably among implementations, as does the performance (speed) of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> arithmetic. Consequently,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> type is unsuitable
    for data interchange or reproducible results (across implementations) or for portable
    high performance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> 类型进行算术运算应该考虑用于那些可靠性可能受益于实现所提供的标准浮动类型的最大范围和精度的计算。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long double</samp> 类型（与 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    相比）的额外范围和精度在不同实现之间差异很大，<samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>
    算术运算的性能（速度）也有很大差异。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>
    类型不适合用于数据交换或可重现的结果（跨实现），也不适合便携式高性能计算。
- en: Larger types have greater precision but require more storage. Any value that
    can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    can also be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    and any value that can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>.
    The header <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp> defines
    several macros that define the characteristics of floating types.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的类型具有更高的精度，但需要更多的存储空间。任何可以表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    的值也可以表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，任何可以表示为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的值也可以表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>。头文件 <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp>
    定义了几个宏，用于定义浮动类型的特性。
- en: Annex H of C23 specifies additional floating types that have the arithmetic
    interchange and extended floating-point formats specified in IEC 60559\. These
    include a sequence of types with unbounded precision and range and a 16-bit type.
    Future versions of C may include other floating types.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: C23附录H指定了IEC 60559中指定的具有算术交换和扩展浮动点格式的其他浮动类型。包括一系列具有无限精度和范围的类型以及一个16位类型。未来版本的C可能会包括其他浮动类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Arithmetic</samp>
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮动点算术</samp>
- en: Floating-point arithmetic is similar to, and used to model, the arithmetic of
    real numbers. However, there are differences to consider. Unlike in real number
    arithmetic, floating-point numbers are bounded in magnitude and have finite precision.
    Addition and multiplication operations are *not* associative; the distributive
    property *doesn’t* hold, nor do many other properties of real numbers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点运算类似于并用于模拟实数的算术。然而，需要考虑一些差异。与实数算术不同，浮点数在大小上是有限的，并且具有有限精度。加法和乘法运算是*非*结合的；分配律*不成立*，并且许多其他实数的性质也不成立。
- en: Floating types cannot represent all real numbers exactly, even when they can
    be represented in a small number of decimal digits. For example, common decimal
    constants such as 0.1 can’t be represented exactly as binary floating-point numbers.
    Floating types may lack the necessary precision for various applications such
    as loop counters or performing financial calculations. See CERT C rule FLP30-C
    (do not use floating-point variables as loop counters) for more information.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型不能精确表示所有实数，即使它们能在少量小数位中表示。例如，常见的十进制常数如 0.1 不能精确表示为二进制浮点数。浮点类型可能缺乏足够的精度来满足各种应用需求，例如循环计数器或财务计算。有关更多信息，请参见
    CERT C 规则 FLP30-C（不要将浮点变量用作循环计数器）。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point Values</samp>
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮点数值</samp>
- en: 'A floating-point representation whose significand is 0 (all *f*[k] = 0) represents
    a floating-point zero. Zeros are signed according to the sign (*s*), and there
    are two floating-point zero values: +0 and –0\. They are equal but behave differently
    in a few operations. A notable example is <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0/0.0</samp>
    yields positive infinity and <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0/(-0.0)</samp>
    yields negative infinity.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有效位为 0（即所有 *f*[k] = 0）的浮点表示代表浮点零。零根据符号（*s*）进行签名，且有两个浮点零值：+0 和 –0。它们相等，但在一些操作中表现不同。一个显著的例子是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0/0.0</samp> 产生正无穷大，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0/(-0.0)</samp>
    产生负无穷大。
- en: There are no leading zeros in the significand of a *normalized* floating-point
    number (*f*[1] = 1); leading zeros are removed by adjusting the exponent. These
    are *normal* numbers, and they use the full precision of the significand. Therefore,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> has 24 significant
    bits of precision, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    has 53 significant bits of precision, and <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> has 113 significant bits of precision (assuming the IEC 60559 binary128
    format).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化浮点数的有效位中没有前导零（*f*[1] = 1）；前导零通过调整指数来去除。这些是*标准*数，它们使用有效位的全部精度。因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>具有
    24 位有效精度，<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>具有 53 位有效精度，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>具有 113 位有效精度（假设使用 IEC
    60559 binary128 格式）。
- en: '*Subnormal* numbers are positive and negative numbers (but not 0) of very small
    magnitude whose normalized representation would result in an exponent that is
    less than the smallest exponent for the type. Their representations have exponent
    *e* = *e*[min] and leading significand bit *f*[1] = 0\. [Figure 3-3](chapter3.xhtml#fig3-3)
    is a number line showing the range of subnormal values around 0\. The precision
    of subnormal numbers is less than that of normalized numbers.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*非标准*数是非常小的正数和负数（但不是 0），它们的标准化表示会导致指数小于该类型的最小指数。它们的表示具有指数 *e* = *e*[min]，并且前导有效位
    *f*[1] = 0。 [图 3-3](chapter3.xhtml#fig3-3) 显示的是围绕 0 的非标准值范围的数轴。非标准数的精度低于标准化数。'
- en: '![](../images/f03003.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f03003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The domain of subnormal
    numbers</samp>'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 3-3：非标准数的范围</samp>
- en: Floating types can also represent values that are not floating-point numbers,
    such as negative and positive infinity and not-a-number (NaN) values. *NaNs* are
    values that do not represent a number.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型还可以表示不是浮点数的值，例如正负无穷大和非数（NaN）值。*NaN* 是不代表任何数值的特殊值。
- en: Having infinity available as a specific value allows operations to continue
    past overflow and divide-by-zero situations and produce a useful result without
    requiring special treatment. Dividing any nonzero number by (positive or negative)
    zero yields an infinity. Operations with infinite values are well-defined in the
    IEEE floating-point standard.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: A *quiet NaN* propagates through almost every arithmetic operation without raising
    a floating-point exception and is typically tested after a selected sequence of
    operations. An arithmetic operation with a *signaling NaN* operand generally raises
    a floating-point exception immediately. Floating-point exceptions are an advanced
    topic not covered here. For more information, refer to Annex F of the C standard.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In C23, the <samp class="SANS_TheSansMonoCd_W5Regular_11">NAN</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">INFINITY</samp> macros in <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">nan</samp> functions in
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp> provide designations
    for IEC 60559 quiet NaNs and infinities. The <samp class="SANS_TheSansMonoCd_W5Regular_11">FLT_SNAN</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DBL_SNAN</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">LDBL_SNAN</samp>
    macros in <samp class="SANS_TheSansMonoCd_W5Regular_11"><float.h></samp> provide
    designations for IEC 60559 signaling NaNs. C Annex F doesn’t require full support
    for signaling NaNs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'You can identify the class of a floating-point value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp>
    function-like macro, which classifies its argument value as NaN, infinite, normal,
    subnormal, or zero:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In [Listing 3-2](chapter3.xhtml#Lis3-2), we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp>
    macro in the <samp class="SANS_TheSansMonoCd_W5Regular_11">show_classification</samp>
    function to determine whether a floating-point value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is a normal value, subnormal value, zero, infinity, or NaN.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: The</samp> <samp
    class="I">fpclassify</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">macro</samp>'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The function argument <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    (a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> in this example)
    is passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp>
    macro, which switches on the return value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">show_classification</samp>
    function returns a string corresponding to the class of value stored in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: There are also a variety of other classification macros including <samp class="SANS_TheSansMonoCd_W5Regular_11">isinf</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">isnan</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">isnormal</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">issubnormal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">iszero</samp>,
    and so forth that may be more useful than the <samp class="SANS_TheSansMonoCd_W5Regular_11">fpclassify</samp>
    macro in many applications.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating Constants</samp>
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *floating constant* is a decimal or hexadecimal number that represents a
    real number. You should use floating-point constants to represent floating-point
    values that cannot be changed. The following are some examples of floating-point
    constants:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following illustrates constants defined two ways: with a decimal floating
    constant and with a hexadecimal floating constant. The hexadecimal constants have
    values that can be represented exactly in their (binary) type. The decimal constants
    require conversion to binary and might be slightly affected by rounding direction
    modes and evaluation methods. (Rounding modes and evaluation methods are not covered
    in this book.) Hexadecimal constants should be used in such cases if you want
    a specific (to the last bit) value.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'All floating-point constants have a type. The type is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    if unsuffixed, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> if suffixed
    by the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> or <samp
    class="SANS_TheSansMonoCd_W5Regular_11">F</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp> if suffixed by the letter <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>, as shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The decimal point is mandatory in these examples, but the trailing zero is not.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Arithmetic Conversion</samp>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frequently, a value represented in one type (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>)
    must be represented in a different type (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>).
    This might occur when you have an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and need to pass it as an argument to a function that accepts an object of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. When such conversions
    are necessary, you should always ensure that the value is adequately representable
    in the new type. I’ll discuss this further in “Safe Conversions” on [page 70](chapter3.xhtml#pg_70).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Values can be implicitly or explicitly converted from one arithmetic type to
    another. You can use the *cast* operator to perform *explicit* conversions. [Listing
    3-3](chapter3.xhtml#Lis3-3) shows two examples of casts.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: Cast operators</samp>'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 3-3：类型转换操作符</samp>
- en: To perform a cast, place a type name in parentheses just before the expression.
    The cast converts the expression to the unqualified version of the type name in
    parentheses. Here, we cast the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>
    to the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. Because
    <samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp> is of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    this cast is guaranteed to be safe because the value can always be represented
    in a larger integer type of the same signedness.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行类型转换，在表达式前放置一个括号中的类型名称。这个类型转换将表达式转换为括号中类型名称的无限定版本。在这里，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>的值转换为类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>。因为<samp class="SANS_TheSansMonoCd_W5Regular_11">si</samp>是类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>，这个类型转换是安全的，因为该值总是可以在具有相同符号位的较大整数类型中表示。
- en: The second cast in this example casts the result of the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(ss</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sl)</samp>
    to type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp>. Because
    the value is converted to an unsigned type (<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    short</samp>) with less precision, the result of the conversion might not be equal
    to the original value. (Some compilers might warn about this; others won’t.) In
    this example, the result of the expression (13) can be correctly represented in
    the resulting type.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的第二个类型转换将表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">(ss</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">sl)</samp>的结果转换为类型<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp>。由于值被转换为一个精度较低的无符号类型（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp>），转换的结果可能与原值不相等。（一些编译器可能会对此发出警告，其他则不会。）在这个例子中，表达式（13）的结果可以在结果类型中正确表示。
- en: '*Implicit conversion*, also known as *coercion*, occurs automatically in expressions
    as required. Values are coerced, for example, when operations are performed on
    mixed types. In [Listing 3-3](chapter3.xhtml#Lis3-3), implicit conversions are
    used to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> to the
    type of <samp class="SANS_TheSansMonoCd_W5Regular_11">sl</samp> so that the addition
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sl</samp> can be performed on a
    common type. The rules concerning which values are implicitly converted to which
    types are somewhat complicated and involve three concepts: integer conversion
    rank, integer promotions, and the usual arithmetic conversions.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐式转换*，也称为*强制类型转换*，在表达式中根据需要自动发生。值会在操作数类型混合时进行强制转换。例如，在[列表 3-3](chapter3.xhtml#Lis3-3)中，隐式转换用于将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ss</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">sl</samp>的类型，以便可以在一个公共类型上执行加法操作<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sl</samp>。有关哪些值会被隐式转换为哪些类型的规则有些复杂，涉及三个概念：整数转换等级、整数提升和常规算术转换。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Conversion
    Rank</samp>
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">整数转换等级</samp>
- en: '*Integer conversion rank* is a standard rank ordering of integer types used
    to determine a common type for computations. Every integer type has an integer
    conversion rank that determines when and how conversions are implicitly performed.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数转换等级*是一个整数类型的标准等级排序，用于确定计算时的公共类型。每种整数类型都有一个整数转换等级，用来决定何时以及如何隐式地执行转换。'
- en: 'The C standard, section 6.3.1.1, paragraph 1 (ISO/IEC 9899:2024), states that
    every integer type has an integer conversion rank where the following applies:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: C标准，第6.3.1.1节，第1段（ISO/IEC 9899:2024），规定每种整数类型都有一个整数转换等级，以下内容适用：
- en: No two signed integer types have the same rank, even if they have the same representation.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有两个带符号的整数类型具有相同的等级，即使它们具有相同的表示方式。
- en: The rank of a signed integer type is greater than the rank of any signed integer
    type with less precision.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带符号整数类型的等级大于任何精度较低的带符号整数类型的等级。
- en: The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>
    is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>, which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">short
    int</samp>, which is greater than the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">long long int</samp>`的等级大于`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long int</samp>`的等级，而`<samp class="SANS_TheSansMonoCd_W5Regular_11">long
    int</samp>`的等级大于`<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`的等级，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`的等级大于`<samp class="SANS_TheSansMonoCd_W5Regular_11">short
    int</samp>`的等级，`<samp class="SANS_TheSansMonoCd_W5Regular_11">short int</samp>`的等级大于`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>`的等级。'
- en: The rank of a bit-precise signed integer type is greater than the rank of any
    standard integer type with less width or any bit-precise integer type with less
    width.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位精确的有符号整数类型的等级大于任何具有较小宽度的标准整数类型或具有较小宽度的位精确整数类型的等级。
- en: The rank of any unsigned integer type equals the rank of the corresponding signed
    integer type, if any.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何无符号整数类型的等级等于相应有符号整数类型的等级（如果有的话）。
- en: The rank of any standard integer type is greater than the rank of any extended
    integer type with the same width or bit-precise integer type with the same width.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何标准整数类型的等级都大于任何具有相同宽度的扩展整数类型或具有相同宽度的位精确整数类型的等级。
- en: The rank of any bit-precise integer type relative to an extended integer type
    of the same width is implementation defined.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于具有相同宽度的扩展整数类型，任何位精确整数类型的等级是由实现定义的。
- en: The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> equals
    the rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>`的等级等于`<samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp>`和`<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>`的等级。'
- en: The rank of <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp> is less
    than the rank of all other standard integer types.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>`的等级小于所有其他标准整数类型的等级。'
- en: The rank of any enumerated type equals the rank of the compatible integer type.
    Each enumerated type is compatible with <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>,
    a signed integer type, or an unsigned integer type.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何枚举类型的等级等于兼容整数类型的等级。每个枚举类型都与`<samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>`、有符号整数类型或无符号整数类型兼容。
- en: The rank of any extended signed integer type relative to another extended signed
    integer type with the same precision is implementation defined but still subject
    to the other rules for determining the integer conversion rank.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于具有相同精度的另一个扩展有符号整数类型，任何扩展有符号整数类型的等级是由实现定义的，但仍然受到其他确定整数转换等级规则的约束。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Promotions</samp>
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">整数提升</samp>
- en: A *small type* is an integer with a lower conversion rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. *Integer
    promotion* is the process of converting values of small types to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. Integer
    promotions allow you to use an expression of a small type in any expression where
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> may be used. For example, you could use a lower-ranked integer type—typically,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>—on
    the right-hand side of an assignment or as an argument to a function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*小类型*是一个具有低于`<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`或`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>`转换等级的整数。*整数提升*是将小类型的值转换为`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`或`<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>`的过程。整数提升允许你在任何可以使用`<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>`或`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>`的表达式中使用小类型的表达式。例如，你可以在赋值的右侧或作为函数的参数使用一个较低等级的整数类型——通常是`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char</samp>`或`<samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp>`。'
- en: 'Integer promotions serve two primary purposes. First, they encourage operations
    to be performed in a natural size (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>)
    for the architecture, which improves performance. Second, they help avoid arithmetic
    errors from the overflow of intermediate values, for example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Without integer promotion, <samp class="SANS_TheSansMonoCd_W5Regular_11">c1
    * c2</samp> would result in an overflow of the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> type on platforms where <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> is represented by an 8-bit two’s-complement value. This is because
    300 is outside the range of values (–128 to 127) that can be represented by an
    object of this type. However, because of integer promotion, <samp class="SANS_TheSansMonoCd_W5Regular_11">c1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c3</samp>
    are implicitly converted to objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, and the multiplication and division operations take place in this
    size. There is no possibility of overflow while performing these operations because
    the resulting values can be represented by this wider type. In this specific example,
    the result of the entire expression is 75, which is within range of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> type, so the value
    is preserved when stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">cresult</samp>.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to the first C standard, compilers used one of two approaches for integer
    promotions: the unsigned-preserving approach or the value-preserving approach.
    In the *unsigned-preserving approach*, the compiler promotes small, unsigned types
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. In the *value-preserving
    approach*, if all values of the original type can be represented as an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the value of the original small type is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    Otherwise, it’s converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. When developing the original version of the standard (C89), the C
    standards committee decided on value-preserving rules, because they produce incorrect
    results less often than the unsigned-preserving approach. If necessary, you can
    override this behavior by using explicit type casts, as in [Listing 3-3](chapter3.xhtml#Lis3-3).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The result of promoting small unsigned types depends on the precision of the
    integer types, which is implementation defined. For example, the x86-32 and x86-64
    architectures have an 8-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    type, a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">short</samp> type,
    and a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. For
    implementations that target one of these architectures, values of both <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned short</samp>
    are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>,
    because all the values that can be represented in these smaller types can be represented
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>. However,
    16-bit architectures, such as Intel 8086/8088 and the IBM Series/1, have an 8-bit
    <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp> type, a 16-bit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">short</samp> type, and a 16-bit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type. For implementations that
    target these architectures, values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>, while values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    short</samp> are promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. This is because all the values that can be represented as an 8-bit
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> type can be
    represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>,
    but some values that can be represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    short</samp> cannot be represented as a 16-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp> types are exempt
    from integer promotions. Integer promotions might inflate the size of required
    hardware on some platforms, so <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>
    types aren’t subject to the integer promotion rules. For example, in a binary
    expression involving a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(12)</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned _BitInt(3)</samp>,
    the usual arithmetic conversions would not promote either operand to an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> before determining the common
    type. Because one type is signed and one is unsigned and because the signed type
    has greater rank than the unsigned type (due to the bit-widths of the types),
    the unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp> will
    be converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(12)</samp>
    as the common type.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Usual Arithmetic
    Conversions</samp>
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *usual arithmetic conversions* are rules for yielding a *common real type*
    for the operands and result of an arithmetic operation. Ignoring complex or imaginary
    types, each operand is converted to the common real type. Many operators that
    accept integer operands (including <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>
    , <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">?
    :</samp>) perform conversions using the usual arithmetic conversions. The usual
    arithmetic conversions are applied to the promoted operands.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual arithmetic conversions first check whether one of the operands in
    the balancing conversion is a floating type. If so, it applies the following rules:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 1.  If one type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>, the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Otherwise, if one type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Otherwise, if the type of either operand is <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    the other operand is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Otherwise, the integer promotions are performed on both operands.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: If one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    for example, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    If one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Particularly notable is the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, which converts
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> operand to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, although <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    typically has greater precision than <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'If neither operand is a floating type, the following usual arithmetic conversion
    rules are applied to the promoted integer operands:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 1.  If both operands have the same type, no further conversion is needed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Otherwise, if both operands have signed integer types or both have unsigned
    integer types, the operand with the type that has the lesser integer conversion
    rank is converted to the type of the operand with greater rank. If one operand
    has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and the
    other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    for example, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Otherwise, if the operand that has the unsigned integer type has a rank
    greater than or equal to the rank of the other operand’s type, then the operand
    with the signed integer type is converted to the type of the operand with the
    unsigned integer type. For example, if one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>, the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Otherwise, if the type of the operand with the signed integer type can represent
    all the values of the type of the operand with unsigned integer type, then the
    operand with unsigned integer type is converted to the type of the operand with
    signed integer type. For example, if one operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> and the other operand has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long long</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long long</samp> type can represent all the values of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> type, then the operand of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> is converted to an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long long</samp>. This is the case for implementations with a 32-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type and a 64-bit <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp>
    type, such as x86-32 and x86-64.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Otherwise, both operands are converted to the unsigned integer type corresponding
    to the type of the operand with signed integer type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: One consequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>
    being exempt from the integer promotion rules is that a <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>
    operand of a binary operator is not always promoted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> as part of
    the usual arithmetic conversions. Instead, a lower-ranked operand is converted
    to the higher-rank operand type, and the result of the operation is the higher-ranked
    type. For example, given the following declarations
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'the <samp class="SANS_TheSansMonoCd_W5Regular_11">a2</samp> operand in the
    following expression is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>
    as part of the multiplication, and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(3)</samp>:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As part of the following multiplication, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a2</samp> is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, as part of the following multiplication, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is promoted to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Then,
    provided the width of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is not greater than 32, it is converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(33)</samp>
    and the resulting type is <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(33)</samp>:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These conversion rules, which evolved as new types were added, take some getting
    used to. The irregularities in these patterns resulted from varying architectural
    properties (notably, the PDP-11’s automatic promotion of <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>) coupled with a desire
    to avoid changing the behavior of existing programs and (subject to those constraints)
    a desire for uniformity. When in doubt, use type casts to explicitly force the
    conversions that you intend. That said, try not to overuse explicit conversions
    because casts can disable important diagnostics.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example of Implicit
    Conversion</samp>
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example illustrates the use of integer conversion rank, integer
    promotions, and the usual arithmetic conversions. This code compares the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> value <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    for equality with the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    value <samp class="SANS_TheSansMonoCd_W5Regular_11">ui</samp>. We’ll assume this
    code is being compiled for the x86 architecture:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>. Because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp> has a lower integer
    conversion rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, the value
    stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is promoted to
    an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">signed int</samp>
    when used in the comparison. This is accomplished by sign-extending the original
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFF</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xFFFFFFFF</samp>.
    *Sign extension* is used to convert a signed value to a larger-width object. The
    sign bit is copied into each bit position of the expanded object. This operation
    preserves the sign and magnitude when converting a value from a smaller to a larger
    signed integer type.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the usual arithmetic conversions are applied. Because the operands to
    the equal (<samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>) operator have
    different signedness and equal rank, the operand with the signed integer type
    is converted to the type of the operand with the unsigned integer type. The comparison
    is then performed as a 32-bit unsigned operation. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">UINT_MAX</samp>
    has the same values as the promoted and converted value of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>,
    the comparison yields <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    and the code snippet prints the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This result should no longer be surprising.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Safe Conversions</samp>
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both implicit and explicit conversions (the result of a cast operation) can
    produce values that can’t be represented in the resulting type. It’s preferable
    to perform operations on objects of the same type to avoid conversions. However,
    conversions are unavoidable when a function returns or accepts an object of a
    different type. In those cases, we must ensure that the conversion is performed
    correctly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer Conversions</samp>
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Integer conversions* occur when a value of an integer type is converted to
    a different integer type. Conversions to larger types of the same signedness are
    always safe and don’t need to be checked. Most other conversions can produce unexpected
    results if the resulting value cannot be represented in the resulting type. To
    perform these conversions correctly, you must test that the value stored in the
    original integer type is within the range of values that can be represented in
    the resulting integer type. As an example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">do_stuff</samp>
    function shown in [Listing 3-4](chapter3.xhtml#Lis3-4) accepts a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp> argument <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    that needs to be used in a context in which only a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    char</samp> is appropriate.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: Safe conversion</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: To perform this conversion safely, the function checks that <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp>
    can be represented as a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed char</samp>
    in the range [<samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MIN</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SCHAR_MAX</samp>] and returns an
    error if it cannot.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: The specific range tests vary based on the conversion. See CERT C rule INT31-C
    (“Ensure that integer conversions do not result in lost or misinterpreted data”)
    for more information.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Integer-Type to Floating-Type
    Conversions</samp>
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Floating types that conform to Annex F support positive and negative infinities,
    so all integer values are in range. The usual IEC 60559 conversion rules apply.
    See CERT C rule FLP36-C (“Preserve precision when converting integral values to
    floating type”) for more information.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating-Type to Integer-Type
    Conversions</samp>
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a finite value of a floating type is converted to an integer type (other
    than <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>), the fractional
    part is discarded. If the value of the integral part cannot be represented by
    the integer type, Annex F specifies that the “invalid” floating-point exception
    is raised, and the result is unspecified.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Floating-Type Demotions</samp>
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting a floating-point value to a larger floating type is always safe.
    Demoting a floating-point value (that is, converting to a smaller floating type)
    is like converting an integer value to a floating type. Floating types that conform
    to Annex F support positive and negative infinities. Demoting values of floating
    types for these implementations will always succeed because any out-of-range values
    are converted to infinities. See CERT C rule FLP34-C (“Ensure that floating-point
    conversions are within range of the new type”) for more information on floating-point
    conversions.  ## <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about integers and floating types. You also learned
    about implicit and explicit conversions, integer conversion rank, integer promotions,
    and the usual arithmetic conversions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The use of these basic types, particularly integers, is unavoidable and ubiquitous
    in C programming. Even the “Hello, world!” program returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and prints a string—an array of type <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>—which,
    of course, is an integer type. Because integer types are used so often, you can’t
    simply reread this chapter each time you need to use them. You must understand
    their behavior so you can program effectively.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about operators and how to write simple expressions
    to perform operations on these arithmetic types as well as other object types.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
