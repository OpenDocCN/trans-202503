- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First Steps
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you will
  prefs: []
  type: TYPE_NORMAL
- en: Learn the concepts of good project design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the basic properties of electricity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be introduced to the resistor, light-emitting diode (LED), transistor, rectifier
    diode, and relay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a solderless breadboard to construct circuits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how integer variables, `for` loops, and digital outputs can be used to
    create various LED effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you’ll begin to bring your Arduino to life. As you will see, there is more
    to working with Arduino than just the board itself. You’ll learn how to plan projects
    in order to make your ideas a reality, then move on to a quick primer on electricity.
    Electricity is the driving force behind everything we do in this book, and it’s
    important to have a solid understanding of the basics in order to create your
    own projects. You’ll also take a look at the components that bring real projects
    to life. Finally, you’ll examine some new functions that are the building blocks
    for your Arduino sketches.
  prefs: []
  type: TYPE_NORMAL
- en: Planning Your Projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When starting your first few projects, you might be tempted to write your sketch
    immediately after you’ve come up with a new idea. But before you start writing,
    a few basic preparatory steps are in order. After all, your Arduino board isn’t
    a mind reader; it needs precise instructions, and even if these instructions can
    be executed by the Arduino, if you overlook so much as a minor detail, the results
    may not be what you expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you are creating a project that simply blinks a light or one that controls
    an automated model railway signal, you’ll be more successful if you have a detailed
    plan. When designing your Arduino projects, follow these basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define your objective.** Determine what you want to achieve.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write your algorithm.** An *algorithm* is a set of instructions that describes
    how to accomplish your goal. Your algorithm will list the steps necessary for
    you to achieve your project’s objective.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Select your hardware.** Determine how your hardware will connect to the Arduino.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Write your sketch.** Create your initial program that tells the Arduino what
    to do.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wire it up.** Connect your hardware to the Arduino board.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test and debug.** Does it work? During this stage, you identify errors and
    find their causes, whether in the sketch, hardware, or algorithm.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The more time you spend planning your project, the easier a time you’ll have
    during the testing and debugging stage.
  prefs: []
  type: TYPE_NORMAL
- en: About Electricity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s spend a bit of time discussing electricity, since you’ll soon be building
    electronic circuits with your Arduino projects. In simple terms, *electricity*
    is a form of energy that we can harness and convert into heat, light, movement,
    and power. Electricity has three main properties that will be important to us
    as we build projects: current, voltage, and power.'
  prefs: []
  type: TYPE_NORMAL
- en: Current
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flow of electrical energy is called the *current*. Electrical current flows
    through a *circuit* (a path for the current) from the positive side of a power
    source, such as a battery, to the negative side of the power source. This is known
    as *direct current (DC)*. (For the purposes of this book, we will not deal with
    *alternating current*, or *AC*.) In some circuits, the negative side is called
    *ground (GND)*. Current is measured in *amperes* or “amps” (*A*); 1 amp is 6.2415
    × 10^(18) electrons flowing past a single point in 1 second. Smaller amounts of
    current are measured in *milliamps (mA)*, where 1,000 milliamps equal 1 amp.
  prefs: []
  type: TYPE_NORMAL
- en: Voltage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Voltage* is a measure of the difference in potential energy between a circuit’s
    positive and negative ends. This is measured in *volts (V)*. If you think of electrons
    flowing the way water flows, then voltage would be equivalent to pressure: the
    greater the voltage, the faster the current moves through a circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: Power
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Power* is a measurement of the rate at which an electrical device converts
    energy from one form to another. Power is measured in *watts (W)*. For example,
    a 100 W light bulb is much brighter than a 60 W bulb because the higher-wattage
    bulb converts more electrical energy into light.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple mathematical relationship exists among voltage, current, and power:'
  prefs: []
  type: TYPE_NORMAL
- en: Power (*W*) = Voltage (*V*) × Current (*A*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Electronic Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know a little bit about the basics of electricity, let’s look at
    how it interacts with various electronic components and devices. Electronic *components*
    are the various parts that control electric current in a circuit. Just as the
    various parts of a car’s engine work together to store fuel, filter fuel, pump
    fuel, and inject fuel to allow us to drive, electronic components work together
    to control and harness the flow of electricity to help us create useful devices.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, I’ll explain specialized components as we use them. The
    following sections describe some of the fundamental components.
  prefs: []
  type: TYPE_NORMAL
- en: The Resistor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various components, such as the Arduino’s LED, require only a small amount of
    current to function—usually around 10 mA. When the LED receives more current than
    it needs, it converts the excess to heat—and too much heat can kill an LED. To
    reduce the flow of current to components such as LEDs, we can add a *resistor*
    between the voltage source and the component. Current flows freely along normal
    copper wire, but when it encounters a resistor, its movement is slowed. Some current
    is converted into a small amount of heat, which is proportional to the value of
    the resistor. [Figure 3-1](#figure3-1) shows some commonly used resistors.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03001](image_fi/500587c03/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: Typical resistors'
  prefs: []
  type: TYPE_NORMAL
- en: Resistance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The level of resistance can be either fixed or variable. Resistance is measured
    in *ohms* (Ω) and can range from zero to thousands of ohms (*kilohms*, or kΩ)
    to millions of ohms (*megohms*, or MΩ).
  prefs: []
  type: TYPE_NORMAL
- en: Reading Resistance Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although you can test resistance with a multimeter, you can also read resistance
    directly from a physical resistor. The resistors we will use will be physically
    very small, so their resistance value usually cannot be printed on them. One common
    way to show a component’s resistance is with a series of color-coded bands, read
    from left to right, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First band** Represents the first digit of the resistance'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Second band** Represents the second digit of the resistance'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Third band** Represents the multiplier (for four-band resistors) or the third
    digit (for five-band resistors)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fourth band** Represents the multiplier (for five-band resistors) or the
    *tolerance*, or accuracy of the component’s resistance (for four-band resistors)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fifth band** Shows the tolerance for five-band resistors'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Table 3-1](#table3-1) lists the colors of resistors and their corresponding
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: Because it is difficult to manufacture resistors with exact values, you select
    a margin of error as a percentage when buying a resistor. For five-band resistors,
    a brown band in the fifth position indicates tolerance of 1 percent, gold indicates
    5 percent, and silver indicates 10 percent.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-2](#figure3-2) shows a resistor diagram. The yellow, violet, and
    orange resistance bands are read as 4, 7, and 3, respectively, as listed in [Table
    3-1](#table3-1). The third band represents the multiplier; in this example, the
    47 is multiplied by 10 to the power of 3 to arrive at the value of 47,000 Ω, more
    commonly read as 47 kΩ. The brown band indicates a very precise resistor, which
    should be accurate to within 1 percent.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03002](image_fi/500587c03/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: Example resistor diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-1: Values of Bands Printed on a Resistor, in Ohms'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Color** | **Ohms** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Black | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Brown | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Red | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Orange | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Yellow | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Green | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| Blue | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| Violet | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| Gray | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| White | 9 |'
  prefs: []
  type: TYPE_TB
- en: Chip Resistors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Surface-mount chip resistors display a printed number and letter code, as shown
    in [Figure 3-3](#figure3-3), instead of colored stripes. The first two digits
    represent a single number, and the third digit represents the number of zeros
    to follow that number. For example, the resistor in [Figure 3-3](#figure3-3) has
    a value of 10,000 Ω, or 10 kΩ.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03003](image_fi/500587c03/f03003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: A surface-mount resistor'
  prefs: []
  type: TYPE_NORMAL
- en: Power Rating
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The resistor’s *power rating* is a measurement of the power, in watts, that
    it will tolerate before overheating or failing. The resistors shown in [Figure
    3-1](#figure3-1) are 1/4W resistors, which are the most commonly used resistors
    with the Arduino system. For the purposes of the projects in this book, you only
    need 1/4W resistors.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re selecting a resistor, consider the relationship between power, current,
    and voltage. The greater the current and/or voltage in your design, the greater
    the resistor’s power rating should be.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the greater a resistor’s power rating, the greater its physical size.
    For example, the resistor shown in [Figure 3-5](#figure3-5) is a 5W resistor,
    whose body measures 22 mm long by 10 mm wide.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03005](image_fi/500587c03/f03005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: A 5W resistor'
  prefs: []
  type: TYPE_NORMAL
- en: The Light-Emitting Diode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LED is a very common, infinitely useful component that converts electrical
    current into light. LEDs come in various shapes, sizes, and colors. [Figure 3-6](#figure3-6)
    shows a common LED.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03006](image_fi/500587c03/f03006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: A red LED, 5 mm in diameter'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting LEDs in a circuit takes some care, because they are *polarized*;
    this means that current can enter and leave the LED in one direction only. The
    current enters via the *anode* (positive) side and leaves via the *cathode* (negative)
    side, as shown in [Figure 3-7](#figure3-7). Any attempt to make too much current
    flow through an LED in the opposite direction will break the component.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, LEDs are designed so that you can tell which end is which. The leg
    on the anode side is longer (you can think of the “plus” side as having length
    “added” to it), and the rim at the base of the LED is flat on the cathode side,
    as shown in [Figure 3-8](#figure3-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03007](image_fi/500587c03/f03007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-7: Current flow through an LED'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03008](image_fi/500587c03/f03008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-8: LED design indicates the anode (longer leg) and cathode (flat rim)
    sides.'
  prefs: []
  type: TYPE_NORMAL
- en: When adding LEDs to a project, you need to consider the operating voltage and
    current. For example, common red LEDs require around 1.7 V and 5 to 20 mA of current.
    This presents a slight problem for us, because the Arduino outputs a set 5 V and
    a much higher current. Luckily, we can use a current-limiting resistor to reduce
    the current flow into an LED. But which value resistor do we use? That’s where
    Ohm’s law comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the required current-limiting resistor for an LED, use this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*R* = (*V*[s] − *V*[f]) ÷ *I*'
  prefs: []
  type: TYPE_NORMAL
- en: where *V*[s] is the supply voltage (Arduino outputs 5 V), *V*[f] is the LED
    forward voltage drop (say, 1.7 V), and *I* is the current required for the LED
    (10 mA). (The value of *I* must be in amps, so 10 mA converts to 0.01 A.)
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s apply this formula to our LEDs, using values of 5 V for *V*[s], 1.7
    V for *V*[f], and 0.01 A for *I*. Substituting these values into the formula gives
    a value for *R* of 330 Ω. However, the LEDs will happily light up when fed current
    less than 10 mA. It’s good practice to use lower currents when possible to protect
    sensitive electronics, so we’ll use 560 Ω, 1/4W resistors with our LEDs, which
    allow around 6 mA of current to flow.
  prefs: []
  type: TYPE_NORMAL
- en: The Solderless Breadboard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our ever-changing circuits will need a base—something to hold them together
    and build upon. A great tool for this purpose is a *solderless breadboard*. The
    breadboard is a plastic base with rows of electrically connected sockets (just
    don’t cut bread on them). They come in many sizes, shapes, and colors, as shown
    in [Figure 3-10](#figure3-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03010](image_fi/500587c03/f03010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-10: Breadboards in various shapes and sizes'
  prefs: []
  type: TYPE_NORMAL
- en: The key to using a breadboard is knowing how the sockets are connected—whether
    in short columns or in long rows along the edge or in the center. The connections
    vary by board. For example, in the breadboard shown at the top of [Figure 3-11](#figure3-11),
    columns of five holes are connected vertically but isolated horizontally. If you
    place two wires in one vertical row, then they will be electrically connected.
    By the same token, the long rows in the center between the horizontal lines are
    connected horizontally. You’ll often need to connect a circuit to the supply voltage
    and ground, and these long horizontal lines of holes are ideal for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re building more complex circuits, a breadboard will get crowded, and
    you won’t always be able to place components exactly where you want. It’s easy
    to solve this problem using short connecting wires, however. Retailers that sell
    breadboards usually also sell small boxes of wires of various lengths, such as
    the assortment shown in [Figure 3-12](#figure3-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03011](image_fi/500587c03/f03011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-11: Breadboard internal connections'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03012](image_fi/500587c03/f03012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-12: Assorted breadboard wires'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #1: Creating a Blinking LED Wave'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s put some LEDs and resistors to work. In this project, we’ll use five LEDs
    to emulate the front of the famous vehicle KITT from the television show *Knight
    Rider*, creating a kind of wavelike light pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s our algorithm for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn on LED 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait half a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off LED 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn on LED 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait half a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off LED 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue until LED 5 is turned on, at which point the process reverses from
    LEDs 5 to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat indefinitely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Hardware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s what you’ll need to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Five LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Five 560 Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various connecting wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will connect the LEDs to digital pins 2 through 6 via the 560 Ω current-limiting
    resistors.
  prefs: []
  type: TYPE_NORMAL
- en: The Schematic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s build the circuit. Circuit layout can be described in several ways.
    For the first few projects in this book, we’ll use physical layout diagrams similar
    to the one shown in [Figure 3-13](#figure3-13).
  prefs: []
  type: TYPE_NORMAL
- en: By comparing the wiring diagram to the functions in the sketch, you can begin
    to make sense of the circuit. For example, when we use `digitalWrite(2, HIGH)`,
    a high voltage of 5 V flows from digital pin 2, through the current-limiting resistor,
    through the LED via the anode and then the cathode, and finally back to the Arduino’s
    GND socket to complete the circuit. Then, when we use `digitalWrite(2, LOW)`,
    the current stops and the LED turns off.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03013](image_fi/500587c03/f03013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-13: Circuit layout for Project 1'
  prefs: []
  type: TYPE_NORMAL
- en: The Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now for our sketch. Enter this code into the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In `void setup()` at 1, the digital I/O pins are set to outputs, because we
    want them to send current to the LEDs on demand. We specify when to turn on each
    LED using the `digitalWrite()` function in the `void loop()` section of the sketch
    at 2.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Sketch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now connect your Arduino and upload the sketch. After a second or two, the LEDs
    should blink from left to right and then back again. Success is a wonderful thing—embrace
    it!
  prefs: []
  type: TYPE_NORMAL
- en: If nothing happens, however, then immediately remove the USB cable from the
    Arduino and check that you typed the sketch correctly. If you find an error, fix
    it and upload your sketch again. If your sketch matches exactly and the LEDs still
    don’t blink, check your wiring on the breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to make an LED blink with your Arduino, but this sketch is
    somewhat inefficient. For example, if you wanted to modify it to make the LEDs
    cycle more quickly, you would need to alter each `delay(500)`. There is a better
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Using Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In computer programs, we can use *variables* to store data. The problem with
    the sketch for Project 1 as written is that because it doesn’t use variables,
    it’s not very flexible. For example, we use the function `delay(500)` to keep
    the LEDs turned on. If we want to make a change to the delay time, then we have
    to change each entry manually. To address this problem, we’ll create a variable
    to represent the value for the `delay()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following line in the Project 1 sketch, above the `void setup()`
    function and just after the initial comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This assigns the number `250` to a variable called `d`. The `int` indicates
    that the variable contains an integer—a whole number between −32,768 and 32,767\.
    Simply put, any integer value has no fraction or decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Next, change every `500` in the sketch to a `d`. Now when the sketch runs, the
    Arduino will use the value in `d` for the `delay()` functions. When you upload
    your sketch after making these changes, the LEDs will turn on and off at a much
    faster rate, as the delay value is much smaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you want to change the delay, simply change the variable declaration
    at the start of the sketch. For example, entering `100` for the delay would speed
    things up even more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Experiment with the sketch, perhaps altering the delays and the sequence of
    `HIGH` and `LOW`. Have some fun with it. Don’t disassemble the circuit yet, though;
    we’ll continue to use it with more projects in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #2: Repeating with for Loops'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing a sketch, you’ll often repeat the same function. You could simply
    copy and paste the function to duplicate it in a sketch, but that’s inefficient
    and a waste of your Arduino’s program memory. Instead, you can use `for` loops.
    The benefit of using a `for` loop is that you can determine how many times the
    code inside the loop will repeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how a `for` loop works, enter the following code as a new sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop will repeat the code within the curly brackets as long as some
    condition is true. Here we have used a new integer variable, `a`, which starts
    with the value `2`. Every time the code is executed, the `a++` will add 1 to the
    value of `a`. The loop will continue in this fashion while the value of `a` is
    less than 7 (the *condition*). Once it is equal to or greater than 7, the Arduino
    moves on and continues with whatever code comes after the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of loops that a `for` loop executes can also be set by counting
    down from a higher number to a lower number. To demonstrate this, add the following
    loop to the Project 2 sketch after the first `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `for` loop at 1 sets the value of `a` equal to 5 and then subtracts
    1 after every loop due to the `a--`. The loop continues in this manner while the
    value of `a` is greater than 1 (`a > 1`) and finishes once the value of `a` falls
    to 1 or less than 1.
  prefs: []
  type: TYPE_NORMAL
- en: We have now re-created Project 1 using less code. Upload the sketch and see
    for yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Varying LED Brightness with Pulse-Width Modulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than just turning LEDs on and off rapidly using `digitalWrite()`, we
    can define the level of brightness of an LED by adjusting the amount of time between
    each LED’s on and off states using *pulse-width modulation (PWM)*. PWM can be
    used to create the illusion that an LED is shining at different levels of brightness
    by turning the LED on and off rapidly, at around 500 cycles per second. The brightness
    we perceive is determined by the amount of time the digital output pin is on versus
    the amount of time it is off—that is, how long the LED is lit or unlit. Because
    our eyes can’t see flickers faster than 50 cycles per second, the LED appears
    to have a constant brightness.
  prefs: []
  type: TYPE_NORMAL
- en: The greater the *duty cycle* (the longer the pin is on compared to off in each
    cycle), the greater the perceived brightness of the LED connected to the digital
    output pin.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-14](#figure3-14) shows various PWM duty cycles. The filled-in gray
    areas represent the amount of time that the light is on. As you can see, the amount
    of time per cycle that the light is on increases with the duty cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03014](image_fi/500587c03/f03014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-14: Various PWM duty cycles'
  prefs: []
  type: TYPE_NORMAL
- en: Only digital pins 3, 5, 6, 9, 10, and 11 on a regular Arduino board can be used
    for PWM. They are marked on the Arduino board with a tilde (~), as shown in [Figure
    3-15](#figure3-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03015](image_fi/500587c03/f03015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-15: The PWM pins are marked with a tilde (~).'
  prefs: []
  type: TYPE_NORMAL
- en: To create a PWM signal, we use the function `analogWrite(``x``,` `y``)`, where
    `x` is the digital pin and `y` is a value for the duty cycle. `y` can be any value
    between 0 and 255, where 0 indicates a 0 percent duty cycle and 255 indicates
    a 100 percent duty cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Project #3: Demonstrating PWM'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s try this with our circuit from Project 2\. Enter the following sketch
    into the IDE and upload it to the Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The LED on digital pin 3 will exhibit a “breathing effect” as the duty cycle
    increases and decreases. In other words, the LED will turn on, increasing in brightness
    until fully lit, and then reverse until it is dark. Experiment with the sketch
    and circuit. For example, make all five LEDs breathe at once, or have them do
    so sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: More Electric Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll usually find it easy to plan on having a digital output do something
    without taking into account how much current the control really needs to get the
    job done. As you create your project, remember that each digital output pin on
    the Arduino Uno can offer a maximum of 40 mA of current per pin and 200 mA total
    for all pins. However, the three electronic hardware components discussed next
    can help you increase the current-handling ability of the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: The Transistor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost everyone has heard of a *transistor*, but most people don’t really understand
    how it works. In the spirit of brevity, I will keep the explanation as simple
    as possible. A transistor can turn on or off the flow of a much larger current
    than the Arduino Uno can handle. We can, however, safely control a transistor
    using an Arduino digital output pin. A popular transistor is the BC548, shown
    in [Figure 3-16](#figure3-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03016](image_fi/500587c03/f03016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-16: A typical transistor: the BC548'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the LED, the transistor’s pins have a unique function and need to
    be connected in the proper orientation. With the flat front of the transistor
    facing you (as shown on the left of [Figure 3-16](#figure3-16)), the pins on the
    BC548 are called, from left to right, the *collector* (C), *base* (B), and *emitter*
    (E). (Note that this pin order, or *pinout*, is for the BC548 transistor; other
    transistors may be oriented differently.) When a small current is applied to the
    base, such as from an Arduino digital I/O pin, the larger current we want to switch
    enters through the collector. It’s combined with the small current from the base
    before flowing out via the emitter. When the small control current at the base
    is turned off, no current can flow through the transistor.
  prefs: []
  type: TYPE_NORMAL
- en: The BC548 can switch up to 100 mA of current at a maximum of 30 V—much more
    than the Arduino’s digital output. In projects later in the book, you’ll read
    about transistors in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Rectifier Diode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *diode* is a very simple yet useful component that allows current to flow
    in one direction only. It looks a lot like a resistor, as you can see in [Figure
    3-17](#figure3-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03017](image_fi/500587c03/f03017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-17: A 1N4004-type rectifier diode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The projects in this book will use the 1N4004-type rectifier diode. Current
    flows into the diode via the anode and out through the cathode, which is marked
    with the ring around the diode’s body. These diodes can protect parts of the circuit
    against reverse current flow, but there is a price to pay: diodes also cause a
    drop in the voltage of around 0.7 V. The 1N4004 diode is rated to handle 1 A and
    400 V, much higher than we will be using. It’s a tough, common, and low-cost diode.'
  prefs: []
  type: TYPE_NORMAL
- en: The Relay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Relays* are used for the same reason as transistors—to control a large current
    and voltage. A relay has the advantage of being *electrically isolated* from the
    control circuit, allowing the Arduino to switch very large currents and voltages
    without actually coming into contact with those voltages, which could damage it.
    Inside the relay is an interesting pair of items: mechanical switch contacts and
    a low-voltage coil of wire, as shown in [Figure 3-18](#figure3-18).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03018](image_fi/500587c03/f03018.png)![f03018a](image_fi/500587c03/f03018a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-18: Inside a typical relay'
  prefs: []
  type: TYPE_NORMAL
- en: When a current is applied to the relay, the coil becomes an electromagnet and
    attracts a bar of metal that acts just like the toggle of a switch. The magnet
    pulls the bar in one direction when on and lets it fall back when off, thereby
    turning it on or off as current is applied to and removed from the coil. This
    movement has a distinctive “click” that you might recognize from the turn signal
    in older cars.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Voltage Circuits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand a bit about the transistor, rectifier diode, and relay,
    let’s use them together to control higher currents and voltages. For example,
    you may wish to turn a large motor on or off. Connecting the components is simple,
    as shown in [Figure 3-19](#figure3-19).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03019](image_fi/500587c03/f03019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-19: A relay control circuit'
  prefs: []
  type: TYPE_NORMAL
- en: This simple example circuit controls a relay that has a 12 V coil. One use for
    this circuit might be to control a lamp or cooling fan connected to the relay
    switching contacts. The Arduino’s digital pin 10 is connected to the transistor’s
    base via a 1 kΩ resistor. The transistor controls the current through the relay’s
    coil by switching it on and off. Remember that the pins are *C*, *B*, and then
    *E* when looking at the flat surface of the transistor. The object on the left
    of the breadboard at 1 represents a 12 V power supply for the relay coil. The
    negative or ground at 2 from the 12 V supply, the transistor’s emitter pin, and
    Arduino GND are all connected together. Finally, a 1N4004 rectifier diode is connected
    across the relay’s coil at 3, with the cathode on the positive supply side. You
    can check the relay’s data sheet to determine the pins for the contacts and to
    connect the controlled item appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The diode is in place to protect the circuit. When the relay coil changes from
    on to off, stray current remains briefly in the coil and becomes a high-voltage
    spike that has to go somewhere. The diode allows the stray current to loop around
    through the coil until it is dissipated as a tiny amount of heat. It prevents
    the turn-off spike from damaging the transistor or Arduino pin.
  prefs: []
  type: TYPE_NORMAL
- en: Looking Ahead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And now Chapter 3 draws to a close. I hope you had fun trying out the examples
    and experimenting with LED effects. In this chapter, you got to create blinking
    LEDs on the Arduino in various ways, did a bit of hacking, and learned how functions
    and loops can be used to efficiently control components connected to the Arduino.
    Studying this chapter has set you up for more success in the forthcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 will be a lot of fun. You will create some more advanced projects,
    including traffic lights, a thermometer, a battery tester, and more—so when you’re
    ready to take it to the next level, turn the page!
  prefs: []
  type: TYPE_NORMAL
