<html><head></head><body>
<p id="filepos706595" class="calibre_"><span class="calibre6"><span class="bold">
</span></span><span class="calibre1"><span class="bold">10</span></span><br class="calibre5"/><span class="calibre6"><span class="bold">AUTOMATING CLAMAV</span></span></p><p class="calibre_12"><img src="images/00010.jpg" class="calibre_13"/></p><p class="calibre_6">ClamAV is an open source antivirus solution that is used primarily for scanning emails and attachments on email servers to identify potential viruses before they reach and infect computers on the network. But that certainly isn’t its only use case. In this chapter, we’ll use ClamAV to create an automated virus scanner that we can use to scan files for malware and to identify viruses with the help of ClamAV’s database.</p><p class="calibre_6">You’ll learn to automate ClamAV in a couple of ways. One is to interface with libclamav, the native library that drives ClamAV’s command line utilities such as <span class="calibre4">clamscan</span>, a file scanner you may be familiar with. The second way is to interface with the <span class="calibre4">clamd</span> daemon through sockets in order to perform scans on computers without ClamAV installed.</p><p id="filepos707790" class="calibre_10"><span class="calibre3"><span class="bold"> Installing ClamAV</span></span></p><p class="calibre_11">ClamAV is written in C, which creates some complications when automating with C#. It’s available for Linux through common package managers such as <span class="calibre4">yum</span> and <span class="calibre4">apt</span>, as well as for Windows and OS X. Many modern Unix distributions include a ClamAV package, but that version might not be compatible with Mono and .NET.</p><p class="calibre_6">Installing ClamAV on a Linux system should go something like this: $ <span class="bold">sudo apt-get install clamav</span> If you’re running a Red Hat or Fedora-based Linux flavor that ships with <span class="calibre4">yum</span>, run something like this: $ <span class="bold">sudo yum install clamav clamav-scanner clamav-update</span> If you need to enable an extra repository in order to install ClamAV via <span class="calibre4">yum</span>, enter the following: $ <span class="bold">sudo yum install -y epel-release</span> These commands install a version of ClamAV to match your system’s architecture.</p><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">Mono and .NET can’t interface with native, unmanaged libraries unless the architecture of both are compatible. For example, 32-bit Mono and .NET won’t run the same way with ClamAV compiled for a 64-bit Linux or Windows machine. You will need to install or compile native ClamAV libraries to match the Mono or .NET 32-bit architecture.</span></blockquote><p class="calibre_6">The default ClamAV package from the package manager might not have the correct architecture for Mono/.NET. If it doesn’t, you’ll need to specifically install ClamAV to match the Mono/.NET architecture. You can write a program to verify your Mono/.NET version by checking the value of <span class="calibre4">IntPtr.Size</span>. An output of <span class="calibre4">4</span> indicates a 32-bit version, whereas an output of <span class="calibre4">8</span> is a 64-bit version. If you are running Mono or Xamarin on Linux, OS X, or Windows, you can easily check this, as shown in <a href="#filepos710244">Listing 10-1</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">echo "IntPtr.Size" | csharp</span></span><br class="calibre5"/><span class="calibre4">4</span></blockquote><p id="filepos710244" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-1: A one-liner to check the architecture of Mono/.NET</span></span></p><p class="calibre_6">Mono and Xamarin ship with an interactive interpreter for C# (called <span class="calibre4">csharp</span>), similar to the <span class="calibre4">python</span> interpreter, or <span class="calibre4">irb</span> for Ruby. By echoing the <span class="calibre4">IntPtr.Size</span> string into the interpreter using <span class="calibre4">stdin</span>, you can print the value of the <span class="calibre4">Size</span> property, which in this case is <span class="calibre4">4</span> and indicates a 32-bit architecture. If your output is also <span class="calibre4">4</span>, you would need to install 32-bit ClamAV. It might be easiest to set up a VM with the architecture you expect. Because the instructions to compile ClamAV differ across Linux, OS X, and Windows, installing 32-bit ClamAV is outside the scope of this book if you need to do it. However, there are many online tutorials that can walk you through the steps for your particular operating system.</p><p class="calibre_6">You can also use the Unix <span class="calibre4">file</span> utility to check whether your ClamAV library is a 32- or 64-bit version, as shown in <a href="#filepos711880">Listing 10-2</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">file /usr/lib/x86_64-linux-gnu/libclamav.so.7.1.1</span></span><br class="calibre5"/><span class="calibre4">libclamav.so.7.1.1: ELF ➊64-bit LSB shared object, x86-64, version 1 (GNU/Linux),</span><br class="calibre5"/><span class="calibre4">dynamically linked, not stripped </span><a id="filepos711880"/><span class="calibre4"><span class="italic">Listing 10-2: Using</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">file</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">to view the libclamav architecture</span></span></blockquote><p class="calibre_6">Using <span class="calibre4">file</span>, we can see whether the libclamav library has been compiled for a 32-bit or 64-bit architecture. On my computer, <a href="#filepos711880">Listing 10-2</a> shows that the library is a 64-bit version ➊. But in <a href="#filepos710244">Listing 10-1</a>, <span class="calibre4">IntPtr.Size</span> returned <span class="calibre4">4</span>, not <span class="calibre4">8</span>! This means my libclamav (64-bit) and Mono (32-bit) architectures are mismatched. I must either recompile ClamAV to be 32-bit in order to use it with my Mono installation or install a 64-bit Mono runtime.</p><p id="filepos712718" class="calibre_10"><span class="calibre3"><span class="bold">The ClamAV Native Library vs. the clamd Network Daemon</span></span></p><p class="calibre_11">We’ll start by automating ClamAV using the native library libclamav. This allows us to use a local copy of ClamAV and its signatures to perform virus scanning; however, this requires that the ClamAV software and signatures be properly installed and updated on the system or device. The engine can be memory and CPU intensive, using up disk space for antivirus signatures. Sometimes these requirements can take up more resources on a machine than a programmer might like, so offloading the scanning to another machine makes sense.</p><p class="calibre_6">You may rather want to perform your antivirus scanning in a central spot—perhaps when an email server sends or receives an email—in which case you won’t easily be able to use libclamav. Instead, you could use the <span class="calibre4">clamd</span> daemon to offload antivirus scanning from the email server to a dedicated virus-scanning server. You only need to keep one server’s antivirus signatures up-to-date, and you won’t run as great a risk of bogging down your email server.</p><p id="filepos713957" class="calibre_10"><span class="calibre3"><span class="bold">Automating with ClamAV’s Native Library</span></span></p><p class="calibre_11">Once you have ClamAV installed and running properly, you are ready to automate it. First, we’ll automate ClamAV using libclamav directly with P/Invoke (introduced in <a href="index_split_006.html#filepos69411">Chapter 1</a>), which allows managed assemblies to call functions from native, unmanaged libraries. Although you’ll have a handful of supporting classes to implement, integrating ClamAV into your application is relatively straightforward overall.</p><p id="filepos714558" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Setting Up the Supporting Enumerations and Classes</span></span></span></p><p class="calibre_11">We’ll use a few helper classes and enumerations in the code. All the helper classes are very simple—most are fewer than 10 lines of code. However, they make the glue that holds the methods and classes together.</p><p class="calibre_10"><span class="calibre3"><span class="bold">The Supporting Enumerations</span></span></p><p class="calibre_11">The <span class="calibre4">ClamDatabaseOptions</span> enumeration, shown in <a href="#filepos715815">Listing 10-3</a>, is used in the ClamAV engine to set options for the virus-lookup database we’ll use.</p><blockquote class="calibre_14"><span class="calibre4">[Flags]</span><br class="calibre5"/><span class="calibre4">public enum ClamDatabaseOptions</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> CL_DB_PHISHING = 0x2,</span><br class="calibre5"/><span class="calibre4"> CL_DB_PHISHING_URLS = 0x8,</span><br class="calibre5"/><span class="calibre4"> CL_DB_BYTECODE = 0x2000,</span><br class="calibre5"/><span class="calibre4"> ➊CL_DB_STDOPT = (CL_DB_PHISHING | CL_DB_PHISHING_URLS | CL_DB_BYTECODE),</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos715815" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-3: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ClamDatabaseOptions</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">enum that defines the ClamAV database options</span></span></p><p class="calibre_6">The <span class="calibre4">ClamDatabaseOptions</span> enum uses values taken directly from the ClamAV C source for the database options. The three options enable the signatures for phishing emails and for phishing URLs, as well as the dynamic bytecode signatures used in heuristic scanning. Combined, these three make up ClamAV’s standard database options, which are used to scan for viruses or malware. By using the bitwise OR operator to combine the three option values, we come up with a bitmask of the combined options we want to use defined in an enum ➊. Using <span class="italic">bitmasks</span> is a popular way of storing flags or options in a very efficient way.</p><p class="calibre_6">Another enum we must implement is the <span class="calibre4">ClamReturnCode</span> enum, which corresponds to known return codes from ClamAV and is shown in <a href="#filepos717397">Listing 10-4</a>. Again, these values were taken directly from the ClamAV source code.</p><blockquote class="calibre_14"><span class="calibre4">public enum ClamReturnCode</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4">➊CL_CLEAN = 0x0,</span><br class="calibre5"/><span class="calibre4">➋CL_SUCCESS = 0x0,</span><br class="calibre5"/><span class="calibre4">➌CL_VIRUS = 0x1</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos717397" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-4: An enumeration to store the ClamAV return codes we are interested in</span></span></p><p class="calibre_6">This isn’t a complete list of return codes by any means. I am only including the return codes I expect to see in the examples we’ll be writing. These are the clean ➊ and success ➋ codes, which indicate a scanned file had no viruses or that an action was successful, respectively, and the virus code ➌, which reports back that a virus was detected in a scanned file. If you run into any error codes not defined in the <span class="calibre4">ClamReturnCode</span> enum, you can look them up in the ClamAV source code in <span class="italic">clamav.h</span>. These codes are defined in the <span class="calibre4">cl_error_t</span> struct in the header file.</p><p class="calibre_6"> Our <span class="calibre4">ClamReturnCode</span> enum has three values, only two of which are distinct. Both <span class="calibre4">CL_CLEAN</span> and <span class="calibre4">CL_SUCCESS</span> share the same value of <span class="calibre4">0x0</span> because <span class="calibre4">0x0</span> means both that everything is running as expected and that a scanned file is clean. The other value, <span class="calibre4">0x1</span>, is returned when a virus is detected.</p><p class="calibre_6">The last enum we need to define is the <span class="calibre4">ClamScanOptions</span> enum, the most complicated of the enums we need. It’s shown in <a href="#filepos719807">Listing 10-5</a>.</p><blockquote class="calibre_14"><span class="calibre4">[Flags]</span><br class="calibre5"/><span class="calibre4">public enum ClamScanOptions</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> CL_SCAN_ARCHIVE = 0x1,</span><br class="calibre5"/><span class="calibre4"> CL_SCAN_MAIL = 0x2,</span><br class="calibre5"/><span class="calibre4"> CL_SCAN_OLE2 = 0x4,</span><br class="calibre5"/><span class="calibre4"> CL_SCAN_HTML = 0x10,</span><br class="calibre5"/><span class="calibre4"> ➊CL_SCAN_PE = 0x20,</span><br class="calibre5"/><span class="calibre4"> CL_SCAN_ALGORITHMIC = 0x200,</span><br class="calibre5"/><span class="calibre4"> ➋CL_SCAN_ELF = 0x2000,</span><br class="calibre5"/><span class="calibre4"> CL_SCAN_PDF = 0x4000,</span><br class="calibre5"/><span class="calibre4"> ➌CL_SCAN_STDOPT = (CL_SCAN_ARCHIVE | CL_SCAN_MAIL |</span><br class="calibre5"/><span class="calibre4"> CL_SCAN_OLE2 | CL_SCAN_PDF | CL_SCAN_HTML | CL_SCAN_PE |</span><br class="calibre5"/><span class="calibre4"> CL_SCAN_ALGORITHMIC | CL_SCAN_ELF)</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos719807" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-5: The class to hold the options for a ClamAV scan</span></span></p><p class="calibre_6">As you can see, <span class="calibre4">ClamScanOptions</span> looks like a more complex version of <span class="calibre4">ClamDatabaseOptions</span>. It defines a variety of file types that can be scanned (Windows PE executables ➊, Unix ELF executables ➋, PDFs, and so on) along with a set of standard options ➌. As with the previous enumerations, these enumeration values were taken directly from the ClamAV source code.</p><p class="calibre_10"><span class="calibre3"><span class="bold">The ClamResult Supporting Class</span></span></p><p class="calibre_11">Now we need only implement the <span class="calibre4">ClamResult</span> class, shown in <a href="#filepos721117">Listing 10-6</a>, to round out the support required to drive libclamav.</p><blockquote class="calibre_14"><span class="calibre4">public class ClamResult</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> public ➊ClamReturnCode ReturnCode { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string VirusName { get; set; }</span><br class="calibre5"/><span class="calibre4"> public string FullPath { get; set; }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos721117" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-6: The class that holds results of a ClamAV scan</span></span></p><p class="calibre_6">This one is super simple! The first property is a <span class="calibre4">ClamReturnCode</span> ➊ that stores the return code of a scan (which should usually be <span class="calibre4">CL_VIRUS</span>). We also have two string properties: one to hold the name of the virus ClamAV reports back and one to hold the path to the file if we need it later. We’ll use this class to store the results of each file scan as one object.</p><p id="filepos721709" class="calibre_10"><span class="calibre3"><span class="bold">
</span></span><span class="calibre3"><span class="italic"><span class="bold">Accessing ClamAV’s Native Library Functions</span></span></span></p><p class="calibre_11">In order to keep some separation of the native functions we’ll be consuming from libclamav and the rest of the C# code and classes, we define a single class that holds all the ClamAV functions we’ll use (see <a href="#filepos723716">Listing 10-7</a>).</p><blockquote class="calibre_14"><span class="calibre4">static class ClamBindings</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> const string ➊_clamLibPath = "/Users/bperry/clamav/libclamav/.libs/libclamav.7.dylib";</span><br class="calibre5"/><span class="calibre4"> [➋DllImport(_clamLibPath)]</span><br class="calibre5"/><span class="calibre4"> public extern static ➌ClamReturnCode cl_init(uint options);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport(_clamLibPath)]</span><br class="calibre5"/><span class="calibre4"> public extern static IntPtr cl_engine_new();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport(_clamLibPath)]</span><br class="calibre5"/><span class="calibre4"> public extern static ClamReturnCode cl_engine_free(IntPtr engine);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport(_clamLibPath)]</span><br class="calibre5"/><span class="calibre4"> public extern static IntPtr cl_retdbdir();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport(_clamLibPath)]</span><br class="calibre5"/><span class="calibre4"> public extern static ClamReturnCode cl_load(string path, IntPtr engine,</span><br class="calibre5"/><span class="calibre4"> ref uint signo, uint options);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport(_clamLibPath)]</span><br class="calibre5"/><span class="calibre4"> public extern static ClamReturnCode cl_scanfile(string path, ref IntPtr virusName,</span><br class="calibre5"/><span class="calibre4"> ref ulong scanned, IntPtr engine, uint options);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> [DllImport(_clamLibPath)]</span><br class="calibre5"/><span class="calibre4"> public extern static ClamReturnCode cl_engine_compile(IntPtr engine);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos723716" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-7: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ClamBindings</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class, which holds all the ClamAV functions</span></span></p><p class="calibre_6">The <span class="calibre4">ClamBindings</span> class first defines a string that is the full path ➊ to the ClamAV library we’ll be interfacing with. In this example, I am pointing to an OS X <span class="italic">.dylib</span> that I compiled from source to match the architecture of my Mono installation. Depending on how you compiled or installed ClamAV, the path to the native ClamAV library may differ on your system. On Windows, the file will be a <span class="italic">.dll</span> file in the /<span class="italic">Program Files</span> directory if you used the ClamAV installer. On OS X, it will be a <span class="italic">.dylib</span> file, and on Linux it will be a <span class="italic">.so</span> file. On the latter systems, you could use <span class="calibre4">find</span> to locate the correct library.</p><p class="calibre_6">On Linux, something like this would print the path to any libclamav libraries: $ <span class="bold">find / -name libclamav*so$</span></p><p class="calibre_6">On OS X, use this: $ <span class="bold">find / -name libclamav*dylib$</span></p><p class="calibre_6"> The <span class="calibre4">DllImport</span> attribute ➋ tells the Mono/.NET runtime to look for the given function in the library we specified in the argument. This way, we are able to directly call on ClamAV functions inside our program. We’ll cover what the functions shown in <a href="#filepos723716">Listing 10-7</a> do when we implement the <span class="calibre4">ClamEngine</span> class next. You can also see that we’re already using the <span class="calibre4">ClamReturnCode</span> class ➌, which is returned when some of ClamAV’s native functions are called.</p><p id="filepos725576" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Compiling the ClamAV Engine</span></span></span></p><p class="calibre_11">The <span class="calibre4">ClamEngine</span> class in <a href="#filepos727882">Listing 10-8</a> will do most of the real work of scanning and reporting on potentially malicious files.</p><blockquote class="calibre_14"><span class="calibre4">public class ClamEngine : IDisposable</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private ➊IntPtr engine;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public ➋ClamEngine()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ClamReturnCode ret = ClamBindings.➌cl_init((uint)ClamDatabaseOptions.CL_DB_STDOPT);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (ret != ClamReturnCode.CL_SUCCESS)</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Expected CL_SUCCESS, got " + ret);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> engine = ClamBindings.➍cl_engine_new();</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> try</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string ➎dbDir = Marshal.PtrToStringAnsi(ClamBindings.cl_retdbdir());</span><br class="calibre5"/><span class="calibre4"> uint ➏signatureCount = 0;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ret = ClamBindings.➐cl_load(dbDir, engine, ref signatureCount,</span><br class="calibre5"/><span class="calibre4"> (uint)ClamScanOptions.CL_SCAN_STDOPT);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (ret != ClamReturnCode.CL_SUCCESS)</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Expected CL_SUCCESS, got " + ret);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ret = (ClamReturnCode)ClamBindings.➑cl_engine_compile(engine);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (ret != ClamReturnCode.CL_SUCCESS)</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Expected CL_SUCCESS, got " + ret);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> catch</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ret = ClamBindings.cl_engine_free(engine);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (ret != ClamReturnCode.CL_SUCCESS)</span><br class="calibre5"/><span class="calibre4"> Console.Error.WriteLine("Freeing allocated engine failed");</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> throw;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span></blockquote><p id="filepos727882" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-8: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ClamEngine</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">class, which scans and reports on files</span></span></p><p class="calibre_6"> First, we declare a class-level <span class="calibre4">IntPtr</span> variable ➊, called <span class="calibre4">engine</span>, which will point to our ClamAV engine for the other methods in the class to use. Although C# doesn’t need a pointer to reference the exact address of an object in memory, C does. C has pointers that are of the <span class="calibre4">intptr_t</span> data type, and <span class="calibre4">IntPtr</span> is the C# version of a C pointer. Since the ClamAV engine will be passed back and forth between .NET and C, we need a pointer to refer to the address in memory where it is stored when we pass it to C. This is what happens when we create <span class="calibre4">engine</span>, which we’ll assign a value inside the constructor.</p><p class="calibre_6">Next, we define the constructor. The constructor for the <span class="calibre4">ClamEngine</span> class ➋ doesn’t require any arguments. To initialize ClamAV to begin allocating engines to scan with, we call <span class="calibre4">cl_init()</span> ➌ from the <span class="calibre4">ClamBindings</span> class by passing the signature database options we want to use when loading the signatures. Just in case ClamAV doesn’t initialize, we check the return code of <span class="calibre4">cl_init()</span> and throw an exception if initialization failed. If ClamAV initializes successfully, we allocate a new engine with <span class="calibre4">cl_engine_new()</span> ➍, which takes no arguments and returns the pointer to the new ClamAV engine that we store in the <span class="calibre4">engine</span> variable for later use.</p><p class="calibre_6">Once we have an engine allocated, we need to load the antivirus signatures to scan with. The <span class="calibre4">cl_retdbdir()</span> function returns the path to the definition database ClamAV is configured to use and stores it in the <span class="calibre4">dbDir</span> variable ➎. Because <span class="calibre4">cl_retdbdir()</span> returns a C pointer string, we convert it to a regular string by using the function <span class="calibre4">PtrToStringAnsi()</span> on the <span class="calibre4">Marshal</span> class, a class used to convert data types from managed types to unmanaged (and vice versa). Once we store the database path, we define an integer, <span class="calibre4">signatureCount</span> ➏, which is passed to <span class="calibre4">cl_load()</span> and assigned the number of signatures that were loaded from the database.</p><p class="calibre_6">We use <span class="calibre4">cl_load()</span> ➐ from the <span class="calibre4">ClamBindings</span> class to load the signature database into the engine. We pass the ClamAV database directory <span class="calibre4">dbDir</span> and the new <span class="calibre4">engine</span> as arguments, along with a few other values. The last argument passed to <span class="calibre4">cl_load()</span> is an enumeration value for the types of files we want to support scanning (such as HTML, PDF, or other specific types of files). We use the class we created earlier, <span class="calibre4">ClamScanOptions</span>, to define our scan options as <span class="calibre4">CL_SCAN_STDOPT</span> so that we use the standard scan options. After we have loaded the virus database (which can take several seconds, depending on the options), we check whether the return code is equal to <span class="calibre4">CL_SUCCESS</span> again; if it is, we finally compile the engine by passing it to the <span class="calibre4">cl_engine_ compile()</span> function ➑, which prepares the engine to begin scanning files. Then we check whether we received a <span class="calibre4">CL_SUCCESS</span> return code one last time.</p><p id="filepos731728" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Scanning Files</span></span></span></p><p class="calibre_11">In order to scan files easily, we’ll wrap <span class="calibre4">cl_scanfile()</span> (the ClamAV library function that scans a file and reports back the result) with our own method, which we’ll call <span class="calibre4">ScanFile()</span>. This allows us to prepare the arguments we need to pass to <span class="calibre4">cl_scanfile()</span> and allows us to process and return the results from ClamAV as one <span class="calibre4">ClamResult</span> object. This is shown in <a href="#filepos733721">Listing 10-9</a>.</p><blockquote class="calibre_14"><span class="calibre4"> public ClamResult ScanFile(string filepath, uint options = (uint)ClamScanOptions.➊CL_SCAN_STDOPT)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ➋ulong scanned = 0;</span><br class="calibre5"/><span class="calibre4"> ➌IntPtr vname = (IntPtr)null;</span><br class="calibre5"/><span class="calibre4"> ClamReturnCode ret = ClamBindings.➍cl_scanfile(filepath, ref vname, ref scanned,</span><br class="calibre5"/><span class="calibre4"> engine, options);</span><br class="calibre5"/><span class="calibre4"> if (ret == ClamReturnCode.CL_VIRUS)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string virus = Marshal.➎PtrToStringAnsi(vname);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➏ClamResult result = new ClamResult();</span><br class="calibre5"/><span class="calibre4"> result.ReturnCode = ret;</span><br class="calibre5"/><span class="calibre4"> result.VirusName = virus;</span><br class="calibre5"/><span class="calibre4"> result.FullPath = filepath;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> return result;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> else if (ret == ClamReturnCode.CL_CLEAN)</span><br class="calibre5"/><span class="calibre4"> return new ClamResult() { ReturnCode = ret, FullPath = filepath };</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> throw new Exception("Expected either CL_CLEAN or CL_VIRUS, got: " + ret);</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos733721" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-9: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ScanFile()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, which scans and returns a</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">ClamResult</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">object</span></span></p><p class="calibre_6">The <span class="calibre4">ScanFile()</span> method we implement takes two arguments, but we only need the first, which is the path of the file to scan. The user can define scan options with the second argument, but if a second argument isn’t specified, then the standard scan options ➊ we defined in <span class="calibre4">ClamScanOptions</span> will be used to scan the file.</p><p class="calibre_6">We start the <span class="calibre4">ScanFile()</span> method by defining some variables to use. The <span class="calibre4">scanned ulong</span> type variable is initially set to <span class="calibre4">0</span> ➋. We won’t actually use this variable after scanning the file, but the <span class="calibre4">cl_scanfile()</span> function requires it in order to be called correctly. The next variable we define is another <span class="calibre4">IntPtr</span>, which we call <span class="calibre4">vname</span> (for <span class="italic">virus name</span>) ➌. We set this initially to be null, but we’ll later assign a C string pointer to it that points to a virus name in the ClamAV database whenever a virus is found.</p><p class="calibre_6">We use the <span class="calibre4">cl_scanfile()</span> function ➍ we defined in <span class="calibre4">ClamBindings</span> to scan the file and pass it a handful of arguments. The first argument is the file path we want to scan, followed by the variable that will be assigned the name of the detected virus, if any. The last two arguments are the engine we will be scanning with and the scan options we want use to perform the virus scan. The middle argument, <span class="calibre4">scanned</span>, is required to call <span class="calibre4">cl_scanfile()</span> but isn’t useful for us here. We won’t use it again after passing it as an argument to this function.</p><p class="calibre_6">The rest of the method packages the scan information nicely for the programmer’s use. If the return code of <span class="calibre4">cl_scanfile()</span> indicates a virus was found, we use <span class="calibre4">PtrToStringAnsi()</span> ➎ to return the string that the <span class="calibre4">vname</span> variable points to in memory. Once we have the virus name, we create a new <span class="calibre4">ClamResult</span> class ➏ and assign it three properties using the <span class="calibre4">cl_scanfile()</span> return code, the virus name, and the path to the scanned file. Then, we return the <span class="calibre4">ClamResult</span> class to the caller. If the return code is <span class="calibre4">CL_CLEAN</span>, we return a new <span class="calibre4">ClamResult</span> class with a <span class="calibre4">ReturnCode</span> of <span class="calibre4">CL_CLEAN</span>. If it is neither <span class="calibre4">CL_CLEAN</span> nor <span class="calibre4">CL_VIRUS</span>, however, we throw an exception because we got a return code we didn’t expect.</p><p id="filepos736890" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Cleaning Up</span></span></span></p><p class="calibre_11">The last method left to implement in the <span class="calibre4">ClamEngine</span> class is <span class="calibre4">Dispose()</span>, shown in <a href="#filepos737830">Listing 10-10</a>, which automatically cleans up after a scan in the context of a <span class="calibre4">using</span> statement and is required by the <span class="calibre4">IDisposable</span> interface.</p><blockquote class="calibre_14"><span class="calibre4"> public void Dispose()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ClamReturnCode ret = ClamBindings.➊cl_engine_free(engine);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (ret != ClamReturnCode.CL_SUCCESS)</span><br class="calibre5"/><span class="calibre4"> Console.Error.WriteLine("Freeing allocated engine failed");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos737830" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-10: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Dispose()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method, which automatically cleans up engines</span></span></p><p class="calibre_6">We implement the <span class="calibre4">Dispose()</span> method because if we don’t free our ClamAV engine when we are done with it, it could become a memory leak. One drawback of working with C libraries from a language like C# is that, because C# has garbage collection, many programmers don’t actively think about cleaning up after themselves. However, C does not have garbage collection. If we allocate something in C, we need to free it when we are done with it. This is what the <span class="calibre4">cl_engine_free()</span> function ➊ does. To be diligent, we’ll also check to make sure that the engine was successfully freed by comparing the return code to <span class="calibre4">CL_SUCCESS</span>. If they are the same, all is good. Otherwise, we throw an exception because we should be able to free an engine we allocated, and if we can’t, this may point to a problem in the code.</p><p id="filepos739005" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Testing the Program by Scanning the EICAR File</span></span></span></p><p class="calibre_11">Now we can bring it all together to scan something to test out our bindings. The EICAR file is an industry-recognized text file used to test antivirus products. It isn’t harmful, but any functioning antivirus product should detect it as a virus, so we’ll use it to test our program. In <a href="#filepos739889">Listing 10-11</a>, we use the Unix <span class="calibre4">cat</span> command to print the contents of a test file used specifically for testing antivirus—the EICAR file.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">cat ~/eicar.com.txt</span></span><br class="calibre5"/><span class="calibre4">X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*</span></blockquote><p id="filepos739889" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-11: Printing the contents of the EICAR antivirus test file</span></span></p><p class="calibre_6">The short program in <a href="#filepos741124">Listing 10-12</a> will scan any files specified as arguments and print the results.</p><blockquote class="calibre_14"><span class="calibre4"> public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> using (➊ClamEngine e = new ClamEngine())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> foreach (string file in args)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> ClamResult result = e.➋ScanFile(file); //pretty simple!</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> if (result != null &amp;&amp; result.ReturnCode == ClamReturnCode.➌CL_VIRUS)</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("Found: " + result.VirusName);</span><br class="calibre5"/><span class="calibre4"> else</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine("File Clean!");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> } //engine is disposed of here and the allocated engine freed automatically</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos741124" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-12: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method of our program to automate ClamAV</span></span></p><p class="calibre_6">We begin by creating our <span class="calibre4">ClamEngine</span> class ➊ in the context of a <span class="calibre4">using</span> statement so that we automatically clean up the engine when we are finished. We then iterate over each argument passed to <span class="calibre4">Main()</span> and assume it is a file path that we can scan with ClamAV. We pass each file path to the <span class="calibre4">ScanFile()</span> method ➋ and then check the result returned by <span class="calibre4">ScanFile()</span> to see if ClamAV has returned the <span class="calibre4">CL_VIRUS</span> return code ➌. If so, we print the virus name to the screen, as shown in <a href="#filepos742346">Listing 10-13</a>. Otherwise, we print the text <span class="calibre4">File Clean!</span></p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">mono ./ch10_automating_clamav_fs.exe ~/eicar.com.txt</span></span><br class="calibre5"/><span class="calibre4">➊ Found: Eicar-Test-Signature </span><a id="filepos742346"/><span class="calibre4"><span class="italic">Listing 10-13: Running our ClamAV program on the EICAR file results in a virus identification.</span></span></blockquote><p class="calibre_6">If the program prints <span class="calibre4">Found: Eicar-Test-Signature</span> ➊, then it works! This means that ClamAV scanned the EICAR file, matched it against the EICAR definition it has in its database, and returned the virus name for us. A great exercise for expanding this program would be to use a <span class="calibre4">FileWatcher</span> class that allows you to define directories to watch for any changes and then automatically scans the files that are changed or created in those folders.</p><p class="calibre_6">We now have a working program that scans files with ClamAV. However, there may be instances when you can’t effectively ship ClamAV with the application due to licensing (ClamAV is licensed with the GNU Public License) or technical reasons, but you still need a way to scan files for viruses on your network. We’ll go over one other method to automate ClamAV that will solve this problem in a more centralized way.</p><p id="filepos743490" class="calibre_10"><span class="calibre3"><span class="bold">Automating with clamd</span></span></p><p class="calibre_11">The <span class="calibre4">clamd</span> daemon provides a great way to add virus scanning to an application that accepts file uploads from users or something similar. It operates over the TCP, but with no SSL by default! It is also very lightweight, but it has to be run on a server on your network, which results in some limitations. The <span class="calibre4">clamd</span> service allows you to have a long-lived process running for scanning files instead of needing to manage and allocate the ClamAV engine as in the previous automation. Because it’s a server version of ClamAV, you can use <span class="calibre4">clamd</span> to scan files for computers without even installing the application. This can be convenient when you only want to manage virus definitions in one place or you have resource limitations and want to offload the virus scanning to another machine, as discussed earlier. Getting automation working for <span class="calibre4">clamd</span> is exceedingly simple in C#. It requires two small classes: a session and a manager.</p><p id="filepos744650" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Installing the clamd Daemon</span></span></span></p><p class="calibre_11">On most platforms, installing ClamAV from the package manager might not install the <span class="calibre4">clamd</span> daemon. For instance, on Ubuntu, you will need to install the <span class="calibre4">clamav-daemon</span> package separately with <span class="calibre4">apt</span>, as shown here: $ <span class="bold">sudo apt-get install clamav-daemon</span> On Red Hat or Fedora, you’d install a slightly different package name: $ <span class="bold">sudo yum install clamav-server</span></p><p id="filepos745238" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Starting the clamd Daemon</span></span></span></p><p class="calibre_11">To use <span class="calibre4">clamd</span> after installing the daemon, you need to start the daemon, which listens on port 3310 and address 127.0.0.1 by default. You can do this with the <span class="calibre4">clamd</span> command, as shown in <a href="#filepos745792">Listing 10-14</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">clamd</span></span><span class="calibre4">
</span><a id="filepos745792"/><span class="calibre4"><span class="italic">Listing 10-14: Starting the clamd daemon</span></span></blockquote><p class="calibre_16"><span class="calibre3"><span class="bold"><span class="calibre_17"><span class="calibre_18">  NOTE </span></span></span></span></p><blockquote class="calibre_7"><span class="italic">If you install</span>
<span class="calibre4"><span class="italic">clamd</span></span>
<span class="italic">with a package manager, it may be configured by default to listen on a local UNIX socket rather than on a network interface. If you are having trouble connecting to the</span>
<span class="calibre4"><span class="italic">clamd</span></span>
<span class="italic">daemon using a TCP socket, make sure that</span>
<span class="calibre4"><span class="italic">clamd</span></span>
<span class="italic">is configured to listen on a network interface!</span></blockquote><p class="calibre_6">You may not get any feedback when you run the command. No news is good news! If <span class="calibre4">clamd</span> starts with no messages, then you have successfully started it. We can test whether <span class="calibre4">clamd</span> is running properly with <span class="calibre4">netcat</span> by connecting to the listening port and seeing what happens when we manually run commands on it, such as by getting the current <span class="calibre4">clamd</span> version and scanning a file, as in <a href="#filepos747467">Listing 10-15</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">echo VERSION | nc -v 127.0.0.1 3310</span></span><br class="calibre5"/><span class="calibre4">ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015</span><br class="calibre5"/><span class="calibre4"> $ </span><span class="calibre4"><span class="bold">echo "SCAN /tmp/eicar.com.txt" | nc -v 127.0.0.1 3310</span></span><br class="calibre5"/><span class="calibre4">/tmp/eicar.com.txt: Eicar-Test-Signature FOUND</span></blockquote><p id="filepos747467" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-15: Running simple commands for</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">clamd</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">using the</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">netcat</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">TCP utility</span></span></p><p class="calibre_6">Connecting to <span class="calibre4">clamd</span> and sending the <span class="calibre4">VERSION</span> command should print the ClamAV version. You can also send the <span class="calibre4">SCAN</span> command with a file path as the argument, and it should return the scan results. Writing code to automate this is easy.</p><p id="filepos748167" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating a Session Class for clamd</span></span></span></p><p class="calibre_11">The <span class="calibre4">ClamdSession</span> class requires almost no deep dive into how the code in the class works because it’s so simple. We create some properties to hold the host and port that <span class="calibre4">clamd</span> runs on, an <span class="calibre4">Execute()</span> method that takes a <span class="calibre4">clamd()</span> command and executes it, and a <span class="calibre4">TcpClient</span> class to create a new TCP stream to write the commands to, as shown in <a href="#filepos750465">Listing 10-16</a>. The <span class="calibre4">TcpClient</span> class was first introduced in <a href="index_split_009.html#filepos344540">Chapter 4</a> when we built custom payloads. We also used it in <a href="index_split_012.html#filepos509064">Chapter 7</a> when we automated the OpenVAS vulnerability scanner.</p><blockquote class="calibre_14"><span class="calibre4">public class ClamdSession</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private string _host = null;</span><br class="calibre5"/><span class="calibre4"> private int _port;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public ➊ClamdSession(string host, int port)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _host = host;</span><br class="calibre5"/><span class="calibre4"> _port = port;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string ➋Execute(string command)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> string resp = string.Empty;</span><br class="calibre5"/><span class="calibre4"> using (➌TcpClient client = new TcpClient(_host, _port))</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> using (NetworkStream stream = client.➍GetStream())</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> byte[] data = System.Text.Encoding.ASCII.GetBytes(command);</span><br class="calibre5"/><span class="calibre4"> stream.➎Write(data, 0, data.Length);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➏using (StreamReader rdr = new StreamReader(stream))</span><br class="calibre5"/><span class="calibre4"> resp = rdr.ReadToEnd();</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➐return resp;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos750465" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-16: The class to create a new</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">clamd</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">session</span></span></p><p class="calibre_6"> The <span class="calibre4">ClamdSession</span> constructor ➊ takes two arguments—the host and the port to connect to—and then assigns those to local class variables for the <span class="calibre4">Execute()</span> method to use. In the past, all of our session classes have implemented the <span class="calibre4">IDisposable</span> interface, but we really don’t need to do that with the <span class="calibre4">ClamdSession</span> class. We don’t need to clean anything up when we are done because <span class="calibre4">clamd</span> is a daemon that runs on a port and is a background process that can continue to run, so this saves us a bit of complexity.</p><p class="calibre_6">The <span class="calibre4">Execute()</span> method ➋ takes a single argument: the command to run on the <span class="calibre4">clamd</span> instance. Our <span class="calibre4">ClamdManager</span> class will only implement a few of the possible <span class="calibre4">clamd</span> commands available, so you should find researching the <span class="calibre4">clamd</span> protocol commands highly useful to see what other powerful commands are available to automate. To get the commands running and start reading the <span class="calibre4">clamd</span> response, we first create a new <span class="calibre4">TcpClient</span> class ➌ that uses the host and passes the port to the constructor as the <span class="calibre4">TcpClient</span> arguments. We then call <span class="calibre4">GetStream()</span> ➍ to make a connection to the <span class="calibre4">clamd</span> instance that we can write our command to. Using the <span class="calibre4">Write()</span> method ➎, we write our command to the stream and then create a new <span class="calibre4">StreamReader</span> class to read the response ➏. Finally, we return the response to the caller ➐.</p><p id="filepos752483" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Creating a clamd Manager Class</span></span></span></p><p class="calibre_11">The simplicity of the <span class="calibre4">ClamdSession</span> class, which we define in <a href="#filepos753845">Listing 10-17</a>, makes the <span class="calibre4">ClamdManager</span> class super simple as well. It just creates a constructor and two methods to execute the commands from <a href="#filepos747467">Listing 10-15</a> that we had executed manually.</p><blockquote class="calibre_14"><span class="calibre4">public class ClamdManager</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> private ClamdSession _session = null;</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public ➊ClamdManager(ClamdSession session)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> _session = session;</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string ➋GetVersion()</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("VERSION");</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> public string ➌Scan(string path)</span><br class="calibre5"/><span class="calibre4"> {</span><br class="calibre5"/><span class="calibre4"> return _session.Execute("SCAN " + path);</span><br class="calibre5"/><span class="calibre4"> }</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos753845" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-17: The manager class for</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">clamd</span></span></p><p class="calibre_6">The <span class="calibre4">ClamdManager</span> constructor ➊ takes a single argument—the session that will be executing the commands—and assigns it to a local class variable called <span class="calibre4">_session</span> that the other methods can use.</p><p class="calibre_6"> The first method we create is the <span class="calibre4">GetVersion()</span> method ➋, which executes the <span class="calibre4">clamd VERSION</span> command by passing the string <span class="calibre4">VERSION</span> to <span class="calibre4">Execute()</span>, which we defined in the <span class="calibre4">clamd</span> session class. This command returns the version information to the caller. The second method, <span class="calibre4">Scan()</span> ➌, takes a file path as the argument, which it passes to <span class="calibre4">Execute()</span> with the <span class="calibre4">clamd SCAN</span> command. Now that we have both the session and manager classes, we can stick everything together.</p><p id="filepos754987" class="calibre_10"><span class="calibre3"><span class="italic"><span class="bold">Testing with clamd</span></span></span></p><p class="calibre_11">Putting everything together takes only a handful of lines of code for a <span class="calibre4">Main()</span> method, as shown in <a href="#filepos755884">Listing 10-18</a>.</p><blockquote class="calibre_14"><span class="calibre4">public static void Main(string[] args)</span><br class="calibre5"/><span class="calibre4">{</span><br class="calibre5"/><span class="calibre4"> ClamdSession session = new ➊ClamdSession("127.0.0.1", 3310);</span><br class="calibre5"/><span class="calibre4"> ClamdManager manager = new ClamdManager(session);</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> Console.WriteLine(manager.➋GetVersion());</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4"> ➌foreach (string path in args)</span><br class="calibre5"/><span class="calibre4"> Console.WriteLine(manager.Scan(path));</span><br class="calibre5"/><span class="calibre4">}</span></blockquote><p id="filepos755884" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-18: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">Main()</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">method to automate</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">clamd</span></span></p><p class="calibre_6">We create the <span class="calibre4">ClamdSession()</span> ➊ by passing <span class="calibre4">127.0.0.1</span> as the host to connect to and <span class="calibre4">3310</span> as the port on the host. Then we pass the new <span class="calibre4">ClamdSession</span> to the <span class="calibre4">ClamdManager</span> constructor. With a new <span class="calibre4">ClamdManager()</span>, we can print the version ➋ of the <span class="calibre4">clamd</span> instance; then we loop over ➌ each argument passed to the program and try to scan the file and print the results to the screen for the user. In our case, we will only test against one file, the EICAR test file. However, you could put as many files to scan as your command shell allows.</p><p class="calibre_6">The file we will scan needs to be on the server running the <span class="calibre4">clamd</span> daemon, so in order make this work across the network, you need a way to send the file to the server in a place <span class="calibre4">clamd</span> can read it. This could be a remote network share or other way of getting the file to the server. In this example, we have <span class="calibre4">clamd</span> listening on 127.0.0.1 (localhost), and it has scanning access to my home directory on my Mac, which is demonstrated in <a href="#filepos757812">Listing 10-19</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">./ch10_automating_clamav_clamd.exe ~/eicar.com.txt</span></span><br class="calibre5"/><span class="calibre4">ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015</span><br class="calibre5"/><span class="calibre4">/Users/bperry/eicar.com.txt: Eicar-Test-Signature FOUND</span></blockquote><p id="filepos757812" class="calibre_15"><span class="calibre4"><span class="italic">Listing 10-19: The</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">clamd</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">automating program scanning the hard-coded EICAR file</span></span></p><p class="calibre_6">You’ll notice that using <span class="calibre4">clamd</span> is much faster than using the libclamav automation. This is because a bulk of the time spent in the libclamav program was dedicated to allocating and compiling the engine, rather than actually scanning our file. The <span class="calibre4">clamd</span> daemon only has to allocate the engine once at startup; therefore, when we submit our file to be scanned, the results are much, much faster. We can test this by running the applications with the <span class="calibre4">time</span> command, which will print the time it takes for the programs to run, as shown in <a href="#filepos759534">Listing 10-20</a>.</p><blockquote class="calibre_14"><span class="calibre4">$ </span><span class="calibre4"><span class="bold">time ./ch10_automating_clamav_fs.exe ~/eicar.com.txt</span></span><br class="calibre5"/><span class="calibre4">Found: Eicar-Test-Signature</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">real ➊0m11.872s</span><br class="calibre5"/><span class="calibre4">user 0m11.508s</span><br class="calibre5"/><span class="calibre4">sys 0m0.254s</span><br class="calibre5"/><span class="calibre4">$ </span><span class="calibre4"><span class="bold">time ./ch10_automating_clamav_clamd.exe ~/eicar.com.txt</span></span><br class="calibre5"/><span class="calibre4">ClamAV 0.99/20563/Thu Jun 11 15:05:30 2015</span><br class="calibre5"/><span class="calibre4">/Users/bperry/eicar.com.txt: Eicar-Test-Signature FOUND</span><br class="calibre5"/><br class="calibre5"/><span class="calibre4">real ➋0m0.111s</span><br class="calibre5"/><span class="calibre4">user 0m0.087s</span><br class="calibre5"/><span class="calibre4">sys 0m0.011s </span><a id="filepos759534"/><span class="calibre4"><span class="italic">Listing 10-20: A comparison of the time it took for the ClamAV and</span></span><span class="calibre4">
</span><span class="calibre7"><span class="italic">clamd</span></span><span class="calibre4">
</span><span class="calibre4"><span class="italic">applications to scan the same file</span></span></blockquote><p class="calibre_6">Notice that our first program took 11 seconds ➊ to scan the EICAR test file but the second program using <span class="calibre4">clamd</span> took less than a second ➋.</p><p id="filepos760003" class="calibre_10"><span class="calibre3"><span class="bold">Conclusion</span></span></p><p class="calibre_11">ClamAV is a powerful and flexible antivirus solution for home and office use. In this chapter, we were able to drive ClamAV in two distinct ways.</p><p class="calibre_6">First, we implemented some small bindings for the native libclamav library. This allowed us to allocate, scan with, and free our ClamAV engines at will, but at the cost of needing to ship a copy of libclamav and allocate an expensive engine each time we ran our program. We then implemented two classes that allowed us to drive a remote <span class="calibre4">clamd</span> instance to retrieve ClamAV version information and to scan a given file path on the <span class="calibre4">clamd</span> server. This effectively gave our program a nice speed boost, but at the cost of requiring that the file to be scanned be on the server running <span class="calibre4">clamd</span>.</p><p class="calibre_6">The ClamAV project is a great example of a large company (Cisco) really supporting open source software that benefits everyone. You’ll find that extending these bindings to better protect and defend your applications, users, and network is a great exercise.</p><div class="mbp_pagebreak" id="calibre_pb_15"/>
</body></html>