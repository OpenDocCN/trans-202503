["```\n  0a04b0d1 e8 01 00 00 00 CALL➊ FUN_0a04b0d7\n\n  0a04b0d6 c7             ??     C7h➋\n\n       ************************************************************\n\n       *                         FUNCTION                         *\n\n       ************************************************************\n\n       undefined FUN_0a04b0d7()\n\n          undefined AL:1 <RETURN>\n\n       FUN_0a04b0d7                           XREF[1]: FUN_0a04b0c4:0a04b0d1(c)\n\n  0a04b0d7 58             POP➌  EAX\n\n  0a04b0d8 8d 40 0a       LEA➍  EAX,[EAX + 0xa]\n\n          LAB_0a04b0db+1                      XREF[0,1]: 0a04b0db(j)\n\n➎ 0a04b0db eb ff          JMP   LAB_0a04b0db+1\n\n  0a04b0dd e0             ??➏   E0h\n```", "```\n          LAB_0a04b0db+1                       XREF[0,1]:   0a04b0db(j)\n\n➊ 0a04b0db eb ff    JMP    LAB_0a04b0db+1\n\n  0a04b0dd e0        ??     E0h\n```", "```\n  0a04b0db eb        ??     EBh\n\n➊ 0a04b0dc ff       ??     FFh\n\n  0a04b0dd e0        ??     E0h\n```", "```\n➊ 0a04b0dc ff e0    JMP    EAX\n\n  0a04b0de 90        ??     90h\n\n  0a04b0df c7        ??     C7h\n```", "```\n0a04b0d7 58        POP    EAX\n\n0a04b0d8 8d 40 0a  LEA    EAX,[EAX + 0xa]\n\n                      -- Fallthrough Override: 0a04b0dc\n\n0a04b0db eb        ??     EBh\n\n            assume EAX = 0xa04b0e0\n\n        LAB_0a04b0dc                         XREF[1]:     0a04b0d8  \n\n0a04b0dc ff e0     JMP    EAX=>LAB_0a04b0e0\n\n            assume EAX = <UNKNOWN>\n\n0a04b0de 90        ??     90h\n\n0a04b0df c7        ??     C7h\n\n LAB_0a04b0e0                         XREF[1]:     0a04b0dc(j)  \n\n0a04b0e0 58        POP    EAX 0a04b0e0 POP EAX\n```", "```\n  00401000  XOR➊  EAX,EAX\n\n  00401002  JZ➋   LAB_00401009+1\n\n  00401004  MOV    EBX,dword ptr [EAX]\n\n  00401006  MOV    dword ptr [param_1 + -0x4],EBX\n\n       ➌ LAB_00401009+1                       XREF[0,1]: 00401002(j)\n\n➍ 00401009  CALL   SUB_adfeffc6\n\n  0040100e  FICOM  word ptr [EAX + 0x59]\n```", "```\n  00401000  XOR    EAX,EAX\n\n  00401002  JZ     LAB_0040100a\n\n  00401004  MOV    EBX,dword ptr [EAX]\n\n  00401006  MOV    dword ptr [param_1 + -0x4],EBX\n\n➊ 00401009  ??    E8h\n\n          LAB_0040100a                         XREF[1]: 00401002(j)\n\n➋ 0040100a  MOV    EAX,0xdeadbeef\n\n  0040100f  PUSH   EAX\n\n  00401010  POP    param_1\n```", "```\n  0a04b3be  MOV    ECX,0x7f131760              ; ECX = 7F131760\n\n  0a04b3c3  XOR    EDI,EDI                     ; EDI = 00000000\n\n  0a04b3c5  MOV    DI,0x1156                   ; EDI = 00001156\n\n  0a04b3c9  ADD    EDI,0x133ac000              ; EDI = 133AD156\n\n  0a04b3cf  XOR    ECX,EDI                     ; ECX = 6C29C636\n\n  0a04b3d1  SUB    ECX,0x622545ce              ; ECX = 0A048068\n\n  0a04b3d7  MOV    EDI,ECX                     ; EDI = 0A048068\n\n  0a04b3d9  POP    EAX\n\n  0a04b3da  POP    ESI\n\n  0a04b3db  POP    EBX\n\n  0a04b3dc  POP    EDX\n\n  0a04b3dd  POP    ECX\n\n➊ 0a04b3de  XCHG   dword ptr [ESP],EDI         ; TOS =   0A048068\n\n  0a04b3e1  RET                                ; return to 0A048068\n```", "```\n➊ 0041d07a  CALL   LAB_0041d07f\n\n          LAB_0041d07f                         XREF[1]: 0041d07a(j)\n\n➋ 0041d07f  POP    EBP\n\n➌ 0041d080  LEA    EAX,[EBP + 0x46]\n\n➍ 0041d083  PUSH   EAX\n\n  0041d084  XOR    EAX,EAX\n\n➎ 0041d086  PUSH   dword ptr FS:[EAX]\n\n➏ 0041d089  MOV    dword ptr FS:[EAX],ESP\n\n➐ 0041d08c  INT    3\n\n  0041d08d  NOP\n\n  0041d08e  MOV    EAX,EAX\n\n  0041d090  STC\n\n  0041d091  NOP\n\n  0041d092  LEA    EAX,[EBX*0x2 + 0x1234]\n\n  0041d099  CLC\n\n  0041d09a  NOP\n\n  0041d09b  SHR    EBX,0x5\n\n  0041d09e  CLD\n\n  0041d09f  NOP\n\n  0041d0a0  ROL    EAX,0x7\n\n  0041d0a3  NOP\n\n  0041d0a4  NOP\n\n➑ 0041d0a5  XOR    EBX,EBX\n\n➒ 0041d0a7  DIV    EBX\n\n  0041d0a9  POP    dword ptr FS:[0x0]\n```", "```\nint FUN_0041d0c5(EXCEPTION_RECORD *param_1,void *frame,➊CONTEXT *ctx) {\n\n  DWORD code;\n\n➋ ctx->Eip = ctx->Eip + 1;\n\n➌ code = param_1->ExceptionCode;\n\n➍ if (code == EXCEPTION_INT_DIVIDE_BY_ZERO) {\n\n    ctx->Eip = ctx->Eip + 1;\n\n  ➎ ctx->Dr0 = 0;\n\n    ctx->Dr1 = 0;\n\n    ctx->Dr2 = 0;\n\n    ctx->Dr3 = 0;\n\n    ctx->Dr6 = ctx->Dr6 & 0xffff0ff0;\n\n    ctx->Dr7 = ctx->Dr7 & 0xdc00;\n\n  }\n```", "```\n  This file is packed with the UPX executable packer http://upx.tsx.org\n\n  UPX 1.07 Copyright (C) 1996-2001 the UPX Team. All Rights Reserved.\n```", "```\n004008a3 72        ??     72h    r\n\n004008a4 85        ??     85h\n\n004008a5 6c        ??     6Ch    l\n```", "```\n004034e3  ??       ??\n\n004034e4  ??       ??\n```", "```\n        LAB_0040886c                         XREF[1]: 0040888e(j)\n\n0040886c  MOV    EAX,dword ptr [EDI]\n\n0040886e  OR     EAX,EAX\n\n00408870  JZ     LAB_004088ae\n\n00408872  MOV    EBX,dword ptr [EDI + 0x4]\n\n00408875  LEA    EAX,[EAX + ESI*0x1 + 0x8000]\n\n0040887c  ADD    EBX,ESI\n\n0040887e  PUSH   EAX\n\n0040887f  ADD    EDI,0x8\n\n00408882  CALL➊ dword ptr [ESI + 0x808c]=>KERNEL32.DLL::LoadLibraryA\n\n00408888  XCHG   EAX,EBP\n\n        LAB_00408889                         XREF[1]: 004088a6(j)\n\n00408889  MOV    AL,byte ptr [EDI]\n\n0040888b  INC    EDI\n\n0040888c  OR     AL,AL\n\n0040888e  JZ     LAB_0040886c\n\n00408890  MOV    ECX,EDI\n\n00408892  PUSH   EDI\n\n00408893  DEC    EAX\n\n00408894  SCASB.REPNE ES:EDI\n\n00408896  PUSH    EBP\n\n00408897  CALL➋ dword ptr [ESI + 0x8090]=>KERNEL32.DLL::GetProcAddress\n\n0040889d  OR     EAX,EAX\n\n 0040889f  JZ     LAB_004088a8\n\n004088a1  MOV➌  dword ptr [EBX],EAX ; save to import table\n\n004088a3  ADD    EBX,0x4\n\n004088a6  JMP    LAB_00408889\n```", "```\n0041d1e4  CMP    dword ptr [EAX],0x64616f4c\n\n0041d1ea  JNZ    LAB_0041d226\n\n0041d1ec  CMP    dword ptr [EAX + 0x4],0x7262694c\n\n0041d1f3  JNZ    LAB_0041d226\n\n0041d1f5  CMP    dword ptr [EAX + 0x8],0x41797261\n\n0041d1fc  JNZ    LAB_0041d226\n```", "```\n0041d1e4  CMP    dword ptr [EAX],\"Load\"\n\n0041d1ea  JNZ    LAB_0041d226\n\n0041d1ec  CMP    dword ptr [EAX + 0x4],\"Libr\"\n\n0041d1f3  JNZ    LAB_0041d226\n\n0041d1f5  CMP    dword ptr [EAX + 0x8],\"aryA\"\n\n0041d1fc  JNZ    LAB_0041d226\n```", "```\n➊ GetProcAddress : 8A0FB5E2\n\n  GetProcessAffinityMask : B9756EFE\n\n  GetProcessHandleCount : B50EB87C\n\n  GetProcessHeap : C246DA44\n\n GetProcessHeaps : A18AAB23\n\n  GetProcessId : BE05ED07\n```", "```\n➊ 05371035  PUSH   dword ptr [DAT_05371008]\n\n➋ 0537103b  PUSHFD\n\n➌ 0537103c  PUSHAD\n\n➍ 0537103d  MOV    ECX,dword ptr [DAT_05371000]\n\n  05371043  JMP    LAB_05371082\n\n  ...\n\n          LAB_05371082                         XREF[1]:     05371043(j)\n\n➎ 05371082  CALL   FUN_05371048\n\n  05371087  SHL    byte ptr [EBX + -0x2b],1\n\n  0537108a  PUSHFD\n\n  0537108b  XCHG   byte ptr [EDX + -0x11],AL\n\n  0537108e  POP    SS\n\n  0537108f  XCHG   EAX,ESP\n\n  05371090  CWDE\n\n  05371091  AAD    0x8e\n\n  05371093  PUSH   ECX\n\n➏ 05371094  OUT    DX,EAX\n\n  05371095  ADD    byte ptr [EDX + 0xa81bee60],BH\n\n  0537109b  PUSH   SS\n\n  0537109c  RCR    dword ptr [ESI + 0xc],CL\n\n  0537109f  PUSH   CS\n\n  053710a0  SUB    AL,0x70\n\n  053710a2  CMP    CH,byte ptr [EAX + 0x6e]\n\n  053710a5  CMP    dword ptr [DAT_cbd35372],0x9c38a8bc\n\n  053710af  AND    AL,0xf4\n\n  053710b1  SBB    EBP,ESP\n\n  053710b4  POP    DS\n\n➐ 053710b5  ??    C6h\n```", "```\nint ECX = getInt(toAddr(0x5371000));    // from instruction 0537103d\n```", "```\n  FUN_05371048                                 XREF[1]:     entry:05371082(c)\n\n➊ 05371048  POP    ESI\n\n➋ 05371049  MOV    EDI,ESI\n\n➌ 0537104b  MOV    EBX,dword ptr [DAT_05371004] = C09657B0h\n\n  05371051  OR     EBX,EBX\n\n➍ 05371053  JZ     LAB_0537107f\n\n➎ 05371059  XOR    EDX,EDX\n\n        ➏ LAB_0537105b                         XREF[1]:  0537107d(j)\n\n  0537105b  MOV    EAX,0x8\n\n        ➐ LAB_05371060                         XREF[1]:  05371073(j)\n\n  05371060  SHRD   EDX,EBX,0x1\n\n  05371064  SHR    EBX,1\n\n  05371066  JNC    LAB_05371072\n\n  0537106c  XOR    EBX,0xc0000057\n\n          LAB_05371072                         XREF[1]:  05371066(j)\n\n  05371072  DEC    EAX\n\n  05371073  JNZ    LAB_05371060\n\n  05371075  SHR    EDX,0x18\n\n  05371078  LODSB  ESI\n\n  05371079  XOR    AL,DL\n\n  0537107b  STOSB  ES:EDI\n\n  0537107c  DEC    ECX\n\n  0537107d  JNZ    LAB_0537105b\n\n          LAB_0537107f                         XREF[1]:  05371053(j)\n\n  0537107f  POPAD\n\n  05371080  POPFD\n\n  05371081  RET\n```", "```\nint ECX = getInt(toAddr(0x5371000));   // from instruction 0537103D\n\nint ESI = 0x05371087;                  // from instruction 05371048\n\nint EDI = ESI;                         // from instruction 05371049\n\nint EBX = getInt(toAddr(0x5371004));   // from instruction 0537104B\n\nint EDX = 0;                           // from instruction 05371059\n```", "```\npublic void run() throws Exception {\n\n   int ECX = getInt(toAddr(0x5371000));   // from instruction 0537103D\n\n   int ESI = 0x05371087;                  // from instruction 05371048\n\n   int EDI = ESI;                         // from instruction 05371049\n\n   int EBX = getInt(toAddr(0x5371004));   // from instruction 0537104B\n\n   if (EBX != 0) {                        // from instructions 05371051 \n\n                                          //   and 05371053\n\n      int EDX = 0;                        // from instruction 05371059\n\n      do {\n\n         int EAX = 8;                     // from instruction 0537105B\n\n         do {\n\n                                          // mimic x86 shrd instruction\n\n                                          //   using several operations\n\n            EDX = EDX >>> 1;              // unsigned shift right one bit\n\n            int CF = EBX & 1;             // remember the low bit of EBX\n\n            if (CF == 1) {                // CF represents the x86 carry flag\n\n               EDX = EDX | 0x80000000;    // shift in low bit of EBX if it's 1\n\n            }\n\n            EBX = EBX >>> 1;              // unsigned shift right one bit\n\n            if (CF == 1) {                // from instruction 05371066\n\n               EBX = EBX ^ 0xC0000057;    // from instruction 0537106C\n\n            }\n\n            EAX--;                        // from instruction 05371072\n\n         } while (EAX != 0);              // from instruction 05371073\n\n         EDX = EDX >>> 24;                // unsigned shift right 24 bits\n\n      ➊ EAX = getByte(toAddr(ESI));      // from instruction 05371078\n\n         ESI++;\n\n         EAX = EAX ^ EDX;                 // from instruction 05371079\n\n         clearListing(toAddr(EDI));       // clear byte so we can change it\n\n      ➋ setByte(toAddr(EDI), (byte)EAX); // from instruction 0537107B\n\n         EDI++;\n\n         ECX--;                           // from instruction 0537107C\n\n      } while (ECX != 0);                 // from instruction 0537107D\n\n   }\n\n}\n```", "```\nEAX = (EAX & 0xFFFFFF00) | (getByte(toAddr(ESI)) & 0xFF);\n```", "```\n0537107f  POPAD\n\n05371080  POPFD\n\n05371081  RET\n```", "```\n       entry\n\n➊ 05371035  PUSH   dword ptr [DAT_05371008]\n\n  0537103b  PUSHFD\n\n  0537103c  PUSHAD\n```", "```\n➊ unsigned char check_access[] = {\n\n      0xf0, 0xed, 0x2c, 0x40, 0x2c, 0xd8, 0x59, 0x26, 0xd8,\n\n      0x59, 0xc1, 0xaa, 0x31, 0x65, 0xaa, 0x13, 0x65, 0xf8, 0x66\n\n  };\n\n unsigned char key = 0xa5;\n\n  void unpack() {\n\n      for (int ii = 0; ii < sizeof(check_access); ii++) {\n\n        ➋ check_access[ii] ^= key;\n\n      }\n\n  }\n\n  void do_challenge() {\n\n      int guess;\n\n      int access_allowed;\n\n      int (*check_access_func)(int);\n\n    ➌ unpack();\n\n      printf(\"Enter the correct integer: \");\n\n      scanf(\"%d\", &guess);\n\n      check_access_func = (int (*)(int))check_access;\n\n      access_allowed = check_access_func(guess)➋;\n\n      if (access_allowed) {\n\n          printf(\"Access granted!\\n\");\n\n      } else {\n\n          printf(\"Access denied!\\n\");\n\n      }\n\n  }\n\n  int main() {\n\n      do_challenge();\n\n      return 0;\n\n  }\n```", "```\nprivate EmulatorHelper emuHelper;   // EmulatorHelper member variable object\n\nprivate Address executionAddress;   // Initially the start of the selection\n\nprivate Address endAddress;         // End of the selected region\n```", "```\nemuHelper = new EmulatorHelper(currentProgram);\n\nemuHelper.enableMemoryWriteTracking(true);\n```", "```\nif (currentSelection != null) {\n\n    executionAddress = currentSelection.getMinAddress();\n\n    endAddress = currentSelection.getMaxAddress().next();\n\n} else {\n\n    println(\"Nothing selected\");\n\n    return;\n\n}\n```", "```\nInstruction executionInstr = getInstructionAt(executionAddress);\n\nif (executionInstr == null) {\n\n    printerr(\"Instruction not found at: \" + executionAddress);\n\n    return;\n\n}\n\nlong stackOffset = (executionInstr.getAddress().getAddressSpace().\n\n                    getMaxAddress().getOffset() >>> 1) - 0x7fff;\n\nemuHelper.writeRegister(emuHelper.getStackPointerRegister(), stackOffset);\n\n// Setup breakpoint at the end address\n\nemuHelper.setBreakpoint(endAddress);\n\n// Set continuing to false as we are just starting the emulation\n\nboolean continuing = false;;\n```", "```\n➊ while (!monitor.isCancelled() &&\n\n         !emuHelper.getExecutionAddress().equals(endAddress)) {\n\n      if (continuing) {\n\n emuHelper.run(monitor);\n\n      } else {\n\n          emuHelper.run(executionAddress, executionInstr, monitor);\n\n      }\n\n    ➋ executionAddress = emuHelper.getExecutionAddress();\n\n      // determine why the emulator stopped, and handle each possible reason\n\n    ➌ if (emuHelper.getEmulateExecutionState() ==\n\n          EmulateExecutionState.BREAKPOINT) {\n\n          continuing = true;\n\n      } else if (monitor.isCancelled()) {\n\n          println(\"Emulation cancelled at 0x\" + executionAddress);\n\n          continuing = false;\n\n      } else {\n\n          println(\"Emulation Error at 0x\" + executionAddress +\n\n                  \": \" + emuHelper.getLastError());\n\n          continuing = false;\n\n      }\n\n    ➍ writeBackMemory();\n\n      if (!continuing) {\n\n          break;\n\n      }\n\n  }\n```", "```\nprivate void writeBackMemory() {\n\n    AddressSetView memWrites = emuHelper.getTrackedMemoryWriteSet();\n\n    AddressIterator aIter = memWrites.getAddresses(true);\n\n    Memory mem = currentProgram.getMemory();\n\n    while (aIter.hasNext()) {\n\n        Address a = aIter.next();\n\n        MemoryBlock mb = getMemoryBlock(a);\n\n        if (mb == null) {\n\n            continue;\n\n        }\n\n if (!mb.isInitialized()) {\n\n            // initialize memory\n\n            try {\n\n                mem.convertToInitialized(mb, (byte)0x00);\n\n            } catch (Exception e) {\n\n                println(e.toString());\n\n            }\n\n        }\n\n        try {\n\n            mem.setByte(a, emuHelper.readMemoryByte(a));\n\n        } catch (Exception e) {\n\n            println(e.toString());\n\n        }\n\n    }\n\n}\n```", "```\nemuHelper.dispose();\n```", "```\n0010077d 48 8d 05 8c 08 20 00  LEA    RAX,[check_access]\n```", "```\ncheck_access[(int)local_c] = check_access[(int)local_c] ^ key;\n```", "```\n00301010 f0 ed 2c 40 2c d8 59  undefined1[19]\n\n         26 d8 59 c1 aa 31 65\n\n         aa 13 65 f8 66\n```", "```\n00301010 55 48 89 e5 89 7d     undefined1[19]\n\n         fc 83 7d fc 64 0f\n\n         94 c0 0f b6 c0 5d c3\n```", "```\n     check_access\n\n00301010 55                    PUSH   RBP\n\n00301011 48 89 e5              MOV    RBP,RSP\n\n00301014 89 7d fc              MOV    dword ptr [RBP + -0x4],EDI\n\n00301017 83 7d fc 64           CMP    dword ptr [RBP + -0x4],100\n\n0030101b 0f 94 c0              SETZ   AL\n\n0030101e 0f b6 c0              MOVZX  EAX,AL\n\n00301021 5d                    POP    RBP\n\n00301022 c3                    RET\n```", "```\nulong UndefinedFunction_00301010(int param_1)\n\n{\n\n  return (ulong)(param_1 == 100);\n\n}\n```"]