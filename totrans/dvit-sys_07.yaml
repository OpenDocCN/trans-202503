- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 64-BIT X86 ASSEMBLY (X86-64)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we cover the Intel Architecture 64-bit (x86-64) instruction
    set architecture. Recall that an instruction set architecture (or ISA; see [Chapter
    5](ch05.xhtml#ch05)) defines the set of instructions and binary encodings of a
    machine-level program. To run the examples in this chapter, you will need access
    to a machine with a 64-bit x86 processor. The term “x86” is often used synonymously
    with the IA-32 architecture. The 64-bit extension of this architecture is referred
    to as x86-64 (or x64) and is ubiquitous in modern computers. Both IA32 and x86-64
    belong to the x86 architecture family.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check to see if you have a 64-bit Intel processor on your Linux machine,
    run the `uname -p` command. If you have an x86-64 system, you should see output
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since x86-64 is an extension of the smaller IA32 ISA, some readers may prefer
    a discussion of IA32\. To read more about IA32, see [Chapter 8](ch08.xhtml#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: X86 SYNTAX BRANCHES
  prefs: []
  type: TYPE_NORMAL
- en: x86 architectures typically follow one of two different syntax branches. Unix
    machines commonly use the AT&T syntax, given that Unix was developed at AT&T Bell
    Labs. The corresponding assembler is GNU Assembler (GAS). Since we use GCC for
    most examples in this book, we cover AT&T syntax in this chapter. Windows machines
    commonly use Intel syntax, which is used by Microsoft’s Macro Assembler (MASM).
    The Netwide Assembler (NASM) is an example of a Linux assembler that uses Intel
    syntax. The argument regarding the superiority of one syntax over the other is
    one of the “holy wars” of the discipline. However, there is value in being familiar
    with both syntaxes, as a programmer may encounter either in various circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: '7.1 Diving into Assembly: Basics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a first look at x64 assembly, we modify the `adder` function from [Chapter
    6](ch06.xhtml#ch06) to simplify its behavior. The modified function (`adder2`)
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile this code, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s view the corresponding assembly of this code by using the `objdump`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for the code snippet associated with `adder2` by typing /adder2 while
    examining the file `output` using less. The section associated with `adder2` should
    look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry if you don’t understand what’s going on just yet. We will cover
    assembly in greater detail in later sections. For now, let’s study the structure
    of these individual instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Each line in the preceding example contains an instruction’s 64-bit address
    in program memory, the bytes corresponding to the instruction, and the plaintext
    representation of the instruction itself. For example, `55` is the machine code
    representation of the instruction `push %rbp`, and the instruction occurs at address
    `0x400526` in program memory. Note that `0x400526` is an abbreviation of the full
    64-bit address associated with the `push %rbp` instruction; the leading zeros
    are ignored for readability.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a single line of C code often translates to multiple
    instructions in assembly. The operation `a + 2` is represented by the two instructions
    `mov -0x4(%rbp),%eax` and `add $0x2,%eax`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning YOUR ASSEMBLY MAY LOOK DIFFERENT!**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are compiling your code along with us, you may notice that some of your
    assembly examples look different from what is shown in this book. The precise
    assembly instructions that are output by any compiler depend on that compiler’s
    version and the underlying operating system. Most of the assembly examples in
    this book were generated on systems running Ubuntu or Red Hat Enterprise Linux
    (RHEL).
  prefs: []
  type: TYPE_NORMAL
- en: In the examples that follow, we do not use any optimization flags. For example,
    we compile any example file (`example.c`) using the command `gcc -o example example.c`.
    Consequently, there are many seemingly redundant instructions in the examples
    that follow. Remember that the compiler is not “smart”—it simply follows a series
    of rules to translate human-readable code into machine language. During this translation
    process, it is not uncommon for some redundancy to occur. Optimizing compilers
    remove many of these redundancies during optimization, which is covered in [Chapter
    12](ch12.xhtml#ch12).
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1 Registers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall that a *register* is a word-sized storage unit located directly on the
    CPU. There may be separate registers for data, instructions, and addresses. For
    example, the Intel CPU has a total of 16 registers for storing 64-bit data: `%rax`,
    `%rbx`, `%rcx`, `%rdx`, `%rdi`, `%rsi`, `%rsp`, `%rbp`, and `%r8`–`%r15`. All
    the registers save for `%rsp` and `%rbp` hold general-purpose 64-bit data. While
    a program may interpret a register’s contents as, say, an integer or an address,
    the register itself makes no distinction. Programs can read from or write to all
    16 registers.'
  prefs: []
  type: TYPE_NORMAL
- en: The registers `%rsp` and `%rbp` are known as the *stack pointer* and the *frame
    pointer* (or *base pointer*), respectively. The compiler reserves these registers
    for operations that maintain the layout of the program stack. For example, register
    `%rsp` always points to the top of the stack. In earlier x86 systems (e.g., IA32),
    the frame pointer commonly tracked the base of the active stack frame and helped
    to reference parameters. However, the base pointer is less frequently used in
    x86-64 systems. Compilers typically store the first six parameters in registers
    `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, and `%r9`, respectively. Register `%rax`
    stores the return value from a function.
  prefs: []
  type: TYPE_NORMAL
- en: The last register worth mentioning is `%rip` or the *instruction pointer*, sometimes
    called the *program counter* (PC). It points to the next instruction to be executed
    by the CPU. Unlike the 16 registers mentioned previously, programs cannot write
    directly to register `%rip`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.2 Advanced Register Notation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since x86-64 is an extension of the 32-bit x86 architecture (which itself was
    an extension of an earlier 16-bit version), the ISA provides mechanisms to access
    the lower 32 bits, 16 bits, and lower bytes of each register. [Table 7-1](ch07.xhtml#ch7tab1)
    lists each of the 16 registers and the ISA notations to access their component
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-1:** x86-64 Registers and Mechanisms for Accessing Lower Bytes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **64-bit Register** | **32-bit Register** | **Lower 16 Bits** | **Lower 8
    Bits** |'
  prefs: []
  type: TYPE_TB
- en: '| `%rax` | `%eax` | `%ax` | `%al` |'
  prefs: []
  type: TYPE_TB
- en: '| `%rbx` | `%ebx` | `%bx` | `%bl` |'
  prefs: []
  type: TYPE_TB
- en: '| `%rcx` | `%ecx` | `%cx` | `%cl` |'
  prefs: []
  type: TYPE_TB
- en: '| `%rdx` | `%edx` | `%dx` | `%dl` |'
  prefs: []
  type: TYPE_TB
- en: '| `%rdi` | `%edi` | `%di` | `%dil` |'
  prefs: []
  type: TYPE_TB
- en: '| `%rsi` | `%esi` | `%si` | `%sil` |'
  prefs: []
  type: TYPE_TB
- en: '| `%rsp` | `%esp` | `%sp` | `%spl` |'
  prefs: []
  type: TYPE_TB
- en: '| `%rbp` | `%ebp` | `%bp` | `%bpl` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r8` | `%r8d` | `%r8w` | `%r8b` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r9` | `%r9d` | `%r9w` | `%r9b` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r10` | `%r10d` | `%r10w` | `%r10b` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r11` | `%r11d` | `%r11w` | `%r11b` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r12` | `%r12d` | `%r12w` | `%r12b` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r13` | `%r13d` | `%r13w` | `%r13b` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r14` | `%r14d` | `%r14w` | `%r14b` |'
  prefs: []
  type: TYPE_TB
- en: '| `%r15` | `%r15d` | `%r15w` | `%r15b` |'
  prefs: []
  type: TYPE_TB
- en: The first eight registers (`%rax`, `%rbx`, `%rcx`, `%rdx`, `%rdi`, `%rsi`, `%rsp`,
    and `%rbp`) are 64-bit extensions of 32-bit registers in x86 and have a common
    mechanism for accessing their lower 32 bits, lower 16 bits, and least-significant
    byte. To access the lower 32 bits of the first eight registers, simply replace
    the `r` in the register name with `e`. Thus, the register corresponding to the
    lower 32 bits of register `%rax` is register `%eax`. To access the lower 16 bits
    of each of these eight registers, reference the last two letters of the register’s
    name. So, the mechanism to access the lower two bytes of register `%rax` is `%ax`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The names that refer to subsets of register `%rax`*'
  prefs: []
  type: TYPE_NORMAL
- en: The ISA provides a separate mechanism to access the eight-bit components within
    the lower 16 bits of the first four listed registers. [Figure 7-1](ch07.xhtml#ch7fig1)
    depicts the access mechanisms for register `%rax`. The *higher* and *lower* bytes
    within the lower 16 bits of the first four listed registers can be accessed by
    taking the last two letters of the register name and replacing the last letter
    with either an `h` (for *higher*) or an `l` (for *lower*) depending on which byte
    is desired. For example, `%al` references the lower eight bits of register `%ax`,
    whereas `%ah` references the higher eight bits of register `%ax`. These eight-bit
    registers are commonly used for storing single-byte values for certain operations
    such as bitwise shifts (a 32-bit register cannot be shifted more than 32 places,
    and the number 32 requires only a single byte of storage).
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning WARNING: COMPILER MAY CHOOSE COMPONENT REGISTERS DEPENDING ON TYPE**'
  prefs: []
  type: TYPE_NORMAL
- en: When reading assembly code, keep in mind that the compiler typically uses the
    64-bit registers when dealing with 64-bit values (e.g., pointers or `long` types),
    and the 32-bit component registers when dealing with 32-bit types (e.g., `int`).
    In x86-64, it is very common to see 32-bit component registers intermixed with
    the full 64-bit registers. For example, in the `adder2` function shown earlier,
    the compiler references component register `%eax` instead of `%rax` since `int`
    types typically take up 32 bits (four bytes) of space on 64-bit systems. If the
    `adder2` function had a `long` parameter instead of `int`, the compiler would
    store `a` in register `%rax` instead of register `%eax`.
  prefs: []
  type: TYPE_NORMAL
- en: The last eight registers (`%r8`–`%r15`) were not part of the IA32 ISA. However,
    they also have mechanisms to access their different byte components. To access
    the lower 32 bits, 16 bits, or byte of the last eight registers, append the letter
    `d`, `w`, or `b`, respectively, to the end of the register’s name. Thus, `%r9d`
    accesses the lower 32 bits of register `%r9`, whereas `%r9w` accesses the lower
    16 bits, and `%r9b` accesses the lowest byte of register `%r9`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.3 Instruction Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each instruction consists of an operation code (or *opcode*) that specifies
    what it does, and one or more *operands* that tell the instruction how to do it.
    For example, the instruction `add $0x2,%eax` has the opcode `add` and the operands
    `$0x2` and `%eax`.
  prefs: []
  type: TYPE_NORMAL
- en: Each operand corresponds to a source or destination location for a specific
    operation. Two operand instructions typically follow the source, destination (`S`,
    `D`) format, where the first operand specifies a source register, and the second
    operand specifies the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple types of operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Constant* (*literal*) values are preceded by the `$` sign. For example, in
    the instruction `add $0x2,%eax`, `$0x2` is a literal value that corresponds to
    the hexadecimal value 0x2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Register* forms refer to individual registers. Thus, the instruction `mov
    %rsp,%rbp` specifies that the value in the source register (`%rsp`) should be
    copied to the destination location (register `%rbp`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Memory* forms correspond to some value inside main memory (RAM) and are commonly
    used for address lookups. Memory address forms can contain a combination of registers
    and constant values. For example, in the instruction `mov -0x4(%rbp),%eax`, the
    operand `-0x4(%rbp)` is an example of a memory form. It loosely translates to
    “add –0x4 to the value in register `%rbp` (i.e., subtract 0x4 from `%rbp`), and
    then perform a memory lookup.” If this sounds like a pointer dereference, that’s
    because it is!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.1.4 An Example with Operands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The best way to explain operands in detail is to present a quick example. Suppose
    that memory contains the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x804 | 0xCA |'
  prefs: []
  type: TYPE_TB
- en: '| 0x808 | 0xFD |'
  prefs: []
  type: TYPE_TB
- en: '| 0x80c | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x810 | 0x1E |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s also assume that the following registers contain the values shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Register** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `%rax` | 0x804 |'
  prefs: []
  type: TYPE_TB
- en: '| `%rbx` | 0x10 |'
  prefs: []
  type: TYPE_TB
- en: '| `%rcx` | 0x4 |'
  prefs: []
  type: TYPE_TB
- en: '| `%rdx` | 0x1 |'
  prefs: []
  type: TYPE_TB
- en: Then the operands in [Table 7-2](ch07.xhtml#ch7tab2) evaluate to the values
    shown there. Each row of the table matches an operand with its form (e.g., constant,
    register, memory), how it is translated, and its value. Note that the notation
    M[x] in this context denotes the value at the memory location specified by address
    x.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-2:** Example Operands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operand** | **Form** | **Translation** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `%rcx` | Register | `%rcx` | 0x4 |'
  prefs: []
  type: TYPE_TB
- en: '| `(%rax)` | Memory | M[`%rax`] or M[0x804] | 0xCA |'
  prefs: []
  type: TYPE_TB
- en: '| `$0x808` | Constant | 0x808 | 0x808 |'
  prefs: []
  type: TYPE_TB
- en: '| `0x808` | Memory | M[0x808] | 0xFD |'
  prefs: []
  type: TYPE_TB
- en: '| `0x8(%rax)` | Memory | M[`%rax` + 8] or M[0x80c] | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| `(%rax, %rcx)` | Memory | M[`%rax` + `%rcx`] or M[0x808] | 0xFD |'
  prefs: []
  type: TYPE_TB
- en: '| `0x4(%rax, %rcx)` | Memory | M[`%rax` + `%rcx` + 4] or M[0x80c] | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| `0x800(,%rdx,4)` | Memory | M[0x800 + `%rdx`×4] or M[0x804] | 0xCA |'
  prefs: []
  type: TYPE_TB
- en: '| `(%rax, %rdx, 8)` | Memory | M[`%rax` + `%rdx`×8] or M[0x80c] | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: In [Table 7-2](ch07.xhtml#ch7tab2), the notation `%rcx` indicates the value
    stored in register `%rcx`. In contrast, M[`%rax`] indicates that the value inside
    `%rax` should be treated as an address, and to dereference (look up) the value
    at that address. Therefore, the operand `(%rax)` corresponds to M[0x804], which
    corresponds to the value 0xCA.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important notes before continuing. Although [Table 7-2](ch07.xhtml#ch7tab2)
    shows many valid operand forms, not all forms can be used interchangeably in all
    circumstances. Specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Constant forms cannot serve as destination operands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory forms cannot serve as *both* the source and destination operand in a
    single instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases of scaling operations (refer back to the last two operands in [Table
    7-2](ch07.xhtml#ch7tab2)), the scaling factor is a third parameter in the parentheses.
    Scaling factors can be one of 1, 2, 4, or 8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 7-2](ch07.xhtml#ch7tab2) is provided as a reference; however, understanding
    key operand forms will help improve the reader’s speed in parsing assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.5 Instruction Suffixes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In several cases in upcoming examples, common and arithmetic instructions have
    a suffix that indicates the *size* (associated with the *type*) of the data being
    operated on at the code level. The compiler automatically translates code to instructions
    with the appropriate suffix. [Table 7-3](ch07.xhtml#ch7tab3) shows the common
    suffixes for x86-64 instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-3:** Example Instruction Suffixes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Suffix** | **C Type** | **Size (Bytes)** |'
  prefs: []
  type: TYPE_TB
- en: '| b | `char` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| w | `short` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| l | `int` or `unsigned` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| s | `float` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| q | `long`, `unsigned long`, all pointers | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| d | `double` | 8 |'
  prefs: []
  type: TYPE_TB
- en: Note that instructions involved with conditional execution have different suffixes
    based on the evaluated condition. We cover instructions associated with conditional
    execution in “Conditional Control and Loops” on [page 310](ch07.xhtml#lev1_54).
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Common Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we discuss several common assembly instructions. [Table 7-4](ch07.xhtml#ch7tab4)
    lists the most foundational instructions in x86 (and thus x64) assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-4:** Most Common Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `mov S,D` | S → D | (copies value of S into D) |'
  prefs: []
  type: TYPE_TB
- en: '| `add S,D` | S + D → D | (adds S to D and stores result in D) |'
  prefs: []
  type: TYPE_TB
- en: '| `sub S,D` | D – S → D | (subtracts S *from* D and stores result in D) |'
  prefs: []
  type: TYPE_TB
- en: Therefore, the sequence of instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'translates to:'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the value at location `%rbp` + –0x4 in *memory* (or M[`%rbp`– 0x4]) to
    register `%eax`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the value 0x2 to register `%eax`, and store the result in register `%eax`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three instructions shown in [Table 7-4](ch07.xhtml#ch7tab4) also form the
    building blocks for instructions that maintain the organization of the program
    stack (i.e., the *call stack*). Recall that registers `%rbp` and `%rsp` refer
    to the *frame* pointer and *stack* pointer, respectively, and are reserved by
    the compiler for call stack management. Recall from our earlier discussion on
    program memory in “Parts of Program Memory and Scope” on [page 64](ch02.xhtml#lev1_9)
    that the call stack typically stores local variables and parameters and helps
    the program track its own execution (see [Figure 7-2](ch07.xhtml#ch7fig2)). On
    x86-64 systems, the execution stack grows toward *lower* addresses. Like all stack
    data structures, operations occur at the “top” of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: The parts of a program’s address space*'
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 ISA provides two instructions ([Table 7-5](ch07.xhtml#ch7tab5)) to
    simplify call stack management.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-5:** Stack Management Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `push S` | Pushes a copy of S onto the top of the stack. Equivalent to:`sub
    $0x8,%rsp``mov S,(%rsp)` |'
  prefs: []
  type: TYPE_TB
- en: '| `pop D` | Pops the top element off the stack and places it in location D.Equivalent
    to:`mov (%rsp),D``add $0x8,%rsp` |'
  prefs: []
  type: TYPE_TB
- en: Notice that although the three instructions in [Table 7-4](ch07.xhtml#ch7tab4)
    require two operands, the `push` and `pop` instructions in [Table 7-5](ch07.xhtml#ch7tab5)
    require only one operand each.
  prefs: []
  type: TYPE_NORMAL
- en: '7.2.1 Putting It All Together: A More Concrete Example'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a closer look at the `adder2` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'and its corresponding assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The assembly code consists of a `push` instruction, followed by three `mov`
    instructions, an `add` instruction, a `pop` instruction, and finally a `retq`
    instruction. To understand how the CPU executes this set of instructions, we need
    to revisit the structure of program memory (see “Parts of Program Memory and Scope”
    on [page 64](ch02.xhtml#lev1_9)). Recall that every time a program executes, the
    operating system allocates the new program’s address space (also known as *virtual
    memory*). Virtual memory and the related concept of processes are covered in greater
    detail in [Chapter 13](ch13.xhtml#ch13); for now, it suffices to think of a process
    as the abstraction of a running program and virtual memory as the memory that
    is allocated to a single process. Every process has its own region of memory called
    the *call stack*. Keep in mind that the call stack is located in process/virtual
    memory, unlike registers (which are located on the CPU).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-3](ch07.xhtml#ch7fig3) depicts a sample state of the call stack and
    registers prior to the execution of the `adder2` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Execution stack prior to execution*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the stack grows toward *lower* addresses. Register `%eax` contains
    a junk value. The single parameter to the `adder2` function (`a`) is stored in
    register `%rdi` by convention. Since `a` is of type `int`, it is stored in component
    register `%edi`, which is shown in [Figure 7-3](ch07.xhtml#ch7fig3). Likewise,
    because the `adder2` function returns an `int`, component register `%eax` is used
    for the return value instead of `%rax`.
  prefs: []
  type: TYPE_NORMAL
- en: The addresses associated with the instructions in the code segment of program
    memory (0x400526–0x400534) have been shortened to 0x526–0x534 to improve figure
    readability. Likewise, the addresses associated with the call stack segment of
    program memory have been shortened to 0xd28–0xd1c from 0x7fffffffdd28–0x7fffffffdd1c.
    In truth, call stack addresses occur at much higher addresses in program memory
    than code segment addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the initial values of registers `%rsp` and `%rbp`: they
    are 0xd28 and 0xd40, respectively. The upper-left arrow in the following figures
    visually indicates the currently executing instruction. The `%rip` register (or
    instruction pointer) shows the next instruction to execute. Initially, `%rip`
    contains address 0x526, which corresponds to the first instruction in the `adder2`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0304-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first instruction (`push %rbp`) places a copy of the value in `%rbp` (or
    0xd40) on top of the stack. After it executes, the `%rip` register advances to
    the address of the next instruction to execute (0x527). The `push` instruction
    decrements the stack pointer by 8 (“growing” the stack by 8 bytes), resulting
    in a new `%rsp` value of 0xd20\. Recall that the `push %rbp` instruction is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In other words, subtract 8 from the stack pointer and place a copy of the contents
    of `%rbp` in the location pointed to by the dereferenced stack pointer, `(%rsp)`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0304-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Recall that the structure of the `mov` instruction is `mov S,D`, where S is
    the source location, and D is the destination. Thus, the next instruction (`mov`
    `%rsp,%rbp`) updates the value of `%rbp` to 0xd20\. The register `%rip` advances
    to the address of the next instruction to execute, or 0x52a.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0305-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, `mov %edi,-0x4(%rbp)` is executed. This is a bit more complicated than
    the last `mov` instruction. Let’s parse it piece by piece. First, recall that
    the first parameter to any function is stored in register `%rdi`. Since `a` is
    of type `int`, the compiler stores the first parameter in component register `%edi`.
    Next, the operand `-0x4(%rbp)` translates to M[`%rbp` – 0x4]. Since `%rbp` contains
    the value 0xd20, subtracting 4 from it yields 0xd1c. Therefore, the `mov` instruction
    copies the value of register `%edi` (or 0x28) to location 0xd1c on the stack.
    The instruction pointer advances to address 0x52d, the next address to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that storing the value 0x28 does not affect the stack pointer (`%rsp`).
    Therefore, as far as the program is concerned, the “top” of this stack is still
    address 0xd20.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0305-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next `mov` instruction (`mov -0x4(%rbp),%eax`) copies the value at stack
    location 0xd1c (i.e., M[`%rbp` – 0x4] or 0x28) and stores it in register `%eax`.
    Register `%rip` advances to the next instruction to be executed, or 0x530.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0306-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, `add $0x2,%eax` is executed. Recall that the `add` instruction has the
    form `add S,D` and places the quantity S + D in the destination D. So, `add $0x2,`
    `%eax` adds the constant value 0x2 to the value stored in `%eax` (or 0x28), resulting
    in the value 0x2A being stored in register `%eax`. Register `%rip` advances to
    point to the next instruction to be executed, or 0x533.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0306-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next instruction that executes is `pop %rbp`. This instruction “pops” the
    value off the top of the call stack and places it in destination register `%rbp`.
    Recall that this instruction is equivalent to the following sequence of two instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the top of the stack is 0xd20, since that is the value stored in
    `%rsp`. Therefore, as soon as this instruction executes, the value `(%rsp)` (i.e.,
    M[0xd20]) is copied into register `%rbp`. Thus, `%rbp` now contains the value
    0xd40\. The stack pointer *increments* by 8, since the stack grows toward lower
    addresses (and consequently *shrinks* toward higher ones). The new value of `%rsp`
    is 0xd28, and `%rip` now points to the address of the last instruction to execute
    (i.e., 0x534).
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction executed is `retq`. We will talk more about what happens
    with `retq` in future sections when we discuss function calls, but for now it
    suffices to know that it prepares the call stack for returning from a function.
    By convention, the register `%rax` always contains the return value (if one exists).
    In this case, because `adder2` is of type `int`, the return value is stored in
    component register `%eax`, and the function returns the value 0x2A, or 42.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, note that the final values in registers `%rsp` and `%rbp`
    are 0xd28 and 0xd40, respectively, which are the *same values as when the function
    started executing*! This is normal and expected behavior with the call stack.
    The purpose of the call stack is to store the temporary variables and data of
    each function as it executes in the context of a program. When a function completes
    executing, the stack returns to the state it was in prior to the function call.
    As a result, it is common to see the following two instructions at the beginning
    of a function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'and the following two instructions at the end of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 7.3 Arithmetic Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The x86 ISA implements several instructions that correspond to arithmetic operations
    performed by the ALU. [Table 7-6](ch07.xhtml#ch7tab6) lists several arithmetic
    instructions that one may encounter when reading assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-6:** Common Arithmetic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `add S,D` | S + D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `sub S,D` | D – S → D |'
  prefs: []
  type: TYPE_TB
- en: '| `inc D` | D + 1 → D |'
  prefs: []
  type: TYPE_TB
- en: '| `dec D` | D – 1 → D |'
  prefs: []
  type: TYPE_TB
- en: '| `neg D` | –D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `imul S,D` | S × D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `idiv S` | `%rax` / S: quotient → `%rax`, remainder → `%rdx` |'
  prefs: []
  type: TYPE_TB
- en: The `add` and `sub` instructions correspond to addition and subtraction and
    take two operands each. The next three entries show the single-register instructions
    for the increment (`x++`), decrement (`x--`), and negation (`-x`) operations in
    C. The multiplication instruction operates on two operands and places the product
    in the destination. If the product requires more than 64 bits to represent, the
    value is truncated to 64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: The division instruction works a little differently. Prior to the execution
    of the `idiv` instruction, it is assumed that register `%rax` contains the dividend.
    Calling `idiv` on operand S divides the contents of `%rax` by S and places the
    quotient in register `%rax` and the remainder in register `%rdx`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.1 Bit Shifting Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bit shifting instructions enable the compiler to perform bit shifting operations.
    Multiplication and division instructions typically take a long time to execute.
    Bit shifting offers the compiler a shortcut for multiplicands and divisors that
    are powers of 2\. For example, to compute `77 * 4`, most compilers will translate
    this operation to `77 << 2` to avoid the use of an `imul` instruction. Likewise,
    to compute `77 / 4`, a compiler typically translates this operation to `77 >>
    2` to avoid using the `idiv` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that left and right bit shift translate to different instructions
    based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-7:** Bit Shift Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** | **Arithmetic or Logical?** |'
  prefs: []
  type: TYPE_TB
- en: '| `sal v,D` | D `≪` v → D | arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `shl v,D` | D `≪` v → D | logical |'
  prefs: []
  type: TYPE_TB
- en: '| `sar v,D` | D `≫` v → D | arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `shr v,D` | D `≫` v → D | logical |'
  prefs: []
  type: TYPE_TB
- en: Each shift instruction takes two operands, one which is usually a register (denoted
    by D) and the other which is a shift value (*v*). On 64-bit systems, the shift
    value is encoded as a single byte (since it doesn’t make sense to shift past 63).
    The shift value *v* must either be a constant or stored in register `%cl`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note DIFFERENT VERSIONS OF INSTRUCTIONS HELP DISTINGUISH TYPES AT AN ASSEMBLY
    LEVEL**'
  prefs: []
  type: TYPE_NORMAL
- en: At the assembly level, there is no notion of types. However, recall that the
    compiler will use component registers based on types. Similarly, recall that shift
    right works differently depending on whether the value is signed or unsigned.
    At the assembly level, the compiler uses separate instructions to distinguish
    between logical and arithmetic shifts!
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.2 Bitwise Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bitwise instructions enable the compiler to perform bitwise operations on data.
    One way the compiler uses bitwise operations is for certain optimizations. For
    example, a compiler may choose to implement 77 mod 4 with the operation `77 &`
    `3` in lieu of the more expensive `idiv` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-8](ch07.xhtml#ch7tab8) lists common bitwise instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-8:** Bitwise Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `and S,D` | S `&` D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `or S,D` | S `&#124;` D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `xor S,D` | S `^` D → D |'
  prefs: []
  type: TYPE_TB
- en: '| `not D` | `~`D → D |'
  prefs: []
  type: TYPE_TB
- en: Remember that bitwise `not` is distinct from negation (`neg`). The `not` instruction
    flips the bits, but does not add 1\. Be careful not to confuse these two instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!**'
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, it may be tempting to replace common arithmetic
    operations in your C code with bitwise shifts and other operations. This is *not*
    recommended. Most modern compilers are smart enough to replace simple arithmetic
    operations with bitwise operations when it makes sense, making it unnecessary
    for the programmer to do so. As a general rule, programmers should prioritize
    code readability whenever possible and avoid premature optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3.3 The Load Effective Address Instruction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*What’s lea got to do (got to do) with it?*'
  prefs: []
  type: TYPE_NORMAL
- en: '*What’s lea, but an effective address loading?*'
  prefs: []
  type: TYPE_NORMAL
- en: —With apologies to Tina Turner
  prefs: []
  type: TYPE_NORMAL
- en: We finally come to the *load effective address* or `lea` instruction, which
    is probably the arithmetic instruction that causes students the most consternation.
    It is traditionally used as a fast way to compute the address of a location in
    memory. The `lea` instruction operates on the same operand structure that we’ve
    seen thus far but does *not* include a memory lookup. Regardless of the type of
    data contained in the operand (whether it be a constant value or an address),
    `lea` simply performs arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose that register `%rax` contains the constant value 0x5, register
    `%rdx` contains the constant value 0x4, and register `%rcx` contains the value
    0x808 (which happens to be an address). [Table 7-9](ch07.xhtml#ch7tab9) depicts
    some example `lea` operations, their translations, and corresponding values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-9:** Example lea Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `lea 8(%rax), %rax` | 8 + `%rax` → `%rax` | 13 → `%rax` |'
  prefs: []
  type: TYPE_TB
- en: '| `lea (%rax, %rdx), %rax` | `%rax` + `%rdx` → `%rax` | 9 → `%rax` |'
  prefs: []
  type: TYPE_TB
- en: '| `lea (,%rax,4), %rax` | `%rax` × 4 → `%rax` | 20 → `%rax` |'
  prefs: []
  type: TYPE_TB
- en: '| `lea -0x8(%rcx), %rax` | `%rcx` – 8 → `%rax` | 0x800 → `%rax` |'
  prefs: []
  type: TYPE_TB
- en: '| `lea -0x4(%rcx, %rdx, 2), %rax` | `%rcx` + `%rdx` × 2 – 4 → `%rax` | 0x80c
    → `%rax` |'
  prefs: []
  type: TYPE_TB
- en: In all cases, the `lea` instruction performs arithmetic on the operand specified
    by the source S and places the result in the destination operand D. The `mov`
    instruction is identical to the `lea` instruction *except* that the `mov` instruction
    is *required* to treat the contents in the source operand as a memory location
    if it is in a memory form. In contrast, `lea` performs the same (sometimes complicated)
    operand arithmetic *without* the memory lookup, enabling the compiler to cleverly
    use `lea` as a substitution for some types of arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Conditional Control and Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section covers x86 assembly instructions for conditionals and loops (see
    “Conditionals and Loops” on [page 30](ch01.xhtml#lev1_3)). Recall that conditional
    statements enable coders to modify program execution based on the result of a
    conditional expression. The compiler translates conditionals into assembly instructions
    that modify the instruction pointer (`%rip`) to point to an address that is not
    the next one in the program sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.1 Preliminaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Conditional Comparison Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Comparison instructions perform an arithmetic operation for the purpose of guiding
    the conditional execution of a program. [Table 7-10](ch07.xhtml#ch7tab10) lists
    the basic instructions associated with conditional control.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-10:** Conditional Control Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `cmp R1, R2` | Compares R1 with R2 (i.e., evaluates R2 – R1) |'
  prefs: []
  type: TYPE_TB
- en: '| `test R1, R2` | Computes R1 `&` R2 |'
  prefs: []
  type: TYPE_TB
- en: 'The `cmp` instruction compares the values of two registers, R2 and R1\. Specifically,
    it subtracts R1 from R2\. The `test` instruction performs bitwise AND. It is common
    to see an instruction like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the bitwise AND of `%rax` with itself is zero only when `%rax`
    contains zero. In other words, this is a test for a zero value and is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the arithmetic instructions covered thus far, `cmp` and `test` do not
    modify the destination register. Instead, both instructions modify a series of
    single-bit values known as *condition code flags*. For example, `cmp` will modify
    condition code flags based on whether the value R2 – R1 results in a positive
    (greater), negative (less), or zero (equal) value. Recall that condition code
    values encode information about an operation in the ALU (see “The ALU” on [page
    261](ch05.xhtml#lev2_100)). The condition code flags are part of the `FLAGS` register
    on x86 systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-11:** Common Condition Code Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `ZF` | Is equal to zero (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `SF` | Is negative (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `OF` | Overflow has occurred (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `CF` | Arithmetic carry has occurred (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '[Table 7-11](ch07.xhtml#ch7tab11) depicts the common flags used for condition
    code operations. Revisiting the `cmp R1, R2` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ZF` flag is set to 1 if R1 and R2 are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SF` flag is set to 1 if R2 is *less* than R1 (R2 – R1 results in a negative
    value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OF` flag is set to 1 if the operation R2 – R1 results in an integer overflow
    (useful for signed comparisons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CF` flag is set to 1 if the operation R2 – R1 results in a carry operation
    (useful for unsigned comparisons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SF` and `OF` flags are used for comparison operations on signed integers,
    whereas the `CF` flag is used for comparisons on unsigned integers. Although an
    in-depth discussion of condition code flags is beyond the scope of this book,
    the setting of these registers by `cmp` and `test` enables the next set of instructions
    we cover (the *jump* instructions) to operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Jump Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A jump instruction enables a program’s execution to “jump” to a new position
    in the code. In the assembly programs we have traced through thus far, `%rip`
    always points to the next instruction in program memory. The jump instructions
    enable `%rip` to be set to either a new instruction not yet seen (as in the case
    of an `if` statement) or to a previously executed instruction (as in the case
    of a loop).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-12:** Direct Jump Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `jmp L` | Jump to location specified by L |'
  prefs: []
  type: TYPE_TB
- en: '| `jmp *addr` | Jump to specified address |'
  prefs: []
  type: TYPE_TB
- en: '**Direct jump instructions.**   [Table 7-12](ch07.xhtml#ch7tab12) lists the
    set of direct jump instructions; `L` refers to a *symbolic label*, which serves
    as an identifier in the program’s object file. All labels consist of some letters
    and digits followed by a colon. Labels can be *local* or *global* to an object
    file’s scope. Function labels tend to be *global* and usually consist of the function
    name and a colon. For example, `main:` (or `<main>:`) is used to label a user-defined
    `main` function. In contrast, labels whose scope are *local* are preceded by a
    period. For example, `.L1:` is a local label one may encounter in the context
    of an `if` statement or loop.'
  prefs: []
  type: TYPE_NORMAL
- en: All labels have an associated address. When the CPU executes a `jmp` instruction,
    it modifies `%rip` to reflect the program address specified by label `L`. A programmer
    writing assembly can also specify a particular address to jump to using the `jmp
    *` instruction. Sometimes, local labels are shown as an offset from the start
    of a function. Therefore, an instruction whose address is 28 bytes away from the
    start of `main` may be represented with the label `<main+28>`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the instruction `jmp 0x8048427 <main+28>` indicates a jump to address
    0x8048427, which has the associated label `<main+28>`, representing that it is
    28 bytes away from the starting address of the `main` function. Executing this
    instruction sets `%rip` to 0x8048427.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional jump instructions.**    The behavior of conditional jump instructions
    depends on the condition code registers set by the `cmp` instruction. [Table 7-13](ch07.xhtml#ch7tab13)
    lists the set of common conditional jump instructions. Each instruction starts
    with the letter `j` denoting that it is a jump instruction. The suffix of each
    instruction indicates the *condition* for the jump. The jump instruction suffixes
    also determine whether to interpret numerical comparisons as signed or unsigned.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-13:** Conditional Jump Instructions; Synonyms Shown in Parentheses'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signed Comparison** | **Unsigned Comparison** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `je` (`jz`) |  | jump if equal (==) or jump if zero |'
  prefs: []
  type: TYPE_TB
- en: '| `jne` (`jnz`) |  | jump if not equal (!=) |'
  prefs: []
  type: TYPE_TB
- en: '| `js` |  | jump if negative |'
  prefs: []
  type: TYPE_TB
- en: '| `jns` |  | jump if non-negative |'
  prefs: []
  type: TYPE_TB
- en: '| `jg` (`jnle`) | `ja` (`jnbe`) | jump if greater (>) |'
  prefs: []
  type: TYPE_TB
- en: '| `jge` (`jnl`) | `jae` (`jnb`) | jump if greater than or equal (>=) |'
  prefs: []
  type: TYPE_TB
- en: '| `jl` (`jnge`) | `jb` (`jnae`) | jump if less (<) |'
  prefs: []
  type: TYPE_TB
- en: '| `jle` (`jng`) | `jbe` (`jna`) | jump if less than or equal (<=) |'
  prefs: []
  type: TYPE_TB
- en: Instead of memorizing these different conditional jump instructions, it is more
    helpful to sound out the instruction suffixes. [Table 7-14](ch07.xhtml#ch7tab14)
    lists the letters commonly found in jump instructions and their word correspondence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-14:** Jump Instruction Suffixes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Letter** | **Word** |'
  prefs: []
  type: TYPE_TB
- en: '| `j` | jump |'
  prefs: []
  type: TYPE_TB
- en: '| `n` | not |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | equal |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | signed |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | greater (signed interpretation) |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | less (signed interpretation) |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | above (unsigned interpretation) |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | below (unsigned interpretation) |'
  prefs: []
  type: TYPE_TB
- en: Sounding it out, we can see that `jg` corresponds to *jump greater* and that
    its signed synonym `jnl` stands for *jump not less*. Likewise, the unsigned version
    `ja` stands for *jump above*, whereas its synonym `jnbe` stands for *jump not
    below or equal*.
  prefs: []
  type: TYPE_NORMAL
- en: If you sound out the instructions, it helps to explain why certain synonyms
    correspond to particular instructions. The other thing to remember is that the
    terms *greater* and *less* instruct the CPU to interpret the numerical comparison
    as a signed value, whereas *above* and *below* indicate that the numerical comparison
    is unsigned.
  prefs: []
  type: TYPE_NORMAL
- en: The goto statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the following subsections, we look at conditionals and loops in assembly
    and reverse engineer them back to C. When translating assembly code of conditionals
    and loops back into C, it is useful to understand the corresponding C language
    `goto` forms. The `goto` statement is a C primitive that forces program execution
    to switch to another line in the code. The assembly instruction associated with
    the `goto` statement is `jmp`.
  prefs: []
  type: TYPE_NORMAL
- en: The `goto` statement consists of the `goto` keyword followed by a *goto label*,
    a type of program label that indicates where execution should continue. So, `goto
    done` means that the program execution should jump to the line marked by label
    `done`. Other examples of program labels in C include the `switch` statement labels
    previously covered in “switch Statements” on [page 122](ch02.xhtml#lev2_36).
  prefs: []
  type: TYPE_NORMAL
- en: The following code listings depict a function `getSmallest` written in regular
    C code (first) and its associated `goto` form in C (second). The `getSmallest`
    function compares the values of two integers (`x` and `y`), and assigns the smaller
    value to the variable `smallest`.
  prefs: []
  type: TYPE_NORMAL
- en: Regular C version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: goto version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `goto` form of this function may seem counterintuitive, but let’s discuss
    what exactly is going on. The conditional checks to see whether variable `x` is
    less than or equal to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: If `x` is less than or equal to `y`, the program transfers control to the label
    marked by `else_statement`, which contains the single statement `smallest = x`.
    Since the program executes linearly, the program continues on to execute the code
    under the label `done`, which returns the value of `smallest` (`x`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `x` is greater than `y`, `smallest` is assigned the value `y`. The program
    then executes the statement `goto done`, which transfers control to the `done`
    label, which returns the value of `smallest` (`y`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `goto` statements were commonly used in the early days of programming,
    the use of `goto` statements in modern code is considered bad practice, as it
    reduces the overall readability of code. In fact, computer scientist Edsger Dijkstra
    wrote a famous paper lambasting the use of `goto` statements called “Go To Statement
    Considered Harmful.”^([1](ch07.xhtml#fn7_1))
  prefs: []
  type: TYPE_NORMAL
- en: In general, well-designed C programs do not use `goto` statements, and programmers
    are discouraged from using them to avoid writing code that is difficult to read,
    debug, and maintain. However, the C `goto` statement is important to understand,
    as GCC typically changes C code with conditionals into a `goto` form prior to
    translating it to assembly, including code that contains `if` statements and loops.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.2 if Statements in Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s take a look at the `getSmallest` function in assembly. For convenience,
    the function is reproduced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding assembly code extracted from GDB looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is a different view of the assembly code than we have seen before. Here,
    we can see the *address* associated with each instruction, but not the *bytes*.
    Note that this assembly segment has been lightly edited for the sake of simplicity.
    The instructions that are normally part of function creation (i.e., `push %rbp`,
    `mov %rsp,%rbp`) are removed. By convention, GCC places the first and second parameters
    of a function in registers `%rdi` and `%rsi`, respectively. Since the parameters
    to `getSmallest` are of type `int`, the compiler places the parameters in the
    respective component registers `%edi` and `%esi` instead. For the sake of clarity,
    we refer to these parameters as `x` and `y`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s trace through the first few lines of the previous assembly code snippet.
    Note that we will not draw out the stack explicitly in this example. We leave
    this as an exercise for the reader and encourage you to practice your stack tracing
    skills by drawing it out yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The first `mov` instruction copies the value located in register `%edi` (the
    first parameter, `x`) and places it at memory location `%rbp-0x14` on the call
    stack. The instruction pointer (`%rip`) is set to the address of the next instruction,
    or 0x40059d.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `mov` instruction copies the value located in register `%esi` (the
    second parameter, `y`) and places it at memory location `%rbp-0x18` on the call
    stack. The instruction pointer (`%rip`) updates to point to the address of the
    next instruction, or 0x4005a0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third `mov` instruction copies `x` to register `%eax`. Register `%rip` updates
    to point to the address of the next instruction in sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` instruction compares the value at location `%rbp-0x18` (the second
    parameter, `y`) to `x` and sets appropriate condition code flag registers. Register
    `%rip` advances to the address of the next instruction, or 0x4005a6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jle` instruction at address 0x4005a6 indicates that if `x` is less than
    or equal to `y`, the next instruction that should execute should be at location
    `<getSmallest+26>` and that `%rip` should be set to address 0x4005b0\. Otherwise,
    `%rip` is set to the next instruction in sequence, or 0x4005a8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next instructions to execute depend on whether the program follows the
    branch (i.e., executes the jump) at address 0x4005a6\. Let’s first suppose that
    the branch was *not* followed. In this case, `%rip` is set to 0x4005a8 (i.e.,
    `<getSmallest+18>`) and the following sequence of instructions executes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mov -0x18(%rbp), %eax` instruction at `<getSmallest+18>` copies `y` to
    register `%eax`. Register `%rip` advances to 0x4005ae.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jmp` instruction at `<getSmallest+24>` sets register `%rip` to address
    0x4005b9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last instructions to execute are the `pop` `%rbp` instruction and the `retq`
    instruction, which cleans up the stack and returns from the function call. In
    this case, `y` is in the return register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, suppose that the branch was taken at `<getSmallest+16>`. In other words,
    the `jle` instruction sets register `%rip` to 0x4005b0 (i.e., `<getSmallest+26>`).
    Then, the next instructions to execute are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mov -0x14(%rbp),%eax` instruction at address 0x4005b0 copies `x` to register
    `%eax`. Register `%rip` advances to 0x4005b9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last instructions that execute are `pop %rbp` and `retq`, which cleans up
    the stack and returns the value in the return register. In this case, component
    register `%eax` contains `x`, and `getSmallest` returns `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then annotate the preceding assembly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Translating this back to C code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Translated C code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In these code listings, the variable `smallest` corresponds to register `%eax`.
    If `x` is less than or equal to `y`, the code executes the statement `smallest
    = x`, which is associated with the `goto` label `assign_x` in our `goto` form
    of this function. Otherwise, the statement `smallest = y` is executed. The `goto`
    label `done` is used to indicate that the value in `smallest` should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the preceding C translation of the assembly code is a bit different
    from the original `getSmallest` function. These differences don’t matter; close
    inspection of both functions reveals that the two programs are logically equivalent.
    However, the compiler first converts any `if` statement into an equivalent `goto`
    form, which results in the slightly different but equivalent version. The following
    code examples show the standard `if` statement format and its equivalent `goto`
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: C if statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Compiler’s equivalent goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Compilers translating code into assembly designate a jump when a condition is
    true. Contrast this behavior with the structure of an `if` statement, where a
    “jump” (to the `else`) occurs when conditions are *not* true. The `goto` form
    captures this difference in logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the original `goto` translation of the `getSmallest` function,
    we can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x <= y` corresponds to `!*<condition>*`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`smallest = x` is the <else_statement>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `smallest = y` is the <then_statement>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line in the function is `return smallest`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rewriting the original version of the function with the preceding annotations
    yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This version is identical to the original `getSmallest` function. Keep in mind
    that a function written in different ways at the C code level can translate to
    the same set of assembly instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The cmov Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The last set of conditional instructions we cover are *conditional move* (`cmov`)
    instructions. The `cmp`, `test`, and `jmp` instructions implement a *conditional
    transfer of control* in a program. In other words, the execution of the program
    branches in many directions. This can be very problematic for optimizing code
    because these branches are very expensive.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the `cmov` instruction implements a *conditional transfer of data*.
    In other words, both the <then_statement> and <else_statement> of the conditional
    are executed, and the data is placed in the appropriate register based on the
    result of the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of C’s *ternary expression* often results in the compiler generating
    a `cmov` instruction in place of jumps. For the standard if-then-else statement,
    the ternary expression has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use this format to rewrite the `getSmallest` function as a ternary expression.
    Keep in mind that this new version of the function behaves exactly as the original
    `getSmallest` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although this may not seem like a big change, let’s look at the resulting assembly.
    Recall that the first and second parameters (`x` and `y`) are stored in registers
    `%edi` and `%esi`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This assembly code has no jumps. After the comparison of `x` and `y`, `x` moves
    into the return register only if `x` is less than or equal to `y`. Like the jump
    instructions, the suffix of the `cmov` instructions indicates the condition on
    which the conditional move occurs. [Table 7-15](ch07.xhtml#ch7tab15) lists the
    set of conditional move instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-15:** The `cmov` Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signed** | **Unsigned** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `cmove` (`cmovz`) |  | move if equal (==) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovne` (`cmovnz`) |  | move if not equal (!=) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovs` |  | move if negative |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovns` |  | move if non-negative |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovg` (`cmovnle`) | `cmova` (`cmovnbe`) | move if greater (>) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovge` (`cmovnl`) | `cmovae` (`cmovnb`) | move if greater than or equal
    (>=) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovl` (`cmovnge`) | `cmovb` (`cmovnae`) | move if less (<) |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovle` (`cmovng`) | `cmovbe` (`cmovna`) | move if less than or equal (<=)
    |'
  prefs: []
  type: TYPE_TB
- en: 'In the case of the original `getSmallest` function, the compiler’s internal
    optimizer (see [Chapter 12](ch12.xhtml#ch12)) will replace the jump instructions
    with a `cmov` instruction if level 1 optimizations are turned on (i.e., `-O1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the compiler is very cautious about optimizing jump instructions
    into `cmov` instructions, especially in cases where side effects and pointer values
    are involved. Here, we show two equivalent ways of writing a function, `incrementX`:'
  prefs: []
  type: TYPE_NORMAL
- en: C code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: C ternary form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each function takes a pointer to an integer as input and checks whether it is
    `NULL`. If `x` is not `NULL`, the function increments and returns the dereferenced
    value of `x`. Otherwise, the function returns the value 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is tempting to think that `incrementX2` uses a `cmov` instruction since
    it uses a ternary expression. However, both functions yield the exact same assembly
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the `cmov` instruction *executes both branches of the conditional*.
    In other words, `x` gets dereferenced no matter what. Consider the case where
    `x` is a null pointer. Recall that dereferencing a null pointer leads to a null
    pointer exception in the code, causing a segmentation fault. To prevent any chance
    of this happening, the compiler takes the safe road and uses jumps.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.3 Loops in Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like `if` statements, loops in assembly are also implemented using jump instructions.
    However, loops enable instructions to be *revisited* based on the result of an
    evaluated condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `sumUp` function shown in the following example sums up all the positive
    integers from 1 to a user-defined integer. This code is intentionally written
    suboptimally to illustrate a `while` loop in C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this code and disassembling it using GDB yields the following assembly
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Again, we will not draw out the stack explicitly in this example. However, we
    encourage readers to draw the stack out themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The First Five Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first five instructions of this function set the stack up for function
    execution and set up temporary values for function execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Recall that stack locations store *temporary variables* in a function. For simplicity
    we will refer to the location marked by `%rbp-0x8` as `total`, and `%rbp-0x4`
    as `i`. The input parameter to `sumUp` (`n`) is moved to stack location `%rbp-0x14`.
    Despite the placement of temporary variables on the stack, keep in mind that the
    stack pointer has not changed after the execution of the first instruction (i.e.,
    `push %rbp`).
  prefs: []
  type: TYPE_NORMAL
- en: The Heart of the Loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next seven instructions in the `sumUp` function represent the heart of
    the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction is a direct jump to `<sumUp+33>`, which sets the instruction
    pointer (`%rip`) to address 0x400547.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next instruction that executes is `mov -0x4(%rbp),%eax`, which places the
    value of `i` in register `%eax`. Register `%rip` is updated to 0x40054a.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` instruction at `<sumUp+36>` compares `i` to `n` and sets the appropriate
    condition code registers. Register `%rip` is set to 0x40054d.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jle` instruction then executes. The instructions that execute next depend
    on whether or not the branch is taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that the branch *is* taken (i.e., `i <= n` is true). Then the instruction
    pointer is set to 0x40053d and program execution jumps to `<sumUp+23>`. The following
    instructions then execute in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mov` instruction at `<sumUp+23>` copies `i` to register `%eax`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add %eax,-0x8(%rbp)` adds `i` to `total` (i.e., `total += i`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add` instruction at `<sumUp+29>` then adds 1 to `i` (i.e., `i += 1`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mov` instruction at `<sumUp+33>` copies the updated value of `i` to register
    `%eax`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` instruction then compares `i` to `n` and sets the appropriate condition
    code registers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, `jle` executes. If `i` is less than or equal to `n`, program execution
    once again jumps to `<sumUp+23>` and the loop (defined between `<sumUp+23>` and
    `<sumUp+39>`) repeats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the branch is *not* taken (i.e., `i` is *not* less than or equal to `n`),
    the following instructions execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These instructions copy `total` to register `%eax`, restore `%rbp` to its original
    value, and exit the function. Thus, the function returns `total` upon exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the assembly and then the C `goto` forms of the `sumUp`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: Assembly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Translated goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is also equivalent to the following C code without `goto`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: for Loops in Assembly
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The primary loop in the `sumUp` function can also be written as a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This version yields assembly code identical to our `while` loop example. We
    repeat the assembly code here and annotate each line with its English translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To understand why the `for` loop version of this code results in identical assembly
    to the `while` loop version of the code, recall that the `for` loop has the following
    representation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and is equivalent to the following `while` loop representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Since every `for` loop can be represented by a `while` loop (see “for Loops”
    on [page 35](ch01.xhtml#lev3_5)), the following two C programs are equivalent
    representations for the previous assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: For loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: While loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 7.5 Functions in Assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we traced through simple functions in assembly. In
    this section, we discuss the interaction between multiple functions in assembly
    in the context of a larger program. We also introduce some new instructions involved
    with function management.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with a refresher on how the call stack is managed. Recall that `%rsp`
    is the *stack pointer* and always points to the top of the stack. The register
    `%rbp` represents the base pointer (also known as the *frame pointer*) and points
    to the base of the current stack frame. The *stack frame* (also known as the *activation
    frame* or the *activation record*) refers to the portion of the stack allocated
    to a single function call. The currently executing function is always at the top
    of the stack, and its stack frame is referred to as the *active frame*. The active
    frame is bounded by the stack pointer (at the top of stack) and the frame pointer
    (at the bottom of the frame). The activation record typically holds local variables
    for a function. [Figure 7-4](ch07.xhtml#ch7fig4) shows the stack frames for `main`
    and a function it calls named `fname`. We will refer to the `main` function as
    the *caller* function and `fname` as the *callee* function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Stack frame management*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 7-4](ch07.xhtml#ch7fig4), the current active frame belongs to the
    callee function (`fname`). The memory between the stack pointer and the frame
    pointer is used for local variables. The stack pointer moves as local values are
    pushed and popped from the stack. In contrast, the frame pointer remains relatively
    constant, pointing to the beginning (the bottom) of the current stack frame. As
    a result, compilers like GCC commonly reference values on the stack relative to
    the frame pointer. In [Figure 7-4](ch07.xhtml#ch7fig4), the active frame is bounded
    below by the base pointer of `fname`, which is stack address 0x418\. The value
    stored at address 0x418 is the “saved” `%rbp` value (0x42c), which itself is an
    address that indicates the bottom of the activation frame for the `main` function.
    The top of the activation frame of `main` is bounded by the *return address*,
    which indicates where in the `main` function program execution resumes once the
    callee function `fname` finishes executing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning THE RETURN ADDRESS POINTS TO CODE SEGMENT MEMORY, NOT STACK MEMORY**'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the call stack region (stack memory) of a program is different from
    its code region (code segment memory). While `%rbp` and `%rsp` point to addresses
    in the stack memory, `%rip` points to an address in *code* segment memory. In
    other words, the return address is an address in code segment memory, not stack
    memory (see [Figure 7-5](ch07.xhtml#ch7fig5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: The parts of a program’s address space*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-16](ch07.xhtml#ch7tab16) contains several additional instructions
    that the compiler uses for basic function management.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-16:** Common Function Management Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `leaveq` | Prepares the stack for leaving a function. Equivalent to: |'
  prefs: []
  type: TYPE_TB
- en: '|  | `mov %rbp,%rsp` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `pop %rbp` |'
  prefs: []
  type: TYPE_TB
- en: '| `callq addr <fname>` | Switches active frame to callee function. Equivalent
    to: |'
  prefs: []
  type: TYPE_TB
- en: '|  | `push %rip` |'
  prefs: []
  type: TYPE_TB
- en: '|  | `mov addr, %rip` |'
  prefs: []
  type: TYPE_TB
- en: '| `retq` | Restores active frame to caller function. Equivalent to: |'
  prefs: []
  type: TYPE_TB
- en: '|  | `pop %rip` |'
  prefs: []
  type: TYPE_TB
- en: For example, the `leaveq` instruction function is a shorthand that the compiler
    uses to restore the stack and frame pointers as it prepares to leave a function.
    When the callee function finishes execution, `leaveq` ensures that the frame pointer
    is *restored* to its previous value.
  prefs: []
  type: TYPE_NORMAL
- en: The `callq` and `retq` instructions play a prominent role in the process where
    one function calls another. Both instructions modify the instruction pointer (register
    `%rip`). When the caller function executes the `callq` instruction, the current
    value of `%rip` is saved on the stack to represent the return address, or the
    program address at which the caller resumes executing once the callee function
    finishes. The `callq` instruction also replaces the value of `%rip` with the address
    of the callee function.
  prefs: []
  type: TYPE_NORMAL
- en: The `retq` instruction restores the value of `%rip` to the value saved on the
    stack, ensuring that the program resumes execution at the program address specified
    in the caller function. Any value returned by the callee is stored in `%rax` or
    one of its component registers (e.g., `%eax`). The `retq` instruction is usually
    the last instruction that executes in any function.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.1 Function Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike IA32, function parameters are typically preloaded into registers prior
    to a function call. [Table 7-17](ch07.xhtml#ch7tab17) lists the parameters to
    a function and the register (if any) that they are loaded into prior to a function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-17:** Locations of Function Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Location** |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter 1 | `%rdi` |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter 2 | `%rsi` |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter 3 | `%rdx` |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter 4 | `%rcx` |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter 5 | `%r8` |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter 6 | `%r9` |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter 7+ | on call stack |'
  prefs: []
  type: TYPE_TB
- en: The first six parameters to a function are loaded into registers `%rdi`, `%rsi`,
    `%rdx`, `%rcx`, `%r8`, and `%r9`, respectively. Any additional parameters are
    successively loaded into the call stack based on their size (4 byte offsets for
    32-bit data, 8 byte offsets for 64-bit data).
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.2 Tracing Through an Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using our knowledge of function management, let’s trace through the code example
    first introduced at the beginning of this chapter. Note that the `void` keyword
    is added to the parameter list of each function definition to specify that the
    functions take no arguments. This change does not modify the output of the program;
    however, it does simplify the corresponding assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We compile this code with the command `gcc -o prog prog.c` and use `objdump
    -d` to view the underlying assembly. The latter command outputs a pretty big file
    that contains a lot of information that we don’t need. Use `less` and the search
    functionality to extract the `adder`, `assign`, and `main` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Each function begins with a symbolic label that corresponds to its declared
    name in the program. For example, `<main>:` is the symbolic label for the `main`
    function. The address of a function label is also the address of the first instruction
    in that function. To save space in the figures that follow, we truncate addresses
    to the lower 12 bits. So, program address 0x400542 is shown as 0x542.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.3 Tracing Through main
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 7-6](ch07.xhtml#ch7fig6) shows the execution stack immediately prior
    to the execution of `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The initial state of the CPU registers and call stack prior to
    executing the main function*'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the stack grows toward lower addresses. In this example, `%rbp`
    initially is stack address 0x830, and `%rsp` initially is stack address 0xd48\.
    Both of these values are made up for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Since the functions shown in the previous example utilize integer data, we highlight
    component registers `%eax` and `%edi`, which initially contain junk values. The
    upper-left arrow indicates the currently executing instruction. Initially, `%rip`
    contains address 0x542, which is the program memory address of the first line
    in the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0332-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first instruction saves the current value of `%rbp` by pushing 0x830 onto
    the stack. Since the stack grows toward lower addresses, the stack pointer `%rsp`
    is updated to 0xd40, which is 8 bytes less than 0xd48\. `%rip` advances to the
    next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0332-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov %rsp,%rbp`) updates the value of `%rbp` to be the
    same as `%rsp`. The frame pointer (`%rbp`) now points to the start of the stack
    frame for the `main` function. `%rip` advances to the next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0333-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `sub` instruction subtracts 0x10 from the address of our stack pointer,
    which essentially causes the stack to “grow” by 16 bytes, which we represent by
    showing two 8-byte locations on the stack. Register `%rsp` therefore has the new
    value of 0xd30\. `%rip` advances to the next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0333-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `callq <assign>` instruction pushes the value inside register `%rip` (which
    denotes the address of the *next* instruction to execute) onto the stack. Since
    the next instruction after `callq <assign>` has an address of 0x55f, that value
    is pushed onto the stack as the return address. Recall that the return address
    indicates the program address where execution should resume when program execution
    returns to `main`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `callq` instruction moves the address of the `assign` function (0x526)
    into register `%rip`, signifying that program execution should continue into the
    callee function `assign` and not the next instruction in `main`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0334-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first two instructions that execute in the `assign` function are the usual
    book-keeping that every function performs. The first instruction pushes the value
    stored in `%rbp` (memory address 0xd40) onto the stack. Recall that this address
    points to the beginning of the stack frame for `main`. `%rip` advances to the
    second instruction in `assign`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0334-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov %rsp,%rbp`) updates `%rbp` to point to the top of
    the stack, marking the beginning of the stack frame for `assign`. The instruction
    pointer (`%rip`) advances to the next instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0335-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `mov` instruction at address 0x52a moves the value `$0x28` (or 40) onto
    the stack at address `-0x4(%rbp)`, which is four bytes above the frame pointer.
    Recall that the frame pointer is commonly used to reference locations on the stack.
    However, keep in mind that this operation does not change the value of `%rsp`—the
    stack pointer still points to address 0xd20\. Register `%rip` advances to the
    next instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0336-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `mov` instruction at address 0x531 places the value `$0x28` into register
    `%eax`, which holds the return value of the function. `%rip` advances to the `pop`
    instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0336-02.jpg) At this point, the `assign` function has almost
    completed execution. The next instruction that executes is `pop %rbp`, which restores
    `%rbp` to its previous value, or 0xd40\. Since the `pop` instruction modifies
    the stack pointer, `%rsp` updates to 0xd28.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0337-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last instruction in `assign` is a `retq` instruction. When `retq` executes,
    the return address is popped off the stack into register `%rip`. In our example,
    `%rip` now advances to point to the `callq` instruction in `main` at address 0x55f.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important things to notice at this juncture:'
  prefs: []
  type: TYPE_NORMAL
- en: The stack pointer and the frame pointer have been restored to their values prior
    to the call to `assign`, reflecting that the stack frame for `main` is once again
    the active frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The old values on the stack from the prior active stack frame are *not* removed.
    They still exist on the call stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](../images/f0338-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Back in `main`, the call to `adder` *overwrites* the old return address on the
    stack with a new return address (0x554). This return address points to the next
    instruction to be executed after `adder` returns, or `mov %eax,-0x4(%rbp)`. Register
    `%rip` updates to point to the first instruction to execute in `adder`, which
    is at address 0x536.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0338-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first instruction in the `adder` function saves the caller’s frame pointer
    (`%rbp` of `main`) on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0339-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction updates `%rbp` with the current value of `%rsp`, or address
    0xd20\. Together, these last two instructions establish the beginning of the stack
    frame for `adder`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0339-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pay close attention to the next instruction that executes. Recall that `$0x28`
    was placed on the stack during the call to `assign`. The instruction `mov $-0x4(%rbp),%eax`
    moves an *old* value that is on the stack into register `%eax`! This would not
    have occurred if the programmer had initialized variable `a` in the `adder` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0340-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `add` instruction at address 0x53d adds 2 to register `%eax`. Recall that
    when a 32-bit integer is being returned, x86-64 utilizes component register `%eax`
    instead of `%rax`. Together the last two instructions are equivalent to the following
    code in `adder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![image](../images/f0341-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After `pop` executes, the frame pointer again points to the beginning of the
    stack frame for `main`, or address 0xd40\. The stack pointer now contains the
    address 0xd28.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0341-02.jpg) The execution of `retq` pops the return address
    off the stack, restoring the instruction pointer back to 0x554, or the address
    of the next instruction to execute in `main`. The address contained in `%rsp`
    is now 0xd30.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0342-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Back in `main`, the `mov %eax,-0x4(%rbp)` instruction places the value in `%eax`
    at a location four bytes above `%rbp`, or at address 0xd3c. The next instruction
    replaces it back into register `%eax`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0342-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Skipping ahead a little, the `mov` instruction at address 0x55a copies the value
    in `%eax` (or 0x2A) to register `%esi`, which is the 32-bit component register
    associated with `%rsi` and typically stores the second parameter to a function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0343-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov $0x400604,%edi`) copies a constant value (an address
    in code segment memory) to register `%edi`. Recall that register `%edi` is the
    32-bit component register of `%rdi`, which typically stores the first parameter
    to a function. The code segment memory address 0x400604 is the base address of
    the string `"x is %d\n"`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0344-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction resets register `%eax` with the value 0\. The instruction
    pointer advances to the call to the `printf` function (which is denoted with the
    label `<printf@plt>`).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0344-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next instruction calls the `printf` function. For the sake of brevity,
    we will not trace the `printf` function, which is part of `stdio.h`. However,
    we know from the manual page (`man -s3 printf`) that `printf` has the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the first argument is a pointer to a string specifying the
    format, and the second argument onward specify the values that are used in that
    format. The instructions specified by addresses 0x55a–0x566 correspond to the
    following line in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `printf` function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: A return address specifying the instruction that executes after the call to
    `printf` is pushed onto the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `%rbp` is pushed onto the stack, and `%rbp` is updated to point
    to the top of the stack, indicating the beginning of the stack frame for `printf`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point, `printf` references its arguments, which are the string `"x is`
    `%d\n"` and the value 0x2A. The first parameter is stored in component register
    `%edi`, and the second parameter is stored in component register `%esi`. The return
    address is located directly below `%rbp` at location `%rbp+8`.
  prefs: []
  type: TYPE_NORMAL
- en: For any function with *n* arguments, GCC places the first six arguments in registers,
    as shown in [Table 7-17](ch07.xhtml#ch7tab17), and the remaining arguments onto
    the stack *below* the return address.
  prefs: []
  type: TYPE_NORMAL
- en: After the call to `printf`, the value 0x2A is output to the user in integer
    format. Thus, the value 42 is printed to the screen!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0345-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After the call to `printf`, the last few instructions clean up the stack and
    prepare a clean exit from the `main` function. First, the `mov` instruction at
    address 0x56b ensures that 0 is in the return register (since the last thing `main`
    does is return 0).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0346-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `leaveq` instruction prepares the stack for returning from the function
    call. Recall that `leaveq` is analogous to the following pair of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the CPU overwrites the stack pointer with the frame pointer.
    In our example, the stack pointer is initially updated from 0xd30 to 0xd40\. Next,
    the CPU executes `pop %rbp`, which takes the value located at 0xd40 (in our example,
    the address 0x830) and places it in `%rbp`. After `leaveq` executes, the stack
    and frame pointers revert to their original values prior to the execution of `main`.
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction that executes is `retq`. With 0x0 in the return register
    `%eax`, the program returns zero, indicating correct termination.
  prefs: []
  type: TYPE_NORMAL
- en: If you have carefully read through this section, you should understand why our
    program prints out the value 42\. In essence, the program inadvertently uses old
    values on the stack to cause it to behave in a way that we didn’t expect. This
    example was pretty harmless; however, we discuss in future sections how hackers
    have misused function calls to make programs misbehave in truly malicious ways.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursive functions are a special class of functions that call themselves (also
    known as *self-referential* functions) to compute a value. Like their nonrecursive
    counterparts, recursive functions create new stack frames for each function call.
    Unlike standard functions, recursive functions contain function calls to themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the problem of summing up the set of positive integers from 1
    to *n*. In previous sections, we discussed the `sumUp` function to achieve this
    task. The following code listings show a related function called `sumDown`, which
    adds the numbers in reverse (*n* to 1), and its recursive equivalent `sumr`:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterative
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Recursive
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The base case in the recursive function `sumr` accounts for any values of *n*
    that are less than one. The recursive step calls `sumr` with the value *n –* 1
    and adds the result to *n* prior to returning. Compiling `sumr` and disassembling
    it with GDB yields the following assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in the preceding assembly code is annotated with its English translation.
    Here, we show the corresponding `goto` form (first) and C program without `goto`
    statements (second):'
  prefs: []
  type: TYPE_NORMAL
- en: C goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: C version without goto
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Although this translation may not initially appear to be identical to the original
    `sumr` function, close inspection reveals that the two functions are indeed equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '7.6.1 Animation: Observing How the Call Stack Changes'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an exercise, we encourage you to draw out the stack and see how the values
    change. We have provided an animation online that depicts how the stack is updated
    when we run this function with the value 3.^([2](ch07.xhtml#fn7_2))
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that arrays (see “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9))
    are ordered collections of data elements of the same type that are contiguously
    stored in memory. Statically allocated single-dimension arrays (see “Single-Dimensional
    Arrays” on [page 81](ch02.xhtml#lev2_22)) have the form <type> `arr[N]`, where
    <type> is the data type, `arr` is the identifier associated with the array, and
    `N` is the number of data elements. Declaring an array statically as <type> `arr[N]`
    or dynamically as `arr = malloc(N * sizeof(` <type>`))` allocates `N` × `sizeof(`
    <type>`)` total bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: To access the element at index `i` in array `arr`, use the syntax `arr[i]`.
    Compilers commonly convert array references into pointer arithmetic (see “Pointer
    Variables” on [page 67](ch02.xhtml#lev2_17)) prior to translating to assembly.
    So, `arr+i` is equivalent to `&arr[i]`, and `*(arr+i)` is equivalent to `arr[i]`.
    Since each data element in `arr` is of type <type>, `arr+i` implies that element
    `i` is stored at address `arr` + `sizeof(` <type>`)` × `i`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-18](ch07.xhtml#ch7tab18) outlines some common array operations and
    their corresponding assembly instructions. In the examples that follow, suppose
    that we declare an `int` array of length 10 (`int arr[10]`). Assume that register
    `%rdx` stores the address of `arr`, register `%rcx` stores the `int` value `i`,
    and register `%rax` represents some variable `x` (also of type `int`). Recall
    that `int` variables take up four bytes of space, whereas `int *` variables take
    up eight bytes of space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-18:** Common Array Operations and Their Corresponding Assembly Representations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Type** | **Assembly Representation** |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr` | `int *` | `mov %rdx,%rax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr[0]` | `int` | `mov (%rdx),%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr[i]` | `int` | `mov (%rdx,%rcx,4),%eax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = &arr[3]` | `int *` | `lea 0xc(%rdx),%rax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr+3` | `int *` | `lea 0xc(%rdx),%rax` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = *(arr+5)` | `int` | `mov 0x14(%rdx),%eax` |'
  prefs: []
  type: TYPE_TB
- en: Pay close attention to the *type* of each expression in [Table 7-18](ch07.xhtml#ch7tab18).
    In general, the compiler uses `mov` instructions to dereference pointers and the
    `lea` instruction to compute addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that to access element `arr[3]` (or `*(arr+3)` using pointer arithmetic),
    the compiler performs a memory lookup on address `arr+3*4` instead of `arr+3`.
    To understand why this is necessary, recall that any element at index `i` in an
    array is stored at address `arr + sizeof(` <type>`) * i`. The compiler must therefore
    multiply the index by the size of the data type (in this case four, since `sizeof(int)`
    = 4) to compute the correct offset. Recall also that memory is byte-addressable;
    offsetting by the correct number of bytes is the same as computing an address.
    Lastly, because `int` values require only four bytes of space, they are stored
    in component register `%eax` of register `%rax`.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a sample array (`array`) with 10 integer elements ([Figure
    7-7](ch07.xhtml#ch7fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: The layout of a 10-integer array in memory. Each *x*[*i*]-labeled
    box represents four bytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that since `array` is an array of integers, each element takes up exactly
    four bytes. Thus, an integer array with 10 elements consumes 40 bytes of contiguous
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the address of element 3, the compiler multiplies the index 3 by
    the data size of the integer type (4) to yield an offset of 12 (or 0xc). Sure
    enough, element 3 in [Figure 7-7](ch07.xhtml#ch7fig7) is located at byte offset
    *x*[12].
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple C function called `sumArray` that sums up all
    the elements in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sumArray` function takes the address of an array and the array’s associated
    length and sums up all the elements in the array. Now take a look at the corresponding
    assembly for the `sumArray` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When tracing this assembly code, consider whether the data being accessed represents
    an address or a value. For example, the instruction at `<sumArray+11>` results
    in `%rbp-0x4` containing a variable of type `int`, which is initially set to 0\.
    In contrast, the argument stored at `%rbp-0x18` is the first argument to the function
    (`array`) which is of type `int *` and corresponds to the base address of the
    array. A different variable (which we call `i`) is stored at location `%rbp-0x8`.
    Lastly, note that size suffixes are included at the end of instructions like `add`
    and `mov` only when necessary. In cases where constant values are involved, the
    compiler needs to explicitly state how many bytes of the constant are being moved.
  prefs: []
  type: TYPE_NORMAL
- en: The astute reader will notice a previously unseen instruction at line `<sumArray+30>`
    called `cltq`. The `cltq` instruction stands for “convert long to quad” and converts
    the 32-bit `int` value stored in `%eax` to a 64-bit integer value that is stored
    in `%rax`. This operation is necessary because the instructions that follow perform
    pointer arithmetic. Recall that on 64-bit systems, pointers take up 8 bytes of
    space. The compiler’s use of `cltq` simplifies the process by ensuring that all
    data are stored in 64-bit registers instead of 32-bit components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the five instructions between locations `<sumArray+32>`
    and `<sumArray+49>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the compiler commonly uses `lea` to perform simple arithmetic on
    operands. The operand `0x0(,%rax,4)` translates to `%rax*4 + 0x0`. Since `%rax`
    holds the value of `i`, this operation copies the value `i*4` to `%rdx`. At this
    point, `%rdx` contains the number of bytes to calculate the correct offset of
    `array[i]` (recall that `sizeof(int)` = 4).
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction (`mov -0x18(%rbp),%rax`) copies the first argument to the
    function (the base address of `array`) into register `%rax`. Adding `%rdx` to
    `%rax` in the next instruction causes `%rax` to contain `array+i*4`. Recall that
    the element at index `i` in `array` is stored at address `array + sizeof(` <type>`)
    * i`. Therefore, `%rax` now contains the assembly-level computation of the address
    `&array[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction at `<sumArray+47>` *dereferences* the value located at `%rax`,
    placing the value of `array[i]` into `%eax`. Notice the use of the component register
    `%eax`, since `array[i]` contains a 32-bit `int` value! In contrast, the variable
    `i` was changed to a quad-word on line `<sumArray+30>` since `i` was about to
    be used for *address computation*. Again, addresses are stored as 64-bit words.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, `%eax` is added to the value in `%rbp-0x4`, or `total`. Therefore, the
    five instructions between locations `<sumArray+22>` and `<sumArray+39>` correspond
    to the line `total += array[i]` in the `sumArray` function.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 Matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A matrix is a two-dimensional array. A matrix in C can be statically allocated
    as a two-dimensional array (`M[n][m]`), dynamically allocated with a single call
    to `malloc`, or dynamically allocated as an array of arrays. Let’s consider the
    array of arrays implementation. The first array contains `n` elements (`M[n]`),
    and each element `M[i]` in our matrix contains an array of `m` elements. The following
    code snippets each declare matrices of size 4 × 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the dynamically allocated matrix, the main array contains a contiguous
    array of `int` pointers. Each integer pointer points to a different array in memory.
    [Figure 7-8](ch07.xhtml#ch7fig8) illustrates how we would normally visualize each
    of these matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Illustration of a statically allocated (`M1`) and a dynamically
    allocated (`M2`) 3 × 4 matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: For both of these matrix declarations, element (*i*,*j*) can be accessed using
    the double-indexing syntax `M[i][j]`, where `M` is either `M1` or `M2`. However,
    these matrices are organized differently in memory. Even though both store the
    elements in their primary array contiguously in memory, our statically allocated
    matrix also stores all the rows contiguously in memory, as shown in [Figure 7-9](ch07.xhtml#ch7fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Matrix `M1`’s memory layout in row-major order*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This contiguous ordering is not guaranteed for `M2`. Recall (from “Two-Dimensional
    Array Memory Layout” on [page 86](ch02.xhtml#lev3_13)) that to contiguously allocate
    an *n* × *m* matrix on the heap, we should use a single call to `malloc` that
    allocates *n* × *m* elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Recall that with the declaration of `M3`, element (*i*,*j*) *cannot* be accessed
    using the `M[i][j]` notation. Instead, we must index the element using the format
    `M3[i*COLS + j]`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.1 Contiguous Two-Dimensional Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a function `sumMat` that takes a pointer to a contiguously allocated
    (either statically allocated or memory-efficiently dynamically allocated) matrix
    as its first parameter, along with the numbers of rows and columns, and returns
    the sum of all the elements inside the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: We use scaled indexing in the code snippet that follows because it applies to
    both statically and dynamically allocated contiguous matrices. Recall that the
    syntax `m[i][j]` does not work with the memory-efficient contiguous dynamic allocation
    previously discussed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the corresponding assembly. Each line is annotated with its English
    translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The local variables `i`, `j`, and `total` are loaded at addresses `%rbp-0xc`,
    `%rbp-0x8`, and `%rbp-0x4` on the stack, respectively. The input parameters `m`,
    `row`, and `cols` are stored at locations `%rbp-0x8`, `%rbp-0x1c`, and `%rbp-0x20`,
    respectively. Using this knowledge, let’s zoom in on the component that just deals
    with the access of element (*i*,*j*) in our matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first set of instructions calculates the value `i*cols` and places it in
    register `%edx`. Recall that for a matrix named `matrix`, `matrix + (i*cols)`
    is equivalent to `&matrix[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The next set of instructions computes `(i*cols + j)*4`. The compiler multiplies
    the index `i*cols+j` by four since each element in the matrix is a four-byte integer,
    and this multiplication enables the compiler to compute the correct offset. The
    `cltq` instruction on line `<sumMat+53>` is needed to sign-extend the contents
    of `%eax` into a 64-bit integer, since that is about to be used for address calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the following set of instructions adds the calculated offset to the matrix
    pointer and dereferences it to yield the value of element (*i*,*j*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction loads the address of matrix `m` into register `%rax`.
    The `add` instruction adds `(i*cols + j)*4` to the address of `m` to correctly
    calculate the offset of element (*i*,*j*). The third instruction dereferences
    the address in `%rax` and places the value in `%eax`. Notice the use of `%eax`
    as the destination component register; since our matrix contains integers, and
    an integer takes up four bytes of space, component register `%eax` is again used
    instead of `%rax`.
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction adds the value in `%eax` to the accumulator `total`, which
    is located at stack address `%rbp-0x4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider how element (1,2) is accessed in [Figure 7-9](ch07.xhtml#ch7fig9).
    For convenience, the figure is reproduced here in [Figure 7-10](ch07.xhtml#ch7fig10):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Matrix `M1`’s memory layout in row-major order*'
  prefs: []
  type: TYPE_NORMAL
- en: Element (1,2) is located at address `M1 + 1*COLS + 2`. Since `COLS` = 3, element
    (1,2) corresponds to `M1+5`. To access the element at this location, the compiler
    must multiply 5 by the size of the `int` data type (four bytes), yielding the
    offset `M1+20`, which corresponds to byte *x*[20] in the figure. Dereferencing
    this location yields element 5, which is indeed element (1,2) in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.2 Noncontiguous Matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The noncontiguous matrix implementation is a bit more complicated. [Figure 7-11](ch07.xhtml#ch7fig11)
    visualizes how `M2` may be laid out in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Matrix `M2`’s noncontiguous layout in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the array of pointers is contiguous, and that each array pointed
    to by an element of `M2` (e.g., `M2[i]`) is contiguous. However, the individual
    arrays are not contiguous with one another. Since `M2` is an array of pointers,
    each element of `M2` takes eight bytes of space. In contrast, since `M2[i]` is
    an `int` array, each element of `M2[i]` is four bytes away.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sumMatrix` function in the following example takes an array of integer
    pointers (called `matrix`) as its first parameter, and a number of rows and columns
    as its second and third parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Even though this function looks nearly identical to the `sumMat` function shown
    earlier, the matrix accepted by this function consists of a contiguous array of
    *pointers*. Each pointer contains the address of a separate contiguous array,
    which corresponds to a separate row in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding assembly for `sumMatrix` follow. Each line is annotated with
    its English translation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the variables `i`, `j`, and `total` are at stack addresses `%rbp-0xc`,
    `%rbp-0x8`, and `%rbp-0x4`, respectively. The input parameters `matrix`, `row`,
    and `cols` are located at stack addresses `%rbp-0x18`, `%rbp-0x1c`, and `%rbp-0x20`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s zoom in on the section that deals specifically with an access to element
    (*i*,*j*), or `matrix[i][j]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The five instructions in this example compute `matrix[i]`, or `*(matrix+i)`.
    Since `matrix[i]` contains a pointer, `i` is first converted to a 64-bit integer.
    Then, the compiler multiplies `i` by eight prior to adding it to `matrix` to calculate
    the correct address offset (recall that pointers are eight bytes in size). The
    instruction at `<sumMatrix+59>` then dereferences the calculated address to get
    the element `matrix[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `matrix` is an array of `int` pointers, the element located at `matrix[i]`
    is itself an `int` pointer. The *j*th element in `matrix[i]` is located at offset
    *j* × 4 in the `matrix[i]` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of instructions extract the *j*th element in array `matrix[i]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction in this snippet loads variable `j` into register `%edx`.
    The `movslq` instruction at `<sumMatrix+65>` converts `%edx` into a 64-bit integer,
    storing the result in 64-bit register `%rdx`. The compiler then uses the left
    shift (`shl`) instruction to multiply `j` by four and stores the result in register
    `%rdx`. The compiler finally adds the resulting value to the address located in
    `matrix[i]` to get the address of element `matrix[i][j]`. The instructions at
    `<sumMatrix+75>` and `<sumMatrix+77>` obtain the value at `matrix[i][j]` and add
    the value to `total`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit [Figure 7-11](ch07.xhtml#ch7fig11) and consider an example access
    to M2[1][2]. For convenience, we reproduce the figure in [Figure 7-12](ch07.xhtml#ch7fig12):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Matrix `M2`’s noncontiguous layout in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `M2` starts at memory location *x*[0]. The compiler first computes
    the address of `M2[1]` by multiplying 1 by 8 (`sizeof(int *)`) and adding it to
    the address of `M2` (*x*[0]), yielding the new address *x*[8]. A dereference of
    this address yields the address associated with `M2[1]`, or *x*[36]. The compiler
    then multiplies index 2 by 4 (`sizeof(int)`), and adds the result (8) to *x*[36],
    yielding a final address of *x*[44]. The address *x*[44] is dereferenced, yielding
    the value 5\. Sure enough, the element in [Figure 7-11](ch07.xhtml#ch7fig11) that
    corresponds to `M2[1][2]` has the value 5.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 structs in Assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `struct` (see “C Structs” on [page 103](ch02.xhtml#lev1_15)) is another way
    to create a collection of data types in C. Unlike arrays, structs enable different
    data types to be grouped together. C stores a `struct` like a single-dimension
    array, where the data elements (fields) are stored contiguously. Let’s revisit
    `struct studentT` from [Chapter 1](ch01.xhtml#ch01):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-13](ch07.xhtml#ch7fig13) shows how `student` is laid out in memory.
    Each *x*[*i*] denotes the address of a particular field.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: The memory layout of `struct studentT`*'
  prefs: []
  type: TYPE_NORMAL
- en: The fields are stored contiguously next to one another in memory in the order
    in which they are declared. In [Figure 7-13](ch07.xhtml#ch7fig13), the `age` field
    is allocated at the memory location directly after the `name` field (at byte offset
    *x*[64]) and is followed by the `grad_yr` (byte offset *x*68) and `gpa` (byte
    offset *x*[72]) fields. This organization enables memory-efficient access to the
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the compiler generates assembly code to work with a `struct`,
    consider the function `initStudent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initStudent` function uses the base address of a `struct studentT` as
    its first parameter, and the desired values for each field as its remaining parameters.
    The following listing depicts this function in assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Being mindful of the byte offsets of each field is key to understanding this
    code. Here are a few things to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The `strncpy` call takes the base address of the `name` field of `s`, the address
    of array `nm`, and a length specifier as its three arguments. Recall that because
    `name` is the first field in the `struct studentT`, the address of `s` is synonymous
    with the address of `s->name`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet contains the previously undiscussed register (`%xmm0`) and
    instruction (`movss`). The `%xmm0` register is an example of a register reserved
    for floating-point values. The `movss` instruction indicates that the data being
    moved onto the call stack is of type single-precision floating point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part (instructions `<initStudent+51>` through `<initStudent+58>`)
    places the value of the `gr` parameter at an offset of 0x44 (or 68) from the start
    of `s`. Revisiting the memory layout in [Figure 7-13](ch07.xhtml#ch7fig13) shows
    that this address corresponds to `s->grad_yr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section (instructions `<initStudent+61>` through `<initStudent+68>`)
    copies the `ag` parameter to the `s->age` field of the `struct`, which is located
    at an offset of 0x40 (or 64) bytes from the address of `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `g` parameter value is copied to the `s->gpa` field (byte offset
    72 or 0x48) of the `struct`. Notice the use of the `%xmm0` register since the
    data contained at location `%rbp-0x1c` is single-precision floating point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 7.9.1 Data Alignment and structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following modified declaration of `struct studentT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The size of the `name` field is modified to be 63 bytes, instead of the original
    64\. Consider how this affects the way the `struct` is laid out in memory. It
    may be tempting to visualize it as in [Figure 7-14](ch07.xhtml#ch7fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: An incorrect memory layout for the updated `struct` `studentTM`.
    Note that the `name` field is reduced from 64 to 63 bytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this depiction, the `age` field occurs in the byte immediately following
    the `name` field. But this is incorrect. [Figure 7-15](ch07.xhtml#ch7fig15) depicts
    the actual layout in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: The correct memory layout for the updated `struct` `studentTM`.
    Byte *x*[63] is added by the compiler to satisfy memory alignment constraints,
    but it doesn’t correspond to any of the fields.*'
  prefs: []
  type: TYPE_NORMAL
- en: x64’s alignment policy requires that two-byte data types (that is, `short`)
    reside at a two-byte-aligned address, four-byte data types (i.e., `int`, `float`,
    and `unsigned`) reside at four-byte-aligned addresses, whereas larger data types
    (`long`, `double`, and pointer data) reside at eight-byte-aligned addresses. For
    a `struct`, the compiler adds empty bytes as *padding* between fields to ensure
    that each field satisfies its alignment requirements. For example, in the `struct`
    declared in [Figure 7-15](ch07.xhtml#ch7fig15) the compiler adds a byte of padding
    at byte *x*[63] to ensure that the `age` field starts at an address that is at
    a multiple of four. Values aligned properly in memory can be read or written in
    a single operation, enabling greater efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens when a `struct` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Moving the `name` array to the end ensures that `age`, `grad_yr`, and `gpa`
    are four-byte aligned. Most compilers will remove the filler byte at the end of
    the `struct`. However, if the `struct` is ever used in the context of an array
    (e.g., `struct studentTM courseSection[20];`) the compiler will once again add
    the filler byte as padding between each `struct` in the array to ensure that alignment
    requirements are properly met.
  prefs: []
  type: TYPE_NORMAL
- en: '7.10 Real World: Buffer Overflow'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C language does not perform automatic array bounds checking. Accessing memory
    outside of the bounds of an array is problematic and often results in errors such
    as segmentation faults. However, a clever attacker can inject malicious code that
    intentionally overruns the boundary of an array (also known as a *buffer*) to
    force the program to execute in an unintended manner. In the worst cases, the
    attacker can run code that allows them to gain *root privilege*, or OS-level access
    to the computer system. A piece of software that takes advantage of the existence
    of a known buffer overrun error in a program is known as a *buffer overflow exploit*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we use GDB and assembly language to fully characterize the
    mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage
    you to explore “Debugging Assembly Code” on [page 177](ch03.xhtml#lev1_24).
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.1 Famous Examples of Buffer Overflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Buffer overflow exploits emerged in the 1980s and remained a chief scourge of
    the computing industry through the early parts of the 2000s. While many modern
    operating systems have protections against the simplest buffer overflow attacks,
    careless programming errors can still leave modern programs wide open to attack.
    Buffer overflow exploits have recently been discovered in Skype,^([3](ch07.xhtml#fn7_3))
    Android,^([4](ch07.xhtml#fn7_4)) Google Chrome,^([5](ch07.xhtml#fn7_5)) and others.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some notable historic examples of buffer overflow exploits.
  prefs: []
  type: TYPE_NORMAL
- en: The Morris Worm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Morris Worm^([6](ch07.xhtml#fn7_6)) was released in 1998 on ARPANet from
    MIT (to hide that it was written by a student at Cornell) and exploited a buffer
    overrun vulnerability that existed in the Unix finger daemon (`fingerd`). In Linux
    and other Unix-like systems, a *daemon* is a type of process that continuously
    executes in the background, usually performing clean-up and monitoring tasks.
    The `fingerd` daemon returns a user-friendly report on a computer or person. Most
    crucially, the worm had a replication mechanism that caused it to be sent to the
    same computer multiple times, bogging down the system to an unusable state. Although
    the author claimed that the worm was meant as a harmless intellectual exercise,
    the replication mechanism enabled the worm to spread easily and made it difficult
    to remove. In future years, other worms would employ buffer overflow exploits
    to gain unauthorized access into systems. Notable examples include Code Red (2001),
    MS-SQLSlammer (2003), and W32/Blaster (2003).
  prefs: []
  type: TYPE_NORMAL
- en: AOL Chat Wars
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: David Auerbach,^([7](ch07.xhtml#fn7_7)) a former Microsoft engineer, detailed
    his experience with a buffer overflow during his efforts to integrate Microsoft’s
    Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then,
    AOL Instant Messenger (AIM) was *the* service to use if you wanted to instant
    message (or IM) friends and family. Microsoft tried to gain a foothold in this
    market by designing a feature in MMS that enabled MMS users to talk to their AIM
    “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect
    to them. Microsoft engineers figured out a way for MMS clients to mimic the messages
    sent by AIM clients to AOL servers, making it difficult for AOL to distinguish
    between messages received by MMS and AIM. AOL responded by changing the way AIM
    sent messages, and MMS engineers duly changed their client’s messages to once
    again match AIM’s. This “chat war” continued until AOL started using a buffer
    overflow error *in their own client* to verify that sent messages came from AIM
    clients. Since MMS clients did not have the same vulnerability, the chat wars
    ended, with AOL as the victor.
  prefs: []
  type: TYPE_NORMAL
- en: '7.10.2 A First Look: The Guessing Game'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To help you understand the mechanism of the buffer overflow attack, we provide
    the executable of a simple program that enables the user to play a guessing game
    with the program. Download the `secret` executable^([8](ch07.xhtml#fn7_8)) and
    extract it using the `tar` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following, we provide a copy of the main file associated with the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: main.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This game prompts the user to enter first a secret number and then a secret
    string to win the guessing game. The header file `other.h` contains the definition
    of the `getSecretCode` and `calculateValue` functions, but it is unavailable to
    us. How then can a user beat the program? Brute forcing the solution will take
    too long. One strategy is to analyze the `secret` executable in GDB and step through
    the assembly to reveal the secret number and string. The process of examining
    assembly code to reveal knowledge of how it works is commonly referred to as *reverse
    engineering* assembly. Readers comfortable enough with their GDB and assembly
    reading skills should be able to figure out what the secret number and the secret
    string should be by using GDB to reverse engineer their values.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a different, sneakier way to win.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.3 Taking a Closer Look (Under the C)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program contains a potential buffer overrun vulnerability at the first call
    to `scanf`. To understand what is going on, let’s inspect the assembly code of
    the `main` function using GDB. Let’s also place a breakpoint at address 0x0000000000400717,
    which is the address of the instruction immediately before the call to `scanf`
    (note that placing the breakpoint at the address of `scanf` causes program execution
    to halt *inside* the call to `scanf`, not in `main`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-16](ch07.xhtml#ch7fig16) depicts the stack immediately before the
    call to `scanf`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: The call stack immediately before the call to `scanf`*'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the call to `scanf`, the first two arguments for `scanf` are preloaded
    into registers `%edi` and `%rsi`, respectively. The `lea` instruction at location
    `<main+25>` creates the reference for array `buf`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that the user enters `1234567890` at the prompt. [Figure 7-17](ch07.xhtml#ch7fig17)
    illustrates what the stack looks like immediately after the call to `scanf` completes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: The call stack immediately after the call to `scanf` with input
    `1234567890`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the hex values for the ASCII encodings of the digits 0 to 9 are
    0x30 to 0x39, and that each stack memory location is eight bytes long. The frame
    pointer is 32 bytes away from the stack pointer. Readers tracing along can confirm
    the value of `%rbp` by using GDB to print its value (`p` `$rbp`). In the example
    shown, the value of `%rbp` is 0x7fffffffdd10\. The following command allows the
    reader to inspect the 48 bytes (in hex) below `%rsp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This GDB command yields output that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Each line represents one 64-bit address, or two 32-bit addresses. So, the value
    associated with the 32-bit address 0x7fffffffdd0c is located at the rightmost
    four bytes of the line showing 0x7fffffffdd08.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding assembly segment, the byte at address 0xf7ffffffdd00 is 0xf0,
    the byte at address 0xf7ffffffdd01 is 0xdd, the byte at address 0xf7ffffffdd02
    is 0xff, the byte at address 0xf7ffffffdd03 is 0xff, the byte at address 0xf7ffffffdd04
    is 0xff, and the byte at address 0xf7ffffffdd05 is 0x7f. However, the 64-bit *value*
    at address 0x7fffffffdd00 is in fact 0x7fffffffddf0\. Remember that since x86-64
    is a little-endian system (see “Integer Byte Order” on [page 224](ch04.xhtml#lev1_34)),
    the bytes for multibyte values such as addresses are stored in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the address for `buf` is located at the top of the stack.
    Therefore, the first two addresses hold the inputted bytes associated with the
    input string 1234567890:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The null termination byte `\0` appears in the third most significant byte location
    at address 0x7fffffffdcf8 (i.e., at address 0x7fffffffdcfa). Recall that `scanf`
    terminates all strings with a null byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, 1234567890 is not the secret number. Here is the output when we
    try to run `secret` with input string 1234567890:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `echo $?` command prints out the return value of the last executed command
    in the shell. In this case, the program returned 1 because the secret number we
    entered is wrong. Recall that by convention, programs return 0 when there are
    no errors. Our goal going forward is to trick the program into exiting with a
    return value of 0, indicating that we won the game.
  prefs: []
  type: TYPE_NORMAL
- en: '7.10.4 Buffer Overflow: First Attempt'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, let’s try typing in the string 1234567890123456789012345678901234567890123:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Interesting! Now the program crashes with a segmentation fault, with return
    code 139\. [Figure 7-18](ch07.xhtml#ch7fig18) shows what the call stack for `main`
    looks like immediately after the call to `scanf` with this new input.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: The call stack immediately after the call to `scanf` with input
    1234567890123456789012345678901234567890123*'
  prefs: []
  type: TYPE_NORMAL
- en: The input string is so long that it not only overwrote the values stored at
    0xd08 and 0xd10, but it spilled over into the return address below the stack frame
    for `main`. Recall that when a function returns, the program tries to resume execution
    at the address specified by the return address. In this example, the program tries
    to resume execution at address 0xf7ff00333231 after exiting `main`, which does
    not appear to exist. So the program crashes with a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the program in GDB (`input.txt` contains the input string above)
    reveals this devilry in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our input string blew past the stated limits of the array `buf`,
    overwriting all the other values stored on the stack. In other words, our string
    created a buffer overrun and corrupted the call stack, causing the program to
    crash. This process is also known as *smashing the stack*.
  prefs: []
  type: TYPE_NORMAL
- en: '7.10.5 A Smarter Buffer Overflow: Second Attempt'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our first example smashed the stack by overwriting the `%rbp` register and return
    address with junk, causing the program to crash. An attacker whose goal is to
    simply crash a program would be satisfied at this point. However, our goal is
    to trick the guessing game to return 0, indicating that we won the game. We accomplish
    this by filling the call stack with data more meaningful than junk values. For
    example, we could overwrite the stack so that the return address is replaced with
    the address of `endGame`. Then, when the program attempts to return from `main`,
    it will instead execute `endGame` rather than crashing with a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the address of `endGame`, let’s inspect `secret` again in GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Observe that `endGame` starts at address 0x00000000004006da. [Figure 7-19](ch07.xhtml#ch7fig19)
    illustrates a sample exploit that forces `secret` to run the `endGame` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: A sample string that can force `secret` to execute the `endGame`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, there are 40 bytes of junk values followed by the return address.
    Again, because x86-64 is a little-endian system, the bytes in the return address
    appear to be in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates how an attacker could construct the preceding
    exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The `\x` before each number indicates that the number is formatted as the hexadecimal
    representation of a character. After defining `ebuff[]`, the `main` function simply
    prints it out, character by character. To get the associated byte string, compile
    and run this program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the file `exploit` as input to `scanf`, it suffices to run `secret`
    with `exploit` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The program prints out “You are so wrong!” since the string contained in `exploit`
    is *not* the secret number. However, the program also prints out the string “You
    win!” Recall, though, that our goal is to trick the program to return 0\. In a
    larger system, where the notion of “success” is tracked by an external program,
    it is often most important what a program returns, not what it prints out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the return value yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Our exploit works! We won the game!
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.6 Protecting Against Buffer Overflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The example we showed changed the control flow of the `secret` executable,
    forcing it to return a zero value associated with success. However, an exploit
    like this could do some real damage. Furthermore, some older computer systems
    *executed* bytes from stack memory. If an attacker placed bytes associated with
    assembly instructions on the call stack, the CPU would interpret the bytes as
    *real* instructions, enabling the attacker to force the CPU to execute *any arbitrary
    code of their choosing*. Fortunately, there are strategies that modern computer
    systems employ to make it more difficult for attackers to run buffer overflow
    exploits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack randomization.**   The OS allocates the starting address of the stack
    at a random location in stack memory, causing the position/size of the call stack
    to vary from one run of a program to another. Multiple machines running the same
    code would have different stack addresses. Modern Linux systems use stack randomization
    as a standard practice. However, a determined attacker can brute force the attack,
    by attempting to repeat attacks with different addresses. A common trick is to
    use a *NOP sled* (i.e., a large number of `nop` instructions) before the actual
    exploit code. Executing the `nop` instruction (`0x90`) has no effect, other than
    causing the program counter to increment to the next instruction. As long as the
    attacker can get the CPU to execute somewhere in the NOP sled, the NOP sled will
    eventually lead to the exploit code that follows it. Aleph One’s writeup^([9](ch07.xhtml#fn7_9))
    details the mechanism of this type of attack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack corruption detection.**   Another line of defense is to try to detect
    when the stack is corrupted. Recent versions of GCC use a stack protector known
    as a *canary* that acts as a guard between the buffer and the other elements of
    the stack. A canary is a value stored in a nonwriteable section of memory that
    can be compared to a value put on the stack. If the canary “dies” during a program’s
    execution, the program knows that it is under attack and aborts with an error
    message. A clever attacker can, however, replace the canary to prevent the program
    from detecting stack corruption.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limiting executable regions.**   In this line of defense, executable code
    is restricted to only particular regions of memory. In other words, the call stack
    is no longer executable. However, even this defense can be defeated. In an attack
    utilizing *return-oriented programming* (ROP), an attacker can “cherry-pick” instructions
    in executable regions and jump from instruction to instruction to build an exploit.
    There are some famous examples of this online, especially in video games.^([10](ch07.xhtml#fn7_10))'
  prefs: []
  type: TYPE_NORMAL
- en: However, the best line of defense is always the programmer. To prevent buffer
    overflow attacks on your programs, use C functions with *length specifiers* whenever
    possible and add code that performs array bounds checking. It is crucial that
    any defined arrays match the chosen length specifiers. [Table 7-19](ch07.xhtml#ch7tab19)
    lists some common “bad” C functions that are vulnerable to buffer overflow and
    the corresponding “good” function to use (assume that `buf` is allocated 12 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-19:** C Functions with Length Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instead of** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `gets(buf)` | `fgets(buf, 12, stdin)` |'
  prefs: []
  type: TYPE_TB
- en: '| `scanf("%s", buf)` | `scanf("%12s", buf)` |'
  prefs: []
  type: TYPE_TB
- en: '| `strcpy(buf2, buf)` | `strncpy(buf2, buf, 12)` |'
  prefs: []
  type: TYPE_TB
- en: '| `strcat(buf2, buf)` | `strncat(buf2, buf, 12)` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf(buf, "%d", num)` | `snprintf(buf, 12, "%d", num)` |'
  prefs: []
  type: TYPE_TB
- en: 'The `secret2` binary^([11](ch07.xhtml#fn7_11)) no longer has the buffer overflow
    vulnerability. Here’s the `main` function of this new binary:'
  prefs: []
  type: TYPE_NORMAL
- en: main2.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we added a length specifier to all calls of `scanf`, causing the
    `scanf` function to stop reading from the input after the first 12 bytes are read.
    The exploit string no longer breaks the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Of course, any reader with basic reverse-engineering skills can still win the
    guessing game by analyzing the assembly code. If you haven’t tried to beat the
    program yet with reverse engineering, we encourage you to do so now.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch07.xhtml#rfn7_1) Edsger Dijkstra,“Go To Statement Considered Harmful,”
    *Communications of the ACM* 11(3), pp. 147–148, 1968.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch07.xhtml#rfn7_2) *[https://diveintosystems.org/book/C7-x86_64/recursion.html](https://diveintosystems.org/book/C7-x86_64/recursion.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch07.xhtml#rfn7_3) Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely
    Execute Malicious Code,” *[https://thehackernews.com/2017/06/skype-crash-bug.html](https://thehackernews.com/2017/06/skype-crash-bug.html)*,
    2017.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch07.xhtml#rfn7_4) Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow
    in multiple Android DRM services,” *[https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/](https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/)*,
    2018.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch07.xhtml#rfn7_5) Tom Spring, “Google Patches ‘High Severity’ Browser
    Bug,” *[https://threatpost.com/google-patches-high-severity-browser-bug/128661/](https://threatpost.com/google-patches-high-severity-browser-bug/128661/)*,
    2017.'
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch07.xhtml#rfn7_6) Christopher Kelty, “The Morris Worm,” *Limn Magazine*,
    Issue 1: Systemic Risk, 2011\. *[https://limn.it/articles/the-morris-worm/](https://limn.it/articles/the-morris-worm/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch07.xhtml#rfn7_7) David Auerbach, “Chat Wars: Microsoft vs. AOL,” *NplusOne
    Magazine*, Issue 19, Spring 2014\. *[https://nplusonemag.com/issue-19/essays/chat-wars/](https://nplusonemag.com/issue-19/essays/chat-wars/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch07.xhtml#rfn7_8) *[https://diveintosystems.org/book/C7-x86_64/_attachments/secretx86-64.tar.gz](https://diveintosystems.org/book/C7-x86_64/_attachments/secretx86-64.tar.gz)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[9.](ch07.xhtml#rfn7_9) Aleph One, “Smashing the Stack for Fun and Profit,”
    *[http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)*,
    1996.'
  prefs: []
  type: TYPE_NORMAL
- en: '[10.](ch07.xhtml#rfn7_10) DotsAreCool, “Super Mario World Credit Warp” (Nintendo
    ROP example), *[https://youtu.be/vAHXK2wut_I](https://youtu.be/vAHXK2wut_I)*,
    2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '[11.](ch07.xhtml#rfn7_11) *[https://diveintosystems.org/book/C7-x86_64/_attachments/secret2x86-64.tar.gz](https://diveintosystems.org/book/C7-x86_64/_attachments/secret2x86-64.tar.gz)*'
  prefs: []
  type: TYPE_NORMAL
