- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: 64-BIT X86 ASSEMBLY (X86-64)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 64位x86汇编（X86-64）
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: In this chapter, we cover the Intel Architecture 64-bit (x86-64) instruction
    set architecture. Recall that an instruction set architecture (or ISA; see [Chapter
    5](ch05.xhtml#ch05)) defines the set of instructions and binary encodings of a
    machine-level program. To run the examples in this chapter, you will need access
    to a machine with a 64-bit x86 processor. The term “x86” is often used synonymously
    with the IA-32 architecture. The 64-bit extension of this architecture is referred
    to as x86-64 (or x64) and is ubiquitous in modern computers. Both IA32 and x86-64
    belong to the x86 architecture family.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Intel架构的64位（x86-64）指令集架构。回想一下，指令集架构（或ISA；见[第5章](ch05.xhtml#ch05)）定义了机器级程序的指令集和二进制编码。为了运行本章的示例，你需要一台配有64位x86处理器的机器。“x86”这个术语通常与IA-32架构同义。该架构的64位扩展被称为x86-64（或x64），并且在现代计算机中普遍存在。IA32和x86-64都属于x86架构家族。
- en: 'To check to see if you have a 64-bit Intel processor on your Linux machine,
    run the `uname -p` command. If you have an x86-64 system, you should see output
    like the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的Linux机器是否有64位Intel处理器，可以运行`uname -p`命令。如果你有一个x86-64系统，你应该看到类似以下的输出：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since x86-64 is an extension of the smaller IA32 ISA, some readers may prefer
    a discussion of IA32\. To read more about IA32, see [Chapter 8](ch08.xhtml#ch08).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于x86-64是较小的IA32 ISA的扩展，因此一些读者可能更喜欢讨论IA32。欲了解更多关于IA32的内容，请参见[第8章](ch08.xhtml#ch08)。
- en: X86 SYNTAX BRANCHES
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: x86语法分支
- en: x86 architectures typically follow one of two different syntax branches. Unix
    machines commonly use the AT&T syntax, given that Unix was developed at AT&T Bell
    Labs. The corresponding assembler is GNU Assembler (GAS). Since we use GCC for
    most examples in this book, we cover AT&T syntax in this chapter. Windows machines
    commonly use Intel syntax, which is used by Microsoft’s Macro Assembler (MASM).
    The Netwide Assembler (NASM) is an example of a Linux assembler that uses Intel
    syntax. The argument regarding the superiority of one syntax over the other is
    one of the “holy wars” of the discipline. However, there is value in being familiar
    with both syntaxes, as a programmer may encounter either in various circumstances.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: x86架构通常遵循两种不同的语法分支之一。Unix机器通常使用AT&T语法，因为Unix是在AT&T贝尔实验室开发的。对应的汇编程序是GNU汇编器（GAS）。由于我们在本书中的大多数示例都使用GCC，因此本章将介绍AT&T语法。Windows机器通常使用Intel语法，这是微软宏汇编器（MASM）使用的语法。Netwide汇编器（NASM）是一个使用Intel语法的Linux汇编器示例。关于哪种语法优于另一种的争论，是该领域的“圣战”之一。然而，熟悉两种语法都是有价值的，因为程序员在不同的情况下可能会遇到其中的任何一种。
- en: '7.1 Diving into Assembly: Basics'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 深入汇编：基础知识
- en: 'For a first look at x64 assembly, we modify the `adder` function from [Chapter
    6](ch06.xhtml#ch06) to simplify its behavior. The modified function (`adder2`)
    is shown here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次接触x64汇编，我们将修改[第6章](ch06.xhtml#ch06)中的`adder`函数，以简化其行为。修改后的函数（`adder2`）如下所示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To compile this code, use the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，使用以下命令：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let’s view the corresponding assembly of this code by using the `objdump`
    command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过使用`objdump`命令查看这段代码的相应汇编：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Search for the code snippet associated with `adder2` by typing /adder2 while
    examining the file `output` using less. The section associated with `adder2` should
    look similar to the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`less`查看文件`output`时，通过键入`/adder2`来查找与`adder2`相关的代码片段。与`adder2`相关的部分应该类似于以下内容：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don’t worry if you don’t understand what’s going on just yet. We will cover
    assembly in greater detail in later sections. For now, let’s study the structure
    of these individual instructions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还不理解发生了什么，也不用担心。我们将在后面的章节中更详细地讲解汇编语言。现在，让我们来研究这些单独指令的结构。
- en: Each line in the preceding example contains an instruction’s 64-bit address
    in program memory, the bytes corresponding to the instruction, and the plaintext
    representation of the instruction itself. For example, `55` is the machine code
    representation of the instruction `push %rbp`, and the instruction occurs at address
    `0x400526` in program memory. Note that `0x400526` is an abbreviation of the full
    64-bit address associated with the `push %rbp` instruction; the leading zeros
    are ignored for readability.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，每一行都包含了程序内存中指令的64位地址、与指令对应的字节，以及指令本身的明文表示。例如，`55`是指令`push %rbp`的机器码表示，而该指令位于程序内存中的地址`0x400526`。请注意，`0x400526`是与`push
    %rbp`指令相关的完整64位地址的简写；为了可读性，前导零被省略。
- en: It is important to note that a single line of C code often translates to multiple
    instructions in assembly. The operation `a + 2` is represented by the two instructions
    `mov -0x4(%rbp),%eax` and `add $0x2,%eax`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，一行C代码通常会翻译成汇编中的多条指令。操作`a + 2`会由两条指令`mov -0x4(%rbp),%eax`和`add $0x2,%eax`来表示。
- en: '**Warning YOUR ASSEMBLY MAY LOOK DIFFERENT!**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：您的汇编代码可能会有所不同！**'
- en: If you are compiling your code along with us, you may notice that some of your
    assembly examples look different from what is shown in this book. The precise
    assembly instructions that are output by any compiler depend on that compiler’s
    version and the underlying operating system. Most of the assembly examples in
    this book were generated on systems running Ubuntu or Red Hat Enterprise Linux
    (RHEL).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我们一起编译代码，你可能会注意到你的汇编示例与本书中显示的有所不同。任何编译器输出的精确汇编指令取决于该编译器的版本以及底层操作系统。本书中的大多数汇编示例是在运行Ubuntu或Red
    Hat Enterprise Linux（RHEL）系统上生成的。
- en: In the examples that follow, we do not use any optimization flags. For example,
    we compile any example file (`example.c`) using the command `gcc -o example example.c`.
    Consequently, there are many seemingly redundant instructions in the examples
    that follow. Remember that the compiler is not “smart”—it simply follows a series
    of rules to translate human-readable code into machine language. During this translation
    process, it is not uncommon for some redundancy to occur. Optimizing compilers
    remove many of these redundancies during optimization, which is covered in [Chapter
    12](ch12.xhtml#ch12).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们没有使用任何优化标志。例如，我们通过命令`gcc -o example example.c`编译任何示例文件（`example.c`）。因此，接下来的示例中会有许多看似冗余的指令。请记住，编译器并不是“聪明”的——它只是遵循一系列规则将人类可读的代码翻译成机器语言。在这个翻译过程中，出现一些冗余是很常见的。优化编译器在优化过程中会去除这些冗余，这部分内容在[第12章](ch12.xhtml#ch12)中讲解。
- en: 7.1.1 Registers
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1 寄存器
- en: 'Recall that a *register* is a word-sized storage unit located directly on the
    CPU. There may be separate registers for data, instructions, and addresses. For
    example, the Intel CPU has a total of 16 registers for storing 64-bit data: `%rax`,
    `%rbx`, `%rcx`, `%rdx`, `%rdi`, `%rsi`, `%rsp`, `%rbp`, and `%r8`–`%r15`. All
    the registers save for `%rsp` and `%rbp` hold general-purpose 64-bit data. While
    a program may interpret a register’s contents as, say, an integer or an address,
    the register itself makes no distinction. Programs can read from or write to all
    16 registers.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，*寄存器*是一个位于CPU内部的字长存储单元。可能会有单独的寄存器用于数据、指令和地址。例如，英特尔的CPU有16个寄存器用于存储64位数据：`%rax`、`%rbx`、`%rcx`、`%rdx`、`%rdi`、`%rsi`、`%rsp`、`%rbp`，以及`%r8`到`%r15`。除了`%rsp`和`%rbp`外，所有寄存器都用于保存通用的64位数据。虽然程序可以将寄存器的内容解释为整数或地址等，但寄存器本身并不做区分。程序可以从所有16个寄存器中读取或写入数据。
- en: The registers `%rsp` and `%rbp` are known as the *stack pointer* and the *frame
    pointer* (or *base pointer*), respectively. The compiler reserves these registers
    for operations that maintain the layout of the program stack. For example, register
    `%rsp` always points to the top of the stack. In earlier x86 systems (e.g., IA32),
    the frame pointer commonly tracked the base of the active stack frame and helped
    to reference parameters. However, the base pointer is less frequently used in
    x86-64 systems. Compilers typically store the first six parameters in registers
    `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, and `%r9`, respectively. Register `%rax`
    stores the return value from a function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器`%rsp`和`%rbp`分别被称为*栈指针*和*帧指针*（或*基指针*）。编译器为这些寄存器保留了用于维护程序栈布局的操作。例如，寄存器`%rsp`始终指向栈顶。在早期的x86系统（例如IA32）中，帧指针通常跟踪活动栈帧的基地址，并帮助引用参数。然而，在x86-64系统中，基指针的使用变得较少。编译器通常将前六个参数分别存储在寄存器`%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8`和`%r9`中。寄存器`%rax`用于存储函数的返回值。
- en: The last register worth mentioning is `%rip` or the *instruction pointer*, sometimes
    called the *program counter* (PC). It points to the next instruction to be executed
    by the CPU. Unlike the 16 registers mentioned previously, programs cannot write
    directly to register `%rip`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个值得提及的寄存器是`%rip`，即*指令指针*，有时也叫做*程序计数器*（PC）。它指向CPU将要执行的下一条指令。与前面提到的16个寄存器不同，程序不能直接写入`%rip`寄存器。
- en: 7.1.2 Advanced Register Notation
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2 高级寄存器符号
- en: Since x86-64 is an extension of the 32-bit x86 architecture (which itself was
    an extension of an earlier 16-bit version), the ISA provides mechanisms to access
    the lower 32 bits, 16 bits, and lower bytes of each register. [Table 7-1](ch07.xhtml#ch7tab1)
    lists each of the 16 registers and the ISA notations to access their component
    bytes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 x86-64 是 32 位 x86 架构的扩展（而 32 位 x86 本身是早期 16 位版本的扩展），ISA 提供了机制来访问每个寄存器的低32位、低16位和低字节。[表
    7-1](ch07.xhtml#ch7tab1) 列出了每个寄存器以及访问其组件字节的 ISA 标记。
- en: '**Table 7-1:** x86-64 Registers and Mechanisms for Accessing Lower Bytes'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-1：** x86-64 寄存器及访问低字节的机制'
- en: '| **64-bit Register** | **32-bit Register** | **Lower 16 Bits** | **Lower 8
    Bits** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **64位寄存器** | **32位寄存器** | **低16位** | **低8位** |'
- en: '| `%rax` | `%eax` | `%ax` | `%al` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `%rax` | `%eax` | `%ax` | `%al` |'
- en: '| `%rbx` | `%ebx` | `%bx` | `%bl` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `%rbx` | `%ebx` | `%bx` | `%bl` |'
- en: '| `%rcx` | `%ecx` | `%cx` | `%cl` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `%rcx` | `%ecx` | `%cx` | `%cl` |'
- en: '| `%rdx` | `%edx` | `%dx` | `%dl` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `%rdx` | `%edx` | `%dx` | `%dl` |'
- en: '| `%rdi` | `%edi` | `%di` | `%dil` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `%rdi` | `%edi` | `%di` | `%dil` |'
- en: '| `%rsi` | `%esi` | `%si` | `%sil` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `%rsi` | `%esi` | `%si` | `%sil` |'
- en: '| `%rsp` | `%esp` | `%sp` | `%spl` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `%rsp` | `%esp` | `%sp` | `%spl` |'
- en: '| `%rbp` | `%ebp` | `%bp` | `%bpl` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `%rbp` | `%ebp` | `%bp` | `%bpl` |'
- en: '| `%r8` | `%r8d` | `%r8w` | `%r8b` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `%r8` | `%r8d` | `%r8w` | `%r8b` |'
- en: '| `%r9` | `%r9d` | `%r9w` | `%r9b` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `%r9` | `%r9d` | `%r9w` | `%r9b` |'
- en: '| `%r10` | `%r10d` | `%r10w` | `%r10b` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `%r10` | `%r10d` | `%r10w` | `%r10b` |'
- en: '| `%r11` | `%r11d` | `%r11w` | `%r11b` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `%r11` | `%r11d` | `%r11w` | `%r11b` |'
- en: '| `%r12` | `%r12d` | `%r12w` | `%r12b` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `%r12` | `%r12d` | `%r12w` | `%r12b` |'
- en: '| `%r13` | `%r13d` | `%r13w` | `%r13b` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `%r13` | `%r13d` | `%r13w` | `%r13b` |'
- en: '| `%r14` | `%r14d` | `%r14w` | `%r14b` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `%r14` | `%r14d` | `%r14w` | `%r14b` |'
- en: '| `%r15` | `%r15d` | `%r15w` | `%r15b` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `%r15` | `%r15d` | `%r15w` | `%r15b` |'
- en: The first eight registers (`%rax`, `%rbx`, `%rcx`, `%rdx`, `%rdi`, `%rsi`, `%rsp`,
    and `%rbp`) are 64-bit extensions of 32-bit registers in x86 and have a common
    mechanism for accessing their lower 32 bits, lower 16 bits, and least-significant
    byte. To access the lower 32 bits of the first eight registers, simply replace
    the `r` in the register name with `e`. Thus, the register corresponding to the
    lower 32 bits of register `%rax` is register `%eax`. To access the lower 16 bits
    of each of these eight registers, reference the last two letters of the register’s
    name. So, the mechanism to access the lower two bytes of register `%rax` is `%ax`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前八个寄存器（`%rax`、`%rbx`、`%rcx`、`%rdx`、`%rdi`、`%rsi`、`%rsp` 和 `%rbp`）是x86架构的64位扩展，具有访问它们的低32位、低16位和最低有效字节的公共机制。要访问这前八个寄存器的低32位，只需将寄存器名称中的
    `r` 替换为 `e`。因此，寄存器 `%rax` 对应的低32位寄存器是 `%eax`。要访问这些寄存器的低16位，只需引用寄存器名称的最后两个字母。因此，访问寄存器
    `%rax` 的低两个字节的机制是 `%ax`。
- en: '![image](../images/07fig01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig01.jpg)'
- en: '*Figure 7-1: The names that refer to subsets of register `%rax`*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：表示寄存器 `%rax` 子集的名称*'
- en: The ISA provides a separate mechanism to access the eight-bit components within
    the lower 16 bits of the first four listed registers. [Figure 7-1](ch07.xhtml#ch7fig1)
    depicts the access mechanisms for register `%rax`. The *higher* and *lower* bytes
    within the lower 16 bits of the first four listed registers can be accessed by
    taking the last two letters of the register name and replacing the last letter
    with either an `h` (for *higher*) or an `l` (for *lower*) depending on which byte
    is desired. For example, `%al` references the lower eight bits of register `%ax`,
    whereas `%ah` references the higher eight bits of register `%ax`. These eight-bit
    registers are commonly used for storing single-byte values for certain operations
    such as bitwise shifts (a 32-bit register cannot be shifted more than 32 places,
    and the number 32 requires only a single byte of storage).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ISA 提供了一个独立的机制，用于访问前四个列出的寄存器中低16位内的八位组件。[图 7-1](ch07.xhtml#ch7fig1) 展示了访问寄存器
    `%rax` 的机制。在前四个列出的寄存器的低16位中，可以通过将寄存器名称的最后两个字母替换为 `h`（表示 *高* 字节）或 `l`（表示 *低* 字节）来访问高字节和低字节，具体取决于需要访问的字节。例如，`%al`
    代表寄存器 `%ax` 的低8位，而 `%ah` 代表寄存器 `%ax` 的高8位。这些八位寄存器通常用于存储单字节值，用于某些操作，如位移（32位寄存器不能被移位超过32位，数字32只需要一个字节的存储）。
- en: '**Warning WARNING: COMPILER MAY CHOOSE COMPONENT REGISTERS DEPENDING ON TYPE**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 WARNING：编译器可能根据类型选择组件寄存器**'
- en: When reading assembly code, keep in mind that the compiler typically uses the
    64-bit registers when dealing with 64-bit values (e.g., pointers or `long` types),
    and the 32-bit component registers when dealing with 32-bit types (e.g., `int`).
    In x86-64, it is very common to see 32-bit component registers intermixed with
    the full 64-bit registers. For example, in the `adder2` function shown earlier,
    the compiler references component register `%eax` instead of `%rax` since `int`
    types typically take up 32 bits (four bytes) of space on 64-bit systems. If the
    `adder2` function had a `long` parameter instead of `int`, the compiler would
    store `a` in register `%rax` instead of register `%eax`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读汇编代码时，要记住编译器通常在处理64位值（例如指针或`long`类型）时使用64位寄存器，在处理32位类型（例如`int`）时使用32位寄存器。在x86-64中，常常会看到32位寄存器与完整的64位寄存器混合使用。例如，在前面展示的`adder2`函数中，编译器引用了32位寄存器`%eax`而不是`%rax`，因为`int`类型通常在64位系统中占用32位（四字节）空间。如果`adder2`函数的参数是`long`类型而不是`int`，编译器会将`a`存储在寄存器`%rax`中，而不是寄存器`%eax`。
- en: The last eight registers (`%r8`–`%r15`) were not part of the IA32 ISA. However,
    they also have mechanisms to access their different byte components. To access
    the lower 32 bits, 16 bits, or byte of the last eight registers, append the letter
    `d`, `w`, or `b`, respectively, to the end of the register’s name. Thus, `%r9d`
    accesses the lower 32 bits of register `%r9`, whereas `%r9w` accesses the lower
    16 bits, and `%r9b` accesses the lowest byte of register `%r9`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的八个寄存器（`%r8`–`%r15`）不是IA32指令集的一部分。然而，它们也有访问其不同字节组件的机制。要访问最后八个寄存器的低32位、16位或字节，只需在寄存器名后添加字母`d`、`w`或`b`。因此，`%r9d`访问寄存器`%r9`的低32位，而`%r9w`访问低16位，`%r9b`访问寄存器`%r9`的最低字节。
- en: 7.1.3 Instruction Structure
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3 指令结构
- en: Each instruction consists of an operation code (or *opcode*) that specifies
    what it does, and one or more *operands* that tell the instruction how to do it.
    For example, the instruction `add $0x2,%eax` has the opcode `add` and the operands
    `$0x2` and `%eax`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每条指令由操作码（或*操作符*）组成，用于指定它的功能，以及一个或多个*操作数*，用于指示指令如何执行。例如，指令`add $0x2,%eax`的操作码是`add`，操作数是`$0x2`和`%eax`。
- en: Each operand corresponds to a source or destination location for a specific
    operation. Two operand instructions typically follow the source, destination (`S`,
    `D`) format, where the first operand specifies a source register, and the second
    operand specifies the destination.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作数对应于特定操作的源或目标位置。两操作数指令通常遵循源、目标（`S`、`D`）格式，其中第一个操作数指定源寄存器，第二个操作数指定目标寄存器。
- en: 'There are multiple types of operands:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数有多种类型：
- en: '*Constant* (*literal*) values are preceded by the `$` sign. For example, in
    the instruction `add $0x2,%eax`, `$0x2` is a literal value that corresponds to
    the hexadecimal value 0x2.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常量*（*字面值*）值前面带有`$`符号。例如，在指令`add $0x2,%eax`中，`$0x2`是一个字面值，对应于十六进制值0x2。'
- en: '*Register* forms refer to individual registers. Thus, the instruction `mov
    %rsp,%rbp` specifies that the value in the source register (`%rsp`) should be
    copied to the destination location (register `%rbp`).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*寄存器*形式指的是单独的寄存器。因此，指令`mov %rsp,%rbp`表示将源寄存器（`%rsp`）中的值复制到目标位置（寄存器`%rbp`）。'
- en: '*Memory* forms correspond to some value inside main memory (RAM) and are commonly
    used for address lookups. Memory address forms can contain a combination of registers
    and constant values. For example, in the instruction `mov -0x4(%rbp),%eax`, the
    operand `-0x4(%rbp)` is an example of a memory form. It loosely translates to
    “add –0x4 to the value in register `%rbp` (i.e., subtract 0x4 from `%rbp`), and
    then perform a memory lookup.” If this sounds like a pointer dereference, that’s
    because it is!'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内存*形式对应于主内存（RAM）中的某个值，并常用于地址查找。内存地址形式可以包含寄存器和常量值的组合。例如，在指令`mov -0x4(%rbp),%eax`中，操作数`-0x4(%rbp)`就是内存形式的一个示例。它大致翻译为“将-0x4加到寄存器`%rbp`中的值上（即从`%rbp`中减去0x4），然后进行内存查找。”如果这听起来像是指针解引用，那就是因为它确实是！'
- en: 7.1.4 An Example with Operands
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.4 带操作数的示例
- en: 'The best way to explain operands in detail is to present a quick example. Suppose
    that memory contains the following values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 解释操作数的最佳方式是通过一个简短的示例。假设内存中包含以下值：
- en: '| **Address** | **Value** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **值** |'
- en: '| 0x804 | 0xCA |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 0x804 | 0xCA |'
- en: '| 0x808 | 0xFD |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 0x808 | 0xFD |'
- en: '| 0x80c | 0x12 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 0x80c | 0x12 |'
- en: '| 0x810 | 0x1E |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 0x810 | 0x1E |'
- en: 'Let’s also assume that the following registers contain the values shown:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下寄存器包含所示的值：
- en: '| **Register** | **Value** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** | **值** |'
- en: '| `%rax` | 0x804 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `%rax` | 0x804 |'
- en: '| `%rbx` | 0x10 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `%rbx` | 0x10 |'
- en: '| `%rcx` | 0x4 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `%rcx` | 0x4 |'
- en: '| `%rdx` | 0x1 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `%rdx` | 0x1 |'
- en: Then the operands in [Table 7-2](ch07.xhtml#ch7tab2) evaluate to the values
    shown there. Each row of the table matches an operand with its form (e.g., constant,
    register, memory), how it is translated, and its value. Note that the notation
    M[x] in this context denotes the value at the memory location specified by address
    x.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后[表 7-2](ch07.xhtml#ch7tab2)中的操作数会计算出其中显示的值。表格的每一行将操作数与其形式（例如常量、寄存器、内存）、翻译方式以及值进行匹配。请注意，在这个上下文中，M[x]表示由地址
    x 指定的内存位置中的值。
- en: '**Table 7-2:** Example Operands'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-2：** 示例操作数'
- en: '| **Operand** | **Form** | **Translation** | **Value** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **操作数** | **形式** | **翻译** | **值** |'
- en: '| `%rcx` | Register | `%rcx` | 0x4 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `%rcx` | 寄存器 | `%rcx` | 0x4 |'
- en: '| `(%rax)` | Memory | M[`%rax`] or M[0x804] | 0xCA |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `(%rax)` | 内存 | M[`%rax`] 或 M[0x804] | 0xCA |'
- en: '| `$0x808` | Constant | 0x808 | 0x808 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `$0x808` | 常量 | 0x808 | 0x808 |'
- en: '| `0x808` | Memory | M[0x808] | 0xFD |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `0x808` | 内存 | M[0x808] | 0xFD |'
- en: '| `0x8(%rax)` | Memory | M[`%rax` + 8] or M[0x80c] | 0x12 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `0x8(%rax)` | 内存 | M[`%rax` + 8] 或 M[0x80c] | 0x12 |'
- en: '| `(%rax, %rcx)` | Memory | M[`%rax` + `%rcx`] or M[0x808] | 0xFD |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `(%rax, %rcx)` | 内存 | M[`%rax` + `%rcx`] 或 M[0x808] | 0xFD |'
- en: '| `0x4(%rax, %rcx)` | Memory | M[`%rax` + `%rcx` + 4] or M[0x80c] | 0x12 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `0x4(%rax, %rcx)` | 内存 | M[`%rax` + `%rcx` + 4] 或 M[0x80c] | 0x12 |'
- en: '| `0x800(,%rdx,4)` | Memory | M[0x800 + `%rdx`×4] or M[0x804] | 0xCA |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `0x800(,%rdx,4)` | 内存 | M[0x800 + `%rdx`×4] 或 M[0x804] | 0xCA |'
- en: '| `(%rax, %rdx, 8)` | Memory | M[`%rax` + `%rdx`×8] or M[0x80c] | 0x12 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `(%rax, %rdx, 8)` | 内存 | M[`%rax` + `%rdx`×8] 或 M[0x80c] | 0x12 |'
- en: In [Table 7-2](ch07.xhtml#ch7tab2), the notation `%rcx` indicates the value
    stored in register `%rcx`. In contrast, M[`%rax`] indicates that the value inside
    `%rax` should be treated as an address, and to dereference (look up) the value
    at that address. Therefore, the operand `(%rax)` corresponds to M[0x804], which
    corresponds to the value 0xCA.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表 7-2](ch07.xhtml#ch7tab2)中，符号 `%rcx` 表示寄存器 `%rcx` 中存储的值。相比之下，M[`%rax`] 表示
    `%rax` 中的值应该被视为地址，并通过该地址解引用（查找）值。因此，操作数 `(%rax)` 对应于 M[0x804]，其值为 0xCA。
- en: 'A few important notes before continuing. Although [Table 7-2](ch07.xhtml#ch7tab2)
    shows many valid operand forms, not all forms can be used interchangeably in all
    circumstances. Specifically:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有几个重要的注意事项。虽然[表 7-2](ch07.xhtml#ch7tab2)显示了许多有效的操作数形式，但并不是所有形式都可以在所有情况下互换使用。具体来说：
- en: Constant forms cannot serve as destination operands.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量形式不能作为目标操作数。
- en: Memory forms cannot serve as *both* the source and destination operand in a
    single instruction.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存形式不能作为*源*和*目标*操作数同时出现在单条指令中。
- en: In cases of scaling operations (refer back to the last two operands in [Table
    7-2](ch07.xhtml#ch7tab2)), the scaling factor is a third parameter in the parentheses.
    Scaling factors can be one of 1, 2, 4, or 8.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缩放操作的情况下（请回顾[表 7-2](ch07.xhtml#ch7tab2)中的最后两个操作数），缩放因子是括号中的第三个参数。缩放因子可以是 1、2、4
    或 8 之一。
- en: '[Table 7-2](ch07.xhtml#ch7tab2) is provided as a reference; however, understanding
    key operand forms will help improve the reader’s speed in parsing assembly language.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-2](ch07.xhtml#ch7tab2)作为参考提供，但理解关键操作数形式有助于提高读者解析汇编语言的速度。'
- en: 7.1.5 Instruction Suffixes
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.5 指令后缀
- en: In several cases in upcoming examples, common and arithmetic instructions have
    a suffix that indicates the *size* (associated with the *type*) of the data being
    operated on at the code level. The compiler automatically translates code to instructions
    with the appropriate suffix. [Table 7-3](ch07.xhtml#ch7tab3) shows the common
    suffixes for x86-64 instructions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个例子中，常见的和算术指令都有一个后缀，表示在代码级别操作的数据的*大小*（与*类型*相关）。编译器会自动将代码翻译成带有适当后缀的指令。[表
    7-3](ch07.xhtml#ch7tab3)展示了 x86-64 指令的常见后缀。
- en: '**Table 7-3:** Example Instruction Suffixes'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-3：** 示例指令后缀'
- en: '| **Suffix** | **C Type** | **Size (Bytes)** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **后缀** | **C 类型** | **大小（字节）** |'
- en: '| b | `char` | 1 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| b | `char` | 1 |'
- en: '| w | `short` | 2 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| w | `short` | 2 |'
- en: '| l | `int` or `unsigned` | 4 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| l | `int` 或 `unsigned` | 4 |'
- en: '| s | `float` | 4 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| s | `float` | 4 |'
- en: '| q | `long`, `unsigned long`, all pointers | 8 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| q | `long`，`unsigned long`，所有指针 | 8 |'
- en: '| d | `double` | 8 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| d | `double` | 8 |'
- en: Note that instructions involved with conditional execution have different suffixes
    based on the evaluated condition. We cover instructions associated with conditional
    execution in “Conditional Control and Loops” on [page 310](ch07.xhtml#lev1_54).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与条件执行相关的指令具有基于评估条件的不同后缀。我们在“条件控制与循环”章节中讨论与条件执行相关的指令，详见[第 310 页](ch07.xhtml#lev1_54)。
- en: 7.2 Common Instructions
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 常见指令
- en: In this section, we discuss several common assembly instructions. [Table 7-4](ch07.xhtml#ch7tab4)
    lists the most foundational instructions in x86 (and thus x64) assembly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论几种常见的汇编指令。[表 7-4](ch07.xhtml#ch7tab4)列出了 x86（因此也适用于 x64）汇编中的最基础指令。
- en: '**Table 7-4:** Most Common Instructions'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-4：** 最常用的指令'
- en: '| **Instruction** | **Translation** |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |  |'
- en: '| `mov S,D` | S → D | (copies value of S into D) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `mov S,D` | S → D | （将 S 的值复制到 D 中） |'
- en: '| `add S,D` | S + D → D | (adds S to D and stores result in D) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `add S,D` | S + D → D | （将 S 加到 D，并将结果存储在 D 中） |'
- en: '| `sub S,D` | D – S → D | (subtracts S *from* D and stores result in D) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `sub S,D` | D – S → D | （从 D 中减去 S，并将结果存储在 D 中） |'
- en: Therefore, the sequence of instructions
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，指令序列
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'translates to:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译为：
- en: Copy the value at location `%rbp` + –0x4 in *memory* (or M[`%rbp`– 0x4]) to
    register `%eax`.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *内存* 中位置 `%rbp` + –0x4 处的值（或 M[`%rbp`– 0x4]）复制到寄存器 `%eax`。
- en: Add the value 0x2 to register `%eax`, and store the result in register `%eax`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值 0x2 加到寄存器 `%eax` 中，并将结果存储在寄存器 `%eax` 中。
- en: The three instructions shown in [Table 7-4](ch07.xhtml#ch7tab4) also form the
    building blocks for instructions that maintain the organization of the program
    stack (i.e., the *call stack*). Recall that registers `%rbp` and `%rsp` refer
    to the *frame* pointer and *stack* pointer, respectively, and are reserved by
    the compiler for call stack management. Recall from our earlier discussion on
    program memory in “Parts of Program Memory and Scope” on [page 64](ch02.xhtml#lev1_9)
    that the call stack typically stores local variables and parameters and helps
    the program track its own execution (see [Figure 7-2](ch07.xhtml#ch7fig2)). On
    x86-64 systems, the execution stack grows toward *lower* addresses. Like all stack
    data structures, operations occur at the “top” of the stack.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-4](ch07.xhtml#ch7tab4)中显示的三条指令也构成了维持程序堆栈组织的指令（即 *调用堆栈*）的基石。回顾一下 `%rbp`
    和 `%rsp` 寄存器分别指向 *帧* 指针和 *栈* 指针，并且被编译器保留用于调用堆栈管理。回忆我们之前在《程序内存的组成与作用》一节中关于程序内存的讨论（见[第64页](ch02.xhtml#lev1_9)），调用堆栈通常存储局部变量和参数，并帮助程序追踪其执行（见[图7-2](ch07.xhtml#ch7fig2)）。在
    x86-64 系统上，执行堆栈是向 *较低* 地址增长的。像所有堆栈数据结构一样，操作发生在堆栈的“顶部”。'
- en: '![image](../images/07fig02.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig02.jpg)'
- en: '*Figure 7-2: The parts of a program’s address space*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：程序地址空间的组成部分*'
- en: The x86-64 ISA provides two instructions ([Table 7-5](ch07.xhtml#ch7tab5)) to
    simplify call stack management.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 ISA 提供了两条指令（[表 7-5](ch07.xhtml#ch7tab5)）来简化调用堆栈管理。
- en: '**Table 7-5:** Stack Management Instructions'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-5：** 堆栈管理指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `push S` | Pushes a copy of S onto the top of the stack. Equivalent to:`sub
    $0x8,%rsp``mov S,(%rsp)` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `push S` | 将 S 的副本推送到堆栈的顶部。等价于：`sub $0x8,%rsp``mov S,(%rsp)` |'
- en: '| `pop D` | Pops the top element off the stack and places it in location D.Equivalent
    to:`mov (%rsp),D``add $0x8,%rsp` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `pop D` | 从堆栈顶端弹出元素，并将其放入位置 D。等价于：`mov (%rsp),D``add $0x8,%rsp` |'
- en: Notice that although the three instructions in [Table 7-4](ch07.xhtml#ch7tab4)
    require two operands, the `push` and `pop` instructions in [Table 7-5](ch07.xhtml#ch7tab5)
    require only one operand each.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然[表 7-4](ch07.xhtml#ch7tab4)中的三条指令需要两个操作数，[表 7-5](ch07.xhtml#ch7tab5)中的
    `push` 和 `pop` 指令每条只需要一个操作数。
- en: '7.2.1 Putting It All Together: A More Concrete Example'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1 将一切结合起来：一个更具体的例子
- en: Let’s take a closer look at the `adder2` function
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看 `adder2` 函数
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'and its corresponding assembly code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 及其对应的汇编代码：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The assembly code consists of a `push` instruction, followed by three `mov`
    instructions, an `add` instruction, a `pop` instruction, and finally a `retq`
    instruction. To understand how the CPU executes this set of instructions, we need
    to revisit the structure of program memory (see “Parts of Program Memory and Scope”
    on [page 64](ch02.xhtml#lev1_9)). Recall that every time a program executes, the
    operating system allocates the new program’s address space (also known as *virtual
    memory*). Virtual memory and the related concept of processes are covered in greater
    detail in [Chapter 13](ch13.xhtml#ch13); for now, it suffices to think of a process
    as the abstraction of a running program and virtual memory as the memory that
    is allocated to a single process. Every process has its own region of memory called
    the *call stack*. Keep in mind that the call stack is located in process/virtual
    memory, unlike registers (which are located on the CPU).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编代码由一条`push`指令、三条`mov`指令、一条`add`指令、一条`pop`指令和最后一条`retq`指令组成。为了理解CPU如何执行这一组指令，我们需要重新回顾程序内存的结构（参见[第64页](ch02.xhtml#lev1_9)的“程序内存的部分和作用域”）。回想一下，每当程序执行时，操作系统会分配新的程序地址空间（也称为*虚拟内存*）。虚拟内存和相关的进程概念将在[第13章](ch13.xhtml#ch13)中详细讨论；现在，只需将进程视为正在运行的程序的抽象，而虚拟内存则是分配给单个进程的内存。每个进程都有自己的内存区域，称为*调用栈*。请记住，调用栈位于进程/虚拟内存中，不同于位于CPU上的寄存器。
- en: '[Figure 7-3](ch07.xhtml#ch7fig3) depicts a sample state of the call stack and
    registers prior to the execution of the `adder2` function.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-3](ch07.xhtml#ch7fig3)描绘了`adder2`函数执行前，调用栈和寄存器的一个示例状态。'
- en: '![image](../images/07fig03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig03.jpg)'
- en: '*Figure 7-3: Execution stack prior to execution*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-3：执行栈（执行前状态）*'
- en: Notice that the stack grows toward *lower* addresses. Register `%eax` contains
    a junk value. The single parameter to the `adder2` function (`a`) is stored in
    register `%rdi` by convention. Since `a` is of type `int`, it is stored in component
    register `%edi`, which is shown in [Figure 7-3](ch07.xhtml#ch7fig3). Likewise,
    because the `adder2` function returns an `int`, component register `%eax` is used
    for the return value instead of `%rax`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，栈是朝向*较低*地址增长的。寄存器`%eax`包含一个垃圾值。`adder2`函数的唯一参数（`a`）按约定存储在寄存器`%rdi`中。由于`a`是`int`类型，它被存储在组件寄存器`%edi`中，如[图7-3](ch07.xhtml#ch7fig3)所示。同样，由于`adder2`函数返回一个`int`类型的值，返回值存储在组件寄存器`%eax`中，而不是`%rax`。
- en: The addresses associated with the instructions in the code segment of program
    memory (0x400526–0x400534) have been shortened to 0x526–0x534 to improve figure
    readability. Likewise, the addresses associated with the call stack segment of
    program memory have been shortened to 0xd28–0xd1c from 0x7fffffffdd28–0x7fffffffdd1c.
    In truth, call stack addresses occur at much higher addresses in program memory
    than code segment addresses.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高图示的可读性，程序内存中代码段的指令地址（0x400526–0x400534）已被简化为0x526–0x534。同样，程序内存中调用栈段的地址也已从0x7fffffffdd28–0x7fffffffdd1c简化为0xd28–0xd1c。实际上，调用栈的地址在程序内存中的位置远高于代码段地址。
- en: 'Pay close attention to the initial values of registers `%rsp` and `%rbp`: they
    are 0xd28 and 0xd40, respectively. The upper-left arrow in the following figures
    visually indicates the currently executing instruction. The `%rip` register (or
    instruction pointer) shows the next instruction to execute. Initially, `%rip`
    contains address 0x526, which corresponds to the first instruction in the `adder2`
    function.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意寄存器`%rsp`和`%rbp`的初始值：它们分别是0xd28和0xd40。下图中的左上箭头直观地指示了当前正在执行的指令。`%rip`寄存器（或指令指针）显示了下一条要执行的指令。最初，`%rip`包含地址0x526，该地址对应于`adder2`函数中的第一条指令。
- en: '![image](../images/f0304-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0304-01.jpg)'
- en: 'The first instruction (`push %rbp`) places a copy of the value in `%rbp` (or
    0xd40) on top of the stack. After it executes, the `%rip` register advances to
    the address of the next instruction to execute (0x527). The `push` instruction
    decrements the stack pointer by 8 (“growing” the stack by 8 bytes), resulting
    in a new `%rsp` value of 0xd20\. Recall that the `push %rbp` instruction is equivalent
    to:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令（`push %rbp`）将寄存器`%rbp`（或0xd40）中的值复制到栈顶。执行后，`%rip`寄存器会指向下一条指令的地址（0x527）。`push`指令将栈指针减少8（“增长”栈8个字节），导致新的`%rsp`值为0xd20。回想一下，`push
    %rbp`指令等价于：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In other words, subtract 8 from the stack pointer and place a copy of the contents
    of `%rbp` in the location pointed to by the dereferenced stack pointer, `(%rsp)`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，将栈指针减去8，并将寄存器`%rbp`的内容复制到栈指针解引用的位置`(%rsp)`中。
- en: '![image](../images/f0304-02.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0304-02.jpg)'
- en: Recall that the structure of the `mov` instruction is `mov S,D`, where S is
    the source location, and D is the destination. Thus, the next instruction (`mov`
    `%rsp,%rbp`) updates the value of `%rbp` to 0xd20\. The register `%rip` advances
    to the address of the next instruction to execute, or 0x52a.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`mov`指令的结构是`mov S,D`，其中S是源位置，D是目标位置。因此，下一条指令（`mov %rsp,%rbp`）将更新`%rbp`的值为0xd20。寄存器`%rip`推进到下一个要执行的指令地址，即0x52a。
- en: '![image](../images/f0305-01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0305-01.jpg)'
- en: Next, `mov %edi,-0x4(%rbp)` is executed. This is a bit more complicated than
    the last `mov` instruction. Let’s parse it piece by piece. First, recall that
    the first parameter to any function is stored in register `%rdi`. Since `a` is
    of type `int`, the compiler stores the first parameter in component register `%edi`.
    Next, the operand `-0x4(%rbp)` translates to M[`%rbp` – 0x4]. Since `%rbp` contains
    the value 0xd20, subtracting 4 from it yields 0xd1c. Therefore, the `mov` instruction
    copies the value of register `%edi` (or 0x28) to location 0xd1c on the stack.
    The instruction pointer advances to address 0x52d, the next address to be executed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，执行`mov %edi,-0x4(%rbp)`指令。这比上一条`mov`指令稍微复杂一些。我们逐步解析。首先，回想一下，任何函数的第一个参数都存储在寄存器`%rdi`中。由于`a`是`int`类型，编译器将第一个参数存储在分量寄存器`%edi`中。接下来，操作数`-0x4(%rbp)`表示`M[%rbp
    - 0x4]`。由于`%rbp`的值为0xd20，减去4得到0xd1c。因此，`mov`指令将寄存器`%edi`的值（即0x28）复制到栈上0xd1c的位置。指令指针推进到下一个要执行的地址0x52d。
- en: Note that storing the value 0x28 does not affect the stack pointer (`%rsp`).
    Therefore, as far as the program is concerned, the “top” of this stack is still
    address 0xd20.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存储值0x28不会影响栈指针（`%rsp`）。因此，就程序而言，这个栈的“顶部”仍然是地址0xd20。
- en: '![image](../images/f0305-02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0305-02.jpg)'
- en: The next `mov` instruction (`mov -0x4(%rbp),%eax`) copies the value at stack
    location 0xd1c (i.e., M[`%rbp` – 0x4] or 0x28) and stores it in register `%eax`.
    Register `%rip` advances to the next instruction to be executed, or 0x530.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条`mov`指令（`mov -0x4(%rbp),%eax`）将栈位置0xd1c的值（即M[`%rbp` – 0x4]或0x28）复制并存储到寄存器`%eax`中。寄存器`%rip`推进到下一条要执行的指令地址，即0x530。
- en: '![image](../images/f0306-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0306-01.jpg)'
- en: Next, `add $0x2,%eax` is executed. Recall that the `add` instruction has the
    form `add S,D` and places the quantity S + D in the destination D. So, `add $0x2,`
    `%eax` adds the constant value 0x2 to the value stored in `%eax` (or 0x28), resulting
    in the value 0x2A being stored in register `%eax`. Register `%rip` advances to
    point to the next instruction to be executed, or 0x533.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，执行`add $0x2,%eax`。回想一下，`add`指令的形式是`add S,D`，将S + D的结果存储在目标D中。因此，`add $0x2,%eax`将常量值0x2加到寄存器`%eax`中存储的值（即0x28），结果是寄存器`%eax`中存储值0x2A。寄存器`%rip`推进到下一个要执行的指令地址，即0x533。
- en: '![image](../images/f0306-02.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0306-02.jpg)'
- en: 'The next instruction that executes is `pop %rbp`. This instruction “pops” the
    value off the top of the call stack and places it in destination register `%rbp`.
    Recall that this instruction is equivalent to the following sequence of two instructions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条执行的指令是`pop %rbp`。该指令将调用栈顶部的值“弹出”，并将其放入目标寄存器`%rbp`中。回想一下，这条指令等价于以下两条指令的组合：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Recall that the top of the stack is 0xd20, since that is the value stored in
    `%rsp`. Therefore, as soon as this instruction executes, the value `(%rsp)` (i.e.,
    M[0xd20]) is copied into register `%rbp`. Thus, `%rbp` now contains the value
    0xd40\. The stack pointer *increments* by 8, since the stack grows toward lower
    addresses (and consequently *shrinks* toward higher ones). The new value of `%rsp`
    is 0xd28, and `%rip` now points to the address of the last instruction to execute
    (i.e., 0x534).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，栈顶是0xd20，因为这是`%rsp`中存储的值。因此，一旦执行该指令，`(%rsp)`（即M[0xd20]）的值将被复制到寄存器`%rbp`中。因此，`%rbp`现在包含值0xd40。栈指针按8递增，因为栈是向低地址方向增长（因此，*向高地址方向收缩*）。`%rsp`的新值为0xd28，`%rip`现在指向最后一条要执行的指令地址（即0x534）。
- en: The last instruction executed is `retq`. We will talk more about what happens
    with `retq` in future sections when we discuss function calls, but for now it
    suffices to know that it prepares the call stack for returning from a function.
    By convention, the register `%rax` always contains the return value (if one exists).
    In this case, because `adder2` is of type `int`, the return value is stored in
    component register `%eax`, and the function returns the value 0x2A, or 42.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后执行的指令是`retq`。我们将在后续章节讨论函数调用时更详细地讲解`retq`的作用，但现在了解它是为返回函数时准备调用栈就足够了。按照惯例，寄存器`%rax`始终包含返回值（如果存在）。在本例中，由于`adder2`是`int`类型，返回值存储在寄存器`%eax`中，函数返回值为0x2A，即42。
- en: Before we continue, note that the final values in registers `%rsp` and `%rbp`
    are 0xd28 and 0xd40, respectively, which are the *same values as when the function
    started executing*! This is normal and expected behavior with the call stack.
    The purpose of the call stack is to store the temporary variables and data of
    each function as it executes in the context of a program. When a function completes
    executing, the stack returns to the state it was in prior to the function call.
    As a result, it is common to see the following two instructions at the beginning
    of a function
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，注意寄存器`%rsp`和`%rbp`中的最终值分别是0xd28和0xd40，这与函数开始执行时的值*相同*！这在调用栈中是正常且预期的行为。调用栈的作用是存储每个函数在程序执行过程中所使用的临时变量和数据。当函数执行完毕时，栈会恢复到函数调用前的状态。因此，在函数开始时，通常会看到以下两条指令：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'and the following two instructions at the end of a function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在函数结尾的以下两条指令：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 7.3 Arithmetic Instructions
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 算术指令
- en: The x86 ISA implements several instructions that correspond to arithmetic operations
    performed by the ALU. [Table 7-6](ch07.xhtml#ch7tab6) lists several arithmetic
    instructions that one may encounter when reading assembly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: x86架构实现了几个与ALU执行的算术操作对应的指令。[表 7-6](ch07.xhtml#ch7tab6)列出了在阅读汇编代码时可能遇到的几种算术指令。
- en: '**Table 7-6:** Common Arithmetic Instructions'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-6：** 常见算术指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `add S,D` | S + D → D |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `add S,D` | S + D → D |'
- en: '| `sub S,D` | D – S → D |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `sub S,D` | D – S → D |'
- en: '| `inc D` | D + 1 → D |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `inc D` | D + 1 → D |'
- en: '| `dec D` | D – 1 → D |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `dec D` | D – 1 → D |'
- en: '| `neg D` | –D → D |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `neg D` | –D → D |'
- en: '| `imul S,D` | S × D → D |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `imul S,D` | S × D → D |'
- en: '| `idiv S` | `%rax` / S: quotient → `%rax`, remainder → `%rdx` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `idiv S` | `%rax` / S: 商 → `%rax`，余数 → `%rdx` |'
- en: The `add` and `sub` instructions correspond to addition and subtraction and
    take two operands each. The next three entries show the single-register instructions
    for the increment (`x++`), decrement (`x--`), and negation (`-x`) operations in
    C. The multiplication instruction operates on two operands and places the product
    in the destination. If the product requires more than 64 bits to represent, the
    value is truncated to 64 bits.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`和`sub`指令对应加法和减法，每个指令需要两个操作数。接下来的三行显示了C语言中单寄存器的增量（`x++`）、减量（`x--`）和取反（`-x`）操作。乘法指令操作两个操作数，并将结果存入目的地。如果乘积需要超过64位来表示，则该值会被截断为64位。'
- en: The division instruction works a little differently. Prior to the execution
    of the `idiv` instruction, it is assumed that register `%rax` contains the dividend.
    Calling `idiv` on operand S divides the contents of `%rax` by S and places the
    quotient in register `%rax` and the remainder in register `%rdx`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除法指令的工作方式稍有不同。在执行`idiv`指令之前，假设寄存器`%rax`包含被除数。对操作数S调用`idiv`时，将`%rax`中的内容除以S，并将商存入寄存器`%rax`，余数存入寄存器`%rdx`。
- en: 7.3.1 Bit Shifting Instructions
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1 位移指令
- en: Bit shifting instructions enable the compiler to perform bit shifting operations.
    Multiplication and division instructions typically take a long time to execute.
    Bit shifting offers the compiler a shortcut for multiplicands and divisors that
    are powers of 2\. For example, to compute `77 * 4`, most compilers will translate
    this operation to `77 << 2` to avoid the use of an `imul` instruction. Likewise,
    to compute `77 / 4`, a compiler typically translates this operation to `77 >>
    2` to avoid using the `idiv` instruction.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 位移指令使编译器能够执行位移操作。乘法和除法指令通常需要较长的执行时间。位移提供了编译器对2的幂次乘数和除数的捷径。例如，要计算`77 * 4`，大多数编译器会将此操作转换为`77
    << 2`，以避免使用`imul`指令。同样，要计算`77 / 4`，编译器通常会将此操作转换为`77 >> 2`，以避免使用`idiv`指令。
- en: Keep in mind that left and right bit shift translate to different instructions
    based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，左移和右移操作根据目标是算术（有符号）移位还是逻辑（无符号）移位，所对应的指令不同。
- en: '**Table 7-7:** Bit Shift Instructions'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-7：** 移位指令'
- en: '| **Instruction** | **Translation** | **Arithmetic or Logical?** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** | **算术或逻辑？** |'
- en: '| `sal v,D` | D `≪` v → D | arithmetic |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `sal v,D` | D `≪` v → D | 算术 |'
- en: '| `shl v,D` | D `≪` v → D | logical |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `shl v,D` | D `≪` v → D | 逻辑 |'
- en: '| `sar v,D` | D `≫` v → D | arithmetic |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `sar v,D` | D `≫` v → D | 算术 |'
- en: '| `shr v,D` | D `≫` v → D | logical |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `shr v,D` | D `≫` v → D | 逻辑 |'
- en: Each shift instruction takes two operands, one which is usually a register (denoted
    by D) and the other which is a shift value (*v*). On 64-bit systems, the shift
    value is encoded as a single byte (since it doesn’t make sense to shift past 63).
    The shift value *v* must either be a constant or stored in register `%cl`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每条移位指令都有两个操作数，一个通常是寄存器（记作 D），另一个是移位值（*v*）。在 64 位系统中，移位值被编码为一个字节（因为移位超过 63 是没有意义的）。移位值
    *v* 必须是常量或存储在寄存器 `%cl` 中。
- en: '**Note DIFFERENT VERSIONS OF INSTRUCTIONS HELP DISTINGUISH TYPES AT AN ASSEMBLY
    LEVEL**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：不同版本的指令有助于在汇编层面区分类型**'
- en: At the assembly level, there is no notion of types. However, recall that the
    compiler will use component registers based on types. Similarly, recall that shift
    right works differently depending on whether the value is signed or unsigned.
    At the assembly level, the compiler uses separate instructions to distinguish
    between logical and arithmetic shifts!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编层面，没有类型的概念。然而，回忆一下编译器会根据类型使用不同的寄存器。同样，记住右移操作根据值是有符号还是无符号，工作方式也不同。在汇编层面，编译器使用不同的指令来区分逻辑移位和算术移位！
- en: 7.3.2 Bitwise Instructions
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2 按位指令
- en: Bitwise instructions enable the compiler to perform bitwise operations on data.
    One way the compiler uses bitwise operations is for certain optimizations. For
    example, a compiler may choose to implement 77 mod 4 with the operation `77 &`
    `3` in lieu of the more expensive `idiv` instruction.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 按位指令使编译器能够对数据执行按位操作。编译器使用按位操作的一种方式是进行某些优化。例如，编译器可能会选择使用 `77 & 3` 来代替开销更大的 `idiv`
    指令来实现 `77 mod 4`。
- en: '[Table 7-8](ch07.xhtml#ch7tab8) lists common bitwise instructions.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-8](ch07.xhtml#ch7tab8) 列出了常见的按位操作指令。'
- en: '**Table 7-8:** Bitwise Operations'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-8：** 按位操作'
- en: '| **Instruction** | **Translation** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `and S,D` | S `&` D → D |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `与 S,D` | S `&` D → D |'
- en: '| `or S,D` | S `&#124;` D → D |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `或 S,D` | S `&#124;` D → D |'
- en: '| `xor S,D` | S `^` D → D |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `异或 S,D` | S `^` D → D |'
- en: '| `not D` | `~`D → D |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `not D` | `~`D → D |'
- en: Remember that bitwise `not` is distinct from negation (`neg`). The `not` instruction
    flips the bits, but does not add 1\. Be careful not to confuse these two instructions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，按位 `not` 操作与取反操作（`neg`）不同。`not` 指令翻转比特位，但不加 1。小心不要混淆这两条指令。
- en: '**Warning USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：只有在需要时才在 C 代码中使用按位操作！**'
- en: After reading this section, it may be tempting to replace common arithmetic
    operations in your C code with bitwise shifts and other operations. This is *not*
    recommended. Most modern compilers are smart enough to replace simple arithmetic
    operations with bitwise operations when it makes sense, making it unnecessary
    for the programmer to do so. As a general rule, programmers should prioritize
    code readability whenever possible and avoid premature optimization.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本节内容后，可能会有冲动想用按位移位和其他操作替代 C 代码中的常见算术操作。但*不推荐*这样做。大多数现代编译器足够智能，在合适的时候将简单的算术操作替换为按位操作，这样程序员就无需手动做出这些优化。一般来说，程序员应优先考虑代码可读性，避免过早优化。
- en: 7.3.3 The Load Effective Address Instruction
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3 加载有效地址指令
- en: '*What’s lea got to do (got to do) with it?*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*lea 和这有什么关系？*'
- en: '*What’s lea, but an effective address loading?*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*lea 不就是一个有效地址加载吗？*'
- en: —With apologies to Tina Turner
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: —向蒂娜·特纳致歉
- en: We finally come to the *load effective address* or `lea` instruction, which
    is probably the arithmetic instruction that causes students the most consternation.
    It is traditionally used as a fast way to compute the address of a location in
    memory. The `lea` instruction operates on the same operand structure that we’ve
    seen thus far but does *not* include a memory lookup. Regardless of the type of
    data contained in the operand (whether it be a constant value or an address),
    `lea` simply performs arithmetic.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于来到了 *加载有效地址* 或 `lea` 指令，它可能是学生最困惑的算术指令。它通常用作快速计算内存中位置地址的一种方式。`lea` 指令在我们迄今为止看到的相同操作数结构上操作，但
    *不* 包含内存查找。无论操作数中包含的数据类型（无论是常数值还是地址），`lea` 仅执行算术运算。
- en: For example, suppose that register `%rax` contains the constant value 0x5, register
    `%rdx` contains the constant value 0x4, and register `%rcx` contains the value
    0x808 (which happens to be an address). [Table 7-9](ch07.xhtml#ch7tab9) depicts
    some example `lea` operations, their translations, and corresponding values.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设寄存器 `%rax` 存储常数值 0x5，寄存器 `%rdx` 存储常数值 0x4，寄存器 `%rcx` 存储值 0x808（这恰好是一个地址）。[表
    7-9](ch07.xhtml#ch7tab9)展示了一些 `lea` 操作示例、它们的翻译和相应的值。
- en: '**Table 7-9:** Example lea Operations'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-9：** 示例 lea 操作'
- en: '| **Instruction** | **Translation** | **Value** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** | **值** |'
- en: '| `lea 8(%rax), %rax` | 8 + `%rax` → `%rax` | 13 → `%rax` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `lea 8(%rax), %rax` | 8 + `%rax` → `%rax` | 13 → `%rax` |'
- en: '| `lea (%rax, %rdx), %rax` | `%rax` + `%rdx` → `%rax` | 9 → `%rax` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `lea (%rax, %rdx), %rax` | `%rax` + `%rdx` → `%rax` | 9 → `%rax` |'
- en: '| `lea (,%rax,4), %rax` | `%rax` × 4 → `%rax` | 20 → `%rax` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `lea (,%rax,4), %rax` | `%rax` × 4 → `%rax` | 20 → `%rax` |'
- en: '| `lea -0x8(%rcx), %rax` | `%rcx` – 8 → `%rax` | 0x800 → `%rax` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `lea -0x8(%rcx), %rax` | `%rcx` – 8 → `%rax` | 0x800 → `%rax` |'
- en: '| `lea -0x4(%rcx, %rdx, 2), %rax` | `%rcx` + `%rdx` × 2 – 4 → `%rax` | 0x80c
    → `%rax` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `lea -0x4(%rcx, %rdx, 2), %rax` | `%rcx` + `%rdx` × 2 – 4 → `%rax` | 0x80c
    → `%rax` |'
- en: In all cases, the `lea` instruction performs arithmetic on the operand specified
    by the source S and places the result in the destination operand D. The `mov`
    instruction is identical to the `lea` instruction *except* that the `mov` instruction
    is *required* to treat the contents in the source operand as a memory location
    if it is in a memory form. In contrast, `lea` performs the same (sometimes complicated)
    operand arithmetic *without* the memory lookup, enabling the compiler to cleverly
    use `lea` as a substitution for some types of arithmetic.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，`lea` 指令对源操作数 S 所指定的操作数执行算术运算，并将结果放入目标操作数 D 中。`mov` 指令与 `lea` 指令相同，*唯一的区别*是
    `mov` 指令在源操作数是内存形式时，*必须*将其内容视为内存地址。而 `lea` 则执行相同（有时是复杂的）操作数算术运算，*不进行*内存查找，使得编译器可以巧妙地使用
    `lea` 来替代某些类型的算术操作。
- en: 7.4 Conditional Control and Loops
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 条件控制与循环
- en: This section covers x86 assembly instructions for conditionals and loops (see
    “Conditionals and Loops” on [page 30](ch01.xhtml#lev1_3)). Recall that conditional
    statements enable coders to modify program execution based on the result of a
    conditional expression. The compiler translates conditionals into assembly instructions
    that modify the instruction pointer (`%rip`) to point to an address that is not
    the next one in the program sequence.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 x86 汇编指令中的条件语句和循环（请参见[第 30 页](ch01.xhtml#lev1_3)中的“条件语句和循环”）。回顾一下，条件语句使得程序员可以根据条件表达式的结果修改程序的执行流程。编译器将条件语句转换成汇编指令，这些指令通过修改指令指针（`%rip`）来跳转到程序序列中不是下一个地址的地方。
- en: 7.4.1 Preliminaries
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1 前提
- en: Conditional Comparison Instructions
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件比较指令
- en: Comparison instructions perform an arithmetic operation for the purpose of guiding
    the conditional execution of a program. [Table 7-10](ch07.xhtml#ch7tab10) lists
    the basic instructions associated with conditional control.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 比较指令执行算术运算，以指导程序的条件执行。[表 7-10](ch07.xhtml#ch7tab10)列出了与条件控制相关的基本指令。
- en: '**Table 7-10:** Conditional Control Instructions'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-10：** 条件控制指令'
- en: '| **Instruction** | **Translation** |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **翻译** |'
- en: '| `cmp R1, R2` | Compares R1 with R2 (i.e., evaluates R2 – R1) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `cmp R1, R2` | 比较 R1 和 R2（即计算 R2 – R1） |'
- en: '| `test R1, R2` | Computes R1 `&` R2 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `test R1, R2` | 计算 R1 `&` R2 |'
- en: 'The `cmp` instruction compares the values of two registers, R2 and R1\. Specifically,
    it subtracts R1 from R2\. The `test` instruction performs bitwise AND. It is common
    to see an instruction like:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp` 指令比较两个寄存器 R2 和 R1 的值。具体来说，它计算 R2 减去 R1 的结果。`test` 指令执行按位与运算。常见的指令可能是：'
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, the bitwise AND of `%rax` with itself is zero only when `%rax`
    contains zero. In other words, this is a test for a zero value and is equivalent
    to:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`%rax` 与自身的按位与操作仅当 `%rax` 包含零时结果为零。换句话说，这是对零值的测试，等效于：
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unlike the arithmetic instructions covered thus far, `cmp` and `test` do not
    modify the destination register. Instead, both instructions modify a series of
    single-bit values known as *condition code flags*. For example, `cmp` will modify
    condition code flags based on whether the value R2 – R1 results in a positive
    (greater), negative (less), or zero (equal) value. Recall that condition code
    values encode information about an operation in the ALU (see “The ALU” on [page
    261](ch05.xhtml#lev2_100)). The condition code flags are part of the `FLAGS` register
    on x86 systems.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不像迄今为止所涵盖的算术指令，`cmp` 和 `test` 不修改目标寄存器。相反，这两条指令修改一系列称为*条件码标志位*的单比特值。例如，`cmp`
    将根据 R2 – R1 的值是正数（大于）、负数（小于）还是零（等于）来修改条件码标志位。请回忆条件码值编码了 ALU（见第261页上的“ALU”）。条件码标志位是
    x86 系统中 `FLAGS` 寄存器的一部分。
- en: '**Table 7-11:** Common Condition Code Flags'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-11：** 常见条件码标志位'
- en: '| **Flag** | **Translation** |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **标志位** | **翻译** |'
- en: '| `ZF` | Is equal to zero (1: yes; 0: no) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `ZF` | 等于零（1：是；0：否） |'
- en: '| `SF` | Is negative (1: yes; 0: no) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `SF` | 是否为负数（1：是；0：否） |'
- en: '| `OF` | Overflow has occurred (1: yes; 0: no) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `OF` | 溢出发生了（1：是；0：否） |'
- en: '| `CF` | Arithmetic carry has occurred (1: yes; 0: no) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `CF` | 算术进位发生了（1：是；0：否） |'
- en: '[Table 7-11](ch07.xhtml#ch7tab11) depicts the common flags used for condition
    code operations. Revisiting the `cmp R1, R2` instruction:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-11](ch07.xhtml#ch7tab11) 描述了用于条件码操作的常见标志位。重新审视 `cmp R1, R2` 指令：'
- en: The `ZF` flag is set to 1 if R1 and R2 are equal.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 R1 和 R2 相等时，`ZF` 标志位被设置为1。
- en: The `SF` flag is set to 1 if R2 is *less* than R1 (R2 – R1 results in a negative
    value).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 R2 小于 R1（R2 – R1 导致负值），则 `SF` 标志位被设置为1。
- en: The `OF` flag is set to 1 if the operation R2 – R1 results in an integer overflow
    (useful for signed comparisons).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作 R2 – R1 导致整数溢出，则 `OF` 标志位被设置为1（适用于有符号比较）。
- en: The `CF` flag is set to 1 if the operation R2 – R1 results in a carry operation
    (useful for unsigned comparisons).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作 R2 – R1 导致进位操作，则 `CF` 标志位被设置为1（适用于无符号比较）。
- en: The `SF` and `OF` flags are used for comparison operations on signed integers,
    whereas the `CF` flag is used for comparisons on unsigned integers. Although an
    in-depth discussion of condition code flags is beyond the scope of this book,
    the setting of these registers by `cmp` and `test` enables the next set of instructions
    we cover (the *jump* instructions) to operate correctly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`SF` 和 `OF` 标志位用于有符号整数比较操作，而 `CF` 标志位用于无符号整数比较。虽然对条件码标志位的深入讨论超出了本书的范围，但 `cmp`
    和 `test` 设置这些寄存器使得我们接下来介绍的一组指令（*跳转*指令）能够正确运行。'
- en: Jump Instructions
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 跳转指令
- en: A jump instruction enables a program’s execution to “jump” to a new position
    in the code. In the assembly programs we have traced through thus far, `%rip`
    always points to the next instruction in program memory. The jump instructions
    enable `%rip` to be set to either a new instruction not yet seen (as in the case
    of an `if` statement) or to a previously executed instruction (as in the case
    of a loop).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转指令使得程序可以“跳转”到代码中的新位置执行。在迄今为止跟踪的汇编程序中，`%rip` 总是指向程序存储器中的下一条指令。跳转指令使得 `%rip`
    可以设置为一个尚未见过的新指令（如 `if` 语句中的情况）或者已经执行过的指令（如循环中的情况）。
- en: '**Table 7-12:** Direct Jump Instructions'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-12：** 直接跳转指令'
- en: '| **Instruction** | **Description** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| `jmp L` | Jump to location specified by L |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `jmp L` | 跳转到由 L 指定的位置 |'
- en: '| `jmp *addr` | Jump to specified address |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `jmp *addr` | 跳转到指定地址 |'
- en: '**Direct jump instructions.**   [Table 7-12](ch07.xhtml#ch7tab12) lists the
    set of direct jump instructions; `L` refers to a *symbolic label*, which serves
    as an identifier in the program’s object file. All labels consist of some letters
    and digits followed by a colon. Labels can be *local* or *global* to an object
    file’s scope. Function labels tend to be *global* and usually consist of the function
    name and a colon. For example, `main:` (or `<main>:`) is used to label a user-defined
    `main` function. In contrast, labels whose scope are *local* are preceded by a
    period. For example, `.L1:` is a local label one may encounter in the context
    of an `if` statement or loop.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接跳转指令。**   [表 7-12](ch07.xhtml#ch7tab12) 列出了直接跳转指令集；`L` 指的是一个*符号标签*，它在程序的目标文件中充当标识符。所有标签由一些字母和数字组成，后跟一个冒号。标签可以是程序文件范围内的*本地*或*全局*标签。函数标签通常是*全局*的，并且通常由函数名称和冒号组成。例如，`main:`（或
    `<main>:`）用于标记用户定义的 `main` 函数。相比之下，作用域为*本地*的标签前面带有一个点。例如，`.L1:` 是在 `if` 语句或循环上下文中可能遇到的本地标签。'
- en: All labels have an associated address. When the CPU executes a `jmp` instruction,
    it modifies `%rip` to reflect the program address specified by label `L`. A programmer
    writing assembly can also specify a particular address to jump to using the `jmp
    *` instruction. Sometimes, local labels are shown as an offset from the start
    of a function. Therefore, an instruction whose address is 28 bytes away from the
    start of `main` may be represented with the label `<main+28>`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标签都有关联的地址。当 CPU 执行 `jmp` 指令时，会修改 `%rip` 以反映由标签 `L` 指定的程序地址。汇编程序员还可以使用 `jmp
    *` 指令指定要跳转到的特定地址。有时，本地标签显示为相对于函数开头的偏移量。因此，距离 `main` 开始处 28 字节的指令可能被表示为标签 `<main+28>`。
- en: For example, the instruction `jmp 0x8048427 <main+28>` indicates a jump to address
    0x8048427, which has the associated label `<main+28>`, representing that it is
    28 bytes away from the starting address of the `main` function. Executing this
    instruction sets `%rip` to 0x8048427.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，指令 `jmp 0x8048427 <main+28>` 表示跳转到地址 0x8048427，其关联标签为 `<main+28>`，表示距离 `main`
    函数起始地址 28 字节处。执行此指令会将 `%rip` 设置为 0x8048427。
- en: '**Conditional jump instructions.**    The behavior of conditional jump instructions
    depends on the condition code registers set by the `cmp` instruction. [Table 7-13](ch07.xhtml#ch7tab13)
    lists the set of common conditional jump instructions. Each instruction starts
    with the letter `j` denoting that it is a jump instruction. The suffix of each
    instruction indicates the *condition* for the jump. The jump instruction suffixes
    also determine whether to interpret numerical comparisons as signed or unsigned.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件跳转指令。**    条件跳转指令的行为取决于由 `cmp` 指令设置的条件码寄存器。[表 7-13](ch07.xhtml#ch7tab13)
    列出了常见条件跳转指令集。每条指令以字母 `j` 开头，表示它是一条跳转指令。每条指令的后缀指示跳转的条件。跳转指令的后缀还确定了是将数值比较解释为有符号还是无符号。'
- en: '**Table 7-13:** Conditional Jump Instructions; Synonyms Shown in Parentheses'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-13：** 条件跳转指令；同义词显示在括号中'
- en: '| **Signed Comparison** | **Unsigned Comparison** | **Description** |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **有符号比较** | **无符号比较** | **描述** |'
- en: '| `je` (`jz`) |  | jump if equal (==) or jump if zero |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `je` (`jz`) |  | 等于时跳转（==）或零时跳转 |'
- en: '| `jne` (`jnz`) |  | jump if not equal (!=) |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `jne` (`jnz`) |  | 不等于时跳转（!=） |'
- en: '| `js` |  | jump if negative |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `js` |  | 负数时跳转 |'
- en: '| `jns` |  | jump if non-negative |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `jns` |  | 负数时跳转 |'
- en: '| `jg` (`jnle`) | `ja` (`jnbe`) | jump if greater (>) |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `jg` (`jnle`) | `ja` (`jnbe`) | 大于时跳转（>） |'
- en: '| `jge` (`jnl`) | `jae` (`jnb`) | jump if greater than or equal (>=) |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `jge` (`jnl`) | `jae` (`jnb`) | 大于等于时跳转（>=） |'
- en: '| `jl` (`jnge`) | `jb` (`jnae`) | jump if less (<) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `jl` (`jnge`) | `jb` (`jnae`) | 小于时跳转（<） |'
- en: '| `jle` (`jng`) | `jbe` (`jna`) | jump if less than or equal (<=) |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `jle` (`jng`) | `jbe` (`jna`) | 小于等于时跳转（<=） |'
- en: Instead of memorizing these different conditional jump instructions, it is more
    helpful to sound out the instruction suffixes. [Table 7-14](ch07.xhtml#ch7tab14)
    lists the letters commonly found in jump instructions and their word correspondence.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不要记忆这些不同的条件跳转指令，通过读出指令后缀更有帮助。[表 7-14](ch07.xhtml#ch7tab14) 列出了常见跳转指令中常见的字母及其对应的单词。
- en: '**Table 7-14:** Jump Instruction Suffixes'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 7-14：** 跳转指令后缀'
- en: '| **Letter** | **Word** |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **字母** | **单词** |'
- en: '| `j` | jump |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `j` | 跳转 |'
- en: '| `n` | not |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 不 |'
- en: '| `e` | equal |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `e` | 等于 |'
- en: '| `s` | signed |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 有符号 |'
- en: '| `g` | greater (signed interpretation) |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 大于（有符号解释） |'
- en: '| `l` | less (signed interpretation) |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 小于（有符号解释） |'
- en: '| `a` | above (unsigned interpretation) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 大于（无符号解释） |'
- en: '| `b` | below (unsigned interpretation) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 下面（无符号解释） |'
- en: Sounding it out, we can see that `jg` corresponds to *jump greater* and that
    its signed synonym `jnl` stands for *jump not less*. Likewise, the unsigned version
    `ja` stands for *jump above*, whereas its synonym `jnbe` stands for *jump not
    below or equal*.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读出这些指令，我们可以看到 `jg` 对应于 *跳转大于*，而它的带符号同义词 `jnl` 则代表 *跳转不小于*。同样，无符号版本 `ja` 代表
    *跳转大于*，而它的同义词 `jnbe` 代表 *跳转不小于或等于*。
- en: If you sound out the instructions, it helps to explain why certain synonyms
    correspond to particular instructions. The other thing to remember is that the
    terms *greater* and *less* instruct the CPU to interpret the numerical comparison
    as a signed value, whereas *above* and *below* indicate that the numerical comparison
    is unsigned.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些指令读出来，会有助于理解为什么某些同义词对应特定的指令。另一点需要记住的是，*greater* 和 *less* 会指示 CPU 将数字比较解释为带符号值，而
    *above* 和 *below* 则表明数字比较是无符号的。
- en: The goto statement
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: goto 语句
- en: In the following subsections, we look at conditionals and loops in assembly
    and reverse engineer them back to C. When translating assembly code of conditionals
    and loops back into C, it is useful to understand the corresponding C language
    `goto` forms. The `goto` statement is a C primitive that forces program execution
    to switch to another line in the code. The assembly instruction associated with
    the `goto` statement is `jmp`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的小节中，我们将讨论汇编中的条件语句和循环，并将它们反向工程回 C 语言。当将汇编代码中的条件语句和循环翻译回 C 语言时，理解对应的 C 语言`goto`形式是很有帮助的。`goto`语句是
    C 语言中的一种原语，它强制程序执行跳转到代码中的另一行。与 `goto` 语句相关的汇编指令是 `jmp`。
- en: The `goto` statement consists of the `goto` keyword followed by a *goto label*,
    a type of program label that indicates where execution should continue. So, `goto
    done` means that the program execution should jump to the line marked by label
    `done`. Other examples of program labels in C include the `switch` statement labels
    previously covered in “switch Statements” on [page 122](ch02.xhtml#lev2_36).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 语句由 `goto` 关键字和一个*跳转标签*组成，跳转标签是一种程序标签，用于指示程序应该从哪里继续执行。因此，`goto done`表示程序执行应跳转到标签为
    `done` 的行。C 语言中的其他程序标签例子包括在“switch 语句”中提到的 `switch` 语句标签，[第122页](ch02.xhtml#lev2_36)也有介绍。'
- en: The following code listings depict a function `getSmallest` written in regular
    C code (first) and its associated `goto` form in C (second). The `getSmallest`
    function compares the values of two integers (`x` and `y`), and assigns the smaller
    value to the variable `smallest`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码清单展示了一个函数 `getSmallest`，它首先用常规的 C 代码编写（第一部分），然后展示其相应的 C 语言 `goto` 形式（第二部分）。`getSmallest`
    函数比较两个整数（`x` 和 `y`）的值，并将较小的值赋给变量 `smallest`。
- en: Regular C version
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 常规 C 版本
- en: '[PRE14]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: goto version
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: goto 版本
- en: '[PRE15]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `goto` form of this function may seem counterintuitive, but let’s discuss
    what exactly is going on. The conditional checks to see whether variable `x` is
    less than or equal to `y`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的 `goto` 形式可能看起来有些反直觉，但让我们来讨论一下究竟发生了什么。条件语句检查变量 `x` 是否小于或等于 `y`。
- en: If `x` is less than or equal to `y`, the program transfers control to the label
    marked by `else_statement`, which contains the single statement `smallest = x`.
    Since the program executes linearly, the program continues on to execute the code
    under the label `done`, which returns the value of `smallest` (`x`).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `x` 小于或等于 `y`，程序将控制权转移到标记为 `else_statement` 的标签，该标签下包含单个语句 `smallest = x`。由于程序是线性执行的，因此程序会继续执行
    `done` 标签下的代码，返回 `smallest` 的值（即 `x`）。
- en: If `x` is greater than `y`, `smallest` is assigned the value `y`. The program
    then executes the statement `goto done`, which transfers control to the `done`
    label, which returns the value of `smallest` (`y`).
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `x` 大于 `y`，则将 `smallest` 赋值为 `y`。然后程序执行 `goto done` 语句，这会将控制权转移到 `done` 标签，返回
    `smallest` 的值（即 `y`）。
- en: While `goto` statements were commonly used in the early days of programming,
    the use of `goto` statements in modern code is considered bad practice, as it
    reduces the overall readability of code. In fact, computer scientist Edsger Dijkstra
    wrote a famous paper lambasting the use of `goto` statements called “Go To Statement
    Considered Harmful.”^([1](ch07.xhtml#fn7_1))
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `goto` 语句在编程的早期被广泛使用，但在现代代码中使用 `goto` 语句被认为是一种不好的做法，因为它会降低代码的可读性。实际上，计算机科学家埃兹赫尔·代克斯特拉（Edsger
    Dijkstra）曾写过一篇著名的论文，猛烈批评了 `goto` 语句的使用，论文名为“Go To 语句被认为有害”。^([1](ch07.xhtml#fn7_1))
- en: In general, well-designed C programs do not use `goto` statements, and programmers
    are discouraged from using them to avoid writing code that is difficult to read,
    debug, and maintain. However, the C `goto` statement is important to understand,
    as GCC typically changes C code with conditionals into a `goto` form prior to
    translating it to assembly, including code that contains `if` statements and loops.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，设计良好的 C 程序不会使用 `goto` 语句，并且程序员通常被建议避免使用它们，以避免编写难以阅读、调试和维护的代码。然而，理解 C 语言中的
    `goto` 语句非常重要，因为 GCC 通常会在将 C 代码翻译成汇编之前，将包含条件语句和循环的代码转换为 `goto` 形式。
- en: 7.4.2 if Statements in Assembly
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2 汇编中的 `if` 语句
- en: 'Let’s take a look at the `getSmallest` function in assembly. For convenience,
    the function is reproduced here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下汇编中的 `getSmallest` 函数。为了方便，这里重新列出该函数：
- en: '[PRE16]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The corresponding assembly code extracted from GDB looks similar to the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从 GDB 提取的相应汇编代码如下所示：
- en: '[PRE17]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a different view of the assembly code than we have seen before. Here,
    we can see the *address* associated with each instruction, but not the *bytes*.
    Note that this assembly segment has been lightly edited for the sake of simplicity.
    The instructions that are normally part of function creation (i.e., `push %rbp`,
    `mov %rsp,%rbp`) are removed. By convention, GCC places the first and second parameters
    of a function in registers `%rdi` and `%rsi`, respectively. Since the parameters
    to `getSmallest` are of type `int`, the compiler places the parameters in the
    respective component registers `%edi` and `%esi` instead. For the sake of clarity,
    we refer to these parameters as `x` and `y`, respectively.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前看到的汇编代码的另一种视角。在这里，我们可以看到与每条指令相关联的*地址*，但看不到*字节*。请注意，为了简化说明，这段汇编代码已经做了轻微编辑。通常作为函数创建一部分的指令（例如
    `push %rbp`，`mov %rsp,%rbp`）已被移除。根据惯例，GCC 会将函数的第一个和第二个参数分别放入寄存器 `%rdi` 和 `%rsi`
    中。由于 `getSmallest` 函数的参数类型为 `int`，编译器将这些参数放入相应的组件寄存器 `%edi` 和 `%esi` 中。为了便于说明，我们将这些参数分别称为
    `x` 和 `y`。
- en: Let’s trace through the first few lines of the previous assembly code snippet.
    Note that we will not draw out the stack explicitly in this example. We leave
    this as an exercise for the reader and encourage you to practice your stack tracing
    skills by drawing it out yourself.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟踪前面汇编代码片段的前几行。请注意，在这个例子中我们不会显式地绘制堆栈。我们将这作为一个练习留给读者，并鼓励你通过自己画出来来练习堆栈跟踪技巧。
- en: The first `mov` instruction copies the value located in register `%edi` (the
    first parameter, `x`) and places it at memory location `%rbp-0x14` on the call
    stack. The instruction pointer (`%rip`) is set to the address of the next instruction,
    or 0x40059d.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一条 `mov` 指令将寄存器 `%edi`（第一个参数 `x`）中的值复制到调用栈中的内存位置 `%rbp-0x14`。指令指针（`%rip`）设置为下一个指令的地址，或者
    0x40059d。
- en: The second `mov` instruction copies the value located in register `%esi` (the
    second parameter, `y`) and places it at memory location `%rbp-0x18` on the call
    stack. The instruction pointer (`%rip`) updates to point to the address of the
    next instruction, or 0x4005a0.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二条 `mov` 指令将寄存器 `%esi`（第二个参数 `y`）中的值复制到调用栈中的内存位置 `%rbp-0x18`。指令指针（`%rip`）更新，指向下一个指令的地址，或者
    0x4005a0。
- en: The third `mov` instruction copies `x` to register `%eax`. Register `%rip` updates
    to point to the address of the next instruction in sequence.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三条 `mov` 指令将 `x` 复制到寄存器 `%eax`。寄存器 `%rip` 更新，指向顺序中下一个指令的地址。
- en: The `cmp` instruction compares the value at location `%rbp-0x18` (the second
    parameter, `y`) to `x` and sets appropriate condition code flag registers. Register
    `%rip` advances to the address of the next instruction, or 0x4005a6.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmp` 指令将位置 `%rbp-0x18`（第二个参数 `y`）的值与 `x` 进行比较，并设置相应的条件码标志寄存器。寄存器 `%rip` 会跳转到下一个指令的地址，或者
    0x4005a6。'
- en: The `jle` instruction at address 0x4005a6 indicates that if `x` is less than
    or equal to `y`, the next instruction that should execute should be at location
    `<getSmallest+26>` and that `%rip` should be set to address 0x4005b0\. Otherwise,
    `%rip` is set to the next instruction in sequence, or 0x4005a8.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址 0x4005a6 处的 `jle` 指令表示，如果 `x` 小于或等于 `y`，则应该执行下一条指令，其地址位于 `<getSmallest+26>`，并且
    `%rip` 应该设置为地址 0x4005b0。否则，`%rip` 设置为下一个顺序指令的地址，或者 0x4005a8。
- en: 'The next instructions to execute depend on whether the program follows the
    branch (i.e., executes the jump) at address 0x4005a6\. Let’s first suppose that
    the branch was *not* followed. In this case, `%rip` is set to 0x4005a8 (i.e.,
    `<getSmallest+18>`) and the following sequence of instructions executes:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来执行的指令取决于程序是否在地址 0x4005a6 跳转（即执行跳转）。我们首先假设没有跟随跳转。在这种情况下，`%rip` 被设置为 0x4005a8（即
    `<getSmallest+18>`），接下来执行的指令序列如下：
- en: The `mov -0x18(%rbp), %eax` instruction at `<getSmallest+18>` copies `y` to
    register `%eax`. Register `%rip` advances to 0x4005ae.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+18>` 处的 `mov -0x18(%rbp), %eax` 指令将 `y` 复制到寄存器 `%eax`。寄存器 `%rip`
    移动到 0x4005ae。'
- en: The `jmp` instruction at `<getSmallest+24>` sets register `%rip` to address
    0x4005b9.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<getSmallest+24>` 处的 `jmp` 指令将寄存器 `%rip` 设置为地址 0x4005b9。'
- en: The last instructions to execute are the `pop` `%rbp` instruction and the `retq`
    instruction, which cleans up the stack and returns from the function call. In
    this case, `y` is in the return register.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后要执行的指令是 `pop` `%rbp` 指令和 `retq` 指令，它们清理堆栈并从函数调用中返回。在这种情况下，`y` 存在于返回寄存器中。
- en: 'Now, suppose that the branch was taken at `<getSmallest+16>`. In other words,
    the `jle` instruction sets register `%rip` to 0x4005b0 (i.e., `<getSmallest+26>`).
    Then, the next instructions to execute are:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设跳转发生在 `<getSmallest+16>`。换句话说，`jle` 指令将寄存器 `%rip` 设置为 0x4005b0（即 `<getSmallest+26>`）。接下来执行的指令是：
- en: The `mov -0x14(%rbp),%eax` instruction at address 0x4005b0 copies `x` to register
    `%eax`. Register `%rip` advances to 0x4005b9.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址 0x4005b0 的 `mov -0x14(%rbp),%eax` 指令将 `x` 复制到寄存器 `%eax`。寄存器 `%rip` 移动到 0x4005b9。
- en: The last instructions that execute are `pop %rbp` and `retq`, which cleans up
    the stack and returns the value in the return register. In this case, component
    register `%eax` contains `x`, and `getSmallest` returns `x`.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行的最后一条指令是 `pop %rbp` 和 `retq`，它们清理堆栈并返回返回寄存器中的值。在这种情况下，寄存器 `%eax` 包含 `x`，而
    `getSmallest` 返回 `x`。
- en: 'We can then annotate the preceding assembly as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按如下方式注释之前的汇编代码：
- en: '[PRE18]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Translating this back to C code yields:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将此翻译回 C 代码得到：
- en: goto form
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: goto 形式
- en: '[PRE19]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Translated C code
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译后的 C 代码
- en: '[PRE20]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In these code listings, the variable `smallest` corresponds to register `%eax`.
    If `x` is less than or equal to `y`, the code executes the statement `smallest
    = x`, which is associated with the `goto` label `assign_x` in our `goto` form
    of this function. Otherwise, the statement `smallest = y` is executed. The `goto`
    label `done` is used to indicate that the value in `smallest` should be returned.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码列表中，变量 `smallest` 对应于寄存器 `%eax`。如果 `x` 小于或等于 `y`，代码将执行语句 `smallest = x`，这与我们
    `goto` 形式中函数的 `assign_x` 标签相关联。否则，执行语句 `smallest = y`。`goto` 标签 `done` 用于表示应返回
    `smallest` 中的值。
- en: 'Notice that the preceding C translation of the assembly code is a bit different
    from the original `getSmallest` function. These differences don’t matter; close
    inspection of both functions reveals that the two programs are logically equivalent.
    However, the compiler first converts any `if` statement into an equivalent `goto`
    form, which results in the slightly different but equivalent version. The following
    code examples show the standard `if` statement format and its equivalent `goto`
    form:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，之前对汇编代码的 C 翻译与原始的 `getSmallest` 函数略有不同。这些差异不重要；仔细检查两个函数可以发现这两个程序在逻辑上是等价的。然而，编译器首先将任何
    `if` 语句转换为等效的 `goto` 形式，这导致了略微不同但等价的版本。以下代码示例显示了标准的 `if` 语句格式及其等效的 `goto` 形式：
- en: C if statement
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: C 的 if 语句
- en: '[PRE21]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compiler’s equivalent goto form
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的等效 goto 形式
- en: '[PRE22]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Compilers translating code into assembly designate a jump when a condition is
    true. Contrast this behavior with the structure of an `if` statement, where a
    “jump” (to the `else`) occurs when conditions are *not* true. The `goto` form
    captures this difference in logic.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将代码翻译成汇编时，在条件为真时指定跳转。与此行为相比，`if` 语句的结构是，当条件 *不* 为真时会发生“跳转”（到 `else`）。`goto`
    形式捕获了这种逻辑差异。
- en: 'Considering the original `goto` translation of the `getSmallest` function,
    we can see that:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 `getSmallest` 函数的原始 `goto` 翻译，我们可以看到：
- en: '`x <= y` corresponds to `!*<condition>*`.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x <= y` 对应于 `!*<condition>*`。'
- en: '`smallest = x` is the <else_statement>.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smallest = x` 是 <else_statement>。'
- en: The line `smallest = y` is the <then_statement>.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smallest = y` 这一行是 <then_statement>。'
- en: The last line in the function is `return smallest`.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数中的最后一行是 `return smallest`。
- en: 'Rewriting the original version of the function with the preceding annotations
    yields:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的注释重写原始版本的函数得到：
- en: '[PRE23]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This version is identical to the original `getSmallest` function. Keep in mind
    that a function written in different ways at the C code level can translate to
    the same set of assembly instructions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The cmov Instructions
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The last set of conditional instructions we cover are *conditional move* (`cmov`)
    instructions. The `cmp`, `test`, and `jmp` instructions implement a *conditional
    transfer of control* in a program. In other words, the execution of the program
    branches in many directions. This can be very problematic for optimizing code
    because these branches are very expensive.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the `cmov` instruction implements a *conditional transfer of data*.
    In other words, both the <then_statement> and <else_statement> of the conditional
    are executed, and the data is placed in the appropriate register based on the
    result of the condition.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of C’s *ternary expression* often results in the compiler generating
    a `cmov` instruction in place of jumps. For the standard if-then-else statement,
    the ternary expression has the form:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s use this format to rewrite the `getSmallest` function as a ternary expression.
    Keep in mind that this new version of the function behaves exactly as the original
    `getSmallest` function:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although this may not seem like a big change, let’s look at the resulting assembly.
    Recall that the first and second parameters (`x` and `y`) are stored in registers
    `%edi` and `%esi`, respectively.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This assembly code has no jumps. After the comparison of `x` and `y`, `x` moves
    into the return register only if `x` is less than or equal to `y`. Like the jump
    instructions, the suffix of the `cmov` instructions indicates the condition on
    which the conditional move occurs. [Table 7-15](ch07.xhtml#ch7tab15) lists the
    set of conditional move instructions.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-15:** The `cmov` Instructions'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signed** | **Unsigned** | **Description** |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| `cmove` (`cmovz`) |  | move if equal (==) |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| `cmovne` (`cmovnz`) |  | move if not equal (!=) |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| `cmovs` |  | move if negative |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| `cmovns` |  | move if non-negative |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| `cmovg` (`cmovnle`) | `cmova` (`cmovnbe`) | move if greater (>) |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| `cmovge` (`cmovnl`) | `cmovae` (`cmovnb`) | move if greater than or equal
    (>=) |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| `cmovl` (`cmovnge`) | `cmovb` (`cmovnae`) | move if less (<) |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| `cmovle` (`cmovng`) | `cmovbe` (`cmovna`) | move if less than or equal (<=)
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: 'In the case of the original `getSmallest` function, the compiler’s internal
    optimizer (see [Chapter 12](ch12.xhtml#ch12)) will replace the jump instructions
    with a `cmov` instruction if level 1 optimizations are turned on (i.e., `-O1`):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In general, the compiler is very cautious about optimizing jump instructions
    into `cmov` instructions, especially in cases where side effects and pointer values
    are involved. Here, we show two equivalent ways of writing a function, `incrementX`:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: C code
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: C ternary form
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each function takes a pointer to an integer as input and checks whether it is
    `NULL`. If `x` is not `NULL`, the function increments and returns the dereferenced
    value of `x`. Otherwise, the function returns the value 1.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'It is tempting to think that `incrementX2` uses a `cmov` instruction since
    it uses a ternary expression. However, both functions yield the exact same assembly
    code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Recall that the `cmov` instruction *executes both branches of the conditional*.
    In other words, `x` gets dereferenced no matter what. Consider the case where
    `x` is a null pointer. Recall that dereferencing a null pointer leads to a null
    pointer exception in the code, causing a segmentation fault. To prevent any chance
    of this happening, the compiler takes the safe road and uses jumps.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.3 Loops in Assembly
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like `if` statements, loops in assembly are also implemented using jump instructions.
    However, loops enable instructions to be *revisited* based on the result of an
    evaluated condition.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The `sumUp` function shown in the following example sums up all the positive
    integers from 1 to a user-defined integer. This code is intentionally written
    suboptimally to illustrate a `while` loop in C.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Compiling this code and disassembling it using GDB yields the following assembly
    code:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Again, we will not draw out the stack explicitly in this example. However, we
    encourage readers to draw the stack out themselves.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: The First Five Instructions
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first five instructions of this function set the stack up for function
    execution and set up temporary values for function execution:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Recall that stack locations store *temporary variables* in a function. For simplicity
    we will refer to the location marked by `%rbp-0x8` as `total`, and `%rbp-0x4`
    as `i`. The input parameter to `sumUp` (`n`) is moved to stack location `%rbp-0x14`.
    Despite the placement of temporary variables on the stack, keep in mind that the
    stack pointer has not changed after the execution of the first instruction (i.e.,
    `push %rbp`).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The Heart of the Loop
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next seven instructions in the `sumUp` function represent the heart of
    the loop:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first instruction is a direct jump to `<sumUp+33>`, which sets the instruction
    pointer (`%rip`) to address 0x400547.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next instruction that executes is `mov -0x4(%rbp),%eax`, which places the
    value of `i` in register `%eax`. Register `%rip` is updated to 0x40054a.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` instruction at `<sumUp+36>` compares `i` to `n` and sets the appropriate
    condition code registers. Register `%rip` is set to 0x40054d.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jle` instruction then executes. The instructions that execute next depend
    on whether or not the branch is taken.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that the branch *is* taken (i.e., `i <= n` is true). Then the instruction
    pointer is set to 0x40053d and program execution jumps to `<sumUp+23>`. The following
    instructions then execute in sequence:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: The `mov` instruction at `<sumUp+23>` copies `i` to register `%eax`.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add %eax,-0x8(%rbp)` adds `i` to `total` (i.e., `total += i`).
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add` instruction at `<sumUp+29>` then adds 1 to `i` (i.e., `i += 1`).
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+29>` 处的 `add` 指令将 1 加到 `i` 上（即 `i += 1`）。'
- en: The `mov` instruction at `<sumUp+33>` copies the updated value of `i` to register
    `%eax`.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sumUp+33>` 处的 `mov` 指令将更新后的 `i` 值复制到寄存器 `%eax`。'
- en: The `cmp` instruction then compares `i` to `n` and sets the appropriate condition
    code registers.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmp` 指令随后将 `i` 与 `n` 进行比较，并设置适当的条件码寄存器。'
- en: Next, `jle` executes. If `i` is less than or equal to `n`, program execution
    once again jumps to `<sumUp+23>` and the loop (defined between `<sumUp+23>` and
    `<sumUp+39>`) repeats.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，`jle` 执行。如果 `i` 小于或等于 `n`，程序执行会再次跳转到 `<sumUp+23>`，并且循环（在 `<sumUp+23>` 和
    `<sumUp+39>` 之间定义）会重复。
- en: 'If the branch is *not* taken (i.e., `i` is *not* less than or equal to `n`),
    the following instructions execute:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分支 *没有* 被执行（即 `i` *不* 小于或等于 `n`），则执行以下指令：
- en: '[PRE35]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These instructions copy `total` to register `%eax`, restore `%rbp` to its original
    value, and exit the function. Thus, the function returns `total` upon exit.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令将 `total` 复制到寄存器 `%eax`，恢复 `%rbp` 的原始值，并退出函数。因此，函数在退出时返回 `total`。
- en: 'The following code shows the assembly and then the C `goto` forms of the `sumUp`
    function:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `sumUp` 函数的汇编形式和 C 语言中 `goto` 的形式：
- en: Assembly
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编
- en: '[PRE36]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Translated goto form
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的 goto 形式
- en: '[PRE37]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding code is also equivalent to the following C code without `goto`
    statements:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码也等同于以下没有 `goto` 语句的 C 代码：
- en: '[PRE38]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: for Loops in Assembly
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 汇编中的 for 循环
- en: 'The primary loop in the `sumUp` function can also be written as a `for` loop:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumUp` 函数中的主要循环也可以写成一个 `for` 循环：'
- en: '[PRE39]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This version yields assembly code identical to our `while` loop example. We
    repeat the assembly code here and annotate each line with its English translation:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本生成的汇编代码与我们的 `while` 循环示例相同。我们在此重复汇编代码，并用英文注释标注每一行：
- en: '[PRE40]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To understand why the `for` loop version of this code results in identical assembly
    to the `while` loop version of the code, recall that the `for` loop has the following
    representation
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么该 `for` 循环版本的代码和 `while` 循环版本生成相同的汇编代码，回忆一下 `for` 循环的表示形式如下：
- en: '[PRE41]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and is equivalent to the following `while` loop representation:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 并且等同于以下的 `while` 循环表示形式：
- en: '[PRE42]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since every `for` loop can be represented by a `while` loop (see “for Loops”
    on [page 35](ch01.xhtml#lev3_5)), the following two C programs are equivalent
    representations for the previous assembly:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 `for` 循环都可以用 `while` 循环表示（请参见 [第 35 页](ch01.xhtml#lev3_5)的“for 循环”部分），以下两个
    C 程序是与前述汇编代码等效的表示：
- en: For loop
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: For 循环
- en: '[PRE43]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: While loop
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: While 循环
- en: '[PRE44]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 7.5 Functions in Assembly
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 汇编中的函数
- en: In the previous section, we traced through simple functions in assembly. In
    this section, we discuss the interaction between multiple functions in assembly
    in the context of a larger program. We also introduce some new instructions involved
    with function management.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们追踪了简单的汇编函数。在本节中，我们将讨论多个函数在汇编中的交互，特别是在一个更大程序的上下文中。我们还将介绍一些与函数管理相关的新指令。
- en: Let’s begin with a refresher on how the call stack is managed. Recall that `%rsp`
    is the *stack pointer* and always points to the top of the stack. The register
    `%rbp` represents the base pointer (also known as the *frame pointer*) and points
    to the base of the current stack frame. The *stack frame* (also known as the *activation
    frame* or the *activation record*) refers to the portion of the stack allocated
    to a single function call. The currently executing function is always at the top
    of the stack, and its stack frame is referred to as the *active frame*. The active
    frame is bounded by the stack pointer (at the top of stack) and the frame pointer
    (at the bottom of the frame). The activation record typically holds local variables
    for a function. [Figure 7-4](ch07.xhtml#ch7fig4) shows the stack frames for `main`
    and a function it calls named `fname`. We will refer to the `main` function as
    the *caller* function and `fname` as the *callee* function.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从复习一下如何管理调用栈开始。回忆一下，`%rsp` 是 *栈指针*，它始终指向栈的顶部。寄存器 `%rbp` 代表基指针（也称为 *帧指针*），指向当前栈帧的底部。*栈帧*（也叫
    *激活帧* 或 *激活记录*）指的是栈上为单个函数调用分配的部分。当前正在执行的函数总是在栈的顶部，它的栈帧被称为 *活动帧*。活动帧的边界由栈指针（栈顶）和帧指针（帧底）界定。激活记录通常保存一个函数的局部变量。[图
    7-4](ch07.xhtml#ch7fig4)展示了 `main` 函数和它调用的函数 `fname` 的栈帧。我们将 `main` 函数称为 *调用者*
    函数，`fname` 称为 *被调用者* 函数。
- en: '![image](../images/07fig04.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/07fig04.jpg)'
- en: '*Figure 7-4: Stack frame management*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：栈帧管理*'
- en: In [Figure 7-4](ch07.xhtml#ch7fig4), the current active frame belongs to the
    callee function (`fname`). The memory between the stack pointer and the frame
    pointer is used for local variables. The stack pointer moves as local values are
    pushed and popped from the stack. In contrast, the frame pointer remains relatively
    constant, pointing to the beginning (the bottom) of the current stack frame. As
    a result, compilers like GCC commonly reference values on the stack relative to
    the frame pointer. In [Figure 7-4](ch07.xhtml#ch7fig4), the active frame is bounded
    below by the base pointer of `fname`, which is stack address 0x418\. The value
    stored at address 0x418 is the “saved” `%rbp` value (0x42c), which itself is an
    address that indicates the bottom of the activation frame for the `main` function.
    The top of the activation frame of `main` is bounded by the *return address*,
    which indicates where in the `main` function program execution resumes once the
    callee function `fname` finishes executing.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning THE RETURN ADDRESS POINTS TO CODE SEGMENT MEMORY, NOT STACK MEMORY**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the call stack region (stack memory) of a program is different from
    its code region (code segment memory). While `%rbp` and `%rsp` point to addresses
    in the stack memory, `%rip` points to an address in *code* segment memory. In
    other words, the return address is an address in code segment memory, not stack
    memory (see [Figure 7-5](ch07.xhtml#ch7fig5)).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig05.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: The parts of a program’s address space*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-16](ch07.xhtml#ch7tab16) contains several additional instructions
    that the compiler uses for basic function management.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-16:** Common Function Management Instructions'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
- en: '| `leaveq` | Prepares the stack for leaving a function. Equivalent to: |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
- en: '|  | `mov %rbp,%rsp` |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '|  | `pop %rbp` |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '| `callq addr <fname>` | Switches active frame to callee function. Equivalent
    to: |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
- en: '|  | `push %rip` |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '|  | `mov addr, %rip` |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| `retq` | Restores active frame to caller function. Equivalent to: |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '|  | `pop %rip` |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: For example, the `leaveq` instruction function is a shorthand that the compiler
    uses to restore the stack and frame pointers as it prepares to leave a function.
    When the callee function finishes execution, `leaveq` ensures that the frame pointer
    is *restored* to its previous value.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The `callq` and `retq` instructions play a prominent role in the process where
    one function calls another. Both instructions modify the instruction pointer (register
    `%rip`). When the caller function executes the `callq` instruction, the current
    value of `%rip` is saved on the stack to represent the return address, or the
    program address at which the caller resumes executing once the callee function
    finishes. The `callq` instruction also replaces the value of `%rip` with the address
    of the callee function.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The `retq` instruction restores the value of `%rip` to the value saved on the
    stack, ensuring that the program resumes execution at the program address specified
    in the caller function. Any value returned by the callee is stored in `%rax` or
    one of its component registers (e.g., `%eax`). The `retq` instruction is usually
    the last instruction that executes in any function.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.1 Function Parameters
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike IA32, function parameters are typically preloaded into registers prior
    to a function call. [Table 7-17](ch07.xhtml#ch7tab17) lists the parameters to
    a function and the register (if any) that they are loaded into prior to a function
    call.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-17:** Locations of Function Parameters'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Location** |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
- en: '| Parameter 1 | `%rdi` |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
- en: '| Parameter 2 | `%rsi` |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
- en: '| Parameter 3 | `%rdx` |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
- en: '| Parameter 4 | `%rcx` |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
- en: '| Parameter 5 | `%r8` |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: '| Parameter 6 | `%r9` |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| Parameter 7+ | on call stack |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: The first six parameters to a function are loaded into registers `%rdi`, `%rsi`,
    `%rdx`, `%rcx`, `%r8`, and `%r9`, respectively. Any additional parameters are
    successively loaded into the call stack based on their size (4 byte offsets for
    32-bit data, 8 byte offsets for 64-bit data).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.2 Tracing Through an Example
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using our knowledge of function management, let’s trace through the code example
    first introduced at the beginning of this chapter. Note that the `void` keyword
    is added to the parameter list of each function definition to specify that the
    functions take no arguments. This change does not modify the output of the program;
    however, it does simplify the corresponding assembly.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We compile this code with the command `gcc -o prog prog.c` and use `objdump
    -d` to view the underlying assembly. The latter command outputs a pretty big file
    that contains a lot of information that we don’t need. Use `less` and the search
    functionality to extract the `adder`, `assign`, and `main` functions:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Each function begins with a symbolic label that corresponds to its declared
    name in the program. For example, `<main>:` is the symbolic label for the `main`
    function. The address of a function label is also the address of the first instruction
    in that function. To save space in the figures that follow, we truncate addresses
    to the lower 12 bits. So, program address 0x400542 is shown as 0x542.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.3 Tracing Through main
  id: totrans-445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 7-6](ch07.xhtml#ch7fig6) shows the execution stack immediately prior
    to the execution of `main`.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig06.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: The initial state of the CPU registers and call stack prior to
    executing the main function*'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the stack grows toward lower addresses. In this example, `%rbp`
    initially is stack address 0x830, and `%rsp` initially is stack address 0xd48\.
    Both of these values are made up for this example.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Since the functions shown in the previous example utilize integer data, we highlight
    component registers `%eax` and `%edi`, which initially contain junk values. The
    upper-left arrow indicates the currently executing instruction. Initially, `%rip`
    contains address 0x542, which is the program memory address of the first line
    in the `main` function.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0332-01.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
- en: The first instruction saves the current value of `%rbp` by pushing 0x830 onto
    the stack. Since the stack grows toward lower addresses, the stack pointer `%rsp`
    is updated to 0xd40, which is 8 bytes less than 0xd48\. `%rip` advances to the
    next instruction in sequence.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0332-02.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov %rsp,%rbp`) updates the value of `%rbp` to be the
    same as `%rsp`. The frame pointer (`%rbp`) now points to the start of the stack
    frame for the `main` function. `%rip` advances to the next instruction in sequence.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0333-01.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
- en: The `sub` instruction subtracts 0x10 from the address of our stack pointer,
    which essentially causes the stack to “grow” by 16 bytes, which we represent by
    showing two 8-byte locations on the stack. Register `%rsp` therefore has the new
    value of 0xd30\. `%rip` advances to the next instruction in sequence.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0333-02.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
- en: The `callq <assign>` instruction pushes the value inside register `%rip` (which
    denotes the address of the *next* instruction to execute) onto the stack. Since
    the next instruction after `callq <assign>` has an address of 0x55f, that value
    is pushed onto the stack as the return address. Recall that the return address
    indicates the program address where execution should resume when program execution
    returns to `main`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `callq` instruction moves the address of the `assign` function (0x526)
    into register `%rip`, signifying that program execution should continue into the
    callee function `assign` and not the next instruction in `main`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0334-01.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
- en: The first two instructions that execute in the `assign` function are the usual
    book-keeping that every function performs. The first instruction pushes the value
    stored in `%rbp` (memory address 0xd40) onto the stack. Recall that this address
    points to the beginning of the stack frame for `main`. `%rip` advances to the
    second instruction in `assign`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0334-02.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov %rsp,%rbp`) updates `%rbp` to point to the top of
    the stack, marking the beginning of the stack frame for `assign`. The instruction
    pointer (`%rip`) advances to the next instruction in the `assign` function.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0335-01.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
- en: The `mov` instruction at address 0x52a moves the value `$0x28` (or 40) onto
    the stack at address `-0x4(%rbp)`, which is four bytes above the frame pointer.
    Recall that the frame pointer is commonly used to reference locations on the stack.
    However, keep in mind that this operation does not change the value of `%rsp`—the
    stack pointer still points to address 0xd20\. Register `%rip` advances to the
    next instruction in the `assign` function.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 位于地址0x52a的`mov`指令将值`$0x28`（或40）存入栈中，地址为`-0x4(%rbp)`，即帧指针上方四个字节的地址。回想一下，帧指针通常用来引用栈上的位置。但请记住，这一操作并不会改变`%rsp`的值——栈指针仍然指向地址0xd20。寄存器`%rip`将前进到`assign`函数中的下一条指令。
- en: '![image](../images/f0336-01.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0336-01.jpg)'
- en: The `mov` instruction at address 0x531 places the value `$0x28` into register
    `%eax`, which holds the return value of the function. `%rip` advances to the `pop`
    instruction in the `assign` function.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 位于地址0x531的`mov`指令将值`$0x28`存入寄存器`%eax`，该寄存器保存函数的返回值。`%rip`将前进到`assign`函数中的`pop`指令。
- en: '![image](../images/f0336-02.jpg) At this point, the `assign` function has almost
    completed execution. The next instruction that executes is `pop %rbp`, which restores
    `%rbp` to its previous value, or 0xd40\. Since the `pop` instruction modifies
    the stack pointer, `%rsp` updates to 0xd28.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/f0336-02.jpg) 到这里，`assign`函数几乎已经执行完毕。下一条将执行的指令是`pop %rbp`，它将`%rbp`恢复到先前的值，即0xd40。由于`pop`指令修改了栈指针，`%rsp`更新为0xd28。'
- en: '![image](../images/f0337-01.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0337-01.jpg)'
- en: The last instruction in `assign` is a `retq` instruction. When `retq` executes,
    the return address is popped off the stack into register `%rip`. In our example,
    `%rip` now advances to point to the `callq` instruction in `main` at address 0x55f.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`assign`函数中的最后一条指令是`retq`指令。当`retq`执行时，返回地址会从栈中弹出并加载到寄存器`%rip`中。在我们的示例中，`%rip`此时将前进并指向`main`中的`callq`指令，地址为0x55f。'
- en: 'Some important things to notice at this juncture:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时有几个重要的注意事项：
- en: The stack pointer and the frame pointer have been restored to their values prior
    to the call to `assign`, reflecting that the stack frame for `main` is once again
    the active frame.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈指针和帧指针已经恢复为调用`assign`之前的值，表明`main`的栈帧再次成为活动帧。
- en: The old values on the stack from the prior active stack frame are *not* removed.
    They still exist on the call stack.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前活动栈帧中的旧值*并没有*被移除，它们仍然存在于调用栈中。
- en: '![image](../images/f0338-01.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0338-01.jpg)'
- en: Back in `main`, the call to `adder` *overwrites* the old return address on the
    stack with a new return address (0x554). This return address points to the next
    instruction to be executed after `adder` returns, or `mov %eax,-0x4(%rbp)`. Register
    `%rip` updates to point to the first instruction to execute in `adder`, which
    is at address 0x536.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，调用`adder`时，*覆盖*了栈上旧的返回地址，并将新的返回地址（0x554）存入栈中。这个返回地址指向`adder`返回后的下一条指令，或者`mov
    %eax,-0x4(%rbp)`。寄存器`%rip`更新为指向`adder`中第一条需要执行的指令，该指令位于地址0x536。
- en: '![image](../images/f0338-02.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0338-02.jpg)'
- en: The first instruction in the `adder` function saves the caller’s frame pointer
    (`%rbp` of `main`) on the stack.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`adder`函数中的第一条指令保存了调用者的帧指针（即`main`中的`%rbp`）到栈上。'
- en: '![image](../images/f0339-01.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0339-01.jpg)'
- en: The next instruction updates `%rbp` with the current value of `%rsp`, or address
    0xd20\. Together, these last two instructions establish the beginning of the stack
    frame for `adder`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令将`%rbp`更新为`%rsp`的当前值，或者地址0xd20。合起来，这两条指令确定了`adder`的栈帧开始位置。
- en: '![image](../images/f0339-02.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0339-02.jpg)'
- en: Pay close attention to the next instruction that executes. Recall that `$0x28`
    was placed on the stack during the call to `assign`. The instruction `mov $-0x4(%rbp),%eax`
    moves an *old* value that is on the stack into register `%eax`! This would not
    have occurred if the programmer had initialized variable `a` in the `adder` function.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意下一条即将执行的指令。回顾一下，`$0x28`是在调用`assign`时放置到栈上的。指令`mov $-0x4(%rbp),%eax`将栈上一个*旧的*值移动到寄存器`%eax`中！如果程序员在`adder`函数中初始化了变量`a`，这一操作是不会发生的。
- en: '![image](../images/f0340-01.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0340-01.jpg)'
- en: 'The `add` instruction at address 0x53d adds 2 to register `%eax`. Recall that
    when a 32-bit integer is being returned, x86-64 utilizes component register `%eax`
    instead of `%rax`. Together the last two instructions are equivalent to the following
    code in `adder`:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 位于地址0x53d的`add`指令将2加到寄存器`%eax`中。回想一下，当返回一个32位整数时，x86-64使用的是组件寄存器`%eax`，而不是`%rax`。这两条指令一起相当于`adder`中的以下代码：
- en: '[PRE47]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![image](../images/f0341-01.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0341-01.jpg)'
- en: After `pop` executes, the frame pointer again points to the beginning of the
    stack frame for `main`, or address 0xd40\. The stack pointer now contains the
    address 0xd28.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pop`执行后，帧指针再次指向`main`的栈帧开始位置，即地址0xd40。此时，栈指针包含地址0xd28。
- en: '![image](../images/f0341-02.jpg) The execution of `retq` pops the return address
    off the stack, restoring the instruction pointer back to 0x554, or the address
    of the next instruction to execute in `main`. The address contained in `%rsp`
    is now 0xd30.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '![image](../images/f0341-02.jpg) `retq`指令从栈中弹出返回地址，将指令指针恢复到0x554，或`main`中下一条要执行的指令地址。此时，`%rsp`中包含的地址为0xd30。'
- en: '![image](../images/f0342-01.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0342-01.jpg)'
- en: Back in `main`, the `mov %eax,-0x4(%rbp)` instruction places the value in `%eax`
    at a location four bytes above `%rbp`, or at address 0xd3c. The next instruction
    replaces it back into register `%eax`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，`mov %eax,-0x4(%rbp)`指令将`%eax`中的值放置在`%rbp`上方四个字节的位置，或地址0xd3c。接下来的指令将其重新放回`%eax`寄存器中。
- en: '![image](../images/f0342-02.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0342-02.jpg)'
- en: Skipping ahead a little, the `mov` instruction at address 0x55a copies the value
    in `%eax` (or 0x2A) to register `%esi`, which is the 32-bit component register
    associated with `%rsi` and typically stores the second parameter to a function.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 略微跳跃，地址0x55a的`mov`指令将`%eax`中的值（或0x2A）复制到寄存器`%esi`中，`%esi`是与`%rsi`相关的32位组件寄存器，通常用于存储函数的第二个参数。
- en: '![image](../images/f0343-01.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0343-01.jpg)'
- en: The next instruction (`mov $0x400604,%edi`) copies a constant value (an address
    in code segment memory) to register `%edi`. Recall that register `%edi` is the
    32-bit component register of `%rdi`, which typically stores the first parameter
    to a function. The code segment memory address 0x400604 is the base address of
    the string `"x is %d\n"`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令（`mov $0x400604,%edi`）将常量值（代码段内存中的一个地址）复制到寄存器`%edi`中。回想一下，寄存器`%edi`是`%rdi`的32位组件寄存器，通常用于存储函数的第一个参数。代码段内存地址0x400604是字符串`"x
    is %d\n"`的基地址。
- en: '![image](../images/f0344-01.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0344-01.jpg)'
- en: The next instruction resets register `%eax` with the value 0\. The instruction
    pointer advances to the call to the `printf` function (which is denoted with the
    label `<printf@plt>`).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令将寄存器`%eax`重置为0。指令指针前进到调用`printf`函数的位置（该位置由标签`<printf@plt>`表示）。
- en: '![image](../images/f0344-02.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0344-02.jpg)'
- en: 'The next instruction calls the `printf` function. For the sake of brevity,
    we will not trace the `printf` function, which is part of `stdio.h`. However,
    we know from the manual page (`man -s3 printf`) that `printf` has the following
    format:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令调用`printf`函数。为了简便起见，我们不再追踪`printf`函数（它是`stdio.h`的一部分）。然而，我们从手册页面（`man -s3
    printf`）中可以了解到，`printf`具有以下格式：
- en: '[PRE48]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In other words, the first argument is a pointer to a string specifying the
    format, and the second argument onward specify the values that are used in that
    format. The instructions specified by addresses 0x55a–0x566 correspond to the
    following line in the `main` function:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，第一个参数是指向指定格式的字符串的指针，第二个参数及之后的参数指定了该格式中使用的值。地址0x55a–0x566之间的指令对应着`main`函数中的以下一行：
- en: '[PRE49]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When the `printf` function is called:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 当`printf`函数被调用时：
- en: A return address specifying the instruction that executes after the call to
    `printf` is pushed onto the stack.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个返回地址（指定`printf`调用之后执行的指令）被推送到栈中。
- en: The value of `%rbp` is pushed onto the stack, and `%rbp` is updated to point
    to the top of the stack, indicating the beginning of the stack frame for `printf`.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%rbp`的值被推送到栈中，`%rbp`被更新为指向栈顶，表示`printf`的栈帧开始位置。'
- en: At some point, `printf` references its arguments, which are the string `"x is`
    `%d\n"` and the value 0x2A. The first parameter is stored in component register
    `%edi`, and the second parameter is stored in component register `%esi`. The return
    address is located directly below `%rbp` at location `%rbp+8`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时刻，`printf`会引用其参数，这些参数是字符串`"x is` `%d\n"`和数值0x2A。第一个参数存储在组件寄存器`%edi`中，第二个参数存储在组件寄存器`%esi`中。返回地址位于`%rbp`下方的位置`%rbp+8`。
- en: For any function with *n* arguments, GCC places the first six arguments in registers,
    as shown in [Table 7-17](ch07.xhtml#ch7tab17), and the remaining arguments onto
    the stack *below* the return address.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何有*n*个参数的函数，GCC将前六个参数放入寄存器中，如[表7-17](ch07.xhtml#ch7tab17)所示，其余参数则放入栈中，*在*返回地址之下。
- en: After the call to `printf`, the value 0x2A is output to the user in integer
    format. Thus, the value 42 is printed to the screen!
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0345-01.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
- en: After the call to `printf`, the last few instructions clean up the stack and
    prepare a clean exit from the `main` function. First, the `mov` instruction at
    address 0x56b ensures that 0 is in the return register (since the last thing `main`
    does is return 0).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0346-01.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
- en: 'The `leaveq` instruction prepares the stack for returning from the function
    call. Recall that `leaveq` is analogous to the following pair of instructions:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In other words, the CPU overwrites the stack pointer with the frame pointer.
    In our example, the stack pointer is initially updated from 0xd30 to 0xd40\. Next,
    the CPU executes `pop %rbp`, which takes the value located at 0xd40 (in our example,
    the address 0x830) and places it in `%rbp`. After `leaveq` executes, the stack
    and frame pointers revert to their original values prior to the execution of `main`.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction that executes is `retq`. With 0x0 in the return register
    `%eax`, the program returns zero, indicating correct termination.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: If you have carefully read through this section, you should understand why our
    program prints out the value 42\. In essence, the program inadvertently uses old
    values on the stack to cause it to behave in a way that we didn’t expect. This
    example was pretty harmless; however, we discuss in future sections how hackers
    have misused function calls to make programs misbehave in truly malicious ways.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Recursion
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursive functions are a special class of functions that call themselves (also
    known as *self-referential* functions) to compute a value. Like their nonrecursive
    counterparts, recursive functions create new stack frames for each function call.
    Unlike standard functions, recursive functions contain function calls to themselves.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the problem of summing up the set of positive integers from 1
    to *n*. In previous sections, we discussed the `sumUp` function to achieve this
    task. The following code listings show a related function called `sumDown`, which
    adds the numbers in reverse (*n* to 1), and its recursive equivalent `sumr`:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Iterative
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Recursive
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The base case in the recursive function `sumr` accounts for any values of *n*
    that are less than one. The recursive step calls `sumr` with the value *n –* 1
    and adds the result to *n* prior to returning. Compiling `sumr` and disassembling
    it with GDB yields the following assembly code:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Each line in the preceding assembly code is annotated with its English translation.
    Here, we show the corresponding `goto` form (first) and C program without `goto`
    statements (second):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: C goto form
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: C version without goto
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Although this translation may not initially appear to be identical to the original
    `sumr` function, close inspection reveals that the two functions are indeed equivalent.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '7.6.1 Animation: Observing How the Call Stack Changes'
  id: totrans-530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an exercise, we encourage you to draw out the stack and see how the values
    change. We have provided an animation online that depicts how the stack is updated
    when we run this function with the value 3.^([2](ch07.xhtml#fn7_2))
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 Arrays
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that arrays (see “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9))
    are ordered collections of data elements of the same type that are contiguously
    stored in memory. Statically allocated single-dimension arrays (see “Single-Dimensional
    Arrays” on [page 81](ch02.xhtml#lev2_22)) have the form <type> `arr[N]`, where
    <type> is the data type, `arr` is the identifier associated with the array, and
    `N` is the number of data elements. Declaring an array statically as <type> `arr[N]`
    or dynamically as `arr = malloc(N * sizeof(` <type>`))` allocates `N` × `sizeof(`
    <type>`)` total bytes of memory.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: To access the element at index `i` in array `arr`, use the syntax `arr[i]`.
    Compilers commonly convert array references into pointer arithmetic (see “Pointer
    Variables” on [page 67](ch02.xhtml#lev2_17)) prior to translating to assembly.
    So, `arr+i` is equivalent to `&arr[i]`, and `*(arr+i)` is equivalent to `arr[i]`.
    Since each data element in `arr` is of type <type>, `arr+i` implies that element
    `i` is stored at address `arr` + `sizeof(` <type>`)` × `i`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-18](ch07.xhtml#ch7tab18) outlines some common array operations and
    their corresponding assembly instructions. In the examples that follow, suppose
    that we declare an `int` array of length 10 (`int arr[10]`). Assume that register
    `%rdx` stores the address of `arr`, register `%rcx` stores the `int` value `i`,
    and register `%rax` represents some variable `x` (also of type `int`). Recall
    that `int` variables take up four bytes of space, whereas `int *` variables take
    up eight bytes of space.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-18:** Common Array Operations and Their Corresponding Assembly Representations'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Type** | **Assembly Representation** |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
- en: '| `x = arr` | `int *` | `mov %rdx,%rax` |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
- en: '| `x = arr[0]` | `int` | `mov (%rdx),%eax` |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
- en: '| `x = arr[i]` | `int` | `mov (%rdx,%rcx,4),%eax` |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
- en: '| `x = &arr[3]` | `int *` | `lea 0xc(%rdx),%rax` |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
- en: '| `x = arr+3` | `int *` | `lea 0xc(%rdx),%rax` |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
- en: '| `x = *(arr+5)` | `int` | `mov 0x14(%rdx),%eax` |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
- en: Pay close attention to the *type* of each expression in [Table 7-18](ch07.xhtml#ch7tab18).
    In general, the compiler uses `mov` instructions to dereference pointers and the
    `lea` instruction to compute addresses.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Notice that to access element `arr[3]` (or `*(arr+3)` using pointer arithmetic),
    the compiler performs a memory lookup on address `arr+3*4` instead of `arr+3`.
    To understand why this is necessary, recall that any element at index `i` in an
    array is stored at address `arr + sizeof(` <type>`) * i`. The compiler must therefore
    multiply the index by the size of the data type (in this case four, since `sizeof(int)`
    = 4) to compute the correct offset. Recall also that memory is byte-addressable;
    offsetting by the correct number of bytes is the same as computing an address.
    Lastly, because `int` values require only four bytes of space, they are stored
    in component register `%eax` of register `%rax`.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a sample array (`array`) with 10 integer elements ([Figure
    7-7](ch07.xhtml#ch7fig7)).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig07.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: The layout of a 10-integer array in memory. Each *x*[*i*]-labeled
    box represents four bytes.*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Notice that since `array` is an array of integers, each element takes up exactly
    four bytes. Thus, an integer array with 10 elements consumes 40 bytes of contiguous
    memory.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: To compute the address of element 3, the compiler multiplies the index 3 by
    the data size of the integer type (4) to yield an offset of 12 (or 0xc). Sure
    enough, element 3 in [Figure 7-7](ch07.xhtml#ch7fig7) is located at byte offset
    *x*[12].
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple C function called `sumArray` that sums up all
    the elements in an array:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `sumArray` function takes the address of an array and the array’s associated
    length and sums up all the elements in the array. Now take a look at the corresponding
    assembly for the `sumArray` function:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When tracing this assembly code, consider whether the data being accessed represents
    an address or a value. For example, the instruction at `<sumArray+11>` results
    in `%rbp-0x4` containing a variable of type `int`, which is initially set to 0\.
    In contrast, the argument stored at `%rbp-0x18` is the first argument to the function
    (`array`) which is of type `int *` and corresponds to the base address of the
    array. A different variable (which we call `i`) is stored at location `%rbp-0x8`.
    Lastly, note that size suffixes are included at the end of instructions like `add`
    and `mov` only when necessary. In cases where constant values are involved, the
    compiler needs to explicitly state how many bytes of the constant are being moved.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: The astute reader will notice a previously unseen instruction at line `<sumArray+30>`
    called `cltq`. The `cltq` instruction stands for “convert long to quad” and converts
    the 32-bit `int` value stored in `%eax` to a 64-bit integer value that is stored
    in `%rax`. This operation is necessary because the instructions that follow perform
    pointer arithmetic. Recall that on 64-bit systems, pointers take up 8 bytes of
    space. The compiler’s use of `cltq` simplifies the process by ensuring that all
    data are stored in 64-bit registers instead of 32-bit components.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the five instructions between locations `<sumArray+32>`
    and `<sumArray+49>`:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Recall that the compiler commonly uses `lea` to perform simple arithmetic on
    operands. The operand `0x0(,%rax,4)` translates to `%rax*4 + 0x0`. Since `%rax`
    holds the value of `i`, this operation copies the value `i*4` to `%rdx`. At this
    point, `%rdx` contains the number of bytes to calculate the correct offset of
    `array[i]` (recall that `sizeof(int)` = 4).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: The next instruction (`mov -0x18(%rbp),%rax`) copies the first argument to the
    function (the base address of `array`) into register `%rax`. Adding `%rdx` to
    `%rax` in the next instruction causes `%rax` to contain `array+i*4`. Recall that
    the element at index `i` in `array` is stored at address `array + sizeof(` <type>`)
    * i`. Therefore, `%rax` now contains the assembly-level computation of the address
    `&array[i]`.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: The instruction at `<sumArray+47>` *dereferences* the value located at `%rax`,
    placing the value of `array[i]` into `%eax`. Notice the use of the component register
    `%eax`, since `array[i]` contains a 32-bit `int` value! In contrast, the variable
    `i` was changed to a quad-word on line `<sumArray+30>` since `i` was about to
    be used for *address computation*. Again, addresses are stored as 64-bit words.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, `%eax` is added to the value in `%rbp-0x4`, or `total`. Therefore, the
    five instructions between locations `<sumArray+22>` and `<sumArray+39>` correspond
    to the line `total += array[i]` in the `sumArray` function.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 Matrices
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A matrix is a two-dimensional array. A matrix in C can be statically allocated
    as a two-dimensional array (`M[n][m]`), dynamically allocated with a single call
    to `malloc`, or dynamically allocated as an array of arrays. Let’s consider the
    array of arrays implementation. The first array contains `n` elements (`M[n]`),
    and each element `M[i]` in our matrix contains an array of `m` elements. The following
    code snippets each declare matrices of size 4 × 3:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the case of the dynamically allocated matrix, the main array contains a contiguous
    array of `int` pointers. Each integer pointer points to a different array in memory.
    [Figure 7-8](ch07.xhtml#ch7fig8) illustrates how we would normally visualize each
    of these matrices.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig08.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: Illustration of a statically allocated (`M1`) and a dynamically
    allocated (`M2`) 3 × 4 matrix*'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: For both of these matrix declarations, element (*i*,*j*) can be accessed using
    the double-indexing syntax `M[i][j]`, where `M` is either `M1` or `M2`. However,
    these matrices are organized differently in memory. Even though both store the
    elements in their primary array contiguously in memory, our statically allocated
    matrix also stores all the rows contiguously in memory, as shown in [Figure 7-9](ch07.xhtml#ch7fig9).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig09.jpg)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Matrix `M1`’s memory layout in row-major order*'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'This contiguous ordering is not guaranteed for `M2`. Recall (from “Two-Dimensional
    Array Memory Layout” on [page 86](ch02.xhtml#lev3_13)) that to contiguously allocate
    an *n* × *m* matrix on the heap, we should use a single call to `malloc` that
    allocates *n* × *m* elements:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Recall that with the declaration of `M3`, element (*i*,*j*) *cannot* be accessed
    using the `M[i][j]` notation. Instead, we must index the element using the format
    `M3[i*COLS + j]`.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.1 Contiguous Two-Dimensional Arrays
  id: totrans-575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a function `sumMat` that takes a pointer to a contiguously allocated
    (either statically allocated or memory-efficiently dynamically allocated) matrix
    as its first parameter, along with the numbers of rows and columns, and returns
    the sum of all the elements inside the matrix.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: We use scaled indexing in the code snippet that follows because it applies to
    both statically and dynamically allocated contiguous matrices. Recall that the
    syntax `m[i][j]` does not work with the memory-efficient contiguous dynamic allocation
    previously discussed.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here is the corresponding assembly. Each line is annotated with its English
    translation:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The local variables `i`, `j`, and `total` are loaded at addresses `%rbp-0xc`,
    `%rbp-0x8`, and `%rbp-0x4` on the stack, respectively. The input parameters `m`,
    `row`, and `cols` are stored at locations `%rbp-0x8`, `%rbp-0x1c`, and `%rbp-0x20`,
    respectively. Using this knowledge, let’s zoom in on the component that just deals
    with the access of element (*i*,*j*) in our matrix:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first set of instructions calculates the value `i*cols` and places it in
    register `%edx`. Recall that for a matrix named `matrix`, `matrix + (i*cols)`
    is equivalent to `&matrix[i]`.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The next set of instructions computes `(i*cols + j)*4`. The compiler multiplies
    the index `i*cols+j` by four since each element in the matrix is a four-byte integer,
    and this multiplication enables the compiler to compute the correct offset. The
    `cltq` instruction on line `<sumMat+53>` is needed to sign-extend the contents
    of `%eax` into a 64-bit integer, since that is about to be used for address calculation.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the following set of instructions adds the calculated offset to the matrix
    pointer and dereferences it to yield the value of element (*i*,*j*):'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first instruction loads the address of matrix `m` into register `%rax`.
    The `add` instruction adds `(i*cols + j)*4` to the address of `m` to correctly
    calculate the offset of element (*i*,*j*). The third instruction dereferences
    the address in `%rax` and places the value in `%eax`. Notice the use of `%eax`
    as the destination component register; since our matrix contains integers, and
    an integer takes up four bytes of space, component register `%eax` is again used
    instead of `%rax`.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: The last instruction adds the value in `%eax` to the accumulator `total`, which
    is located at stack address `%rbp-0x4`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider how element (1,2) is accessed in [Figure 7-9](ch07.xhtml#ch7fig9).
    For convenience, the figure is reproduced here in [Figure 7-10](ch07.xhtml#ch7fig10):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig10.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Matrix `M1`’s memory layout in row-major order*'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Element (1,2) is located at address `M1 + 1*COLS + 2`. Since `COLS` = 3, element
    (1,2) corresponds to `M1+5`. To access the element at this location, the compiler
    must multiply 5 by the size of the `int` data type (four bytes), yielding the
    offset `M1+20`, which corresponds to byte *x*[20] in the figure. Dereferencing
    this location yields element 5, which is indeed element (1,2) in the matrix.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.2 Noncontiguous Matrix
  id: totrans-594
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The noncontiguous matrix implementation is a bit more complicated. [Figure 7-11](ch07.xhtml#ch7fig11)
    visualizes how `M2` may be laid out in memory.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig11.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Matrix `M2`’s noncontiguous layout in memory*'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the array of pointers is contiguous, and that each array pointed
    to by an element of `M2` (e.g., `M2[i]`) is contiguous. However, the individual
    arrays are not contiguous with one another. Since `M2` is an array of pointers,
    each element of `M2` takes eight bytes of space. In contrast, since `M2[i]` is
    an `int` array, each element of `M2[i]` is four bytes away.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sumMatrix` function in the following example takes an array of integer
    pointers (called `matrix`) as its first parameter, and a number of rows and columns
    as its second and third parameters:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Even though this function looks nearly identical to the `sumMat` function shown
    earlier, the matrix accepted by this function consists of a contiguous array of
    *pointers*. Each pointer contains the address of a separate contiguous array,
    which corresponds to a separate row in the matrix.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding assembly for `sumMatrix` follow. Each line is annotated with
    its English translation.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Once again, the variables `i`, `j`, and `total` are at stack addresses `%rbp-0xc`,
    `%rbp-0x8`, and `%rbp-0x4`, respectively. The input parameters `matrix`, `row`,
    and `cols` are located at stack addresses `%rbp-0x18`, `%rbp-0x1c`, and `%rbp-0x20`,
    respectively.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s zoom in on the section that deals specifically with an access to element
    (*i*,*j*), or `matrix[i][j]`:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The five instructions in this example compute `matrix[i]`, or `*(matrix+i)`.
    Since `matrix[i]` contains a pointer, `i` is first converted to a 64-bit integer.
    Then, the compiler multiplies `i` by eight prior to adding it to `matrix` to calculate
    the correct address offset (recall that pointers are eight bytes in size). The
    instruction at `<sumMatrix+59>` then dereferences the calculated address to get
    the element `matrix[i]`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Since `matrix` is an array of `int` pointers, the element located at `matrix[i]`
    is itself an `int` pointer. The *j*th element in `matrix[i]` is located at offset
    *j* × 4 in the `matrix[i]` array.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of instructions extract the *j*th element in array `matrix[i]`:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The first instruction in this snippet loads variable `j` into register `%edx`.
    The `movslq` instruction at `<sumMatrix+65>` converts `%edx` into a 64-bit integer,
    storing the result in 64-bit register `%rdx`. The compiler then uses the left
    shift (`shl`) instruction to multiply `j` by four and stores the result in register
    `%rdx`. The compiler finally adds the resulting value to the address located in
    `matrix[i]` to get the address of element `matrix[i][j]`. The instructions at
    `<sumMatrix+75>` and `<sumMatrix+77>` obtain the value at `matrix[i][j]` and add
    the value to `total`.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit [Figure 7-11](ch07.xhtml#ch7fig11) and consider an example access
    to M2[1][2]. For convenience, we reproduce the figure in [Figure 7-12](ch07.xhtml#ch7fig12):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig12.jpg)'
  id: totrans-613
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Matrix `M2`’s noncontiguous layout in memory*'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Note that `M2` starts at memory location *x*[0]. The compiler first computes
    the address of `M2[1]` by multiplying 1 by 8 (`sizeof(int *)`) and adding it to
    the address of `M2` (*x*[0]), yielding the new address *x*[8]. A dereference of
    this address yields the address associated with `M2[1]`, or *x*[36]. The compiler
    then multiplies index 2 by 4 (`sizeof(int)`), and adds the result (8) to *x*[36],
    yielding a final address of *x*[44]. The address *x*[44] is dereferenced, yielding
    the value 5\. Sure enough, the element in [Figure 7-11](ch07.xhtml#ch7fig11) that
    corresponds to `M2[1][2]` has the value 5.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 structs in Assembly
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `struct` (see “C Structs” on [page 103](ch02.xhtml#lev1_15)) is another way
    to create a collection of data types in C. Unlike arrays, structs enable different
    data types to be grouped together. C stores a `struct` like a single-dimension
    array, where the data elements (fields) are stored contiguously. Let’s revisit
    `struct studentT` from [Chapter 1](ch01.xhtml#ch01):'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[Figure 7-13](ch07.xhtml#ch7fig13) shows how `student` is laid out in memory.
    Each *x*[*i*] denotes the address of a particular field.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig13.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: The memory layout of `struct studentT`*'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: The fields are stored contiguously next to one another in memory in the order
    in which they are declared. In [Figure 7-13](ch07.xhtml#ch7fig13), the `age` field
    is allocated at the memory location directly after the `name` field (at byte offset
    *x*[64]) and is followed by the `grad_yr` (byte offset *x*68) and `gpa` (byte
    offset *x*[72]) fields. This organization enables memory-efficient access to the
    fields.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the compiler generates assembly code to work with a `struct`,
    consider the function `initStudent`:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `initStudent` function uses the base address of a `struct studentT` as
    its first parameter, and the desired values for each field as its remaining parameters.
    The following listing depicts this function in assembly:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Being mindful of the byte offsets of each field is key to understanding this
    code. Here are a few things to keep in mind.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: The `strncpy` call takes the base address of the `name` field of `s`, the address
    of array `nm`, and a length specifier as its three arguments. Recall that because
    `name` is the first field in the `struct studentT`, the address of `s` is synonymous
    with the address of `s->name`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This code snippet contains the previously undiscussed register (`%xmm0`) and
    instruction (`movss`). The `%xmm0` register is an example of a register reserved
    for floating-point values. The `movss` instruction indicates that the data being
    moved onto the call stack is of type single-precision floating point.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part (instructions `<initStudent+51>` through `<initStudent+58>`)
    places the value of the `gr` parameter at an offset of 0x44 (or 68) from the start
    of `s`. Revisiting the memory layout in [Figure 7-13](ch07.xhtml#ch7fig13) shows
    that this address corresponds to `s->grad_yr`:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The next section (instructions `<initStudent+61>` through `<initStudent+68>`)
    copies the `ag` parameter to the `s->age` field of the `struct`, which is located
    at an offset of 0x40 (or 64) bytes from the address of `s`:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Lastly, the `g` parameter value is copied to the `s->gpa` field (byte offset
    72 or 0x48) of the `struct`. Notice the use of the `%xmm0` register since the
    data contained at location `%rbp-0x1c` is single-precision floating point:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 7.9.1 Data Alignment and structs
  id: totrans-637
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following modified declaration of `struct studentT`:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The size of the `name` field is modified to be 63 bytes, instead of the original
    64\. Consider how this affects the way the `struct` is laid out in memory. It
    may be tempting to visualize it as in [Figure 7-14](ch07.xhtml#ch7fig14).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig14.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: An incorrect memory layout for the updated `struct` `studentTM`.
    Note that the `name` field is reduced from 64 to 63 bytes.*'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: In this depiction, the `age` field occurs in the byte immediately following
    the `name` field. But this is incorrect. [Figure 7-15](ch07.xhtml#ch7fig15) depicts
    the actual layout in memory.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig15.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: The correct memory layout for the updated `struct` `studentTM`.
    Byte *x*[63] is added by the compiler to satisfy memory alignment constraints,
    but it doesn’t correspond to any of the fields.*'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: x64’s alignment policy requires that two-byte data types (that is, `short`)
    reside at a two-byte-aligned address, four-byte data types (i.e., `int`, `float`,
    and `unsigned`) reside at four-byte-aligned addresses, whereas larger data types
    (`long`, `double`, and pointer data) reside at eight-byte-aligned addresses. For
    a `struct`, the compiler adds empty bytes as *padding* between fields to ensure
    that each field satisfies its alignment requirements. For example, in the `struct`
    declared in [Figure 7-15](ch07.xhtml#ch7fig15) the compiler adds a byte of padding
    at byte *x*[63] to ensure that the `age` field starts at an address that is at
    a multiple of four. Values aligned properly in memory can be read or written in
    a single operation, enabling greater efficiency.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens when a `struct` is defined as follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Moving the `name` array to the end ensures that `age`, `grad_yr`, and `gpa`
    are four-byte aligned. Most compilers will remove the filler byte at the end of
    the `struct`. However, if the `struct` is ever used in the context of an array
    (e.g., `struct studentTM courseSection[20];`) the compiler will once again add
    the filler byte as padding between each `struct` in the array to ensure that alignment
    requirements are properly met.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '7.10 Real World: Buffer Overflow'
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C language does not perform automatic array bounds checking. Accessing memory
    outside of the bounds of an array is problematic and often results in errors such
    as segmentation faults. However, a clever attacker can inject malicious code that
    intentionally overruns the boundary of an array (also known as a *buffer*) to
    force the program to execute in an unintended manner. In the worst cases, the
    attacker can run code that allows them to gain *root privilege*, or OS-level access
    to the computer system. A piece of software that takes advantage of the existence
    of a known buffer overrun error in a program is known as a *buffer overflow exploit*.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we use GDB and assembly language to fully characterize the
    mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage
    you to explore “Debugging Assembly Code” on [page 177](ch03.xhtml#lev1_24).
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.1 Famous Examples of Buffer Overflow
  id: totrans-653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Buffer overflow exploits emerged in the 1980s and remained a chief scourge of
    the computing industry through the early parts of the 2000s. While many modern
    operating systems have protections against the simplest buffer overflow attacks,
    careless programming errors can still leave modern programs wide open to attack.
    Buffer overflow exploits have recently been discovered in Skype,^([3](ch07.xhtml#fn7_3))
    Android,^([4](ch07.xhtml#fn7_4)) Google Chrome,^([5](ch07.xhtml#fn7_5)) and others.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Here are some notable historic examples of buffer overflow exploits.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: The Morris Worm
  id: totrans-656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Morris Worm^([6](ch07.xhtml#fn7_6)) was released in 1998 on ARPANet from
    MIT (to hide that it was written by a student at Cornell) and exploited a buffer
    overrun vulnerability that existed in the Unix finger daemon (`fingerd`). In Linux
    and other Unix-like systems, a *daemon* is a type of process that continuously
    executes in the background, usually performing clean-up and monitoring tasks.
    The `fingerd` daemon returns a user-friendly report on a computer or person. Most
    crucially, the worm had a replication mechanism that caused it to be sent to the
    same computer multiple times, bogging down the system to an unusable state. Although
    the author claimed that the worm was meant as a harmless intellectual exercise,
    the replication mechanism enabled the worm to spread easily and made it difficult
    to remove. In future years, other worms would employ buffer overflow exploits
    to gain unauthorized access into systems. Notable examples include Code Red (2001),
    MS-SQLSlammer (2003), and W32/Blaster (2003).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: AOL Chat Wars
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: David Auerbach,^([7](ch07.xhtml#fn7_7)) a former Microsoft engineer, detailed
    his experience with a buffer overflow during his efforts to integrate Microsoft’s
    Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then,
    AOL Instant Messenger (AIM) was *the* service to use if you wanted to instant
    message (or IM) friends and family. Microsoft tried to gain a foothold in this
    market by designing a feature in MMS that enabled MMS users to talk to their AIM
    “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect
    to them. Microsoft engineers figured out a way for MMS clients to mimic the messages
    sent by AIM clients to AOL servers, making it difficult for AOL to distinguish
    between messages received by MMS and AIM. AOL responded by changing the way AIM
    sent messages, and MMS engineers duly changed their client’s messages to once
    again match AIM’s. This “chat war” continued until AOL started using a buffer
    overflow error *in their own client* to verify that sent messages came from AIM
    clients. Since MMS clients did not have the same vulnerability, the chat wars
    ended, with AOL as the victor.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '7.10.2 A First Look: The Guessing Game'
  id: totrans-660
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To help you understand the mechanism of the buffer overflow attack, we provide
    the executable of a simple program that enables the user to play a guessing game
    with the program. Download the `secret` executable^([8](ch07.xhtml#fn7_8)) and
    extract it using the `tar` command:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the following, we provide a copy of the main file associated with the executable:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: main.c
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This game prompts the user to enter first a secret number and then a secret
    string to win the guessing game. The header file `other.h` contains the definition
    of the `getSecretCode` and `calculateValue` functions, but it is unavailable to
    us. How then can a user beat the program? Brute forcing the solution will take
    too long. One strategy is to analyze the `secret` executable in GDB and step through
    the assembly to reveal the secret number and string. The process of examining
    assembly code to reveal knowledge of how it works is commonly referred to as *reverse
    engineering* assembly. Readers comfortable enough with their GDB and assembly
    reading skills should be able to figure out what the secret number and the secret
    string should be by using GDB to reverse engineer their values.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a different, sneakier way to win.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.3 Taking a Closer Look (Under the C)
  id: totrans-668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program contains a potential buffer overrun vulnerability at the first call
    to `scanf`. To understand what is going on, let’s inspect the assembly code of
    the `main` function using GDB. Let’s also place a breakpoint at address 0x0000000000400717,
    which is the address of the instruction immediately before the call to `scanf`
    (note that placing the breakpoint at the address of `scanf` causes program execution
    to halt *inside* the call to `scanf`, not in `main`).
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[Figure 7-16](ch07.xhtml#ch7fig16) depicts the stack immediately before the
    call to `scanf`.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig16.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-16: The call stack immediately before the call to `scanf`*'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the call to `scanf`, the first two arguments for `scanf` are preloaded
    into registers `%edi` and `%rsi`, respectively. The `lea` instruction at location
    `<main+25>` creates the reference for array `buf`.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that the user enters `1234567890` at the prompt. [Figure 7-17](ch07.xhtml#ch7fig17)
    illustrates what the stack looks like immediately after the call to `scanf` completes.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig17.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-17: The call stack immediately after the call to `scanf` with input
    `1234567890`*'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the hex values for the ASCII encodings of the digits 0 to 9 are
    0x30 to 0x39, and that each stack memory location is eight bytes long. The frame
    pointer is 32 bytes away from the stack pointer. Readers tracing along can confirm
    the value of `%rbp` by using GDB to print its value (`p` `$rbp`). In the example
    shown, the value of `%rbp` is 0x7fffffffdd10\. The following command allows the
    reader to inspect the 48 bytes (in hex) below `%rsp`:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This GDB command yields output that looks similar to the following:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Each line represents one 64-bit address, or two 32-bit addresses. So, the value
    associated with the 32-bit address 0x7fffffffdd0c is located at the rightmost
    four bytes of the line showing 0x7fffffffdd08.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '**Note MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER**'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding assembly segment, the byte at address 0xf7ffffffdd00 is 0xf0,
    the byte at address 0xf7ffffffdd01 is 0xdd, the byte at address 0xf7ffffffdd02
    is 0xff, the byte at address 0xf7ffffffdd03 is 0xff, the byte at address 0xf7ffffffdd04
    is 0xff, and the byte at address 0xf7ffffffdd05 is 0x7f. However, the 64-bit *value*
    at address 0x7fffffffdd00 is in fact 0x7fffffffddf0\. Remember that since x86-64
    is a little-endian system (see “Integer Byte Order” on [page 224](ch04.xhtml#lev1_34)),
    the bytes for multibyte values such as addresses are stored in reverse order.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the address for `buf` is located at the top of the stack.
    Therefore, the first two addresses hold the inputted bytes associated with the
    input string 1234567890:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The null termination byte `\0` appears in the third most significant byte location
    at address 0x7fffffffdcf8 (i.e., at address 0x7fffffffdcfa). Recall that `scanf`
    terminates all strings with a null byte.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, 1234567890 is not the secret number. Here is the output when we
    try to run `secret` with input string 1234567890:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `echo $?` command prints out the return value of the last executed command
    in the shell. In this case, the program returned 1 because the secret number we
    entered is wrong. Recall that by convention, programs return 0 when there are
    no errors. Our goal going forward is to trick the program into exiting with a
    return value of 0, indicating that we won the game.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '7.10.4 Buffer Overflow: First Attempt'
  id: totrans-691
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, let’s try typing in the string 1234567890123456789012345678901234567890123:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Interesting! Now the program crashes with a segmentation fault, with return
    code 139\. [Figure 7-18](ch07.xhtml#ch7fig18) shows what the call stack for `main`
    looks like immediately after the call to `scanf` with this new input.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig18.jpg)'
  id: totrans-695
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-18: The call stack immediately after the call to `scanf` with input
    1234567890123456789012345678901234567890123*'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: The input string is so long that it not only overwrote the values stored at
    0xd08 and 0xd10, but it spilled over into the return address below the stack frame
    for `main`. Recall that when a function returns, the program tries to resume execution
    at the address specified by the return address. In this example, the program tries
    to resume execution at address 0xf7ff00333231 after exiting `main`, which does
    not appear to exist. So the program crashes with a segmentation fault.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the program in GDB (`input.txt` contains the input string above)
    reveals this devilry in action:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Notice that our input string blew past the stated limits of the array `buf`,
    overwriting all the other values stored on the stack. In other words, our string
    created a buffer overrun and corrupted the call stack, causing the program to
    crash. This process is also known as *smashing the stack*.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '7.10.5 A Smarter Buffer Overflow: Second Attempt'
  id: totrans-701
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our first example smashed the stack by overwriting the `%rbp` register and return
    address with junk, causing the program to crash. An attacker whose goal is to
    simply crash a program would be satisfied at this point. However, our goal is
    to trick the guessing game to return 0, indicating that we won the game. We accomplish
    this by filling the call stack with data more meaningful than junk values. For
    example, we could overwrite the stack so that the return address is replaced with
    the address of `endGame`. Then, when the program attempts to return from `main`,
    it will instead execute `endGame` rather than crashing with a segmentation fault.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the address of `endGame`, let’s inspect `secret` again in GDB:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Observe that `endGame` starts at address 0x00000000004006da. [Figure 7-19](ch07.xhtml#ch7fig19)
    illustrates a sample exploit that forces `secret` to run the `endGame` function.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/07fig19.jpg)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-19: A sample string that can force `secret` to execute the `endGame`
    function*'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, there are 40 bytes of junk values followed by the return address.
    Again, because x86-64 is a little-endian system, the bytes in the return address
    appear to be in reverse order.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates how an attacker could construct the preceding
    exploit:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `\x` before each number indicates that the number is formatted as the hexadecimal
    representation of a character. After defining `ebuff[]`, the `main` function simply
    prints it out, character by character. To get the associated byte string, compile
    and run this program as follows:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To use the file `exploit` as input to `scanf`, it suffices to run `secret`
    with `exploit` as follows:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The program prints out “You are so wrong!” since the string contained in `exploit`
    is *not* the secret number. However, the program also prints out the string “You
    win!” Recall, though, that our goal is to trick the program to return 0\. In a
    larger system, where the notion of “success” is tracked by an external program,
    it is often most important what a program returns, not what it prints out.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the return value yields:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Our exploit works! We won the game!
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 7.10.6 Protecting Against Buffer Overflow
  id: totrans-719
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The example we showed changed the control flow of the `secret` executable,
    forcing it to return a zero value associated with success. However, an exploit
    like this could do some real damage. Furthermore, some older computer systems
    *executed* bytes from stack memory. If an attacker placed bytes associated with
    assembly instructions on the call stack, the CPU would interpret the bytes as
    *real* instructions, enabling the attacker to force the CPU to execute *any arbitrary
    code of their choosing*. Fortunately, there are strategies that modern computer
    systems employ to make it more difficult for attackers to run buffer overflow
    exploits:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack randomization.**   The OS allocates the starting address of the stack
    at a random location in stack memory, causing the position/size of the call stack
    to vary from one run of a program to another. Multiple machines running the same
    code would have different stack addresses. Modern Linux systems use stack randomization
    as a standard practice. However, a determined attacker can brute force the attack,
    by attempting to repeat attacks with different addresses. A common trick is to
    use a *NOP sled* (i.e., a large number of `nop` instructions) before the actual
    exploit code. Executing the `nop` instruction (`0x90`) has no effect, other than
    causing the program counter to increment to the next instruction. As long as the
    attacker can get the CPU to execute somewhere in the NOP sled, the NOP sled will
    eventually lead to the exploit code that follows it. Aleph One’s writeup^([9](ch07.xhtml#fn7_9))
    details the mechanism of this type of attack.'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack corruption detection.**   Another line of defense is to try to detect
    when the stack is corrupted. Recent versions of GCC use a stack protector known
    as a *canary* that acts as a guard between the buffer and the other elements of
    the stack. A canary is a value stored in a nonwriteable section of memory that
    can be compared to a value put on the stack. If the canary “dies” during a program’s
    execution, the program knows that it is under attack and aborts with an error
    message. A clever attacker can, however, replace the canary to prevent the program
    from detecting stack corruption.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '**Limiting executable regions.**   In this line of defense, executable code
    is restricted to only particular regions of memory. In other words, the call stack
    is no longer executable. However, even this defense can be defeated. In an attack
    utilizing *return-oriented programming* (ROP), an attacker can “cherry-pick” instructions
    in executable regions and jump from instruction to instruction to build an exploit.
    There are some famous examples of this online, especially in video games.^([10](ch07.xhtml#fn7_10))'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: However, the best line of defense is always the programmer. To prevent buffer
    overflow attacks on your programs, use C functions with *length specifiers* whenever
    possible and add code that performs array bounds checking. It is crucial that
    any defined arrays match the chosen length specifiers. [Table 7-19](ch07.xhtml#ch7tab19)
    lists some common “bad” C functions that are vulnerable to buffer overflow and
    the corresponding “good” function to use (assume that `buf` is allocated 12 bytes).
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 7-19:** C Functions with Length Specifiers'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instead of** | **Use** |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
- en: '| `gets(buf)` | `fgets(buf, 12, stdin)` |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
- en: '| `scanf("%s", buf)` | `scanf("%12s", buf)` |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
- en: '| `strcpy(buf2, buf)` | `strncpy(buf2, buf, 12)` |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
- en: '| `strcat(buf2, buf)` | `strncat(buf2, buf, 12)` |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
- en: '| `sprintf(buf, "%d", num)` | `snprintf(buf, 12, "%d", num)` |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
- en: 'The `secret2` binary^([11](ch07.xhtml#fn7_11)) no longer has the buffer overflow
    vulnerability. Here’s the `main` function of this new binary:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: main2.c
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Notice that we added a length specifier to all calls of `scanf`, causing the
    `scanf` function to stop reading from the input after the first 12 bytes are read.
    The exploit string no longer breaks the program:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Of course, any reader with basic reverse-engineering skills can still win the
    guessing game by analyzing the assembly code. If you haven’t tried to beat the
    program yet with reverse engineering, we encourage you to do so now.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch07.xhtml#rfn7_1) Edsger Dijkstra,“Go To Statement Considered Harmful,”
    *Communications of the ACM* 11(3), pp. 147–148, 1968.'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch07.xhtml#rfn7_2) *[https://diveintosystems.org/book/C7-x86_64/recursion.html](https://diveintosystems.org/book/C7-x86_64/recursion.html)*'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch07.xhtml#rfn7_3) Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely
    Execute Malicious Code,” *[https://thehackernews.com/2017/06/skype-crash-bug.html](https://thehackernews.com/2017/06/skype-crash-bug.html)*,
    2017.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch07.xhtml#rfn7_4) Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow
    in multiple Android DRM services,” *[https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/](https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/)*,
    2018.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch07.xhtml#rfn7_5) Tom Spring, “Google Patches ‘High Severity’ Browser
    Bug,” *[https://threatpost.com/google-patches-high-severity-browser-bug/128661/](https://threatpost.com/google-patches-high-severity-browser-bug/128661/)*,
    2017.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch07.xhtml#rfn7_6) Christopher Kelty, “The Morris Worm,” *Limn Magazine*,
    Issue 1: Systemic Risk, 2011\. *[https://limn.it/articles/the-morris-worm/](https://limn.it/articles/the-morris-worm/)*'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch07.xhtml#rfn7_7) David Auerbach, “Chat Wars: Microsoft vs. AOL,” *NplusOne
    Magazine*, Issue 19, Spring 2014\. *[https://nplusonemag.com/issue-19/essays/chat-wars/](https://nplusonemag.com/issue-19/essays/chat-wars/)*'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch07.xhtml#rfn7_8) *[https://diveintosystems.org/book/C7-x86_64/_attachments/secretx86-64.tar.gz](https://diveintosystems.org/book/C7-x86_64/_attachments/secretx86-64.tar.gz)*'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '[9.](ch07.xhtml#rfn7_9) Aleph One, “Smashing the Stack for Fun and Profit,”
    *[http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)*,
    1996.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[10.](ch07.xhtml#rfn7_10) DotsAreCool, “Super Mario World Credit Warp” (Nintendo
    ROP example), *[https://youtu.be/vAHXK2wut_I](https://youtu.be/vAHXK2wut_I)*,
    2015.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '[11.](ch07.xhtml#rfn7_11) *[https://diveintosystems.org/book/C7-x86_64/_attachments/secret2x86-64.tar.gz](https://diveintosystems.org/book/C7-x86_64/_attachments/secret2x86-64.tar.gz)*'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
