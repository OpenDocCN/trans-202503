<html><head></head><body>
<h2 class="h2c" id="ch08"><span epub:type="pagebreak" id="page_149"/><span class="big1"><strong>8</strong></span><br/><strong>MANIPULATING CONTROL FLOW IN A GAME</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">Forcing a game to execute foreign code is definitely powerful, but what if you could alter the way a game executes its own code? What if you could force the game to bypass the code that draws the fog of war, trick it into making enemies visible through walls, or manipulate the arguments it passes to functions? <em>Control flow manipulation</em> lets you do exactly that, allowing you to change what a process does by intercepting code execution and monitoring, modifying, or preventing it.</p>&#13;
<p class="indent">There are many ways to manipulate the control flow of a process, but almost all require you to modify the process’s assembly code. Depending on your goals, you’ll need to either completely remove code from the process (called <em>NOPing</em>) or force the process to redirect execution to injected functions (called <em>hooking</em>). In the beginning of this chapter, you’ll learn about <span epub:type="pagebreak" id="page_150"/>NOPing, several types of hooking, and other control flow manipulation techniques. Once I’ve explained the basics, I’ll show you how I’ve applied these principles to common game libraries like Adobe AIR and Direct3D.</p>&#13;
<p class="indent">Open the directory <em>GameHackingExamples/Chapter8_ControlFlow</em> in this book’s resource files to see the complete sample code for the next section and “<a href="ch08.xhtml#ch00lev1sec151">Hooking to Redirect Game Execution</a>” on <a href="ch08.xhtml#page_153">page 153</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec148"><strong>NOPing to Remove Unwanted Code</strong></h3>&#13;
<p class="noindent"><a href="ch07.xhtml#ch07">Chapter 7</a> described how to inject new code into a game, but the opposite—removing code from a game—can also be useful. Some hacks require you to stop some of a game’s original code from being executed, and to do that, you’ll have to get rid of it. One way to eliminate code from a game process is NOPing, which involves overwriting the original x86 assembly code with NOP instructions.</p>&#13;
<h4 class="h4" id="ch00lev1sec149"><strong><em>When to NOP</em></strong></h4>&#13;
<p class="noindent">Consider a game that won’t show the health bars of cloaked enemies. It’s pretty hard to see cloaked enemies coming, and you’d have a huge advantage in combat if you could at least see their health bars. The code to draw health bars often looks like <a href="ch08.xhtml#ch8exe1">Listing 8-1</a>.</p>&#13;
<pre>for (int i = 0; i &lt; creatures.size(); i++) {<br/>    auto c = creatures[i];<br/>    if (c.isEnemy &amp;&amp; c.isCloaked) continue;<br/>    drawHealthBar(c.healthBar);<br/>}</pre>&#13;
<p class="listt"><a id="ch8exe1"/><em>Listing 8-1: The loop from the</em> <code><span class="codeitalic">drawCreatureHealthBarExample()</code></span> <em>function</em></p>&#13;
<p class="indent">When drawing health bars, a game with cloaked creatures might use a <code>for</code> loop to check whether the creatures within the screen’s bounds are cloaked. If an enemy isn’t cloaked, the loop calls some function (<code>drawHealthBar()</code> in this example) to display the enemy’s health bar.</p>&#13;
<p class="indent">Given the source code, you could force the game to draw even cloaked enemies’ health bars by simply removing <code>if (c.isEnemy &amp;&amp; c.isCloaked) continue;</code> from the code. But as a game hacker, you have only the assembly code, not the source code. When simplified, the assembly that <a href="ch08.xhtml#ch8exe1">Listing 8-1</a> translates into looks something like this pseudocode:</p>&#13;
<pre>  startOfLoop:                        ; for<br/>      MOV i, 0                        ; int i = 0<br/>      JMP condition                   ; first loop, skip increment<br/>  increment:<br/>      ADD i, 1                        ; i++<br/>  condition:<br/>      CMP i, creatures.Size()         ; i &lt; creatures.size()<br/>      JNB endOfLoop                   ; exit loop if i &gt;= creatures.size()<br/>  body:<br/>      MOV c, creatures[i]             ; auto c = creatures[i]<br/>      TEST c.isEnemy, c.isEnemy       ; if c.isEnemy<br/>      JZ drawHealthBar                ; draw bar if c.isEnemy == false<br/>      TEST c.isCloaked, c.isCloaked   ; &amp;&amp; c.isCloaked<br/>      JZ drawHealthBar                ; draw bar if c.isCloaked == false<br/><span class="ent">➊</span>     JMP increment                   ; continue<br/>  drawHealthBar:<br/>      CALL drawHealthBar(c.healthBar) ; drawHealthBar(c.healthBar)<br/>      JMP increment                   ; continue<br/>  endOfLoop:</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_151"/>To trick the game into drawing all enemy health bars, regardless of cloaking, you’d need to remove the <code>JMP increment</code> command <span class="ent">➊</span> that executes when <code>c.isEnemy &amp;&amp; c.isCloaked</code> evaluates to <code>true</code>. In assembly, though, replacing unwanted code with instructions that do nothing is easier than deleting code. That’s where the NOP command comes in. Since NOP is a single byte (0x90), you can overwrite the 2-byte <code>JMP increment</code> command with two NOP commands. When the processor reaches those NOP commands, it rolls over them and falls into <code>drawHealthBar()</code> even when <code>c.isEnemy &amp;&amp; c.isCloaked</code> evaluates to <code>true</code>.</p>&#13;
<h4 class="h4" id="ch00lev1sec150"><strong><em>How to NOP</em></strong></h4>&#13;
<p class="noindent">The first step to NOPing a chunk of assembly code is making the memory chunk where the code lives writable. It’s possible for the code on the same memory page to be executed while you’re writing the NOP commands, though, so you also want to make sure the memory is still executable. You can accomplish both of these tasks by setting the memory’s protection to <code>PAGE_EXECUTE_READWRITE</code>. Once the memory is properly protected, you can write the NOP commands and be done. It technically doesn’t hurt to leave the memory writable, but it’s good practice to also restore the original protection when you’re finished.</p>&#13;
<p class="indent">Provided you have facilities in place for writing and protecting memory (as described in <a href="ch06.xhtml#ch06">Chapter 6</a>), you can write a function like the one shown in <a href="ch08.xhtml#ch8exe2">Listing 8-2</a> to write NOP commands to game memory. (Follow along by opening the project’s <em>NOPExample.cpp</em> file.)</p>&#13;
<pre>template&lt;int SIZE&gt;<br/>void writeNop(DWORD address)<br/>{<br/>    auto oldProtection =<br/>        protectMemory&lt;BYTE[SIZE]&gt;(address, PAGE_EXECUTE_READWRITE);<br/><br/>    for (int i = 0; i &lt; SIZE; i++)<br/>        writeMemory&lt;BYTE&gt;(address + i, 0x90);<br/><br/>    protectMemory&lt;BYTE[SIZE]&gt;(address, oldProtection);<br/>}</pre>&#13;
<p class="listt"><a id="ch8exe2"/><em>Listing 8-2: Proper NOPing, complete with memory protection</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_152"/>In this example, the <code>writeNop()</code> function sets the appropriate memory protection, writes a number of NOP commands equal to <code>SIZE</code>, and reapplies the original memory protection level.</p>&#13;
<p class="indent">The <code>writeNop()</code> function takes the number of NOP instructions to place as a template parameter, since the memory functions require a correctly sized type at compile time. Passing an integer <code>SIZE</code> tells the memory functions to operate on a type of <code>BYTE[SIZE]</code> at compile time. To specify a dynamic size at runtime, simply drop the loop and instead call <code>protectMemory&lt;BYTE&gt;</code> and pass <code>address</code> and <code>address + SIZE</code> as arguments. As long as the size isn’t larger than a page (and really, you shouldn’t be NOPing a full page), this will ensure that the memory gets properly protected even if it’s on a page boundary.</p>&#13;
<p class="indent">Call this function with the address where you want to place your NOPs and the number of NOP commands to place:</p>&#13;
<pre>writeNop&lt;2&gt;(0xDEADBEEF);</pre>&#13;
<p class="indent">Keep in mind that the number of NOP commands should match the size in bytes of the command being removed. This call to <code>writeNop()</code> writes two NOP commands to the address 0xDEADBEEF.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>PRACTICE NOPING</strong></p>&#13;
<p class="noindent">If you haven’t already, open <em>NOPExample.cpp</em> in this chapter’s example code now and play around with it for a bit. You’ll find a working implementation of the <code>writeNop()</code> function and an interesting function called <code>getAddressforNOP()</code> that scans the example program’s memory to find where the NOP command should be placed.</p>&#13;
<p class="indent">To see the NOP command in action, run the compiled NOPapplication in Visual Studio’s debugger with breakpoints at the start and end of the <code>writeNop()</code> function. When the first breakpoint is hit, press <small>ALT</small>-8 to open the disassembly window, enter <code><span class="codestrong">address</code></span> in the input box, and press <small>ENTER</small>. This brings you to the NOP’s target address, where you’ll see the assembly code fully intact. Press F5 to continue execution, which triggers the second breakpoint after allowing the application to place the NOPs. Finally, jump back to <code>address</code> in the disassembly tab to see that the code was replaced by NOPs.</p>&#13;
<p class="indent">You can rework this code to do other cool stuff. For example, you might try placing NOPs on the comparisons instead of the jump or even modifying the jump’s type or destination.</p>&#13;
<p class="indent">These and other alternative approaches may work, but note that they introduce more room for error than overwriting the single JMP with NOP commands. When modifying foreign code, make as few changes as possible to minimize the potential for errors.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec151"><span epub:type="pagebreak" id="page_153"/><strong>Hooking to Redirect Game Execution</strong></h3>&#13;
<p class="noindent">So far, I’ve shown you how to manipulate games by adding code to them, hijacking their threads, creating new threads, and even removing existing code from their execution flow. These methods are very powerful on their own, but when combined, they form an even more potent method of manipulation called <em>hooking</em>. Hooking allows you to intercept precise branches of execution and redirect them to injected code that you’ve written to dictate what the game should do next, and it comes in a variety of flavors. In this section, I’ll teach you about four of the most powerful hooking methods for game hacking: call hooking, virtual function table hooking, import address table hooking, and jump hooking.</p>&#13;
<h4 class="h4" id="ch00lev1sec152"><strong><em>Call Hooking</em></strong></h4>&#13;
<p class="noindent">A <em>call hook</em> directly modifies the target of a <code>CALL</code> operation to point to a new piece of code. There are a few variations of the <code>CALL</code> operation in x86 assembly, but call hooks are generally used on only one: the <em>near call</em>, which takes an immediate address as an operand.</p>&#13;
<h5 class="h5" id="ch00lev1sec153"><strong>Working with Near Calls in Memory</strong></h5>&#13;
<p class="noindent">In an assembly program, a near call looks like this:</p>&#13;
<pre>CALL 0x0BADF00D</pre>&#13;
<p class="indent">This near call is represented by the byte 0xE8, so you might assume it is stored in memory like this:</p>&#13;
<pre>0xE8 0x0BADF00D</pre>&#13;
<p class="indent">Or, when split into single bytes and swapped for endianness, like this:</p>&#13;
<pre>0xE8 0x0D 0xF0 0xAD 0x0B</pre>&#13;
<p class="indent">But the anatomy of a near call in memory is not that simple. Instead of storing the callee’s absolute address, a near call stores an offset to the callee relative to the address immediately after the call. Since a near call is 5 bytes, the address immediately after the call is 5 bytes later in memory. Given that, the address stored can be computed as follows:</p>&#13;
<pre>calleeAddress – (callAddress + 5)</pre>&#13;
<p class="indent">If <code>CALL 0x0BADF00D</code> lives at 0xDEADBEEF in memory, then the value after 0xE8 is this:</p>&#13;
<pre>0x0BADF00D – (0xDEADBEEF + 5) = 0x2D003119</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>In memory, then, that <code>CALL</code> instruction looks like this:</p>&#13;
<pre>0xE8 0x19 0x31 0x00 0x2D</pre>&#13;
<p class="indent">To hook a near call, you first need to change the offset following 0xE8 (that is, the little-endian 0x19 0x31 0x00 0x2D) to point to your new callee.</p>&#13;
<h5 class="h5" id="ch00lev1sec154"><strong>Hooking a Near Call</strong></h5>&#13;
<p class="noindent">Following the same memory protection rules shown in <a href="ch08.xhtml#ch8exe2">Listing 8-2</a>, you hook a near call like so (follow along by opening <em>CallHookExample.cpp</em>):</p>&#13;
<pre>  DWORD callHook(DWORD hookAt, DWORD newFunc)<br/>  {<br/>      DWORD newOffset = newFunc - hookAt - 5;<br/><br/>      auto oldProtection =<br/>          protectMemory&lt;DWORD&gt;(hookAt + 1, PAGE_EXECUTE_READWRITE);<br/><br/>      DWORD originalOffset = readMemory&lt;DWORD&gt;(<span class="ent">➊</span>hookAt + 1);<br/>      writeMemory&lt;DWORD&gt;(hookAt + 1, newOffset);<br/>      protectMemory&lt;DWORD&gt;(hookAt + 1, oldProtection);<br/><br/><span class="ent">➋</span>     return originalOffset + hookAt + 5;<br/>  }</pre>&#13;
<p class="indent">This function takes as arguments the address of the <code>CALL</code> to hook (<code>hookAt</code>) and the address to redirect execution to (<code>newFunc</code>), and it uses them to calculate the offset required to call the code at the address <code>newFunc</code> contains. After you apply the correct memory protections, the <code>callHook()</code> function writes the new offset to the memory at <code>hookAt + 1</code> <span class="ent">➊</span>, applies the old memory protections, calculates the address of the original call <span class="ent">➋</span>, and returns that value to the caller.</p>&#13;
<p class="indent">Here’s how you might actually use a function like this in a game hack:</p>&#13;
<pre>DWORD origFunc = callHook(0xDEADBEEF, (DWORD)&amp;someNewFunction);</pre>&#13;
<p class="indent">This hooks the near call to 0x0BADF00D at 0xDEADBEEF and redirects it to the address of <code>someNewFunction</code>, which is the code your hack will execute. After this is called, the <code>origFunc</code> value will hold 0x0BADF00D.</p>&#13;
<h5 class="h5" id="ch00lev1sec155"><strong>Cleaning Up the Stack</strong></h5>&#13;
<p class="noindent">The new callee must also properly handle the stack, preserve registers, and pass proper return values. At the least, this means your replacement function must match the game’s original function in both calling convention and argument count.</p>&#13;
<p class="indent">Let’s say this is the original full function call, in assembly:</p>&#13;
<pre>PUSH 1<br/>PUSH 456<br/>PUSH 321<br/>CALL 0x0BADF00D <br/>ADD ESP, 0x0C</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_155"/>You can tell the function has the C++ <code>__cdecl</code> convention because the stack is being reset by the caller. Additionally, the 0x0C bytes being cleaned from the stack show that there are three arguments, which you can calculate as follows:</p>&#13;
<div class="imagec"><img src="../images/f0155-01.jpg" alt="image"/></div>&#13;
<p class="indent">Of course, you can also obtain the number of arguments by checking how many things are pushed to the stack: there are three <code>PUSH</code> commands, one for each argument.</p>&#13;
<h5 class="h5" id="ch00lev1sec156"><strong>Writing a Call Hook</strong></h5>&#13;
<p class="noindent">In any case, the new callee, <code>someNewFunction</code>, must follow the <code>__cdecl</code> convention and have three arguments. Here’s an example skeleton for the new callee:</p>&#13;
<pre>DWORD __cdecl someNewFunction(DWORD arg1, DWORD arg2, DWORD arg3)<br/>{<br/><br/>}</pre>&#13;
<p class="indent">In Visual Studio, C++ programs use the <code>__cdecl</code> convention by default, so technically you could omit it from your function definition; however, I’ve found it’s better to be verbose so you get into the habit of being specific. Also keep in mind that if the caller expects a value to be returned, the return type of your function should match as well. This example assumes the return type is always a <code>DWORD</code> or smaller. Since return types in this size range will all be passed back on EAX, further examples will also use a return type of <code>DWORD</code>.</p>&#13;
<p class="indent">In most cases, a hook finishes by calling the original function and passing its return value back to the caller. Here’s how all of that might fit together:</p>&#13;
<pre>typedef DWORD (__cdecl _origFunc)(DWORD arg1, DWORD arg2, DWORD arg3);<br/><br/>_origFunc* originalFunction =<br/>    (_origFunc*)hookCall(0xDEADBEEF, (DWORD)&amp;someNewFunction);<br/><br/>DWORD __cdecl someNewFunction(DWORD arg1, DWORD arg2, DWORD arg3)<br/>{<br/>    return originalFunction(arg1, arg2, arg3);<br/>}</pre>&#13;
<p class="indent">This example uses <code>typedef</code> to declare a type representing the original function’s prototype and creates a pointer with this type to the original <span epub:type="pagebreak" id="page_156"/>function. Then <code>someNewFunction()</code> uses this pointer to call the original function with the original arguments and pass the returned value back to the caller.</p>&#13;
<p class="indent">Right now, all <code>someNewFunction()</code> does is return to the original function. But you can do whatever you want from inside the <code>someNewFunction()</code> call from here. You can modify the parameters being passed to the original function or intercept and store interesting parameters for later use. If you know the caller isn’t expecting a return value (or if you know how to spoof the return value), you can even forget about the original function and completely replace, replicate, or improve its functionality inside the new callee. Once you’ve perfected this skill, you can add your own native C or C++ code to any part of a game that you wish.</p>&#13;
<h4 class="h4" id="ch00lev1sec157"><strong><em>VF Table Hooking</em></strong></h4>&#13;
<p class="noindent">Unlike call hooks, <em>virtual function (VF) table hooks</em> don’t modify assembly code. Instead, they modify the function addresses stored in the VF tables of classes. (If you need a refresher on VF tables, see “<a href="ch04.xhtml#ch00lev1sec78">A Class with Virtual Functions</a>” on <a href="ch04.xhtml#page_75">page 75</a>.) All instances of the same class type share a static VF table, so VF table hooks will intercept all calls made to a member function, regardless of which class instance the game is calling the function from. This can be both powerful and tricky.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>THE TRUTH ABOUT VF TABLES</strong></p>&#13;
<p class="noindent">To simplify the explanation, I lied a little when I said that VF table hooks could intercept all calls made to a function. In reality, the VF table is traversed only when a virtual function is called in a way that leaves the compiler with some plausible type ambiguity. For example, a VF table will be traversed when a function is called through the <code>inst-&gt;function()</code> call format. A VF table won’t be traversed when a virtual function is invoked in such a way that the compiler is sure about the type, as in <code>inst.function()</code> or similar calls, since the compiler will know the function’s address. Conversely, calling <code>inst.function()</code> from a scope where <code>inst</code> is passed in as a reference would trigger a VF table traversal. Before you try to deploy VF table hooking, make sure the function calls you want to hook have type ambiguity.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec158"><strong>Writing a VF Table Hook</strong></h5>&#13;
<p class="noindent">Before we go any deeper into how to place a VF table hook, we need to talk about those pesky calling conventions again. VF tables are used by class instances to call virtual member functions, and all member functions will have the <code>__thiscall</code> convention. The name <code>__thiscall</code> is derived from <span epub:type="pagebreak" id="page_157"/>the <code>this</code> pointer that member functions use to reference the active class instance. Thus, member functions are given <code>this</code> as a pseudoparameter on ECX.</p>&#13;
<p class="indent">It’s possible to match the prototype of a <code>__thiscall</code> by declaring a class that acts as a container for all <code>__thiscall</code> hook callbacks, but I don’t prefer this method. Instead, I find it easier to control the data using inline assembly. Let’s explore how you control the data when placing a VF hook on a class that looks like this:</p>&#13;
<pre>class someBaseClass {<br/>    public:<br/>        virtual DWORD someFunction(DWORD arg1) {}<br/>};<br/>class someClass : public someBaseClass {<br/>    public:<br/>        virtual DWORD someFunction(DWORD arg1) {}<br/>};</pre>&#13;
<p class="indent">The <code>someBaseClass</code> class just has one member (a public virtual function), and the <code>someClass</code> class inherits from <code>someBaseClass</code> and overrides the <code>someBaseClass::someFunction</code> member. To hook <code>someClass::someFunction</code>, you replicate the prototype in your VF table hook, as shown in <a href="ch08.xhtml#ch8exe3">Listing 8-3</a> (follow along in the <em>VFHookExample.cpp</em> file of the project).</p>&#13;
<pre>   DWORD __stdcall someNewVFFunction(DWORD arg1)<br/>   { <br/><span class="ent">➊</span>      static DWORD _this;<br/>        __asm MOV _this, ECX<br/>   }</pre>&#13;
<p class="listt"><a id="ch8exe3"/><em>Listing 8-3: The start of a VF table hook</em></p>&#13;
<p class="indent">This function works as a hook because <code>__thiscall</code> only differs from <code>__stdcall</code> in that the former is given <code>this</code> on ECX. To reconcile this small difference, the callback function uses inline assembly (denoted by <code>__asm</code>) to copy <code>this</code> from ECX to a static variable <span class="ent">➊</span>. Since the static variable is actually initialized as a global, the only code that executes before <code>MOV _this, ECX</code> is the code that sets up the stack frame—and that code never touches ECX. That ensures that the proper value is in ECX when the assembly is executed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If multiple threads start calling the same VF function, the</em> <code><span class="codeitalic">someNewVFFunction()</code></span> <em>hook will break because</em> <code><span class="codeitalic">_this</code></span> <em>might be modified by one call while still being used by another call. I’ve never personally run into this problem, as games don’t typically throw around multiple instances of critical classes between threads, but an efficient remedy would be to store</em> <code><span class="codeitalic">_this</code></span> <em>in thread local storage, ensuring each thread would have its own copy.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_158"/>Before returning, a VF table callback must also restore ECX, to keep with the <code>__thiscall</code> convention. Here’s how that process looks:</p>&#13;
<pre>DWORD __stdcall someNewVFFunction(DWORD arg1)<br/>{<br/>    static DWORD _this;<br/>    __asm MOV _this, ECX<br/><br/>    // do game modifying stuff here<br/><br/> __asm <span class="ent">➊</span>MOV ECX, _this<br/>}</pre>&#13;
<p class="indent">After executing some game-hacking code, this version of the function <code>someNewVFFunction()</code> restores ECX <span class="ent">➊</span> with a reversed version of the first <code>MOV</code> instruction from <a href="ch08.xhtml#ch8exe3">Listing 8-3</a>.</p>&#13;
<p class="indent">Unlike with <code>__cdecl</code> functions, however, you shouldn’t call functions that use the <code>__thiscall</code> convention from pure C++ using only a function pointer and <code>typedef</code> (as you would for a call hook). When calling the original function from a VF table hook, you must use inline assembly—that’s the only way to be sure you’re passing data (specifically <code>_this</code>) around properly. For example, this is how you continue to build the <code>someNewVFFunction()</code> hook:</p>&#13;
<pre>   DWORD __stdcall someNewVFFunction(DWORD arg1)<br/>   {<br/>       static DWORD _this, _ret;<br/>       __asm MOV _this, ECX<br/><br/>       // do pre-call stuff here<br/><br/>       __asm {<br/>           PUSH arg1<br/>           MOV ECX, _this<br/><span class="ent">➊</span>          CALL [originalVFFunction]<br/><span class="ent">➋</span>          MOV _ret, EAX<br/>       }<br/><br/>       // do post-call stuff here<br/><br/><span class="ent">➌</span>      __asm MOV ECX, _this<br/>       return _ret;<br/>   }</pre>&#13;
<p class="indent">Now, <code>someNewVFFunction()</code> stores <code>this</code> in the <code>_this</code> variable, allows some code to execute, calls the original game function <span class="ent">➊</span> that’s being hooked, stores that function’s return value in <code>_ret</code> <span class="ent">➋</span>, allows some more code to execute, restores <code>this</code> to ECX <span class="ent">➌</span>, and returns the value stored in <code>_ret</code>. The callee cleans the stack for <code>__thiscall</code> calls, so unlike a call hook, the pushed argument doesn’t need to be removed.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_159"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you want to remove a single pushed argument at any point, use the assembly instruction</em> <code><span class="codeitalic">ADD ESP, 0x4</code></span> <em>because a single argument is 4 bytes.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec159"><strong>Using a VF Table Hook</strong></h5>&#13;
<p class="noindent">With the calling convention established and a skeleton callback in place, it’s time to move on to the fun part: actually using a VF table hook. A pointer to a class’s VF table is the first member of every class instance, so placing a VF table hook requires only a class instance address and the index of the function to be hooked. Using these two pieces of information, you need only a modest amount of code to place a hook. Here’s an example:</p>&#13;
<pre>DWORD hookVF(DWORD classInst, DWORD funcIndex, DWORD newFunc)<br/>{<br/>    DWORD VFTable = <span class="ent">➊</span>readMemory&lt;DWORD&gt;(classInst);<br/>    DWORD hookAt = VFTable + funcIndex * sizeof(DWORD);<br/><br/>    auto oldProtection =<br/>        protectMemory&lt;DWORD&gt;(hookAt, PAGE_READWRITE);<br/>    DWORD originalFunc = readMemory&lt;DWORD&gt;(hookAt);<br/>    writeMemory&lt;DWORD&gt;(hookAt, newFunc);<br/>    protectMemory&lt;DWORD&gt;(hookAt, oldProtection);<br/><br/>    return originalFunc;<br/>}</pre>&#13;
<p class="indent">The <code>hookVF()</code> function finds the VF table by reading the first member of the class instance <span class="ent">➊</span> and storing it in <code>VFTable</code>. Since the VF table is just an array of <code>DWORD</code>-sized addresses, this code finds the function address by multiplying the function’s index in the VF table (<code>funcIndex</code> in this example) by the size of a <code>DWORD</code>, which is 4, and adding the result to the VF table’s address. From there, <code>hookVF()</code> acts similar to a call hook: it makes sure the memory is properly accessible by setting appropriate protections, stores the original function address for later, writes the new function address, and finally, restores the original memory protection.</p>&#13;
<p class="indent">You’ll typically hook the VF table of a class instantiated by the game, and calling a function like <code>hookVF()</code> for a VF table hook looks like this:</p>&#13;
<pre>DWORD origVFFunction =<br/>    hookVF(classInstAddr, 0, (DWORD)&amp;someNewVFFunction);</pre>&#13;
<p class="indent">As usual, you need to find <code>classInstAddr</code> and the <code>funcIndex</code> argument ahead of time.</p>&#13;
<p class="indent">There are some very niche cases in which VF table hooks are useful, and it can be really hard to find the right class pointers and functions. Given that, instead of showing contrived use cases, I’ll come back to VF table hooks in “<a href="ch08.xhtml#ch00lev1sec174">Applying Jump Hooks and VF Hooks to Direct3D</a>” on <a href="ch08.xhtml#page_175">page 175</a>, once I’ve discussed other types of hooking.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_160"/>If you want to play with VF hooks before reading more, add new virtual functions to the example classes in this book’s resource files and practice hooking them. You might even create a second class that derives from <code>someBaseClass</code> and place a hook on its virtual table to demonstrate how you can have two completely separate VF hooks on two classes that inherit the same base class.</p>&#13;
<h4 class="h4" id="ch00lev1sec160"><strong><em>IAT Hooking</em></strong></h4>&#13;
<p class="noindent">IAT hooks actually replace function addresses in a specific type of VF table, called the <em>import address table (IAT)</em>. Each loaded module in a process contains an IAT in its PE header. A module’s IAT holds a list of all the other modules on which the module depends, as well as a list of functions that the module uses from each dependency. Think of an IAT as a lookup table for APIs to call one another.</p>&#13;
<p class="indent">When a module is loaded, its dependencies are also loaded. Dependency loading is a recursive process that continues until all dependencies for all modules are loaded. As each dependency is loaded, the operating system finds all functions used by the dependent module and fills any blank spaces in its IAT with the function addresses. Then, when a module calls a function from a dependency, it makes that call by resolving the function’s address from the IAT.</p>&#13;
<h5 class="h5" id="ch00lev1sec161"><strong>Paying for Portability</strong></h5>&#13;
<p class="noindent">Function addresses are always resolved from the IAT in real time, so hooking the IAT is similar to hooking VF tables. Since function pointers are stored in the IAT beside their actual names, there’s no need to do any reverse engineering or memory scanning; as long as you know the name of the API you want to hook, you can hook it! Moreover, IAT hooking lets you easily hook Windows API calls on a module-specific basis, allowing your hooks to intercept only API calls from a game’s main module.</p>&#13;
<p class="indent">This portability has a cost, though; the code to place an IAT hook is much more complex than what you’ve seen so far. First, you need to locate the PE header of the game’s main module. Since the PE header is the first structure in any binary, you can find it at the base address of each module, as shown in <a href="ch08.xhtml#ch8exe4">Listing 8-4</a> (follow along in the <em>IATHookExample.cpp</em> file of the project).</p>&#13;
<pre>DWORD baseAddr = (DWORD)GetModuleHandle(NULL);</pre>&#13;
<p class="listt"><a id="ch8exe4"/><em>Listing 8-4: Fetching the module’s base address</em></p>&#13;
<p class="indent">Once you’ve found the base address, you must verify that the PE header is valid. This validation can be very important, as some games try to prevent these types of hooks by scrambling nonessential parts of their PE header after they load. A valid PE header is prefixed by a DOS header, which indicates <span epub:type="pagebreak" id="page_161"/>the file is a DOS MZ executable; the DOS header is identified by the magic value 0x5A4D. A member of the DOS header called <code>e_lfanew</code> then points to the optional header, which contains values like the size of the code, a version number, and so on and is identified by the magic value 0x10B.</p>&#13;
<p class="indent">The Windows API has PE structures called <code>IMAGE_DOS_HEADER</code> and <code>IMAGE_OPTIONAL_HEADER</code> that correspond to the DOS header and optional header, respectively. You can use them to validate the PE header with code like <a href="ch08.xhtml#ch8exe5">Listing 8-5</a>.</p>&#13;
<pre>auto dosHeader = pointMemory&lt;IMAGE_DOS_HEADER&gt;(baseAddr);<br/>if (dosHeader-&gt;e_magic != 0x5A4D)<br/>    return 0;<br/><br/>auto optHeader =<br/>    pointMemory&lt;IMAGE_OPTIONAL_HEADER&gt;(baseAddr + dosHeader-&gt;e_lfanew + 24);<br/>if (optHeader-&gt;Magic != 0x10B)<br/>    return 0;</pre>&#13;
<p class="listt"><a id="ch8exe5"/><em>Listing 8-5: Confirming the DOS and optional headers are valid</em></p>&#13;
<p class="indent">The calls to <code>pointMemory()</code> create pointers to the two headers that need to be checked. If either <code>if()</code> statement returns <code>0</code>, then the corresponding header has the wrong magic number, meaning the PE header isn’t valid.</p>&#13;
<p class="indent">References to the IAT from assembly are hardcoded, meaning assembly references don’t traverse the PE header to locate the IAT. Instead, each function call has a static location indicating where to find the function address. That means overwriting the PE header to say that there are no imports is a viable way to protect against IAT hooks, and some games have this protection.</p>&#13;
<p class="indent">To account for that, you also need to make sure the game’s IAT still exists. <a href="ch08.xhtml#ch8exe6">Listing 8-6</a> shows how to add such a check to the code in <a href="ch08.xhtml#ch8exe5">Listing 8-5</a>.</p>&#13;
<pre>auto IAT = optHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];<br/>if (IAT.Size == 0 || IAT.VirtualAddress == 0)<br/>    return 0;</pre>&#13;
<p class="listt"><a id="ch8exe6"/><em>Listing 8-6: Checking that the IAT actually exists</em></p>&#13;
<p class="indent">The PE header contains many sections that store information about the application’s code, embedded resources, relocations, and so on. The piece of code in <a href="ch08.xhtml#ch8exe6">Listing 8-6</a> is particularly interested in the data section, which—as you might guess—stores many different types of data. Each type of data is stored in its own directory, and the <code>DataDirectory</code> member of <code>IMAGE_OPTIONAL_HEADER</code> is an array of directory headers that describes the size and virtual address of each directory in the data section. The Windows API defines a constant called <code>IMAGE_DIRECTORY_ENTRY_IMPORT</code>, which happens to be the index of the IAT header within the <code>DataDirectory</code> array.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>Thus, this code uses <code>optHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]</code> to resolve the header of the IAT and check that the header’s <code>Size</code> and <code>VirtualAddress</code> are nonzero, essentially confirming its existence.</p>&#13;
<h5 class="h5" id="ch00lev1sec162"><strong>Traversing the IAT</strong></h5>&#13;
<p class="noindent">Once you know the IAT is still intact, you can start traversing it, and this is where IAT hooking starts to get ugly. The IAT is an array of structures called <em>import descriptors</em>. There is one import descriptor for each dependency, each import descriptor points to an array of structures called <em>thunks</em>, and each thunk represents a function imported from the dependency.</p>&#13;
<p class="indent">Luckily, the Windows API exposes both the import descriptors and thunks through the <code>IMAGE_IMPORT_DESCRIPTOR</code> and <code>IMAGE_THUNK_DATA</code> structures, respectively. Having the structures predefined saves you from creating your own, but it doesn’t make the code to traverse the IAT any prettier. To see what I mean, look at <a href="ch08.xhtml#ch8exe7">Listing 8-7</a>, which builds on <a href="ch08.xhtml#ch8exe4">Listings 8-4</a> through <a href="ch08.xhtml#ch8exe6">8-6</a>.</p>&#13;
<pre>   auto impDesc =<br/>       pointMemory&lt;IMAGE_IMPORT_DESCRIPTOR&gt;(<span class="ent">➊</span>baseAddr + IAT.VirtualAddress);<br/><br/><span class="ent">➋</span> while (impDesc-&gt;FirstThunk) {<br/><span class="ent">➌</span>     auto thunkData =<br/>          pointMemory&lt;IMAGE_THUNK_DATA&gt;(baseAddr + impDesc-&gt;OriginalFirstThunk);<br/>      int n = 0;<br/><span class="ent">➍</span>     while (thunkData-&gt;u1.Function) {<br/>          // the hook happens in here<br/>          n++;<br/>          thunkData++;<br/>      }<br/>      impDesc++;<br/>   }</pre>&#13;
<p class="listt"><a id="ch8exe7"/><em>Listing 8-7: Iterating over the IAT to find a function</em></p>&#13;
<p class="indent">Keeping in mind that the import descriptors are stored relative to the start of the PE header, this code adds the module’s base address to the virtual address found in the IAT’s directory header <span class="ent">➊</span>, creating a pointer, <code>impDesc</code>, that points to the module’s first import descriptor.</p>&#13;
<p class="indent">Import descriptors are stored in a sequential array, and a descriptor with a <code>FirstThunk</code> member set to <code>NULL</code> signifies the end of the array. Knowing this, the code uses a <code>while</code> loop <span class="ent">➋</span> that continues until <code>impDesc-&gt;FirstThunk</code> is <code>NULL</code>, incrementing the descriptor by executing <code>impDesc++</code> each iteration.</p>&#13;
<p class="indent">For each import descriptor, the code creates a pointer called <code>thunkData</code> <span class="ent">➌</span> that points to the first thunk inside the descriptor. Using a familiar loop, the code iterates over thunks <span class="ent">➍</span> until one is found with a <code>Function</code> member set to <code>NULL</code>. The loop also uses an integer, <code>n</code>, to keep track of the current thunk index, as the index is important when placing the hook.</p>&#13;
<h5 class="h5" id="ch00lev1sec163"><span epub:type="pagebreak" id="page_163"/><strong>Placing the IAT Hook</strong></h5>&#13;
<p class="noindent">From here, placing the hook is just a matter of finding the proper function name and replacing the function address. You can find the name inside the nested <code>while</code> loop, as shown in <a href="ch08.xhtml#ch8exe8">Listing 8-8</a>.</p>&#13;
<pre>char* importFunctionName =<br/>    pointMemory&lt;char&gt;(baseAddr + (DWORD)thunkData-&gt;u1.AddressOfData + 2);</pre>&#13;
<p class="listt"><a id="ch8exe8"/><em>Listing 8-8: Finding the function name</em></p>&#13;
<p class="indent">The function name for each thunk is stored at <code>thunkData-&gt;u1.AddressOfData + 2</code> bytes into the module, so you can add that value to the module’s base address to locate the function name in memory.</p>&#13;
<p class="indent">After obtaining a pointer to the function name, use <code>strcmp()</code> to check whether it’s the target function, like so:</p>&#13;
<pre>if (strcmp(importFuncName, funcName) == 0) {<br/>    // the final step happens in here<br/>}</pre>&#13;
<p class="indent">Once you’ve located the target function using its name, you simply need to overwrite the function address with the address of your own function. Unlike function names, function addresses are stored in an array at the start of each import descriptor. Using <code>n</code> from the thunk loop, you can finally set the hook, as shown in <a href="ch08.xhtml#ch8exe9">Listing 8-9</a>.</p>&#13;
<pre>   auto vfTable = pointMemory&lt;DWORD&gt; (baseAddr + impDesc-&gt;FirstThunk);<br/>   DWORD original = vfTable[n];<br/><br/><span class="ent">➊</span> auto oldProtection = protectMemory&lt;DWORD&gt;((DWORD)&amp;vfTable[n], PAGE_READWRITE);<br/><span class="ent">➋</span> vfTable[n] = newFunc;<br/>   protectMemory&lt;DWORD&gt;((DWORD)&amp;vfTable[n], oldProtection);</pre>&#13;
<p class="listt"><a id="ch8exe9"/><em>Listing 8-9: Finding the function address</em></p>&#13;
<p class="indent">This code locates the VF table for the current descriptor by adding the address of the first thunk to the module base address. The VF table is an array of function addresses, so the code uses the <code>n</code> variable as an index to locate the target function address.</p>&#13;
<p class="indent">Once the address is found, the code in <a href="ch08.xhtml#ch8exe9">Listing 8-9</a> works just like a typical VF hook: it stores the original function address, sets the protection of index <code>n</code> in the VF table to <code>PAGE_READWRITE</code> <span class="ent">➊</span>, inserts the new function address into the VF table <span class="ent">➋</span>, and finally restores the old protection.</p>&#13;
<p class="indent">If you stitch together the code from <a href="ch08.xhtml#ch8exe4">Listings 8-4</a> through <a href="ch08.xhtml#ch8exe9">8-9</a>, the final IAT hooking function looks like <a href="ch08.xhtml#ch8exe10">Listing 8-10</a>.</p>&#13;
<pre>DWORD hookIAT(const char* funcName, DWORD newFunc)<br/>                 {<br/>    DWORD baseAddr = (DWORD)GetModuleHandle(NULL);<br/>    auto dosHeader = pointMemory&lt;IMAGE_DOS_HEADER&gt;(baseAddr);<br/>    if (dosHeader-&gt;e_magic != 0x5A4D)<br/>        return 0;<br/><br/>    auto optHeader =<br/>        pointMemory&lt;IMAGE_OPTIONAL_HEADER&gt;(baseAddr + dosHeader-&gt;e_lfanew + 24);<br/>    if (optHeader-&gt;Magic != 0x10B)<br/>        return 0;<br/><br/>    auto IAT =<br/>        optHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];<br/>    if (IAT.Size == 0 || IAT.VirtualAddress == 0)<br/>        return 0;<br/><br/>    auto impDesc =<br/>        pointMemory&lt;IMAGE_IMPORT_DESCRIPTOR&gt;(baseAddr + IAT.VirtualAddress);<br/><br/>    while (impDesc-&gt;FirstThunk) {<br/>        auto thunkData =<br/>            pointMemory&lt;IMAGE_THUNK_DATA&gt;(baseAddr + impDesc-&gt;OriginalFirstThunk);<br/>        int n = 0;<br/>        while (thunkData-&gt;u1.Function) {<br/>            char* importFuncName = pointMemory&lt;char&gt;<br/>                (baseAddr + (DWORD)thunkData-&gt;u1.AddressOfData + 2);<br/>            if (strcmp(importFuncName, funcName) == 0) {<br/>                auto vfTable = pointMemory&lt;DWORD&gt;(baseAddr + impDesc-&gt;FirstThunk);<br/>                DWORD original = vfTable[n];<br/>                auto oldProtection =<br/>                    protectMemory&lt;DWORD&gt;((DWORD)&amp;vfTable[n], PAGE_READWRITE);<br/>                vfTable[n] = newFunc;<br/>                protectMemory&lt;DWORD&gt;((DWORD)&amp;vfTable[n], oldProtection);<br/>                return original;<br/>            }<br/>            n++;<br/>            thunkData++;<br/>        }<br/>        impDesc++;<br/>    }<br/>}</pre>&#13;
<p class="listt"><span epub:type="pagebreak" id="page_164"/><a id="ch8exe10"/><em>Listing 8-10: The complete IAT hooking function</em></p>&#13;
<p class="indent">This is the most complex code that we’ve put together so far, and it’s pretty hard to read when squished to fit on a page. If you haven’t yet wrapped your head around what it’s doing, you might want to study the example code from this book’s resource files before continuing.</p>&#13;
<h5 class="h5" id="ch00lev1sec164"><strong>Using an IAT Hook to Sync with a Game Thread</strong></h5>&#13;
<p class="noindent">With the code in <a href="ch08.xhtml#ch8exe10">Listing 8-10</a>, hooking any Windows API function is as simple as knowing the function name and the proper prototype. The <code>Sleep()</code> API is a common API to hook when game hacking, as bots can use a <code>Sleep()</code> hook to thread-sync with a game’s main loop.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_165"/><strong>GETTING IN SYNC WITH THREAD SYNC</strong></p>&#13;
<p class="noindent">Your injected code will inevitably have to sync with a game’s main loop, or it won’t work. When you’re reading or writing data larger than 4 bytes, for example, being out of sync allows the game to read or write that data at the same time as you. You’ll be stepping on the game’s toes, and vice versa, leading to all sorts of race conditions and data corruption issues. Similarly, if you try to call a game’s function from your own thread, you run the risk of crashing the game if the function is not thread safe.</p>&#13;
<p class="indent">Since IAT hooks are thread-safe modifications to the PE header, they can be placed from any thread. By placing one on a function that’s called before or after the game’s main loop, you can effectively sync with the game’s main thread. All you need to do is place the hook and execute any thread-sensitive code from your hook callback.</p>&#13;
</div>&#13;
<p class="indent">Here’s one way to use <code>hookIAT()</code> to hook the <code>Sleep()</code> API:</p>&#13;
<pre>VOID WINAPI newSleepFunction(DWORD ms)<br/>{<br/>    // do thread-sensitive things<br/>    originalSleep(ms);<br/>}<br/><br/>typedef VOID (WINAPI _origSleep)(DWORD ms);<br/>_origSleep* originalSleep =<br/>    (_origSleep*)hookIAT("Sleep", (DWORD)&amp;newSleepFunction);</pre>&#13;
<p class="indent">Here’s why this works. At the end of a game’s main loop, it might call <code>Sleep()</code> to rest until it’s ready to draw the next frame. Since it’s sleeping, it’s safe for you to do anything you want without worrying about synchronization issues. Some games might not do this, or they might call <code>Sleep()</code> from multiple threads, and those games will require a different method.</p>&#13;
<p class="indent">A more portable alternative is to hook the <code>PeekMessageA()</code> API function, because games often call that function from the main loop while waiting for input. Then, your bot can do thread-sensitive operations from within the <code>PeekMessageA()</code> hook, ensuring that they’re done from the game’s main thread. You may also want your bot to use this method to hook the <code>send()</code> and <code>recv()</code> API functions, as intercepting these allows you to create a packet sniffer relatively simply.</p>&#13;
<h4 class="h4" id="ch00lev1sec165"><strong><em>Jump Hooking</em></strong></h4>&#13;
<p class="noindent"><em>Jump hooking</em> allows you to hook code in places where there is no branching code to manipulate. A jump hook replaces the code being hooked with an unconditional jump to a <em>trampoline function</em>. When the jump is hit, <span epub:type="pagebreak" id="page_166"/>the trampoline function stores all current register and flag values, calls a callback function of your choice, restores the registers, restores the flags, executes the code that was replaced by the hook, and finally jumps back to the code just below the hook. This process is shown in <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>.</p>&#13;
<div class="image"><img src="../images/f08-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch8fig1"/><em>Figure 8-1: A jump hook</em></p>&#13;
<p class="indent">The original code shows an example of some unmodified assembly you might find in a game, and the hooked code shows how that assembly might look after being hooked by a jump hook. The trampoline box shows an example trampoline function, in assembly, and the callback represents the code you’re trying to execute through hooking. In the original code, the assembly executes from top to bottom. In the hooked code, to get from the <code>SUB EAX,1</code> instruction to the <code>RETN</code> instruction, execution must follow the path shown by the dashed arrows.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If your callback code is simple, it can be integrated into the trampoline instead. It’s also not always necessary to store and restore the registers and flags, but doing so is good practice.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec166"><strong>Placing a Jump</strong></h5>&#13;
<p class="noindent">The byte code of an unconditional jump resembles that of a near call, but the first byte is 0xE9 instead of 0xE8. (See “<a href="ch08.xhtml#ch00lev1sec153">Working with Near Calls in Memory</a>” on <a href="ch08.xhtml#page_153">page 153</a> for a refresher.) In <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>, the unconditional jump <code>JMP trampoline</code> replaces the following four operations:</p>&#13;
<pre>POP EAX<br/>MOV AL, 1<br/>POP EDI<br/>POP ESI</pre>&#13;
<p class="indent">In this case, you need to replace multiple sequential operations to accommodate the 5-byte size of the unconditional jump. You may come across cases where the size of the operation (or operations) being replaced is larger than 5 bytes. When this happens, replace the remaining bytes with NOP instructions.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_167"/>Now, let’s look at how to replace those operations. <a href="ch08.xhtml#ch8exe11">Listing 8-11</a> shows the code to place a jump hook.</p>&#13;
<pre>   DWORD hookWithJump(DWORD hookAt, DWORD newFunc, int size)<br/>   {<br/>       if (size &gt; 12) // shouldn't ever have to replace 12+ bytes<br/>           return 0;<br/><span class="ent">➊</span>      DWORD newOffset = newFunc - hookAt - 5;<br/><br/>       auto oldProtection =<br/>           protectMemory&lt;DWORD[3]&gt;(hookAt + 1,PAGE_EXECUTE_READWRITE);<br/><span class="ent">➋</span>      writeMemory&lt;BYTE&gt;(hookAt, 0xE9);<br/><span class="ent">➌</span>      writeMemory&lt;DWORD&gt;(hookAt + 1, newOffset);<br/>       for (unsigned int i = 5; i &lt; size; i++)<br/>           writeMemory&lt;BYTE&gt;(hookAt + i, 0x90);<br/>       protectMemory&lt;DWORD[3]&gt;(hookAt + 1, oldProtection);<br/><br/>       return hookAt + 5;<br/>   }</pre>&#13;
<p class="listt"><a id="ch8exe11"/><em>Listing 8-11: How to place a jump hook</em></p>&#13;
<p class="indent">This function takes the address to hook at, the address of the callback function, and the size of the memory to overwrite (in bytes) as arguments. First, it calculates the offset between the hook site and the trampoline and stores the result in <code>newOffset</code> <span class="ent">➊</span>. Next, <code>PAGE_EXECUTE_READWRITE</code> permissions are applied to the memory to be changed. The unconditional jump (0xE9) <span class="ent">➋</span> and the address of the callback function <span class="ent">➌</span> are then written to memory, and a <code>for</code> loop writes NOP instructions (0x90) to any abandoned bytes. After the old protections are reapplied, <code>hookWithJump()</code> returns to the original address.</p>&#13;
<p class="indent">Notice that the <code>hookWithJump()</code> function ensures that <code>size</code> is not above 12 before placing the jump. This check is important because a jump takes up 5 bytes, meaning it can replace up to five commands if the first four are each a single byte. If the first four commands are each a single byte, the fifth command would need to be more than 8 bytes to trigger the <code>if (size &gt; 12)</code> clause. Because 9-byte operations are very, very rare, 12 is a safe but flexible limit. Having this limit can stop all sorts of bugs from happening, especially if your bot is dynamically detecting the <code>size</code> parameter. If the bot messes up and passes a <code>size</code> of <code>500,000,000</code>, for instance, the check will stop you from NOPing the whole universe.</p>&#13;
<h5 class="h5" id="ch00lev1sec167"><strong>Writing the Trampoline Function</strong></h5>&#13;
<p class="noindent">Using the function in <a href="ch08.xhtml#ch8exe11">Listing 8-11</a>, you can replicate the hook shown in <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>, but first you’ll have to create the trampoline function as follows:</p>&#13;
<pre><span epub:type="pagebreak" id="page_168"/>   DWORD restoreJumpHook = 0;<br/>   void __declspec(naked) myTrampoline()<br/>   {<br/>      __asm {<br/><span class="ent">➊</span>         PUSHFD<br/><span class="ent">➋</span>         PUSHAD<br/><span class="ent">➌</span>         CALL jumpHookCallback<br/><span class="ent">➍</span>         POPAD<br/><span class="ent">➎</span>         POPFD<br/><span class="ent">➏</span>         POP EAX<br/>          MOV AL, 1<br/>          POP EDI<br/><span class="ent">➐</span>         POP ESI<br/><span class="ent">➑</span>         JMP [restoreJumpHook]<br/>      }<br/>  }</pre>&#13;
<p class="indent">Just like the trampoline described alongside <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>, this trampoline stores all current flag <span class="ent">➊</span> and register values <span class="ent">➋</span>, calls a callback function <span class="ent">➌</span>, restores the registers <span class="ent">➍</span>, restores the flags <span class="ent">➎</span>, executes the code that was replaced by the hook at <span class="ent">➏</span> and <span class="ent">➐</span>, and finally jumps back to the original code just below the jump and NOPs <span class="ent">➑</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>To ensure that the compiler doesn’t autogenerate any extra code within the trampoline, always declare the trampoline using the</em> <code><span class="codeitalic">__declspec(naked)</code></span> <em>convention.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec168"><strong>Finishing the Jump Hook</strong></h5>&#13;
<p class="noindent">Once you create the trampoline, define the callback and set the hook like so:</p>&#13;
<pre>void jumpHookCallback() {<br/>    // do stuff<br/>}<br/>restoreJumpHook = hookWithJump(0xDEADBEEF, &amp;myTrampoline, 5);</pre>&#13;
<p class="indent">Finally, inside the <code>jumpHookCallback()</code> function, execute the code that relies on the hook. If your code needs to read or write the values of the registers as they were when the hook executed, you’re in luck. The <code>PUSHAD</code> command pushes them to the stack in the order EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI. The trampoline calls <code>PUSHAD</code> directly before the <code>jumpHookCallback()</code> call, so you can reference the register values as arguments, like this:</p>&#13;
<pre>void jumpHookCallback(DWORD EDI, DWORD ESI, DWORD EBP, DWORD ESP,<br/>                      DWORD EBX, DWORD EDX, DWORD ECX, DWORD EAX) {<br/>    // do stuff<br/>}<br/>restoreJumpHook = hookWithJump(0xDEADBEEF, &amp;myTrampoline, 5);</pre>&#13;
<p class="indent">Since the trampoline uses <code>POPAD</code> to directly restore the registers from these values on the stack, any modifications you make to the parameters will be applied to the actual registers when they are restored from the stack.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_169"/>Like VF table hooks, jump hooks are rarely needed, and they can be tricky to simulate with a simple example. To help you wrap your head around them, I’ll explore a real-world, practical use case in “<a href="ch08.xhtml#ch00lev1sec174">Applying Jump Hooks and VF Hooks to Direct3D</a>” on <a href="ch08.xhtml#page_175">page 175</a>.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>PROFESSIONAL API HOOKING LIBRARIES</strong></p>&#13;
<p class="noindent">There are prewritten hooking libraries, like Microsoft’s Detours and MadCHook, that use only jump hooks. These libraries can automatically detect and follow other hooks, they know how many instructions to replace, and they generate trampoline functions for you. The libraries are able to do this because they understand how to disassemble and walk through assembly instructions to determine lengths, jump destinations, and so on. If you need to use hooks with that much power, it is arguably better to use one of those libraries than to create your own.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec169"><strong>Applying Call Hooks to Adobe AIR</strong></h3>&#13;
<p class="noindent">Adobe AIR is a development framework that can be used to make cross-platform games in an environment similar to Abode Flash. AIR is a common framework for online games, as it allows developers to write cross-platform code in a versatile, high-level language called ActionScript. ActionScript is an interpreted language, and AIR runs the code inside a virtual machine, which makes it infeasible to hook game-specific code with AIR. Instead, it is easier to hook AIR itself.</p>&#13;
<p class="indent">The example code for this section can be found in <em>GameHackingExamples/Chapter8_AdobeAirHook</em> in this book’s source files. The code comes from an old project of mine, and it works on any game running <em>Adobe AIR.dll</em> version 3.7.0.1530. I’ve gotten it working on other versions as well, but I can’t guarantee it will work with much newer or much older versions, so treat this as a case study.</p>&#13;
<h4 class="h4" id="ch00lev1sec170"><strong><em>Accessing the RTMP Goldmine</em></strong></h4>&#13;
<p class="noindent">The <em>Real Time Messaging Protocol (RTMP)</em> is a text-based network protocol that ActionScript uses to serialize and send entire objects over the network. RTMP sits on top of the <em>HyperText Transfer Protocol (HTTP)</em>, and a secure version, RTMPS, sits on top of <em>HTTP Secure (HTTPS)</em>. RTMPS allows game developers to easily send and receive entire object instances over a secure connection with little complication, making it the network protocol of choice for any games running on AIR.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Data sent over RTMP/RTMPS is serialized through</em> Action Message Format (AMF)<em>, and parsing AMF packets is beyond the scope of this book. Search online for “AMF3 Parser,” and you’ll find a lot of code that does it.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_170"/>Data sent over RTMP and RTMPS is very rich. The packets contain information about object types, names, and values. This is a gold mine. If you can intercept this data in real time, you can instantaneously respond to changes in game state, see a wealth of critical information without ever reading it from memory, and find useful pieces of data that you might not even know exist.</p>&#13;
<p class="indent">A while back, I was working on a tool that required a ton of insight into the state of a game. Obtaining such a large amount of data directly from memory would have been extremely hard, if not impossible. After some research, I realized that the game was using RTMPS to communicate with the server, and that prompted me to start digging into this gold mine.</p>&#13;
<p class="indent">Since RTMPS is encrypted, I knew I had to somehow hook the cryptographic functions used by AIR before I could get any usable data. After searching online, I found source code for a small tool called airlog, created by another game hacker who, like me, was trying to log packets sent over RTMPS. Although the tool hooked the exact functions I needed, the code was outdated, messy, and, worst of all, didn’t work on the version of AIR I was trying to hook.</p>&#13;
<p class="indent">But that didn’t mean it was useless. Not only did airlog hook the two functions I needed, but it also located them by scanning for certain byte patterns within the Adobe AIR library. These byte patterns were three years old, though, so they weren’t working anymore. The newer versions of Adobe AIR had changed enough that the assembly bytes were no longer the same. The difference in bytes was a problem for the code in airlog, but not for me.</p>&#13;
<p class="indent">Inside an inline assembly block, you can specify raw bytes with the following function call:</p>&#13;
<pre>_emit <span class="codeitalic">BYTE</span></pre>&#13;
<p class="indent">If you replace <code><span class="codeitalic">BYTE</code></span> with, say, <code>0x03</code>, the code will be compiled in a way that treats <code>0x03</code> as a byte in the assembly code, regardless of whether that makes sense. Using this trick, I compiled the byte arrays back to assembly code. The code didn’t do anything, and it wasn’t meant to; using this trick simply allowed me to attach to my dummy application with OllyDBG and inspect bytes, which were conveniently presented as a clean disassembly.</p>&#13;
<p class="indent">Since these bytes represented the code surrounding the functions I needed, so, too, did their disassembly. The code was pretty standard and didn’t seem likely to change, so I turned my attention to the constants. The code had a few immediate values passed as offsets in commands. Knowing how commonly these can change, I rewired airlog’s pattern-matching algorithm to support wildcards, updated the patterns to treat any constants as wildcards, and then ran the match. After some tweaks to the patterns and a bit of digging through duplicate search results, I tracked down the functions I wanted to hook. I appropriately named them <code>encode()</code> and <code>decode()</code> and began working on a tool similar to airlog—but better.</p>&#13;
<h4 class="h4" id="ch00lev1sec171"><span epub:type="pagebreak" id="page_171"/><strong><em>Hooking the RTMPS encode() Function</em></strong></h4>&#13;
<p class="noindent">I discovered that the <code>encode()</code> function, which is used to encrypt the data for outgoing packets, is a nonvirtual <code>__thiscall</code>, meaning it’s called by a near call. Moreover, the call happens inside a loop. The entire loop looks like <a href="ch08.xhtml#ch8exe12">Listing 8-12</a>, taken directly from the OllyDBG disassembly pane.</p>&#13;
<pre>   loop:<br/>       MOV EAX, [ESI+3C58]<br/>       SUB EAX,EDI<br/>       PUSH EAX<br/><span class="ent">➊</span>      LEA EAX, [ESI+EDI+1C58]<br/>       PUSH EAX<br/>       MOV ECX,ESI<br/><span class="ent">➋</span>      CALL encode<br/>       CMP EAX,-1<br/><span class="ent">➌</span>      JE SHORT endLoop<br/>       ADD EDI,EAX<br/><span class="ent">➍</span>      CMP EDI, [ESI+3C58]<br/>       JL loop<br/>   endLoop:</pre>&#13;
<p class="listt"><a id="ch8exe12"/><em>Listing 8-12: The <code>encode()</code> loop</em></p>&#13;
<p class="indent">With a bit of analysis and some guidance from airlog, I determined that the <code>encode()</code> function called at <span class="ent">➊</span> takes a byte array and buffer length (let’s call them <code>buffer</code> and <code>size</code>, respectively) as parameters. The function returns <code>-1</code> when it fails and returns <code>size</code> otherwise. The function operates on chunks of 4,096 bytes, which is why this happens in a loop.</p>&#13;
<p class="indent">Turned into more readable pseudocode, the loop calling <code>encode()</code> looks like this (the numbers refer to the relevant assembly instructions in <a href="ch08.xhtml#ch8exe12">Listing 8-12</a>):</p>&#13;
<pre>for (EDI = 0; EDI &lt; <span class="ent">➍</span>[ESI+3C58]; ) {<br/>    EAX = <span class="ent">➋</span>encode(<span class="ent">➊</span>&amp;[ESI+EDI+1C58], [ESI+3C58] - EDI);<br/>    if (EAX == -1) <span class="ent">➌</span>break;<br/>    EDI += EAX;<br/>}</pre>&#13;
<p class="indent">I wasn’t interested in what <code>encode()</code> did, but I needed the entire buffer it was looping over, and hooking <code>encode()</code> was my means of getting that buffer. Looking at the real loop in <a href="ch08.xhtml#ch8exe12">Listing 8-12</a>, I knew that the calling object instance’s full buffer was stored at ESI+0x1C58, that the full size was stored at ESI+0x3C58, and that EDI contained the loop counter. I devised the hook with these things in mind, ultimately creating a two-part hook.</p>&#13;
<p class="indent">The first part of my hook was a <code>reportEncode()</code> function that logs the entire buffer on the first loop iteration. Here’s the <code>reportEncode()</code> function in full:</p>&#13;
<pre>DWORD __stdcall reportEncode(<br/>    const unsigned char* buffer,<br/>    unsigned int size,<br/>    unsigned int loopCounter)<br/>{<br/>    if (loopCounter == 0)<br/>        printBuffer(buffer, size);<br/>    return origEncodeFunc;<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_172"/>This function takes <code>buffer</code>, <code>size</code>, and <code>loopCounter</code> as parameters and returns the address of the function I dubbed <code>encode()</code>. Before fetching that address, however, the second part of my hook, a <code>myEncode()</code> function, does all of the dirty work to obtain <code>buffer</code>, <code>size</code>, and <code>loopCounter</code>, as follows:</p>&#13;
<pre>void __declspec(naked) myEncode()<br/>{<br/>    __asm {<br/>        MOV EAX, DWORD PTR SS:[ESP + 0x4]     // get buffer<br/>        MOV EDX, DWORD PTR DS:[ESI + 0x3C58]  // get full size<br/>        PUSH ECX           // store ecx<br/>        PUSH EDI           // push current pos (loop counter)<br/>        PUSH EDX           // push size<br/>        PUSH EAX           // push buffer<br/>        CALL reportEncode  // report the encode call<br/>        POP ECX            // restore ecx<br/>        JMP EAX            // jump to encode<br/>    }<br/>}</pre>&#13;
<p class="indent">The <code>myEncode()</code> function is a pure assembly function that replaces the original <code>encode()</code> function call using a near call hook. After storing ECX on the stack, <code>myEncode()</code> obtains <code>buffer</code>, <code>size</code>, and <code>loopCounter</code> and passes them to the <code>reportEncode()</code> function. After calling the <code>reportEncode()</code> function, the <code>myEncode()</code> function restores ECX and jumps directly into <code>encode()</code>, causing the original function to execute and return gracefully to the loop.</p>&#13;
<p class="indent">Since <code>myEncode()</code> cleans everything it uses from the stack, the stack still contains the original parameters and return address in the correct spot after <code>myEncode()</code> runs. That’s why <code>myEncode()</code> jumps directly into <code>encode()</code> instead of using a function call: that stack is already set up with the proper return address and parameters, so the <code>encode()</code> function will think everything happened as normal.</p>&#13;
<h4 class="h4" id="ch00lev1sec172"><strong><em>Hooking the RTMPS decode() Function</em></strong></h4>&#13;
<p class="noindent">The function I named <code>decode()</code>, which is used to decrypt incoming data, was also a <code>__thiscall</code> that was called in a loop. It worked on chunks of 4,096 bytes and took a buffer and size as parameters. The loop was quite a bit more complex, containing multiple function calls, nested loops, and loop escapes, but hooking worked much the same as hooking the so-called <code>encode()</code> function. The reason for the added complexity is not relevant to hooking the function, but it makes the code difficult to summarize, so I won’t show the original function here. The bottom line is this: once all the complexity was rubbed away, the <code>decode()</code> loop was the <code>encode()</code> loop in reverse.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_173"/>Once again, I devised a two-part near call hook. The first part, <code>reportDecode()</code>, is shown here:</p>&#13;
<pre>void __stdcall reportDecode(const unsigned char* buffer, unsigned int size)<br/>{<br/>    printBuffer(buffer, size);<br/>}</pre>&#13;
<p class="indent">The function logs each packet that comes through. I didn’t have a loop index at the time, so I decided that it was okay to log every single partial packet.</p>&#13;
<p class="indent">The second part of the hook, the <code>myDecode()</code> function, acts as the new callee and does all of the dirty work, as follows:</p>&#13;
<pre>   void __declspec(naked) myDecode()<br/>   {<br/>       __asm {<br/>           MOV EAX, DWORD PTR SS:[ESP + 0x4] // get buffer<br/>           MOV EDX, DWORD PTR SS:[ESP + 0x8] // get size<br/>           PUSH EDX                          // push size<br/>           PUSH EAX                          // push buffer<br/><span class="ent">➊</span>          CALL [origDecodeFunc]<br/><br/>           MOV EDX, DWORD PTR SS:[ESP + 0x4] // get the buffer<br/><br/>           PUSH EAX                          // store eax (return value)<br/>           PUSH ECX                          // store ecx<br/>           PUSH EAX                          // push size<br/>           PUSH EDX                          // push buffer<br/>           CALL reportDecode                 // report the results now<br/>           POP ECX                           // restore ecx<br/><span class="ent">➋</span>          POP EAX                           // restore eax (return value)<br/><span class="ent">➌</span>          RETN 8                            // return and clean stack<br/>       }<br/>   }</pre>&#13;
<p class="indent">I knew the buffer was decrypted in place, meaning the encrypted chunk would be overwritten with the decrypted one once the call to <code>decode()</code> was complete. This meant that <code>myDecode()</code> had to call the original <code>decode()</code> function <span class="ent">➊</span> before calling the <code>reportDecode()</code> function, which would give the results of the decoding. Ultimately, <code>myDecode()</code> also needed to return with the same value that the original <code>decode()</code> function would and clean up the stack, and the final <code>POP</code> <span class="ent">➋</span> and <code>RETN</code> <span class="ent">➌</span> instructions took care of that.</p>&#13;
<h4 class="h4" id="ch00lev1sec173"><strong><em>Placing the Hooks</em></strong></h4>&#13;
<p class="noindent">The next problem I ran into was that the hooks were for code inside the module <em>Adobe AIR.dll</em>, which was not the main module of the game. Because of the code’s location, I needed to find the base addresses for the hooks a bit differently. Additionally, since I needed these hooks to work across a few different versions of Adobe AIR, I also had to find the right addresses <span epub:type="pagebreak" id="page_174"/>for each version. Instead of trying to get my hands on all of the different versions of Adobe AIR, I took another page out of airlog’s playbook and decided to programmatically locate the addresses by writing a small memory scanner. Before I could write the memory scanner, I needed both the base address and size of <em>Adobe AIR.dll</em> so I could limit my memory search to only that area.</p>&#13;
<p class="indent">I found these values using <code>Module32First()</code> and <code>Module32Next()</code> as follows:</p>&#13;
<pre>   MODULEENTRY32 entry;<br/>   entry.dwSize = sizeof(MODULEENTRY32);<br/>   HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, NULL);<br/><br/>   DWORD base, size;<br/>   if (Module32First(snapshot, &amp;entry) == TRUE) {<br/><span class="ent">➊</span>      while (Module32Next(snapshot, &amp;entry) == TRUE) {<br/>           std::wstring binaryPath = entry.szModule;<br/><span class="ent">➋</span>          if (binaryPath.find("Adobe AIR.dll") != std::wstring::npos) {<br/>               size = (DWORD)entry.modBaseSize;<br/>               base = (DWORD)entry.modBaseAddr;<br/>               break;<br/>           }<br/>       }<br/>   }<br/><br/>   CloseHandle(snapshot);</pre>&#13;
<p class="indent">This code loops through all modules in the process until it finds <em>Adobe AIR.dll</em> <span class="ent">➊</span>. When it finds the correct module entry <span class="ent">➋</span>, it fetches the <code>modBaseSize</code> and <code>modBaseAddr</code> properties from it and breaks out immediately.</p>&#13;
<p class="indent">The next step was finding a sequence of bytes I could use to identify the functions. I decided to use the byte code surrounding each call. I also had to make sure that each sequence was unique while avoiding the use of any constants in the patterns to ensure the code’s portability. <a href="ch08.xhtml#ch8exe13">Listing 8-13</a> shows the byte sequences I ended up with.</p>&#13;
<pre>const char encodeSeq[16] = {<br/>    0x8B, 0xCE,                   // MOV ECX, ESI<br/>    0xE8, 0xA6, 0xFF, 0xFF, 0xFF, // CALL encode<br/>    0x83, 0xF8, 0xFF,             // CMP EAX, -1<br/>    0x74, 0x16,                   // JE SHORT endLoop<br/>    0x03, 0xF8,                   // ADD EDI, EAX<br/>    0x3B, 0xBE};                  // part of CMP EDI, [ESI+0x3C58]<br/>const char decodeSeq[12] = {<br/>    0x8B, 0xCE,                   // MOV ECX, ESI<br/>    0xE8, 0x7F, 0xF7, 0xFF, 0xFF, // CALL decode<br/>    0x83, 0xF8, 0xFF,             // CMP EAX, -1<br/>    0x89, 0x86};                  // part of MOV [ESI+0x1C54], EAX</pre>&#13;
<p class="listt"><a id="ch8exe13"/><em>Listing 8-13: The <code>encode()</code> and <code>decode()</code> byte sequences</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_175"/>Notice the <code>CALL</code> instruction in each pattern; these are the calls to the Adobe AIR functions I named <code>encode()</code> and <code>decode()</code>. I scanned for these sequences with the following function:</p>&#13;
<pre>DWORD findSequence(<br/>    DWORD base, DWORD size,<br/>    const char* sequence,<br/>    unsigned int seqLen){<br/>    for (DWORD adr = base; adr &lt;= base + size – seqLen; adr++) {<br/>        if (memcmp((LPVOID)sequence, (LPVOID)adr, seqLen) == 0)<br/>            return adr;<br/>    }<br/>    return 0;<br/>}</pre>&#13;
<p class="indent">Treating the memory of <em>Adobe AIR.dll</em> as a byte array, the <code>findSequence()</code> function looks for a sequence of bytes as a subset of that byte array and returns the address of the first match it finds. With the <code>findSequence()</code> function written, finding the addresses I needed to hook <code>encode()</code> and <code>decode()</code> was simple. Here’s how those calls looked:</p>&#13;
<pre>DWORD encodeHookAt =<br/>    findSequence(base, size, encodeSeq, 16) + 2;<br/>DWORD decodeHookAt =<br/>    findSequence(base, size, decodeSeq, 12) + 2;</pre>&#13;
<p class="indent">Since each target call was 2 bytes into its receptive search sequence, all I had to do was locate each sequence and add 2. After that, the final step was to place the hooks using the method described in “<a href="ch08.xhtml#ch00lev1sec152">Call Hooking</a>” on <a href="ch08.xhtml#page_153">page 153</a>.</p>&#13;
<p class="indent">With my hook finished, I could see every single piece of data that went between the game’s client and server. Moreover, since the RTMPS protocol sends serialized ActionScript objects, the data was basically self-documenting. Every single piece of information was accompanied by a variable name. Every variable existed as a member of a well-described object. Every object had a consistent name. Like I said—it was a gold mine.</p>&#13;
<h3 class="h3" id="ch00lev1sec174"><strong>Applying Jump Hooks and VF Hooks to Direct3D</strong></h3>&#13;
<p class="noindent">Unlike the Adobe AIR hook I just described, hooks for Direct3D (the 3D graphics component of Microsoft’s DirectX API) are very common and highly documented. Direct3D is ubiquitous in the world of gaming: a majority of PC games use the library, which means that hooking it gives you a very powerful method for intercepting data and manipulating the graphics layers of many different games. You can use a Direct3D hook for a number <span epub:type="pagebreak" id="page_176"/>of tasks, such as detecting locations of hidden enemy players, increasing the lighting of dark in-game environments, and seamlessly displaying additional graphical information. Making effective use of a Direct3D hook requires you to learn about the API, but there’s more than enough information in this book to get you started.</p>&#13;
<p class="indent">In this section, I’ll give you a high-level introduction to a game loop that uses Direct3D before diving right into the implementation of a Direct3D hook. Rather than detailing the internals and giving you the analytical backstory as I did with the Adobe AIR hook, I’ll go over the most popular Direct3D hook method, as it is well documented and used by the majority of game hackers.</p>&#13;
<p class="indent">The online resources for this book include two pieces of example code for this section; find those files now if you want to follow along. The first part, an example Direct3D 9 application for you to hack on, can be found under <em>GameHackingExamples/Chapter8_Direct3DApplication</em>. The second part, the actual hook, is under <em>Chapter8_Direct3DHook</em>.</p>&#13;
<p class="indent">There are multiple versions of Direct3D in use at any given time, and there are ways to hook each one. For this book, I’ll focus on hooking Direct3D 9, because it is the only commonly used version that is supported by Windows XP.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Even though XP has reached end of life, many people in less developed countries still use it as a primary gaming system. Direct3D 9 works on all versions of Windows and is nearly as powerful as its successors, so many game companies still prefer to use it over newer versions that don’t have as much backward compatibility.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec175"><strong><em>The Drawing Loop</em></strong></h4>&#13;
<p class="noindent">Let’s jump right in with a crash course on how Direct3D works. Inside a Direct3D game’s source code, you’ll find an infinite loop that processes input and renders graphics. Each iteration in this drawing loop is called a <em>frame</em>. If we cut out all the extraneous code and focus simply on a bare skeleton, we can visualize a game’s main loop with the following code:</p>&#13;
<pre>int WINAPI WinMain(args)<br/>{<br/>    /* Some code here would be called<br/>       to set up Direct3D and initialize<br/>       the game. Leaving it out for brevity. */<br/>    MSG msg;<br/>    while(TRUE) {<br/>        /* Some code would be here to handle incoming<br/>           mouse and keyboard messages. */<br/>        drawFrame(); // this is the function we care about<br/>    }<br/>    /* Some code here would be called to<br/>       clean up everything before exiting. */<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_177"/>This function is the entry point of the game. Simply put, it initializes the game and then enters the game’s main loop. Inside the main loop, it executes code responsible for processing user input before calling <code>drawFrame()</code> to redraw the screen using Direct3D. (Check out the code in <em>GameHackingExamples/Chapter8_Direct3DApplication</em> to see a fully functional game loop.)</p>&#13;
<p class="indent">Each time it is called, the <code>drawFrame()</code> function redraws the entire screen. The code looks something like this:</p>&#13;
<pre>   void drawFrame()<br/>   { <br/><span class="ent">➊</span>      device-&gt;Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);<br/>       device-&gt;BeginScene();<br/>       // drawing will happen here<br/>       device-&gt;EndScene();<br/>       device-&gt;Present(NULL, NULL, NULL, NULL);<br/>   }</pre>&#13;
<p class="indent">After clearing the screen with <code>device-&gt;Clear</code> <span class="ent">➊</span>, the <code>drawFrame()</code> function calls <code>device-&gt;BeginScene()</code> to unlock the scene for drawing. It then executes some drawing code (what that drawing code actually does isn’t important right now) and locks the scene with a <code>device-&gt;EndScene()</code> call. To finish up, it renders the scene to the screen by calling the <code>device-&gt;Present()</code> function.</p>&#13;
<p class="indentb">Notice that all of these functions are called as members of some instance called <code>device</code>. This is simply an object instance representing the Direct3D device, which is used to invoke all sorts of drawing calls. Also, notice that this function is devoid of any actual drawing code, but that’s okay. It’s really only important for you to understand the high-level concepts of drawing loops, frames, and the Direct3D device. To recap, games have a main loop with two responsibilities:</p>&#13;
<p class="bull">• Handling incoming messages</p>&#13;
<p class="bull">• Drawing the game to the screen</p>&#13;
<p class="indentt">Each iteration in this loop is called a frame, and each frame is drawn by a device. Taking control of the device gives you access to the most sensitive and descriptive details of the game’s state; that is, you’ll be able to peek into the game’s state after the data has been parsed, processed, and rendered to the screen. Moreover, you’ll be able to modify the output of this state. These two superpowers enable you to pull off all kinds of awesome hacks.</p>&#13;
<h4 class="h4" id="ch00lev1sec176"><strong><em>Finding the Direct3D Device</em></strong></h4>&#13;
<p class="noindent">To take control of a Direct3D device, you hook the member functions in the device’s VF table. Unfortunately, however, using the Direct3D API to instantiate your own instance of the same <code>device</code> class from injected code doesn’t mean you’ll share a VF table with the game’s instance. Direct3D devices use <span epub:type="pagebreak" id="page_178"/>a customized runtime implementation of VF tables, and each device gets its own unique VF table. Additionally, devices sometimes rewrite their own VF tables, removing any hooks and restoring the original function addresses.</p>&#13;
<p class="indent">Both of these Direct3D quirks leave you with one inevitable option: you must find the address of the game’s device and modify its VF table directly. Here’s how:</p>&#13;
<ol>&#13;
<li><p class="noindenta">Create a Direct3D device and traverse its VF table to locate the true address of <code>EndScene()</code>.</p></li>&#13;
<li><p class="noindenta">Place a temporary jump hook on <code>EndScene()</code>.</p></li>&#13;
<li><p class="noindenta">When the jump hook callback is executed, store the address of the device that was used to call the function, remove the hook, and restore execution normally.</p></li>&#13;
<li><p class="noindenta">From there, use VF hooks to hook any member function of the Direct3D device.</p></li>&#13;
</ol>&#13;
<h5 class="h5" id="ch00lev1sec177"><strong>Jump Hooking EndScene()</strong></h5>&#13;
<p class="noindent">Since every device will call <code>EndScene()</code> at the end of each frame, you can hook <code>EndScene()</code> using a jump hook and intercept the game’s device from your hook callback. Unique devices may have their own unique VF tables, but the different tables still point to the same functions, so you can find the address of <code>EndScene()</code> in the VF table of any arbitrary device. Using standard Direct3D API calls, you can create your own device like this:</p>&#13;
<pre>LPDIRECT3D9 pD3D = Direct3DCreate9(D3D_SDK_VERSION);<br/>if (!pD3D) return 0;<br/><br/>D3DPRESENT_PARAMETERS d3dpp;<br/>ZeroMemory( &amp;d3dpp, sizeof(d3dpp) );<br/>d3dpp.Windowed = TRUE;<br/>d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;<br/>d3dpp.hDeviceWindow = hWnd;<br/><br/>LPDIRECT3DDEVICE9 device;<br/>HRESULT res = pD3D-&gt;CreateDevice(<br/>    D3DADAPTER_DEFAULT,<br/>    D3DDEVTYPE_HAL,<br/>    hWnd,<br/>    D3DCREATE_SOFTWARE_VERTEXPROCESSING,<br/>    &amp;d3dpp, &amp;device);<br/>if (FAILED(res)) return 0;</pre>&#13;
<p class="indent">Explaining how everything in Direct3D works is outside the scope of this book, so just know that you can copy this code to create a Direct3D device that contains the <code>EndScene()</code> function as a member. The <code>EndScene()</code> address is at index <code>42</code> in the VF table of <code>device</code> (see “The Meaning of Device, <span epub:type="pagebreak" id="page_179"/>Direct3D, and VF Hooks” box to learn how to find that index), and you can read it using a subset of the VF table hooking code from “<a href="ch08.xhtml#ch00lev1sec159">Using a VF Table Hook</a>” on <a href="ch08.xhtml#page_159">page 159</a>, as follows:</p>&#13;
<pre>DWORD getVF(DWORD classInst, DWORD funcIndex)<br/>{<br/>    DWORD VFTable = readMemory&lt;DWORD&gt;(classInst);<br/>    DWORD hookAddress = VFTable + funcIndex * sizeof(DWORD);<br/>    return readMemory&lt;DWORD&gt;(hookAddress);<br/>}<br/>DWORD EndSceneAddress = getVF((DWORD)device, 42);</pre>&#13;
<p class="indent">Once you’ve obtained the address, your discovery device has served its purpose, and it can be destroyed with a call to the <code>Release()</code> function:</p>&#13;
<pre>pD3D-&gt;Release();<br/>device-&gt;Release();</pre>&#13;
<p class="indent">With the address of <code>EndScene()</code> in hand, you’d be ready to start thinking about how to place your hook in memory. But since you just have a function address, your only option is to place a jump hook at the top of the function.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>THE MEANING OF DEVICE, DIRECT3D, AND VF HOOKS</strong></p>&#13;
<p class="noindent">If you’re wondering how I know that the index of the <code>EndScene()</code> function is <code>42</code>, you’ve come to the right box. Since Direct3D 9 is a freely available library, you can actually see quite a bit of what goes on under the hood. The main header file for the library is <em>d3d9.h</em>. If you open this file in your editor and search for “EndScene,” you’ll end up in the middle of a large class definition that specifies several functions using C macros. This is the base class for all Direct3D 9 <code>device</code> implementations, and it defines the virtual functions used by the class.</p>&#13;
<p class="indent">The VF table is constructed in the same order as the functions are defined in code, so you can determine the index of any member function by simply counting the lines. You can scroll to the top of the class definition (at line 426 in my version of the library, and probably yours too), note the line where the first function is declared (line 429), and then scroll to the <code>EndScene()</code> definition and note that line (line 473). Finally, count the number of blank or commented lines (two for me) and do some math: 473 – 429 – 2 = 42.</p>&#13;
<p class="indent">Presto! The <code>EndScene()</code> function is the 43rd function declared, so it sits at the 42nd spot in the VF table. Another advantage to having this header is that you can see the name, argument types, argument names, and return type of every single function in the device class. So when you’re writing your own hooks in the future, you’ll know exactly where to look.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec178"><span epub:type="pagebreak" id="page_180"/><strong>Placing and Removing the Jump Hook</strong></h5>&#13;
<p class="noindent">Since you’re just using the hook to find the device, you need to call it only once. After obtaining the device, you’ll remove the jump hook and restore execution back to the start of <code>EndScene()</code> so that the drawing loop can carry on its work. Believe it or not, this makes your life much easier. Since the code will be restored immediately, there’s no need for your trampoline to execute the commands that are replaced by the jump, and there’s no need to pad the jump with NOPs. All you need to do is store the original bytes and place the hook. To do so, you use a slightly tweaked version of the jump-hooking code from <a href="ch08.xhtml#ch8exe11">Listing 8-11</a>:</p>&#13;
<pre>   unsigned char* hookWithJump(DWORD hookAt, DWORD newFunc)<br/>   {<br/>       DWORD newOffset = newFunc - hookAt - 5;<br/><span class="ent">➊</span>      auto oldProtection = protectMemory&lt;BYTE[5]&gt;(hookAt, PAGE_EXECUTE_READWRITE);<br/>       unsigned char* originals = new unsigned char[5];<br/>       for (int i = 0; i &lt; 5; i++)<br/><span class="ent">➋</span>          originals[i] = readMemory&lt;unsigned char&gt;(hookAt + i);<br/><span class="ent">➌</span>      writeMemory&lt;BYTE&gt;(hookAt, 0xE9);<br/>       writeMemory&lt;DWORD&gt;(hookAt + 1, newOffset);<br/>       protectMemory&lt;BYTE[5]&gt;(hookAt, oldProtection);<br/>       return originals;<br/>   }</pre>&#13;
<p class="indent">Like the function in <a href="ch08.xhtml#ch8exe11">Listing 8-11</a>, this function makes the memory writable <span class="ent">➊</span>, places the hook <span class="ent">➌</span>, and restores the memory protection. Before placing the hook, it allocates a 5-byte buffer called <code>originals</code> <span class="ent">➋</span> and fills it with the original bytes. After the hook is placed, it returns <code>originals</code> to the calling function.</p>&#13;
<p class="indent">When it’s time to remove the hook, pass <code>originals</code> to the following function:</p>&#13;
<pre>void unhookWithJump(DWORD hookAt, unsigned char* originals)<br/>{<br/>    auto oldProtection = protectMemory&lt;BYTE[5]&gt;(hookAt, PAGE_EXECUTE_READWRITE);<br/>    for (int i = 0; i &lt; 5; i++)<br/>        writeMemory&lt;BYTE&gt;(hookAt + i, originals[i]);<br/>    protectMemory&lt;BYTE[5]&gt;(hookAt, oldProtection);<br/>    delete [] originals;<br/>}</pre>&#13;
<p class="indent">This code simply iterates over <code>originals</code> and quietly places those 5 bytes back where they were found so that everything is as expected when execution returns to the <code>EndScene()</code> function. When the time comes, you can place and remove your actual hook using two lines of code, like this:</p>&#13;
<pre>auto originals = hookWithJump(EndSceneAddress, (DWORD)&amp;endSceneTrampoline);<br/>unhookWithJump(EndSceneAddress, originals);</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_181"/>Once you have the <code>hookWithJump()</code> and <code>unhookWithJump()</code> functions, it’s time to prepare the callback and find the device.</p>&#13;
<h5 class="h5" id="ch00lev1sec179"><strong>Writing the Callback and Trampoline</strong></h5>&#13;
<p class="noindent">Even though you can obtain the <code>EndScene()</code> address from a VF table, the <code>EndScene()</code> function doesn’t actually follow the <code>__thiscall</code> convention. Direct3D classes are simple wrappers around a C API, and all of the member function calls are forwarded to <code>__stdcall</code> functions that take a class instance as a first parameter. This means that your trampoline only needs to grab the device from the stack, pass it to the callback, and then jump back to <code>EndScene()</code>. The callback only has to remove the jump hook before returning to the trampoline.</p>&#13;
<p class="indent">The final code for the callback and trampoline to this jump hook looks something like this:</p>&#13;
<pre>   LPDIRECT3DDEVICE9 discoveredDevice;<br/>   DWORD __stdcall reportInitEndScene(LPDIRECT3DDEVICE9 device)<br/>   {<br/>       discoveredDevice = device;<br/>       unhookWithJump(EndSceneAddress, originals);<br/>       return EndSceneAddress;<br/>   }<br/>   __declspec(naked) void endSceneTrampoline()<br/>   {<br/>       __asm {<br/>           MOV EAX, DWORD PTR SS:[ESP + 0x4]<br/>           PUSH EAX  // give the device to the callback<br/><span class="ent">➊</span>          CALL reportInitEndScene<br/>           JMP EAX   // jump to the start of EndScene<br/>       }<br/>   }</pre>&#13;
<p class="indent">Using the <code>hookWithJump()</code> function, you can place a jump hook on <code>EndScene()</code> that calls the <code>endSceneTrampoline()</code> function. When the game’s device calls the <code>EndScene()</code> function, the trampoline function calls the <code>reportInitEndScene()</code> function <span class="ent">➊</span>. The <code>reportInitEndScene()</code> function stores the captured device pointer to a global variable called <code>discoveredDevice</code>, removes the hook by calling <code>unhookWithJump()</code>, and returns the address of <code>EndScene()</code> to the trampoline. To finish up, the trampoline jumps directly to EAX, which will be holding the address that was returned from the reporting function.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can use jump hooks to completely skip the VF table hooking that I’ll show you, but it’s very unreliable to use “dumb” jump hooks on commonly hooked API functions. Consistently obtaining good results with only jump hooks requires professional hooking libraries, and I’d rather teach you how to do it completely on your own.</em></p>&#13;
</div>&#13;
<p class="indent">At this point, all that’s left to do is hook the VF table of <code>discoveredDevice</code> to hack the game. The next two sections will walk you through hooks on the <code>EndScene()</code> and <code>Reset()</code> functions, which are required if you want a stable hook.</p>&#13;
<h4 class="h4" id="ch00lev1sec180"><span epub:type="pagebreak" id="page_182"/><strong><em>Writing a Hook for EndScene()</em></strong></h4>&#13;
<p class="noindent">A hook on <code>EndScene()</code> is useful because it allows you to intercept a completed frame just before it is rendered; you can effectively execute your own rendering code inside the game loop. As you saw when locating this function’s address in “<a href="ch08.xhtml#ch00lev1sec177">Jump Hooking <code>EndScene()</code></a>” on <a href="ch08.xhtml#page_178">page 178</a>, this function is at index <code>42</code> in the VF table. You can hook <code>EndScene()</code> using a VF hook as follows:</p>&#13;
<pre>typedef HRESULT (WINAPI* _endScene)(LPDIRECT3DDEVICE9 pDevice);<br/>_endScene origEndScene =<br/>    (_endScene)hookVF((DWORD)discoveredDevice, 42,(DWORD)&amp;myEndScene);<br/>HRESULT WINAPI myEndScene(LPDIRECT3DDEVICE9 pDevice)<br/>{<br/>    // draw your own stuff here<br/>    return origEndScene(pDevice);<br/>}</pre>&#13;
<p class="indent">This code uses the <code>hookVF()</code> function from “<a href="ch08.xhtml#ch00lev1sec159">Using a VF Table Hook</a>” on <a href="ch08.xhtml#page_159">page 159</a> to hook <code>EndScene()</code> at index <code>42</code> of <code>discoveredDevice</code>, using <code>myEndScene()</code> as the callback function. A direct Direct3D device will occasionally repatch its own VF table and restore the original function addresses. This typically happens from within the <code>EndScene()</code> function, meaning you also have to repatch the VF table after calling the original <code>EndScene()</code> function. There are a few changes you can make to this hook to handle that, as shown in <a href="ch08.xhtml#ch8exe14">Listing 8-14</a>.</p>&#13;
<pre>_endScene origEndScene = NULL;<br/>void placeHooks()<br/>{<br/>    auto ret = hookVF((DWORD)discoveredDevice, 42, (DWORD)&amp;myEndScene);<br/>    if (ret != (DWORD)&amp;myEndScene) // don't point to your hook<br/>        origEndScene = (_endScene)ret;<br/>}<br/>placeHooks();<br/><br/>HRESULT WINAPI myEndScene(LPDIRECT3DDEVICE9 pDevice)<br/>{<br/>    // draw your own stuff here<br/>    auto ret = origEndScene(pDevice);<br/>    placeHooks(); // update hooks<br/>    return ret;<br/>}</pre>&#13;
<p class="listt"><a id="ch8exe14"/><em>Listing 8-14: Final code to hook <code>EndScene()</code></em></p>&#13;
<p class="indent">The code to place the hook has been moved into a function called <code>placeHooks()</code> so it can be called multiple times with ease. The callback function still forwards the call to the original function, but it makes sure to call <code>placeHooks()</code> before returning. This ensures that the hook is always active, even if the original <code>EndScene()</code> function removes it.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_183"/>Another point to notice is that <code>placeHooks()</code> updates the address of <code>origEndScene()</code> every time the hook is replaced, as long as the address returned from <code>hookVF()</code> isn’t the address of the <code>myEndScene()</code> function. This does two distinct things. First, it allows other applications to hook <code>EndScene()</code> without stepping on their toes, since it will update <code>origEndScene()</code> to whatever is seen in the VF table. Second, it makes sure that the value of <code>origEndScene()</code> can never be the address of our callback, preventing a potential infinite loop. An infinite loop is possible otherwise, because <code>origEndScene()</code> doesn’t always fix the device’s VF table, meaning <code>placeHooks()</code> can be called when the VF table still contains the <code>myEndScene()</code> function.</p>&#13;
<h4 class="h4" id="ch00lev1sec181"><strong><em>Writing a Hook for Reset()</em></strong></h4>&#13;
<p class="noindent">When you’re using a Direct3D hook in production, you’ll be doing all kinds of tasks like drawing custom text, displaying images related to your bot, and interacting with function calls from the game. These tasks will require you to create your own Direct3D objects that are tied to the game’s device, and that can be a problem. From time to time, the game may completely reset its device through a <code>Reset()</code> function. When a device is reset, you’ll need to update any objects (most commonly fonts and sprites) that you’ve created for the device, using their <code>OnLostDevice()</code> member functions.</p>&#13;
<p class="indent">Since <code>Reset()</code> is called from the VF table of the device, you can use a hook on it to tell you when the device has been reset. <code>Reset()</code> takes two parameters and is at index <code>16</code> in the VF table. You can add this code to <code>placeHooks()</code> in <a href="ch08.xhtml#ch8exe14">Listing 8-14</a> to hook the <code>Reset()</code> function:</p>&#13;
<pre>auto ret = hookVF((DWORD)discoveredDevice, 16, (DWORD)&amp;myReset);<br/>if (ret != (DWORD)&amp;myReset)<br/>    origReset = (_reset)ret;</pre>&#13;
<p class="indent">And this is the declaration to use for <code>origReset</code>:</p>&#13;
<pre>typedef HRESULT (WINAPI* _reset)(<br/>    LPDIRECT3DDEVICE9 pDevice,<br/>    D3DPRESENT_PARAMETERS* pPresentationParameters);<br/>_reset origReset = NULL;</pre>&#13;
<p class="indent">When a reset is successful, the original function returns <code>D3D_OK</code>. Your hook function recognizes this and calls <code>OnLostDevice()</code> accordingly:</p>&#13;
<pre>HRESULT WINAPI myReset(<br/>    LPDIRECT3DDEVICE9 pDevice,<br/>    D3DPRESENT_PARAMETERS* pPresentationParameters)<br/>{<br/>    auto result = origReset(pDevice, pPresentationParameters);<br/>    if (result == D3D_OK) {<br/>        // call onLostDevice() for all of your objects<br/>    }<br/>    return result;<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_184"/>Once you fill in the contents of the <code>if()</code> statement, all of your objects are ready to use again.</p>&#13;
<h4 class="h4" id="ch00lev1sec182"><strong><em>What’s Next?</em></strong></h4>&#13;
<p class="noindent">Now that I’ve shown you how to take control of a game’s Direct3D device, you’re probably wondering what you can do with it. Unlike the other examples in the book, the code in this section and the example code don’t have a one-to-one correlation, but the functionality is still the same. Here’s a high-level view of the correlation between this chapter and the code in the <em>Chapter8_Direct3DHook</em> example project.</p>&#13;
<p class="indent">The file <em>DirectXHookCallbacks.h</em> contains the callbacks for the <code>EndScene()</code> and <code>Reset()</code> functions, two callbacks for other common functions, and the trampoline and reporter functions for the temporary jump hook. These functions are all pretty much as described in this chapter, except they call into a singleton class defined in <em>DirectXHook.h</em> and <em>DirectXHook.cpp</em>. This singleton class is responsible for forwarding the calls to the original functions.</p>&#13;
<p class="indent">The class is also responsible for all of the heavy lifting, and it contains the code to create the discovery device, place the hooks, draw text, handle device resets, and display images. Furthermore, it allows external code to add custom callbacks for each hook, as you can see in <em>main.cpp</em>. Here, you’ll see a number of different callbacks that are drawing custom text, adding new images to the screen, and changing the textures of models that are drawn by the game. I recommend poking around in the code to get a better understanding of what’s going on, but don’t get too carried away. We’ll dive into this code in <a href="ch09.xhtml#ch09">Chapter 9</a> to talk about all the cool hacks it can do.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>OPTIONAL FIXES FOR STABILITY</strong></p>&#13;
<p class="noindent">The <code>Reset()</code> and <code>EndScene()</code> hooks described in this chapter should work well for any game running Direct3D 9, but it is slightly unstable. If the game tries to execute <code>EndScene()</code> when the jump hook is placed, it will crash because the bytes are being modified. There are two ways to fix this. First, you can place the jump hook from within an IAT hook on <code>PeekMessage()</code>. This will work because placing an IAT hook is a thread-safe operation, but it assumes that <code>PeekMessage()</code> is called only from the same thread that does the Direct3D drawing.</p>&#13;
<p class="indent">A safer, but more complex, alternative is to iterate over every thread in the game (similar to how it worked for thread hijacking) and use <code>SuspendThread()</code> to pause all threads in the game (except for the one placing the hook, of course). Before pausing a thread, you must make sure its <code>EIP</code> is not executing the first 5 bytes of <code>EndScene()</code>. After the hook is placed, you must use <code>ResumeThread()</code> to restore execution with your hook in place.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec183"><span epub:type="pagebreak" id="page_185"/><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">Control flow manipulation is a very important skill in game hacking, and a lot of the hacks in this book rely on it. Throughout the next two chapters you’ll learn how to create common hacks using the Direct3D hook, and you’ll get a better idea of the general use cases of hooking. Even if you feel a little shaky, continue to <a href="ch09.xhtml#ch09">Chapter 9</a>. The code examples there center on the Direct3D hook and will get you even more familiar with hooking techniques.<span epub:type="pagebreak" id="page_186"/></p>&#13;
</body></html>