- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SPECIAL IMAGE ACCESS TOPICS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter demonstrates techniques for getting information about disk image
    files and making them accessible as block devices and as mounted directories.
    You’ll learn to set up loop devices and create logical devices with device mapper
    tools. You’ll also explore methods to map or convert software-encrypted disk images,
    making them accessible by forensic tools. These methods are useful in situations
    in which the contents of an image cannot be accessed directly and a layer of active
    translation or decryption is needed. Examples of such images include encrypted
    filesystems, virtual machine (VM) images, and other image file formats that forensic
    tools do not directly support.
  prefs: []
  type: TYPE_NORMAL
- en: Each section also includes examples of safely mounting (read-only) image files
    as regular filesystems on the forensic acquisition host. Then you can easily browse
    and access the filesystem using common programs, such as file managers, office
    suites, file viewers, media players, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Forensically Acquired Image Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basis for many of the methods and examples you’ll see in this section is
    the Linux loop device (not to be confused with a loopback device, which is a network
    interface). A *loop device* is a pseudo device that can be associated with a regular
    file, making the file accessible as a block device in */dev*.
  prefs: []
  type: TYPE_NORMAL
- en: Linux systems typically create eight loop devices by default, which might not
    be enough for a forensic acquisition host, but you can increase that number, either
    manually or automatically, on boot up. To create 32 loop devices during boot up,
    add `max_loop=32` to the `GRUB_CMDLINE_LINUX_DEFAULT=` line in the */etc/default/grub*
    file; after reboot, 32 unused loop devices should be available. The sfsimage script
    uses loop devices to mount SquashFS forensic evidence containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover different VM images from common VM systems from QEMU,
    VirtualBox, VMWare, and Microsoft Virtual PC. I also describe access to OS-encrypted
    filesystems, including Microsoft’s BitLocker, Apple’s FileVault, Linux LUKS, and
    VeraCrypt (a fork of TrueCrypt). But let’s begin the with the simplest form of
    image: a raw disk image acquired using a dd-style acquisition tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Raw Image Files with Loop Devices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simplest demonstration of a loop device can be shown using a raw image
    file (possibly acquired from a simple `dd` command). The `losetup` command attaches
    and detaches loop devices from a Linux system. This example creates a block device
    for an *image.raw* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the flags specify that the loop should be read-only (`--read-only`) and
    the next available loop device should be used (`--find`) and displayed on completion
    (`--show`). The filename specified (*image.raw*) will then become available as
    an attached block device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `losetup` command without parameters displays the status of all
    configured loop devices. Here we can see the one just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The */dev/loop0* device now points to */exam/image.raw*, and you can access
    it with any tools that operate on block devices. For example, here the Sleuth
    Kit `mmls` command is able to see the partition table on the *image.raw* file
    using the loop device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you no longer need a loop device, simply detach it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Loop devices are flexible and configurable. In the previous mmls example, a
    filesystem starts at sector 2048\. It’s possible to specify an offset each time
    you run a forensic tool, but it’s easier to have a separate device for each partition
    (similar to */dev/sda1* for example). You can create a separate loop device with
    the `losetup` command just for that partition by specifying the correct offset
    flag (`--offset`) and size flag (`--sizelimit`). However, a more commonly accepted
    way is to use the device mapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do this manually using dmsetup and mapping tables as described in
    “[RAID and Multidisk Systems](ch06.xhtml#ch06lev1sec07)” on [page 178](ch06.xhtml#page_178).
    However, the kpartx tool automates the creation of partition devices for a particular
    image file. A forensically acquired image with four partitions is used in the
    following example to demonstrate the kpartx tool making mapper devices for each
    partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the kpartx tool reads the partition table on a disk or image file, creates
    a loop device for the whole image, and then creates mapper devices for each partition.
    The `-r` flag ensures the drive loop and partition mappings are read-only, and
    the `-a` flag instructs kpartx to map everything it finds. Use the verbose flag
    `-v` to document the command output and to indicate what was just mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, a loop device is created (*/dev/loop0*) for the whole image
    file and is accessible as a raw block device. In addition, partition devices are
    now available in the */dev/mapper* directory, and you can access them using forensic
    tools that operate on partitions, without specifying any offsets. Here are a few
    example Sleuth Kit commands for some of the partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A filesystem mapped to a device from an image file can be safely mounted as
    read-only. This will allow you access it with a standard file manager, applications,
    and other file-analysis tools. You can mount and unmount loop partitions, as shown
    in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, a directory, *p3*, representing the partition was created in the same
    directory as the raw image. Then *p3* was used as the mount point (the chosen
    mount point can be anywhere on the examiner host filesystem). Midnight Commander
    (`mc`) is a text-based file manager (a Norton Commander clone) and is used in
    this example to review the files on the mounted partition. When the mount point
    is no longer needed, the `umount` command (this command is spelled correctly with
    only one *n*) unmounts the filesystem, and rmdir removes the mount point directory.
    This is the traditional Unix way to mount and unmount a filesystem on a host system.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you no longer need the drive loop and partition mappings, you can remove
    them all by using the kpartx delete (`-d`) flag and the name of the image file,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that this “delete” has no effect on the disk image’s contents. The loop
    and mappings are deleted, not the drive image, and the drive image is not modified.
  prefs: []
  type: TYPE_NORMAL
- en: If a raw image has a corrupt or overwritten partition table, you can scan the
    image for filesystems and use dmsetup to manually map filesystems as devices (using
    dmsetup tables).
  prefs: []
  type: TYPE_NORMAL
- en: When you create, mount, unmount, or detach a loop device, root privileges are
    required. They’re also required for operating on the */dev/loopX* device with
    forensic tools. The examples shown in this section were run as the root user to
    reduce the complexity of the command lines, making them easier to understand.
    Prefixing the commands with `sudo` can be used to run privileged commands as a
    non-root user.
  prefs: []
  type: TYPE_NORMAL
- en: '***Forensic Format Image Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ewflib software package includes a tool called ewfmount to “mount” the contents
    of a forensic image, making it accessible as a regular raw image file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a group of **.e01* files. A mount point, `raw`
    in this example, is created with `mkdir` and will contain the raw image file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The ewfmount tool creates a FUSE filesystem containing a virtual raw image
    from one or more EWF files. You can run `ewfmount` command with the first of the
    EnCase EWF files and the mount point to access a raw image file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then operate on this virtual raw image file using tools that don’t
    support EWF formats directly. In the following example, a hex editor (without
    EWF support) is used in sector mode to analyze the raw image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The kpartx tool is again useful to identify partitions and create corresponding
    loop devices, enabling the use of tools that can operate on block devices and
    allowing the mounting of the filesystems for regular browsing. The kpartx output
    of the **.e01* files mounted with ewfmount is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s continue using this example to create a mount point for a partition and
    mount and access a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a mount point corresponding to the partition is created in
    the local directory, the partition device is mounted on it, and the file-system
    is accessed with `ls`. If possible, avoid the use of */mnt* or other shared mount
    directories when mounting evidence files and containers. It is easier to perform
    forensic work when the mount points for an image are in the same working directory
    as other related case files.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, when the work is completed, you need to clean up the mounts and
    virtual files. Again, this is done in the reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `fusermount` command is shown in this example, but the standard Linux `umount`
    command would also work. Make sure your current working directory is not inside
    the mount point and that no programs have open files inside the mount points.
    Both conditions will cause these cleanup steps to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using SquashFS forensic evidence containers, you can access the raw image
    by mounting the **.sfs* file with `sfsimage -m`, creating the partition devices,
    and then mounting the desired partition. You can then execute regular commands
    on the subject image’s filesystem. A complete example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are finished accessing the raw image and its filesystems, clean up
    with SquashFS forensic evidence containers is also done in reverse. The `sfsimage
    -u` command unmounts a SquashFS filesytem as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This section has demonstrated several methods for accessing the contents of
    forensic formats, both as block devices and as regular filesystems. The ewfmount
    tool also works with FTK SMART files. Afflib has a similar tool called affuse
    for mounting **.aff* files. Both ewfmount and affuse can operate on single or
    split files of their respective formats.
  prefs: []
  type: TYPE_NORMAL
- en: Note that many forensic tools (Sleuth Kit, for example) are able to operate
    directly on forensic formats without the need for a raw block device or raw file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Prepare Boot Images with xmount***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Forensic investigators often want to examine a subject drive image with nonforensic
    tools, such file managers, office suites, applications, or other file viewer tools.
    This can be done by making the drive contents safely available over a read-only
    mount for the local examiner machine to access.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it is useful to boot a subject drive in a VM to observe and interact
    directly with the live subject environment. This allows you to view the subject’s
    desktop and use the installed programs of the subject PC. To do this, you can
    use a number of tools described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The xmount (pronounced “crossmount”) tool creates a virtual disk image that
    you can boot using VM software, such as VirtualBox or kvmqemu. The xmount tool
    allows you to simulate a read-write drive, making the VM think the disk is writable,
    but it continues to protect the image in a read-only state. Multiple VM output
    formats are available, including raw, DMG, VDI, VHD, VMDK, and VMDKS.
  prefs: []
  type: TYPE_NORMAL
- en: The input formats include forensically acquired image files, such as **.raw*,
    EnCase **.ewf*, and AFFlib **.aff* files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a raw image (*image.raw*) set up with xmount as a VirtualBox
    **.vdi* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the directory *virtual* is created to hold the virtual image
    file (it will be FUSE mounted). From an existing *image.raw* file, the `xmount`
    command creates a write-cached VirtualBox VDI image in the *./virtual* directory.
    This is just a virtual representation of the image file; it is not copied or converted
    (thus not wasting disk space on the examiner machine). The `--in` and `--out`
    flags specify the image format used. The input formats must be raw, AFF, or EWF.
    Multiple output formats are possible.
  prefs: []
  type: TYPE_NORMAL
- en: Booting an OS image in a VM can be challenging when the installed OS is expecting
    a different hardware configuration than provided by the VM. Typically, this is
    less of an issue with Linux installations but can be problematic with Windows
    and OS X. To solve this problem, two tools, opengates and openjobs, were created
    to prepare Windows and OS X images for safely booting subject disks in a virtual
    environment. I won’t cover how to use opengates and openjobs, but you can find
    more information about them at *[https://www.pinguin.lu/openjobs/](https://www.pinguin.lu/openjobs/)*
    and *[https://www.pinguin.lu/opengates/](https://www.pinguin.lu/opengates/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you no longer need the VM image, you can clean up by unmounting the virtual
    image and removing the mount point directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A *xmount.cache* file containing data written during the use of the VM might
    exist. You can save the file if you need to continue the previous VM session,
    or you can remove it.
  prefs: []
  type: TYPE_NORMAL
- en: '**VM Images**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the increasing performance of home computers, hardware virtualization in
    most modern CPUs, and the availability of inexpensive or free virtualization software,
    there is an increased need to analyze the contents of VM images. In some cases,
    you might find many VM images on subject PCs. This section focuses on accessing
    common VM image file types such as QCOW2, VDI, VMDK, and VHD.
  prefs: []
  type: TYPE_NORMAL
- en: '***QEMU QCOW2***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The QCOW2 format is a common VM image type found on Linux and used by the QEMU
    emulator. In this section, I’ll make a QCOW2 image available as a block device
    and safely mount it for browsing.
  prefs: []
  type: TYPE_NORMAL
- en: The libqcow-utils package (written by Joachim Metz, author of ewflib) contains
    the qcowinfo and qcowmount tools. You can use both tools in the same way as you
    used the ewfinfo and ewfmount tools in previous examples. But the following example
    shows an alternative method using the `qemu-img` command, the nbd kernel module,
    and the qemu-nbd tool. This method offers performance advantages because it operates
    in the kernel and saves you a few steps because you don’t need to use kpartx.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a **.qcow2* file, the `qemu-img` command can provide a summary of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To access a QCOW image in a raw image representation with nbd, you need to
    load the nbd kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike with the `losetup` command, the device is not automatically chosen.
    A */dev/nbd** device needs to be specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the QCOW2 image file was connected to the kernel module in read-only
    mode, and the partition device was automatically detected. You can use this raw
    device with forensic tools, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The partition devices (the raw device name with `p1` in this example) are also
    ready for you to use directly with forensic tools. To illustrate, here’s the `fls`
    command operating directly on a filesystem on the partition device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Mounting the devices locally for browsing is trivial. A local mount point directory
    is created, and the filesystem is mounted normally, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The cleanup here is similar to the examples using loop devices, but with fewer
    steps. All processes should close files, and you should leave the mounted directory
    so it can be unmounted. A `qemu-nbd disconnect` command specifying the device
    name will unregister the device from the kernel, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: An optional step is to remove the kernel module using `rmmod nbd`. But there
    is no harm in leaving it in if you’ll be doing more QCOW mounts. You can also
    autoload the nbd module at boot by adding it to the */etc/modules* file.
  prefs: []
  type: TYPE_NORMAL
- en: '***VirtualBox VDI***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: VirtualBox is an open source project maintained by Oracle (formerly Sun Microsystems).
    Although it supports multiple VM image formats, VirtualBox VDI images are used
    in the examples that follow. The same `qemu-nbd` command is used as before but
    with an OpenSolaris image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The VirtualBox software package includes a number of utilities; the VBoxManage
    tool is shown here, providing information about the VDI image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can mount VirtualBox images using `qemu-nbd` and the nbd kernel module
    (as you saw in the previous section using QCOW2). The Open-Solaris example shown
    here is slightly different from the partitioning scheme Windows and Linux use.
    Multiple disk slices^([1](footnote.xhtml#fn42)) are also shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a single Solaris partition (`p1`) contains multiple slices
    (`p5`, `p6`, `p7`, and `p8`).
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same methods as in the previous QEMU example to access the raw
    and partition devices, then mount the partitions as read-only to a local mount
    point. Here again, you don’t need to use kpartx to find the partitions, because
    the kernel does it automatically. Once you are finished accessing the partitions
    (or slices, here), perform the cleanup steps to unmount filesystems and disconnect
    the nbd device.
  prefs: []
  type: TYPE_NORMAL
- en: '***VMWare VMDK***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *Virtual Machine DisK (VMDK)* format is used by VMWare’s VM software products.
    The following example uses the libvmdk-utils software package on an Apple Lion
    VMDK image split into multiple parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve information about the assembled image and each of the “Extents”
    using `vmdkinfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a mount point and mounting the image makes it accessible as a raw
    image file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using kpartx, as shown earlier in the chapter, will create the associated disk
    and partition block devices. You can then use forensic analysis tools on them
    directly or mount them on the local machine to browse the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '***Microsoft VHD***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number of methods help you make the Microsoft VHD virtual image format accessible.
    For example, you can use the qemu-nbd method or use the libvhdi-utils with vhdiinfo
    and vhdimount.
  prefs: []
  type: TYPE_NORMAL
- en: A third method is available using the blktap-utils with the Xen blktap xapi
    interface. Similar to the nbd method, the blktap requires you to insert a kernel
    module and manually allocate a device. A tapdisk process is spawned, attached
    to the driver, and instructed to open a disk image. The manual pages for blktap-utils
    aren’t very useful, but you can find a description on the Xen website at *[http://wiki.xen.org/wiki/Mounting_a_.vhd_disk_image_using_blktap/tapdisk](http://wiki.xen.org/wiki/Mounting_a_.vhd_disk_image_using_blktap/tapdisk)*
    and at *[http://lists.xen.org/archives/html/xen-api/2012-05/msg00149.html](http://lists.xen.org/archives/html/xen-api/2012-05/msg00149.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: To complete this section, I’ll repeat the process for setting up devices using
    the libvhdi tools. For simplicity, the previous examples used the privileged root
    user. But the following examples demonstrate a nonprivileged user authorized to
    use `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: To run the FUSE `mount` and `unmount` commands as a nonprivileged user, you
    need to set *user_allow_other* in */etc/fuse.conf*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find information about the image using `vhdiinfo`, and no special privileges
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can FUSE mount the image without root privileges, but you need to explicitly
    instruct the `vhdimount` command to allow the root user access by adding the `-X
    allow_root` flag. This flag is also needed to allow root to perform further actions
    through `sudo` (like creating block devices with kpartx):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw image is now available in the *./raw* directory, and you can access
    it with standard tools. To create loop and mapper devices, run `kpartx` with the
    `sudo` command. Once the devices are created, you can access them with tools via
    the `sudo` command. The `sudo` command is required for all block device access.
    Examples with kpartx and fls are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Mounting the filesystem also requires `sudo`, and explicitly specifying `-o
    ro` mounts it as read-only. An example of creating a mount point, mounting the
    filesystem from the previous example, and accessing it with `ls` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The cleanup of this session requires `sudo` for unmounting the raw image and
    removing the loop and mapper devices. You can remove the FUSE mount of the **.vhd*
    file without root privileges. These steps are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You configure the `sudo` command by editing the */etc/sudoers* file. Many of
    the examples in this book use the root user for simplicity’s sake to reduce the
    number of commands on an already complex command line. It’s good practice to work
    as a nonprivileged user with security mechanisms such as `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: '**OS-Encrypted Filesystems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s look at accessing popular encrypted filesystems. The focus is not
    on key recovery (although I do provide a couple of suggestions) but on accessing
    the filesystems with a known key. It’s assumed the keys or passwords are available
    from memory dumps, escrow/backup in enterprise organizations, individuals legally
    compelled to provide them, victims offering to help, commercial recovery services/software,
    or other sources.
  prefs: []
  type: TYPE_NORMAL
- en: You can determine the type of filesystem encryption with various partition-analysis
    tools that can identify headers, magic numbers, and other artifacts unique to
    a particular encrypted filesystem type. You’ll find an overview of identifying
    filesystem encryption in a forensic context at *[http://encase-forensic-blog.guidancesoftware.com/2014/04/version-7-tech-tip-spotting-full-disk.html](http://encase-forensic-blog.guidancesoftware.com/2014/04/version-7-tech-tip-spotting-full-disk.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll find the information about a particular encrypted image
    needed to create an unencrypted block device or file that you can access using
    forensic tools or safely mount for local browsing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Microsoft BitLocker***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Microsoft’s current default filesystem encryption is BitLocker. It encrypts
    at the block level, protecting entire volumes. A variant of BitLocker designed
    for removable media is called BitLocker-To-Go, which uses encrypted container
    files on a regular unencrypted filesystem. Two open source tools, dislocker and
    libbde, are shown in the examples in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Written by Romain Coltel, you’ll find the dislocker package at *[https://github.com/Aorimn/dislocker/](https://github.com/Aorimn/dislocker/)*.
    It provides various tools for handling BitLocker volumes, including viewing metadata,
    creating decrypted image files, and FUSE mounting volumes.
  prefs: []
  type: TYPE_NORMAL
- en: The dislocker-find tool scans all attached partition devices and specified files
    to identify the existence of any BitLocker volumes. Scanning for BitLocker devices
    might not be necessary if the subject device was already identified during the
    process of attaching it to the acquisition host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dislocker-metadata` command provides an overview of a BitLocker drive.
    The next example is an image taken from a USB thumb drive. The entire drive is
    encrypted, and it doesn’t have a partition table. The image file can be queried
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The output of this command provides a lot of detailed cryptographic information
    not shown here. You can save the output of `dislocker-metadata` to a text file
    for documentation purposes. This command can also operate directly on attached
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: As in previous password and encryption examples, it’s assumed that you have
    the key. Some commercial tools are available to attempt password brute force to
    recover the key. In addition, you can use a volatility plug-in to extract the
    FVEK from a memory image (*[https://github.com/elceef/bitlocker/](https://github.com/elceef/bitlocker/)*),
    and you could use this tool in conjunction with the inception memorydumping tool.
    The use of these tools is not covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a virtual file or block device to operate on a decrypted view
    of the disk image “in place.” The process to do so is similar to the examples
    in “[VM Images](ch08.xhtml#ch08lev1sec02)” on [page 237](ch08.xhtml#page_237).
    The dislocker software package provides a tool to create a FUSE filesystem with
    virtual representation of the decrypted volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The file that appears in the *clear* directory is a decrypted representation
    of the encrypted filesystem, and you can operate on it using regular forensic
    tools. An example using Sleuth Kit’s fsstat is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can safely mount the decrypted filesystem image for normal browsing. The
    `mount` command has a `loop` option, which allows a partition image file to be
    directly mounted, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The cleanup in this example is a simple matter of unmounting the files’ mount
    point, removing the FUSE mount, and deleting the mount directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the preceding examples were done with root privileges to reduce complexity
    and make them easier to understand. You can perform the same commands as a nonprivileged
    user, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here `dislocker-fuse` passes `-o allow_root` to the FUSE driver, allowing `sudo`
    to be used for mounting and unmounting. The `uid=holmes` ensures that Mr. Holmes
    can access the mounted files without root privileges. It’s assumed that Mr. Holmes
    is a member of the FUSE Unix group, and the */etc/fuse.conf* file contains the
    line *user_allow_other*.
  prefs: []
  type: TYPE_NORMAL
- en: Using dislocker, you can provide three possible credentials to unlock a BitLocker
    container. A `-u` flag (used in the previous example) specifies that the user’s
    password be requested. A `-p` flag provides a recovery password (48 digits long).
    And an `-f` flag specifies a key file (BEK file).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a recovery password (`-p`) instead of a user password (`-u`) requires
    manually keying in the 48-digit recovery password, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-root version of this command passes flags to FUSE, which allows for
    mounting with `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also decrypt the BitLocker image and save it separately as a regular
    filesystem image (only the specified volume is saved, not the partition table
    or other partitions). This will take some time depending on the size of the BitLocker
    image, as the entire image is decrypted and written to a new image file on the
    disk. You’ll need to do some capacity planning, because the two images, encrypted
    and decrypted, will take up space on the acquisition host. You can create a decrypted
    version of the volume as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The resulting decrypted image file is the same size as the original because
    each BitLocker block was decrypted and the cleartext block written to the new
    image. This command does not need root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can mount the decrypted BitLocker image file and access it as a partition
    using a `mount` command with a `loop` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The only command that is different for non-root use is `mount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Because BitLocker is the default filesystem encryption on the dominant OS platform,
    it’s worth providing a second example using a different software package. The
    libbde package (written by Joachim Metz, the author of ewflib) also provides libraries
    and tools to access BitLocker images.
  prefs: []
  type: TYPE_NORMAL
- en: The example shown next is slightly more complex than the previous one, because
    it involves a notebook disk with a regular partition table (in contrast to a USB
    thumb drive without a partition table). After calculating the offsets from the
    mmls output, the bdeinfo tool is demonstrated to provide a compact overview of
    the BitLocker container.
  prefs: []
  type: TYPE_NORMAL
- en: Both dislocker and libbde can be given a byte offset for the start of the BitLocker-encrypted
    volume. But this is unnecessary when working with image files of volumes/partitions
    or devices without partitions. In this example, an acquired image has a partition
    table, and the BitLocker-encrypted volume offset (in bytes) must be calculated.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Always be sure about the units used for a command. Some tools use sector offsets,
    and others use byte offsets. It is important to distinguish and convert between
    the two.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example demonstrates how to determine the byte offset. The Sleuth
    Kit `mmls` command displays the partition table and the sector offsets for each
    partition. The sector offset must be converted into a byte offset, which can be
    used with the decryption tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert the sector offset shown by `mmls` to a byte offset by multiplying
    by the sector size. On the command line it is convenient to use Bash math expansion.
    In this example, the sector offset is 4098048 and the sector size is 512\. Multiplying
    these gives a byte offset of 2098200576\. You can use this value for the `bdeinfo`
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bdemount` command operates similarly to the `dislocker` command and creates
    a virtual file that represents the decrypted image (the full key has been shortened
    here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The file will appear in the *./raw* directory, where you can analyze it directly
    or mount it to a loop device for regular browsing. The mount commands are the
    same as the previous BitLocker example, so they’re not repeated here.
  prefs: []
  type: TYPE_NORMAL
- en: '***Apple FileVault***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Apple’s filesystem encryption built into OS X is FileVault. It is also a block-level
    encryption system, and several open source tools are available to decrypt it.
    Two tools I’ll describe here are libfvde and VFDecrypt. (The libfvde software
    package was written by Omar Choudary and Joachim Metz, and you’ll find it at *[https://github.com/libyal/libfvde/](https://github.com/libyal/libfvde/)*.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you use the libfvde tools, you need to calculate the correct byte offset
    of the FileVault-encrypted volume. The `mmls` command provides the sector offset
    of the volume, which needs to be converted to bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Multiplying the sector offset by the sector size using simple Bash math expansion
    provides a byte offset of 209735680, which you can use for the fvdeinfo and fvdemount
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fvdeinfo tool provides an overview of the FileVault-encrypted volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To decrypt the FileVault volume, you need to recover the *EncryptedRoot.plist.wipekey*
    file and provide either a user password or recovery key. You can find and extract
    the *wipekey* file using Sleuth Kit tools, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The recursive fls output of the Recovery HD partition uses the sector offset
    found with mmls. The output is grepped for the *EncryptedRoot.plist.wipekey* file.
    After it’s found, the icat tool is used to extract it (using the inode, which
    is 1036 in this example). Notice how a sector offset was used with fls and icat,
    and not a byte offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 24-character recovery key is used with the `-r` flag and the now-recovered
    *EncryptedRoot.plist.wipekey* file. You can then use this key to create a FUSE
    mount of a decrypted representation of the volume, as shown here (the recovery
    key has been shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can provide a user password (`-p`) instead of a recovery key (`-r`), and
    also using the *EncryptedRoot.plist.wipekey* file, you can access the resulting
    volume image with regular forensic tools. An example using Sleuthkit’s fsstat
    on the decrypted volume is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mount this decrypted volume as a regular filesystem for browsing,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When the analysis work is complete, you’ll need to do some cleanup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the preceding examples were done with root privileges to reduce complexity
    and make them easier to understand. Most of the commands can be done as non-root
    with a few exceptions. Examples in which a command is different when run by a
    nonprivileged user are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `-X allow_root` string in the `fvdemount` command allows root to access
    the FUSE mounted directory. The `sudo` command is needed to mount and unmount
    the hfsplus filesystem. When you’re browsing the filesystem, you might also need
    the `sudo` command if filesystem permissions restrict access to files or directories.
  prefs: []
  type: TYPE_NORMAL
- en: Several other notable open source tools exist for operating on File-Vault images.
    The VFDecrypt tool also provides decryption of FileVault images. Originally written
    by Ralf-Philipp Weinmann, David Hulton, and Jacob Appelbaum, it is now maintained
    by Drake Allegrini. You’ll find it at *[https://github.com/andyvand/VFDecrypt/](https://github.com/andyvand/VFDecrypt/)*.
    It can decrypt an image into an unencrypted volume image.
  prefs: []
  type: TYPE_NORMAL
- en: FileVault Cracking software was created by some of the same authors as VFDecrypt;
    you’ll find it at *[http://openciphers.sourceforge.net/oc/vfcrack.php](http://openciphers.sourceforge.net/oc/vfcrack.php)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux LUKS***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number of file encryption systems are available in the open source world.
    Some, like eCryptfs or encfs, are directory based. Others, like GPG and various
    crypt tools, operate on individual files.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I mainly focus on the LUKS encryption system, but I’ll also
    touch on plain dm-crypt and loop-AES. Using the cryptsetup tool, you can set up
    all three. (You can also use the cryptsetup tool to manage True-Crypt volumes,
    which I’ll describe in the following section.)
  prefs: []
  type: TYPE_NORMAL
- en: The examples that follow operate on a forensically acquired image with a LUKS-encrypted
    filesystem. We’ll create a block device representing the decrypted content of
    an encrypted filesystem and show methods to safely mount the filesystem structure
    for browsing with regular tools. The three goals are to get information about
    the encryption, create a device that can be accessed with forensic tools, and
    safely mount the filesystem for regular browsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step requires the byte offset of the LUKS-encrypted partition. The
    sector offset is shown by Sleuth Kit’s `mmls` of the image file. The byte offset
    is the sector offset multiplied by the sector size, which is calculated to be
    1048576 using simple Bash math expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the byte offset to create a loop device of the encrypted partition
    by employing `losetup` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The LUKS-encrypted partition is now accessible as a block device, which the
    cryptsetup tool can use. You can find information about the encrypted partition
    using cryptsetup’s `luksDump` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The key slots can be of interest from a forensics perspective. A LUKS volume
    can have up to eight keys, meaning there are potentially eight different passwords
    where you can attempt recovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the password to the LUKS-encrypted filesystem, you can use cryptsetup’s
    `open` command on the loop0 device to create a mapper device. This device provides
    a decrypted representation of the encrypted image. The mapper device is named
    *clear* in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The encrypted loop device is opened with the `--readonly` flag. The verbose
    (`-v`) flag is also given to provide more information about the success of the
    decryption key. After a successful key has been entered, a new (decrypted) partition
    device will appear in the */dev/mapper* directory and can be operated on using
    standard forensic tools. For example, you can run the Sleuth Kit fsstat tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mount this partition device on the local machine for regular browsing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the examination work is complete, the cleanup process can take place.
    Each step is done in reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is a simplified example of a single partition on a single non-bootable
    data disk. A LUKS-encrypted disk with an bootable OS may have an additional Logical
    Volume Manager (LVM) layer. Such disks may have additional devices that appear
    in the */dev/mapper* directory (root, swap, and so on). You can access or mount
    each of these devices individually. During the cleanup process, you need to remove
    the partition devices with dmsetup before closing the LVM device with cryptsetup.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, the steps shown in this section were performed as a root user.
    To run the examples as a non-root user, `losetup`, `cryptsetup`, `mount`, and
    `umount` need `sudo` to execute, as do any tools that access the */dev/mapper*
    partition device. Depending on the filesystem mounted, additional user options
    may be useful (`uid=holmes` for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Images encrypted with plain dm-crypt and loop-AES can also be decrypted using
    the cryptstetup tool. These follow a similar process as the preceding LUKS example.
    The cryptsetup `open` command needs to have either `plain` or `loopaes` specified
    using the `--type` flag. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using `--type loopaes` will also require a key file. Specifying `--type luks`
    is also possible, but unnecessary, because it’s the default.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find more information about cryptsetup and LUKS at *[https://gitlab.com/cryptsetup/cryptsetup/wikis/home/](https://gitlab.com/cryptsetup/cryptsetup/wikis/home/)*.
    And you’ll find a compatible Windows implementation at *[https://github.com/t-d-k/librecrypt/](https://github.com/t-d-k/librecrypt/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***TrueCrypt and VeraCrypt***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After development of TrueCrypt was stopped, several forks emerged. The dominating
    fork at the moment is VeraCrypt. It offers backward compatibility as well as new
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: The two examples of VeraCrypt I’ll provide are a normal encrypted container
    and a hidden container. I used the standard command line version of VeraCrypt
    in conjunction with familiar tools to make the containers available for further
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example shows a simple encrypted TrueCrypt or VeraCrypt container
    file. The `--file-system=none` flag is important because it prevents VeraCrypt
    from mounting any filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `-l` flag, you can list all the decrypted containers on the host
    system by slot number. The slot number is an important identifier to use in subsequent
    commands. In this example, the slot number is `1` and the familiar `/dev/mapper/*`
    directory is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'After providing the correct credentials, you can request more information about
    the container by specifying the slot number, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Two devices have been created. The device */dev/loop0* is encrypted as a raw
    image (the same as the file on the filesystem). The device shown in the volume
    properties, */dev/mapper/veracrypt1*, is the decrypted volume, which you can operate
    on directly using forensic tools. Here is an example of Sleuth Kit examining the
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mount the mapper device on the local machine and browse the filesystem
    with regular tools, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, deleted files will not be visible in the user-mounted area; they
    will only be visible when you use forensic tools via the */dev/mapper/veracrypt1*
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the cleanup process is the reverse of the setup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The second VeraCrypt example I’ll provide shows how to access a hidden volume.
    One feature of TrueCrypt and VeraCrypt is that it’s possible to have two passwords
    that reveal two separate volumes. The use of both passwords is compared in the
    two command outputs below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *hidden.raw* is a VeraCrypt drive containing a hidden volume. Providing
    the first password produces a functioning standard TrueCrypt container with files,
    claiming the full 1GB capacity of the drive and showing `Type: Normal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If the volume is dismounted and then mounted again using the hidden volume’s
    password, you’ll see a completely different set of files. The time needed to mount
    the volume is also different. With the container in the preceding example, 3.5
    seconds was needed to unlock it, whereas unlocking the hidden container in the
    same file needed 29 seconds. This is because the standard volume decryption is
    attempted first (with all supported algorithms), and upon failing, the decryption
    of a hidden volume is finally tried. In the volume properties, the real size is
    now shown together with `Type: Hidden`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The mapped device of a hidden volume produces a filesystem that you can directly
    analyze with forensic tools.
  prefs: []
  type: TYPE_NORMAL
- en: TrueCrypt and VeraCrypt volumes can also be managed by newer versions of cryptsetup
    (version 1.6.7 and later), providing you with similar mounting possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: There are commercial and open source cracking tools for TrueCrypt/VeraCrypt
    containers, but their use is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned to make acquired image files available as block
    devices, create partition devices, and safely make them available for use with
    regular filesystem tools. You also learned to use loop devices and became more
    familiar with */dev/mapper* devices. I showed tips for booting up suspect images
    and demonstrated methods for accessing VM images from various VM formats. Finally,
    you learned how to make a variety of encrypted filesystems available for access
    in decrypted form.
  prefs: []
  type: TYPE_NORMAL
