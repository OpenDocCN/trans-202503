["```\ndef say(something: str) -> str: return \"You said: \" + something\n```", "```\nTraceback (most recent call last): File \"<stdin>\", line 1, in <module>\nZeroDivisionError: integer division or modulo by zero\n```", "```\n// Go’s Open method clearly has an error return\nfunc Open(name string) (file *File, err error)\n// Java’s open() method clearly throws an IOException\npublic void open (File file) throws IOException\n```", "```\ndef find_node(start_node, search_name): for node in start_node.neighbors: if search_name in node.name: raise FoundNodeException(node) find_node(node, search_name)\n```", "```\ntry { // ...\n} catch (Exception e) { // ignoring since there’s nothing I can do about it\n}\n```", "```\nf = open('foo.txt', 'w')\n# ...\nf.close()\n```", "```\nwith open('foo.txt') as f: # ...\n```", "```\n# set root logger to ERROR level for fout FileAppender\nlog4j.rootLogger=ERROR,fout\n# set com.foo.bar to INFO level \nlog4j.logger.com.foo.bar=INFO\n```", "```\ninfo!(\"Failed request: {}, retrying\", e);\n```", "```\n2022-03-19 12:18:32,320 – appLog – WARNING – Request failed with:\n2022-03-19 12:18:32,348 – appLog – INFO – User login: 986\nUnable to read from pipe.\n2022-03-19 12:18:32,485 – appLog – INFO – User logout: 986\n```", "```\nwhile(messages.size() > 0) { Message m = message.poll(); // This string is concatenated even when trace is disabled! log.trace(\"got message: \" + m); // This string is also concatenated when trace is disabled. log.trace(\"got message: {}\".format(m)); // This string is only concatenated when trace is enabled. It’s faster. log.trace(\"got message: {}\", m);\n}\n```", "```\nimport json\nfrom flask import Flask, jsonify\nfrom statsd import StatsClient\napp = Flask(__name__)\nstatsd = StatsClient()\nmap = {}\n@app.route('/set/<k>/<v>')\ndef set(k, v): \"\"\" Sets a key's value. Overwrites if key already exists. \"\"\" map[k] = v statsd.gauge('map_size', len(map))\n@app.route('/get/<k>')\ndef get(k): \"\"\" Returns key's value if it exists. Else, None is returned. \"\"\" try: v = map[k] statsd.incr('key_hit') return v except KeyError as e: statsd.incr('key_miss') return None\n@app.route('/unset/<k>')\ndef unset(k): \"\"\" Deletes key from map if it exists. Else, no-op. \"\"\" map.pop(k, None) statsd.gauge('map_size', len(map))\n@app.route('/dump')\ndef dump(): \"\"\" Encodes map as a JSON string and returns it. \"\"\" with statsd.timer('map_json_encode_time'): return jsonify(map)\n```"]