- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 29 PROGRAMMING CRUD OPERATIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding chapter, we began developing a database-driven web application,
    with a focus on learning how to read data from the database. However, reading
    is just one of the four primary database operations known collectively as *CRUD*,
    short for *create, read, update, delete*. In this chapter, we’ll look at the other
    components of CRUD as we expand our web application. We’ll write code that allows
    users to change the database data by deleting, adding, or updating entries through
    interactive links and web forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just about any database-driven mobile or web application revolves around the
    four CRUD operations. Take an email app as an example: when you write a new email
    and send it, this *creates* an item in the database representing the receiver
    of the email, as well as an item in your own system’s Sent mailbox database. It’s
    common to *read* or *delete* email in your inbox, and you may also draft an email
    and then *update* it later before sending (or deleting) it.'
  prefs: []
  type: TYPE_NORMAL
- en: As we start adding the remaining CRUD features to our web application, you’ll
    notice a pattern. Each change will begin with a new case in the front-controller
    switch statement inside the Application class, invoking a new method in the ProductController
    class. This method, in turn, will call a new repository class method, where the
    actual database interaction will take place. Finally, we’ll update the appropriate
    page templates to add the necessary user interface for the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we need to delete data from a database table. For example, a car manufacturer
    may stop making a particular model of a car. The model’s details might be copied
    into an archive database table, and then the model is deleted from the main table
    of car models. To delete data from a table, we use the DELETE SQL keyword. If
    no criteria are given, all records are deleted from the named table.
  prefs: []
  type: TYPE_NORMAL
- en: 'When deleting a specific row or rows matching certain criteria, we need to
    provide an SQL WHERE clause. For example, to delete the row with an ID of 4 from
    a model table, the SQL statement would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ll look at examples of deleting an entire table and selectively deleting
    entries from a table in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Everything from a Table
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s first add a feature to our web application from the previous chapter that
    deletes all the products from the products table in the database. [Figure 29-1](#fig29-1)
    shows the Delete All Products link we’ll create, along with a pop-up confirmation
    dialog. It’s always a good idea to offer users a chance to reconsider and cancel
    destructive operations such as permanently deleting data (assuming they have the
    option to delete data at all).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure29-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 29-1: Deleting all products'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll add a new route to detect a POST submission with the action =deleteAll
    variable. Update the run() method in the Application class to match [Listing 29-1](#lis29-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-1: The updated Application class to act on the deleteAll action'
  prefs: []
  type: TYPE_NORMAL
- en: We add a new $isPostSubmission variable that will be true if the received request
    uses the POST method. While it’s technically possible to write a web application
    that changes the server state (such as the database contents) in response to GET
    messages, this would violate the definition of the HTTP GET method. For this reason,
    we’ll use the POST method and an HTML <form> element for any database-changing
    requests (deletions, creations, or updates) in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We next add a new case to the front-controller switch statement for when the
    value of action in the URL is 'deleteAll'. When this action is received through
    a POST request, we invoke the deleteAll() method of the ProductController object.
    If $isPostSubmission is false, we instead use the defaultController to return
    an error message to the user.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll define the deleteAll() method next. Update *src/ProductController.php*
    to match the contents of [Listing 29-2](#lis29-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-2: Adding the deleteAll() method to ProductController'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the ProductController class’s deleteAll() method to in turn invoke
    the deleteAll() method of the ProductRepository class (which manages communication
    with the database). Then we invoke the list() method to make the application display
    the Product List page, using the header() function and location URL /?action=products.
    The user should therefore see an empty list of products after they’ve all been
    deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll add the deleteAll() method to the ProductRepository class. Update
    *src/ProductRepository.php* as shown in [Listing 29-3](#lis29-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-3: Adding the deleteAll() method to ProductRepository'
  prefs: []
  type: TYPE_NORMAL
- en: We declare the deleteAll() method to return an integer value indicating the
    number of rows deleted from the database. If the connection is NULL, we return
    0. Otherwise, we declare, prepare, and execute the 'DELETE FROM product' SQL query
    string, which deletes every entry from the product table. Then we invoke the rowCount()
    method of the PDO statement object ❶, which returns the number of rows affected
    by the most recently executed query. We return this integer value at the end of
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to update the template for the Product List page to offer a
    link for deleting all the products. Update *templates/product/list.xhtml.twig*
    to match the contents of [Listing 29-4](#lis29-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-4: The list.xhtml.twig template for listing all products'
  prefs: []
  type: TYPE_NORMAL
- en: Here we add a paragraph to the end of the template declaring a POST method form
    containing a Bootstrap-styled button with the text Delete ALL products. The action
    for our controller to receive (deleteAll) is sent through the form’s action attribute.
    This button includes a pop-up confirmation message (launched by the JavaScript
    confirm() function) declared in its onclick attribute, so the user will be able
    to confirm or cancel the request.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Individual Items by ID
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Just as we can show a particular product based on its ID, we can also use an
    ID to specify which individual product to delete from the database. Let’s add
    that feature now. [Figure 29-2](#fig29-2) shows a screenshot of the page we’ll
    create: each product in the Product List page will get its own Show and Delete
    button-styled links, each triggering a database action based on the product’s
    ID.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure29-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 29-2: The Show and Delete buttons for an individual product'
  prefs: []
  type: TYPE_NORMAL
- en: We first need to add a new route URL pattern of action=delete, where the ID
    of the product to be deleted is passed through a POST form submission as a variable
    id. Update the Application class code to match [Listing 29-5](#lis29-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-5: The Application class, updated to act on the delete action'
  prefs: []
  type: TYPE_NORMAL
- en: Here we add a new case in the front-controller switch statement for when the
    value of action in the URL is 'delete'. In this case, we attempt to extract an
    integer variable id from the POST variables received in the request ❶. If $isPostSubmission
    is true and the ID isn’t empty, we pass the ID to the delete() method of the ProductController
    object. Otherwise, we pass an appropriate error message to the error() method
    of the DefaultController object for display.
  prefs: []
  type: TYPE_NORMAL
- en: To define the delete() method, update *src/ProductController.php* according
    to [Listing 29-6](#lis29-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-6: Adding the delete() method to ProductController'
  prefs: []
  type: TYPE_NORMAL
- en: The delete() method takes in an integer product ID and passes it to the delete()
    method of the ProductRepository object. Then it makes the application display
    the Product List page via the list() method. The user should therefore see the
    list of products, less the one deleted, after clicking the link to delete an item.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll add the delete() method to the ProductRepository class in *src/ProductRepository.php*.
    [Listing 29-7](#lis29-7) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-7: Adding the delete() method to ProductRepository'
  prefs: []
  type: TYPE_NORMAL
- en: The delete() method takes in an integer argument (the ID) and returns a Boolean
    indicating the success of the deletion. If the connection is NULL, we return false.
    Otherwise, we declare the SQL query string 'DELETE FROM product WHERE id = :id'
    to delete just the product with the specified ID. We then prepare the statement
    and bind the $id argument to the :id placeholder. Executing the statement then
    produces a Boolean success value, which we store and return.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to update the Product List template to offer the button-styled
    Show and Delete links for each product. Modify *templates/product/list.xhtml.twig*
    to match the contents of [Listing 29-8](#lis29-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-8: The list.xhtml.twig template offering deletion by ID'
  prefs: []
  type: TYPE_NORMAL
- en: We style the existing Show link as a secondary button ❶. Then we declare a POST
    submission form with action=delete and a button Delete, passing id as a hidden
    variable filling in the product ID with the Twig {{product.id}} placeholder ❷.
    As with the Delete ALL products form, this form button includes a pop-up confirmation
    message declared in an onclick attribute, so the user will be able to confirm
    or cancel the request. We also add a Twig else block ❸ so that the message (there
    are no products to display) is shown if no products are found in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating New Database Entries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s turn to the *C* in CRUD: creating new database entries by using SQL INSERT
    statements. For example, here’s an SQL statement that inserts a new row into a
    table called cat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Three values are provided for the name, gender, and age columns. The INSERT
    SQL statement requires us to first list the sequence of column names, and then
    follow this with the values to be inserted into those columns.
  prefs: []
  type: TYPE_NORMAL
- en: We touched on how to create new database entries when we first set up our application’s
    database with its two initial products in “Setting Up the Database Schema” on
    [page 543](chapter28.xhtml#pg_543). Now we’ll make the process interactive by
    adding a form to our application that allows users to define new products and
    submit them to the database. [Figure 29-3](#fig29-3) shows the form we’ll create.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure29-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 29-3: The link to create a new product and its associated form'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add a button link at the bottom of the Product List page to create a new
    product. This link will launch a Create NEW Product page with form fields for
    submitting the new product’s description and price.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Products Through a Web Form
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To offer the Create NEW Product page form feature, we first need to add two
    new route actions to the application, one to display the form (action=create)
    and one to process the form submission (action=processCreate). [Listing 29-9](#lis29-9)
    shows how to add cases for these actions to the front controller in the Application
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-9: Adding the ''create'' and ''processCreate'' routes to the front
    controller'
  prefs: []
  type: TYPE_NORMAL
- en: First, we add a new case in the front-controller switch statement for when the
    value of action in the URL is 'create' ❶. This invokes the create() method of
    the ProductController object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare the case for the 'processCreate' action ❷. For that, we retrieve
    the description and price values from the POST submission variables. Notice the
    use of two filters for the float price variable; the FILTER_FLAG_ALLOW_FRACTION
    argument is required to permit the decimal-point character.
  prefs: []
  type: TYPE_NORMAL
- en: If $isPostSubmission is true and both $description and $price are not empty
    ❸, the description and price are passed to the processCreate() method of the ProductController
    object. Otherwise, an appropriate error message will be displayed using the error()
    method of the DefaultController object.
  prefs: []
  type: TYPE_NORMAL
- en: This example is assuming that the product database table uses auto-incrementing
    to choose a new, unique integer ID when a new row is added, as demonstrated in
    [Chapter 28](chapter28.xhtml). Without this feature, we’d also have to supply
    an ID for the new product, perhaps using logic that first finds the highest current
    ID in the database and then adds 1 to it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now add the create() and processCreate() methods to the Product Controller
    class. Update *src/ProductController.php* to match [Listing 29-10](#lis29-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-10: Adding the create() and processCreate() methods to ProductController'
  prefs: []
  type: TYPE_NORMAL
- en: The create() method ❶ simply renders the *templates/product/create.xhtml.twig*
    template to display the new product form (we’ll create this template shortly).
    The processCreate() method ❷ takes in a string for the new description and a float
    for the new price and passes them along to the insert() method of the ProductRepository
    object for insertion into the database. Then processCreate() invokes the Product
    List page via the list() method so that the user will see the updated list of
    products, including the newly created one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were being completely correct, our processCreate() method would not call
    the list() method, but instead would force a redirect, sending a new request to
    the server to list all products. By not redirecting, we’ll get a problem: if the
    user refreshes their browser page after submitting a form, the form will be submitted
    a second time. However, adding redirects now would make our work in the next section
    more complex, so we’ll just call the list() method for now and formulate a better
    redirect solution at the end of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: To add the insert() method to the ProductRepository class, update *src/ProductRepository.php*
    as shown in [Listing 29-11](#lis29-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-11: Adding the insert() method to ProductRepository'
  prefs: []
  type: TYPE_NORMAL
- en: The new insert() method takes in a string argument ($description) and a float
    argument ($price) and returns an integer—either the ID of the newly created database
    record or -1 if no record is created. If the database connection is NULL, we return
    -1 right away. Otherwise, we declare and prepare the SQL query string 'INSERT
    INTO product (description, price) VALUES (:description, :price)' to add a new
    entry to the product table.
  prefs: []
  type: TYPE_NORMAL
- en: We then bind the $description argument to the :description placeholder and the
    $price argument to the :price placeholder before executing the statement. Finally,
    we test the Boolean $success value from the execution ❶. If true, we use the lastInsertId()
    method of the PDO connection object to return the ID of the most recently inserted
    database entry, which should correspond to the new product. If false, we return
    -1 instead.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s revise the Product List page template to include the link for adding
    a new product. Update *templates/product/list.xhtml.twig* to match the contents
    of [Listing 29-12](#lis29-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-12: Adding the new product link to the list.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: Here we add a paragraph to the end of the template containing a Bootstrap button–styled
    link with the text Create NEW product. The link triggers the create URL action.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s add the Twig template to display the Create NEW Product page form.
    Create the *templates/product/create.xhtml.twig* template file containing the
    code shown in [Listing 29-13](#lis29-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-13: The create.xhtml.twig template for the new product form'
  prefs: []
  type: TYPE_NORMAL
- en: This template presents an HTML form ❶ whose submit action is action=processCreate,
    so the submitted values will be passed along to the processCreate() method of
    the ProductController class described earlier. The form contains two paragraphs,
    for the description and price, and then a Submit button.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the Newly Created Product
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When something is changed, it’s helpful to highlight the change to the user.
    Let’s update our application to highlight the new product in the product list
    after it’s been added to the database. [Figure 29-4](#fig29-4) shows the effect
    we want to achieve; it shows we’ve added a very expensive bag of nails costing
    $999!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure29-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 29-4: Displaying the newly created product with a highlighted background'
  prefs: []
  type: TYPE_NORMAL
- en: To implement this feature, we can take advantage of the return value from the
    ProductRepository class’s insert() method, which we declared in the preceding
    section. This value indicates the ID of the newly created product, so we can add
    logic to the application to highlight the product whose ID matches this value.
    First, we need to update the ProductController class, shown in [Listing 29-14](#lis29-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-14: Updating the list() and update() methods in the ProductController
    class'
  prefs: []
  type: TYPE_NORMAL
- en: We update the list() method (which displays the complete product list) to take
    in an optional $newProductId parameter with a default value of NULL. We pass this
    parameter to the Twig Product List template, along with the array of products
    ❶. Next, we update the processCreate() method to receive the new product ID returned
    from insert() and pass it along to the list() method.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can update the Product List template to highlight the product matching
    the id variable passed to the template. Since the product IDs start at 1 and auto-increment,
    a value of -1 will never match an object retrieved from the database, so the list()
    method’s default $newProductId parameter value of -1 will result in no products
    being highlighted. Modify *templates/product/list.xhtml.twig* as shown in [Listing
    29-15](#lis29-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-15: Updating the list.xhtml.twig template to highlight the newly
    added product within the list'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve added a Twig if statement inside the loop through the products that sets
    the Twig highlight variable to 'active' if the ID of the current product matches
    the received Twig variable id ❶. Otherwise, the highlight variable is set to an
    empty string. We include the value of highlight in the CSS style classes for each
    list item ❷, so each product will either be highlighted or not, as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to add a <style> element for the active CSS class in the base
    template. Update */templates/product/base.xhtml.twig* according to [Listing 29-16](#lis29-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-16: Declaring a <style> element in the base.xhtml.twig Twig template'
  prefs: []
  type: TYPE_NORMAL
- en: In the <head> element, we add a CSS rule that active list items should have
    a pink background.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a Database Entry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last CRUD operation to explore is the *U* for *update*. This operation
    is necessary since the data in a database constantly needs to be changed to reflect
    changes in the real world, such as a person’s new address, the increase in the
    price of a product, a user changing their subscription status, and so on. To modify
    an existing record in a table, we can use the SQL UPDATE keyword. For example,
    here’s an SQL statement that changes the age of a cat to 5, for the row whose
    ID is 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let’s add a way to update an existing product to our web application. Much like
    creating a new product, we’ll do this through a web form. [Figure 29-5](#fig29-5)
    shows how this new feature will work.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure29-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 29-5: Updating an existing product'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add an Edit button to each product in the Product List page, which will
    take the user to an Edit Product page with form fields to modify the product’s
    description and price (the ID will be read-only). These fields will start out
    with the current values filled in. Once the changes are submitted, the newly updated
    product will be highlighted on the Product List page.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this feature, we must first add two new route actions, one to display
    the editing form (action=edit) and one to process the form submission (action=processEdit).
    [Listing 29-17](#lis29-17) adds these two new cases to the front controller in
    the Application class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-17: Adding the ''edit'' and ''processEdit'' routes to the front
    controller'
  prefs: []
  type: TYPE_NORMAL
- en: We add a new case in the front-controller switch statement for when the value
    of action in the URL is 'edit' ❶. As with the 'show' and 'delete' cases, we attempt
    to extract an integer id variable from the URL-encoded variables received in the
    request. If the value of id is empty, we display an appropriate error message
    by passing a string message to the error() method of the DefaultController object.
    If the value isn’t empty, we pass it to the edit() method of the ProductController
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the 'processEdit' case ❷, which starts by retrieving id, description,
    and price from the POST submitted variables. If $isPostSubmission is true and
    all three variables (id, description, and price) aren’t empty, we pass the values
    to the processEdit() method of the ProductController object. Otherwise, we again
    display an appropriate error message by using the error() method of the DefaultController
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll add the new methods to the ProductController class. Update *src/ProductController.php*
    to match the contents of [Listing 29-18](#lis29-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-18: Adding the edit() and processEdit() methods to ProductController'
  prefs: []
  type: TYPE_NORMAL
- en: The edit() method uses the provided integer $id argument to retrieve a single
    Product object from the database ❶. Then it passes this object to the */templates/product/edit.xhtml.twig*
    template, which displays the form for editing the product. The processEdit() method
    takes in an $id integer, $description string, and $price float and passes them
    to the update() method of the ProductRepository object ❷. Then it makes the application
    display to the Product List page via the list() method. As with the processCreate()
    method, we pass the ID of the updated product to list() so that product will be
    highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 29-19 shows how to add the new update() method to the ProductRepository
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-19: Adding the update() method to the ProductRepository class'
  prefs: []
  type: TYPE_NORMAL
- en: The update() method takes in a product’s ID, description, and price, and returns
    a Boolean value indicating the success or failure of the update. If the database
    connection is NULL, then false is returned. Otherwise, we declare the SQL query
    string 'UPDATE product SET description = :description, price = :price WHERE id=:id',
    using the WHERE clause with the object’s ID to specify the particular database
    row to be updated. After preparing the statement, we bind the $id, $description,
    and $price variables to their corresponding placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Then we execute the statement and return the resulting Boolean success value.
    Note that we’re returning a Boolean here, rather than the product ID as we did
    previously for the insert() method. The difference here is that the calling method
    already knows the product ID in question, so it’s sufficient to simply return
    the true/false success of executing the database update statement.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to offer an Edit button for each product on the Product List page.
    Update the *templates/product/list.xhtml.twig* file as shown in [Listing 29-20](#lis29-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-20: Adding an Edit button to the list.xhtml.twig template'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Twig for loop for the current product, we add a Bootstrap button–styled
    link with the text Edit. This link for the edit action includes the id of the
    current product.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s add the Twig template to display the form to edit the details
    of a product. Create *templates/product/edit.xhtml.twig* containing the code shown
    in [Listing 29-21](#lis29-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-21: The edit.xhtml.twig template for the form to edit a product'
  prefs: []
  type: TYPE_NORMAL
- en: The main work of this template is to present an HTML form ❶ whose submit action
    is action=processEdit, so the submitted values will go to the processEdit() method
    of the ProductController class described earlier. This form contains three paragraphs,
    for the ID, description, and price, and then a Submit button. The ID, description,
    and price form inputs are populated with the values of the Product object for
    those properties. The ID input has the readonly attribute; since we don’t want
    the user to be able to edit this value, it’s displayed but isn’t editable ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Double Form Submission with Redirects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our current implementation, we call the list() method after processing a
    form submission to add or edit a product. By passing a product ID to this method,
    we can make our template highlight the product that’s been created or updated.
    If the user were to refresh their browser page after submitting a form, however,
    the browser would attempt to submit the form data a second time by repeating the
    HTTP POST request. We can avoid this problem by making the server *redirect* to
    request the Product List page after a form submission (a GET request for the URL
    /?action=products). If the page is refreshed, this GET request to list all products
    will be repeated rather than the POST request. This technique is sometimes called
    the *post-redirect-get (PRG) pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update our application to use this redirect approach. Rather than passing
    the product ID as an argument to the list() method, we’ll need to store the ID
    in the $_SESSION array. As we discussed in [Chapter 14](chapter14.xhtml), this
    is a special array for storing data about the user’s current browser session.
    First, we’ll update the list() method and add a new session helper method in *src/ProductController.php*,
    as shown in [Listing 29-22](#lis29-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-22: Updating the list() method and adding getIdFromSession() to
    the ProductController class'
  prefs: []
  type: TYPE_NORMAL
- en: The list() method no longer has any parameters as input. Instead we attempt
    to retrieve an ID from the session by using the getIdFromSession() method ❶. This
    method initializes the $id variable to NULL, then tests whether the $_SESSION
    array contains a variable with a key of 'id' ❷. If such a key exists, its value
    is retrieved and stored in $id, then that element of the array is unset so that
    it will no longer be stored in the session once retrieved. The method returns
    the value of $id, which will be either NULL or the value retrieved from the session.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can update the ProductController class methods to use redirects after
    storing the ID in the session. Update these methods in *src/ProductController.php*
    as shown in [Listing 29-23](#lis29-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-23: Updating the POST action methods to use redirects in ProductController'
  prefs: []
  type: TYPE_NORMAL
- en: Both the delete() and deleteAll() methods have been updated to use the built-in
    header() function to redirect the server to process a GET request for the URL
    /?action=products ❶. This value of action will result in the products being listed
    by our list() method.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also updated processCreate() to store the ID of the newly created product
    ($newObjectId) in the session with key 'id' ❷. Then it redirects the server to
    process a GET request for the URL /?action=products. Likewise, we’ve updated the
    processEdit() method to store the ID of the edited product’s ID ($id) in the session
    with the key 'id' ❸ and to redirect to /?action=products in the same way. We’ve
    now improved our web application to properly redirect after processing a POST
    form submission, so a refresh of the browser will not result in a repeat submission
    of the form data.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re storing the ID in the session, we have to ensure that the session
    is started by our front-controller index script each time a request is received.
    Update */public/index.php* as shown in [Listing 29-24](#lis29-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 29-24: Updating index.php to ensure that sessions are active for our
    web application'
  prefs: []
  type: TYPE_NORMAL
- en: We now call the session_start() function before any actions are taken. This
    ensures that our web application can store and retrieve values from the user’s
    HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we explored the full range of standard database operations:
    creating, reading, updating, and deleting entries, collectively known as *CRUD*.
    As in the preceding chapter, we used prepared statements for all our database
    queries, making it easy to bind parameters to the four actions such as deleting
    a row by its ID or inserting new values into multiple fields of a database entry.'
  prefs: []
  type: TYPE_NORMAL
- en: We continued to see how much of the architecture of a database-driven web application
    is identical to that of a non-database application. The core of our code is focused
    around a front controller interrogating the requests received from the web client
    and invoking appropriate controller methods. By encapsulating our database actions
    in a repository class, we were able to keep the logic in our controller classes
    focused on responding to requests by arranging data and rendering the appropriate
    Twig template.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how forms for creating and updating database rows are presented
    and processed just like any other web form, only now the data is passed to the
    repository method to work with the database. We then saw how to improve the system
    by using redirects after processing form submissions to avoid a repeat of the
    form actions if the browser page happens to be refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Open a web application you regularly use, such as a social media app or
    e-commerce site. Explore the actions available to you as a user and reflect on
    which CRUD operations are being executed for each action. How is data coming from
    and being saved to the database sitting behind the web application you’re using?
  prefs: []
  type: TYPE_NORMAL
- en: '2.   Create a CRUD web application for Book objects with these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: id (integer), an auto-incrementing primary key
  prefs: []
  type: TYPE_NORMAL
- en: title (string)
  prefs: []
  type: TYPE_NORMAL
- en: author (string)
  prefs: []
  type: TYPE_NORMAL
- en: price (float)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can either create a new project from scratch or reuse classes from this
    chapter and the [Chapter 28](chapter28.xhtml) exercises. I suggest you follow
    this sequence when incrementally adding CRUD features to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: a.   List all objects.
  prefs: []
  type: TYPE_NORMAL
- en: b.   List one object, given an ID.
  prefs: []
  type: TYPE_NORMAL
- en: c.   Delete all objects.
  prefs: []
  type: TYPE_NORMAL
- en: d.   Delete one object, given an ID.
  prefs: []
  type: TYPE_NORMAL
- en: e.   Create a new object.
  prefs: []
  type: TYPE_NORMAL
- en: f.   Edit an object, given an ID.
  prefs: []
  type: TYPE_NORMAL
