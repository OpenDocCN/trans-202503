<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_407"/><span class="big">15</span><br/>FLAIM PART II: PUSHING THE ENVELOPE</h2>&#13;
<p class="quote"><em>What we do in college is to get over our little-mindedness. Education—to get it you have to hang around till you catch on.<br/>—Robert Lee Frost</em><sup><a id="ch15fn_1" href="footnote.xhtml#ch15fn1">1</a></sup></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">It’s a well-understood principle that no matter how many books you read, or how many lectures you attend, or how many queries you present on mailing lists, you’ll still be left with unanswered questions. It’s estimated that half of the world’s population has access to the internet today.<sup><a id="ch15fn_2" href="footnote.xhtml#ch15fn2">2</a></sup> There are thousands of terabytes of information available from your desktop. Nevertheless, it seems every project has one or two issues that are just different enough from all others that even internet searches are fraught with futility.</p>&#13;
<p class="indent">To reduce the potential frustration of learning the Autotools, this chapter continues with the FLAIM build system conversion project by tackling some of the less common features of FLAIM’s build system requirements. <span epub:type="pagebreak" id="page_408"/>My hope is that by presenting solutions to some of these less common problems, you’ll become familiar with the underlying framework provided by the Autotools. Such familiarity provides the insight needed to bend the Autotools to your own unique requirements.</p>&#13;
<p class="indent">The <em>xflaim</em> library provides Java and C# language bindings. Automake provides rudimentary support for building Java sources but currently provides no built-in support for building C# sources. In this chapter, I’ll show you how to use Automake’s built-in Java support to build the Java language bindings in xflaim, and then I’ll show you how to write your own <code>make</code> rules for the C# language bindings.</p>&#13;
<p class="indent">We’ll round out this chapter, and finish up the FLAIM conversion pro­ject, with discussions of using native compiler options, building generated documentation, and adding your own top-level recursive <code>make</code> targets.</p>&#13;
<h3 class="h3" id="ch15sec1">Building Java Sources Using the Autotools</h3>&#13;
<p class="noindent">The <em>GNU Automake Manual</em> presents information on building Java sources in two different ways. The first is the traditional and widely understood method of compiling Java source code into Java byte code, which can then be executed within the Java virtual machine (JVM). The second way is the lesser-known method of compiling Java source code directly into native machine code using the GNU Compiler for Java (<code>gcj</code>) frontend to the GNU compiler tool suite. The object files containing this machine code can then be linked together into native executable programs using the standard GNU linker. Probably due to lack of interest, and to the JVM’s having been vastly improved over the years, the GCJ project is no longer being maintained. It’s therefore likely that all support for this mechanism will soon be entirely dropped from the Autotools.</p>&#13;
<p class="indent">In this chapter, I’ll focus on the former—building Java class files from Java source files using the Automake built-in <code>JAVA</code> primary. We’ll also explore the necessary extensions required to build and install <em>.jar</em> files.</p>&#13;
<h4 class="h4" id="ch15sec1-1"><em>Autotools Java Support</em></h4>&#13;
<p class="noindent">Autoconf has little, if any, built-in support for Java. For example, it provides no macros that locate Java tools in the end user’s environment.<sup><a id="ch15fn_3" href="footnote.xhtml#ch15fn3">3</a></sup> Automake’s built-in support for building Java classes is minimal, but getting it to work is not really that difficult if you’re willing to dig in a bit. The biggest stumbling block is conceptual more than functional. You have to work a little to align your understanding of the Java build process with that of the Automake designers.</p>&#13;
<p class="indent">Automake provides a built-in primary (<code>JAVA</code>) for building Java sources, but it does not provide any preconfigured installation location prefixes for <span epub:type="pagebreak" id="page_409"/>installing Java classes. However, the usual place to install Java classes and <em>.jar</em> files is in the <code>$(datadir)</code><em>/java</em> directory, so creating a proper prefix is as simple as using the Automake prefix extension mechanism of defining a variable suffixed with <em>dir</em>, as shown in <a href="ch15.xhtml#ch15ex1">Listing 15-1</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
javadir = $(datadir)/java&#13;
java_JAVA = file_a.java file_b.java ...&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch15ex1"><em>Listing 15-1: Defining a Java installation directory in a</em> Makefile.am <em>file</em></p>&#13;
<p class="indent">Now, you don’t often want to install Java sources, which is what you will accomplish when you define your <code>JAVA</code> primary in this manner. Rather, you want the <em>.class</em> files to be installed, or more likely a <em>.jar</em> file containing all of your <em>.class</em> files. It’s generally more useful, therefore, to define the <code>JAVA</code> primary with the <code>noinst</code> prefix. Additionally, files in a <code>JAVA</code> primary list are not distributed by default, so you may even want to use the <code>dist</code> super-prefix, as shown in <a href="ch15.xhtml#ch15ex2">Listing 15-2</a>.</p>&#13;
<pre>dist_noinst_JAVA = file_a.java file_b.java...</pre>&#13;
<p class="caption" id="ch15ex2"><em>Listing 15-2: Defining a list of non-installed Java files that are distributed</em></p>&#13;
<p class="indent">When you define a list of Java source files in a variable containing the <code>JAVA</code> primary, Automake generates a <code>make</code> rule that builds that list of files all in one command, using the syntax shown in <a href="ch15.xhtml#ch15ex3">Listing 15-3</a>.<sup><a id="ch15fn_4" href="footnote.xhtml#ch15fn4">4</a></sup></p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
JAVAROOT = .&#13;
JAVAC = javac&#13;
CLASSPATH_ENV = CLASSPATH=$(JAVAROOT):$(srcdir)/$(JAVAROOT):\&#13;
  $${CLASSPATH:+":$$CLASSPATH"}&#13;
<span class="codeitalic1">--</span><span class="codeitalic1">snip--</span>&#13;
all: all-am&#13;
<span class="codeitalic1">--snip--</span>&#13;
all-am: Makefile classnoinst.stamp $(DATA) all-local&#13;
<span class="codeitalic1">--snip--</span>&#13;
classnoinst.stamp: $(am__java_sources)&#13;
        @list1='$?'; list2=; if test -n "$$list1"; then \&#13;
        for p in $$list1; do \&#13;
          if test -f $$p; then d=; else d="$(srcdir)/"; fi; \&#13;
          list2="$$list2 $$d$$p"; \&#13;
        done; \&#13;
<span epub:type="pagebreak" id="page_410"/>     <span class="ent">➊</span> echo '$(CLASSPATH_ENV) $(JAVAC) -d $(JAVAROOT) \&#13;
          $(AM_JAVACFLAGS) $(JAVACFLAGS) '"$$list2"; \&#13;
        $(CLASSPATH_ENV) $(JAVAC) -d $(JAVAROOT) \&#13;
          $(AM_JAVACFLAGS) $(JAVACFLAGS) $$list2; \&#13;
        else :; fi&#13;
     <span class="ent">➋</span> echo timestamp &gt; $@&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch15ex3"><em>Listing 15-3: This long shell command was taken from a</em> Makefile <em>generated by Automake.</em></p>&#13;
<p class="indent">Most of the code you see in these commands exists solely to prepend the <code>$(srcdir)</code> prefix onto each file in the user-specified list of Java sources in order to properly support <code>VPATH</code> builds. This code uses a shell <code>for</code> statement to split the list into individual files, prepend the <code>$(srcdir)</code>, and then reassemble the list.<sup><a id="ch15fn_5" href="footnote.xhtml#ch15fn5">5</a></sup></p>&#13;
<p class="indent">The part that actually does the work of building the Java sources is found in two lines (four wrapped lines, actually)<sup><a id="ch15fn_6" href="footnote.xhtml#ch15fn6">6</a></sup> near the bottom at <span class="ent">➊</span>.</p>&#13;
<p class="indent">Automake generates a stamp file at <span class="ent">➋</span> because the single <code>$(JAVAC)</code> command generates several <em>.class</em> files from the <em>.java</em> files. Rather than choosing one of these files at random, Automake generates and uses a stamp file as the target of the rule, which causes <code>make</code> to ignore the relationships between individual <em>.class</em> files and their corresponding <em>.java</em> files. That is, if you delete a <em>.class</em> file, the rules in the makefile will not cause it to be rebuilt. The only way to cause the re-execution of the <code>$(JAVAC)</code> command is to either modify one or more of the <em>.java</em> files, thereby causing their timestamps to become newer than that of the stamp file, or delete the stamp file entirely.</p>&#13;
<p class="indent">The variables used in the build environment and on the command line include <code>JAVAROOT</code>, <code>JAVAC</code>, <code>JAVACFLAGS</code>, <code>AM_JAVACFLAGS</code>, and <code>CLASSPATH_ENV</code>. Each variable may be specified in the <em>Makefile.am</em> file.<sup><a id="ch15fn_7" href="footnote.xhtml#ch15fn7">7</a></sup> If a variable is not specified, the defaults shown in <a href="ch15.xhtml#ch15ex3">Listing 15-3</a> are used instead.</p>&#13;
<p class="indent">All <em>.java</em> files specified in a <code>JAVA</code> primary variable are compiled using a single command line, which may pose a problem on systems with limited command line lengths. If you encounter such a problem, you can either break up your Java project into multiple Java source directories or develop your own <code>make</code> rules for building Java classes. (When I discuss building C# code in “Building the C# Sources” on <a href="ch15.xhtml#page_418">page 418</a>, I demonstrate how to write such custom rules.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_411"/>The <code>CLASSPATH_ENV</code> variable sets the Java <code>CLASSPATH</code> environment variable so that it contains <code>$(JAVAROOT)</code>, <code>$(srcdir)/$(JAVAROOT)</code>, and then any class path that may have been configured in the environment by the end user.</p>&#13;
<p class="indent">The <code>JAVAROOT</code> variable is used to specify the location of the project’s Java root directory within the project’s build tree, where the Java compiler will expect to find the start of generated package directory hierarchies belonging to your project.</p>&#13;
<p class="indent">The <code>JAVAC</code> variable contains <code>javac</code> by default, with the assumption that <code>javac</code> can be found in the system path. The <code>AM_JAVACFLAGS</code> variable may be set in <em>Makefile.am</em>, though the non-Automake version of this variable (<code>JAVACFLAGS</code>) is considered a user variable and thus shouldn’t be set in makefiles.</p>&#13;
<p class="indent">This is all fine as far as it goes, but it doesn’t go nearly far enough. In this relatively simple Java project, we still need to generate Java native interface (JNI) header files using the <code>javah</code> utility as well as a <em>.jar</em> file from the <em>.class</em> files built from the Java sources. Unfortunately, Automake-provided Java support doesn’t even begin to handle these tasks, so we’ll have to do the rest with handcoded <code>make</code> rules. We’ll begin with Autoconf macros to ensure that we have a good Java build environment.</p>&#13;
<h4 class="h4" id="ch15sec1-2"><em>Using ac-archive Macros</em></h4>&#13;
<p class="noindent">The GNU Autoconf Archive supplies community-contributed Autoconf macros that come close to what we need in order to ensure that we have a good Java development environment. In this particular case, I downloaded the latest source package and just hand-installed the <em>.m4</em> files that I needed into the <em>xflaim/m4</em> directory.<sup><a id="ch15fn_8" href="footnote.xhtml#ch15fn8">8</a></sup></p>&#13;
<p class="indent">Then I modified the files (including their names) to work the way my <code>FLM_PROG_TRY_DOXYGEN</code> macro works. I wanted to locate any existing Java tools, but I also wanted be able to continue without them if necessary. Though it has gotten much better in the last 10 years, given the politics surrounding the existence of Java tools in Linux distributions, this is probably a wise approach.</p>&#13;
<p class="indent">I created the following macros within corresponding Java-related <em>.m4</em> files:</p>&#13;
<ul>&#13;
<li class="noindent"><code>FLM_PROG_TRY_JAVAC</code> is defined in <em>flm_prog_try_javac.m4</em>.</li>&#13;
<li class="noindent"><code>FLM_PROG_TRY_JAVAH</code> is defined in <em>flm_prog_try_javah.m4</em>.</li>&#13;
<li class="noindent"><code>FLM_PROG_TRY_JAVADOC</code> is defined in <em>flm_prog_try_javadoc.m4</em>.</li>&#13;
<li class="noindent"><code>FLM_PROG_TRY_JAR</code> is defined in <em>flm_prog_try_jar.m4</em>.</li>&#13;
<li class="noindent"><code>FLM_PROG_TRY_JNI</code> is defined in <em>flm_prog_try_jni.m4</em>.</li>&#13;
</ul>&#13;
<p class="indent">With a bit more effort, I was also able to create the C# macros I needed to accomplish the same tasks for the C# language bindings:</p>&#13;
<ul>&#13;
<li class="noindent"><code>FLM_PROG_TRY_CSC</code> is defined in <em>flm_prog_try_csc.m4</em>.</li>&#13;
<li class="noindent"><code>FLM_PROG_TRY_CSVM</code> is defined in <em>flm_prog_try_csvm.m4</em>.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_412"/><a href="ch15.xhtml#ch15ex4">Listing 15-4</a> shows the portion of the xflaim <em>configure.ac</em> file that invokes these Java and C# macros.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
# Checks for optional programs.&#13;
FLM_PROG_TRY_CSC&#13;
FLM_PROG_TRY_CSVM&#13;
FLM_PROG_TRY_JNI&#13;
FLM_PROG_TRY_JAVADOC&#13;
<span class="codeitalic1">--snip--</span>&#13;
# Automake conditionals.&#13;
AM_CONDITIONAL([HAVE_JAVA], [test "x$flm_prog_have_jni" = xyes])&#13;
AM_CONDITIONAL([HAVE_CSHARP], [test -n "$CSC"])&#13;
<span class="codeitalic1">--snip</span><span class="codeitalic1">--</span></pre>&#13;
<p class="caption" id="ch15ex4"><em>Listing 15-4:</em> xflaim/configure.ac: <em>The portion of this file that searches for Java and C# tools</em></p>&#13;
<p class="indent">These macros set the <code>CSC</code>, <code>CSVM</code>, <code>JAVAC</code>, <code>JAVAH</code>, <code>JAVADOC</code>, and <code>JAR</code> variables to the location of their respective C# and Java tools and then substitute them into the xflaim project’s <em>Makefile.in</em> templates using <code>AC_SUBST</code>. If any of these variables are already set in the user’s environment when the <code>configure</code> script is executed, their values are left untouched, thus allowing the user to override the values that would have been set by the macros.</p>&#13;
<p class="indent">I discuss the internal operation of these macros in <a href="ch16.xhtml">Chapter 16</a>.</p>&#13;
<h4 class="h4" id="ch15sec1-3"><em>Canonical System Information</em></h4>&#13;
<p class="noindent">The only non-obvious bit of information you need to know about using macros from the GNU Autoconf Archive is that many of them rely on the built-in Autoconf macro, <code>AC_CANONICAL_HOST</code>. Autoconf provides a way to automatically expand any macros used internally by a macro definition right before the definition so that required macros are made available immediately. However, if <code>AC_CANONICAL_HOST</code> is not used before certain macros (including <code>LT_INIT</code>), <code>autoreconf</code> will generate about a dozen warning messages.</p>&#13;
<p class="indent">To eliminate these warnings, I added <code>AC_CANONICAL_TARGET</code> to my xflaim-level <em>configure.ac</em> file, immediately after the call to <code>AC_INIT</code>. The <code>AC_CANONICAL_SYSTEM</code> macro, and the macros that it calls (<code>AC_CANONICAL_BUILD</code>, <code>AC_CANONICAL_HOST</code>, and <code>AC_CANONICAL_TARGET</code>), are designed to ensure that the <code>$build</code>, <code>$host</code>, and <code>$target</code> environment variables are defined by <code>configure</code> to contain appropriate values describing the user’s build, host, and target systems, respectively. Because I’m not doing any cross-compiling in this build system, I only needed to invoke <code>AC_CANONICAL_TARGET</code>.</p>&#13;
<p class="indent">These variables contain canonical values for the build, host, and target CPU, vendor, and operating system. Values like these are very useful to extension macros. If a macro can assume these variables are set properly, then it saves quite a bit of code duplication in the macro definition.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_413"/>The values of these variables are calculated using the helper scripts <code>config .guess</code> and <code>config.sub</code>, which are distributed with Autoconf.<sup><a id="ch15fn_9" href="footnote.xhtml#ch15fn9">9</a></sup> The <code>config.guess</code> script uses a combination of <code>uname</code> commands to ferret out information about the build system, then uses that information to derive a set of canonical values for CPU, vendor, and operating system. The <code>config.sub</code> script is used to reformat build, host, and target information specified by the user on the <code>configure</code> command line into a canonical value. The host and target values default to that of the build, unless you override them with command line options to <code>configure</code>. Such an override might be used when cross-compiling. (See “Item 6: Cross-Compiling” on <a href="ch18.xhtml#page_517">page 517</a> for a more detailed explanation of cross-compiling within the Autotools framework.)</p>&#13;
<h4 class="h4" id="ch15sec1-4"><em>The xflaim/java Directory Structure</em></h4>&#13;
<p class="noindent">The original xflaim source layout had the Java JNI and C# native sources located in directory structures outside of <em>xflaim/src</em>. The JNI sources were in <em>xflaim/java/jni</em>, and the C# native sources were in <em>xflaim/csharp/xflaim</em>. While Automake can generate rules for accessing files outside the current directory hierarchy, it seems silly to put these files so far away from the only library they can really belong to. Therefore, in this case, I broke my own rule about not rearranging files and moved the contents of these two directories beneath <em>xflaim/src</em>. I named the JNI directory <em>xflaim/src/java</em> and the C# native sources directory <em>xflaim/src/cs</em>. The following diagram illustrates this new directory hierarchy:</p>&#13;
<pre>flaim&#13;
  xflaim&#13;
    src&#13;
      cs&#13;
        wrapper&#13;
      java&#13;
        wrapper&#13;
          xflaim</pre>&#13;
<p class="indent">As you can see, I also added a <em>wrapper</em> directory beneath the <em>java</em> directory, in which I rooted the xflaim wrapper package hierarchy. Since the Java xflaim wrapper classes are part of the Java xflaim package, they must be located in a directory called <em>xflaim</em>. Nevertheless, the build happens in the wrapper directory. There are no build files found in the <em>wrapper/xflaim</em> directory or any directories below that point.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_414"/><em>No matter how deep your package hierarchy is, you will still build the Java classes in the</em> wrapper <em>directory, which is the <em><code>JAVAROOT</code></em> directory for this project. Autotools Java projects consider the <em><code>JAVAROOT</code></em> directory the build directory for the java package.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch15sec1-5"><em>The xflaim/src/Makefile.am File</em></h4>&#13;
<p class="noindent">At this point, the <em>configure.ac</em> file is doing about all it can to ensure that I have a good Java build environment, in which case my build system will be able to generate my JNI wrapper classes and header files and build my C++ JNI sources. If my end user’s system doesn’t provide these tools, they simply won’t be able to build or link the JNI language bindings to the <em>xflaim</em> library on that host.</p>&#13;
<p class="indent">Have a look at the <em>xflaim/src/Makefile.am</em> file shown in <a href="ch15.xhtml#ch15ex5">Listing 15-5</a> and examine the portions that are relevant to building the Java and C# language bindings.</p>&#13;
<pre>if HAVE_JAVA&#13;
  JAVADIR = java&#13;
  JNI_LIBADD = java/libxfjni.la&#13;
endif&#13;
&#13;
if HAVE_CSHARP&#13;
  CSDIR = cs&#13;
  CSI_LIBADD = cs/libxfcsi.la&#13;
endif&#13;
&#13;
SUBDIRS = $(JAVADIR) $(CSDIR)&#13;
<span class="codeitalic1">--snip--</span>&#13;
libxflaim_la_LIBADD = $(JNI_LIBADD) $(CSI_LIBADD) $(FTK_LTLIB)&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch15ex5"><em>Listing 15-5</em>: xflaim/src/Makefile.am: <em>The portion of this makefile that builds Java and C# sources</em></p>&#13;
<p class="indent">I’ve already explained the use of the conditionals to ensure that the <em>java</em> and <em>cs</em> directories are only built if the proper conditions are met. You can now see how this fits into the build system I’ve created so far.</p>&#13;
<p class="indent">Notice that I’m conditionally defining two new library variables. If I can build the Java language bindings, the <em>java</em> subdirectory will be built, and the <code>JNI_LIBADD</code> variable will refer to the library that is built in the <em>java</em> directory. If I can build the C# language bindings, the <em>cs</em> subdirectory will be built, and the <code>CSI_LIBADD</code> variable will refer to the library that is built in the <em>cs</em> directory. In either case, if the required tools are not found by <code>configure</code>, the corresponding variable will remain undefined. When an undefined <code>make</code> variable is referenced, it expands to nothing, so there’s no harm in using it in <code>libxflaim_la_LIBADD</code>.</p>&#13;
<h4 class="h4" id="ch15sec1-6"><span epub:type="pagebreak" id="page_415"/><em>Building the JNI C++ Sources</em></h4>&#13;
<p class="noindent">Now turn your attention to the <em>xflaim/src/java/Makefile.am</em> file shown in <a href="ch15.xhtml#ch15ex6">Listing 15-6</a>.</p>&#13;
<pre>SUBDIRS = wrapper&#13;
&#13;
XFLAIM_INCLUDE = -I$(srcdir)/..&#13;
&#13;
noinst_LTLIBRARIES = libxfjni.la&#13;
&#13;
libxfjni_la_SOURCES = \&#13;
 jbackup.cpp \&#13;
 jdatavector.cpp \&#13;
 jdb.cpp \&#13;
 jdbsystem.cpp \&#13;
 jdomnode.cpp \&#13;
 jistream.cpp \&#13;
 jniftk.cpp \&#13;
 jniftk.h \&#13;
 jnirestore.cpp \&#13;
 jnirestore.h \&#13;
 jnistatus.cpp \&#13;
 jnistatus.h \&#13;
 jostream.cpp \&#13;
 jquery.cpp&#13;
&#13;
libxfjni_la_CPPFLAGS = $(XFLAIM_INCLUDE) $(FTK_INCLUDE)</pre>&#13;
<p class="caption" id="ch15ex6"><em>Listing 15-6</em>: xflaim/src/java/Makefile.am: <em>This makefile builds the JNI sources.</em></p>&#13;
<p class="indent">Again, I want the <em>wrapper</em> directory to be built first (the dot at the end of the <code>SUBDIRS</code> list is implied), before the <em>xflaim</em> library, because the <em>wrapper</em> directory will build the class files and JNI header files required by the JNI convenience library sources. Building this directory is not conditional. If I’ve made it this far into the build hierarchy, I know I have all the Java tools I need. This <em>Makefile.am</em> file simply builds a convenience library containing my JNI C++ interface functions.</p>&#13;
<p class="indent">Because of the way Libtool builds both shared and static libraries from the same sources, this convenience library will become part of both the <em>xflaim</em> shared and static libraries. The original build system makefile accounted for this by linking the JNI and C# native interface objects only into the shared library (where they make sense).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The fact that these libraries are added to both the shared and static</em> xflaim <em>libraries is not really a problem. Objects in a static library remain unused in applications or libraries linking to the static library, as long as functions and data in those objects remain unreferenced, though this is a bit of a wart on my new build system.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch15sec1-7"><span epub:type="pagebreak" id="page_416"/><em>The Java Wrapper Classes and JNI Headers</em></h4>&#13;
<p class="noindent">Finally, <em>xflaim/src/java/wrapper/Makefile.am</em> takes us to the heart of the matter. I’ve tried many different configurations for building Java JNI wrappers, and this one always comes out on top. <a href="ch15.xhtml#ch15ex7">Listing 15-7</a> shows the <em>wrapper</em> directory’s Automake input file.</p>&#13;
<pre>   JAVAROOT = .&#13;
&#13;
<span class="ent">➊</span> jarfile = $(PACKAGE)jni-$(VERSION).jar&#13;
<span class="ent">➋</span> jardir = $(datadir)/java&#13;
   pkgpath = xflaim&#13;
   jhdrout = ..&#13;
&#13;
   $(jarfile): $(dist_noinst_JAVA)&#13;
           $(JAR) cvf $(JARFLAGS) $@ $(pkgpath)/*.class&#13;
&#13;
<span class="ent">➌</span> jar_DATA = $(jarfile)&#13;
&#13;
   java-headers.stamp: $(classdist_noinst.stamp)&#13;
           @list=`echo $(dist_noinst_JAVA) | sed -e 's|\.java||g' -e 's|/|.|g'`;\&#13;
             echo "$(JAVAH) -cp . -jni -d $(jhdrout) $(JAVAHFLAGS) $$list"; \&#13;
             $(JAVAH) -cp . -jni -d $(jhdrout) $(JAVAHFLAGS) $$list&#13;
        <span class="ent">➍</span> @echo "JNI headers generated" &gt; java-headers.stamp&#13;
&#13;
<span class="ent">➎</span> all-local: java-headers.stamp&#13;
&#13;
<span class="ent">➏</span> CLEANFILES = $(jarfile) $(pkgpath)/*.class java-headers.stamp\&#13;
    $(jhdrout)/xflaim_*.h&#13;
&#13;
   dist_noinst_JAVA = \&#13;
    $(pkgpath)/BackupClient.java \&#13;
    $(pkgpath)/Backup.java \&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    $(pkgpath)/XFlaimException.java \&#13;
    $(pkgpath)/XPathAxis.java</pre>&#13;
<p class="caption" id="ch15ex7"><em>Listing 15-7</em>: xflaim/src/java/wrapper/Makefile.am: <em>The wrapper directory’s</em> Makefile.am <em>file</em></p>&#13;
<p class="indent">At the top of the file, I’ve set the <code>JAVAROOT</code> variable to dot (<code>.</code>), because I want Automake to be able to tell the Java compiler that this is where the package hierarchy begins. The default value for <code>JAVAROOT</code> is <code>$(top_builddir)</code>, which would incorrectly have the wrapper class belong to the <em>xflaim.src.java.wrapper.xflaim</em> package.</p>&#13;
<p class="indent">I create a variable at <span class="ent">➊</span> called <code>jarfile</code>, which derives its value from <code>$(PACKAGE</code><code>_TARNAME)</code> and <code>$(PACKAGE_VERSION)</code>. (Recall from <a href="ch03.xhtml">Chapter 3</a> that this is also how the <code>distdir</code> variable is derived, from which the name of the tarball comes.) A <code>make</code> rule indicates how the <em>.jar</em> file should be built. Here, I’m using the <code>JAR</code> variable, whose value was calculated by the <code>FLM_PROG_TRY_JNI</code> macro in the <code>configure</code> script.</p>&#13;
<p class="indent">I define a new installation variable at <span class="ent">➋</span> called <code>jardir</code> where <em>.jar</em> files are to be installed, and I use that variable as the prefix for a <code>DATA</code> primary <span epub:type="pagebreak" id="page_417"/>at <span class="ent">➌</span>. Automake considers files that fit the Automake <em><code>where_HOW</code></em> scheme (with a defined <em><code>where</code></em><code>dir</code>) as either architecture-independent data files or platform-specific executables. Installation location variables (those ending in <code>dir</code>) that begin with <code>bin</code>, <code>sbin</code>, <code>libexec</code>, <code>sysconf</code>, <code>localstate</code>, <code>lib</code>, or <code>pkglib</code> or that contain the string “exec” are considered platform-specific executables and are installed during execution of the <code>install-exec</code> target. Automake considers files installed in any other locations data files. These are installed during execution of the <code>install-data</code> target. The well-known installation locations such as <em>bindir</em>, <em>sbindir</em>, and so on are already taken, but if you want to install custom architecture-dependent executable files, just ensure that your custom installation location variable contains the string “exec,” as in <code>myspecialexecdir</code>.</p>&#13;
<p class="indent">I use another stamp file at <span class="ent">➍</span> in the rule that builds the JNI header files from the <em>.class</em> files for the same reasons that Automake uses a stamp file in the rule that it uses to build <em>.class</em> files from <em>.java</em> source files.</p>&#13;
<p class="indent">This is the most complex part of this makefile, so I’ll break it into smaller pieces.</p>&#13;
<p class="indent">The rule states that the stamp file depends on the source files listed in the <code>dist_noinst_JAVA</code> variable. The command is a bit of complex shell script that strips the <em>.java</em> extensions from the file list and converts all the slash characters into periods. The reason for this is that the <code>javah</code> utility wants a list of class names, not a list of filenames. The <code>$(JAVAH)</code> command then accepts this entire list as input in order to generate a corresponding list of JNI header files. The last line, of course, generates the stamp file.</p>&#13;
<p class="indent">Finally at <span class="ent">➎</span>, I hook my <code>java-headers.stamp</code> target into the <code>all</code> target by adding it as a dependency to the <code>all-local</code> target. When the <code>all</code> target (the default for all Automake-generated makefiles) is executed in this makefile, <em>java-headers.stamp</em> will be built, along with the JNI headers.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It’s a good idea to add custom rule targets as dependencies to the Automake-provided hook and local targets, rather than directly associating commands with these hook and local targets. By doing this, the commands for individual tasks on those targets remain isolated and thus easier to maintain.</em></p>&#13;
</div>&#13;
<p class="indent">I add the <em>.jar</em> file, all of the <em>.class</em> files, the <em>java-headers.stamp</em> file, and all of the generated JNI header files to the <code>CLEANFILES</code> variable at <span class="ent">➏</span> so that Automake will clean them up when <code>make clean</code> is executed. Again, I can use the <code>CLEANFILES</code> variable here because I’m not trying to delete any directories.</p>&#13;
<p class="indent">The final step in writing any such custom code is to ensure that the <code>distcheck</code> target still works, because when we generate our own products, we have to ensure that the <code>clean</code> target properly removes them all.</p>&#13;
<p class="indent">Finally, I should mention that the rule to build the <em>.jar</em> file, near the top of <a href="ch15.xhtml#ch15ex7">Listing 15-7</a>, relies on a wildcard to pick up all the <em>.class</em> files in the <em>xflaim</em> directory. The Autotools purposely avoid such wildcards for many reasons, including the very valid reason that you may inadvertently pick up files that were built by a previous build that are no longer relevant to your project after changes eliminate those sources from the project. For Java, the only way to specify the exact <em>.class</em> files that should go into the <em>.jar</em> file is to parse <span epub:type="pagebreak" id="page_418"/>all the <em>.java</em> files and derive a list of <em>.class</em> files that would be built from those sources. I made a judgment call here and decided that using a wildcard was worth the possible problems doing so may cause. I also used wildcards in the <code>CLEANFILES</code> variable near the bottom of <a href="ch15.xhtml#ch15ex7">Listing 15-7</a>. Of course, the same potential problems exist here—you could remove a file that is present but no longer associated with the build.</p>&#13;
<h4 class="h4" id="ch15sec1-8"><em>A Caveat About Using the JAVA Primary</em></h4>&#13;
<p class="noindent">The one important caveat to using the <code>JAVA</code> primary is that you may define only one <code>JAVA</code> primary variable per <em>Makefile.am</em> file. The reason for this is that multiple classes may be generated from a single <em>.java</em> file, and the only way to know which classes came from which <em>.java</em> file would be for Automake to parse the <em>.java</em> files (which is ridiculous, and arguably the primary reason why build tools like <em>Apache Ant</em> and <em>Maven</em> were developed). Rather than do this, Automake allows only one <code>JAVA</code> primary per file, so all <em>.class</em> files generated within a given build directory are installed in the location specified by the single <code>JAVA</code> primary variable prefix.<sup><a id="ch15fn_10" href="footnote.xhtml#ch15fn10">10</a></sup></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The system I’ve designed will work fine for this case, but it’s a good thing I don’t need to install my JNI header files, because I have no way of knowing what they’re called from within my</em> Makefile.am <em>file</em>!</p>&#13;
</div>&#13;
<p class="indent">You should by now be able to see the problems that the Autotools have with Java. In fact, these problems are not so much related to the design issues in the Autotools as they are to design issues within the Java language itself, as you’ll see in the next section.</p>&#13;
<h3 class="h3" id="ch15sec2">Building the C# Sources</h3>&#13;
<p class="noindent">Returning to the <em>xflaim/src/cs</em> directory brings us to a discussion of building sources for a language for which Automake has no support: C#. <a href="ch15.xhtml#ch15ex8">Listing 15-8</a> shows the <em>Makefile.am</em> file that I wrote for the <em>cs</em> directory.</p>&#13;
<pre>SUBDIRS = wrapper&#13;
&#13;
XFLAIM_INCLUDE = -I$(srcdir)/..&#13;
&#13;
noinst_LTLIBRARIES = libxfcsi.la&#13;
&#13;
libxfcsi_la_SOURCES = \&#13;
 Backup.cpp \&#13;
<span epub:type="pagebreak" id="page_419"/> DataVector.cpp \&#13;
 Db.cpp \&#13;
 DbInfo.cpp \&#13;
 DbSystem.cpp \&#13;
 DbSystemStats.cpp \&#13;
 DOMNode.cpp \&#13;
 IStream.cpp \&#13;
 OStream.cpp \&#13;
 Query.cpp&#13;
&#13;
libxfcsi_la_CPPFLAGS = $(XFLAIM_INCLUDE) $(FTK_INCLUDE)</pre>&#13;
<p class="caption" id="ch15ex8"><em>Listing 15-8</em>: xflaim/src/cs/Makefile.am: <em>The contents of the cs directory’s Automake input file</em></p>&#13;
<p class="indent">Not surprisingly, this looks almost identical to the <em>Makefile.am</em> file found in the <em>xflaim/src/java</em> directory because I’m building a simple convenience library from C++ source files found in this directory, just as I did in the <em>java</em> directory. As in the Java version, this makefile first builds a subdirectory called <em>wrapper</em>.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex9">Listing 15-9</a> shows the full contents of the <em>wrapper/Makefile.am</em> file.</p>&#13;
<pre>   EXTRA_DIST = xflaim cstest sample xflaim.ndoc&#13;
&#13;
   xfcs_sources = \&#13;
    xflaim/BackupClient.cs \&#13;
    xflaim/Backup.cs \&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    xflaim/RestoreClient.cs \&#13;
    xflaim/RestoreStatus.cs&#13;
&#13;
   cstest_sources = \&#13;
    cstest/BackupDbTest.cs \&#13;
    cstest/CacheTests.cs \&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    cstest/StreamTests.cs \&#13;
    cstest/VectorTests.cs&#13;
&#13;
   TESTS = cstest_script&#13;
&#13;
   AM_CSCFLAGS = -d:mono -nologo -warn:4 -warnaserror+ -optimize+&#13;
   #AM_CSCFLAGS += -debug+ -debug:full -define:FLM_DEBUG&#13;
&#13;
<span class="ent">➊</span> all-local: xflaim_csharp.dll&#13;
&#13;
   clean-local:&#13;
           rm -f xflaim_csharp.dll xflaim_csharp.xml cstest_script\&#13;
             cstest.exe libxflaim.so&#13;
           rm -f Output_Stream&#13;
           rm -rf abc backup test.*&#13;
&#13;
   install-exec-local:&#13;
           test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"&#13;
           $(INSTALL_PROGRAM) xflaim_csharp.dll "$(DESTDIR)$(libdir)"&#13;
&#13;
   <span epub:type="pagebreak" id="page_420"/>install-data-local:&#13;
           test -z "$(docdir)" || $(MKDIR_P) "$(DESTDIR)$(docdir)"&#13;
           $(INSTALL_DATA) xflaim_csharp.xml "$(DESTDIR)$(docdir)"&#13;
&#13;
   uninstall-local:&#13;
           rm -f "$(DESTDIR)$(libdir)/xflaim_csharp.dll"&#13;
           rm -f "$(DESTDIR)$(docdir)/xflaim_csharp.xml"&#13;
&#13;
<span class="ent">➋</span> xflaim_csharp.dll: $(xfcs_sources)&#13;
           @list1='$(xfcs_sources)'; list2=; if test -n "$$list1"; then \&#13;
             for p in $$list1; do \&#13;
               if test -f $$p; then d=; else d="$(srcdir)/"; fi; \&#13;
               list2="$$list2 $$d$$p"; \&#13;
             done; \&#13;
             echo '$(CSC) -target:library $(AM_CSCFLAGS) $(CSCFLAGS) -out:$@\&#13;
               -doc:$(@:.dll=.xml) '"$$list2";\&#13;
             <span class="codestrong1">$(CSC) -target:library $(AM_CSCFLAGS) $(CSCFLAGS) \</span>&#13;
               <span class="codestrong1">-out:$@ -doc:$(@:.dll=.xml) $$list2</span>; \&#13;
           else :; fi&#13;
&#13;
   check_SCRIPTS = cstest.exe cstest_script&#13;
&#13;
<span class="ent">➌</span> cstest.exe: xflaim_csharp.dll $(cstest_sources)&#13;
          @list1='$(cstest_sources)'; list2=; if test -n "$$list1"; then \&#13;
             for p in $$list1; do \&#13;
               if test -f $$p; then d=; else d="$(srcdir)/"; fi; \&#13;
               list2="$$list2 $$d$$p"; \&#13;
             done; \&#13;
             echo '$(CSC) $(AM_CSCFLAGS) $(CSCFLAGS) -out:$@ '"$$list2"'\&#13;
               -reference:xflaim_csharp.dll'; \&#13;
             <span class="codestrong1">$(CSC) $(AM_CSCFLAGS) $(CSCFLAGS) -out:$@ $$list2 \</span>&#13;
               <span class="codestrong1">-reference:xflaim_csharp.dll; \</span>&#13;
          else :; fi&#13;
&#13;
<span class="ent">➍</span> cstest_script: cstest.exe&#13;
           echo "#!/bin/sh" &gt; cstest_script&#13;
           echo "$(top_builddir)/libtool --mode=execute \&#13;
           <span class="ent">➎</span> -dlopen=../../libxflaim.la $(CSVM) cstest.exe" &gt;&gt; cstest_script&#13;
           chmod 0755 cstest_script</pre>&#13;
<p class="caption" id="ch15ex9"><em>Listing 15-9</em>: xflaim/src/cs/wrapper/Makefile.am: <em>The full contents of the C# makefile</em></p>&#13;
<p class="indent">The default target for <em>Makefile.am</em> is <code>all</code>, the same as that of a normal non-Automake makefile. Again, I’ve hooked my code into the <code>all</code> target by implementing the <code>all-local</code> target, which depends on a file named <em>xflaim_csharp.dll</em>.<sup><a id="ch15fn_11" href="footnote.xhtml#ch15fn11">11</a></sup></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_421"/>The C# sources are built by the commands under the <em>xflaim_csharp.dll</em> target at <span class="ent">➋</span>, and the <em>xflaim_csharp.dll</em> binary depends on the list of C# source files specified in the <code>xfcs_sources</code> variable. The commands in this rule are copied from the Automake-generated <em>java/wrapper/Makefile</em> and are slightly modified to build C# binaries from C# source files (as highlighted in the listing). This isn’t intended to be a lesson in building C# sources; the point here is that the default target is automatically built by creating a dependency between the <code>all-local</code> target and your own targets at <span class="ent">➊</span>.</p>&#13;
<p class="indent">This <em>Makefile.am</em> file also builds a set of unit tests in C# that assess the C# language bindings. The target of this rule is <em>cstest.exe</em> (<span class="ent">➌</span>), which ultimately becomes a C# executable. The rule states that <em>cstest.exe</em> depends on <em>xflaim_csharp.dll</em> and the source files. I’ve again copied the commands from the rule for building <em>xflaim_csharp.dll</em> (as highlighted) and modified them for building the C# programs.</p>&#13;
<p class="indent">Ultimately, upon building the <code>check</code> target, the Automake-generated makefile will attempt to execute the scripts or executables listed in the <code>TESTS</code> variable. The idea here is to ensure that all necessary components are built before these files are executed. I’ve tied into the <code>check</code> target by defining <code>check-local</code> and making it depend on my test code targets.</p>&#13;
<p class="indent">The <code>cstest_script</code> at <span class="ent">➍</span> is a shell script built solely to execute the <em>cstest.exe</em> binary within the C# virtual machine. The C# virtual machine is found in the <code>CSVM</code> variable, which was defined in <code>configure</code> by the code generated by the <code>FLM_PROG_TRY_CSVM</code> macro.</p>&#13;
<p class="indent">The <code>cstest_script</code> depends only on the <code>cstest.exe</code> program. However, the <em>xflaim</em> library either must be present in the current directory or must be in the system library search path. We gain maximum portability here by using Libtool’s <em>execute</em> mode to add the <em>xflaim</em> library to the system library search path before executing the C# virtual machine at <span class="ent">➎</span>.</p>&#13;
<h4 class="h4" id="ch15sec2-1"><em>Manual Installation</em></h4>&#13;
<p class="noindent">Since in this example I’m doing everything myself, I have to write my own installation rules. <a href="ch15.xhtml#ch15ex10">Listing 15-10</a> reproduces only the installation rules in the <em>Makefile.am</em> file from <a href="ch15.xhtml#ch15ex9">Listing 15-9</a>.</p>&#13;
<pre><span class="codeitalic1">--</span><span class="codeitalic1">snip--</span>&#13;
install-exec-local:&#13;
        test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"&#13;
        $(INSTALL_PROGRAM) xflaim_csharp.dll "$(DESTDIR)$(libdir)"&#13;
&#13;
install-data-local:&#13;
        test -z "$(docdir)" || $(MKDIR_P) "$(DESTDIR)$(docdir)"&#13;
        $(INSTALL_DATA) xflaim_csharp.xml "$(DESTDIR)$(docdir)"&#13;
&#13;
uninstall-local:&#13;
        rm -f "$(DESTDIR)$(libdir)/xflaim_csharp.dll"&#13;
        rm -f "$(DESTDIR)$(docdir)/xflaim_csharp.xml"&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch15ex10"><em>Listing 15-10</em>: xflaim/src/cs/wrapper/Makefile.am: <em>The installation rules of this makefile</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_422"/>According to the rules defined in the <em>GNU Coding Standards</em>, the installation targets do not depend on the binaries they install, so if the binaries haven’t been built yet, I may have to exit from <em>root</em> to my user account to build the binaries with <code>make all</code> first.</p>&#13;
<p class="indent">Automake distinguishes between installing programs and installing data. However, there’s only one <code>uninstall</code> target. The rationale seems to be that you might want to do an <code>install-exec</code> operation per system in your network, but only one shared <code>install-data</code> operation. Uninstalling a product requires no such separation, because uninstalling data multiple times is typically harmless.</p>&#13;
<h4 class="h4" id="ch15sec2-2"><em>Cleaning Up Again</em></h4>&#13;
<p class="noindent">As usual, things must be cleaned up properly in order to make distribution checks happy. The <code>clean-local</code> target handles this nicely, as shown in <a href="ch15.xhtml#ch15ex11">Listing 15-11</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
clean-local:&#13;
        rm -f xflaim_csharp.dll xflaim_csharp.xml cstest_script \&#13;
          cstest.exe libxflaim.so&#13;
        rm -f Output_Stream&#13;
        rm -rf abc backup test.*&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch15ex11"><em>Listing 15-11</em>: xflaim/src/cs/wrapper/Makefile.am: <em>The clean rules defined in this makefile</em></p>&#13;
<h3 class="h3" id="ch15sec3">Configuring Compiler Options</h3>&#13;
<p class="noindent">The original GNU Make build system provided a number of command line build options. By specifying a list of auxiliary targets on the <code>make</code> command line, the user could indicate that they wanted a debug or release build, force a 32-bit build on a 64-bit system, generate generic SPARC code on a Solaris system, and so on. This was a turnkey approach to build systems that is quite common in commercial code.</p>&#13;
<p class="indent">In open source projects, and particularly in Autotools-based build systems, the more common practice is to omit much of this rigid framework, allowing the user to set their own options in the standard user variables: <code>CC</code>, <code>CPP</code>, <code>CXX</code>, <code>CFLAGS</code>, <code>CXXFLAGS</code>, <code>CPPFLAGS</code>, and so on.<sup><a id="ch15fn_12" href="footnote.xhtml#ch15fn12">12</a></sup></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_423"/>Probably the most compelling argument for the Autotools approach to option management is that it’s policy driven and the rigid frameworks used by commercial software vendors can easily be implemented in terms of the much more flexible policy-driven Autotools framework. For example, a <em>config.site</em> file might be used to provide site-wide options for all Autotools-based builds done at a particular site. A simple script can be used to configure various environment-based options before calling <code>configure</code>, or these options may even be passed to <code>configure</code> or <code>make</code> directly within such a script. The Autotools policy-driven approach offers the flexibility to be as configurable as a developer might want or as tight as required by management.</p>&#13;
<p class="indent">Ultimately, we’d like to have FLAIM project options conform to the Autotools policy-driven approach; however, I didn’t want to lose the research effort involved in determining the hardcoded native compiler options specified in the original makefile. To this end, I’ve added back in <em>some</em> of the options to the <em>configure.ac</em> file that were supported by the original build system, but I’ve left others out. <a href="ch15.xhtml#ch15ex12">Listing 15-12</a> shows the end result of these efforts. This code enables various native compiler options, optimizations, and debugging features on demand, based on the contents of some of the user variables.</p>&#13;
<pre>   <span class="codeitalic1">--snip--</span>&#13;
   # Configure supported platforms' compiler and linker flags&#13;
<span class="ent">➊</span> case $host in&#13;
     sparc-*-solaris*)&#13;
       LDFLAGS="$LDFLAGS -R /usr/lib/lwp"&#13;
       case $CXX in&#13;
         *g++*) ;;&#13;
         *)&#13;
           if "x$debug" = xno; then&#13;
             CXXFLAGS="$CXXFLAGS -xO3"&#13;
           fi&#13;
           SUN_STUDIO=`$CXX -V | grep "Sun C++"`&#13;
           if "x$SUN_STUDIO" = "xSun C++"; then&#13;
             CXXFLAGS="$CXXFLAGS -errwarn=%all -errtags\&#13;
               -erroff=hidef,inllargeuse,doubunder"&#13;
           fi ;;&#13;
     esac ;;&#13;
&#13;
   *-apple-darwin*)&#13;
     AC_DEFINE([OSX], [1], [Define if building on Apple OSX.]) ;;&#13;
&#13;
   *-*-aix*)&#13;
     case $CXX in&#13;
       *g++*) ;;&#13;
       *) CXXFLAGS="$CXXFLAGS -qstrict" ;;&#13;
     esac ;;&#13;
&#13;
   *-*-hpux*)&#13;
     case $CXX in&#13;
       *g++*) ;;&#13;
       *)&#13;
         # Disable "Placement operator delete&#13;
<span epub:type="pagebreak" id="page_424"/>         # invocation is not yet implemented" warning&#13;
         CXXFLAGS="$CXXFLAGS +W930" ;;&#13;
     esac ;;&#13;
  esac&#13;
  <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch15ex12"><em>Listing 15-12</em>: xflaim/configure.ac: <em>The portion of this file that enables compiler-specific options</em></p>&#13;
<p class="indent">Remember that this code depends on the earlier use of the <code>AC_CANONICAL_SYSTEM</code> (or <code>AC_CANONICAL_TARGET</code>) macro, which sets <code>build</code>, <code>host</code>, and <code>target</code> environment variables to canonical string values that indicate CPU, vendor, and operating system.</p>&#13;
<p class="indent">In <a href="ch15.xhtml#ch15ex12">Listing 15-12</a>, I used the <code>host</code> variable in the <code>case</code> statement at <span class="ent">➊</span> to determine the type of system for which I was building. This <code>case</code> statement determines if the user is building on Solaris, Apple Darwin, AIX, or HP-UX by looking for substrings in <code>host</code> that are common to all variations of these platforms. The <code>config.guess</code> and <code>config.sub</code> files are your friends here. If you need to write code like this for your project, examine these files to find common traits for the processes and systems for which you’d like to set various compiler and linker options.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In each of these cases (except for the definition of the <em><code>OSX</code></em> preprocessor variable on Apple Darwin systems), I’m really only setting flags for native compilers. The GNU compiler tools seem to be able to handle any code without the need for additional compiler options. It’s worth reiterating here that the Autotools feature-present approach to setting options once again wins. Maintenance is reduced dramatically when you don’t have to support large <em><code>case</code></em> statements for an ever-growing list of supported hosts and tool sets.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch15sec4">Hooking Doxygen into the Build Process</h3>&#13;
<p class="noindent">I want to generate documentation as part of my build process, if possible. That is, if the user has <code>doxygen</code> installed, the build system will use it to build Doxygen documentation as part of the <code>make all</code> process.</p>&#13;
<p class="indent">The original build system has both static and generated documentation. The static documentation should always be installed, but the Doxygen documentation can only be built if the <code>doxygen</code> program is available on the host. Thus, I always build the <em>docs</em> directory, but I use the <code>AM_CONDITIONAL</code> macro to conditionally build the <em>docs/doxygen</em> directory.</p>&#13;
<p class="indent">Doxygen uses a configuration file (often called <em>doxyfile</em>) to configure literally hundreds of Doxygen options. This configuration file contains some information that is known to the configuration script. This sounds like the perfect opportunity to use an Autoconf-generated file. To this end, I’ve written an Autoconf template file called <em>doxyfile.in</em> that contains most of what a normal Doxygen input file would contain, as well as a few Autoconf <span epub:type="pagebreak" id="page_425"/>substitution variable references. The relevant lines in this file are shown in <a href="ch15.xhtml#ch15ex13">Listing 15-13</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
PROJECT_NAME                = @PACKAGE_NAME@&#13;
<span class="codeitalic1">--snip--</span>&#13;
PROJECT_NUMBER              = @PACKAGE_VERSION@&#13;
<span class="codeitalic1">--snip--</span>&#13;
STRIP_FROM_PATH             = @top_srcdir@&#13;
<span class="codeitalic1">--snip--</span>&#13;
INPUT                       = @top_srcdir@/src/xflaim.h&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch15ex13"><em>Listing 15-13</em>: xflaim/docs/doxygen/doxyfile.in: <em>The lines in this file that contain Autoconf variables</em></p>&#13;
<p class="indent">There are many other lines in this file, but they are all identical to the output file, so I’ve omitted them for the sake of space and clarity. The key here is that <code>config.status</code> will replace these substitution variables with their values as defined in <em>configure.ac</em> and by Autoconf itself. If these values change in <em>configure.ac</em>, the generated file will be rewritten with the new values. I’ve added a conditional reference for <em>xflaim/docs/doxygen/doxyfile</em> to the <code>AC_CONFIG_FILES</code> list in xflaim’s <em>configure.ac</em> file. That’s all it takes.</p>&#13;
<p class="indent"><a href="ch15.xhtml#ch15ex14">Listing 15-14</a> shows the <em>xflaim/docs/doxygen/Makefile.am</em> file.</p>&#13;
<pre><span class="ent">➊</span> docpkg = $(PACKAGE_TARNAME)-doxy-$(PACKAGE_VERSION).tar.gz&#13;
&#13;
<span class="ent">➋</span> doc_DATA = $(docpkg)&#13;
&#13;
<span class="ent">➌</span> $(docpkg): doxygen.stamp&#13;
           tar chof - html | gzip -9 -c &gt;$@&#13;
&#13;
   doxygen.stamp: doxyfile&#13;
           $(DOXYGEN) $(DOXYFLAGS) $&lt;&#13;
           echo Timestamp &gt; $@&#13;
&#13;
<span class="ent">➍</span> install-data-hook:&#13;
           cd $(DESTDIR)$(docdir) &amp;&amp; tar xf $(docpkg)&#13;
&#13;
   uninstall-data-hook:&#13;
           cd $(DESTDIR)$(docdir) &amp;&amp; rm -rf html&#13;
&#13;
<span class="ent">➎</span> CLEANFILES = doxywarn.txt doxygen.stamp $(docpkg)&#13;
&#13;
   clean-local:&#13;
           rm -rf html</pre>&#13;
<p class="caption" id="ch15ex14"><em>Listing 15-14</em>: xflaim/docs/doxygen/Makefile.am: <em>The full contents of this makefile</em></p>&#13;
<p class="indent">Here, I create a package name at <span class="ent">➊</span> for the tarball that will contain the Doxygen documentation files. This is basically the same as the distribution tarball for the xflaim project, except that it contains the text <code>-doxy</code> after the package name.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_426"/>I define a <code>doc_DATA</code> variable at <span class="ent">➋</span> that contains the name of the Doxygen tarball. This file will be installed in the <code>$(docdir)</code> directory, which by default is <code>$(datarootdir)</code><em>/doc/</em><code>$(PACKAGE_TARNAME)</code>, and <code>$(datarootdir)</code> is configured by Automake as <code>$(prefix)</code><em>/share</em>, by default.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The</em> <code>DATA</code> <em>primary brings with it significant Automake functionality—installation is managed automatically. While I must build the Doxygen documentation package, the</em> <code>DATA</code> <em>primary automatically hooks the</em> <code>all</code> <em>target for me so that my package is built when the user executes</em> <code>make</code> <em>or</em> <code>make all</code>.</p>&#13;
</div>&#13;
<p class="indent">I use another stamp file at <span class="ent">➌</span> because Doxygen generates literally hundreds of <em>.html</em> files from the source files in my project. Rather than attempt to figure out a rational way to assign dependencies, I’ve chosen to generate one stamp file and then use that to determine whether the documentation is out-of-date.<sup><a id="ch15fn_13" href="footnote.xhtml#ch15fn13">13</a></sup></p>&#13;
<p class="indent">I also decided that it would be nice to unpack the documentation archive into the package <em>doc</em> directory. Left up to Automake, the tarball would make it into the proper directory at installation time, but that’s as far as it would go. I needed to be able to hook the installation process to do this, and this is the perfect use for an Automake <code>-hook</code> target. I use the <code>install-data-hook</code> target at <span class="ent">➍</span> because the <code>-hook</code> targets allow you to perform extra user-defined shell commands after the operation that’s being hooked has completed. Likewise, I use <code>uninstall-hook</code> to remove the <em>html</em> directory created when the <em>.tar</em> file was extracted during installation. (There is no distinction between uninstalling platform-specific and platform-independent files, so there is only one hook for uninstalling files.)</p>&#13;
<p class="indent">To clean my generated files, I use a combination of the <code>CLEANFILES</code> variable at <span class="ent">➎</span> and a <code>clean-local</code> rule just to demonstrate that it can be done.</p>&#13;
<h3 class="h3" id="ch15sec5">Adding Nonstandard Targets</h3>&#13;
<p class="noindent">Adding a new nonstandard target is a little different than hooking an existing target. In the first place, you don’t need to use <code>AM_CONDITIONAL</code> and other Autoconf tests to see if you have the tools you need. Instead, you can do all conditional testing from the <em>Makefile.am</em> file because you control the entire command set associated with the target, although this isn’t recommended practice. (It’s always preferable to ensure that the build environment is configured correctly from the <code>configure</code> script.) In cases where <code>make</code> targets can only be expected to work under certain conditions, or on certain platforms, it’s a good idea to provide checks within the target to ensure that the operation requested can actually be performed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_427"/>To start with, I create a directory within each project root directory called <em>obs</em> to contain the <em>Makefile.am</em> file for building RPM package files. (<em>OBS</em> is an acronym for <em>openSUSE Build Service</em>, an online package-building service.)<sup><a id="ch15fn_14" href="footnote.xhtml#ch15fn14">14</a></sup></p>&#13;
<p class="indent">Building RPM package files is done using a configuration file, called a <em>spec</em> file, which is very much like the <em>doxyfile</em> used to configure Doxygen for a specific project. As with the <em>doxyfile</em>, the RPM spec file references information that <code>configure</code> knows about the package. So, I wrote an <em>xflaim.spec.in</em> file, adding substitution variables where appropriate, and then added another file reference to the <code>AC_CONFIG_FILES</code> macro. This allows <code>configure</code> to substitute information about the project into the spec file. <a href="ch15.xhtml#ch15ex15">Listing 15-15</a> shows the relevant portion of the <em>xflaim.spec.in</em> file in bold.</p>&#13;
<pre>Name: <span class="codestrong1">@PACKAGE_TARNAME@</span>&#13;
BuildRequires: gcc-c++ libstdc++-devel flaimtk-devel gcc-java gjdoc fastjar&#13;
mono-core doxygen&#13;
Requires: libstdc++ flaimtk mono-core java &gt;= 1.4.2&#13;
Summary: XFLAIM is an XML database library.&#13;
URL: http://sourceforge.net/projects/flaim/&#13;
Version: <span class="codestrong1">@PACKAGE_VERSION@</span>&#13;
Release: 1&#13;
License: GPL&#13;
Vendor: Novell, Inc.&#13;
Group: Development/Libraries/C and C++&#13;
Source: %{name}-%{version}.tar.gz&#13;
BuildRoot: %{_tmppath}/%{name}-%{version}-build&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch15ex15"><em>Listing 15-15</em>: x flaim/obs/xflaim.spec.in: <em>The portion of this file that illustrates using Autoconf variables</em></p>&#13;
<p class="indent">Notice the use of the variables <code>@PACKAGE_TARNAME@</code> and <code>@PACKAGE_VERSION@</code> in this listing. Although the tar name is not likely to change much over the life of this project, the version will change often. Without the Autoconf substitution mechanism, I’d have to remember to update this version number whenever I updated the version in the <em>configure.ac</em> file. <a href="ch15.xhtml#ch15ex16">Listing 15-16</a> shows the <em>xflaim/obs/Makefile.am</em> file, which actually does the work of building the RPMs.</p>&#13;
<pre>   rpmspec = $(PACKAGE_TARNAME).spec&#13;
&#13;
   rpmmacros =\&#13;
    --define="_rpmdir $${PWD}"\&#13;
    --define="_srcrpmdir $${PWD}"\&#13;
    --define="_sourcedir $${PWD}/.."\&#13;
    --define="_specdir $${PWD}"\&#13;
    --define="_builddir $${PWD}"&#13;
   <span epub:type="pagebreak" id="page_428"/>RPMBUILD = rpmbuild&#13;
   RPMFLAGS = --nodeps --buildroot="$${PWD}/_rpm"&#13;
&#13;
<span class="ent">➊</span> rpmcheck:&#13;
           if ! ($(RPMBUILD) --version) &gt;/dev/null 2&gt;&amp;1; then \&#13;
             echo "*** This make target requires an rpm-based Linux&#13;
   distribution."; \&#13;
             (exit 1); exit 1; \&#13;
           fi&#13;
&#13;
   srcrpm: rpmcheck $(rpmspec)&#13;
           $(RPMBUILD) $(RPMFLAGS) -bs $(rpmmacros) $(rpmspec)&#13;
&#13;
   rpms: rpmcheck $(rpmspec)&#13;
           $(RPMBUILD) $(RPMFLAGS) -ba $(rpmmacros) $(rpmspec)&#13;
&#13;
   .PHONY: rpmcheck srcrpm rpms</pre>&#13;
<p class="caption" id="ch15ex16"><em>Listing 15-16</em>: xflaim/obs/Makefile.am: <em>The complete contents of this makefile</em></p>&#13;
<p class="indent">Building RPM packages is rather simple, as you can see. The targets provided by this makefile include <code>srcrpm</code> and <code>rpms</code>. The <code>rpmcheck</code> target at <span class="ent">➊</span> is used internally to verify that RPMs can be built in the end user’s environment.</p>&#13;
<p class="indent">In order to find out which targets in a lower-level <em>Makefile.am</em> file are supported by a top-level build, look at the top-level <em>Makefile.am</em> file. As <a href="ch15.xhtml#ch15ex17">Listing 15-17</a> shows, if the target is not passed down, that target must be intended for internal use only, within the lower-level directory.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
RPM = rpm&#13;
&#13;
rpms srcrpm: dist&#13;
     <span class="ent">➊</span> (cd obs &amp;&amp; $(MAKE) $(AM_MAKEFLAGS) $@) || exit 1&#13;
        rpmarch=`$(RPM) --showrc | grep "^build arch" | \&#13;
          sed 's/\(.*: \)\(.*\)/\2/'`; \&#13;
        test -z "obs/$$rpmarch" || \&#13;
          ( mv obs/$$rpmarch/* . &amp;&amp; rm -rf /obs/$$rpmarch )&#13;
        rm -rf obs/$(distdir)&#13;
<span class="codeitalic1">--snip--</span>&#13;
.PHONY: srcrpm rpms</pre>&#13;
<p class="caption" id="ch15ex17"><em>Listing 15-17</em>: xflaim/Makefile.am: <em>If the target is not passed down, it’s an internal target.</em></p>&#13;
<p class="indent">As you can see from the command at <span class="ent">➊</span> in <a href="ch15.xhtml#ch15ex17">Listing 15-17</a>, when a user targets <code>rpms</code> or <code>srcrpm</code> from the top-level build directory, the commands are recursively passed down to <em>obs/Makefile</em>. The remaining commands simply remove droppings left behind by the RPM build process that are simpler to remove at this level. (Try building an RPM package sometime, and you’ll see what I mean!)</p>&#13;
<p class="indent">Notice, too, that both of these top-level makefile targets depend on the <code>dist</code> target because the RPM build process requires the distribution tarball. Adding the tarball as a dependency of the <code>rpms</code> target simply ensures that the distribution tarball is there when the <code>rpmbuild</code> utility needs it.</p>&#13;
<h3 class="h3" id="ch15sec6"><span epub:type="pagebreak" id="page_429"/>Summary</h3>&#13;
<p class="noindent">While using the Autotools, you have many details to manage—most of which, as they say in the open source software world, <em>can wait for the next release</em>! Even as I committed this code to the FLAIM project repository, I noticed details that could be improved. The takeaway lesson here is that a build system is never really finished. It should be incrementally improved over time, as you find time in your schedule to work on it. And it can be rewarding to do so.</p>&#13;
<p class="indent">I’ve shown you a number of new features that have not been covered in earlier chapters, and there are many more features that I cannot begin to cover in this book. Study the Autotools manuals to become truly proficient. At this point, it should be pretty simple for you to pick up that additional information yourself.<span epub:type="pagebreak" id="page_430"/></p>&#13;
</body></html>