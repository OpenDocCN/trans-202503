- en: '12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WORKING WITH AZURE
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With organizations pushing more and more services to the cloud, it’s important
    that automators understand how to work there. Luckily, thanks to PowerShell’s
    modules, and its ability to work with just about any API, working in the cloud
    is a breeze. In this and the next chapter, I’ll show you how to use PowerShell
    to automate tasks; in this chapter, you’ll work with Microsoft Azure, and in the
    next, with Amazon Web Services.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ll be running the code in this chapter, I make a few assumptions about
    your environment. The first is that you have a Microsoft Azure subscription set
    up. You’ll be working with real cloud resources in this chapter, so you will receive
    charges to your account, but the fees should be reasonable. As long as you don’t
    leave any of the virtual machines you’re creating up for too long, the fees should
    be less than $10.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an Azure subscription set up, you’ll need the `Az` PowerShell
    module bundle. This bundle of modules provided by Microsoft has hundreds of commands
    to perform tasks on nearly every Azure service available. You can download it
    by running Install-Module Az in your console (make sure to run as the administrator).
    I should note that I am using version 2.4.0 of the `Az` module. If you’re using
    a later version, I can’t guarantee that all of these commands will work exactly
    the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure gives us a few ways to authenticate to its service. In this chapter, you’ll
    use a service principal. A *service principal* is an Azure application’s identity.
    It is the object that represents an application that can then be assigned various
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Why are you creating a service principal? You want to authenticate to Azure
    by using an automated script that requires no user interaction. To do this, Azure
    requires you to use either a service principal or an organizational account. I
    want everyone to be able to follow along regardless of the type of account they
    have, so you’ll use a service principal to authenticate to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Service Principal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Counterintuitively, the first thing you have to do to create a service principal
    is authenticate the old-fashioned way. To do this, use `Connect-AzAccount`, which
    produces a window like [Figure 12-1](ch12.xhtml#ch12fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/12fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 12-1: The `Connect-AzAccount` credential prompt*'
  prefs: []
  type: TYPE_NORMAL
- en: Provide your Azure username and password, and the window should close, giving
    an output similar to [Listing 12-1](ch12.xhtml#ch12list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: Output from `Connect-AzAccount`*'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to record the subscription ID and tenant ID. You’ll need those in your
    script a little later. If, for some reason, you don’t catch them while authenticating
    with `Connect-AzAccount` here, you can always get them by using the `Get-AzSubscription`
    command later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’re (interactively) authenticated, you can start creating a service
    principal. It’s a three-step process: first, you create a new Azure AD application;
    then, you create the service principal itself; and last, you create a role assignment
    for that service principal.'
  prefs: []
  type: TYPE_NORMAL
- en: You can create the Azure AD application by using whatever name and URI you like
    ([Listing 12-2](ch12.xhtml#ch12list2)). What URI you use doesn’t matter for our
    purposes, but a URI is required to create the AD application. To ensure that you
    have adequate rights to create an AD application, refer to [*https://docs**.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals*](https://docs.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals)*.*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-2: Creating an Azure AD application*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that you’re first creating a secure string by using a password ❶.
    After you have the password in the correct format, you create a new Azure AD application
    ❷. A service principal requires an Azure AD application to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use the `New-AzADServicePrincipal` command to create the service principal,
    as in [Listing 12-3](ch12.xhtml#ch12list3). You reference the application created
    in [Listing 12-2](ch12.xhtml#ch12list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-3: Creating an Azure service principal with PowerShell*'
  prefs: []
  type: TYPE_NORMAL
- en: Last, you need to assign a role to the service principal. [Listing 12-4](ch12.xhtml#ch12list4)
    assigns a `Contributor` role to ensure that the service principal has the access
    it needs to perform all of the tasks in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-4: Creating a role assignment for a service principal*'
  prefs: []
  type: TYPE_NORMAL
- en: With that, the service principal has been created and assigned a role.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left to do is save the encrypted password represented as a secure
    string for the application you just created somewhere on the disk. You can do
    that by using the `ConvertFrom-SecureString` command. The `ConvertFrom-SecureString`
    command (the complement of `ConvertTo-SecureString`) converts encrypted text represented
    as a PowerShell secure string to a general string, allowing you to save and reference
    it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you have the password saved to disk, you’re ready to set up noninteractive
    authentication for Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Noninteractively Authenticating with Connect-AzAccount
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Connect-AzAccount` command prompts you to manually input a username and
    password. In your scripts, you want to be as noninteractive as possible, because
    the last thing you want to do is depend on someone sitting in front of a computer
    to type in your password! Luckily, you can also pass a `PSCredential` object to
    `Connect-AzAccount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll write a small script to handle noninteractive authentication. First,
    let’s create a `PSCredential` object that contains the Azure app ID and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the subscription ID and tenant ID you wrote down earlier? You need
    to pass those into `Connect-AzAccount` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You’re all set up for noninteractive authentication! Now that you have this
    set up, it will be saved so you don’t have to authenticate like this again.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the condensed code, download the *AzureAuthentication.ps1* script
    from the book’s resources for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Virtual Machine and All Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to set up an Azure virtual machine. *Azure virtual machines* are one
    of the most popular Azure services, and having the skills to build Azure VMs will
    be a big advantage for anyone working in an Azure environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now, way back in the day, when I first created my Azure subscription and wanted
    to play around with a virtual machine, I thought there’d be a single command to
    set it up—like all I’d have to do was run `New-AzureVm`, and voila! There’d be
    a brand-new virtual machine for me to play with. Boy, was I wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Little did I realize the number of dependencies that had to be in place before
    a virtual machine would actually work. Did you notice how short the prerequisite
    section of this chapter is? I left it that way for a reason: to get more experience
    working with PowerShell, you’ll install all the dependencies you need to create
    a virtual machine with Azure. You’ll install a resource group, a virtual network,
    a storage account, a public IP address, a network interface, and an operating
    system image. In other words, you’ll build this VM from the ground up. Let’s get
    started!'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Resource Group
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Azure, everything is a *resource*, and everything must live inside a *resource
    group*. Your first task is to create a resource group. To do that, you’ll use
    the `New-AzResourceGroup` command. This command requires a resource group name
    and the geographic region that it will be created in. For this example, you’ll
    create a resource group named `PowerShellForSysAdmins-RG`, and you’ll place it
    in the East US region (as shown in [Listing 12-5](ch12.xhtml#ch12list5)). You
    can find all available regions by running the `Get-AzLocation` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-5: Creating an Azure resource group*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the resource group is created, it’s time to build out the network stack
    your VM will use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Network Stack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For your VM to connect to the outside world and other Azure resources, it needs
    a *network stack*: the subnet, virtual network, public IP address (optional),
    and virtual network adapter (vNIC) that the VM uses.'
  prefs: []
  type: TYPE_NORMAL
- en: The Subnet
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Your first step is to create a subnet. A *subnet* is a logical network of IP
    addresses that can communicate with one another without the use of a router. The
    subnet will be what goes “into” the virtual network. Subnets segment a virtual
    network into smaller networks.
  prefs: []
  type: TYPE_NORMAL
- en: To create a subnet config, use the `New-AzVirtualNetworkSubnetConfig` command
    ([Listing 12-6](ch12.xhtml#ch12list6)). This command requires a name and the IP
    address prefix or network identity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-6: Creating a virtual network subnet config*'
  prefs: []
  type: TYPE_NORMAL
- en: You assign the subnet a name of `PowerShellForSysAdmins-Subnet` and use the
    prefix of 10.0.1.0/24.
  prefs: []
  type: TYPE_NORMAL
- en: The Virtual Network
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you’ve created a subnet config, you can use it to create the virtual
    network. The *virtual network* is an Azure resource that allows you to segment
    various resources such as virtual machines from all other resources. A virtual
    network can be thought of in the same context as a logical network that you may
    implement on premises in a network router.
  prefs: []
  type: TYPE_NORMAL
- en: To create a virtual network, use the `New-AzVirtualNetwork` command, as shown
    in [Listing 12-7](ch12.xhtml#ch12list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-7: Creating a virtual network*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that to create a virtual network, you have to specify the name of the
    network ❶, the resource group ❷, the region (location) ❸, and the overarching
    private network that your subnet will be a part of ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The Public IP Address
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that you’ve set up a virtual network, you need a public IP address so you
    can connect your VM to the internet and have clients connect to your VM. Note
    that this step isn’t technically necessary if you plan to make your virtual machine
    available only to other Azure resources. But since you have bigger plans for your
    VM, you’ll go ahead and do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you can create a public IP address by using a single command: `New-AzPublicIpAddress`.
    You’ve seen most of the parameters for this function before, but notice that there’s
    a new one named `AllocationMethod`. This parameter tells Azure whether to create
    a dynamic or static IP address resource. As shown in [Listing 12-8](ch12.xhtml#ch12list8),
    specify that you want a dynamic IP address. You assign your virtual machines dynamic
    IP addresses because it’s one less task to worry about. Because you don’t require
    an IP address to always be the same, using dynamic IP addresses frees you from
    another task.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-8: Creating a public IP address*'
  prefs: []
  type: TYPE_NORMAL
- en: Although this public IP address exists, it’s useless because it’s not associated
    with anything yet. You need to *bind* it to a vNIC.
  prefs: []
  type: TYPE_NORMAL
- en: The Virtual Network Adapter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To build the vNIC, you need to execute another single-line command, `New-AzNetworkInterface`,
    and you can use a lot of the same parameters you’ve been using. You also need
    the ID of the subnet and the ID of the public IP address you created earlier.
    Both the subnet and the public IP address were stored as objects with an ID property;
    you simply need to access that property, as shown in [Listing 12-9](ch12.xhtml#ch12list9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-9: Creating an Azure vNIC*'
  prefs: []
  type: TYPE_NORMAL
- en: Your network stack is complete! The next step is creating the storage account.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Storage Account
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You need to store the virtual machine somewhere. That somewhere is called a
    *storage account*. Creating a basic storage account is as easy as using the `New``-AzStorageAccount`
    command. As with the past few commands you’ve seen, you need a name, resource
    group, and location; but here you have the new `Type` parameter, which specifies
    the level of redundancy your storage account will contain. Use the least expensive
    type of storage account (*locally redundant*), specified by the `Standard_LRS`
    argument, as you can see in [Listing 12-10](ch12.xhtml#ch12list10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-10: Creating an Azure storage account*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have somewhere for the VM to live, it’s time to set up the operating
    system image.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Operating System Image
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *operating system image* is the base to the virtual disk your virtual machine
    will be using. Instead of installing Windows on your virtual machine, you’ll use
    a preexisting operating system image to get you to the point to where you can
    just turn it on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You create an operating system image in two steps: defining some OS configuration
    settings, and then defining the offer or OS image to use. Azure uses the term
    *offer* to reference the VM image.'
  prefs: []
  type: TYPE_NORMAL
- en: To set up all the configuration settings, you build a VM configuration object.
    This object defines the name and size of the VM you’re creating. You do this by
    using the `New-AzVMConfig` command. In [Listing 12-11](ch12.xhtml#ch12list11),
    you create a `Standard_A3` VM. (You can find a list of all sizes available by
    running `Get-AzVMSize` and specifying the region.).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-11: Creating a VM configuration*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the configuration is created, you can pass the object as the VM parameter
    for the `Set-AzVMOperatingSystem` command. This command allows you to both define
    operating-system-specific attributes, such as the hostname of the VM, and enable
    Windows Update and other attributes. We’ll keep it simple here, but if you’d like
    to see everything possible, check out `Set-AzVMOperatingSystem` information by
    using `Get-Help`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-12](ch12.xhtml#ch12list12) creates a Windows operating system object
    that will have the hostname of `Automate-VM` (note: the hostname must be fewer
    than 16 characters). You use the username and password returned by the `Get-Credential`
    command to create a new administrative user with the provided password, and you
    use the `EnableAutoUpdate` parameter to automatically apply any new Windows updates.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-12: Creating an operating system image*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to create a VM offer. An offer is how Azure allows you to choose
    what kind of operating system will be installed on the VM’s OS disk. This example
    uses a Windows Server 2012 R2 Datacenter image. This image is one provided by
    Microsoft, so no need to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created the offer object, you can create a source image by using
    the `Set-AzVMSourceImage` command, as shown in [Listing 12-13](ch12.xhtml#ch12list13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-13: Finding and creating a VM source image*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you’re querying all offers in the East US region ❶ with a publisher name
    of `MicrosoftWindowsServer` ❷. You may use `Get-AzVMImagePublisher` to find a
    list of publishers. You then limit the offers to a name of `WindowsServer` ❸.
    With the source image allocated, you can now assign the image to the VM object.
    This completes the setup of the VM’s virtual disk.
  prefs: []
  type: TYPE_NORMAL
- en: To assign the image to the VM object, you need a URI for the OS disk you just
    created, and you need to pass that URI along with the VM object to the `Set-AzVMOSDisk`
    command ([Listing 12-14](ch12.xhtml#ch12list14)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-14: Assigning the operating system disk to the VM*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have an OS disk, and it’s assigned to a VM object. Time to
    finish this up!
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re *almost* done. All that’s left is to attach the vNIC you created earlier
    and, well, create the actual VM.
  prefs: []
  type: TYPE_NORMAL
- en: To attach the vNIC to the VM, you use the `Add-AzVmNetworkInterface` command
    and pass the VM object you created along with the ID of the vNIC you created earlier—all
    of which you can see in [Listing 12-15](ch12.xhtml#ch12list15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-15: Attaching the vNIC to the VM*'
  prefs: []
  type: TYPE_NORMAL
- en: And now, at last, you can create the VM, as shown in [Listing 12-16](ch12.xhtml#ch12list16).
    By calling the `New-AzVm` command with the VM object, the resource group, and
    region, you finally have your VM! Note that this will start the VM, and at this
    point, you’ll begin incurring charges.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-16: Creating the Azure virtual machine*'
  prefs: []
  type: TYPE_NORMAL
- en: You should have a brand-new VM in Azure called `Automate-VM`. To confirm, you
    can run `Get-AzVm` to ensure that the VM exists. Check out the output in [Listing
    12-17](ch12.xhtml#ch12list17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-17: Discovering your Azure VM*'
  prefs: []
  type: TYPE_NORMAL
- en: If you see similar output, you’ve successfully created an Azure virtual machine!
  prefs: []
  type: TYPE_NORMAL
- en: Automating the VM Creation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Whew! That was a lot of work getting a single virtual machine running and building
    all of the dependencies; I would hate to have to go through it again when I want
    to build my next VM. Why don’t we create a single function that’ll handle all
    this for us? With a function, we can incorporate all the code we just went through
    into a single, executable chunk of code that we can reuse over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re feeling adventurous, I created a custom PowerShell function called
    `New-CustomAzVm`, available in this chapter’s resources. It provides an excellent
    example of how to incorporate all the tasks accomplished in this section into
    a single, cohesive function with a minimal amount of input.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an Azure Web App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re working with Azure, you’ll want to know how to deploy an Azure web
    app. *Azure web apps* allow you to quickly provision websites and various other
    web services running on servers such as IIS, Apache, and more without worrying
    about building the web server itself. Once you learn how to deploy an Azure web
    app with PowerShell, you’ll be able to work the process into larger workflows
    including development build pipelines, test environment provisioning, lab provisioning,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploying an Azure web app is a two-step process: you create an app service
    plan and then create the web app itself. Azure web apps are a part of Azure App
    Services, and any resource under this umbrella must have an associated app service
    plan. *App service plans* tell the web app which kind of underlying compute resources
    to build the program on.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an App Service Plan and Web App
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating an Azure service plan is simple enough. As before, you need only a
    single command. This command requires you to provide the name of the app service
    plan, the region or location where it will exist, the resource group, and an optional
    tier that defines the kind of performance provided by the server running underneath
    the web app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as you did in the previous section, you create a resource group to keep
    all of your resources together; let’s use this command: New-AzResourceGroup -Name
    ''PowerShellForSysAdmins-App'' -Location ''East US''. Once the resource group
    is created, you create the app service plan and place it inside that resource
    group.'
  prefs: []
  type: TYPE_NORMAL
- en: Your web app, called `Automate`, will be in the East US region and in the `Free`
    tier of apps. You can see all the code to accomplish those tasks in [Listing 12-18](ch12.xhtml#ch12list18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-18: Creating an Azure app service plan*'
  prefs: []
  type: TYPE_NORMAL
- en: Once this command is executed, you’ll have the app service plan created and
    can move on to creating the web app itself.
  prefs: []
  type: TYPE_NORMAL
- en: You may not be surprised to hear that creating an Azure web app with PowerShell
    is also a single-command process. Just run `New-AzWebApp`, and supply it with
    the now-common parameters of resource group name, name, and location, along with
    the app service plan this web app will sit on top of.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-19](ch12.xhtml#ch12list19) uses the `New-AzWebApp` command to create
    a web app with the name `MyApp` inside the `PowerShellForSysAdmins-App` resource
    group using the app service plan `Automate` (the one that you created earlier).
    Note that this starts the app, which may incur billing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-19: Creating an Azure web app*'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this command, you should see a lot of properties in your output;
    these are the web app’s various settings.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an Azure SQL Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common Azure task is deploying an Azure SQL database. To deploy an
    Azure SQL database, you need to do three things: create the Azure SQL server that
    the database will run on, create the database itself, and then create a SQL Server
    firewall rule to connect to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: As in previous sections, you create a resource group to house all your new resources.
    Run New-AzResourceGroup -Name 'PowerShellForSysAdmins-SQL' -Location 'East US'
    to do so. Then you’ll create the SQL server that the database will run on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure SQL Server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Creating an Azure SQL server takes yet another single-line command: `New-AzSqlServer`.
    And yet again, you need to provide the name of the resource, the name of the server
    itself, and the region—but here, you also need the username and password of the
    SQL administrator user on the server. This requires a little more work. Because
    you need to create a credential to pass to `New-AzSqlServer`, let’s go ahead and
    do that first. I covered how to create a `PSCredential` object in the “Creating
    a Service Principal” on [page 158](ch12.xhtml#page_158), so we won’t go over that
    here.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Once you have a credential, the rest is as easy as putting all the parameters
    into a hashtable, and passing it into the `New-AzSqlServer` function, as shown
    in [Listing 12-20](ch12.xhtml#ch12list20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-20: Creating the Azure SQL server*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the SQL server has been created, you have the bedrock for your database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Azure SQL Database
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create the SQL database, use the `New-AzSqlDatabase` command, as shown in
    [Listing 12-21](ch12.xhtml#ch12list21). Along with the common parameter of `ResourceGroupName`,
    pass in the name of the server that you just created and the name of the database
    you want to create (in this example, `AutomateSQLDb`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-21: Creating an Azure SQL database*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a running SQL database in Azure. But when you try to
    connect to it, it won’t work. By default, when a new Azure SQL database is created,
    it’s locked down from any outside connections. You need to create a firewall rule
    so you can allow connections to your database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SQL Server Firewall Rule
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The command to create a firewall rule is `New-AzSqlServerFirewallRule`. The
    command takes in the resource group name, the name of the server you created earlier,
    the name for the firewall rule, and start and end IP addresses. The start and
    end IP addresses allow you to specify a single IP address or a range of IPs to
    allow into your database. Since you’ll be working on only one local computer to
    manage Azure, let’s limit the connections to your SQL server to be from only your
    current computer. To do that, you first need to figure out your public IP address.
    You can easily do this via a PowerShell one-liner: Invoke-RestMethod http://ipinfo.io/json
    | Select -ExpandProperty ip. You can then use the public IP address for both the
    `StartIPAddress` and `EndIPAddress` parameters. However, note that if your public
    IP address changes, you’ll need to do all this again.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, be aware that the server name in [Listing 12-22](ch12.xhtml#ch12list22)
    must be made up of all lowercase letters, hyphens, and/or numbers. Otherwise,
    you’ll get an error when you attempt to create the firewall rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-22: Creating an Azure SQL server firewall rule*'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! Your database should be up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Your SQL Database
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To test your database, let’s make a small function that uses the `System.Data.SqlClient.SqlConnection`
    object’s `Open()` method to attempt a simple connection; see [Listing 12-23](ch12.xhtml#ch12list23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-23: Testing a SQL connection to the Azure SQL database*'
  prefs: []
  type: TYPE_NORMAL
- en: You use the SQL server’s fully qualified domain name created earlier as the
    `ServerName` parameter for this function ❶ along with the SQL administrator username
    and password inside a `PSCredential` object ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Then you break apart the `PSCredential` object into a plaintext username and
    password ❸, create the connection string to make the database connection ❹, invoke
    the `Open()` method on the `SqlConnection` object to attempt to connect to the
    database ❺, and then finally close the database connection ❻.
  prefs: []
  type: TYPE_NORMAL
- en: You can execute this function by running Test-SqlConnection -ServerName 'powershellsysadmins-sqlsrv.database.windows.net'
    -DatabaseName 'AutomateSQLDb' -Credential (Get-Credential). If you can connect
    to the database, the function will return `True`; otherwise, it will return `False`
    (and further investigation will be needed).
  prefs: []
  type: TYPE_NORMAL
- en: You can clean everything up by removing the resource group with the command
    Remove-AzResourceGroup -ResourceGroupName 'PowerShellForSysAdmins-SQL'.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you dove headfirst into automating Microsoft Azure with PowerShell.
    You set up noninteractive authentication, and deployed a virtual machine, web
    app, and SQL database. And you did it all from PowerShell, sparing you any visits
    to the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: You couldn’t have done this without the `Az` PowerShell module and the hard
    work of the people who created it. Like other PowerShell cloud modules, all these
    commands rely on various APIs that are being called under the hood. Thanks to
    the module, you didn’t have to worry about learning how to call REST methods or
    use endpoint URLs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll take a look at using PowerShell to automate Amazon
    Web Services.
  prefs: []
  type: TYPE_NORMAL
