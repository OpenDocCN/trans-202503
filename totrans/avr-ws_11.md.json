["```\n\n      // Project 44 - Using the 74HC595 Shift Register\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      ❶ void setupSPI()\n\n      {\n\n      PORTB |= (1 << 0); // SS pin HIGH\n\n      // Set up SPI bus\n\n      SPCR = 0b01110000;\n\n      }\n\n      ❷ void dispNumSR(uint8_t value)\n\n      // Displays a number from 0–9 on the seven-segment LED display\n\n      {\n\n      // SS pin LOW\n\n      ❸ PORTB &= ~(1 << PORTB0);\n\n      switch(value)\n\n      // Determine which byte of data to send to the 74HC595\n\n      {\n\n      case 0 : SPDR = 0b11111100; break; // 0\n\n      case 1 : SPDR = 0b01100000; break; // 1\n\n      case 2 : SPDR = 0b11011010; break; // 2\n\n      case 3 : SPDR = 0b11110010; break; // 3\n\n      case 4 : SPDR = 0b01100110; break; // 4\n\n      case 5 : SPDR = 0b10110110; break; // 5\n\n      case 6 : SPDR = 0b10111110; break; // 6\n\n      case 7 : SPDR = 0b11100000; break; // 7\n\n      case 8 : SPDR = 0b11111110; break; // 8\n\n      case 9 : SPDR = 0b11100110; break; // 9\n\n      }\n\n      ❹ while(!(SPSR & (1<<SPIF)));          // Wait for SPI transmission to finish\n\n      // SS pin HIGH\n\n      PORTB |= (1 << PORTB0);\n\n      }\n\n      int main(void)\n\n      ❺ {\n\n      uint8_t i=0;\n\n      DDRB = 0b11111111;                   // Set PORTB as outputs\n\n      setupSPI();\n\n      while (1)\n\n      {\n\n      for (i=0; i<10; i++)\n\n      {\n\n      dispNumSR(i);\n\n      _delay_ms(250);\n\n      }\n\n      }\n\n      }\n\n```", "```\n\n      // Project 45 - Using Two 74HC595 Shift Registers\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      void setupSPI()\n\n      {\n\n      PORTB |= (1 << 0);          // SS pin HIGH\n\n      // Set up SPI bus\n\n      SPCR = 0b01110000;\n\n      }\n\n      ❶ void dispNumSR(uint8_t value)\n\n      // Displays a number from 00–99 on the seven-segment LED displays\n\n      {\n\n      uint8_t leftDigit;\n\n      uint8_t rightDigit;\n\n      ❷ uint8_t digitData[] = {0b11111100, 0b01100000, 0b11011010, 0b11110010, 0b01100110,\n\n      0b10110110, 0b10111110, 0b11100000, 0b11111110, 0b11100110};\n\n      ❸ leftDigit = value/10;\n\n      rightDigit = value%10;\n\n      ❹ PORTB &= ~(1 << PORTB0);    // SS pin LOW\n\n      ❺ SPDR = digitData[rightDigit];\n\n      ❻ while(!(SPSR & (1<<SPIF))); // Wait for SPI transmission to finish\n\n      SPDR = digitData[leftDigit];\n\n      while(!(SPSR & (1<<SPIF))); // Wait for SPI transmission to finish\n\n      ❼ PORTB |= (1 << PORTB0);     // SS pin HIGH\n\n      }\n\n      int main(void)\n\n      {\n\n      uint8_t i=0;\n\n      DDRB = 0b11111111;          // Set PORTB as outputs\n\n      setupSPI();\n\n      while (1)\n\n      {\n\n      for (i=0; i<100; i++)\n\n      {\n\n      dispNumSR(i);\n\n      _delay_ms(250);\n\n      }\n\n      }\n\n      }\n\n```", "```\n\n      // Project 46 - Using the MAX7219 LED Driver IC\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      ❶ void writeMAX7219(char hexdata1, char hexdata2)\n\n      // Sends two bytes in hexadecimal to the MAX7219\n\n      {\n\n      PORTB &= ~(1 << PORTB0);    // SS pin LOW\n\n      SPDR = hexdata1;            // Send value of hexdata1\n\n      while(!(SPSR & (1<<SPIF))); // Wait for SPI transmission to finish\n\n      SPDR = hexdata2;            // Send value of hexdata2\n\n      while(!(SPSR & (1<<SPIF))); // Wait for SPI transmission to finish\n\n      PORTB |= (1 << PORTB0);     // SS pin HIGH\n\n      }\n\n      ❷ void blankMAX7219()\n\n      // Blanks all digits\n\n      {\n\n      uint8_t i;\n\n      for (i=1; i<9; i++)         // Blank all digits\n\n      {\n\n      writeMAX7219(i,15);      // Send blank (15) to digit register (i)\n\n      }\n\n      }\n\n      ❸ void initMAX7219()\n\n      // Set up MAX7219 for use\n\n      {\n\n      PORTB |= (1 << 0);          // SS pin HIGH\n\n      SPCR = 0b01010000;          // Set up SPI bus for MAX7219\n\n      writeMAX7219(0x09,0xFF);    // Mode decode for digits\n\n      writeMAX7219(0x0B,0x07);    // Set scan limit to 8 digits: 0x09 + 0xFF)\n\n      writeMAX7219(0x0A,0x01);    // Set intensity to 8 - 0x0A + 0x08)\n\n      writeMAX7219(0x0C,0x01);    // Mode display on\n\n      blankMAX7219();\n\n      }\n\n      ❹ void dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)\n\n      // Displays \"number\" in location \"digit\" with decimal point on/off\n\n      // Digit: 1~8 for location 1~8\n\n      // Number: 0~15 for 0~9, - E, H, L, P, blank\n\n      // dp: 1 on, 0 off\n\n      {\n\n      ❺ if (dp==1)                  // Add decimal point\n\n      {\n\n      number = number + 128;\n\n      }\n\n      writeMAX7219(digit, number);\n\n      }\n\n      ❻ void numberMAX7219(uint32_t value)\n\n      // Displays a number between 0–99999999\n\n      uint8_t digits[9];\n\n      uint8_t i = 1;\n\n      for (i=1; i<9; i++)\n\n      {\n\n      ❼ digits[i]=15;            // Sending 15 blanks the digit\n\n      }\n\n      i = 1;\n\n      while (value > 0)           // Continue until value > 0\n\n      {\n\n      digits[i] = value % 10;  // Determine and store last digit\n\n      value = value / 10;      // Divide value by 10\n\n      i++;\n\n      }\n\n      for (i=1; i<9; i++)\n\n      {\n\n      dispMAX7219(i, digits[i],0);\n\n      }\n\n      }\n\n      int main(void)\n\n      ❽ {\n\n      uint32_t i;\n\n      DDRB = 0b11111111;          // Set PORTB as outputs\n\n      initMAX7219();\n\n      while (1)\n\n      {\n\n      for (i = 0; i<100000000; i++)\n\n      {\n\n      numberMAX7219(i);\n\n      _delay_ms(100);\n\n      }\n\n      }\n\n      }\n\n```", "```\n\n      writeMAX7219(0x08, 0x09);\n\n```", "```\n\n      writeMAX7219(8, 9);\n\n```", "```\n\n      `dispMAX7219(1, 3, 0)` \n\n```", "```\n\n      // Project 48 - Using the MCP3008 ADC IC\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      void writeMAX7219(char hexdata1, char hexdata2)\n\n      // Sends two bytes in hexadecimal to MAX7219\n\n      {\n\n      SPCR = 0b01010000;             // Set up SPI bus for MAX7219\n\n      PORTB &= ~(1 << PORTB0);       // SS pin LOW\n\n      SPDR = hexdata1;               // Send value of hexdata1\n\n      while(!(SPSR & (1<<SPIF)));    // Wait for SPI transmission to finish\n\n      SPDR = hexdata2;               // Send value of hexdata2\n\n      while(!(SPSR & (1<<SPIF)));    // Wait for SPI transmission to finish\n\n      PORTB |= (1 << PORTB0);        // SS pin HIGH\n\n      }\n\n      void blankMAX7219()\n\n      {\n\n      uint8_t i;\n\n      for (i=1; i<9; i++)\n\n      {\n\n      writeMAX7219(i,15);\n\n      }\n\n      }\n\n      void initMAX7219()\n\n      // Set up MAX7219 for use\n\n      {\n\n      PORTB |= (1 << 0);\n\n      SPCR = 0b01010000;\n\n      writeMAX7219(0x09,0xFF);\n\n      writeMAX7219(0x0B,0x07);\n\n      writeMAX7219(0x0A,0x01);\n\n      writeMAX7219(0x0C,0x01);\n\n      blankMAX7219();\n\n      }\n\n      void dispMAX7219(uint8_t digit, uint8_t number, uint8_t dp)\n\n      {\n\n      if (dp==1)                     // Add decimal point\n\n      {\n\n      number = number + 128;\n\n      }\n\n      writeMAX7219(digit, number);\n\n      }\n\n      void numberMAX7219(uint32_t value)\n\n      // Displays a number between 0–99999999\n\n      uint8_t digits[9];\n\n      uint8_t i = 1;\n\n      for (i=1; i<9; i++)\n\n      {\n\n      digits[i]=15;              // Sending 15 blanks the digit\n\n      }\n\n      i = 1;\n\n      while (value > 0)             // Continue until value > 0\n\n      {\n\n      digits[i] = value % 10;    // Determine and store last digit\n\n      value = value / 10;        // Divide value by 10\n\n      i++;\n\n      }\n\n      for (i=1; i<9; i++)\n\n      {\n\n      dispMAX7219(i, digits[i],0);\n\n      }\n\n      }\n\n      ❶ uint16_t readMCP3008()\n\n      // Read channel 0 and return value\n\n      {\n\n      ❷ uint8_t LSB;\n\n      uint8_t MSB;\n\n      uint16_t ADCvalue;            // Holds data to return to main code\n\n      SPCR = 0b01010010;            // Set up SPI bus for MCP3008\n\n      // SS on PB1 (15)\n\n      PORTB &= ~(1 << PORTB1);      // SS pin LOW\n\n      ❸ SPDR = 0b00000001;            // Send start bit\n\n      while(!(SPSR & (1<<SPIF)));   // Wait for SPI transmission to finish\n\n      SPDR = 0b10000000;            // Select ADC0\n\n      while(!(SPSR & (1<<SPIF)));\n\n      // Place top 2 bits of ADC value in MSB, ignore unwanted bits\n\n      ❹ MSB = SPDR & 0b00000011;\n\n      ❺ SPDR = 0b00000000;            // Request next 8 bits of data\n\n      while(!(SPSR & (1<<SPIF)));\n\n      // Place lower 8 bits of data in LSB\n\n      ❻ LSB = SPDR;\n\n      ❼ PORTB |= (1 << PORTB1);       // SS pin HIGH\n\n      ❽ ADCvalue = MSB << 8 | LSB;    // Construct final 10-bit ADC value\n\n      return ADCvalue;\n\n      }\n\n      int main(void)\n\n      {\n\n      uint16_t ADCoutput;\n\n      DDRB = 0b11111111;            // Set PORTB as outputs\n\n      initMAX7219();\n\n      while (1)\n\n      {\n\n      ❾ ADCoutput = readMCP3008();\n\n      // Convert ADC value to millivolts\n\n      ⓿ ADCoutput = ADCoutput * 4.8828;\n\n      numberMAX7219(ADCoutput);\n\n      _delay_ms(100);\n\n      }\n\n      }\n\n```"]