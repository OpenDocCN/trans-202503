<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch24"><span epub:type="pagebreak" id="page_461"/><span class="big">24</span><br/>ELECTRIC CHARGE</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Electric charge is ultimately responsible for all electrical phenomena. It’s useful to be able to talk about electric charge that’s localized at a particular point in space, but it’s also useful to be able to talk about charge that’s distributed along a curve, along a surface, or throughout a volume. Such charge distributions are the subject of this short chapter.</p>&#13;
<p class="indent">We’ll first introduce the ideas of linear charge density, surface charge density, and volume charge density. We’ll then define a data type for charge distribution capable of representing a point charge, a line charge, a surface charge, a volume charge, or any combination of these. We’ll write functions to find the total charge and the electric dipole moment of a charge distribution. Electric charge gives rise to electric fields. Having a good language for charge distributions prepares us for the next chapter, in which we’ll find the electric field produced by a charge distribution.</p>&#13;
<h3 class="h3" id="ch24lev1">Charge Distributions</h3>&#13;
<p class="noindent">Electric charge is the fundamental quantity responsible for electromagnetic effects, and it plays a key role in electromagnetic theory. In classical <span epub:type="pagebreak" id="page_462"/>electromagnetic theory, which we’re studying in this book, we’ll sometimes think of charge as associated with a particle, in which case we call the charge a <em>point charge</em>, imagining that it has a location in space but no spatial extent.</p>&#13;
<p class="indent">We also sometimes think of charge as a fluid (that is, something that can be continuously distributed throughout a region of space). In fact, we use three types of continuous charge distributions. First, there is charge continuously distributed along a one-dimensional path such as a line or a curve. In this case, we speak of the <em>linear charge density λ</em>, meaning the charge per unit length. This use of the Greek letter lambda is separate and independent of its use in <a href="ch20.xhtml">Chapter 20</a> to mean wavelength. The SI unit for linear charge density is the Coulomb per meter (C/m).</p>&#13;
<p class="indent">Second, there is charge continuously distributed along a two-dimensional surface. In this case, we speak of the <em>surface charge density σ</em> (Greek letter sigma), meaning the charge per unit area. The SI unit for surface charge density is the Coulomb per square meter (C/m<sup>2</sup>).</p>&#13;
<p class="indent">Third, there is charge continuously distributed throughout a three-dimensional volume. In this case, we speak of the <em>volume charge density ρ</em> (Greek letter rho), meaning the charge per unit volume. The SI unit for volume charge density is the Coulomb per cubic meter (C/m<sup>3</sup>). <a href="ch24.xhtml#ch24tab1">Table 24-1</a> summarizes these charge distributions.</p>&#13;
<p class="tabcap" id="ch24tab1"><strong>Table 24-1:</strong> Charge Distributions</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Charge distribution</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Dimensionality</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Symbol</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>SI unit</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">Point charge</p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba"><em>q</em>, <em>Q</em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">C</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Linear charge density</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>λ</em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba">C/m</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Surface charge density</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><em>σ</em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">C/m<sup>2</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Volume charge density</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><em>ρ</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">C/m<sup>3</sup></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Electric charge plays a role in microscopic physics, in that we associate an electric charge with elementary particles such as electrons and quarks. Charge also plays a role in macroscopic physics because electrons can pile up in places, leading to a net negative charge, or they can be absent from atoms, leading to a net positive charge.</p>&#13;
<p class="indent">Materials can be classified as insulators or conductors based on how easy it is for electrons to move around. Insulators are materials in which it is difficult for electrons to leave their atoms and move about the material, while conductors are materials in which it is easy for electrons to move about.</p>&#13;
<p class="indent">Charge distributions on insulators can be more or less arbitrary, and charge distributions of things like atoms can be nonuniform—determined, ultimately, by quantum mechanics. But charge distributions on conductors are constrained because the electrons will not stay where you put them. <em>Fixed</em> macroscopic charge distributions can be realized only on insulators, on which the charges cannot move. So I can charge the tail of my cat to 10 times the charge density as his nose because the electrons stay put. Macroscopic <em>conductors</em> cannot support arbitrary charge densities: the charges <span epub:type="pagebreak" id="page_463"/>move, redistributing themselves very rapidly. So you should imagine as we talk about charge distributions that we are distributing charge on an insulator.</p>&#13;
<p class="indent">Before we introduce the various charge distributions, some introductory code needs to be at the top of the source code file; we’ll look at that next.</p>&#13;
<h3 class="h3" id="ch24lev2">Introductory Code</h3>&#13;
<p class="noindent"><a href="ch24.xhtml#ch24list1">Listing 24-1</a> shows the first lines of the code in the <code>Charge</code> module we’ll write in this chapter.</p>&#13;
<pre id="ch24list1">{-# OPTIONS -Wall #-}&#13;
&#13;
module Charge where&#13;
&#13;
import SimpleVec ( R, Vec, vec, sumV, (*^), (^/), (&lt;.&gt;), magnitude, negateV )&#13;
import Electricity ( elementaryCharge )&#13;
import CoordinateSystems ( Position, ScalarField, origin, cart, sph&#13;
                         , rVF, displacement, shiftPosition )&#13;
import Geometry ( Curve(..), Surface(..), Volume(..)&#13;
                , straightLine, shiftSurface, disk )&#13;
import Integrals&#13;
    ( scalarLineIntegral, scalarSurfaceIntegral, scalarVolumeIntegral&#13;
    , vectorLineIntegral, vectorSurfaceIntegral, vectorVolumeIntegral&#13;
    , curveSample, surfaceSample, volumeSample )</pre>&#13;
<p class="listing"><em>Listing 24-1: Opening lines of code for the <span class="codeitalic1">Charge</span> module</em></p>&#13;
<p class="indent">We use types and functions from the <code>SimpleVec</code> module of <a href="ch10.xhtml">Chapter 10</a>, the <code>Electricity</code> module of <a href="ch21.xhtml">Chapter 21</a>, the <code>CoordinateSystems</code> module of <a href="ch22.xhtml">Chapter 22</a>, the <code>Geometry</code> module of <a href="ch23.xhtml">Chapter 23</a>, and the <code>Integrals</code> module that includes various functions introduced in the next chapter.</p>&#13;
<p class="indent">Let’s define a type synonym for charge:</p>&#13;
<pre>type Charge = R</pre>&#13;
<p class="indent">Defining a new type for charge in this way is half good and half silly. It’s good in that human readers of the code (including the writer of the code) will know the intent of an expression with type <code>Charge</code>. It is, in this sense, a form of documentation for the code. However, it is silly because the compiler doesn’t make any distinction between <code>Charge</code> and <code>R</code> and <code>Double</code>, so it cannot help the writer to avoid using <code>Charge</code> in any place an <code>R</code> or a <code>Double</code> could be used. One of the main purposes of types is separating things that should be separated and letting the computer help enforce that separation. Charge is not at all the same as time, for example, which might also be described by a real number <code>R</code>.</p>&#13;
<p class="indent">Once again, we must choose between simplicity and power. We could use Haskell’s <code>data</code> keyword to define a new type for charge that couldn’t be confused with any other type. Defining a new data type would be a reasonable thing to do here, but there is a bit of extra effort and overhead involved, <span epub:type="pagebreak" id="page_464"/>so I have chosen the simplicity of the <code>type</code> method over the power of the <code>data</code> method.</p>&#13;
<h3 class="h3" id="ch24lev3">A Type for Charge Distribution</h3>&#13;
<p class="noindent">We want to define a new data type <code>ChargeDistribution</code> that can hold a point charge, a line charge, a surface charge, a volume charge, or a combination of these. This is not mandatory; we could settle for separate types for line charge, surface charge, and so on. Introducing a single <code>ChargeDistribution</code> type allows us to write a function</p>&#13;
<pre>eField :: ChargeDistribution -&gt; VectorField</pre>&#13;
<p class="noindent">in the next chapter to emphasize the central idea that charge is the source of electric fields. Once you understand the options a language allows, you can use them to your advantage to underscore the central ideas of the discipline you’re writing about.</p>&#13;
<p class="indent">What information is required to specify each of these distributions? For a point charge, we need to specify how much charge there is and where the charge is located, so we need to give a <code>Charge</code> and a <code>Position</code>. For a line charge, we need to specify a curve along which the charge sits and the linear charge density at each point on the curve. The linear charge density need not be uniform along the curve. It could be high in some places and low in others, or even positive in some places and negative in others. We will use a scalar field to specify the linear charge density. So, a line charge requires that we give a <code>ScalarField</code> for the linear charge density and a <code>Curve</code> along which the charge lies.</p>&#13;
<p class="indent">Specification of a surface charge requires that we give a scalar field for the surface charge density, which may vary from place to place, as well as a surface along which the charge lies. A surface charge is specified by giving a <code>ScalarField</code> and a <code>Surface</code>. Similarly, a volume charge is specified by giving a <code>ScalarField</code> and a <code>Volume</code>.</p>&#13;
<p class="indent">Finally, we can specify a combination of charge distributions by giving a list of charge distributions. Let’s take a look at the code defining the data type <code>ChargeDistribution</code>.</p>&#13;
<pre>data ChargeDistribution&#13;
    = PointCharge   Charge      Position&#13;
    | LineCharge    ScalarField Curve&#13;
    | SurfaceCharge ScalarField Surface&#13;
    | VolumeCharge  ScalarField Volume&#13;
    | MultipleCharges [ChargeDistribution]</pre>&#13;
<p class="indent">The type <code>ChargeDistribution</code> has five data constructors, one for each situation we described earlier. To construct a <code>ChargeDistribution</code>, we use one of the five data constructors along with the relevant information for that sort of charge distribution. A curious attribute of this data type is that it is recursive. The information required by the <code>MultipleCharges</code> constructor is a list of <code>ChargeDistribution</code>s, the very type we are defining. We can think that there <span epub:type="pagebreak" id="page_465"/>are four basic sorts of charge distribution (point, line, surface, and volume) and one composite sort that combines distributions.</p>&#13;
<h3 class="h3" id="ch24lev4">Examples of Charge Distributions</h3>&#13;
<p class="noindent">Let’s write some examples of charge distributions. We can define the charge distribution of a proton at the origin as follows:</p>&#13;
<pre>protonOrigin :: ChargeDistribution&#13;
protonOrigin = PointCharge elementaryCharge origin</pre>&#13;
<p class="indent">Here is a uniform line charge with total charge <code>q</code> and length <code>len</code>, centered at the origin:</p>&#13;
<pre>chargedLine :: Charge -&gt; R -&gt; ChargeDistribution&#13;
chargedLine q len&#13;
    = LineCharge (const $ q / len) $&#13;
      Curve (\z -&gt; cart 0 0 z) (-len/2) (len/2)</pre>&#13;
<p class="indent">We pass in the total charge <code>q</code> and the length <code>len</code>. The uniform linear charge density is <code>q / len</code>, which we pass to the <code>const</code> function since <code>LineCharge</code> requires a scalar field for its first argument.</p>&#13;
<p class="indent">Here is a uniform ball of charge with total charge <code>q</code> and radius <code>radius</code>, centered at the origin:</p>&#13;
<pre>chargedBall :: Charge -&gt; R -&gt; ChargeDistribution&#13;
chargedBall q radius&#13;
    = VolumeCharge (const $ q / (4/3*pi*radius**3)) $&#13;
      Volume (\(r,theta,phi) -&gt; sph r theta phi)&#13;
                 0 radius (const 0) (const pi) (\_ _ -&gt; 0) (\_ _ -&gt; 2*pi)</pre>&#13;
<p class="indent">We pass in the total charge <code>q</code> and the <code>radius</code> of the ball. We can then find the uniform volume charge density by dividing <code>q</code> by the volume 4<em>π</em><sup><em>r</em>3</sup>/3 of a spherical ball.</p>&#13;
<p class="indent">A parallel-plate capacitor consists of two conducting plates, parallel to each other. It is typically used so that one plate has a positive charge and the other has an equal-but-opposite negative charge. The charge on each plate will not be distributed in a precisely uniform way, but if the plates are close together, it is a good approximation to regard the charge on each plate as uniformly distributed over the surface of the plate.</p>&#13;
<p class="indent">The following model of a parallel-plate capacitor is formed with two plates, each the shape of a disk with radius <code>radius</code>. The plates are parallel to each other and separated by a distance of <code>plateSep</code>. The surface charge density on the positive plate is <code>sigma</code>, and that on the negative plate is <code>-sigma</code>.</p>&#13;
<pre>diskCap :: R -&gt; R -&gt; R -&gt; ChargeDistribution&#13;
diskCap radius plateSep sigma&#13;
     = MultipleCharges&#13;
       [SurfaceCharge (const sigma) $<span epub:type="pagebreak" id="page_466"/>&#13;
        shiftSurface (vec 0 0 (plateSep/2)) (disk radius)&#13;
       ,SurfaceCharge (const $ -sigma) $&#13;
        shiftSurface (vec 0 0 (-plateSep/2)) (disk radius)&#13;
       ]</pre>&#13;
<p class="indent">Here we see our first use of the <code>MultipleCharges</code> constructor. The charge distribution consists of two <code>disk</code>s of charge, of the sort we wrote in the last chapter. Since the <code>disk</code> we wrote last chapter is centered at the origin, we use <code>shiftSurface</code>, also from last chapter, to place the disks above and below the origin.</p>&#13;
<p class="indent">Having written some examples of charge distributions, let’s turn to the question of finding the total electric charge of a charge distribution.</p>&#13;
<h3 class="h3" id="ch24lev5">Total Charge</h3>&#13;
<p class="noindent">If we distribute 2 C of charge uniformly over a 4-m length, the linear charge density is 0.5 C/m. Here, we’re speaking in terms of charge density, but sometimes it’s more convenient to speak in terms of total charge. For example, when we’re interested in the electric field produced by this line charge at a place several hundred meters away, total charge is more relevant because the line charge looks like a simple point charge from that distance.</p>&#13;
<h4 class="h4" id="ch24lev6">Total Charge of a Line Charge</h4>&#13;
<p class="noindent">The total charge of a line charge can be found by integrating the linear charge density over the curve on which the charge sits. If <em>P</em> is the path, or curve, along which the charge lies, <em>dl</em> is a length element along the curve, and <em>λ</em> is the scalar field for linear charge density, then the following is the total charge of the line charge:</p>&#13;
<div class="imagec"><img src="Images/466equ01.jpg" alt="Image" width="404" height="48"/></div>&#13;
<p class="indent">In the case where linear charge density is uniform, multiplying it by the length of the curve gives the total charge. In general, linear charge density is not uniform. We perform the integral by dividing the curve into many small segments, multiplying the length of each segment by a representative value of charge density on the segment to determine the charge on the segment, and adding all of these segment charges together. When working analytically, we look at the limit in which the length of each segment goes to zero and the number of segments becomes infinite. When working numerically, we choose some large but finite number of segments.</p>&#13;
<h4 class="h4" id="ch24lev7">Total Charge of a Surface Charge</h4>&#13;
<p class="noindent">The total charge of a surface charge can be found by integrating the surface charge density over the surface on which the charge sits. If <em>S</em> is the surface, <em>da</em> is an area element for the surface, and <em>σ</em> is the scalar field for surface charge density, then</p>&#13;
<div class="imagec"><img src="Images/467equ01.jpg" alt="Image" width="406" height="48"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_467"/>is the total charge of the surface charge.</p>&#13;
<p class="indent">In the case where surface charge density is uniform, multiplying it by the area of the surface gives the total charge. In general, surface charge density is not uniform. We perform the integral by dividing the surface into a large number of small patches, multiplying the area of each patch by a representative value of charge density on the patch to determine the charge on the patch, and adding all of these patch charges together. When working analytically, we look at a limit in which the area of each patch goes to zero and the number of patches becomes infinite. When working numerically, we choose some large but finite number of patches.</p>&#13;
<h4 class="h4" id="ch24lev8">Total Charge of a Volume Charge</h4>&#13;
<p class="noindent">The total charge of a volume charge can be found by integrating the volume charge density over the volume in which the charge sits. If <em>V</em> is the volume, <em>dv</em> is a volume element for the volume, and <em>ρ</em> is the scalar field for volume charge density, then</p>&#13;
<div class="imagec"><img src="Images/467equ02.jpg" alt="Image" width="406" height="48"/></div>&#13;
<p class="noindent">is the total charge of the volume charge.</p>&#13;
<p class="indent">In the case where volume charge density is uniform, multiplying it by the volume gives the total charge. In general, volume charge density is not uniform. We perform the integral in much the same way as we did for the line charge and the surface charge.</p>&#13;
<h4 class="h4" id="ch24lev9">Calculating Total Charge in Haskell</h4>&#13;
<p class="noindent">Here is a function called <code>totalCharge</code> that computes the total charge of a charge distribution:</p>&#13;
<pre>totalCharge :: ChargeDistribution -&gt; Charge&#13;
totalCharge (PointCharge   q      _)&#13;
    = q&#13;
totalCharge (LineCharge    lambda c)&#13;
    = scalarLineIntegral    (curveSample  1000) lambda c&#13;
totalCharge (SurfaceCharge sigma  s)&#13;
    = scalarSurfaceIntegral (surfaceSample 200) sigma s&#13;
totalCharge (VolumeCharge  rho    v)&#13;
    = scalarVolumeIntegral  (volumeSample   50) rho v&#13;
totalCharge (MultipleCharges ds    )&#13;
    = sum [totalCharge d | d &lt;- ds]</pre>&#13;
<p class="indent">The function <code>totalCharge</code> uses pattern matching on the input to treat each of the five data constructors separately. In the case of a point charge, the function simply returns the charge of the point charge. For a line charge, <span epub:type="pagebreak" id="page_468"/>the function uses <code>scalarLineIntegral</code>, which we’ll write in <a href="ch25.xhtml">Chapter 25</a>, to perform the integral in Equation 24.1. The <code>scalarLineIntegral</code> function takes a method to approximate the curve, a scalar field, and a curve as inputs, and it returns an approximation to the line integral of the scalar field over the curve.</p>&#13;
<p class="indent">For a surface charge, the function uses <code>scalarSurfaceIntegral</code>, which we’ll write in <a href="ch25.xhtml">Chapter 25</a>, to perform the integral shown in Equation 24.2. The <code>scalarSurfaceIntegral</code> function takes as inputs a method to approximate the surface, a scalar field, and a surface, and it returns an approximation to the surface integral of the scalar field over the surface. As we’ll see in the next chapter, the method <code>surfaceSample</code> approximates the surface with a number of patches equal to twice the square of the number given; the value of 200 shown earlier will use 80,000 patches.</p>&#13;
<p class="indent">For a volume charge, the function uses <code>scalarVolumeIntegral</code>, which we will write in <a href="ch25.xhtml">Chapter 25</a>, to perform the integral shown in Equation 24.3. The <code>scalarVolumeIntegral</code> function takes a method to approximate the volume, a scalar field, and a volume as inputs, and it returns an approximation to the volume integral of the scalar field over the volume. As we’ll see in the next chapter, the method <code>volumeSample</code> approximates the volume with a number of volume elements equal to five times the cube of the number given; the value of 50 shown earlier will use 625,000 volume elements.</p>&#13;
<p class="indent">In the case of multiple charges, the function calculates the total charge of each distribution in the list and adds the results together. Because <code>total</code> <code>Charge</code> uses <code>totalCharge</code> to carry this out, it is a recursive function.</p>&#13;
<p class="indent">Let’s check the total charge of the distributions we defined earlier.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l Charge</span>&#13;
[ 1 of 11] Compiling Newton2          ( Newton2.hs, interpreted )&#13;
[ 2 of 11] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )&#13;
[ 3 of 11] Compiling SimpleVec        ( SimpleVec.hs, interpreted )&#13;
[ 4 of 11] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )&#13;
[ 5 of 11] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )&#13;
[ 6 of 11] Compiling MOExamples       ( MOExamples.hs, interpreted )&#13;
[ 7 of 11] Compiling Electricity      ( Electricity.hs, interpreted )&#13;
[ 8 of 11] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )&#13;
[ 9 of 11] Compiling Geometry         ( Geometry.hs, interpreted )&#13;
[10 of 11] Compiling VectorIntegrals  ( VectorIntegrals.hs, interpreted )&#13;
[11 of 11] Compiling Charge           ( Charge.hs, interpreted )&#13;
Ok, 11 modules loaded.&#13;
*Charge&gt; <span class="codestrong1">totalCharge protonOrigin</span>&#13;
1.602176634e-19&#13;
*Charge&gt; <span class="codestrong1">totalCharge $ chargedLine 0.25 2</span>&#13;
0.2500000000000002</pre>&#13;
<p class="indent">The total charge of a proton is just the charge of a proton. The total charge of a line charge is the value we gave for the total charge of the line charge.</p>&#13;
<h3 class="h3" id="ch24lev10"><span epub:type="pagebreak" id="page_469"/>Electric Dipole Moment</h3>&#13;
<p class="noindent">An <em>electric dipole</em> is a combination of positive and negative electric charges separated in space. The simplest case consists of a point charge <em>q</em> and a point charge –<em>q</em> separated by some distance <em>d</em>. An electric dipole creates an electric field and also responds to an electric field by feeling a force and/or a torque, so it can be thought of as an electrically active entity similar to electric charge itself. An electric charge distribution with a total charge of 0 often looks like an electric dipole. A neutral diatomic molecule such as sodium chloride is an example of an electric dipole.</p>&#13;
<p class="indent">We characterize an electric dipole by its <em>electric dipole moment</em>, a vector that points from the negative charge toward the positive charge. For the case of charges <em>q</em> and –<em>q</em> separated by distance <em>d</em>, the dipole moment is <strong>p</strong> = <em>q</em><strong>d</strong>, where <strong>d</strong> is the displacement vector from the position of –<em>q</em> to the position of <em>q</em>. The <strong>p</strong> used for electric dipole moment is not related to the <strong>p</strong> used for momentum.</p>&#13;
<p class="indent">The charge distribution <code>simpleDipole</code> describes two charges, <em>q</em> and – <em>q</em>, separated by distance <em>d</em>. The dipole is centered at the origin. The function takes an electric dipole moment and the distance between the point charges as input.</p>&#13;
<pre>simpleDipole :: Vec  -- electric dipole moment&#13;
             -&gt; R    -- charge separation&#13;
             -&gt; ChargeDistribution&#13;
simpleDipole p sep&#13;
    = let q    = magnitude p / sep&#13;
          disp = (sep/2) *^ (p ^/ magnitude p)&#13;
      in MultipleCharges&#13;
             [PointCharge   q  (shiftPosition          disp  origin)&#13;
             ,PointCharge (-q) (shiftPosition (negateV disp) origin)&#13;
             ]</pre>&#13;
<p class="indent">The function computes the charge <code>q</code> of the point charges by dividing the magnitude of the dipole moment by the separation. The displacement vector <code>disp</code> points from the origin to the positive point charge. The displacement vector <code>negateV disp</code> points from the origin to the negative point charge.</p>&#13;
<p class="indent">An electric dipole moment can be associated with any charge distribution. A volume charge density <em>ρ</em> has an electric dipole moment given by</p>&#13;
<div class="imagec"><img src="Images/469equ01.jpg" alt="Image" width="408" height="47"/></div>&#13;
<p class="indent">If the total charge of a charge distribution is 0, the electric dipole moment is often the best simple characterization of the distribution, giving a good approximation for the electric field the distribution creates.</p>&#13;
<p class="indent">Of course, the total charge and the electric dipole moment of a charge distribution could both be 0. In that case, you can define an electric quadrupole moment that characterizes the distribution. In fact, any charge distribution can be viewed as a combination of an electric monopole (point charge), electric dipole, electric quadrupole, electric octupole, and higher <span epub:type="pagebreak" id="page_470"/>terms, called a <em>multipole expansion</em>. We will not explore the expansion in this book, except to note that the electric dipole is the second term in the expansion. Like mathematical series expansions such as the Taylor series, the first nonzero term in the multipole expansion often gives a simple approximation for a charge distribution.</p>&#13;
<p class="indent">The function <code>electricDipoleMoment</code> computes the electric dipole moment for any charge distribution.</p>&#13;
<pre>electricDipoleMoment :: ChargeDistribution -&gt; Vec&#13;
electricDipoleMoment (PointCharge   q     r)&#13;
    = q *^ displacement origin r&#13;
electricDipoleMoment (LineCharge    lambda c)&#13;
    = vectorLineIntegral    (curveSample  1000) (\r -&gt; lambda r *^ rVF r) c&#13;
electricDipoleMoment (SurfaceCharge sigma  s)&#13;
    = vectorSurfaceIntegral (surfaceSample 200) (\r -&gt; sigma  r *^ rVF r) s&#13;
electricDipoleMoment (VolumeCharge  rho    v)&#13;
    = vectorVolumeIntegral  (volumeSample   50) (\r -&gt; rho    r *^ rVF r) v&#13;
electricDipoleMoment (MultipleCharges ds    )&#13;
    = sumV [electricDipoleMoment d | d &lt;- ds]</pre>&#13;
<p class="indent">The function uses pattern matching on the input to split the definition into cases based on the constructor for the distribution. The dipole moment for a point charge is the product of the charge and a displacement vector from the origin to the position of the point charge. For a line charge, we do a vector line integral, similar to Equation 24.4. A surface charge requires a surface integral, and a volume charge uses Equation 24.4 itself. Finally, the dipole moment of a combination distribution is the vector sum of the dipole moments of each component.</p>&#13;
<p class="indent">Another charge distribution that behaves like an electric dipole is a line charge with a linear charge density that smoothly varies from negative to positive. The function <code>lineDipole</code> produces such a distribution, with the linear charge density changing linearly with position. The dipole is centered at the origin, where the linear charge density is 0.</p>&#13;
<pre>lineDipole :: Vec  -- dipole moment&#13;
           -&gt; R    -- charge separation&#13;
           -&gt; ChargeDistribution&#13;
lineDipole p sep&#13;
    = let disp = (sep/2) *^ (p ^/ magnitude p)&#13;
          curve = straightLine (shiftPosition (negateV disp) origin)&#13;
                               (shiftPosition          disp  origin)&#13;
          coeff = 12 / sep**3&#13;
          lambda r = coeff * (displacement origin r &lt;.&gt; p)&#13;
      in LineCharge lambda curve</pre>&#13;
<p class="indent">The function takes the same inputs that <code>simpleDipole</code> took and determines the linear charge density necessary to produce the desired electric dipole moment.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_471"/>In the next chapter, we’ll see several examples of electric dipoles. We’ll look at a simple dipole composed of two point particles, an ideal dipole, and a line dipole. We’ll compare their electric fields, noting the commonalities.</p>&#13;
<h3 class="h3" id="ch24lev11">Summary</h3>&#13;
<p class="noindent">This chapter introduced charge distributions, including line charges, surface charges, and volume charges. We wrote a data type for charge distributions that can handle point charges, line charges, surface charges, volume charges, and combinations of these. We wrote some examples of charge distributions. We wrote functions to calculate the total charge and the electric dipole moment of a distribution. In the next chapter, we will calculate the electric field produced by a charge distribution.</p>&#13;
<h3 class="h3" id="ch24lev12">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 24.1.</strong> Use the functions <code>chargedLine</code> and <code>chargedBall</code> to create some charge distributions and confirm, using <code>totalCharge</code>, that they have the total charge you expect.</p>&#13;
<p class="noindentts"><strong>Exercise 24.2.</strong> Find the total charge and electric dipole moment of the parallel-plate capacitor <code>diskCap</code>, choosing some parameters for radius, plate separation, and surface charge density. By varying the parameters, try to determine how the total charge and electric dipole moment depend on radius, plate separation, and surface charge density.</p>&#13;
<p class="noindentts"><strong>Exercise 24.3.</strong> Write a charge distribution for a uniformly charged surface in the shape of a disk, with total charge <code>q</code> and radius <code>radius</code>.</p>&#13;
<pre>chargedDisk :: Charge -&gt; R -&gt; ChargeDistribution&#13;
chargedDisk q radius = undefined q radius</pre>&#13;
<p class="indent">Check that your distribution has the total charge you expect by using <code>totalCharge</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 24.4.</strong> Write a charge distribution for a uniformly charged circle (one with constant linear charge density), with total charge <code>q</code> and radius <code>radius</code>.</p>&#13;
<pre>circularLineCharge :: Charge -&gt; R -&gt; ChargeDistribution&#13;
circularLineCharge q radius = undefined q radius</pre>&#13;
<p class="indent">Check that your distribution has the total charge you expect by using <code>totalCharge</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 24.5.</strong> Write a charge distribution for a uniformly charged surface in the shape of a square, with total charge <code>q</code> and side length <code>side</code>.</p>&#13;
<pre>chargedSquarePlate :: Charge -&gt; R -&gt; ChargeDistribution&#13;
chargedSquarePlate q side = undefined q side</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_472"/>Check that your distribution has the total charge you expect by using <code>totalCharge</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 24.6.</strong> Write a charge distribution for a uniformly charged surface in the shape of a sphere, with total charge <code>q</code> and radius <code>radius</code>.</p>&#13;
<pre>chargedSphericalShell :: Charge -&gt; R -&gt; ChargeDistribution&#13;
chargedSphericalShell q radius = undefined q radius</pre>&#13;
<p class="indent">Check that your distribution has the total charge you expect by using <code>totalCharge</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 24.7.</strong> Write a charge distribution for a uniformly charged volume in the shape of a cube, with total charge <code>q</code> and side length <code>side</code>.</p>&#13;
<pre>chargedCube :: Charge -&gt; R -&gt; ChargeDistribution&#13;
chargedCube q side = undefined q side</pre>&#13;
<p class="indent">Check that your distribution has the total charge you expect by using <code>totalCharge</code>.</p>&#13;
<p class="noindentts"><strong>Exercise 24.8.</strong> Use the functions <code>simpleDipole</code> and <code>lineDipole</code> to create some charge distributions, and confirm, using <code>electricDipoleMoment</code>, that they have the electric dipole moments you expect.</p>&#13;
<p class="noindentts"><strong>Exercise 24.9.</strong> Write a charge distribution for a parallel-plate capacitor in which the plates are square surfaces, with side length <code>side</code>, separated by a distance <code>plateSep</code>. One plate has a uniform surface charge density <code>sigma</code>, and the other has a uniform surface charge density <code>-sigma</code>.</p>&#13;
<pre>squareCap :: R -&gt; R -&gt; R -&gt; ChargeDistribution&#13;
squareCap side plateSep sigma = undefined side plateSep sigma</pre>&#13;
<p class="noindentts"><strong>Exercise 24.10.</strong> A hydrogen atom in its ground state is made up of a stationary proton at the origin and an electron cloud with volume charge density</p>&#13;
<div class="imagec"><img src="Images/472equ01.jpg" alt="Image" width="198" height="48"/></div>&#13;
<p class="noindent">where <em>e</em> is the elementary charge of the proton and <em>a</em><sub>0</sub> is the Bohr radius. Write a charge distribution for this hydrogen atom. Since our volumes are finite, use a spherical ball with a radius of 10<sub><em>a</em>0</sub> for the volume that holds the charge density. This will omit a tiny bit of the electron’s negative charge. See how close to neutral your hydrogen atom is by using <code>totalCharge</code> on the charge distribution you write.</p>&#13;
<pre>hydrogen :: ChargeDistribution&#13;
hydrogen = undefined</pre>&#13;
</div></body></html>