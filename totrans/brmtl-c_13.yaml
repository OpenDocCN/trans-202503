- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Preprocessor
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The basic C compiler has a number of powerful features, but there are some things
    it just can’t do. To get around its limitations, a preprocessor was added to the
    language. The preprocessor is primarily a *macro processor*, a program that replaces
    text with other text, but it can also include and exclude text and perform other
    actions based on certain conditions. The idea is to have one program (the preprocessor)
    do a small, simple text editing job and then feed that into the compiler proper.
    Since those two steps (and a few others) are hidden behind the `gcc` command,
    you hardly think about them, but they are there.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When `SIZE` is defined to mean `20`, the preprocessor essentially does a global
    search and replace of `SIZE` with `20`.
  prefs: []
  type: TYPE_NORMAL
- en: The HAL library we’re using with our STM microprocessor makes extensive use
    of the preprocessor in a couple of ways. First, the headers contain a `#define`
    for every gettable and settable bit in the processor, and there are quite a few
    of them. Second, STMicroelectronics doesn’t make only one chip; it makes a wide
    variety. Rather than have 20 different header files with information on 20 chips,
    it uses a process called *conditional compilation* to compile only the parts of
    the header file that are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Macros
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the simple macros. A *macro* is basically a pattern (in this
    case, `SIZE`) that is replaced by something else (in this case, `20`). The `#define`
    preprocessor directive is used to define the pattern and replacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a C program. The preprocessor works on anything, including just
    English text. Let’s run it through the preprocessor using the `-E` flag, which
    tells `gcc` to run the program through the preprocessor only and stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the preprocessed results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The lines beginning with a hash mark (`#`) are called *line markers*. They consist
    of a hash mark, a line number, and the name of the file (and some other junk).
    Since the preprocessor may add or remove lines, it would be impossible for the
    compiler to know where it was in the original input file without them.
  prefs: []
  type: TYPE_NORMAL
- en: A lot happens before the first line is processed, but finally we get to the
    second occurrence of it 1, and the output 2 shows that `SIZE` has been replaced
    with the defined value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preprocessor takes things literally, which can get you into trouble, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**square.c**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This example finds the area of a square. It includes a little margin so the
    side of the square is defined 1. To get the area, we multiply the sides together
    and print the result 2. However, this program contains a bug: `SIZE` is not `12`;
    it is `10 + 2`. The preprocessor is a dumb text editor. It does not understand
    C syntax or arithmetic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After passing the program through the preprocessor, we can see where we made
    our mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '**square.i**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned previously, the preprocessor doesn’t understand C. When we use
    the following statement, it defines `SIZE` as literally `10 + 2` rather than `12`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And as you can see, `12 * 12` is a different number from `10 + 2 * 10 + 2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `#define` to define constants more complex than a simple number,
    we put parentheses around the entire expression, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Following this style rule prevents incorrect results from an unexpected order
    of operations after substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the issue of incorrect macro evaluation entirely when the purpose
    of a `#define` is to set or calculate a value in one place and then use it throughout
    the program, use `const`, which is preferred over `#define` wherever possible.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The main reason for this rule is that the `const` modifier is part of the C
    language, and the compiler will evaluate the expression assigned to a `const`
    variable, so `SIDE` is actually `12`.
  prefs: []
  type: TYPE_NORMAL
- en: When C was first designed, it had no `const` modifier, so everyone had to use
    the `#define` statement, which is why `#define` is so widely used, even though
    the more modern `const` has been available for some time.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Parameterized* *macros* allow us to give arguments to macros. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we don’t need to put the parentheses around the argument in the
    expansion. We could write the macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is this bad? Consider what happens when we use this macro with an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The style rule is to include parentheses around the arguments to parameterized
    macros. Without the parentheses, `DOUBLE(1+2)` expands to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the parentheses, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We already have a rule that states to not use `++` or `--` except on lines
    by themselves. Let’s see what happens when we break that rule using a parameterized
    macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What’s the value of `x` after this is executed? It’s `8` instead of `6`, as
    expected. Worse, the value of `y` can be anything, because C’s order of execution
    rules are ambiguous when it comes to mixing multiply (`*`) and increment (`++`)
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re going to write code like this, consider `inline` functions, which
    replace the function call with the body of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It works even if you use the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But again, you shouldn’t write code like this. Instead, write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Use `inline` functions instead of parameterized macros whenever possible. Because
    `inline` functions are part of the C language, the compiler can make sure they’re
    being used correctly (unlike the preprocessor, which just replaces text blindly).
  prefs: []
  type: TYPE_NORMAL
- en: Code Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve been writing macros to define constants and simple expressions.
    We can use `#define` to define code. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, this code has some problems. First, it’s not obvious where the variable
    `i` comes from. We’ve also obscured what’s incrementing it, which is why this
    sort of macro is rarely seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more common macro is one that emulates a short function. Let’s define a macro
    called `DIE` that writes out a message and then kills the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the backslash (`\`) to extend the macro over multiple lines. We can
    use this macro as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, it works, which is due more to luck than design. The problem
    is that `DIE` looks like a function, so we can treat it as a function. Let’s put
    it inside an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand why this is a problem, let’s look at the expansion of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is properly indented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In other words, it will always exit, even if the index is good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see if we can fix this issue by putting curly brackets (`{}`) around
    our statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This now works in the following case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it does not work in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code generates an error message: `else without previous if`. However,
    we have an `if` right there. Let’s look at the expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is that before the `else`, C wants a statement ending with
    a semicolon (`;`) *or* a set of statements enclosed in curly brackets (`{}`).
    It doesn’t know what to do with a set of statements enclosed in curly brackets
    that ends in a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is to use an obscure C statement called the `do`/`while`.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The statements in the block after `do` always execute once, and then again as
    long the `condition` is true. Although it is part of the C language standard,
    I’ve seen it used only twice in the wild, and one of those times was as a punch
    line to a joke.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is used for code macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It works because we can put a semicolon after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This code expands to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Syntactically, `do`/`while` is a single statement, and we can include a semicolon
    after it without trouble. The code within the curly brackets (`printf` and `exit`)
    is safely encapsulated inside the `do`/`while`. The code outside the curly brackets
    is one statement, and that’s what we want. Now the compiler will accept the code
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional compilation allows us to change what’s in our code at compile time.
    The classic use for this feature is to have a debug version and a production version
    of a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#ifdef`/`#endif` directive pair will compile the code between the two
    directives if a symbol is defined. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking, the `// DEBUG` comment is not required, but be sure to include
    it because matching `#ifdef`/`#endif` pairs is hard enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your program looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'then the preprocessed result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if your program looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'then the preprocessed result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Because `DEBUG` is not defined, no code is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem is that all the `#ifdef` statements tend to make the program look
    ugly. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same thing with a lot less code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we used the `#else` directive to tell the preprocessor to reverse
    the sense of the `#if`. If `DEBUG` is defined, calls to `debug` will be replaced
    with calls to `printf`; otherwise, they’ll be replaced by blank space. In this
    case, we don’t need the `do`/`while` trick because the code macro contains a single
    function call (with no semicolon).
  prefs: []
  type: TYPE_NORMAL
- en: Another directive, `#ifndef`, is true if a symbol is not defined and otherwise
    is used the same way as the `#ifdef` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Where Symbols Get Defined
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define symbols in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the program with a `#define`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the command line
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Predefined inside the preprocessor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve already described symbols defined inside a program, so let’s look at the
    other two options.
  prefs: []
  type: TYPE_NORMAL
- en: Command Line Symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To define a symbol on the command line, use the `-D` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `-DDEBUG` argument defines the `DEBUG` symbol so the preprocessor can use
    it. In this example, it does a `#define DEBUG 1` before the program starts. We
    used this symbol in the previous code to control whether `debug` statements were
    compiled in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to symbols, we add to the compilation command manually, and the
    STM32 Workbench generates a makefile to compile a program that defines a number
    of symbols on the command line. The most significant is defined by the `-DSTM32F030x8`
    option. The *CMSIS/device/stm32f0xx.h* file uses the `STM32F030x8` symbol to include
    board-specific files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The STM firmware supports a number of boards, only one of which is the NUCLEO-F030R8\.
    Each chip has a different set of I/O devices located at different places. You
    don’t need to worry about where they are, as the firmware will find the right
    place using the preceding code. This file says, “If I’m an STM32F030x6, include
    the header file for that board; if I’m an STM32F030x8, include the header file
    for that board,” and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The directives used are `#if` and `#elif`. The `#if` tests to see whether the
    expression that follows is true (in this case, whether `STM32F030x6` is defined).
    If it is, the code following it will be compiled. The `#elif` is a combination
    of `#else` and `#if`, which says if the expression is not true, then test another
    expression. The other directive, `defined`, is true if the symbol is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined Symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the preprocessor itself defines a number of symbols, such as `__VERSION__`
    (to specify the compiler version) and `__linux` (on Linux systems). To see what’s
    predefined on your system, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__cplusplus` symbol is defined only if you are compiling a C++ program.
    Frequently, you’ll see something like this in files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It’s part of a song and dance needed by C++ so it can use C programs. You can
    just ignore it for now.
  prefs: []
  type: TYPE_NORMAL
- en: Include Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `#include` directive tells the preprocessor to bring in an entire file
    as if it were part of the original file. There are two forms of this directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first form brings in system header files (files that come with the compiler
    or system libraries you are using). The second brings in files you create.
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem with header files is that they can be included twice. If that happens,
    you get a lot of duplicate defined symbols and other problems. The solution to
    this problem is to add a *sentinel* by using the following design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first time through, the `__FILE_NAME_H__` symbol (the sentinel) is not defined,
    so the entire header file is included. This is good, because we wanted it included—*once*.
    The next time through, `__FILE_NAME_H__` is defined, and the `#ifndef` prevents
    the code below it from being included until the `#endif` is reached at the end
    of the file. Thus, although the header file is included twice, the contents of
    the file appear only once.
  prefs: []
  type: TYPE_NORMAL
- en: Other Preprocessor Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A few minor preprocessor directives are also useful, such as `#warning`, `#error`,
    and `#pragma`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `#warning` directive displays a compiler warning if seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The related `#error` directive issues an error and stops your program from
    compiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#pragma` directive defines compiler-dependent controls. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This GCC-specific `#pragma` turns off warnings about missing prototypes, includes
    a buggy include file, and turns warnings back on.
  prefs: []
  type: TYPE_NORMAL
- en: Preprocessor Tricks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preprocessor is a dumb macro processor, and as a result, we’ve had to adopt
    a number of style rules, described previously, to keep us out of trouble. The
    power of the preprocessor also allows us to perform some interesting tricks to
    make our lives easier. One of them is the `enum` trick, which we discussed in
    Chapter 8. In this section, we’ll look at commenting out code.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to disable some code for testing. One way to do that is to
    comment out the code. For example, suppose the auditing process is buggy; we can
    disable it until the audit group gets its act together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the original code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the code with the audit removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Every line that we wanted removed now begins with the comment (`//`) marker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commenting out every line is labor-intensive, however. Instead, we can use
    conditional compilation to remove the code. All we need to do is surround it with
    `#ifdef UNDEF` and `#endif // UNDEF` statements, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The code inside the `#ifdef`/`#endif` block will be compiled only if `UNDEF`
    is defined, and no sane programmer would do that. Using `#if 0` / `#endif` does
    the same thing without depending on the sanity of other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C preprocessor is a simple yet powerful automatic text editor. Used properly,
    it can make programming tremendously easier. It allows you to define simple numeric
    macros as well as small code macros. (Actually, you can define large code macros,
    but you really don’t want to do that.)
  prefs: []
  type: TYPE_NORMAL
- en: One of its biggest features is the `#include` directive, which facilitates the
    sharing of interfaces between modules. Also, the `#ifdef` capabilities allow you
    to write one program that has multiple personalities through the use of conditional
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: However, you must remember that the preprocessor does not understand C syntax.
    As a result, you must remember several style rules and programming patterns to
    use the system effectively.
  prefs: []
  type: TYPE_NORMAL
- en: For all of its limitations and quirks, the preprocessor can be a powerful tool
    when it comes to creating C programs.
  prefs: []
  type: TYPE_NORMAL
- en: Programming Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a macro to swap two integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Advanced: Write a macro to swap two integers of any type. (Read the documentation
    for GCC’s `typeof` keyword before doing this.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a macro called `islower(x)` that returns true if `x` is a lowercase letter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Crazy advanced: Figure out how the program *zsmall.c* works ([https://www.cise.ufl.edu/~manuel/obfuscate/zsmall.hint](https://www.cise.ufl.edu/~manuel/obfuscate/zsmall.hint)).
    This program is a winner of the obfuscated C contest (it won an award for “Best
    Abuse of the Preprocessor”). All it does is print a list of primes, but all the
    calculations and loops are done using the preprocessor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
