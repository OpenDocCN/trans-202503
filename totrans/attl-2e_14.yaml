- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: 'FLAIM: AN AUTOTOOLS EXAMPLE'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM：一个AUTOTOOLS示例
- en: '*Uncle Abner said . . . a person that started in to carry a cat home by the
    tail was gitting knowledge that was always going to be useful to him*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*阿布内尔叔叔说……一个人开始提着猫的尾巴回家，是在获得一种永远有用的知识。*'
- en: —Mark Twain, Tom Sawyer Abroad
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —马克·吐温，《汤姆·索亚在海外》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: So far in this book, I’ve taken you on a whirlwind tour of the main features
    of Autoconf, Automake, and Libtool, as well as other tools that work well with
    the Autotools. I’ve done my best to explain them in a manner that is not only
    simple to digest but also easy to retain— especially if you’ve had the time and
    inclination to follow along with my examples on your own. I’ve always believed
    that no form of learning comes anywhere close to the learning that happens while
    doing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我已经带你快速浏览了Autoconf、Automake和Libtool的主要特性，以及与Autotools配合得好的其他工具。我尽力以一种既简洁易懂又便于记忆的方式进行解释——特别是如果你有时间和兴趣跟随我提供的示例进行实践。我始终认为，没有什么学习方式能比在实践中获得的学习更有效。
- en: In this chapter and the next, we’ll continue learning about the Auto­tools by
    studying the process I used to convert an existing, real-world, open source project
    from a complex handcoded makefile to a complete GNU Autotools build system. The
    examples I provide in these chapters illustrate the decisions I had to make during
    the conversion process as well as some concrete uses of Autotools features, including
    a few that I haven’t yet presented in previous chapters. These two chapters will
    round out our study of the Autotools by presenting real solutions to real problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章及下一章中，我们将继续通过研究我用来将一个现有的、真实的开源项目从一个复杂的手写makefile转换为一个完整的GNU Autotools构建系统的过程，来学习更多关于Autotools的内容。我在这些章节中提供的示例说明了在转换过程中我做出的决策以及一些Autotools特性的具体应用，包括一些我在之前的章节中尚未展示的特性。这两章将通过展示解决实际问题的真实方案，完成我们对Autotools的学习。
- en: The project I chose to convert is called *FLAIM*, which stands for *FLexible
    Adaptable Information Management*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择转换的项目叫做*FLAIM*，它代表着*灵活适应性信息管理*。
- en: What Is FLAIM?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是FLAIM？
- en: FLAIM is a highly scalable database-management library written in C++ and built
    on its own thin portability layer called the FLAIM toolkit. Some readers may recognize
    FLAIM as the database used by both Novell^([1](footnote.xhtml#ch14fn1)) eDirectory
    and the Novell GroupWise server. FLAIM originated at WordPerfect in the late 1980s,
    and it became part of Novell’s software portfolio during the Novell/WordPerfect
    merger in 1994\. Novell eDirectory used a spin-off of a then-late version of FLAIM
    to manage directory information bases that contain over a billion objects, and
    GroupWise used a much earlier spin-off to manage various server-side databases.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM是一个高可扩展的数据库管理库，使用C++编写，并建立在名为FLAIM工具包的自身轻量级可移植性层之上。有些读者可能会认识到FLAIM是Novell^([1](footnote.xhtml#ch14fn1))
    eDirectory和Novell GroupWise服务器使用的数据库。FLAIM起源于1980年代末的WordPerfect，并在1994年Novell和WordPerfect合并时成为Novell软件组合的一部分。Novell
    eDirectory使用FLAIM的一个衍生版本来管理包含超过十亿个对象的目录信息库，GroupWise则使用一个更早的衍生版本来管理各种服务器端数据库。
- en: Novell made the FLAIM source code available as an open source project licensed
    under the GNU Lesser General Public License (LGPL) version 2^([2](footnote.xhtml#ch14fn2))
    in 2006\. The FLAIM project is currently hosted by [SourceForge.net](http://SourceForge.net),
    and it is the result of 25 years of development and hardening in various WordPerfect
    and Novell products and projects.^([3](footnote.xhtml#ch14fn3))
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Novell在2006年将FLAIM源代码作为开源项目发布，并采用GNU较宽松公共许可证（LGPL）版本2^([2](footnote.xhtml#ch14fn2))。FLAIM项目目前托管在[SourceForge.net](http://SourceForge.net)上，经过了25年的开发和在各种WordPerfect和Novell产品及项目中的巩固与完善。^([3](footnote.xhtml#ch14fn3))
- en: Why FLAIM?
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么选择FLAIM？
- en: While FLAIM is far from a mainstream OSS project, it has several qualities that
    make it a perfect example for showing how to convert a project to use the Autotools.
    For one, FLAIM is currently built using a handcoded GNU makefile that contains
    over 2,000 lines of complex make script. The FLAIM makefile contains a number
    of GNU Make–specific constructs, and thus you can only process this makefile using
    GNU Make. Individual (but nearly identical) makefiles are used to build the *flaim*,
    *xflaim*, and *flaimsql* database libraries, and the FLAIM toolkit (*ftk*), as
    well as several utility and sample programs on Linux, various flavors of Unix,
    Windows, and NetWare.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 FLAIM 远不是一个主流的开源软件项目，但它具有若干特质，使其成为展示如何将项目转换为使用 Autotools 的完美示例。首先，FLAIM 当前是使用一个手写的
    GNU Makefile 构建的，该 Makefile 包含超过 2000 行复杂的 make 脚本。FLAIM 的 Makefile 包含许多 GNU Make
    特有的构造，因此只能使用 GNU Make 来处理这个 Makefile。多个（但几乎相同的）Makefile 被用来构建 *flaim*、*xflaim*
    和 *flaimsql* 数据库库，以及 FLAIM 工具包（*ftk*），并在 Linux、各种 Unix 版本、Windows 和 NetWare 上构建几个实用程序和示例程序。
- en: The existing FLAIM build system targets several different flavors of Unix, including
    AIX, Solaris, and HP-UX, as well as Apple’s macOS. It also targets multiple compilers
    on these systems. These features make FLAIM ideal for this sample conversion project
    because I can show you how to handle differences in operating systems and toolsets
    in the new *configure.ac* files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的 FLAIM 构建系统支持多种不同版本的 Unix 操作系统，包括 AIX、Solaris 和 HP-UX，以及 Apple 的 macOS。它还支持这些系统上的多种编译器。这些特性使得
    FLAIM 成为该示例转换项目的理想选择，因为我可以向你展示如何在新的 *configure.ac* 文件中处理操作系统和工具集的差异。
- en: The existing build system also contains rules for many of the standard Automake
    targets, such as distribution tarballs. Additionally, it provides rules for building
    binary installation packages, as well as RPMs for systems that can build and install
    RPM packages. It even provides targets for building Doxygen^([4](footnote.xhtml#ch14fn4))
    description files, which it then uses to build source documentation. I’ll spend
    a few paragraphs showing you how you can add these types of targets to the infrastructure
    provided by Automake.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的构建系统还包含许多标准 Automake 目标的规则，例如分发 tar 包。此外，它还提供了构建二进制安装包的规则，以及为能够构建和安装 RPM
    包的系统提供的 RPM 规则。它甚至提供了构建 Doxygen^([4](footnote.xhtml#ch14fn4)) 描述文件的目标，之后用于生成源代码文档。我将用几段话向你展示如何将这些类型的目标添加到
    Automake 提供的基础设施中。
- en: The FLAIM toolkit is a portability library that third-party projects can incorporate
    and consume independently. We can use the toolkit to demonstrate Autoconf’s ability
    to manage separate subprojects as optional subdirectories within a project. If
    the user already has the FLAIM toolkit installed on their build machine, they
    can use the installed version or, optionally, override it with a local copy. On
    the other hand, if the toolkit is not installed, then the local, subdirectory-based
    copy will be used by default.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 工具包是一个可移植性库，第三方项目可以独立地将其集成并使用。我们可以使用该工具包展示 Autoconf 如何将独立的子项目作为可选子目录管理在一个项目中。如果用户的构建机器上已经安装了
    FLAIM 工具包，他们可以使用已安装的版本，或者选择覆盖为本地副本。另一方面，如果未安装工具包，则默认使用本地子目录版的工具包。
- en: The FLAIM project also provides code to build both Java and C# language bindings,
    so I’ll delve into those esoteric realms a bit. I won’t go into great detail on
    building either Java or C# applications, but I will cover how to write *Makefile.am*
    files that generate both Java and C# programs and language-binding libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 项目还提供了用于构建 Java 和 C# 语言绑定的代码，因此我将稍微探讨这些晦涩的领域。我不会深入讲解如何构建 Java 或 C# 应用程序，但我会介绍如何编写生成
    Java 和 C# 程序及语言绑定库的 *Makefile.am* 文件。
- en: The FLAIM project makes good use of unit tests. These are built as individual
    programs that run without command line options, so I can easily show you how to
    add real-world unit tests to the new FLAIM Autotools build system using Automake’s
    trivial test framework.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 项目很好地利用了单元测试。这些测试作为独立程序构建，可以在没有命令行选项的情况下运行，因此我可以轻松向你展示如何使用 Automake 的简单测试框架将实际的单元测试添加到新的
    FLAIM Autotools 构建系统中。
- en: The FLAIM project and its original build system employ a reasonably modular
    directory layout, making it rather simple to convert to an Autotools modular build
    system. A simple pass of the `diff` utility over the directory tree should suffice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: FLAIM 项目及其原始构建系统采用了相当模块化的目录布局，使其转换为 Autotools 模块化构建系统变得相当简单。对目录树进行一次简单的 `diff`
    工具比较就足够了。
- en: Logistics
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后勤
- en: When the first edition of this book was published in 2010, FLAIM had just been
    released as an open source project on [SourceForge.net](http://SourceForge.net)
    using Subversion to manage its source code repository. Since that time, the FLAIM
    project has become, more or less, inactive. No one I’m aware of is actively using
    the code base. As I am the only remaining maintainer of the source code, I’ve
    made a GitHub repository for FLAIM specifically for [Chapters 14](ch14.xhtml)
    and [15](ch15.xhtml) of this second edition of this book. You can find this repository
    at the NSP-Autotools area on GitHub under the FLAIM project.^([5](footnote.xhtml#ch14fn5))
    I’ve updated the information in this chapter to be relevant to FLAIM’s storage
    in a git repository.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当本书的第一版在2010年发布时，FLAIM刚刚作为一个开源项目在[SourceForge.net](http://SourceForge.net)上发布，并使用Subversion管理其源代码库。从那时起，FLAIM项目基本上变得不活跃。我所知道的没有人正在积极使用该代码库。由于我是唯一剩下的源代码维护者，我为FLAIM创建了一个GitHub仓库，专门用于本书第二版的[第14章](ch14.xhtml)和[第15章](ch15.xhtml)。您可以在GitHub的FLAIM项目下的NSP-Autotools区域找到这个仓库。^([5](footnote.xhtml#ch14fn5))
    我已经更新了本章中的信息，以便与FLAIM在git仓库中的存储方式相关。
- en: The source code repository for this chapter follows a somewhat different style
    than that for preceding chapters. The original Autotools build system changes
    I made to the FLAIM [SourceForge.net](http://SourceForge.net) project are buried
    beneath, and intermixed with, several dozen unrelated changes. Rather than spend
    hours separating out these changes in an effort to provide you with proper before
    and after snapshots of the FLAIM code base, I simply chose to commit the final
    FLAIM code, with its Autotools build system, to the GitHub project.^([6](footnote.xhtml#ch14fn6))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码库与前几章的源代码库风格略有不同。我对FLAIM [SourceForge.net](http://SourceForge.net) 项目所做的原始Autotools构建系统更改被埋藏在几十个无关的更改之下，并与之交织在一起。与其花费数小时将这些更改分离开来，以便为您提供FLAIM代码库的前后快照，不如直接选择将最终的FLAIM代码和其Autotools构建系统提交到GitHub项目中。^([6](footnote.xhtml#ch14fn6))
- en: Do not be discouraged about FLAIM’s current activity status—it continues to
    provide a wide variety of opportunities to learn about Autotools build system
    techniques in real-world projects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不要对FLAIM当前的活动状态感到灰心——它仍然为我们提供了在现实世界项目中学习Autotools构建系统技术的各种机会。
- en: An Initial Look
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初步观察
- en: Let me start by saying that converting FLAIM from GNU makefiles to an Autotools
    build system is not a trivial project. It took me a couple of weeks, and much
    of that time was spent determining exactly what to build and how to do it—in other
    words, analyzing the legacy build system. Another significant portion of my time
    was spent converting aspects that lay on the outer fringes of Autotools functionality.
    For example, I spent *much* more time converting build system rules for building
    C# language bindings than I did converting rules for building the core C++ libraries.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我要说明将FLAIM从GNU makefile转换为Autotools构建系统并不是一个简单的项目。这花费了我几周的时间，其中大部分时间都用来确定具体需要构建什么以及如何构建——换句话说，就是分析遗留的构建系统。我花费的另一大部分时间则是在转换那些位于Autotools功能边缘的方面。例如，我花了*更多*时间来转换用于构建C#语言绑定的构建系统规则，而不是转换用于构建核心C++库的规则。
- en: The first step in this conversion project is to analyze FLAIM’s existing directory
    structure and build system. What components are actually built, and which components
    depend on which others? Can individual components be built, distributed, and consumed
    independently? These types of component-level relationships are important because
    they’ll often determine how you’ll lay out your project directory structure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换项目的第一步是分析FLAIM现有的目录结构和构建系统。哪些组件实际上被构建，哪些组件依赖于其他组件？是否可以单独构建、分发和消费各个组件？这些组件级别的关系非常重要，因为它们通常决定了你如何布局项目的目录结构。
- en: 'The FLAIM project is actually several small projects under one umbrella project
    within its repository. There are three separate and distinct database products:
    *flaim*, *xflaim*, and *flaimsql*. The flaim subproject is the original FLAIM
    database library used by eDirectory and GroupWise. The xflaim project is a hierarchical
    XML database developed for internal projects at Novell; it is optimized for path-oriented,
    node-based access. The flaimsql project is an SQL layer on top of the FLAIM database.
    It was written as a separate library in order to optimize the lower-level FLAIM
    API for SQL access. This project was an experiment that, frankly, isn’t quite
    finished (but it does compile).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The point is that all three of these database libraries are separate and unrelated
    to each other, with no interlibrary dependencies. Since they may easily be used
    independently of one another, they can actually be shipped as individual distributions.
    You could consider each an open source project in its own right. This, then, will
    become one of my primary goals: to allow the FLAIM open source project to be easily
    broken up into smaller open source projects that can be managed independently
    of one another.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: The FLAIM toolkit is also an independent project. While it’s tailored specifically
    for the FLAIM database libraries, providing just the system service abstractions
    required for a DBMS, it depends on nothing but itself, and thus it may easily
    be used as the basis for portability within other projects without dragging along
    any unnecessary database baggage.^([7](footnote.xhtml#ch14fn7))
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'The original FLAIM project was laid out in its repository as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The complete tree is fairly broad and somewhat deep in places, including significant
    utilities, tests, and other such binaries that are built by the legacy build system.
    At some point during the trek down into this hierarchy, I simply had to stop and
    consider whether it was worth converting that additional utility or layer. (If
    I hadn’t done that, this chapter would be twice as long and half as useful.) To
    this end, I’ve decided to convert the following elements:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The database libraries
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit and library interface tests
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The utilities and other such high-level programs found in various *util* directories
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java and C# language bindings found in the *xflaim* library
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll also convert the C# unit tests, but I won’t go into the Java unit tests,
    because I’m already converting the Java language bindings using Automake’s `JAVA`
    primary. Since Automake provides no help for C#, I have to provide everything
    myself anyway, so I’ll convert the entire C# code base. This will provide an example
    of writing the code for an entirely unsupported Automake product class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As stated earlier, my first true design decision was how to organize the original
    FLAIM project into subprojects. As it turns out, the existing directory layout
    is almost perfect. I’ve created a master *configure.ac* file in the top-level
    *flaim* directory, which is just under the repository root directory. This topmost
    *configure.ac* file acts as a sort of Autoconf control file for each of the four
    lower-level projects: ftk, flaim, flaimsql, and xflaim.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我的第一个真正的设计决策是如何将原始的FLAIM项目组织成子项目。结果表明，现有的目录布局几乎是完美的。我在顶层的*flaim*目录中创建了一个主*configure.ac*文件，该目录就在版本库的根目录下。这个最上层的*configure.ac*文件充当每个四个下级项目（ftk、flaim、flaimsql和xflaim）的Autoconf控制文件。
- en: I’ve managed the database library dependencies on the FLAIM toolkit by treating
    the toolkit as a pure external dependency defined by the `make` variables `FTKINC`
    and `FTKLIB`. I’ve conditionally defined these variables to point to one of a
    few different sources, including installed libraries and even locations given
    in user-specified configuration script options.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过将工具包视为一个纯外部依赖项来管理FLAIM工具包的数据库库依赖关系，该依赖项由`make`变量`FTKINC`和`FTKLIB`定义。我有条件地定义了这些变量，以指向多个不同的来源，包括已安装的库，甚至是用户指定的配置脚本选项中的位置。
- en: '*Adding the configure.ac Files*'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*添加configure.ac文件*'
- en: In the following directory layout, I’ve used an annotation column to indicate
    the placement of individual *configure.ac* files. Each of these files represents
    a project that may be packaged and distributed independently.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的目录布局中，我使用了注释列来指示每个*configure.ac*文件的位置。这些文件代表一个可能被打包并独立分发的项目。
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: My next task was to create these *configure.ac* files. The top-level file was
    trivial, so I created it by hand. The project-specific files were more complex,
    so I allowed the `autoscan` utility to do the bulk of the work for me. [Listing
    14-1](ch14.xhtml#ch14ex1) shows the top-level *configure.ac* file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我的下一个任务是创建这些*configure.ac*文件。顶层文件非常简单，因此我手动创建了它。与项目相关的文件更复杂，因此我让`autoscan`工具为我完成大部分工作。[Listing
    14-1](ch14.xhtml#ch14ex1)展示了顶层的*configure.ac*文件。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-1*: configure.ac: *The umbrella project’s Autoconf input file*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-1*: configure.ac: *Umbrella项目的Autoconf输入文件*'
- en: This *configure.ac* file is short and simple because it doesn’t do much; nevertheless,
    there are some new and important concepts here. I invented the name `flaim-projects`
    and the version number `1.0` at ➊. These are not likely to change unless really
    dramatic changes take place in the project directory structure or the maintainers
    decide to ship a complete bundle of the subprojects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*configure.ac*文件简短而简单，因为它没有做太多工作；尽管如此，这里有一些新的重要概念。我在➊处发明了`flaim-projects`这个名称和版本号`1.0`。除非项目目录结构发生重大变化，或者维护者决定发布一个包含所有子项目的完整捆绑包，否则这些内容不太可能改变。
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For your own projects, consider using the optional third argument to the *`AC_INIT`*
    macro. You can add an email or web address here to indicate to users where they
    can submit a bug report. The contents of this argument show up in* configure *output.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于你自己的项目，考虑使用`AC_INIT`宏的可选第三个参数。你可以在此处添加电子邮件或网址，指示用户可以在哪里提交 bug 报告。此参数的内容会显示在*configure*输出中。*'
- en: 'The most important aspect of an umbrella project like this is the `AC_CONFIG_SUBDIRS`
    macro at ➏, which I have yet to cover in this book. The argument is a whitespace-separated
    list of the subprojects to be built, where each is a complete *GCS*-compliant
    project in its own right. Here’s the prototype for this macro:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的Umbrella项目中最重要的方面是➏处的`AC_CONFIG_SUBDIRS`宏，这是本书中我尚未介绍的。该参数是一个以空格分隔的子项目列表，每个子项目都是一个完全符合*GCS*标准的独立项目。以下是该宏的原型：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It allows the maintainer to set up a hierarchy of projects in much the same
    way that Automake `SUBDIRS` configures the directory hierarchy for Automake within
    a single project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许维护者以与 Automake `SUBDIRS` 配置单个项目中的目录层次结构类似的方式设置项目层次结构。
- en: Because the four subprojects contain all the actual build functionality, this
    *configure.ac* file acts merely as a control file, passing all specified configuration
    options to each of the subprojects in the order they’re given in the macro’s argument.
    The FLAIM toolkit project must be built first since the other projects depend
    on it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这四个子项目包含所有实际的构建功能，所以这个*configure.ac*文件只是充当一个控制文件，将所有指定的配置选项传递给宏参数中给出的顺序中的每个子项目。必须首先构建FLAIM工具包项目，因为其他项目依赖于它。
- en: Automake in the Umbrella Project
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Umbrella 项目中的 Automake
- en: Automake usually requires the existence of several text files in the top-level
    project directory, including the *AUTHORS*, *COPYING*, *INSTALL*, *NEWS*, *README*,
    and *ChangeLog* files. It would be nice not to have to deal with these files in
    the umbrella project. One way to accomplish this is to simply not use Automake
    in the umbrella project. I’d either have to write my own *Makefile.in* template
    for this directory or use Automake just once to generate a *Makefile.in* template
    that I could then check into the repository as part of the project, along with
    the *install-sh* and *missing* scripts added by `automake` `--add-missing` (or
    `autoreconf -i`). Once these files were in place, I could remove `AM_INIT_AUTOMAKE`
    from the master *configure.ac* file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Automake通常要求在顶层项目目录中存在几个文本文件，包括*AUTHORS*、*COPYING*、*INSTALL*、*NEWS*、*README*和*ChangeLog*文件。最好在总项目中不必处理这些文件。实现这一目标的一种方法是干脆不在总项目中使用Automake。我要么得为这个目录编写自己的*Makefile.in*模板，要么只用一次Automake来生成一个*Makefile.in*模板，然后将其与`automake
    --add-missing`（或`autoreconf -i`）添加的*install-sh*和*missing*脚本一起提交到仓库中，作为项目的一部分。一旦这些文件到位，我就可以从主*configure.ac*文件中删除`AM_INIT_AUTOMAKE`。
- en: Another option would be to keep Automake and simply use the `foreign` option
    in `AM_INIT_AUTOMAKE` (which I did at ➋) in the macro’s optional parameter. This
    parameter contains a string of whitespace-separated options that tell Automake
    how to act in lieu of specific Automake command line options. When `automake`
    parses the *configure.ac* file, it notes these options and enables them as if
    they’d been passed on the command line. The `foreign` option tells Automake that
    the project will not entirely follow GNU standards, and thus Automake will not
    require the usual GNU project text files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是保留Automake，并在`AM_INIT_AUTOMAKE`的宏可选参数中使用`foreign`选项（这是我在 ➋ 所做的）。这个参数包含一串以空格分隔的选项，告诉Automake如何替代特定的Automake命令行选项。当`automake`解析*configure.ac*文件时，它会记录下这些选项并启用它们，就像它们是从命令行传递的一样。`foreign`选项告诉Automake，该项目不会完全遵循GNU标准，因此Automake不会要求常见的GNU项目文本文件。
- en: I chose the latter of the two methods because I might want to alter the list
    of subordinate projects at some point and I don’t want to have to tweak a generated
    *Makefile.in* template by hand. I’ve also passed the `-Wall` and `-Werror` options
    in this list, which indicate that Automake should enable all Automake-specific
    warnings and report them as errors. These options have nothing to do with the
    user’s compilation environment—only Automake processing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了两种方法中的后者，因为我可能会在某个时候想修改下属项目的列表，而不希望每次都手动调整生成的*Makefile.in*模板。我还在这个列表中传递了`-Wall`和`-Werror`选项，这表明Automake应该启用所有Automake特有的警告并将其报告为错误。这些选项与用户的编译环境无关——仅与Automake处理相关。
- en: Why Add the Libtool Macros?
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么要添加Libtool宏？
- en: Why include those expensive Libtool macros at ➍? Well, even though I don’t do
    anything with Libtool in the umbrella project, the lower-level projects expect
    a containing project to provide all the necessary scripts, and the `LT_INIT` macro
    provides the *ltmain.sh* script. If you don’t initialize Libtool in the umbrella
    project, tools like `autoreconf`, which actually looks in the *parent* directory
    to determine if the current project is itself a subproject, will fail when they
    can’t find scripts that the current project’s *configure.ac* file requires.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在 ➍ 包含这些昂贵的Libtool宏？好吧，尽管我在总项目中没有使用Libtool，但低级项目期望包含项目提供所有必要的脚本，而`LT_INIT`宏提供了*ltmain.sh*脚本。如果你在总项目中没有初始化Libtool，像`autoreconf`这样的工具（它实际上会在*父*目录中查找，来判断当前项目是否为子项目）会因为找不到当前项目的*configure.ac*文件所需要的脚本而失败。
- en: 'For instance, `autoreconf` expects to find a file called *../ltmain.sh* within
    the ftk project’s top-level directory. Note the reference to the parent directory
    here: `autoreconf` noticed, by examining the parent directory, that ftk was actually
    a subproject of a larger project. Rather than install all the auxiliary scripts
    multiple times, the Autotools generate code that looks for scripts in the project’s
    parent directory. This is done in an effort to reduce the number of copies of
    these scripts that are installed into multiproject packages.^([8](footnote.xhtml#ch14fn8))
    If I don’t use `LT_INIT` in the umbrella project, I can’t successfully run `autoreconf`
    in the subprojects, because the *ltmain.sh* script won’t be in the project’s parent
    directory.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`autoreconf`期望在ftk项目的顶级目录中找到名为*../ltmain.sh*的文件。注意这里对父目录的引用：`autoreconf`通过检查父目录发现，ftk实际上是一个更大项目的子项目。为了避免多次安装所有辅助脚本，Autotools生成代码，查找项目父目录中的脚本。这是为了减少将这些脚本安装到多项目包中的副本数量。^([8](footnote.xhtml#ch14fn8))
    如果我在主项目中不使用`LT_INIT`，则无法在子项目中成功运行`autoreconf`，因为*ltmain.sh*脚本将不会出现在项目的父目录中。
- en: Adding a Macro Subdirectory
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加宏子目录
- en: 'The `AC_CONFIG_MACRO_DIRS` macro at ➎ indicates the name of a subdirectory
    in which the `aclocal` utility can find all project-specific M4 macro files. Here’s
    the prototype:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ➎处的`AC_CONFIG_MACRO_DIRS`宏表示一个子目录的名称，`aclocal`工具可以在该目录中找到所有特定于项目的M4宏文件。以下是原型：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The *.m4* macro files in this directory are ultimately referenced with an `m4_include`
    statement in the `aclocal`-generated *aclocal.m4* file, which `autoconf` reads.
    This macro replaces the original *acinclude.m4* file with a directory containing
    individual macros or smaller sets of macros, each defined in its own *.m4* file.^([9](footnote.xhtml#ch14fn9))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本目录中的*.m4*宏文件最终通过`m4_include`语句引用，在`aclocal`生成的*aclocal.m4*文件中，`autoconf`会读取该文件。这个宏用一个包含单独宏或较小宏集合的目录替换了原来的*acinclude.m4*文件，每个宏都定义在各自的*.m4*文件中。^([9](footnote.xhtml#ch14fn9))
- en: I’ve indicated by the parameter to `AC_CONFIG_MACRO_DIRS` that all of the local
    macro files to be added to *aclocal.m4* are in a subdirectory called *m4*. As
    a bonus, when `autoreconf -i` is executed, and then when it executes the required
    Autotools with their respective *add-missing* options, these tools will note the
    use of this macro in *configure.ac* and add any required system macro files that
    are missing to the *m4* directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过`AC_CONFIG_MACRO_DIRS`参数指明，所有要添加到*aclocal.m4*中的本地宏文件都位于一个名为*m4*的子目录中。作为附带功能，当执行`autoreconf
    -i`时，然后执行带有各自*add-missing*选项的必要Autotools工具时，这些工具会注意到*configure.ac*中使用了此宏，并将任何缺少的系统宏文件添加到*m4*目录中。
- en: The reason I chose to use `AC_CONFIG_MACRO_DIRS` here is that Libtool will not
    add its additional macro files to the project if you haven’t enabled the macro
    directory option in this manner. Instead, it will complain that you should add
    these files to *acinclude.m4* yourself.^([10](footnote.xhtml#ch14fn10))
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择在这里使用`AC_CONFIG_MACRO_DIRS`的原因是，如果没有以这种方式启用宏目录选项，Libtool将不会将其附加的宏文件添加到项目中。相反，它会抱怨应该将这些文件添加到*acinclude.m4*中。^([10](footnote.xhtml#ch14fn10))
- en: Since this is a fairly complex project and I wanted the Autotools to do this
    job for me, I decided to use this macro-directory feature. Future releases of
    the Autotools will likely require this form because it’s considered the more modern
    way of adding macro files to *aclocal.m4*, as opposed to using a single user-generated
    *acinclude.m4* file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相对复杂的项目，我希望Autotools为我完成这项工作，因此决定使用这个宏目录功能。未来的Autotools版本可能会要求使用这种形式，因为它被认为是将宏文件添加到*aclocal.m4*的更现代的方式，而不是使用单一的用户生成的*acinclude.m4*文件。
- en: 'One final thought on this macro: if you look for it in the Autoconf manual,
    you won’t find it—at least not yet, because it’s not an Autoconf macro but an
    Automake macro. It’s prefixed with `AC_` because it was always intended that a
    future release of Autoconf would take on this macro. It’s more functional than
    its singular predecessor, which *is* documented in the Autoconf manual, but the
    functionality was not needed until Automake came along. In fact, I have it on
    pretty good authority (the pre-release Autoconf *ChangeLog*) that ownership will
    change hands when Autoconf 2.70 is published.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个宏的最后一个思考：如果你在 Autoconf 手册中查找它，你是找不到的——至少目前找不到，因为它不是一个 Autoconf 宏，而是一个 Automake
    宏。它的前缀是 `AC_`，因为最初的设计目标是未来某个版本的 Autoconf 会接管这个宏。它比它的单一前身功能更强大，后者在 Autoconf 手册中有文档，但在
    Automake 出现之前，这个功能并不需要。事实上，我有相当可靠的消息来源（预发布的 Autoconf *ChangeLog*），表示当 Autoconf
    2.70 发布时，这个宏的所有权将会转移。
- en: The one item that we haven’t yet covered here is the `AM_PROG_AR` macro at ➌.
    This is a newer Automake macro. The first edition of this book didn’t use it.
    When I updated the Autotools, suddenly `autoreconf` complained that I needed it,
    so I added it and the complaint went away. The Autoconf manual says simply that
    you need it if you want to use an archiver (`ar`) that has an unusual interface
    (such as Microsoft `lib`). The fact is, the real complainer here was Libtool,
    which seems to have a habit of complaining about not including features of the
    other Autotools that it thinks you should be using. I added it to silence the
    warning.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里尚未讨论的一个项目是 ➌ 位置的 `AM_PROG_AR` 宏。这是一个较新的 Automake 宏。本书的第一版没有使用它。当我更新 Autotools
    时，突然 `autoreconf` 报告需要它，所以我加上了它，问题就解决了。Autoconf 手册简单地说明，如果你想使用具有特殊接口（如 Microsoft
    `lib`）的归档器（`ar`），你需要它。事实上，真正发出抱怨的是 Libtool，它似乎习惯性地抱怨没有包含它认为你应该使用的其他 Autotools
    特性。我添加了它以消除警告。
- en: '*The Top-Level Makefile.am File*'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*顶层 Makefile.am 文件*'
- en: The only other point to be covered regarding the umbrella project is the top-level
    *Makefile.am* file, shown in [Listing 14-2](ch14.xhtml#ch14ex2).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于总项目的唯一其他要点是顶层 *Makefile.am* 文件，如[清单 14-2](ch14.xhtml#ch14ex2)所示。
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 14-2*: Makefile.am: *The umbrella project Automake input file*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-2*: Makefile.am: *总项目 Automake 输入文件*'
- en: According to the Automake documentation, the `ACLOCAL_AMFLAGS` variable at ➊
    should be defined in the top-level *Makefile.am* file of any project that uses
    `AC_CONFIG_MACRO_DIR` (singular) in its *configure.ac* file. The flags specified
    on this line tell `aclocal` where it should look for macro files when it’s executed
    by rules defined in *Makefile.am*. The format of this option is similar to that
    of a C-compiler command line include (`-I`) directive; you can specify other `aclocal`
    command line options as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Automake 文档，在 ➊ 位置定义的 `ACLOCAL_AMFLAGS` 变量应该在任何使用 `AC_CONFIG_MACRO_DIR`（单数）作为
    *configure.ac* 文件中的配置项的项目的顶层 *Makefile.am* 文件中定义。此行指定的标志告诉 `aclocal` 在执行时应该在哪里查找宏文件，这些规则是在
    *Makefile.am* 中定义的。此选项的格式类似于 C 编译器命令行的 `-I` 指令；你也可以指定其他 `aclocal` 命令行选项。
- en: This variable used to be required when using a macro subdirectory with the older
    `AC_CONFIG_MACRO_DIR`, but with the advent of the newer `AC_CONFIG_MACRO_DIRS`,
    you no longer need this variable, as it generates code that allows Automake to
    understand which options it should pass to `aclocal`. Unfortunately, Libtool just
    can’t help but pipe up during `autoreconf` when it sees you using a macro directory
    without this variable in your *Makefile.am* files. I’m hoping this noise will
    go away when Autoconf takes ownership of the newer macro (with a subsequent release
    of Libtool, of course).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用旧版 `AC_CONFIG_MACRO_DIR` 时，此变量曾经是必需的，但随着新版 `AC_CONFIG_MACRO_DIRS` 的出现，你不再需要此变量，因为它生成的代码使
    Automake 能够理解应该传递给 `aclocal` 的选项。不幸的是，当 Libtool 看到你在 *Makefile.am* 文件中使用宏目录而没有这个变量时，它还是会在
    `autoreconf` 时发出警告。我希望当 Autoconf 接管了这个新宏（当然，还需要 Libtool 的后续版本发布）时，这个噪音会消失。
- en: The Autotools use this variable in two unrelated places. The first is in a `make`
    rule generated to update the *aclocal.m4* file from all of its various input sources.
    This rule and its supporting variable definitions are shown in [Listing 14-3](ch14.xhtml#ch14ex3),
    which is a code snippet copied from an Autotools-generated makefile.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools 在两个不相关的地方使用这个变量。第一个是在生成的 `make` 规则中，用于根据各种输入源更新 *aclocal.m4* 文件。此规则及其支持的变量定义见于[清单
    14-3](ch14.xhtml#ch14ex3)，这是从 Autotools 生成的 Makefile 中复制的代码片段。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 14-3: The `make` rule and the variables used to update* aclocal.m4
    *from its various dependencies*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The `ACLOCAL_AMFLAGS` definition is also used during execution of `autoreconf`,
    which scans the top-level *Makefile.am* file for this definition and passes the
    value text directly to `aclocal` on the command line. Be aware that `autoreconf`
    does no variable expansion on this string, so if you add shell or `make` variable
    references to the text, they won’t be expanded when `autoreconf` executes `aclocal`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Returning to [Listing 14-2](ch14.xhtml#ch14ex2), I’ve used the `EXTRA_DIST`
    variable at ➋ to ensure that a few additional top-level files get distributed—these
    files and directories are specific to the Windows build system. This isn’t critical
    to the umbrella project, since I don’t intend to create distributions at this
    level, but I like to be complete.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The `SUBDIRS` variable at ➌ duplicates the information in the *configure.ac*
    file’s `AC_CONFIG_SUBDIRS` macro. I tried creating a shell substitution variable
    and exporting it with `AC_SUBST`, but it didn’t work—when I ran `autoreconf`,
    I got an error indicating that I should use literals in the `AC_CONFIG_SUBDIRS`
    macro argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The `rpms` and `srcrpm` targets at ➍ allow the end user to build RPM packages
    for RPM-based Linux systems. The shell commands in this rule simply pass the user-specified
    targets and variables down to each of the lower-level projects in succession,
    just as we did with our handcoded makefiles and *Makefile.in* templates in [Chapters
    3](ch03.xhtml), [4](ch04.xhtml), and [5](ch05.xhtml).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: When passing control to lower-level makefiles in the manner shown in the commands
    for these RPM targets, you should strive to follow this pattern. Passing the expansion
    of `AM_MAKEFLAGS` allows lower-level makefiles access to the same `make` flags
    defined in the current or parent makefile. However, you can add more functionality
    to such recursive `make` code. To see how Automake passes control down to lower-level
    makefiles for its own targets, open an Automake-generated *Makefile.in* template
    and search for the text “`$(am__recursive_targets):`”. The code beneath this target
    shows exactly how Automake does it. While it looks complex at first glance, the
    code performs only two additional tasks. First, it ensures that continue-after-error
    functionality (`make -k`) works properly. Second, it ensures that the current
    directory (`.`) is handled properly if found in the `SUBDIRS` variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings me to my final point about this code: if you choose to write your
    own recursive targets in this manner (and we’ll see other examples of this later
    when we discuss conversion of the flaim build system), you should either avoid
    using a dot in the `SUBDIRS` variable or enhance the shell code to handle this
    special case. If you don’t, your users will likely find themselves in an endless
    recursion loop when they attempt to make one of these targets. For a more extensive
    treatise on this topic, see “Item 2: Implementing Recursive Extension Targets”
    on [page 505](ch18.xhtml#page_505).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The FLAIM Subprojects
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I used `autoscan` to generate a starting point for the ftk project. The `autoscan`
    utility is a bit finicky about where it will look for information. If your project
    doesn’t contain a makefile named exactly *Makefile*, or if your project already
    contains an Autoconf *Makefile.in* template, `autoscan` will not add any information
    about required libraries to the *configure.scan* output file. It has no way of
    determining this information except to look into your old build system, and it
    won’t do this unless conditions are just right.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Given the complexity of the ftk project’s legacy makefile, I was quite impressed
    with `autoscan`’s ability to parse it for library information. [Listing 14-4](ch14.xhtml#ch14ex4)
    shows a portion of the resulting *configure.scan* file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 14-4: A portion of the output from `autoscan` when run over the ftk
    project directory structure*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '*The FLAIM Toolkit configure.ac File*'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After this *configure.scan* file was modified and renamed, the resulting *configure.ac*
    file contained many new constructs, which I’ll discuss in the next few sections.
    In order to facilitate the discussion, I split this file into two parts, the first
    half of which is shown in [Listing 14-5](ch14.xhtml#ch14ex5).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 14-5*: ftk/configure.ac: *The first half of the ftk project’s* configure.ac
    *file*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, you will see that I substituted real values for the placeholders `autoscan`
    left in the `AC_INIT` macro. I added calls to `AM_INIT_AUTOMAKE`, `LT_PREREQ`,
    and `LT_INIT` at ➋, and I added a call to `AC_CONFIG_MACRO_DIRS` at ➍. (For now,
    just ignore the `AM_PROG_AR` macro—I’ll explain it later in this chapter.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '*I didn’t use the *`foreign`* keyword in *`AM_INIT_AUTOMAKE`* this time. Since
    it’s a real open source project, the FLAIM developers will (or at least, should)
    want these files. I used the *`touch`* command to create empty versions of the
    GNU project text files,^([11](footnote.xhtml#ch14fn11)) except for* COPYING *and*
    INSTALL, *which *`autoreconf`* adds.*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: A new construct at ➌ is the `AC_LANG` macro, which indicates the programming
    language (and thus, the compiler) that Autoconf should use when generating compilation
    tests in `configure`. I’ve passed `C++` as the parameter so Autoconf will compile
    these tests using the C++ compiler via the `CXX` variable, rather than the default
    C compiler via the `CC` variable. I then deleted the `AC_PROG_CC` macro call,
    since the source code for this project is written entirely in C++.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: I changed the `AC_CONFIG_SRCDIR` file argument at ➎ to one that made more sense
    to me than the one randomly chosen by `autoscan`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FLM_PROG_TRY_DOXYGEN` macro at ➏ is a custom macro that I wrote. Here’s
    the prototype:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I’ll cover the details of how this macro works in [Chapter 16](ch16.xhtml).
    For now, just know that it manages a precious variable called `DOXYGEN`. If the
    variable is already set, this macro does nothing; if the variable is not set,
    it scans the system search path for a `doxygen` program, setting the variable
    to the program name if it finds one. I’ll explain Autoconf precious variables
    when we get to the xflaim project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: At ➐, I added a couple of configuration options to `configure`’s command line
    parser with `AC_ARG_ENABLE`. I’ll discuss the details of these calls more completely
    as we come to other new constructs that use the variables these macros define.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Automake Configuration Features
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Automake provides the `AM_CONDITIONAL` macro I used at ➑; it has the following
    prototype:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The *`variable`* argument is an Automake conditional name that you can use
    in your *Makefile.am* files to test the associated condition. The *`condition`*
    argument is a *shell condition*—a bit of shell script that could be used as the
    condition in a shell `if-then` statement. In fact, this is exactly how the macro
    uses the *`condition`* argument internally, so it must be formatted as a proper
    `if-then` statement *condition* expression:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `AM_CONDITIONAL` macro always defines two Autoconf substitution variables
    named *`variable`*`_TRUE` and *`variable`*`_FALSE`. If *`condition`* is true,
    *`variable`*`_TRUE` is empty and *`variable`*`_FALSE` is defined as a hash mark
    (`#`), which indicates the beginning of a comment in a makefile. If *`condition`*
    is false, the definitions of these two substitution variables are reversed; that
    is, *`variable`*`_FALSE` is empty, and *`variable`*`_TRUE` becomes the hash mark.
    Automake uses these variables to conditionally comment out portions of your makefile
    script that are defined within Automake conditional statements.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: This instance of `AM_CONDITIONAL` defines the conditional name `HAVE_DOXYGEN`,
    which you can use in the project’s *Makefile.am* files to do something conditionally,
    based on whether or not `doxygen` can be executed successfully (via the `DOXYGEN`
    variable). Any lines of `make` script found within a test for truth in *Makefile.am*
    are prefixed with `@`*`variable`*`_TRUE@` in the Automake-generated *Makefile.in*
    template. Conversely, any lines found within an Automake conditional test for
    falseness are prefixed with `@`*`variable`*`_FALSE@`. When `config.status` generates
    *Makefile* from *Makefile.in*, these lines are either commented out (prefixed
    with hash marks) or not, depending on the truth or falseness of the condition.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s just one caveat with using `AM_CONDITIONAL`: you cannot call it conditionally
    (for instance, within a shell `if-then-else` statement) in the *configure.ac*
    file. You can’t define substitution variables conditionally—you can define their
    contents differently based on the specified condition, but the variables themselves
    are either defined or not at the time Autoconf creates the `configure` script.
    Since Automake-generated template files are created long before the user executes
    `configure`, Automake must be able to rely on the existence of these variables,
    regardless of how they’re defined.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `configure` script, you may want to perform other Autoconf operations
    based on the value of Automake conditionals. This is where the (commented) Automake-provided
    `AM_COND_IF` macro at ➒ comes into play.^([12](footnote.xhtml#ch14fn12)) Its prototype
    is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If *`conditional-variable`* is defined as true by a previous call to `AM_CONDITIONAL`,
    the *`if-true`* shell script (including any Autoconf macro calls) is executed.
    Otherwise, the *`if-false`* shell script is executed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s suppose, for example, that you want to conditionally build a portion
    of your project directory structure—say, the *xflaim/docs/doxygen* directory—based
    on the Automake conditional `HAVE_DOXYGEN`. Perhaps you are appending the subdirectory
    in question onto the `SUBDIRS` variable within an Automake conditional statement
    in your *Makefile.am* file (I’m actually doing this, as you’ll see in “The FLAIM
    Toolkit Makefile.am File” on [page 388](ch14.xhtml#page_388)). Since `make` won’t
    be building this portion of the project directory structure if the condition is
    false, there’s certainly little reason to have `config.status` process the *doxyfile.in*
    template within that directory during configuration. Therefore, you might use
    the code shown in [Listing 14-6](ch14.xhtml#ch14ex6) in your *configure.ac* file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 14-6*: ftk/configure.ac: *Using `AM_COND_IF` to conditionally configure
    a template*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: With this code in place, `configure` simply will not process the *doxyfile.in*
    template at all within the *docs* directory if `doxygen` isn’t installed on the
    user’s system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '*The* docs/Makefile.in *template should not be included here because the *`dist`*
    target must be able to process all directories in the project—whether or not they’re
    conditionally built—during execution of build targets such as *`all`* and *`clean`*.
    Thus, you should never conditionally process* Makefile.in *templates within* configure.ac.
    *However, you can certainly process other types of templates conditionally.*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The line following the line at ➒ is an alternative method of accomplishing
    the same thing using *M4sh*—a macro library built into Autoconf that’s designed
    to make it easier to write portable Bourne shell script. Here is the prototype:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The optional, elided parameters between the second and last ones shown are pairs
    of *`test`*`N` and *`run-if-true`* arguments. Ultimately, this macro works much
    like an `if-then-elif...` shell statement with a user-specified number of `elif`
    conditions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-7](ch14.xhtml#ch14ex7) shows the second half of ftk’s *configure.ac*
    file.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 14-7*: ftk/configure.ac: *The second half of the ftk project’s* configure.ac
    *file*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, I’ve called the `AC_SYS_LARGEFILE` macro. If the user has a 32-bit system,
    this macro ensures that appropriate C-preprocessor definitions (and possibly compiler
    options) that force the use of 64-bit file addressing (also called *large files*)
    are added to the *config.h.in* template. With these variables in place, C-library
    large-address-aware file I/O functions become available to the project source
    code. FLAIM, as a database system, cares very much about this feature.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, 32-bit general-purpose computer systems have become less
    popular as companies like Intel and Microsoft have made media statements concerning
    future versions of their products that will no longer support 32-bit address spaces.
    However, market pressures caused by the millions of existing 32-bit systems have
    cause them to back off a bit on the rhetoric and return to a more pragmatic perspective.
    Nevertheless, 32-bit PCs are on their way out the door in the not-too-distant
    future. Even so, Linux will continue to run on 32-bit systems because many embedded
    systems still get significant benefits from using smaller, less-power-hungry 32-bit
    microprocessors.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Doing Threads the Right Way
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is another new construct, `AX_PTHREAD`, at ➋. In the Jupiter project,
    I simply linked the `jupiter` program with the *pthreads* library via the `-lpthread`
    linker flag. But frankly, this is the wrong way to use *pthreads*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In the presence of multiple threads of execution, you must configure many of
    the standard C-library functions to act in a thread-safe manner. You can do this
    by ensuring that one or more preprocessor definitions are visible to all of the
    standard library header files as they’re being compiled into the program. These
    C-preprocessor definitions must be defined on the compiler command line, and they’re
    not standardized between compiler vendors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Some vendors provide entirely different standard libraries for building single-threaded
    versus multithreaded programs, because adding thread safety to a library reduces
    performance to a degree. Compiler vendors believe (correctly) that they’re doing
    you a favor by giving you different versions of the standard library for these
    purposes. In this scenario, it’s necessary to tell the linker to use the correct
    runtime libraries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, every vendor does multithreading in its own way, from compiler
    options to library names to preprocessor definitions. But there is a reasonable
    solution to the problem: the GNU Autoconf Archive^([13](footnote.xhtml#ch14fn13))
    provides a macro called `AX_PTHREAD` that checks out a user’s compiler and provides
    the correct flags and options for a wide variety of platforms.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'This macro is very simple to use:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It sets several environment variables, including `PTHREAD_CFLAGS`, `PTHREAD``_CXXFLAGS`,
    and `PTHREAD_LIBS`. It’s up to the caller to use these variables properly by adding
    shell code to the *`action-if-found`* argument. If all of your project’s code
    is multithreaded, things are simpler: you need only append these variables to,
    or consume them from within, the standard `CFLAGS`, `CXXFLAGS`, and `LIBS` variables.
    The FLAIM project code base is completely multithreaded, so I chose to do this.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: If you examine the contents of the *ax_pthread.m4* file in the *ftk/m4* directory,
    you might expect to find a large `case` statement that sets options for every
    compiler and platform combination known to man—but that’s not the Autoconf way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the macro incorporates a long list of known *pthreads* compiler options,
    and the generated `configure` script uses the host compiler to compile a small
    *pthreads* program with each one of these options in turn. The flags that are
    recognized by the compiler, and that therefore properly build the test program,
    are added to the `PTHREAD_CFLAGS` and `PTHREAD_CXXFLAGS` variables. This way,
    `AX_PTHREAD` stands a good chance of continuing to work properly, even in the
    face of significant changes to compiler options in the future—and this *is* the
    Autoconf way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Getting Just the Right Libraries
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I deleted the *FIXME* comments (see *configure.scan* in [Listing 14-4](ch14.xhtml#ch14ex4)
    on [page 378](ch14.xhtml#page_378)) above each of the `AC_CHECK_LIB` macro calls
    at ➌ in [Listing 14-7](ch14.xhtml#ch14ex7). I started to replace the main placeholders
    in these macros with actual library function names, but then I began to wonder
    if all of those libraries were really necessary. I wasn’t as concerned about `autoscan`’s
    abilities as I was about the veracity of the original makefile. In handcoded build
    systems, I’ve occasionally noticed that the author will cut and paste sets of
    library names from one makefile to another until the program builds without missing
    symbols.^([14](footnote.xhtml#ch14fn14))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Instead of blindly continuing this trend, I chose to simply comment out all
    of the calls to `AC_CHECK_LIB` to see how far I could get in the build, adding
    them back in one at a time as required to resolve missing symbols. Unless your
    project consumes literally hundreds of libraries, this will only take a few extra
    minutes. I like to link only the libraries that are necessary for my project;
    it speeds up the link process and, when done religiously, provides a good form
    of project-level documentation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The *configure.scan* file contained 14 such calls to `AC_CHECK_LIB`. As it turned
    out, the FLAIM toolkit on my 64-bit Linux system only required three of them—*pthread*,
    *ncurses*, and *rt*—so I deleted the remaining entries and swapped out the placeholder
    parameters for real functions in the *ncurses* and *rt* libraries. In retrospect,
    it appears that my gambit paid off rather handsomely, because I dropped from 14
    libraries to 2\. The third library was the POSIX Thread (*pthreads*) library,
    which is added via the `AX_PTHREAD` macro I discussed in the previous section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: I also converted the *ncurses* `AC_CHECK_LIB` call to `AC_SEARCH_LIBS` because
    I suspect that future FLAIM platforms may use different library names for *curses*
    functionality. I’d like to prepare the build system to have additional libraries
    searched on these platforms. The *ncurses* library is an optional library on most
    platforms, so I added the `AC_CHECK_HEADER` macro to check for *curses.h*, display
    a message in the *`action-if-not-found`* (third) argument that the user should
    install the *curses-development* package, and exit the configuration process with
    an error. The rule is to find problems early, during configuration, rather than
    during compilation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Maintainer-Defined Command Line Options
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next four libraries are checked within an Autoconf conditional statement
    at ➍. This statement is based on the end user’s use of the `--enable-openssl`
    command line argument, which `AC_ARG_ENABLE` provides (see ➐ in [Listing 14-5](ch14.xhtml#ch14ex5)
    on [page 379](ch14.xhtml#page_379)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: I use `AS_IF` here instead of a shell `if-then` statement because, if any of
    the macros called within the conditional statement require additional macros to
    be expanded in order to operate correctly, `AS_IF` will ensure that these dependencies
    are expanded first, outside of the conditional statement. As well as being part
    of the *M4sh* library, the `AS_IF` macro is part of the Autoconf auto-dependency
    framework (also discussed in detail in “Autoconf and M4” on [page 439](ch16.xhtml#page_439)).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `openssl` variable is defined to either `yes` or `no` based
    on the default value given to `AC_ARG_ENABLE` and on the end user’s command line
    choices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The `AC_DEFINE` macro, called in the first argument of `AS_IF`, ensures that
    the C-preprocessor variable `FLM_OPENSSL` is defined in the *config.h* header
    file. The `AC_CHECK_LIB` macros then ensure that `-lssl`, `-lcrypto`, `-ldl`,
    and `-lz` strings are added to the `LIBS` variable, but only if the `openssl`
    variable is set to `yes`. We don’t want to insist that the user have those libraries
    installed unless they have asked for features that need them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get as sophisticated as you want when dealing with maintainer-defined
    command line options such as `--enable-openssl`. But be careful: some levels of
    automation can surprise your users. For instance, automatically enabling the option
    because your checks found that the OpenSSL libraries were installed and accessible
    can be a bit disconcerting.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: I left all the header file and library function checks at ➎, as specified by
    `autoscan`, because a simple text scan through the source code for header files
    and function names is probably pretty accurate.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, however, that `autoscan` did not put *all* of the header files used
    by ftk source code into the `AC_CHECK_HEADERS` argument. The `autoscan` utility’s
    algorithm is simple but effective: it adds all header files included conditionally
    by your source code. This approach assumes that any header file you include conditionally
    might be included differently on different platforms due to portability issues.
    While this approach is usually correct, it’s not always correct, so you should
    look at each of the headers added, find the conditional inclusion in your source
    code, and make a more intelligent assessment of whether or not it should be added
    to `AC_CHECK_HEADERS` in *configure.ac*.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: A good example in this project is the conditional inclusion of *stdlib.h*. As
    it happens, *stdlib.h* is included for Windows builds, and it’s also included
    for Unix builds. It is not, however, included for NetWare builds. Regardless,
    it doesn’t really need to be checked for in `AC_CHECK_HEADERS` for two reasons.
    First, it’s widely standardized across platforms, and second, this build system
    is specifically designed for Unix systems.^([15](footnote.xhtml#ch14fn15)) The
    point is, you should carefully examine what `autoscan` does for you to determine
    if it should be done in your project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: At ➏, we see the conditional (`AS_IF`) use of `AC_DEFINE` based on the contents
    of the `debug` variable. This is another environment variable that’s conditionally
    defined based on the results of a command line parameter given to `configure`.
    The `--enable-debug` option sets the debug variable to `yes`, which ultimately
    enables the `FLM_DEBUG` C-preprocessor definition within *config.h*. Both `FLM_OPENSSL`
    and `FLM_DEBUG` were already used within the FLAIM project source code. Using
    `AC_DEFINE` in this manner allows the end user to determine which features are
    compiled into the libraries.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: I left a fairly large chunk of code out of the listing at ➐ that deals with
    compiler and tool optimizations, which I’ll present in the next chapter. This
    code is identical in all of the projects’ *configure.ac* files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I added references to the makefiles in the *docs*, *obs*, *src*, and
    *util* directories, as well as the *obs/flaimtk.spec* and *src/libflaimtk.pc*
    files at ➑ to the `AC_CONFIG_FILES` macro call, and then I added my usual `cat`
    statement at ➒ near the bottom for some visual verification of my configuration
    status. For now, just ignore the `sed` command right above the `cat` statement.
    I’ll cover that in “Transitive Dependencies” on [page 401](ch14.xhtml#page_401).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '*The FLAIM Toolkit Makefile.am File*'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we ignore the commands for Doxygen- and RPM-specific targets (for now), the
    *ftk/Makefile.am* file is fairly trivial. [Listing 14-8](ch14.xhtml#ch14ex8) shows
    the entire file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 14-8*: ftk/Makefile.am: *The entire contents of the FLAIM toolkit’s
    top-level makefile*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In this file you’ll find the usual `ACLOCAL_AMFLAGS`, `EXTRA_DIST`, and `SUBDIRS`
    variable definitions, but you can also see the use of an Automake conditional
    at ➊. The `if` statement allows me to append another directory (*docs*) to the
    `SUBDIRS` list, but only if the `doxygen` program is available (according to `configure`).
    I used a separate variable here (`DOXYDIR`), but the Automake conditional could
    just as well have surrounded a statement that directly appends the directory name
    (`doc`) to the `SUBDIRS` variable using the Automake `+=` operator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t confuse Automake conditionals with GNU Make conditionals, which use
    the keywords *`ifeq`*, *`ifneq`*, *`ifdef`*, and *`ifndef`*. If you try to use
    an Automake conditional in* Makefile.am *without a corresponding *`AM_CONDITIONAL`*
    statement in* configure.ac, *Automake will complain about it. When this construct
    is used properly, Automake converts it to something that *`make`* understands
    before *`make`* sees it.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Another new construct (at least in a top-level *Makefile.am* file) is the use
    of the `doc_DATA` variable at ➋. The FLAIM toolkit provides some extra documentation
    files in its top-level directory that I’d like to have installed. By using the
    `doc` prefix on the `DATA` primary, I’m telling Automake that I’d like these files
    to be installed as data files in the `$(docdir)` directory, which ultimately resolves
    to the `$(prefix)`*/share/doc* directory, by default.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Files mentioned in `DATA` variables that don’t already have special meaning
    to Automake are not automatically distributed (that is, they’re not added to distribution
    tarballs), so you have to manually distribute them by adding them to the files
    listed in the `EXTRA_DIST` variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '*I did not have to list the standard GNU project text files in *`EXTRA_DIST`*
    because they’re always distributed automatically. However, I did have to mention
    theses files in the *`doc_DATA`* variable, because Automake makes no assumptions
    about which files you want to install.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: I’ll defer a discussion of the RPM targets at ➌ to the next chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Automake -hook and -local Rules
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Automake recognizes two types of integrated extensions, which I call `-local`
    targets and `-hook` targets. Automake recognizes and honors `-local` extensions
    for the following standard targets:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '| `all` | `install-data` | `installcheck` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| `check` | `install-dvi` | `installdirs` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| `clean` | `install-exec` | `maintainer-clean` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `distclean` | `install-html` | `mostlyclean` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `dvi` | `install-info` | `pdf` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `html` | `install-pdf` | `ps` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `info` | `install-ps` | `uninstall` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: Appending `-local` to any of these in your *Makefile.am* files will cause the
    associated commands to be executed *before* the standard target. Automake does
    this by generating the rule for the standard target so that the `-local` version
    is one of its dependencies (if it exists).^([16](footnote.xhtml#ch14fn16)) In
    “Cleaning Your Room” on [page 404](ch14.xhtml#page_404), I’ll show an example
    of this concept using a `clean-local` target.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The `-hook` targets are a bit different in that they are executed *after* the
    corresponding standard target is executed.^([17](footnote.xhtml#ch14fn17)) Automake
    does this by adding another command to the end of the standard target command
    list. This command merely executes `$(MAKE)` on the containing makefile, with
    the `-hook` target as the command line target. Thus, the `-hook` target is executed
    at the end of the standard target commands in a recursive fashion.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'The following standard Automake targets support `-hook` versions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '| `dist` | `install-data` | `uninstall` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `distcheck` | `install-exec` |  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: Automake automatically adds all existing `-local` and `-hook` targets to the
    `.PHONY` rule within the generated makefile.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In the first edition of this book, I used the `dist-hook` target at ➍ in *Makefile.am*
    (now commented out) to adjust the distribution directory after it’s built but
    before `make` builds a distribution archive from its contents. The `rm` command
    removed extraneous files and directories that became part of the distribution
    directory as a result of my adding entire directories to the `EXTRA_DIST` variable.
    When you add directory names to `EXTRA_DIST` (*debian*, *netware*, and *win32*,
    in this case), everything in those directories is added to the distribution—even
    hidden repository control files and directories.^([18](footnote.xhtml#ch14fn18))
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-9](ch14.xhtml#ch14ex9) is a portion of the generated *Makefile*
    that shows how Automake incorporates `dist-hook` into the final makefile. The
    relevant portions are highlighted.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 14-9: The results of defining the `dist-hook` target in* ftk/Makefile.am'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t be afraid to dig into the generated makefiles to see exactly what Automake
    is doing with your code. While there is a fair amount of ugly shell code in the
    *`make`* commands, most of it is safe to ignore. You’re usually more interested
    in the *`make`* rules that Automake is generating, and it’s easy to separate these
    out.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*Designing the ftk/src/Makefile.am File*'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I now need to create *Makefile.am* files in the *src* and *utils* directories
    for the FLAIM toolkit project. I want to ensure that all of the original functionality
    is preserved from the old build system as I’m creating these files. Basically,
    this includes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Properly building the ftk shared and static libraries
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly specifying installation locations for all installed files
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the ftk shared-library version information correctly
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that all remaining unused files are distributed
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that platform-specific compiler options are used
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template shown in [Listing 14-10](ch14.xhtml#ch14ex10) should cover most
    of these points, so I’ll be using it for all of the FLAIM library projects, with
    appropriate additions and subtractions, based on the needs of each individual
    library.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 14-10: A framework for the src and utils directory* Makefile.am *files*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The original *GNUMakefile* told me that the library was named *libftk.so*. This
    is a bad name for a library on Linux, because most of the three-letter library
    names are already taken. Thus, I made an executive decision and renamed the *ftk*
    library to *flaimtk*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-11](ch14.xhtml#ch14ex11) shows most of the final *ftk/src/Makefile.am*
    file.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 14-11*: ftk/src/Makefile.am: *The entire file contents, minus a few
    dozen source files*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'I added the Libtool library name, *libflaimtk.la*, to the `lib_LTLIBRARIES`
    list at ➋ and changed the *`xxxxx`* portions of the remaining macros in [Listing
    14-10](ch14.xhtml#ch14ex10) to `libflaimtk`. I could have entered all the source
    files by hand, but I noticed while reading the original makefile that it used
    the GNU `make` function macro `$(wildcard src/*.cpp)` to build the file list from
    the contents of the *src* directory. This tells me that all of the *.cpp* files
    within the *src* directory are required (or at least consumed) by the library.
    To get the file list into *Makefile.am*, I used a simple shell command to concatenate
    it to the end of the *Makefile.am* file (assuming I’m in the *ftk/src* directory):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This left me with a single-column, backslash-terminated, alphabetized list of
    all of the *.cpp* files in the *ftk/src* directory at the bottom of *ftk/src/Makefile.am*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not forget the single quotes around the *`printf`* argument, which are
    necessary to keep the first pair of backslashes from being interpreted by the
    shell as escape characters during generation of the list. Regardless of quoting,
    *`printf`* understands and interprets the *`\n`* character properly.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: I moved the list up to just below the `libflaimtk_la_SOURCES` line at ➎, added
    a backslash character after the equal sign, and removed the one after the last
    file. Another formatting technique is to simply wrap the line with a backslash
    and a carriage return approximately every 70 characters, but I prefer to put each
    file on a separate line, especially early in the conversion process, so I can
    easily extract files from or add files to the lists as needed. Leaving the files
    on separate lines also gets you the benefit of having source lists be easier to
    compare when reviewing differences in pull-request reviews and other `diff`-style
    output.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: I had to manually examine each header file in the *src* directory in order to
    determine its use in the project. There were only four header files, and, as it
    turns out, the only one the FLAIM toolkit does *not* use on Unix and Linux platforms
    is *ftknlm.h*, which is specific to the NetWare build. I added this file to the
    `EXTRA_DIST` list at ➊ so it would be distributed; just because the build doesn’t
    use it doesn’t mean that users won’t want or need it.^([19](footnote.xhtml#ch14fn19))
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The (newly renamed) *flaimtk.h* file is the only public header file, so I moved
    it into the `include_HEADERS` list at ➌. The other two files are used internally
    in the library build, so I left them in the `libflaimtk_la_SOURCES` list. Had
    this been my own project, I would have moved *flaimtk.h* into an *include* directory
    off the project root directory, but remember that one of my goals here was to
    limit changes to the directory structure and the source code. Moving this header
    file is a philosophical decision that I decided to leave to the maintainers.^([20](footnote.xhtml#ch14fn20))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I noticed in the original makefile that the last release of the *ftk*
    library published an interface version of 4.0\. However, since I changed the name
    of the library from *libftk* to *libflaimtk*, I reset this value to 0.0 because
    it’s a different library. I replaced *`x`*`:`*`y`*`:`*`z`* with `0:0:0` in the
    `-version-info` option at ➏ within the `libflaimtk_la_LDFLAGS` variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '*A version string of *`0:0:0`* is the default, so I could have removed the
    argument entirely and achieved the same result. However, including it gives new
    developers some insight into how to change the interface version in the future.*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: I added the `pkgconfigdir` and `pkgconfig_DATA` variables at ➍ in order to provide
    support for installing pkg-config metadata files for this project. For more on
    the pkg-config system, see [Chapter 10](ch10.xhtml).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '*Moving On to the ftk/util Directory*'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Properly designing *Makefile.am* for the *util* directory requires examining
    the original makefile again for more products. A quick glance at the *ftk/util*
    directory showed that there was only one source file: *ftktest.cpp*. This appeared
    to be some sort of testing program for the *ftk* library, but I know that the
    FLAIM developers use it all the time in various ways besides simply for testing
    a build. So I had a design decision to make here: should I build this as a normal
    program or as a check program?'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*Check programs* are only built when `make check` is executed, and they’re
    never installed. If I want `ftktest` built as a regular program, but not installed,
    I have to use the `noinst` prefix rather than the usual `bin` prefix in the program
    list variable.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: In either case, I probably want to add `ftktest` to the list of tests that are
    executed during `make check`, so the two questions here are (1) whether I want
    to automatically run `ftktest` during `make check` and (2) whether I want to install
    the `ftktest` program. Given that the FLAIM toolkit is a mature product, I opted
    to build `ftktest` during `make check` and leave it uninstalled.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-12 shows my final *ftk/util/Makefile.am* file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 14-12*: ftk/util/Makefile.am: *The final contents of this file*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: I hope that by now you can see the relationship between `TESTS` and `check_PROGRAMS`.
    To be blunt, there really is *no* relationship between the files listed in `check_PROGRAMS`
    and those listed in `TESTS`. The `check` target simply ensures that `check_PROGRAMS`
    are built before the `TESTS` programs and scripts are executed. `TESTS` can refer
    to anything that can be executed without command line parameters. This separation
    of duties makes for a very clean and flexible system.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it for the FLAIM toolkit library and utilities. I don’t know about
    you, but I’d much rather maintain this small set of short files than a single
    2,200-line makefile!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Designing the XFLAIM Build System
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that I’ve finished with the FLAIM toolkit, I’ll move on to the xflaim project.
    I’m choosing to start with xflaim, rather than flaim, because it supplies the
    most build features that can be converted to the Autotools, including the Java
    and C# language bindings (which I won’t actually discuss in detail until the next
    chapter). After xflaim, covering the remaining database projects would be redundant,
    because the processes are identical, if not a little simpler. However, you can
    find the other build system files in this book’s GitHub repositories.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: I generated the *configure.ac* file using `autoscan` once again. It’s important
    to use `autoscan` in each of the individual projects, because the source code
    for each project is different and will thus cause different macros to be written
    into each *configure.scan* file.^([21](footnote.xhtml#ch14fn21)) I then used the
    same techniques I used on the FLAIM toolkit to create xflaim’s *configure.ac*
    file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '*The XFLAIM configure.ac File*'
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After hand-modifying the generated *configure.scan* file and renaming it *configure.ac*,
    I found it to be similar in many ways to the toolkit’s *configure.ac* file. It’s
    fairly long, so I’ll show you only the most significant differences in [Listing
    14-13](ch14.xhtml#ch14ex13).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 14-13*: xflaim/configure.ac: *The most significant portions of this
    Autoconf input file*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'First, notice that I’ve invented a few more `FLM_PROG_TRY_*` macros at ➊. Here
    I’m checking for the existence of the following programs: a C# compiler, a C#
    virtual machine, a Java compiler, a JNI header and stub generator, a Javadoc generation
    tool, a Java archive tool, and Doxygen. I’ve written separate macro files for
    each of these checks and added them to my *xflaim/m4* directory.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: As with the `FLM_PROG_TRY_DOXYGEN` macro used in the toolkit, each of these
    macros attempts to locate the associated program, but these macros don’t fail
    the configuration process if they can’t find the program. I want to be able to
    use these programs if they’re available, but I don’t want to require the user
    to have them in order to build the base libraries.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find a new macro, `AC_ARG_VAR`, at ➋. Like the `AC_ARG_ENABLE` and `AC_ARG_WITH`
    macros, `AC_ARG_VAR` allows the project maintainer to extend the command line
    interface of the `configure` script. This macro is different, however, in that
    it adds a public variable, rather than a command line option, to the list of public
    variables that `configure` cares about. In this case, I’m adding two public variables,
    `FTKINC` and `FTKLIB`. These will show up in `configure`’s help text under the
    section “Some influential environment variables.” The *GNU Autoconf Manual* calls
    these variables *precious*. All of my `FLM_PROG_TRY_*` macros use the `AC_ARG_VAR`
    macro internally to make the associated variables both public and precious.^([22](footnote.xhtml#ch14fn22))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '*The lines of code from* ➋ *through* ➐ *are found in the GitHub repository
    under* xflaim/m4/flm_ftk_search.m4\. *By the end of [Chapter 15](ch15.xhtml),
    all discrepancies are resolved between the listings in this chapter and the files
    in the GitHub repository.*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The large chunk of code beginning at ➌ actually uses these variables to set
    other variables used in the build system. The user can set the public variables
    in the environment, or they can specify them on `configure`’s command line in
    this manner:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, I’ll check to see that either both or neither of the `FTKINC` and `FTKLIB`
    variables is specified. If only one of them is given, I have to fail with an error.
    The user isn’t allowed to tell me where to find only *half* the toolkit; I need
    both the header file and the library.^([23](footnote.xhtml#ch14fn23)) If neither
    of these variables is specified, I search for them at ➍ by looking for a subdirectory
    of the xflaim project directory called *ftk*. If I find one, I’ll configure that
    directory as a subproject to be processed by Autoconf, using the `AC_CONFIG_SUBDIRS`
    macro.^([24](footnote.xhtml#ch14fn24)) I’ll also set both of these variables to
    point to the appropriate relative locations within the ftk subproject.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'If I don’t find *ftk* as a subdirectory, I’ll look for it in the parent directory
    at ➎. If I find it there, I’ll set the variables appropriately. This time, I don’t
    need to configure the located *ftk* directory as a subproject, because I’m assuming
    that the xflaim project is itself a subproject of the umbrella project. If I don’t
    find *ftk* as either a subproject or a sibling project, I’ll use the standard
    `AC_CHECK_LIB` and `AC_CHECK_HEADERS` macros at ➏ to see if the user’s host has
    the toolkit library installed. In that case, I need only add `-lflaimtk` to the
    `LIBS` variable. Also in that case, the header file will be in the standard location:
    usually */usr(/local)/include*. The default functionality of the optional third
    argument to `AC_CHECK_LIB` would automatically add the library reference to the
    `LIBS` variable, but since I’ve overridden this default functionality, I have
    to manually add the toolkit library reference to `LIBS`.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: If I don’t find the library, I give up with an error message indicating that
    xflaim can’t be built without the FLAIM toolkit. However, after making it through
    all these checks, if the `FTKLIB` variable is no longer empty, I use `AC_SUBST`
    at ➐ to publish the `FTK_INCLUDE` and `FTK_LTLIB` variables, which contain derivations
    of `FTKINC` and `FTKLIB` appropriate for use as command line options to the preprocessor
    and the linker.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '*[Chapter 16](ch16.xhtml) converts the large chunk of code between* ➌ *and*
    ➑ *into a custom M4 macro called *`FLM_FTK_SEARCH`**.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The remaining code at ➑ calls `AM_CONDITIONAL` for Java, C#, and Doxygen in
    a manner similar to the way I handled Doxygen in the ftk project. These macros
    are configured to generate warning messages indicating that the Java or C# portions
    of the xflaim project will not be built if those tools can’t be found, but I allow
    the build to continue in any case.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating the xflaim/src/Makefile.am File*'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’m skipping the *xflaim/Makefile.am* file, because it’s nearly identical to
    *ftk/Makefile.am*. Instead, we’ll move on to *xflaim/src/Makefile.am*, which I
    wrote by following the same design principles used with the *ftk/src* version.
    It looks very similar to its ftk counterpart, with one exception: according to
    the original build system makefile, the Java native interface (JNI) and C# native
    language–binding sources are compiled and linked right into the *xflaim* shared
    library.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: This is not an uncommon practice, and it’s quite useful because it alleviates
    the need for extra library objects built specifically for these languages. Essentially,
    the *xflaim* shared library exports native interfaces for these languages, which
    are then consumed by their corresponding native wrappers.^([25](footnote.xhtml#ch14fn25))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to ignore these language bindings for now, but later, when I’m finished
    with the entire xflaim project, I’ll turn my attention back to properly hooking
    them into the library. With this exception then, the *Makefile.am* file shown
    in [Listing 14-14](ch14.xhtml#ch14ex14) looks almost identical to its ftk counterpart.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 14-14*: xflaim/src/Makefile.am: *The xflaim project src directory
    Automake input file*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: I’ve conditionally defined the contents of the `SUBDIRS` variable here based
    on variables defined by corresponding Automake conditional statements in *configure.ac*.
    When `make all` is executed, the `SUBDIRS` variable conditionally recurses into
    the *java* and *cs* subdirectories. But when `make dist` is executed, a hidden
    `DIST_SUBDIRS` variable (which is created by Automake from *all of the possible
    contents* of the `SUBDIRS` variable) references all directories appended, either
    conditionally or unconditionally, to `SUBDIRS`.^([26](footnote.xhtml#ch14fn26))
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '*The library interface version information was extracted from the original
    makefile.*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '*Turning to the xflaim/util Directory*'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *util* directory for xflaim is a bit more complex. According to the original
    makefile, it generates several utility programs as well as a convenience library
    that is consumed by these utilities.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: It was somewhat more difficult to find out which source files belong to which
    utilities and which were not used at all. Several of the files in the *xflaim/util*
    directory are not used by any of the utilities. Do we distribute these extra source
    files? I chose to do so, because they were already being distributed by the original
    build system and adding them to the `EXTRA_DIST` list makes it obvious to later
    observers that they aren’t used.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-15](ch14.xhtml#ch14ex15) shows a portion of the *xflaim/util/Makefile.am*
    file; the parts that are missing are redundant.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 14-15*: xflaim/util/Makefile.am: *The xflaim project’s* util *directory
    Automake input file*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you can see by the elided sections that I left out several
    long lists of files and products. This makefile builds 22 unit tests, but because
    they’re all identical, except for naming differences and the source files from
    which they’re built, I only left the descriptions for two of them (at ➌).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: I’ve defined the file-global `AM_CPPFLAGS` and `LDADD` variables at ➊ in order
    to associate the `XFLAIM` and `FTK` include and library files with each of the
    projects listed in this *Makefile.am* file. This way, I don’t have to explicitly
    append this information to each product.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Transitive Dependencies
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Notice, however, that the `AM_CPPFLAGS` variable uses both the `XFLAIM_INCLUDE`
    and `FTK_INCLUDE` variables—the xflaim utilities clearly require information from
    both sets of header files. So why doesn’t the `LDADD` variable reference the *ftk*
    library? This is because Libtool manages transitive dependencies for you and does
    so in a very portable manner, because some systems don’t have a native mechanism
    for managing transitive dependencies. Because I reference *libxflaim.la* through
    `XFLAIM_LDADD`, and because *libxflaim.la* lists *libflaimtk.la* as a dependency,
    Libtool is able to provide the transitive reference for me on the utility programs’
    linker command lines.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: For a clearer picture of this, examine the contents of *libxflaim.la* (in your
    build directory under *xflaim/src*—you will have to build the project first; run
    `autoreconf -i; ./configure && make`). You’ll find a few lines near the middle
    of the file that look very much like the contents of [Listing 14-16](ch14.xhtml#ch14ex16).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 14-16: The portion of xflaim/src*/libxflaim.la *that shows dependency
    libraries*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The path information for *libflaimtk.la* is listed here so we don’t have to
    specify it in the `LDADD` statement for the xflaim utilities.^([27](footnote.xhtml#ch14fn27))
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Like Libtool, the GNU linker and the Linux loader can manage transitive dependencies
    (TDs). This is done by having `ld` incorporate these indirect dependencies into
    the ELF binaries it generates when appropriate linker command line options are
    used. Libtool’s mechanism relies on a recursive search of a hierarchy of *.la*
    files, whereas Linux’s native mechanism simply recursively searches the library
    hierarchy at build time and embeds all required library references directly into
    the built program or library. The loader then sees and uses these references at
    load time. A nice aspect of using such native TD management is that, if a library
    is updated in a newer version of a package, the loader will immediately begin
    to reference the updated secondary symbols from the new library’s updated reference
    list, and projects built against that library will immediately begin using the
    new version’s transitive dependencies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Recently, some distro vendors have decided it’s worth taking advantage of this
    feature on their platforms. The problem is, Libtool’s TD management reduces the
    perceived advantages of using `ld`’s (and the system loader’s) internal TD management—it
    gets in the way, so to speak. To solve this issue, these vendors have decided
    to release a modified version of Libtool on their platforms, wherein its TD management
    feature is effectively disabled. The result is that you must now specify all direct
    and indirect libraries on the linker (`libtool`) command line or modify your build
    system to use the non-portable native TD management linker options.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Since native TD management is not supported on all platforms, and Libtool’s
    text file–based approach is completely portable, we often rely heavily on Libtool
    to do the right thing when indirect dependencies are required while linking our
    programs and libraries on systems that don’t have a native TD management system.
    When you use a “distro-crippled” Libtool package to build projects designed to
    take advantage of Libtool’s TD management features, your build simply fails at
    the link stage with “missing DSO” (dynamic shared object) messages.^([28](footnote.xhtml#ch14fn28))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The `sed` command in *configure.ac* searches for the text `link_all_deplibs=no`
    in the *libtool* script and replaces it with `link_all_deplibs=yes`. It’s in there
    twice, and the `sed` command will replace both occurrences. `AC_OUTPUT` executes
    `config.status`, which generates the *libtool* script in the project directory,
    so the `sed` command must follow `AC_OUTPUT` to be effective.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '*It doesn’t hurt to use this *`sed`* command, even on systems that do not exhibit
    the problem—*`sed`* simply won’t find anything to replace in your* libtool *script.
    Be aware, however, that if your package is picked up for distribution by a Linux
    vendor that uses internal TD management, they’ll probably ship your package with
    these sorts of commands “patched out.”*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Of course, another option is to forgo the use of automatic transitive dependency
    management entirely by simply specifying all of the link dependencies you know
    you’ll need on the linker’s command line for every program or library you build.
    Pkg-config actually does this for you anyway, so if you can rely on pkg-config
    for all your library management needs, then your projects are simply not affected
    by this issue. This can be done manually in the flaim, xflaim, and flaimsql projects
    by adding `$(FTK_LTLIB)` to the `LDADD` variables as, for example, at ➊ in [Listing
    14-15](ch14.xhtml#ch14ex15).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to try this by commenting out the `sed` commands in *configure.ac*
    and then rebuilding the project. Assuming you’re building on a platform where
    Libtool has been modified, your build will fail at the point where the flaim and
    xflaim projects try to link their utilities only against the *libflaim.la* and
    *libxflaim.la*. To make it work again, update your `LDADD` variables as I mentioned
    earlier.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Stamp Targets
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In creating this makefile, I ran across another minor problem that I hadn’t
    anticipated. At least one of the unit tests seemed to require that some XML data
    files be present in the directory from which the test is executed. The test failed,
    and when I dug into it, I noticed that it failed while trying to open these files.
    Looking around a bit lead me to the *xflaim/util/xmldata* directory, which contained
    several dozen XML files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: I needed to copy those files into the build hierarchy’s *xflaim/util* directory
    before I could run the unit tests. I know that products prefixed with `check`
    are built before `TESTS` are executed, so it occurred to me that I might list
    these files at ➋ in a `check_DATA PLV`. The `check_DATA` variable refers to a
    file called *copy-xml-files.stamp*, which is a special type of file target called
    a *stamp* target. Its purpose is to replace a group of unspecified files, or a
    non-file-based operation, with one single, representative file. This stamp file
    is used to indicate to the build system that all the XML data files have been
    copied into the *util* directory. Automake often uses stamp files in its own generated
    rules.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule for generating the stamp file at ➍ also copies the XML data files
    into the test execution directory. The `echo` statement simply creates a file
    named *copy-xml-files.stamp* that contains a single word: *Timestamp*. The file
    may contain anything (or nothing at all). The important point here is that the
    file exists and has a time and date associated with it. The `make` utility uses
    this information to determine whether the copy operation needs to be executed.
    In this case, since *copy-xml-files.stamp* has no dependencies, its mere existence
    indicates to `make` that the operation has already been done. Delete the stamp
    file to get `make` to perform the copy operation on the next build.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: This is a sort of hybrid between a true file-based rule and a phony target.
    Phony targets are always executed—they aren’t real files, so `make` has no way
    of determining whether the associated operation should be performed based on file
    attributes. The timestamps of file-based rules can be checked against their dependency
    lists to determine whether they should be re-executed. Stamp rules like this are
    executed only if the stamp file is missing, because there are no dependencies
    against which the target’s time and date should be compared.^([29](footnote.xhtml#ch14fn29))
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Your Room
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: All files placed in the build directory should be cleaned up when the user enters
    `make clean` at the command prompt. Since I placed XML data files into the build
    directory, I also need to clean them up. Files listed in `DATA` variables are
    not cleaned up automatically, because `DATA` files are not necessarily generated.
    Sometimes the `DATA` primary is used to list static project files that need to
    be installed. I “created” a bunch of XML files and a stamp file, so I needed to
    remove these during `make clean`. To this end, I added the `clean-local` target
    at ➎, along with its associated `rm` commands.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful when deleting files copied from the source tree into the corresponding
    location in the build tree—you may inadvertently delete source files when building
    from within the source tree. You can compare *`$(srcdir)`* to “*`.`*” within *`make`*
    commands to see if the user is building in the source tree.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to ensure that files created using your own `make` rules
    get cleaned up during execution of the `clean` target. You can define the `CLEANFILES`
    variable to contain a whitespace-separated list of files (or wildcard specifications)
    to be removed. I used a `clean-local` target in this case, because the `CLEANFILES`
    variable has one caveat: it won’t remove directories, only files. Each of the
    `rm` commands that removes a wildcard file specification refers to at least one
    directory. I’ll show you a proper use of `CLEANFILES` in [Chapter 15](ch15.xhtml).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how well your unit tests clean up after themselves, you still
    might want to write `clean` rules that attempt to clean up intermediary test files.
    That way, your makefiles will clean up droppings from interrupted tests and debug
    runs.^([30](footnote.xhtml#ch14fn30)) Remember that the user may be building in
    the source directory. Try to make your wildcards as specific as possible so you
    don’t inadvertently remove source files.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: I use the Automake-supported `clean-local` target here as a way to extend the
    `clean` target. The `clean-local` target is executed as a dependency of (and thus
    executed before) the `clean` target, if it exists. [Listing 14-17](ch14.xhtml#ch14ex17)
    shows the corresponding code from the Automake-generated *Makefile.in* template,
    so you can see how this infrastructure is wired up. The interesting bits are highlighted.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 14-17*: xflaim/util/Makefile.in: *The clean rules generated by Automake
    from* xflaim/util/Makefile.am'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Automake noted that I had a target named `clean-local` in *Makefile.am*, so
    it added `clean-local` to the dependency list for `clean-am` at ➊ and then added
    it to the `.PHONY` variable at ➋. Had I not written a `clean-local` target, these
    references would have been missing from the generated *Makefile*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, those are the basics. If you’ve followed along and understood what we
    did in this chapter, then you should be able to convert nearly any project to
    use an Autotools-based build system. For more details on the topics covered here,
    I refer you to the Autotools manuals. Often just knowing the name of a concept
    so you can easily find it in the manual or in an online search is worth a great
    deal.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.xhtml), I’ll cover the stranger aspects of converting this
    project, including the details of building Java and C# code, adding compiler-specific
    optimization flags and command line options, and even building RPM packages using
    user-defined `make` targets in your *Makefile.am* files.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
