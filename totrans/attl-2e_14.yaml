- en: '14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FLAIM: AN AUTOTOOLS EXAMPLE'
  prefs: []
  type: TYPE_NORMAL
- en: '*Uncle Abner said . . . a person that started in to carry a cat home by the
    tail was gitting knowledge that was always going to be useful to him*.'
  prefs: []
  type: TYPE_NORMAL
- en: —Mark Twain, Tom Sawyer Abroad
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far in this book, I’ve taken you on a whirlwind tour of the main features
    of Autoconf, Automake, and Libtool, as well as other tools that work well with
    the Autotools. I’ve done my best to explain them in a manner that is not only
    simple to digest but also easy to retain— especially if you’ve had the time and
    inclination to follow along with my examples on your own. I’ve always believed
    that no form of learning comes anywhere close to the learning that happens while
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter and the next, we’ll continue learning about the Auto­tools by
    studying the process I used to convert an existing, real-world, open source project
    from a complex handcoded makefile to a complete GNU Autotools build system. The
    examples I provide in these chapters illustrate the decisions I had to make during
    the conversion process as well as some concrete uses of Autotools features, including
    a few that I haven’t yet presented in previous chapters. These two chapters will
    round out our study of the Autotools by presenting real solutions to real problems.
  prefs: []
  type: TYPE_NORMAL
- en: The project I chose to convert is called *FLAIM*, which stands for *FLexible
    Adaptable Information Management*.
  prefs: []
  type: TYPE_NORMAL
- en: What Is FLAIM?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: FLAIM is a highly scalable database-management library written in C++ and built
    on its own thin portability layer called the FLAIM toolkit. Some readers may recognize
    FLAIM as the database used by both Novell^([1](footnote.xhtml#ch14fn1)) eDirectory
    and the Novell GroupWise server. FLAIM originated at WordPerfect in the late 1980s,
    and it became part of Novell’s software portfolio during the Novell/WordPerfect
    merger in 1994\. Novell eDirectory used a spin-off of a then-late version of FLAIM
    to manage directory information bases that contain over a billion objects, and
    GroupWise used a much earlier spin-off to manage various server-side databases.
  prefs: []
  type: TYPE_NORMAL
- en: Novell made the FLAIM source code available as an open source project licensed
    under the GNU Lesser General Public License (LGPL) version 2^([2](footnote.xhtml#ch14fn2))
    in 2006\. The FLAIM project is currently hosted by [SourceForge.net](http://SourceForge.net),
    and it is the result of 25 years of development and hardening in various WordPerfect
    and Novell products and projects.^([3](footnote.xhtml#ch14fn3))
  prefs: []
  type: TYPE_NORMAL
- en: Why FLAIM?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While FLAIM is far from a mainstream OSS project, it has several qualities that
    make it a perfect example for showing how to convert a project to use the Autotools.
    For one, FLAIM is currently built using a handcoded GNU makefile that contains
    over 2,000 lines of complex make script. The FLAIM makefile contains a number
    of GNU Make–specific constructs, and thus you can only process this makefile using
    GNU Make. Individual (but nearly identical) makefiles are used to build the *flaim*,
    *xflaim*, and *flaimsql* database libraries, and the FLAIM toolkit (*ftk*), as
    well as several utility and sample programs on Linux, various flavors of Unix,
    Windows, and NetWare.
  prefs: []
  type: TYPE_NORMAL
- en: The existing FLAIM build system targets several different flavors of Unix, including
    AIX, Solaris, and HP-UX, as well as Apple’s macOS. It also targets multiple compilers
    on these systems. These features make FLAIM ideal for this sample conversion project
    because I can show you how to handle differences in operating systems and toolsets
    in the new *configure.ac* files.
  prefs: []
  type: TYPE_NORMAL
- en: The existing build system also contains rules for many of the standard Automake
    targets, such as distribution tarballs. Additionally, it provides rules for building
    binary installation packages, as well as RPMs for systems that can build and install
    RPM packages. It even provides targets for building Doxygen^([4](footnote.xhtml#ch14fn4))
    description files, which it then uses to build source documentation. I’ll spend
    a few paragraphs showing you how you can add these types of targets to the infrastructure
    provided by Automake.
  prefs: []
  type: TYPE_NORMAL
- en: The FLAIM toolkit is a portability library that third-party projects can incorporate
    and consume independently. We can use the toolkit to demonstrate Autoconf’s ability
    to manage separate subprojects as optional subdirectories within a project. If
    the user already has the FLAIM toolkit installed on their build machine, they
    can use the installed version or, optionally, override it with a local copy. On
    the other hand, if the toolkit is not installed, then the local, subdirectory-based
    copy will be used by default.
  prefs: []
  type: TYPE_NORMAL
- en: The FLAIM project also provides code to build both Java and C# language bindings,
    so I’ll delve into those esoteric realms a bit. I won’t go into great detail on
    building either Java or C# applications, but I will cover how to write *Makefile.am*
    files that generate both Java and C# programs and language-binding libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The FLAIM project makes good use of unit tests. These are built as individual
    programs that run without command line options, so I can easily show you how to
    add real-world unit tests to the new FLAIM Autotools build system using Automake’s
    trivial test framework.
  prefs: []
  type: TYPE_NORMAL
- en: The FLAIM project and its original build system employ a reasonably modular
    directory layout, making it rather simple to convert to an Autotools modular build
    system. A simple pass of the `diff` utility over the directory tree should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Logistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the first edition of this book was published in 2010, FLAIM had just been
    released as an open source project on [SourceForge.net](http://SourceForge.net)
    using Subversion to manage its source code repository. Since that time, the FLAIM
    project has become, more or less, inactive. No one I’m aware of is actively using
    the code base. As I am the only remaining maintainer of the source code, I’ve
    made a GitHub repository for FLAIM specifically for [Chapters 14](ch14.xhtml)
    and [15](ch15.xhtml) of this second edition of this book. You can find this repository
    at the NSP-Autotools area on GitHub under the FLAIM project.^([5](footnote.xhtml#ch14fn5))
    I’ve updated the information in this chapter to be relevant to FLAIM’s storage
    in a git repository.
  prefs: []
  type: TYPE_NORMAL
- en: The source code repository for this chapter follows a somewhat different style
    than that for preceding chapters. The original Autotools build system changes
    I made to the FLAIM [SourceForge.net](http://SourceForge.net) project are buried
    beneath, and intermixed with, several dozen unrelated changes. Rather than spend
    hours separating out these changes in an effort to provide you with proper before
    and after snapshots of the FLAIM code base, I simply chose to commit the final
    FLAIM code, with its Autotools build system, to the GitHub project.^([6](footnote.xhtml#ch14fn6))
  prefs: []
  type: TYPE_NORMAL
- en: Do not be discouraged about FLAIM’s current activity status—it continues to
    provide a wide variety of opportunities to learn about Autotools build system
    techniques in real-world projects.
  prefs: []
  type: TYPE_NORMAL
- en: An Initial Look
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let me start by saying that converting FLAIM from GNU makefiles to an Autotools
    build system is not a trivial project. It took me a couple of weeks, and much
    of that time was spent determining exactly what to build and how to do it—in other
    words, analyzing the legacy build system. Another significant portion of my time
    was spent converting aspects that lay on the outer fringes of Autotools functionality.
    For example, I spent *much* more time converting build system rules for building
    C# language bindings than I did converting rules for building the core C++ libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in this conversion project is to analyze FLAIM’s existing directory
    structure and build system. What components are actually built, and which components
    depend on which others? Can individual components be built, distributed, and consumed
    independently? These types of component-level relationships are important because
    they’ll often determine how you’ll lay out your project directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FLAIM project is actually several small projects under one umbrella project
    within its repository. There are three separate and distinct database products:
    *flaim*, *xflaim*, and *flaimsql*. The flaim subproject is the original FLAIM
    database library used by eDirectory and GroupWise. The xflaim project is a hierarchical
    XML database developed for internal projects at Novell; it is optimized for path-oriented,
    node-based access. The flaimsql project is an SQL layer on top of the FLAIM database.
    It was written as a separate library in order to optimize the lower-level FLAIM
    API for SQL access. This project was an experiment that, frankly, isn’t quite
    finished (but it does compile).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The point is that all three of these database libraries are separate and unrelated
    to each other, with no interlibrary dependencies. Since they may easily be used
    independently of one another, they can actually be shipped as individual distributions.
    You could consider each an open source project in its own right. This, then, will
    become one of my primary goals: to allow the FLAIM open source project to be easily
    broken up into smaller open source projects that can be managed independently
    of one another.'
  prefs: []
  type: TYPE_NORMAL
- en: The FLAIM toolkit is also an independent project. While it’s tailored specifically
    for the FLAIM database libraries, providing just the system service abstractions
    required for a DBMS, it depends on nothing but itself, and thus it may easily
    be used as the basis for portability within other projects without dragging along
    any unnecessary database baggage.^([7](footnote.xhtml#ch14fn7))
  prefs: []
  type: TYPE_NORMAL
- en: 'The original FLAIM project was laid out in its repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete tree is fairly broad and somewhat deep in places, including significant
    utilities, tests, and other such binaries that are built by the legacy build system.
    At some point during the trek down into this hierarchy, I simply had to stop and
    consider whether it was worth converting that additional utility or layer. (If
    I hadn’t done that, this chapter would be twice as long and half as useful.) To
    this end, I’ve decided to convert the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The database libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit and library interface tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The utilities and other such high-level programs found in various *util* directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java and C# language bindings found in the *xflaim* library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll also convert the C# unit tests, but I won’t go into the Java unit tests,
    because I’m already converting the Java language bindings using Automake’s `JAVA`
    primary. Since Automake provides no help for C#, I have to provide everything
    myself anyway, so I’ll convert the entire C# code base. This will provide an example
    of writing the code for an entirely unsupported Automake product class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As stated earlier, my first true design decision was how to organize the original
    FLAIM project into subprojects. As it turns out, the existing directory layout
    is almost perfect. I’ve created a master *configure.ac* file in the top-level
    *flaim* directory, which is just under the repository root directory. This topmost
    *configure.ac* file acts as a sort of Autoconf control file for each of the four
    lower-level projects: ftk, flaim, flaimsql, and xflaim.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve managed the database library dependencies on the FLAIM toolkit by treating
    the toolkit as a pure external dependency defined by the `make` variables `FTKINC`
    and `FTKLIB`. I’ve conditionally defined these variables to point to one of a
    few different sources, including installed libraries and even locations given
    in user-specified configuration script options.
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding the configure.ac Files*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the following directory layout, I’ve used an annotation column to indicate
    the placement of individual *configure.ac* files. Each of these files represents
    a project that may be packaged and distributed independently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: My next task was to create these *configure.ac* files. The top-level file was
    trivial, so I created it by hand. The project-specific files were more complex,
    so I allowed the `autoscan` utility to do the bulk of the work for me. [Listing
    14-1](ch14.xhtml#ch14ex1) shows the top-level *configure.ac* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1*: configure.ac: *The umbrella project’s Autoconf input file*'
  prefs: []
  type: TYPE_NORMAL
- en: This *configure.ac* file is short and simple because it doesn’t do much; nevertheless,
    there are some new and important concepts here. I invented the name `flaim-projects`
    and the version number `1.0` at ➊. These are not likely to change unless really
    dramatic changes take place in the project directory structure or the maintainers
    decide to ship a complete bundle of the subprojects.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For your own projects, consider using the optional third argument to the *`AC_INIT`*
    macro. You can add an email or web address here to indicate to users where they
    can submit a bug report. The contents of this argument show up in* configure *output.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important aspect of an umbrella project like this is the `AC_CONFIG_SUBDIRS`
    macro at ➏, which I have yet to cover in this book. The argument is a whitespace-separated
    list of the subprojects to be built, where each is a complete *GCS*-compliant
    project in its own right. Here’s the prototype for this macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It allows the maintainer to set up a hierarchy of projects in much the same
    way that Automake `SUBDIRS` configures the directory hierarchy for Automake within
    a single project.
  prefs: []
  type: TYPE_NORMAL
- en: Because the four subprojects contain all the actual build functionality, this
    *configure.ac* file acts merely as a control file, passing all specified configuration
    options to each of the subprojects in the order they’re given in the macro’s argument.
    The FLAIM toolkit project must be built first since the other projects depend
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: Automake in the Umbrella Project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Automake usually requires the existence of several text files in the top-level
    project directory, including the *AUTHORS*, *COPYING*, *INSTALL*, *NEWS*, *README*,
    and *ChangeLog* files. It would be nice not to have to deal with these files in
    the umbrella project. One way to accomplish this is to simply not use Automake
    in the umbrella project. I’d either have to write my own *Makefile.in* template
    for this directory or use Automake just once to generate a *Makefile.in* template
    that I could then check into the repository as part of the project, along with
    the *install-sh* and *missing* scripts added by `automake` `--add-missing` (or
    `autoreconf -i`). Once these files were in place, I could remove `AM_INIT_AUTOMAKE`
    from the master *configure.ac* file.
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to keep Automake and simply use the `foreign` option
    in `AM_INIT_AUTOMAKE` (which I did at ➋) in the macro’s optional parameter. This
    parameter contains a string of whitespace-separated options that tell Automake
    how to act in lieu of specific Automake command line options. When `automake`
    parses the *configure.ac* file, it notes these options and enables them as if
    they’d been passed on the command line. The `foreign` option tells Automake that
    the project will not entirely follow GNU standards, and thus Automake will not
    require the usual GNU project text files.
  prefs: []
  type: TYPE_NORMAL
- en: I chose the latter of the two methods because I might want to alter the list
    of subordinate projects at some point and I don’t want to have to tweak a generated
    *Makefile.in* template by hand. I’ve also passed the `-Wall` and `-Werror` options
    in this list, which indicate that Automake should enable all Automake-specific
    warnings and report them as errors. These options have nothing to do with the
    user’s compilation environment—only Automake processing.
  prefs: []
  type: TYPE_NORMAL
- en: Why Add the Libtool Macros?
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Why include those expensive Libtool macros at ➍? Well, even though I don’t do
    anything with Libtool in the umbrella project, the lower-level projects expect
    a containing project to provide all the necessary scripts, and the `LT_INIT` macro
    provides the *ltmain.sh* script. If you don’t initialize Libtool in the umbrella
    project, tools like `autoreconf`, which actually looks in the *parent* directory
    to determine if the current project is itself a subproject, will fail when they
    can’t find scripts that the current project’s *configure.ac* file requires.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `autoreconf` expects to find a file called *../ltmain.sh* within
    the ftk project’s top-level directory. Note the reference to the parent directory
    here: `autoreconf` noticed, by examining the parent directory, that ftk was actually
    a subproject of a larger project. Rather than install all the auxiliary scripts
    multiple times, the Autotools generate code that looks for scripts in the project’s
    parent directory. This is done in an effort to reduce the number of copies of
    these scripts that are installed into multiproject packages.^([8](footnote.xhtml#ch14fn8))
    If I don’t use `LT_INIT` in the umbrella project, I can’t successfully run `autoreconf`
    in the subprojects, because the *ltmain.sh* script won’t be in the project’s parent
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Macro Subdirectory
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `AC_CONFIG_MACRO_DIRS` macro at ➎ indicates the name of a subdirectory
    in which the `aclocal` utility can find all project-specific M4 macro files. Here’s
    the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The *.m4* macro files in this directory are ultimately referenced with an `m4_include`
    statement in the `aclocal`-generated *aclocal.m4* file, which `autoconf` reads.
    This macro replaces the original *acinclude.m4* file with a directory containing
    individual macros or smaller sets of macros, each defined in its own *.m4* file.^([9](footnote.xhtml#ch14fn9))
  prefs: []
  type: TYPE_NORMAL
- en: I’ve indicated by the parameter to `AC_CONFIG_MACRO_DIRS` that all of the local
    macro files to be added to *aclocal.m4* are in a subdirectory called *m4*. As
    a bonus, when `autoreconf -i` is executed, and then when it executes the required
    Autotools with their respective *add-missing* options, these tools will note the
    use of this macro in *configure.ac* and add any required system macro files that
    are missing to the *m4* directory.
  prefs: []
  type: TYPE_NORMAL
- en: The reason I chose to use `AC_CONFIG_MACRO_DIRS` here is that Libtool will not
    add its additional macro files to the project if you haven’t enabled the macro
    directory option in this manner. Instead, it will complain that you should add
    these files to *acinclude.m4* yourself.^([10](footnote.xhtml#ch14fn10))
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a fairly complex project and I wanted the Autotools to do this
    job for me, I decided to use this macro-directory feature. Future releases of
    the Autotools will likely require this form because it’s considered the more modern
    way of adding macro files to *aclocal.m4*, as opposed to using a single user-generated
    *acinclude.m4* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final thought on this macro: if you look for it in the Autoconf manual,
    you won’t find it—at least not yet, because it’s not an Autoconf macro but an
    Automake macro. It’s prefixed with `AC_` because it was always intended that a
    future release of Autoconf would take on this macro. It’s more functional than
    its singular predecessor, which *is* documented in the Autoconf manual, but the
    functionality was not needed until Automake came along. In fact, I have it on
    pretty good authority (the pre-release Autoconf *ChangeLog*) that ownership will
    change hands when Autoconf 2.70 is published.'
  prefs: []
  type: TYPE_NORMAL
- en: The one item that we haven’t yet covered here is the `AM_PROG_AR` macro at ➌.
    This is a newer Automake macro. The first edition of this book didn’t use it.
    When I updated the Autotools, suddenly `autoreconf` complained that I needed it,
    so I added it and the complaint went away. The Autoconf manual says simply that
    you need it if you want to use an archiver (`ar`) that has an unusual interface
    (such as Microsoft `lib`). The fact is, the real complainer here was Libtool,
    which seems to have a habit of complaining about not including features of the
    other Autotools that it thinks you should be using. I added it to silence the
    warning.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Top-Level Makefile.am File*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The only other point to be covered regarding the umbrella project is the top-level
    *Makefile.am* file, shown in [Listing 14-2](ch14.xhtml#ch14ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2*: Makefile.am: *The umbrella project Automake input file*'
  prefs: []
  type: TYPE_NORMAL
- en: According to the Automake documentation, the `ACLOCAL_AMFLAGS` variable at ➊
    should be defined in the top-level *Makefile.am* file of any project that uses
    `AC_CONFIG_MACRO_DIR` (singular) in its *configure.ac* file. The flags specified
    on this line tell `aclocal` where it should look for macro files when it’s executed
    by rules defined in *Makefile.am*. The format of this option is similar to that
    of a C-compiler command line include (`-I`) directive; you can specify other `aclocal`
    command line options as well.
  prefs: []
  type: TYPE_NORMAL
- en: This variable used to be required when using a macro subdirectory with the older
    `AC_CONFIG_MACRO_DIR`, but with the advent of the newer `AC_CONFIG_MACRO_DIRS`,
    you no longer need this variable, as it generates code that allows Automake to
    understand which options it should pass to `aclocal`. Unfortunately, Libtool just
    can’t help but pipe up during `autoreconf` when it sees you using a macro directory
    without this variable in your *Makefile.am* files. I’m hoping this noise will
    go away when Autoconf takes ownership of the newer macro (with a subsequent release
    of Libtool, of course).
  prefs: []
  type: TYPE_NORMAL
- en: The Autotools use this variable in two unrelated places. The first is in a `make`
    rule generated to update the *aclocal.m4* file from all of its various input sources.
    This rule and its supporting variable definitions are shown in [Listing 14-3](ch14.xhtml#ch14ex3),
    which is a code snippet copied from an Autotools-generated makefile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: The `make` rule and the variables used to update* aclocal.m4
    *from its various dependencies*'
  prefs: []
  type: TYPE_NORMAL
- en: The `ACLOCAL_AMFLAGS` definition is also used during execution of `autoreconf`,
    which scans the top-level *Makefile.am* file for this definition and passes the
    value text directly to `aclocal` on the command line. Be aware that `autoreconf`
    does no variable expansion on this string, so if you add shell or `make` variable
    references to the text, they won’t be expanded when `autoreconf` executes `aclocal`.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to [Listing 14-2](ch14.xhtml#ch14ex2), I’ve used the `EXTRA_DIST`
    variable at ➋ to ensure that a few additional top-level files get distributed—these
    files and directories are specific to the Windows build system. This isn’t critical
    to the umbrella project, since I don’t intend to create distributions at this
    level, but I like to be complete.
  prefs: []
  type: TYPE_NORMAL
- en: The `SUBDIRS` variable at ➌ duplicates the information in the *configure.ac*
    file’s `AC_CONFIG_SUBDIRS` macro. I tried creating a shell substitution variable
    and exporting it with `AC_SUBST`, but it didn’t work—when I ran `autoreconf`,
    I got an error indicating that I should use literals in the `AC_CONFIG_SUBDIRS`
    macro argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `rpms` and `srcrpm` targets at ➍ allow the end user to build RPM packages
    for RPM-based Linux systems. The shell commands in this rule simply pass the user-specified
    targets and variables down to each of the lower-level projects in succession,
    just as we did with our handcoded makefiles and *Makefile.in* templates in [Chapters
    3](ch03.xhtml), [4](ch04.xhtml), and [5](ch05.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: When passing control to lower-level makefiles in the manner shown in the commands
    for these RPM targets, you should strive to follow this pattern. Passing the expansion
    of `AM_MAKEFLAGS` allows lower-level makefiles access to the same `make` flags
    defined in the current or parent makefile. However, you can add more functionality
    to such recursive `make` code. To see how Automake passes control down to lower-level
    makefiles for its own targets, open an Automake-generated *Makefile.in* template
    and search for the text “`$(am__recursive_targets):`”. The code beneath this target
    shows exactly how Automake does it. While it looks complex at first glance, the
    code performs only two additional tasks. First, it ensures that continue-after-error
    functionality (`make -k`) works properly. Second, it ensures that the current
    directory (`.`) is handled properly if found in the `SUBDIRS` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings me to my final point about this code: if you choose to write your
    own recursive targets in this manner (and we’ll see other examples of this later
    when we discuss conversion of the flaim build system), you should either avoid
    using a dot in the `SUBDIRS` variable or enhance the shell code to handle this
    special case. If you don’t, your users will likely find themselves in an endless
    recursion loop when they attempt to make one of these targets. For a more extensive
    treatise on this topic, see “Item 2: Implementing Recursive Extension Targets”
    on [page 505](ch18.xhtml#page_505).'
  prefs: []
  type: TYPE_NORMAL
- en: The FLAIM Subprojects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I used `autoscan` to generate a starting point for the ftk project. The `autoscan`
    utility is a bit finicky about where it will look for information. If your project
    doesn’t contain a makefile named exactly *Makefile*, or if your project already
    contains an Autoconf *Makefile.in* template, `autoscan` will not add any information
    about required libraries to the *configure.scan* output file. It has no way of
    determining this information except to look into your old build system, and it
    won’t do this unless conditions are just right.
  prefs: []
  type: TYPE_NORMAL
- en: Given the complexity of the ftk project’s legacy makefile, I was quite impressed
    with `autoscan`’s ability to parse it for library information. [Listing 14-4](ch14.xhtml#ch14ex4)
    shows a portion of the resulting *configure.scan* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4: A portion of the output from `autoscan` when run over the ftk
    project directory structure*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The FLAIM Toolkit configure.ac File*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After this *configure.scan* file was modified and renamed, the resulting *configure.ac*
    file contained many new constructs, which I’ll discuss in the next few sections.
    In order to facilitate the discussion, I split this file into two parts, the first
    half of which is shown in [Listing 14-5](ch14.xhtml#ch14ex5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-5*: ftk/configure.ac: *The first half of the ftk project’s* configure.ac
    *file*'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, you will see that I substituted real values for the placeholders `autoscan`
    left in the `AC_INIT` macro. I added calls to `AM_INIT_AUTOMAKE`, `LT_PREREQ`,
    and `LT_INIT` at ➋, and I added a call to `AC_CONFIG_MACRO_DIRS` at ➍. (For now,
    just ignore the `AM_PROG_AR` macro—I’ll explain it later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I didn’t use the *`foreign`* keyword in *`AM_INIT_AUTOMAKE`* this time. Since
    it’s a real open source project, the FLAIM developers will (or at least, should)
    want these files. I used the *`touch`* command to create empty versions of the
    GNU project text files,^([11](footnote.xhtml#ch14fn11)) except for* COPYING *and*
    INSTALL, *which *`autoreconf`* adds.*'
  prefs: []
  type: TYPE_NORMAL
- en: A new construct at ➌ is the `AC_LANG` macro, which indicates the programming
    language (and thus, the compiler) that Autoconf should use when generating compilation
    tests in `configure`. I’ve passed `C++` as the parameter so Autoconf will compile
    these tests using the C++ compiler via the `CXX` variable, rather than the default
    C compiler via the `CC` variable. I then deleted the `AC_PROG_CC` macro call,
    since the source code for this project is written entirely in C++.
  prefs: []
  type: TYPE_NORMAL
- en: I changed the `AC_CONFIG_SRCDIR` file argument at ➎ to one that made more sense
    to me than the one randomly chosen by `autoscan`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FLM_PROG_TRY_DOXYGEN` macro at ➏ is a custom macro that I wrote. Here’s
    the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: I’ll cover the details of how this macro works in [Chapter 16](ch16.xhtml).
    For now, just know that it manages a precious variable called `DOXYGEN`. If the
    variable is already set, this macro does nothing; if the variable is not set,
    it scans the system search path for a `doxygen` program, setting the variable
    to the program name if it finds one. I’ll explain Autoconf precious variables
    when we get to the xflaim project.
  prefs: []
  type: TYPE_NORMAL
- en: At ➐, I added a couple of configuration options to `configure`’s command line
    parser with `AC_ARG_ENABLE`. I’ll discuss the details of these calls more completely
    as we come to other new constructs that use the variables these macros define.
  prefs: []
  type: TYPE_NORMAL
- en: Automake Configuration Features
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Automake provides the `AM_CONDITIONAL` macro I used at ➑; it has the following
    prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The *`variable`* argument is an Automake conditional name that you can use
    in your *Makefile.am* files to test the associated condition. The *`condition`*
    argument is a *shell condition*—a bit of shell script that could be used as the
    condition in a shell `if-then` statement. In fact, this is exactly how the macro
    uses the *`condition`* argument internally, so it must be formatted as a proper
    `if-then` statement *condition* expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `AM_CONDITIONAL` macro always defines two Autoconf substitution variables
    named *`variable`*`_TRUE` and *`variable`*`_FALSE`. If *`condition`* is true,
    *`variable`*`_TRUE` is empty and *`variable`*`_FALSE` is defined as a hash mark
    (`#`), which indicates the beginning of a comment in a makefile. If *`condition`*
    is false, the definitions of these two substitution variables are reversed; that
    is, *`variable`*`_FALSE` is empty, and *`variable`*`_TRUE` becomes the hash mark.
    Automake uses these variables to conditionally comment out portions of your makefile
    script that are defined within Automake conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: This instance of `AM_CONDITIONAL` defines the conditional name `HAVE_DOXYGEN`,
    which you can use in the project’s *Makefile.am* files to do something conditionally,
    based on whether or not `doxygen` can be executed successfully (via the `DOXYGEN`
    variable). Any lines of `make` script found within a test for truth in *Makefile.am*
    are prefixed with `@`*`variable`*`_TRUE@` in the Automake-generated *Makefile.in*
    template. Conversely, any lines found within an Automake conditional test for
    falseness are prefixed with `@`*`variable`*`_FALSE@`. When `config.status` generates
    *Makefile* from *Makefile.in*, these lines are either commented out (prefixed
    with hash marks) or not, depending on the truth or falseness of the condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s just one caveat with using `AM_CONDITIONAL`: you cannot call it conditionally
    (for instance, within a shell `if-then-else` statement) in the *configure.ac*
    file. You can’t define substitution variables conditionally—you can define their
    contents differently based on the specified condition, but the variables themselves
    are either defined or not at the time Autoconf creates the `configure` script.
    Since Automake-generated template files are created long before the user executes
    `configure`, Automake must be able to rely on the existence of these variables,
    regardless of how they’re defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `configure` script, you may want to perform other Autoconf operations
    based on the value of Automake conditionals. This is where the (commented) Automake-provided
    `AM_COND_IF` macro at ➒ comes into play.^([12](footnote.xhtml#ch14fn12)) Its prototype
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If *`conditional-variable`* is defined as true by a previous call to `AM_CONDITIONAL`,
    the *`if-true`* shell script (including any Autoconf macro calls) is executed.
    Otherwise, the *`if-false`* shell script is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s suppose, for example, that you want to conditionally build a portion
    of your project directory structure—say, the *xflaim/docs/doxygen* directory—based
    on the Automake conditional `HAVE_DOXYGEN`. Perhaps you are appending the subdirectory
    in question onto the `SUBDIRS` variable within an Automake conditional statement
    in your *Makefile.am* file (I’m actually doing this, as you’ll see in “The FLAIM
    Toolkit Makefile.am File” on [page 388](ch14.xhtml#page_388)). Since `make` won’t
    be building this portion of the project directory structure if the condition is
    false, there’s certainly little reason to have `config.status` process the *doxyfile.in*
    template within that directory during configuration. Therefore, you might use
    the code shown in [Listing 14-6](ch14.xhtml#ch14ex6) in your *configure.ac* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-6*: ftk/configure.ac: *Using `AM_COND_IF` to conditionally configure
    a template*'
  prefs: []
  type: TYPE_NORMAL
- en: With this code in place, `configure` simply will not process the *doxyfile.in*
    template at all within the *docs* directory if `doxygen` isn’t installed on the
    user’s system.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* docs/Makefile.in *template should not be included here because the *`dist`*
    target must be able to process all directories in the project—whether or not they’re
    conditionally built—during execution of build targets such as *`all`* and *`clean`*.
    Thus, you should never conditionally process* Makefile.in *templates within* configure.ac.
    *However, you can certainly process other types of templates conditionally.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The line following the line at ➒ is an alternative method of accomplishing
    the same thing using *M4sh*—a macro library built into Autoconf that’s designed
    to make it easier to write portable Bourne shell script. Here is the prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The optional, elided parameters between the second and last ones shown are pairs
    of *`test`*`N` and *`run-if-true`* arguments. Ultimately, this macro works much
    like an `if-then-elif...` shell statement with a user-specified number of `elif`
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-7](ch14.xhtml#ch14ex7) shows the second half of ftk’s *configure.ac*
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-7*: ftk/configure.ac: *The second half of the ftk project’s* configure.ac
    *file*'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, I’ve called the `AC_SYS_LARGEFILE` macro. If the user has a 32-bit system,
    this macro ensures that appropriate C-preprocessor definitions (and possibly compiler
    options) that force the use of 64-bit file addressing (also called *large files*)
    are added to the *config.h.in* template. With these variables in place, C-library
    large-address-aware file I/O functions become available to the project source
    code. FLAIM, as a database system, cares very much about this feature.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, 32-bit general-purpose computer systems have become less
    popular as companies like Intel and Microsoft have made media statements concerning
    future versions of their products that will no longer support 32-bit address spaces.
    However, market pressures caused by the millions of existing 32-bit systems have
    cause them to back off a bit on the rhetoric and return to a more pragmatic perspective.
    Nevertheless, 32-bit PCs are on their way out the door in the not-too-distant
    future. Even so, Linux will continue to run on 32-bit systems because many embedded
    systems still get significant benefits from using smaller, less-power-hungry 32-bit
    microprocessors.
  prefs: []
  type: TYPE_NORMAL
- en: Doing Threads the Right Way
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There is another new construct, `AX_PTHREAD`, at ➋. In the Jupiter project,
    I simply linked the `jupiter` program with the *pthreads* library via the `-lpthread`
    linker flag. But frankly, this is the wrong way to use *pthreads*.
  prefs: []
  type: TYPE_NORMAL
- en: In the presence of multiple threads of execution, you must configure many of
    the standard C-library functions to act in a thread-safe manner. You can do this
    by ensuring that one or more preprocessor definitions are visible to all of the
    standard library header files as they’re being compiled into the program. These
    C-preprocessor definitions must be defined on the compiler command line, and they’re
    not standardized between compiler vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Some vendors provide entirely different standard libraries for building single-threaded
    versus multithreaded programs, because adding thread safety to a library reduces
    performance to a degree. Compiler vendors believe (correctly) that they’re doing
    you a favor by giving you different versions of the standard library for these
    purposes. In this scenario, it’s necessary to tell the linker to use the correct
    runtime libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, every vendor does multithreading in its own way, from compiler
    options to library names to preprocessor definitions. But there is a reasonable
    solution to the problem: the GNU Autoconf Archive^([13](footnote.xhtml#ch14fn13))
    provides a macro called `AX_PTHREAD` that checks out a user’s compiler and provides
    the correct flags and options for a wide variety of platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This macro is very simple to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It sets several environment variables, including `PTHREAD_CFLAGS`, `PTHREAD``_CXXFLAGS`,
    and `PTHREAD_LIBS`. It’s up to the caller to use these variables properly by adding
    shell code to the *`action-if-found`* argument. If all of your project’s code
    is multithreaded, things are simpler: you need only append these variables to,
    or consume them from within, the standard `CFLAGS`, `CXXFLAGS`, and `LIBS` variables.
    The FLAIM project code base is completely multithreaded, so I chose to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: If you examine the contents of the *ax_pthread.m4* file in the *ftk/m4* directory,
    you might expect to find a large `case` statement that sets options for every
    compiler and platform combination known to man—but that’s not the Autoconf way.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the macro incorporates a long list of known *pthreads* compiler options,
    and the generated `configure` script uses the host compiler to compile a small
    *pthreads* program with each one of these options in turn. The flags that are
    recognized by the compiler, and that therefore properly build the test program,
    are added to the `PTHREAD_CFLAGS` and `PTHREAD_CXXFLAGS` variables. This way,
    `AX_PTHREAD` stands a good chance of continuing to work properly, even in the
    face of significant changes to compiler options in the future—and this *is* the
    Autoconf way.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Just the Right Libraries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: I deleted the *FIXME* comments (see *configure.scan* in [Listing 14-4](ch14.xhtml#ch14ex4)
    on [page 378](ch14.xhtml#page_378)) above each of the `AC_CHECK_LIB` macro calls
    at ➌ in [Listing 14-7](ch14.xhtml#ch14ex7). I started to replace the main placeholders
    in these macros with actual library function names, but then I began to wonder
    if all of those libraries were really necessary. I wasn’t as concerned about `autoscan`’s
    abilities as I was about the veracity of the original makefile. In handcoded build
    systems, I’ve occasionally noticed that the author will cut and paste sets of
    library names from one makefile to another until the program builds without missing
    symbols.^([14](footnote.xhtml#ch14fn14))
  prefs: []
  type: TYPE_NORMAL
- en: Instead of blindly continuing this trend, I chose to simply comment out all
    of the calls to `AC_CHECK_LIB` to see how far I could get in the build, adding
    them back in one at a time as required to resolve missing symbols. Unless your
    project consumes literally hundreds of libraries, this will only take a few extra
    minutes. I like to link only the libraries that are necessary for my project;
    it speeds up the link process and, when done religiously, provides a good form
    of project-level documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The *configure.scan* file contained 14 such calls to `AC_CHECK_LIB`. As it turned
    out, the FLAIM toolkit on my 64-bit Linux system only required three of them—*pthread*,
    *ncurses*, and *rt*—so I deleted the remaining entries and swapped out the placeholder
    parameters for real functions in the *ncurses* and *rt* libraries. In retrospect,
    it appears that my gambit paid off rather handsomely, because I dropped from 14
    libraries to 2\. The third library was the POSIX Thread (*pthreads*) library,
    which is added via the `AX_PTHREAD` macro I discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: I also converted the *ncurses* `AC_CHECK_LIB` call to `AC_SEARCH_LIBS` because
    I suspect that future FLAIM platforms may use different library names for *curses*
    functionality. I’d like to prepare the build system to have additional libraries
    searched on these platforms. The *ncurses* library is an optional library on most
    platforms, so I added the `AC_CHECK_HEADER` macro to check for *curses.h*, display
    a message in the *`action-if-not-found`* (third) argument that the user should
    install the *curses-development* package, and exit the configuration process with
    an error. The rule is to find problems early, during configuration, rather than
    during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainer-Defined Command Line Options
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The next four libraries are checked within an Autoconf conditional statement
    at ➍. This statement is based on the end user’s use of the `--enable-openssl`
    command line argument, which `AC_ARG_ENABLE` provides (see ➐ in [Listing 14-5](ch14.xhtml#ch14ex5)
    on [page 379](ch14.xhtml#page_379)).
  prefs: []
  type: TYPE_NORMAL
- en: I use `AS_IF` here instead of a shell `if-then` statement because, if any of
    the macros called within the conditional statement require additional macros to
    be expanded in order to operate correctly, `AS_IF` will ensure that these dependencies
    are expanded first, outside of the conditional statement. As well as being part
    of the *M4sh* library, the `AS_IF` macro is part of the Autoconf auto-dependency
    framework (also discussed in detail in “Autoconf and M4” on [page 439](ch16.xhtml#page_439)).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `openssl` variable is defined to either `yes` or `no` based
    on the default value given to `AC_ARG_ENABLE` and on the end user’s command line
    choices.
  prefs: []
  type: TYPE_NORMAL
- en: The `AC_DEFINE` macro, called in the first argument of `AS_IF`, ensures that
    the C-preprocessor variable `FLM_OPENSSL` is defined in the *config.h* header
    file. The `AC_CHECK_LIB` macros then ensure that `-lssl`, `-lcrypto`, `-ldl`,
    and `-lz` strings are added to the `LIBS` variable, but only if the `openssl`
    variable is set to `yes`. We don’t want to insist that the user have those libraries
    installed unless they have asked for features that need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get as sophisticated as you want when dealing with maintainer-defined
    command line options such as `--enable-openssl`. But be careful: some levels of
    automation can surprise your users. For instance, automatically enabling the option
    because your checks found that the OpenSSL libraries were installed and accessible
    can be a bit disconcerting.'
  prefs: []
  type: TYPE_NORMAL
- en: I left all the header file and library function checks at ➎, as specified by
    `autoscan`, because a simple text scan through the source code for header files
    and function names is probably pretty accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, however, that `autoscan` did not put *all* of the header files used
    by ftk source code into the `AC_CHECK_HEADERS` argument. The `autoscan` utility’s
    algorithm is simple but effective: it adds all header files included conditionally
    by your source code. This approach assumes that any header file you include conditionally
    might be included differently on different platforms due to portability issues.
    While this approach is usually correct, it’s not always correct, so you should
    look at each of the headers added, find the conditional inclusion in your source
    code, and make a more intelligent assessment of whether or not it should be added
    to `AC_CHECK_HEADERS` in *configure.ac*.'
  prefs: []
  type: TYPE_NORMAL
- en: A good example in this project is the conditional inclusion of *stdlib.h*. As
    it happens, *stdlib.h* is included for Windows builds, and it’s also included
    for Unix builds. It is not, however, included for NetWare builds. Regardless,
    it doesn’t really need to be checked for in `AC_CHECK_HEADERS` for two reasons.
    First, it’s widely standardized across platforms, and second, this build system
    is specifically designed for Unix systems.^([15](footnote.xhtml#ch14fn15)) The
    point is, you should carefully examine what `autoscan` does for you to determine
    if it should be done in your project.
  prefs: []
  type: TYPE_NORMAL
- en: At ➏, we see the conditional (`AS_IF`) use of `AC_DEFINE` based on the contents
    of the `debug` variable. This is another environment variable that’s conditionally
    defined based on the results of a command line parameter given to `configure`.
    The `--enable-debug` option sets the debug variable to `yes`, which ultimately
    enables the `FLM_DEBUG` C-preprocessor definition within *config.h*. Both `FLM_OPENSSL`
    and `FLM_DEBUG` were already used within the FLAIM project source code. Using
    `AC_DEFINE` in this manner allows the end user to determine which features are
    compiled into the libraries.
  prefs: []
  type: TYPE_NORMAL
- en: I left a fairly large chunk of code out of the listing at ➐ that deals with
    compiler and tool optimizations, which I’ll present in the next chapter. This
    code is identical in all of the projects’ *configure.ac* files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I added references to the makefiles in the *docs*, *obs*, *src*, and
    *util* directories, as well as the *obs/flaimtk.spec* and *src/libflaimtk.pc*
    files at ➑ to the `AC_CONFIG_FILES` macro call, and then I added my usual `cat`
    statement at ➒ near the bottom for some visual verification of my configuration
    status. For now, just ignore the `sed` command right above the `cat` statement.
    I’ll cover that in “Transitive Dependencies” on [page 401](ch14.xhtml#page_401).
  prefs: []
  type: TYPE_NORMAL
- en: '*The FLAIM Toolkit Makefile.am File*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we ignore the commands for Doxygen- and RPM-specific targets (for now), the
    *ftk/Makefile.am* file is fairly trivial. [Listing 14-8](ch14.xhtml#ch14ex8) shows
    the entire file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-8*: ftk/Makefile.am: *The entire contents of the FLAIM toolkit’s
    top-level makefile*'
  prefs: []
  type: TYPE_NORMAL
- en: In this file you’ll find the usual `ACLOCAL_AMFLAGS`, `EXTRA_DIST`, and `SUBDIRS`
    variable definitions, but you can also see the use of an Automake conditional
    at ➊. The `if` statement allows me to append another directory (*docs*) to the
    `SUBDIRS` list, but only if the `doxygen` program is available (according to `configure`).
    I used a separate variable here (`DOXYDIR`), but the Automake conditional could
    just as well have surrounded a statement that directly appends the directory name
    (`doc`) to the `SUBDIRS` variable using the Automake `+=` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t confuse Automake conditionals with GNU Make conditionals, which use
    the keywords *`ifeq`*, *`ifneq`*, *`ifdef`*, and *`ifndef`*. If you try to use
    an Automake conditional in* Makefile.am *without a corresponding *`AM_CONDITIONAL`*
    statement in* configure.ac, *Automake will complain about it. When this construct
    is used properly, Automake converts it to something that *`make`* understands
    before *`make`* sees it.*'
  prefs: []
  type: TYPE_NORMAL
- en: Another new construct (at least in a top-level *Makefile.am* file) is the use
    of the `doc_DATA` variable at ➋. The FLAIM toolkit provides some extra documentation
    files in its top-level directory that I’d like to have installed. By using the
    `doc` prefix on the `DATA` primary, I’m telling Automake that I’d like these files
    to be installed as data files in the `$(docdir)` directory, which ultimately resolves
    to the `$(prefix)`*/share/doc* directory, by default.
  prefs: []
  type: TYPE_NORMAL
- en: Files mentioned in `DATA` variables that don’t already have special meaning
    to Automake are not automatically distributed (that is, they’re not added to distribution
    tarballs), so you have to manually distribute them by adding them to the files
    listed in the `EXTRA_DIST` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*I did not have to list the standard GNU project text files in *`EXTRA_DIST`*
    because they’re always distributed automatically. However, I did have to mention
    theses files in the *`doc_DATA`* variable, because Automake makes no assumptions
    about which files you want to install.*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll defer a discussion of the RPM targets at ➌ to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Automake -hook and -local Rules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Automake recognizes two types of integrated extensions, which I call `-local`
    targets and `-hook` targets. Automake recognizes and honors `-local` extensions
    for the following standard targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `all` | `install-data` | `installcheck` |'
  prefs: []
  type: TYPE_TB
- en: '| `check` | `install-dvi` | `installdirs` |'
  prefs: []
  type: TYPE_TB
- en: '| `clean` | `install-exec` | `maintainer-clean` |'
  prefs: []
  type: TYPE_TB
- en: '| `distclean` | `install-html` | `mostlyclean` |'
  prefs: []
  type: TYPE_TB
- en: '| `dvi` | `install-info` | `pdf` |'
  prefs: []
  type: TYPE_TB
- en: '| `html` | `install-pdf` | `ps` |'
  prefs: []
  type: TYPE_TB
- en: '| `info` | `install-ps` | `uninstall` |'
  prefs: []
  type: TYPE_TB
- en: Appending `-local` to any of these in your *Makefile.am* files will cause the
    associated commands to be executed *before* the standard target. Automake does
    this by generating the rule for the standard target so that the `-local` version
    is one of its dependencies (if it exists).^([16](footnote.xhtml#ch14fn16)) In
    “Cleaning Your Room” on [page 404](ch14.xhtml#page_404), I’ll show an example
    of this concept using a `clean-local` target.
  prefs: []
  type: TYPE_NORMAL
- en: The `-hook` targets are a bit different in that they are executed *after* the
    corresponding standard target is executed.^([17](footnote.xhtml#ch14fn17)) Automake
    does this by adding another command to the end of the standard target command
    list. This command merely executes `$(MAKE)` on the containing makefile, with
    the `-hook` target as the command line target. Thus, the `-hook` target is executed
    at the end of the standard target commands in a recursive fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following standard Automake targets support `-hook` versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `dist` | `install-data` | `uninstall` |'
  prefs: []
  type: TYPE_TB
- en: '| `distcheck` | `install-exec` |  |'
  prefs: []
  type: TYPE_TB
- en: Automake automatically adds all existing `-local` and `-hook` targets to the
    `.PHONY` rule within the generated makefile.
  prefs: []
  type: TYPE_NORMAL
- en: In the first edition of this book, I used the `dist-hook` target at ➍ in *Makefile.am*
    (now commented out) to adjust the distribution directory after it’s built but
    before `make` builds a distribution archive from its contents. The `rm` command
    removed extraneous files and directories that became part of the distribution
    directory as a result of my adding entire directories to the `EXTRA_DIST` variable.
    When you add directory names to `EXTRA_DIST` (*debian*, *netware*, and *win32*,
    in this case), everything in those directories is added to the distribution—even
    hidden repository control files and directories.^([18](footnote.xhtml#ch14fn18))
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-9](ch14.xhtml#ch14ex9) is a portion of the generated *Makefile*
    that shows how Automake incorporates `dist-hook` into the final makefile. The
    relevant portions are highlighted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-9: The results of defining the `dist-hook` target in* ftk/Makefile.am'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t be afraid to dig into the generated makefiles to see exactly what Automake
    is doing with your code. While there is a fair amount of ugly shell code in the
    *`make`* commands, most of it is safe to ignore. You’re usually more interested
    in the *`make`* rules that Automake is generating, and it’s easy to separate these
    out.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Designing the ftk/src/Makefile.am File*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I now need to create *Makefile.am* files in the *src* and *utils* directories
    for the FLAIM toolkit project. I want to ensure that all of the original functionality
    is preserved from the old build system as I’m creating these files. Basically,
    this includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Properly building the ftk shared and static libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly specifying installation locations for all installed files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the ftk shared-library version information correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that all remaining unused files are distributed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that platform-specific compiler options are used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template shown in [Listing 14-10](ch14.xhtml#ch14ex10) should cover most
    of these points, so I’ll be using it for all of the FLAIM library projects, with
    appropriate additions and subtractions, based on the needs of each individual
    library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-10: A framework for the src and utils directory* Makefile.am *files*'
  prefs: []
  type: TYPE_NORMAL
- en: The original *GNUMakefile* told me that the library was named *libftk.so*. This
    is a bad name for a library on Linux, because most of the three-letter library
    names are already taken. Thus, I made an executive decision and renamed the *ftk*
    library to *flaimtk*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-11](ch14.xhtml#ch14ex11) shows most of the final *ftk/src/Makefile.am*
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-11*: ftk/src/Makefile.am: *The entire file contents, minus a few
    dozen source files*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I added the Libtool library name, *libflaimtk.la*, to the `lib_LTLIBRARIES`
    list at ➋ and changed the *`xxxxx`* portions of the remaining macros in [Listing
    14-10](ch14.xhtml#ch14ex10) to `libflaimtk`. I could have entered all the source
    files by hand, but I noticed while reading the original makefile that it used
    the GNU `make` function macro `$(wildcard src/*.cpp)` to build the file list from
    the contents of the *src* directory. This tells me that all of the *.cpp* files
    within the *src* directory are required (or at least consumed) by the library.
    To get the file list into *Makefile.am*, I used a simple shell command to concatenate
    it to the end of the *Makefile.am* file (assuming I’m in the *ftk/src* directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This left me with a single-column, backslash-terminated, alphabetized list of
    all of the *.cpp* files in the *ftk/src* directory at the bottom of *ftk/src/Makefile.am*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do not forget the single quotes around the *`printf`* argument, which are
    necessary to keep the first pair of backslashes from being interpreted by the
    shell as escape characters during generation of the list. Regardless of quoting,
    *`printf`* understands and interprets the *`\n`* character properly.*'
  prefs: []
  type: TYPE_NORMAL
- en: I moved the list up to just below the `libflaimtk_la_SOURCES` line at ➎, added
    a backslash character after the equal sign, and removed the one after the last
    file. Another formatting technique is to simply wrap the line with a backslash
    and a carriage return approximately every 70 characters, but I prefer to put each
    file on a separate line, especially early in the conversion process, so I can
    easily extract files from or add files to the lists as needed. Leaving the files
    on separate lines also gets you the benefit of having source lists be easier to
    compare when reviewing differences in pull-request reviews and other `diff`-style
    output.
  prefs: []
  type: TYPE_NORMAL
- en: I had to manually examine each header file in the *src* directory in order to
    determine its use in the project. There were only four header files, and, as it
    turns out, the only one the FLAIM toolkit does *not* use on Unix and Linux platforms
    is *ftknlm.h*, which is specific to the NetWare build. I added this file to the
    `EXTRA_DIST` list at ➊ so it would be distributed; just because the build doesn’t
    use it doesn’t mean that users won’t want or need it.^([19](footnote.xhtml#ch14fn19))
  prefs: []
  type: TYPE_NORMAL
- en: The (newly renamed) *flaimtk.h* file is the only public header file, so I moved
    it into the `include_HEADERS` list at ➌. The other two files are used internally
    in the library build, so I left them in the `libflaimtk_la_SOURCES` list. Had
    this been my own project, I would have moved *flaimtk.h* into an *include* directory
    off the project root directory, but remember that one of my goals here was to
    limit changes to the directory structure and the source code. Moving this header
    file is a philosophical decision that I decided to leave to the maintainers.^([20](footnote.xhtml#ch14fn20))
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I noticed in the original makefile that the last release of the *ftk*
    library published an interface version of 4.0\. However, since I changed the name
    of the library from *libftk* to *libflaimtk*, I reset this value to 0.0 because
    it’s a different library. I replaced *`x`*`:`*`y`*`:`*`z`* with `0:0:0` in the
    `-version-info` option at ➏ within the `libflaimtk_la_LDFLAGS` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A version string of *`0:0:0`* is the default, so I could have removed the
    argument entirely and achieved the same result. However, including it gives new
    developers some insight into how to change the interface version in the future.*'
  prefs: []
  type: TYPE_NORMAL
- en: I added the `pkgconfigdir` and `pkgconfig_DATA` variables at ➍ in order to provide
    support for installing pkg-config metadata files for this project. For more on
    the pkg-config system, see [Chapter 10](ch10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '*Moving On to the ftk/util Directory*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Properly designing *Makefile.am* for the *util* directory requires examining
    the original makefile again for more products. A quick glance at the *ftk/util*
    directory showed that there was only one source file: *ftktest.cpp*. This appeared
    to be some sort of testing program for the *ftk* library, but I know that the
    FLAIM developers use it all the time in various ways besides simply for testing
    a build. So I had a design decision to make here: should I build this as a normal
    program or as a check program?'
  prefs: []
  type: TYPE_NORMAL
- en: '*Check programs* are only built when `make check` is executed, and they’re
    never installed. If I want `ftktest` built as a regular program, but not installed,
    I have to use the `noinst` prefix rather than the usual `bin` prefix in the program
    list variable.'
  prefs: []
  type: TYPE_NORMAL
- en: In either case, I probably want to add `ftktest` to the list of tests that are
    executed during `make check`, so the two questions here are (1) whether I want
    to automatically run `ftktest` during `make check` and (2) whether I want to install
    the `ftktest` program. Given that the FLAIM toolkit is a mature product, I opted
    to build `ftktest` during `make check` and leave it uninstalled.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-12 shows my final *ftk/util/Makefile.am* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-12*: ftk/util/Makefile.am: *The final contents of this file*'
  prefs: []
  type: TYPE_NORMAL
- en: I hope that by now you can see the relationship between `TESTS` and `check_PROGRAMS`.
    To be blunt, there really is *no* relationship between the files listed in `check_PROGRAMS`
    and those listed in `TESTS`. The `check` target simply ensures that `check_PROGRAMS`
    are built before the `TESTS` programs and scripts are executed. `TESTS` can refer
    to anything that can be executed without command line parameters. This separation
    of duties makes for a very clean and flexible system.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it for the FLAIM toolkit library and utilities. I don’t know about
    you, but I’d much rather maintain this small set of short files than a single
    2,200-line makefile!
  prefs: []
  type: TYPE_NORMAL
- en: Designing the XFLAIM Build System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that I’ve finished with the FLAIM toolkit, I’ll move on to the xflaim project.
    I’m choosing to start with xflaim, rather than flaim, because it supplies the
    most build features that can be converted to the Autotools, including the Java
    and C# language bindings (which I won’t actually discuss in detail until the next
    chapter). After xflaim, covering the remaining database projects would be redundant,
    because the processes are identical, if not a little simpler. However, you can
    find the other build system files in this book’s GitHub repositories.
  prefs: []
  type: TYPE_NORMAL
- en: I generated the *configure.ac* file using `autoscan` once again. It’s important
    to use `autoscan` in each of the individual projects, because the source code
    for each project is different and will thus cause different macros to be written
    into each *configure.scan* file.^([21](footnote.xhtml#ch14fn21)) I then used the
    same techniques I used on the FLAIM toolkit to create xflaim’s *configure.ac*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '*The XFLAIM configure.ac File*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After hand-modifying the generated *configure.scan* file and renaming it *configure.ac*,
    I found it to be similar in many ways to the toolkit’s *configure.ac* file. It’s
    fairly long, so I’ll show you only the most significant differences in [Listing
    14-13](ch14.xhtml#ch14ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-13*: xflaim/configure.ac: *The most significant portions of this
    Autoconf input file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, notice that I’ve invented a few more `FLM_PROG_TRY_*` macros at ➊. Here
    I’m checking for the existence of the following programs: a C# compiler, a C#
    virtual machine, a Java compiler, a JNI header and stub generator, a Javadoc generation
    tool, a Java archive tool, and Doxygen. I’ve written separate macro files for
    each of these checks and added them to my *xflaim/m4* directory.'
  prefs: []
  type: TYPE_NORMAL
- en: As with the `FLM_PROG_TRY_DOXYGEN` macro used in the toolkit, each of these
    macros attempts to locate the associated program, but these macros don’t fail
    the configuration process if they can’t find the program. I want to be able to
    use these programs if they’re available, but I don’t want to require the user
    to have them in order to build the base libraries.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find a new macro, `AC_ARG_VAR`, at ➋. Like the `AC_ARG_ENABLE` and `AC_ARG_WITH`
    macros, `AC_ARG_VAR` allows the project maintainer to extend the command line
    interface of the `configure` script. This macro is different, however, in that
    it adds a public variable, rather than a command line option, to the list of public
    variables that `configure` cares about. In this case, I’m adding two public variables,
    `FTKINC` and `FTKLIB`. These will show up in `configure`’s help text under the
    section “Some influential environment variables.” The *GNU Autoconf Manual* calls
    these variables *precious*. All of my `FLM_PROG_TRY_*` macros use the `AC_ARG_VAR`
    macro internally to make the associated variables both public and precious.^([22](footnote.xhtml#ch14fn22))
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The lines of code from* ➋ *through* ➐ *are found in the GitHub repository
    under* xflaim/m4/flm_ftk_search.m4\. *By the end of [Chapter 15](ch15.xhtml),
    all discrepancies are resolved between the listings in this chapter and the files
    in the GitHub repository.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The large chunk of code beginning at ➌ actually uses these variables to set
    other variables used in the build system. The user can set the public variables
    in the environment, or they can specify them on `configure`’s command line in
    this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First, I’ll check to see that either both or neither of the `FTKINC` and `FTKLIB`
    variables is specified. If only one of them is given, I have to fail with an error.
    The user isn’t allowed to tell me where to find only *half* the toolkit; I need
    both the header file and the library.^([23](footnote.xhtml#ch14fn23)) If neither
    of these variables is specified, I search for them at ➍ by looking for a subdirectory
    of the xflaim project directory called *ftk*. If I find one, I’ll configure that
    directory as a subproject to be processed by Autoconf, using the `AC_CONFIG_SUBDIRS`
    macro.^([24](footnote.xhtml#ch14fn24)) I’ll also set both of these variables to
    point to the appropriate relative locations within the ftk subproject.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I don’t find *ftk* as a subdirectory, I’ll look for it in the parent directory
    at ➎. If I find it there, I’ll set the variables appropriately. This time, I don’t
    need to configure the located *ftk* directory as a subproject, because I’m assuming
    that the xflaim project is itself a subproject of the umbrella project. If I don’t
    find *ftk* as either a subproject or a sibling project, I’ll use the standard
    `AC_CHECK_LIB` and `AC_CHECK_HEADERS` macros at ➏ to see if the user’s host has
    the toolkit library installed. In that case, I need only add `-lflaimtk` to the
    `LIBS` variable. Also in that case, the header file will be in the standard location:
    usually */usr(/local)/include*. The default functionality of the optional third
    argument to `AC_CHECK_LIB` would automatically add the library reference to the
    `LIBS` variable, but since I’ve overridden this default functionality, I have
    to manually add the toolkit library reference to `LIBS`.'
  prefs: []
  type: TYPE_NORMAL
- en: If I don’t find the library, I give up with an error message indicating that
    xflaim can’t be built without the FLAIM toolkit. However, after making it through
    all these checks, if the `FTKLIB` variable is no longer empty, I use `AC_SUBST`
    at ➐ to publish the `FTK_INCLUDE` and `FTK_LTLIB` variables, which contain derivations
    of `FTKINC` and `FTKLIB` appropriate for use as command line options to the preprocessor
    and the linker.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Chapter 16](ch16.xhtml) converts the large chunk of code between* ➌ *and*
    ➑ *into a custom M4 macro called *`FLM_FTK_SEARCH`**.'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining code at ➑ calls `AM_CONDITIONAL` for Java, C#, and Doxygen in
    a manner similar to the way I handled Doxygen in the ftk project. These macros
    are configured to generate warning messages indicating that the Java or C# portions
    of the xflaim project will not be built if those tools can’t be found, but I allow
    the build to continue in any case.
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating the xflaim/src/Makefile.am File*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’m skipping the *xflaim/Makefile.am* file, because it’s nearly identical to
    *ftk/Makefile.am*. Instead, we’ll move on to *xflaim/src/Makefile.am*, which I
    wrote by following the same design principles used with the *ftk/src* version.
    It looks very similar to its ftk counterpart, with one exception: according to
    the original build system makefile, the Java native interface (JNI) and C# native
    language–binding sources are compiled and linked right into the *xflaim* shared
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: This is not an uncommon practice, and it’s quite useful because it alleviates
    the need for extra library objects built specifically for these languages. Essentially,
    the *xflaim* shared library exports native interfaces for these languages, which
    are then consumed by their corresponding native wrappers.^([25](footnote.xhtml#ch14fn25))
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to ignore these language bindings for now, but later, when I’m finished
    with the entire xflaim project, I’ll turn my attention back to properly hooking
    them into the library. With this exception then, the *Makefile.am* file shown
    in [Listing 14-14](ch14.xhtml#ch14ex14) looks almost identical to its ftk counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-14*: xflaim/src/Makefile.am: *The xflaim project src directory
    Automake input file*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve conditionally defined the contents of the `SUBDIRS` variable here based
    on variables defined by corresponding Automake conditional statements in *configure.ac*.
    When `make all` is executed, the `SUBDIRS` variable conditionally recurses into
    the *java* and *cs* subdirectories. But when `make dist` is executed, a hidden
    `DIST_SUBDIRS` variable (which is created by Automake from *all of the possible
    contents* of the `SUBDIRS` variable) references all directories appended, either
    conditionally or unconditionally, to `SUBDIRS`.^([26](footnote.xhtml#ch14fn26))
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The library interface version information was extracted from the original
    makefile.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Turning to the xflaim/util Directory*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *util* directory for xflaim is a bit more complex. According to the original
    makefile, it generates several utility programs as well as a convenience library
    that is consumed by these utilities.
  prefs: []
  type: TYPE_NORMAL
- en: It was somewhat more difficult to find out which source files belong to which
    utilities and which were not used at all. Several of the files in the *xflaim/util*
    directory are not used by any of the utilities. Do we distribute these extra source
    files? I chose to do so, because they were already being distributed by the original
    build system and adding them to the `EXTRA_DIST` list makes it obvious to later
    observers that they aren’t used.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 14-15](ch14.xhtml#ch14ex15) shows a portion of the *xflaim/util/Makefile.am*
    file; the parts that are missing are redundant.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-15*: xflaim/util/Makefile.am: *The xflaim project’s* util *directory
    Automake input file*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you can see by the elided sections that I left out several
    long lists of files and products. This makefile builds 22 unit tests, but because
    they’re all identical, except for naming differences and the source files from
    which they’re built, I only left the descriptions for two of them (at ➌).
  prefs: []
  type: TYPE_NORMAL
- en: I’ve defined the file-global `AM_CPPFLAGS` and `LDADD` variables at ➊ in order
    to associate the `XFLAIM` and `FTK` include and library files with each of the
    projects listed in this *Makefile.am* file. This way, I don’t have to explicitly
    append this information to each product.
  prefs: []
  type: TYPE_NORMAL
- en: Transitive Dependencies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Notice, however, that the `AM_CPPFLAGS` variable uses both the `XFLAIM_INCLUDE`
    and `FTK_INCLUDE` variables—the xflaim utilities clearly require information from
    both sets of header files. So why doesn’t the `LDADD` variable reference the *ftk*
    library? This is because Libtool manages transitive dependencies for you and does
    so in a very portable manner, because some systems don’t have a native mechanism
    for managing transitive dependencies. Because I reference *libxflaim.la* through
    `XFLAIM_LDADD`, and because *libxflaim.la* lists *libflaimtk.la* as a dependency,
    Libtool is able to provide the transitive reference for me on the utility programs’
    linker command lines.
  prefs: []
  type: TYPE_NORMAL
- en: For a clearer picture of this, examine the contents of *libxflaim.la* (in your
    build directory under *xflaim/src*—you will have to build the project first; run
    `autoreconf -i; ./configure && make`). You’ll find a few lines near the middle
    of the file that look very much like the contents of [Listing 14-16](ch14.xhtml#ch14ex16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-16: The portion of xflaim/src*/libxflaim.la *that shows dependency
    libraries*'
  prefs: []
  type: TYPE_NORMAL
- en: The path information for *libflaimtk.la* is listed here so we don’t have to
    specify it in the `LDADD` statement for the xflaim utilities.^([27](footnote.xhtml#ch14fn27))
  prefs: []
  type: TYPE_NORMAL
- en: Like Libtool, the GNU linker and the Linux loader can manage transitive dependencies
    (TDs). This is done by having `ld` incorporate these indirect dependencies into
    the ELF binaries it generates when appropriate linker command line options are
    used. Libtool’s mechanism relies on a recursive search of a hierarchy of *.la*
    files, whereas Linux’s native mechanism simply recursively searches the library
    hierarchy at build time and embeds all required library references directly into
    the built program or library. The loader then sees and uses these references at
    load time. A nice aspect of using such native TD management is that, if a library
    is updated in a newer version of a package, the loader will immediately begin
    to reference the updated secondary symbols from the new library’s updated reference
    list, and projects built against that library will immediately begin using the
    new version’s transitive dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, some distro vendors have decided it’s worth taking advantage of this
    feature on their platforms. The problem is, Libtool’s TD management reduces the
    perceived advantages of using `ld`’s (and the system loader’s) internal TD management—it
    gets in the way, so to speak. To solve this issue, these vendors have decided
    to release a modified version of Libtool on their platforms, wherein its TD management
    feature is effectively disabled. The result is that you must now specify all direct
    and indirect libraries on the linker (`libtool`) command line or modify your build
    system to use the non-portable native TD management linker options.
  prefs: []
  type: TYPE_NORMAL
- en: Since native TD management is not supported on all platforms, and Libtool’s
    text file–based approach is completely portable, we often rely heavily on Libtool
    to do the right thing when indirect dependencies are required while linking our
    programs and libraries on systems that don’t have a native TD management system.
    When you use a “distro-crippled” Libtool package to build projects designed to
    take advantage of Libtool’s TD management features, your build simply fails at
    the link stage with “missing DSO” (dynamic shared object) messages.^([28](footnote.xhtml#ch14fn28))
  prefs: []
  type: TYPE_NORMAL
- en: The `sed` command in *configure.ac* searches for the text `link_all_deplibs=no`
    in the *libtool* script and replaces it with `link_all_deplibs=yes`. It’s in there
    twice, and the `sed` command will replace both occurrences. `AC_OUTPUT` executes
    `config.status`, which generates the *libtool* script in the project directory,
    so the `sed` command must follow `AC_OUTPUT` to be effective.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It doesn’t hurt to use this *`sed`* command, even on systems that do not exhibit
    the problem—*`sed`* simply won’t find anything to replace in your* libtool *script.
    Be aware, however, that if your package is picked up for distribution by a Linux
    vendor that uses internal TD management, they’ll probably ship your package with
    these sorts of commands “patched out.”*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, another option is to forgo the use of automatic transitive dependency
    management entirely by simply specifying all of the link dependencies you know
    you’ll need on the linker’s command line for every program or library you build.
    Pkg-config actually does this for you anyway, so if you can rely on pkg-config
    for all your library management needs, then your projects are simply not affected
    by this issue. This can be done manually in the flaim, xflaim, and flaimsql projects
    by adding `$(FTK_LTLIB)` to the `LDADD` variables as, for example, at ➊ in [Listing
    14-15](ch14.xhtml#ch14ex15).
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to try this by commenting out the `sed` commands in *configure.ac*
    and then rebuilding the project. Assuming you’re building on a platform where
    Libtool has been modified, your build will fail at the point where the flaim and
    xflaim projects try to link their utilities only against the *libflaim.la* and
    *libxflaim.la*. To make it work again, update your `LDADD` variables as I mentioned
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Stamp Targets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In creating this makefile, I ran across another minor problem that I hadn’t
    anticipated. At least one of the unit tests seemed to require that some XML data
    files be present in the directory from which the test is executed. The test failed,
    and when I dug into it, I noticed that it failed while trying to open these files.
    Looking around a bit lead me to the *xflaim/util/xmldata* directory, which contained
    several dozen XML files.
  prefs: []
  type: TYPE_NORMAL
- en: I needed to copy those files into the build hierarchy’s *xflaim/util* directory
    before I could run the unit tests. I know that products prefixed with `check`
    are built before `TESTS` are executed, so it occurred to me that I might list
    these files at ➋ in a `check_DATA PLV`. The `check_DATA` variable refers to a
    file called *copy-xml-files.stamp*, which is a special type of file target called
    a *stamp* target. Its purpose is to replace a group of unspecified files, or a
    non-file-based operation, with one single, representative file. This stamp file
    is used to indicate to the build system that all the XML data files have been
    copied into the *util* directory. Automake often uses stamp files in its own generated
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule for generating the stamp file at ➍ also copies the XML data files
    into the test execution directory. The `echo` statement simply creates a file
    named *copy-xml-files.stamp* that contains a single word: *Timestamp*. The file
    may contain anything (or nothing at all). The important point here is that the
    file exists and has a time and date associated with it. The `make` utility uses
    this information to determine whether the copy operation needs to be executed.
    In this case, since *copy-xml-files.stamp* has no dependencies, its mere existence
    indicates to `make` that the operation has already been done. Delete the stamp
    file to get `make` to perform the copy operation on the next build.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a sort of hybrid between a true file-based rule and a phony target.
    Phony targets are always executed—they aren’t real files, so `make` has no way
    of determining whether the associated operation should be performed based on file
    attributes. The timestamps of file-based rules can be checked against their dependency
    lists to determine whether they should be re-executed. Stamp rules like this are
    executed only if the stamp file is missing, because there are no dependencies
    against which the target’s time and date should be compared.^([29](footnote.xhtml#ch14fn29))
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Your Room
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: All files placed in the build directory should be cleaned up when the user enters
    `make clean` at the command prompt. Since I placed XML data files into the build
    directory, I also need to clean them up. Files listed in `DATA` variables are
    not cleaned up automatically, because `DATA` files are not necessarily generated.
    Sometimes the `DATA` primary is used to list static project files that need to
    be installed. I “created” a bunch of XML files and a stamp file, so I needed to
    remove these during `make clean`. To this end, I added the `clean-local` target
    at ➎, along with its associated `rm` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful when deleting files copied from the source tree into the corresponding
    location in the build tree—you may inadvertently delete source files when building
    from within the source tree. You can compare *`$(srcdir)`* to “*`.`*” within *`make`*
    commands to see if the user is building in the source tree.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to ensure that files created using your own `make` rules
    get cleaned up during execution of the `clean` target. You can define the `CLEANFILES`
    variable to contain a whitespace-separated list of files (or wildcard specifications)
    to be removed. I used a `clean-local` target in this case, because the `CLEANFILES`
    variable has one caveat: it won’t remove directories, only files. Each of the
    `rm` commands that removes a wildcard file specification refers to at least one
    directory. I’ll show you a proper use of `CLEANFILES` in [Chapter 15](ch15.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how well your unit tests clean up after themselves, you still
    might want to write `clean` rules that attempt to clean up intermediary test files.
    That way, your makefiles will clean up droppings from interrupted tests and debug
    runs.^([30](footnote.xhtml#ch14fn30)) Remember that the user may be building in
    the source directory. Try to make your wildcards as specific as possible so you
    don’t inadvertently remove source files.
  prefs: []
  type: TYPE_NORMAL
- en: I use the Automake-supported `clean-local` target here as a way to extend the
    `clean` target. The `clean-local` target is executed as a dependency of (and thus
    executed before) the `clean` target, if it exists. [Listing 14-17](ch14.xhtml#ch14ex17)
    shows the corresponding code from the Automake-generated *Makefile.in* template,
    so you can see how this infrastructure is wired up. The interesting bits are highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-17*: xflaim/util/Makefile.in: *The clean rules generated by Automake
    from* xflaim/util/Makefile.am'
  prefs: []
  type: TYPE_NORMAL
- en: Automake noted that I had a target named `clean-local` in *Makefile.am*, so
    it added `clean-local` to the dependency list for `clean-am` at ➊ and then added
    it to the `.PHONY` variable at ➋. Had I not written a `clean-local` target, these
    references would have been missing from the generated *Makefile*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, those are the basics. If you’ve followed along and understood what we
    did in this chapter, then you should be able to convert nearly any project to
    use an Autotools-based build system. For more details on the topics covered here,
    I refer you to the Autotools manuals. Often just knowing the name of a concept
    so you can easily find it in the manual or in an online search is worth a great
    deal.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.xhtml), I’ll cover the stranger aspects of converting this
    project, including the details of building Java and C# code, adding compiler-specific
    optimization flags and command line options, and even building RPM packages using
    user-defined `make` targets in your *Makefile.am* files.
  prefs: []
  type: TYPE_NORMAL
