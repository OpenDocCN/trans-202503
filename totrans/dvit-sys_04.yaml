- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: BINARY AND DATA REPRESENTATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制与数据表示
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: From simple stone tablets and cave paintings to written words and phonograph
    grooves, humans have perpetually sought to record and store information. In this
    chapter, we’ll characterize how the latest of humanity’s big storage breakthroughs,
    digital computing, represents information. We also illustrate how to interpret
    meaning from digital data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单的石碑和洞穴壁画到书写文字和留声机的刻痕，人类一直在不断寻求记录和存储信息。在这一章中，我们将描述人类最新的大规模存储突破——数字计算——如何表示信息。我们还将说明如何从数字数据中解读含义。
- en: 'Modern computers utilize a variety of media for storing information (e.g.,
    magnetic disks, optical discs, flash memory, tapes, and simple electrical circuits).
    We characterize storage devices later in Section 11.2; however, for this discussion,
    the medium is largely irrelevant—whether there’s a laser scanning the surface
    of a DVD or a disk head gliding over a magnetic platter, the output from the storage
    device is ultimately a sequence of electrical signals. To simplify the circuitry,
    each signal is *binary*, meaning that it can take only one of two states: the
    absence of a voltage (interpreted as zero) and the presence of a voltage (one).
    This chapter explores how systems encode information into binary, regardless of
    the original storage medium.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机利用多种介质存储信息（例如，磁盘、光盘、闪存、磁带和简单的电路）。我们将在第 11.2 节中对存储设备进行详细描述；然而，对于本讨论来说，介质本身并不重要——无论是激光扫描
    DVD 表面，还是磁头滑过磁性盘片，存储设备的输出最终都是一系列电信号。为了简化电路，每个信号都是*二进制*的，这意味着它只能处于两种状态之一：无电压（解释为零）或有电压（为一）。本章将探讨系统如何将信息编码为二进制，无论原始存储介质是什么。
- en: 'In binary, each signal corresponds to one *bit* (binary digit) of information:
    a zero or a one. It may be surprising that all data can be represented using just
    zeros and ones. Of course, as the complexity of information increases, so does
    the number of bits needed to represent it. Luckily, the number of unique values
    doubles for each additional bit in a bit sequence, so a sequence of *N* bits can
    represent 2^(*N*) unique values.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制中，每个信号对应一个*比特*（二进制位）信息：零或一。可能令人惊讶的是，所有的数据都可以仅用零和一来表示。当然，随着信息复杂性的增加，表示它所需的比特数也会增加。幸运的是，每增加一个比特，唯一值的数量就会翻倍，因此一个*N*比特的序列可以表示
    2^(*N*) 个独特的值。
- en: '[Figure 4-1](ch04.xhtml#ch4fig1) illustrates the growth in the number of representable
    values as the length of a bit sequence increases. A single bit can represent *two*
    values: 0 and 1\. Two bits can represent *four* values: both of the one-bit values
    with a leading 0 (00 and 01), and both of the one-bit values with a leading 1
    (10 and 11). The same pattern applies for any additional bit that extends an existing
    bit sequence: the new bit can be a 0 or 1, and in either case, the remaining bits
    represent the same range of values they did prior to the new bit being added.
    Thus, adding additional bits exponentially increases the number of values the
    new sequence can represent.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](ch04.xhtml#ch4fig1)展示了随着比特序列长度的增加，可以表示的值的数量如何增长。一个比特可以表示*两个*值：0 和 1。两个比特可以表示*四个*值：前导
    0 的两个单比特值（00 和 01），以及前导 1 的两个单比特值（10 和 11）。同样的模式适用于任何扩展现有比特序列的附加比特：新比特可以是 0 或
    1，无论哪种情况，剩余的比特表示的值范围与添加新比特之前相同。因此，增加额外的比特会指数级增加新序列可以表示的值的数量。'
- en: '![image](../images/04fig01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig01.jpg)'
- en: '*Figure 4-1: The values that can be represented with one to four bits. The
    underlined bits correspond to the prefix coming from the row above.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：一个到四个比特可以表示的值。下划线部分的比特对应于上一行的前缀。*'
- en: Because a single bit doesn’t represent much information, storage systems commonly
    group bits into longer sequences for storing more interesting values. The most
    ubiquitous grouping is a *bytes*, which is a collection of eight bits. One byte
    represents 2⁸ = 256 unique values (0–255)—enough to enumerate the letters and
    common punctuation symbols of the English language. Bytes are the smallest unit
    of addressable memory in a computer system, meaning that a program can’t ask for
    fewer than eight bits to store a variable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因为单个比特并不能代表很多信息，存储系统通常将比特组合成更长的序列，以存储更多有意义的值。最常见的组合是*字节*，它是由八个比特组成的集合。一个字节表示
    2⁸ = 256 个独特的值（0–255），足以列举出英语中的字母和常见的标点符号。字节是计算机系统中最小的可寻址内存单位，这意味着程序不能要求少于八个比特来存储一个变量。
- en: 'Modern CPUs also typically define a *word* as either 32 bits or 64 bits, depending
    on the design of the hardware. The size of a word determines the “default” size
    a system’s hardware uses to move data from one component to another (e.g., between
    memory and registers). These larger sequences are necessary for storing numbers,
    since programs often need to count higher than 256! If you’ve programmed in C,
    you know that you must declare a variable before using it (see “Variables and
    C Numeric Types” on [page 21](ch01.xhtml#lev3_2)). Such declarations inform the
    C compiler of two important properties regarding the variable’s binary representation:
    the number of bits to allocate for it, and the way in which the program intends
    to interpret those bits. Conceptually, the number of bits is straightforward,
    as the compiler simply looks up how many bits are associated with the declared
    type (e.g., a `char` is one byte—see “C Numeric Types” on [page 23](ch01.xhtml#lev3_2))
    and associates that amount of memory with the variable. The interpretation of
    a sequence of bits is much more conceptually interesting. All data in a computer’s
    memory is stored as bits, but bits have no *inherent* meaning. For example, even
    with just a single bit, you could interpret the bit’s two values in many different
    ways: up and down, black and white, yes and no, on and off, etc.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 CPU 通常将 *字（word）* 定义为 32 位或 64 位，具体取决于硬件的设计。字的大小决定了系统硬件在从一个组件传输数据到另一个组件时使用的“默认”大小（例如，内存和寄存器之间）。这些较大的数据序列对于存储数字是必要的，因为程序通常需要计算大于
    256 的数值！如果你曾经使用过 C 语言编程，你就知道在使用变量之前必须先声明它（请参阅 [第 21 页](ch01.xhtml#lev3_2)的“变量和
    C 数值类型”）。这样的声明向 C 编译器传递了两个关于变量二进制表示的关键信息：为它分配的位数，以及程序打算如何解释这些位。概念上，位数是直接的，因为编译器只是查找与声明类型相关联的位数（例如，`char`
    是一个字节——请参见 [第 23 页](ch01.xhtml#lev3_2)的“C 数值类型”），并将相应的内存分配给变量。对一组位的解释则更加具有概念上的趣味性。计算机内存中的所有数据都是以位存储的，但位本身没有
    *固有的* 意义。例如，即使只有一个位，你也可以将该位的两个值解释为许多不同的方式：上下、黑白、是与否、开与关等。
- en: Extending the length of a bit sequence expands the range of its interpretations.
    For example, a `char` variable uses the American Standard Code for Information
    Interchange (ASCII) encoding standard, which defines how an eight-bit binary value
    corresponds to English letters and punctuation symbols. [Table 4-1](ch04.xhtml#ch4tab1)
    shows a small subset of the ASCII standard (for a full reference, run `man ascii`
    on the command line). There’s no special reason why the character `’X’` needs
    to correspond to 01011000, so don’t bother memorizing the table. What matters
    is that every program storing letters agrees on their bit sequence interpretation,
    which is why ASCII is defined by a standards committee.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展位序列的长度会扩大其解释范围。例如，`char` 变量使用美国信息交换标准码（ASCII）编码标准，该标准定义了如何将八位二进制值映射到英文字母和标点符号。[表
    4-1](ch04.xhtml#ch4tab1)展示了 ASCII 标准的小部分（完整参考，请在命令行运行 `man ascii`）。字符 `’X’` 必须对应于
    01011000 并没有什么特别的原因，所以不用记住表格。重要的是，每个存储字母的程序都达成了一致，确保它们对位序列的解释是一致的，这也是为什么 ASCII
    是由标准委员会定义的原因。
- en: '**Table 4-1:** A Small Snippet of the Eight-Bit ASCII Character Encoding Standard'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-1：** 八位 ASCII 字符编码标准的一个小片段'
- en: '| **Binary value** | **Character interpretation** | **Binary value** | **Character
    interpretation** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **二进制值** | **字符解释** | **二进制值** | **字符解释** |'
- en: '| 01010111 | W | 00100000 | space |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 01010111 | W | 00100000 | 空格 |'
- en: '| 01011000 | X | 00100001 | ! |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 01011000 | X | 00100001 | ! |'
- en: '| 01011001 | Y | 00100010 | " |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 01011001 | Y | 00100010 | " |'
- en: '| 01011010 | Z | 00100011 | # |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 01011010 | Z | 00100011 | # |'
- en: Any information can be encoded in binary, including rich data like graphics
    and audio. For example, suppose that an image encoding scheme defines 00, 01,
    10, and 11 to correspond to the colors white, orange, blue, and black. [Figure
    4-2](ch04.xhtml#ch4fig2) illustrates how we might use this simple two-bit encoding
    strategy to draw a crude image of a fish using only 12 bytes. In part (a), each
    cell of the image equates to one two-bit sequence. Parts (b) and (c) show the
    corresponding binary encoding as two-bit and byte sequences, respectively. Although
    this example encoding scheme is simplified for learning purposes, the general
    idea is similar to what real graphics systems use, albeit with many more bits
    for a wider range of colors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任何信息都可以以二进制编码，包括图像和音频等丰富的数据。例如，假设一种图像编码方案定义 00、01、10 和 11 分别对应白色、橙色、蓝色和黑色。[图
    4-2](ch04.xhtml#ch4fig2) 展示了我们如何使用这种简单的两位编码策略，仅用 12 字节就能画出一幅粗略的鱼的图像。在（a）部分，每个图像单元对应一个两位序列。部分（b）和（c）分别显示了对应的二进制编码，分别为两位和字节序列。尽管这个示例编码方案是为了学习目的而简化的，但其基本思路类似于实际图形系统所使用的方案，尽管实际应用中使用更多的位来表示更广泛的颜色范围。
- en: '![image](../images/04fig02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig02.jpg)'
- en: '*Figure 4-2: The (a) image representation, (b) two-bit cell representation,
    and (c) byte representation of a simple fish image.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：简单鱼图像的（a）图像表示，（b）两位单元表示，以及（c）字节表示。*'
- en: Having just introduced two encoding schemes, the same bit sequence, 01011010,
    might mean the character `’Z’` to a text editor, whereas a graphics program might
    interpret it as part of a fish’s tail fin. Which interpretation is correct depends
    on the context. Despite the underlying bits being the same, humans often find
    some interpretations much easier to comprehend than others (e.g., perceiving the
    fish as colored cells rather than a table of bytes).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚介绍了两种编码方案后，相同的比特序列 01011010 可能在文本编辑器中表示字符 `’Z’`，而在图形程序中则可能被解释为鱼的尾鳍的一部分。哪种解释正确取决于上下文。尽管底层比特相同，但人类往往会发现某些解释比其他解释更容易理解（例如，将鱼看作彩色单元格，而不是字节表）。
- en: 'The remainder of this chapter largely deals with representing and manipulating
    binary numbers, but the overall point bears repeating: all information is stored
    in a computer’s memory as 0s and 1s, and it’s up to programs or the people running
    them to interpret the meaning of those bits.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分主要处理二进制数字的表示和操作，但总体观点值得重申：所有信息都以 0 和 1 的形式存储在计算机内存中，程序或运行它们的人负责解释这些比特的含义。
- en: 4.1 Number Bases and Unsigned Integers
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 数字进制与无符号整数
- en: Having seen that binary sequences can be interpreted in all sorts of nonnumerical
    ways, let’s turn our attention to numbers. Specifically, we’ll start with *unsigned*
    numbers, which can be interpreted as zero or positive, but they can never be negative
    (they have no *sign*).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到二进制序列可以以各种非数字方式解释之后，接下来我们将关注数字。具体来说，我们从 *无符号* 数字开始，它们可以解释为零或正数，但永远不能是负数（它们没有
    *符号*）。
- en: 4.1.1 Decimal Numbers
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.1 十进制数字
- en: Rather than starting with binary, let’s first examine a number system we’re
    already comfortable using, the *decimal number system*, which uses a *base* of
    10\. *Base 10* implies two important properties for the interpretation and representation
    of decimal values.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不从二进制开始，而是先来看看我们已经习惯使用的数字系统——*十进制系统*，它使用的 *进制* 是 10。*十进制* 表示十进制值的解释和表示有两个重要的属性。
- en: First, any individual digit in a base 10 number stores one of 10 unique values
    (0–9). To store a value larger than 9, the value must *carry* to an additional
    digit to the left. For example, if one digit starts at its maximum value (9) and
    we add 1 to it, the result requires two digits (9 + 1 = 10). The same pattern
    holds for any digit, regardless of its position within a number (e.g., 50**8**0
    + **2**0 = 5**10**0).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，十进制数字中的每一位存储的是 10 个独特值中的一个（0–9）。要存储大于 9 的值，必须将值 *进位* 到左边的另一位。例如，如果某一位数字达到其最大值（9），然后我们加
    1，结果需要两位数字（9 + 1 = 10）。无论数字在数字中的位置如何（例如，50**8**0 + **2**0 = 5**10**0），相同的规律都适用。
- en: Second, the position of each digit in the number determines how important that
    digit is to the overall value of the number. Labeling the digits from *right to
    left* as *d*[0], *d*[1], *d*[2], etc., each successive digit contributes a factor
    of *ten* more than the next. For example, take the value 8425 ([Figure 4-3](ch04.xhtml#ch4fig3)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，数字中每个数字的位置决定了该数字对整体数值的重要性。将数字从*右到左*标记为*d*[0]、*d*[1]、*d*[2]，依此类推，每个后续的数字比下一个数字贡献更多的*十*倍。例如，取值8425（[图4-3](ch04.xhtml#ch4fig3)）。
- en: '![image](../images/04fig03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig03.jpg)'
- en: '*Figure 4-3: The importance of each digit in a base 10 number, using names
    that you may have given to each digit in grade school.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-3：在十进制数中，每个数字的重要性，使用你可能在小学时给每个数字命名的方式。*'
- en: For the example value 8425, the 5 in the “ones” place contributes 5 (5 × 10⁰).
    The 2 in the “tens” place contributes 20 (2 × 10¹). The 4 in the “hundreds” place
    contributes 400 (4 × 10²), and, finally, the 8 in the “thousands” place contributes
    8000 (8 × 10³). More formally, one could express 8425 as
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于示例值8425，“个位”中的5贡献5（5 × 10⁰）。“十位”中的2贡献20（2 × 10¹）。“百位”中的4贡献400（4 × 10²），最后，“千位”中的8贡献8000（8
    × 10³）。更正式地，8425可以表示为
- en: (8 × 10³) + (4 × 10²) + (2 × 10¹) + (5 × 10⁰)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: (8 × 10³) + (4 × 10²) + (2 × 10¹) + (5 × 10⁰)
- en: This pattern of increasing exponents applied to a base of 10 is the reason why
    it’s called a *base 10* number system. Assigning position numbers to digits from
    right to left starting with *d*[0] implies that each digit *d*[*i*] contributes
    10^(*i*) to the overall value. Thus, the overall value of any *N*-digit decimal
    number can be expressed as
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对10为底数的指数递增模式正是它被称为*十进制*数字系统的原因。从右到左为数字位置编号，从*d*[0]开始，意味着每个数字*d*[*i*]对整体数值贡献10^(*i*)。因此，任何*N*位的十进制数的整体值可以表示为
- en: (*d*[*N*–1] × 10^(*N*–1)) + (*d*[*N*–2] × 10^(*N*–2)) + … + (*d*[2] × 10²) +
    (*d*[1] × 10¹) + (*d*[0] × 10⁰)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: (*d*[*N*–1] × 10^(*N*–1)) + (*d*[*N*–2] × 10^(*N*–2)) + … + (*d*[2] × 10²) +
    (*d*[1] × 10¹) + (*d*[0] × 10⁰)
- en: Fortunately, as we’ll soon see, a very similar pattern applies to other number
    systems.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如我们很快会看到的，类似的模式也适用于其他数字系统。
- en: '**Note DISTINGUISHING NUMBER BASES**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意区分数字进制**'
- en: Now that we’re about to introduce a second number system, one potential problem
    is a lack of clarity regarding how to interpret a number. For example, consider
    the value 1000\. It’s not immediately obvious whether you should interpret that
    number as a decimal value (i.e., one thousand) or a binary value (i.e., eight,
    for reasons explained soon). To help clarify, the remainder of this chapter will
    explicitly attach a prefix to all nondecimal numbers. We’ll soon introduce binary,
    for which the prefix is 0b, and hexadecimal, which uses a prefix of 0x.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们即将介绍第二种数字系统，其中一个潜在问题是如何解释一个数字的不清晰性。例如，考虑值1000。很难立刻判断你应该将这个数字解释为十进制值（一千）还是二进制值（八，稍后会解释）。为了帮助澄清，本章的其余部分将明确地为所有非十进制数字附加前缀。我们很快将介绍二进制，它的前缀是0b，以及十六进制，它的前缀是0x。
- en: Therefore, if you see 1000, you should assume it’s a decimal “one thousand,”
    and if you see 0b1000, you should interpret it as a binary number, in this case
    the value “eight.”
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你看到1000，你应该假设它是十进制的“一千”，如果你看到0b1000，你应该将其解释为二进制数，在这种情况下，值为“八”。
- en: 4.1.2 Unsigned Binary Numbers
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.2 无符号二进制数
- en: While you may never have considered the specific formula describing decimal
    numbers as powers of 10, the concept of {*ones*, *tens*, *hundreds*, etc.} places
    should hopefully feel comfortable. Luckily, similar terminology applies to other
    number systems, like binary. Of course, the base is different in other number
    systems, so each digit position contributes a different amount to its numerical
    value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能从未考虑过描述十进制数作为10的幂的具体公式，但{*个位*、*十位*、*百位*等}的概念应该是熟悉的。幸运的是，类似的术语也适用于其他数字系统，比如二进制。当然，其他数字系统中的基数不同，所以每个数字位置对其数值的贡献也不同。
- en: A *binary number system* uses a base of 2 instead of decimal’s 10\. Analyzing
    it the same way that we just did for decimal reveals several parallels (with 2
    substituted for 10).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制数字系统*使用2为底数，而不是十进制的10。按我们刚才对十进制的分析方式来分析它，可以揭示几个相似之处（将2替换为10）。'
- en: First, any individual bit in a base 2 number stores one of two unique values
    (0 or 1). To store a value larger than 1, the binary encoding must *carry* to
    an additional bit to the left. For example, if one bit starts at its maximum value
    (1) and we add 1 to it, the result requires two bits (1 + 1 = 0b10). The same
    pattern holds for any bit, regardless of its position within a number (e.g., 0b100**1**00
    + 0b**1**00 = 0b10**10**00).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，二进制数字中的任何单个位存储的是两个独特值中的一个（0 或 1）。为了存储大于 1 的值，二进制编码必须*进位*到左边的一个额外位。例如，如果一个位达到最大值（1）并且我们加
    1，结果就需要两个位（1 + 1 = 0b10）。对于任何位，无论其在数字中的位置如何（例如，0b100**1**00 + 0b**1**00 = 0b10**10**00），这一模式都适用。
- en: Second, the position of each bit in the number determines how important that
    bit is to the numerical value of the number. Labeling the digits from *right to
    left* as *d*[0], *d*[1], *d*[2], etc., each successive bit contributes a factor
    of *two* more than the next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，数字中每一位的位置决定了该位对数字值的重要性。从*右到左*标记每一位为*d*[0]、*d*[1]、*d*[2]，依此类推，每个连续的位比下一个位多贡献一个*二*的倍数。
- en: 'The first point implies that counting in binary follows the same pattern as
    decimal: by simply enumerating the values and adding digits (bits). Since this
    section focuses on *unsigned* numbers (zero and positives only), it’s natural
    to start counting from zero. [Table 4-2](ch04.xhtml#ch4tab2) shows how to count
    the first few natural numbers in binary. As you can see from the table, counting
    in binary quickly increases the number of digits. Intuitively, this growth makes
    sense, since each binary digit (two possible values) represents less information
    than a decimal digit (10 possible values).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点意味着，二进制计数遵循与十进制相同的模式：通过简单地枚举值并添加数字（位）。由于本节聚焦于*无符号*数字（仅零和正数），因此从零开始计数是自然的。[表
    4-2](ch04.xhtml#ch4tab2)展示了如何用二进制计数前几个自然数。正如表格所示，二进制计数会迅速增加数字的位数。直观地看，这种增长是有意义的，因为每一位二进制数字（有两种可能的值）所表示的信息少于每一位十进制数字（有十种可能的值）。
- en: '**Table 4-2:** A Comparison of Counting in Binary versus Decimal'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-2：** 二进制与十进制计数的比较'
- en: '| **Binary value** | **Decimal value** |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **二进制值** | **十进制值** |'
- en: '| 0 | 0 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 |'
- en: '| 1 | 1 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 10 | 2 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 2 |'
- en: '| 11 | 3 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 3 |'
- en: '| 100 | 4 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 4 |'
- en: '| 101 | 5 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 101 | 5 |'
- en: '| ... | ... |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... |'
- en: 'The second point about labeling digits looks really familiar! In fact, it’s
    so similar to decimal that it leads to a nearly identical formula for interpreting
    a binary number. Simply replace the 10 at the base of each exponent with a 2:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标记数字的第二点看起来非常熟悉！实际上，它与十进制几乎相同，这导致了一个几乎相同的公式来解释二进制数字。只需将每个指数的基数 10 替换为 2：
- en: (*d*[*N*–1] × 2^(*N*–1)) + (*d*[*N*–2] × 2^(*N*–2)) + … + (*d*[2] × 2²) + (*d*[1]
    × 2¹) + (*d*[0] × 2⁰)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (*d*[*N*–1] × 2^(*N*–1)) + (*d*[*N*–2] × 2^(*N*–2)) + … + (*d*[2] × 2²) + (*d*[1]
    × 2¹) + (*d*[0] × 2⁰)
- en: 'Applying this formula yields the *unsigned* interpretation of any binary number.
    For example, take 0b1000:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这个公式可以得出任何二进制数字的*无符号*解释。例如，考虑 0b1000：
- en: (1 × 2³) + (0 × 2²) + (0 × 2¹) + (0 × 2⁰) = 8 + 0 + 0 + 0 = 8
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 2³) + (0 × 2²) + (0 × 2¹) + (0 × 2⁰) = 8 + 0 + 0 + 0 = 8
- en: 'Here’s a longer one-byte example, 0b10110100:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更长的一字节示例，0b10110100：
- en: (1 × 2⁷) + (0 × 2⁶) + (1 × 2⁵) + (1 × 2⁴) + (0 × 2³) + (1 × 2²) + (0 × 2¹) +
    (0 × 2⁰) = 128 + 0 + 32 + 16 + 0 + 4 + 0 + 0 = 180
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 2⁷) + (0 × 2⁶) + (1 × 2⁵) + (1 × 2⁴) + (0 × 2³) + (1 × 2²) + (0 × 2¹) +
    (0 × 2⁰) = 128 + 0 + 32 + 16 + 0 + 4 + 0 + 0 = 180
- en: 4.1.3 Hexadecimal
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.3 十六进制
- en: 'Thus far, we’ve examined two number systems, decimal and binary. Decimal is
    notable due to its comfort for humans, whereas binary matches the way data is
    stored in hardware. It’s important to note that they are equivalent in their expressive
    power. That is, there’s no number you can represent in one system that you can’t
    represent in the other. Given their equivalence, it may surprise you that we’re
    going to discuss one more number system: the base 16 *hexadecimal* system.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经考察了两种数字系统，十进制和二进制。十进制因其对人类的友好性而著名，而二进制则与硬件中数据存储的方式相匹配。需要注意的是，它们在表达能力上是等价的。也就是说，任何可以在一种系统中表示的数字，都可以在另一种系统中表示。鉴于它们的等价性，可能会让你感到惊讶的是，我们接下来要讨论的数字系统是：基于16的*十六进制*系统。
- en: With two perfectly good number systems, you may wonder why we need another.
    The answer is primarily convenience. As shown in [Table 4-2](ch04.xhtml#ch4tab2),
    binary bit sequences quickly grow to a large number of digits. Humans tend to
    have a tough time making sense of long sequences containing only 0’s and 1’s.
    And whereas decimal is more compact, its base of 10 is a mismatch with binary’s
    base 2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有两种完全有效的数字系统，你可能会想为什么我们还需要第三种。答案主要是便利性。正如[表4-2](ch04.xhtml#ch4tab2)所示，二进制位序列会迅速增长为大量的数字。人类往往难以理解只包含0和1的长序列。虽然十进制更紧凑，但其基数10与二进制的基数2不匹配。
- en: Decimal doesn’t easily capture the range that can be expressed using a fixed
    number of bits. For example, suppose that an old computer uses 16-bit memory addresses.
    It’s valid addresses range from 0b0000000000000000 to 0b1111111111111111\. Represented
    in decimal, the addresses range from 0 to 65535\. Clearly, the decimal representations
    are more compact than the long binary sequences, but unless you memorize their
    conversions, it’s more difficult to reason about the decimal numbers. Both problems
    only get worse on modern devices, which use 32- or 64-bit addresses!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制无法轻松地捕捉到可以通过固定数量的位表示的范围。例如，假设一台旧电脑使用16位内存地址。有效地址的范围从0b0000000000000000到0b1111111111111111。以十进制表示，地址的范围从0到65535。显然，十进制表示比长二进制序列更紧凑，但除非你记住它们的转换，否则更难以推理这些十进制数字。现代设备使用32位或64位地址时，这两个问题会变得更加严重！
- en: These long bit sequences are where hexadecimal’s base 16 shines. The large base
    allows each digit to represent enough information for hexadecimal numbers to be
    compact. Furthermore, because the base is itself a power of two (2⁴ = 16), it’s
    easy to map hexadecimal to binary, and vice versa. For the sake of completeness,
    let’s analyze hexadecimal in the same way as decimal and binary.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些长二进制序列正是十六进制基数16的优势所在。大基数使得每个数字能够表示足够的信息，从而让十六进制数字更加紧凑。此外，由于基数本身就是2的幂（2⁴ =
    16），所以十六进制和二进制之间的转换非常容易。为了完整性，我们将像分析十进制和二进制那样分析十六进制。
- en: First, any individual digit in a base 16 number stores one of 16 unique values.
    Any more than 10 values presents a new challenge for hexadecimal—traditional base
    10 digits stop at a maximum value of 9\. By convention, hexadecimal uses letters
    to represent values larger than 9, with A for 10, B for 11, up to F for 15\. Like
    the other systems, to store a value larger than 15, the number must *carry* to
    an additional digit to the left. For example, if one digit starts at its maximum
    value (F) and we add 1 to it, the result requires two digits (0xF + 0x1 = 0x10;
    note that we use 0x to indicate hexadecimal numbers).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，十六进制数字中的每个单独数字存储的是16个唯一值之一。超过10个值会给十六进制带来新的挑战——传统的十进制数字最大值为9。按照惯例，十六进制使用字母表示大于9的值，其中A代表10，B代表11，一直到F代表15。像其他系统一样，若要存储大于15的值，数字必须*进位*到左边的另一位。例如，如果一个数字达到最大值（F），并且我们加1，结果将需要两个数字（0xF
    + 0x1 = 0x10；请注意，我们使用0x来表示十六进制数字）。
- en: Second, the position of each digit in the number determines how important that
    digit is to the numerical value of the number. Labeling the digits from *right
    to left* as *d*[0], *d*[1], *d*[2], etc., each successive digit contributes a
    factor of 16 more than the next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，数字中每个数字的位置决定了它对该数字数值的重要性。将数字从*右到左*标记为*d*[0]、*d*[1]、*d*[2]，依此类推，每个连续的数字对数字的贡献是前一个数字的16倍。
- en: 'Unsurprisingly, the same trusty formula for interpreting a number applies to
    hexadecimal, with 16 as the base:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不意外，相同的解读数字的公式适用于十六进制，基数为16：
- en: (*d*[*N*–1] × 16^(*N*–1)) + (*d*[*N*–2] × 16^(*N*–2)) + … + (*d*[2] × 16²) +
    (*d*[1] × 16¹) + (*d*[0] × 16⁰)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (*d*[*N*–1] × 16^(*N*–1)) + (*d*[*N*–2] × 16^(*N*–2)) + … + (*d*[2] × 16²) +
    (*d*[1] × 16¹) + (*d*[0] × 16⁰)
- en: 'For example, to determine the decimal value of 0x23C8:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，确定0x23C8的十进制值：
- en: '![image](../images/f0196-01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0196-01.jpg)'
- en: '**Warning HEXADECIMAL MISCONCEPTION**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 十六进制误解**'
- en: You may not encounter hexadecimal numbers frequently as you’re first learning
    about systems programming. In fact, the only context where you’re likely to find
    them is in representing memory addresses. For example, if you print the address
    of a variable using the `%p` (pointer) format code for `printf`, you’ll get hexadecimal
    output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在你刚开始学习系统编程时，你可能不会频繁遇到十六进制数字。事实上，你最有可能遇到它们的唯一场景是在表示内存地址时。例如，如果你使用`printf`的`%p`（指针）格式代码打印一个变量的地址，你将得到十六进制输出。
- en: Many students often begin to equate memory addresses (e.g., C pointer variables)
    with hexadecimal. While you may get used to seeing addresses represented that
    way, keep in mind that *they are still stored using binary in the hardware*, just
    like all other data!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 许多学生常常开始将内存地址（例如 C 指针变量）与十六进制等同起来。虽然你可能习惯于看到地址以这种方式表示，但请记住，*它们仍然在硬件中以二进制形式存储*，就像所有其他数据一样！
- en: 4.1.4 Storage Limitations
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.1.4 存储限制
- en: 'Conceptually, there are infinitely many unsigned integers. In practice, a programmer
    must choose how many bits to dedicate to a variable *prior to storing it*, for
    a variety of reasons:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，无符号整数是无限的。实际上，程序员必须在*存储之前*选择为一个变量分配多少位，原因有很多：
- en: Before storing a value, a program must allocate storage space for it. In C,
    declaring a variable tells the compiler how much memory it needs based on its
    type (see “C Numeric Types” on [page 24](ch01.xhtml#lev3_2)).
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储一个值之前，程序必须为其分配存储空间。在 C 语言中，声明一个变量告诉编译器根据其类型需要多少内存（见[第 24 页](ch01.xhtml#lev3_2)的“C
    数值类型”）。
- en: Hardware storage devices have finite capacity. Whereas a system’s main memory
    is typically large and unlikely to be a limiting factor, storage locations inside
    the CPU that are used as temporary “scratch space” (i.e., registers, see “CPU
    Register” on [page 260](ch05.xhtml#lev3_51)) are more constrained. A CPU uses
    registers that are limited to its word size (typically 32 or 64 bits, depending
    on the CPU architecture).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件存储设备具有有限的容量。虽然系统的主内存通常较大，不太可能成为限制因素，但 CPU 内部用于临时“工作空间”（即寄存器，见[第 260 页](ch05.xhtml#lev3_51)的“CPU
    寄存器”）的存储位置则更为受限。CPU 使用的寄存器大小受其字长限制（通常为 32 或 64 位，具体取决于 CPU 架构）。
- en: Programs often move data from one storage device to another (e.g., between CPU
    registers and main memory). As values get larger, storage devices need more wires
    to communicate signals between them. Hence, expanding storage increases the complexity
    of the hardware and leaves less physical space for other components.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序经常将数据从一个存储设备移动到另一个存储设备（例如，从 CPU 寄存器到主内存）。随着数值的增大，存储设备需要更多的线路来在它们之间传递信号。因此，扩展存储会增加硬件的复杂性，并为其他组件腾出更少的物理空间。
- en: The number of bits used to store an integer dictates the range of its representable
    values. [Figure 4-4](ch04.xhtml#ch4fig4) depicts how we might conceptualize infinite
    and finite unsigned integer storage spaces.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储整数的位数决定了其可表示值的范围。[图 4-4](ch04.xhtml#ch4fig4) 描述了我们如何将无限和有限无符号整数存储空间进行概念化。
- en: '![image](../images/04fig04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig04.jpg)'
- en: '*Figure 4-4: Illustrations of (a) an infinite unsigned number line and (b)
    a finite unsigned number line. The latter “wraps around” at either endpoint (overflow).*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：无符号数字线（a）无限长与（b）有限长的示意图。后者在任一端点“回绕”（溢出）。*'
- en: Attempting to store a larger value to a variable than the variable’s size allows
    is known as *integer overflow*. This chapter defers the details of overflow to
    a later section (see “Integer Overflow” on [page 211](ch04.xhtml#lev1_32)). For
    now, think of it like a car’s odometer that “rolls over” back to zero if it attempts
    to increase beyond its maximum value. Similarly, subtracting one from zero yields
    the maximum value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将一个超出变量大小限制的更大值存储到变量中，称为*整数溢出*。本章将整数溢出的详细内容推迟到后面的章节（见[第 211 页](ch04.xhtml#lev1_32)的“整数溢出”）。现在，可以把它想象成汽车的里程表，如果超出最大值，它会“回绕”到零。同样，从零减去一将得到最大值。
- en: At this point, a natural question to ask about unsigned binary is “What’s the
    largest positive value that *N* bits can store?” In other words, given a sequence
    of *N* bits that are all 1, what value does the sequence represent? Reasoning
    about this question informally, the analysis in the previous section shows that
    *N* bits yield 2^(*N*) unique bit sequences. Since one of those sequences must
    represent the number 0, that leaves 2^(*N*) – 1 positive values ranging from 1
    to 2^(*N*) – 1\. Thus, the maximum value for an unsigned binary number of *N*
    bits must be 2^(*N*) – 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，关于无符号二进制的一个自然问题是：“*N* 位可以存储的最大正值是多少？”换句话说，给定一个全为 1 的 *N* 位序列，这个序列表示的值是多少？根据前一节的分析，*N*
    位可以产生 2^(*N*) 个独特的位序列。由于其中一个序列必须表示数字 0，因此剩下的 2^(*N*) – 1 个正值范围从 1 到 2^(*N*) –
    1。因此，*N* 位无符号二进制数的最大值必须是 2^(*N*) – 1。
- en: For example, 8 bits provide 2⁸ = 256 unique sequences. One of those sequences,
    0b00000000, is reserved for 0, leaving 255 sequences for storing positive values.
    Therefore, an 8-bit variable represents the positive values 1 through 255, the
    largest of which is 255.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，8个二进制位提供2⁸ = 256个独特的序列。其中一个序列0b00000000被保留用于表示0，剩下的255个序列用于存储正值。因此，一个8位变量表示从1到255的正值，其中最大的值是255。
- en: 4.2 Converting Between Bases
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 在进制之间转换
- en: You’re likely to encounter each of the three number bases we’ve introduced in
    this chapter in different contexts. In some cases, you may need to convert from
    one base to another. This section starts by showing how to convert between binary
    and hexadecimal, since those two map easily to each other. After that, we’ll explore
    conversions to and from decimal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会在本章中遇到我们介绍的三种数字进制，并在不同的上下文中使用它们。在某些情况下，你可能需要从一个进制转换到另一个进制。本节首先展示了如何在二进制和十六进制之间进行转换，因为这两者之间的映射非常简单。之后，我们将探讨如何与十进制进行转换。
- en: 4.2.1 Converting Between Binary and Hexadecimal
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1 二进制和十六进制之间的转换
- en: Because the bases for both binary and hexadecimal are powers of 2, converting
    between the two is relatively straightforward. Specifically, each hexadecimal
    digit holds one of 16 unique values, and four bits also represents 2⁴ = 16 unique
    values, making their expressive power equivalent. [Table 4-3](ch04.xhtml#ch4tab3)
    enumerates the one-to-one mapping between any sequence of four bits and any single
    hexadecimal digit.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制和十六进制的基数都是2的幂，所以它们之间的转换相对简单。具体而言，每个十六进制数字表示16个独特的值，而四个二进制位也表示2⁴ = 16个独特的值，使得它们的表达能力是等价的。[表4-3](ch04.xhtml#ch4tab3)列出了任何四个二进制位序列与单个十六进制数字之间的一一映射关系。
- en: '**Table 4-3:** The Correspondence Between All Four-Bit Sequences and One-Digit
    Hexadecimal Numbers'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-3：** 所有四位二进制序列与一位十六进制数字的对应关系'
- en: '| **Binary** | **Hexadecimal** | **Binary** | **Hexadecimal** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十六进制** | **二进制** | **十六进制** |'
- en: '| 0000 | 0 | 1000 | 8 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 | 1000 | 8 |'
- en: '| 0001 | 1 | 1001 | 9 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 | 1001 | 9 |'
- en: '| 0010 | 2 | 1010 | A |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 | 1010 | A |'
- en: '| 0011 | 3 | 1011 | B |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 | 1011 | B |'
- en: '| 0100 | 4 | 1100 | C |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 | 1100 | C |'
- en: '| 0101 | 5 | 1101 | D |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 | 1101 | D |'
- en: '| 0110 | 6 | 1110 | E |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 | 1110 | E |'
- en: '| 0111 | 7 | 1111 | F |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 | 1111 | F |'
- en: Note that the content of [Table 4-3](ch04.xhtml#ch4tab3) is equivalent to simply
    counting from 0 to 15 in both number systems, so there’s no need to memorize it.
    Armed with this mapping, you can convert any number of consecutive bits or hex
    digits in either direction.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[表4-3](ch04.xhtml#ch4tab3)中的内容等同于在这两种数字系统中从0到15的简单计数，因此无需记忆它。有了这个映射，你可以在任意方向上转换连续的位或十六进制数字。
- en: 'To convert 0xB491 to binary, simply substitute the corresponding binary value
    for each hexadecimal digit:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要将0xB491转换为二进制，只需为每个十六进制数字替换相应的二进制值：
- en: '[PRE0]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To convert 0b1111011001 to hexadecimal, first divide up the bits into chunks
    of four, from *right to left*. If the leftmost chunk doesn’t have four bits, you
    can pad with leading zeros. Then, substitute the corresponding hexadecimal values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要将0b1111011001转换为十六进制，首先将位分成四位一组，从*右到左*。如果最左边的组不足四位，可以用前导零进行填充。然后，替换成相应的十六进制值：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 4.2.2 Converting to Decimal
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2 转换为十进制
- en: 'Fortunately, converting values to decimal is what we’ve been doing throughout
    previous sections of this chapter. Given a number in *any* base *B*, labeling
    the digits from *right to left* as *d*[0], *d*[1], *d*[2], etc. enables a general
    formula for converting values to decimal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，将值转换为十进制是我们在本章之前的各个部分中已经做过的事情。给定一个*任意*进制*B*的数字，将数字从*右到左*标记为*d*[0]、*d*[1]、*d*[2]，等等，可以得出一个通用的十进制转换公式：
- en: (*d*[*N*–1] × B^(*N*–1)) + (*d*[*N*–2] × B^(*N*–2)) + … + (*d*[2] × *B*²) +
    (*d*[1] × *B*¹) + (*d*[0] × *B*⁰)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (*d*[*N*–1] × B^(*N*–1)) + (*d*[*N*–2] × B^(*N*–2)) + … + (*d*[2] × *B*²) +
    (*d*[1] × *B*¹) + (*d*[0] × *B*⁰)
- en: 4.2.3 Converting from Decimal
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.3 从十进制转换
- en: 'Converting from decimal to other systems requires a little more work. Informally,
    the goal is to do the reverse of the previous formula: determine the value of
    each digit such that, based on the position of the digit, adding each term results
    in the source decimal number. It may help to think about each digit in the target
    base system in the same way that we described the places (e.g., the “ones” place,
    the “tens” place, etc.) for decimal. For example, consider converting from decimal
    to hexadecimal. Each digit of a hexadecimal number corresponds to an increasingly
    large power of 16, and [Table 4-4](ch04.xhtml#ch4tab4) lists the first few powers.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从十进制转换到其他进制需要做些额外的工作。非正式地说，目标是反转之前的公式：确定每一位的值，使得根据数字的位置，每个项的相加结果是原始的十进制数值。可以把目标进制系统中的每一位想象成我们描述十进制时所说的位置（例如“个位”，“十位”等）。例如，考虑从十进制转换到十六进制。十六进制数的每一位对应着16的一个逐渐增大的幂，[表4-4](ch04.xhtml#ch4tab4)列出了前几个幂。
- en: '**Table 4-4:** Powers of 16'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-4：** 16的幂'
- en: '| **16**⁴ | **16**³ | **16**² | **16**¹ | **16**⁰ |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **16**⁴ | **16**³ | **16**² | **16**¹ | **16**⁰ |'
- en: '| 65536 | 4096 | 256 | 16 | 1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 65536 | 4096 | 256 | 16 | 1 |'
- en: 'For example, to convert 9742 to hexadecimal, consider:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑将9742转换为十六进制：
- en: How many multiples of 65536 fit into 9742? (In other words, what is the value
    of the “65536s” place?)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 65536的倍数能装进9742多少次？（换句话说，“65536”的位置值是多少？）
- en: 'The resulting hexadecimal value doesn’t need any multiples of 65536, since
    the value (9742) is smaller than 65536, so *d*[4] should be set to 0\. Note that
    by the same logic, all higher-numbered digits will also be 0 because each digit
    would contribute values even larger than 65536\. Thus far, the result contains
    only:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果的十六进制值不需要任何65536的倍数，因为该值（9742）小于65536，所以*d*[4]应设为0。注意，通过同样的逻辑，所有更高编号的数字也将是0，因为每个数字都会贡献更大的值，超过65536。到目前为止，结果只有：
- en: '| 0 |  |  |  |  |'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 |  |  |  |  |'
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
- en: How many multiples of 4096 fit into 9742? (In other words, what is the value
    of the “4096s” place?)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4096的倍数能装进9742多少次？（换句话说，“4096”的位置值是多少？）
- en: 4096 fits into 9742 twice (2 × 4096 = 8192), so the value of *d*[3] should be
    2\. Thus, *d*[3] will contribute 8192 to the overall value, so the result must
    still account for 9742 − 8192 = 1550.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4096可以装进9742两次（2 × 4096 = 8192），所以*d*[3]的值应为2。因此，*d*[3]将为整体值贡献8192，所以结果仍需考虑9742
    − 8192 = 1550。
- en: '| 0 | 2 |  |  |  |'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 2 |  |  |  |'
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
- en: How many multiples of 256 fit into 1550? (In other words, what is the value
    of the “256s” place?)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 256的倍数能装进1550多少次？（换句话说，“256”的位置值是多少？）
- en: 256 fits into 1550 six times (6 × 256 = 1536), so the value of *d*[2] should
    be 6, leaving 1550 − 1536 = 14.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 256可以装进1550六次（6 × 256 = 1536），所以*d*[2]的值应为6，剩余1550 − 1536 = 14。
- en: '| 0 | 2 | 6 |  |  |'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 2 | 6 |  |  |'
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
- en: How many multiples of 16 fit into 14? (In other words, what is the value of
    the “sixteens” place?)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16的倍数能装进14多少次？（换句话说，“十六”的位置值是多少？）
- en: None, so *d*[1] must be 0.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有，所以*d*[1]必须为0。
- en: '| 0 | 2 | 6 | 0 |  |'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 2 | 6 | 0 |  |'
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
- en: Finally, how many multiples of 1 fit into 14? (In other words, what is the value
    of the “ones” place?)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，1的倍数能装进14多少次？（换句话说，“个位”的位置值是多少？）
- en: The answer is 14, of course, which hexadecimal represents with the digit E.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案当然是14，十六进制表示为数字E。
- en: '| 0 | 2 | 6 | 0 | E |'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 0 | 2 | 6 | 0 | E |'
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
- en: Thus, decimal 9742 corresponds to 0x260E.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制的9742对应于0x260E。
- en: 'Decimal to Binary: Powers of Two'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 十进制到二进制：2的幂
- en: The same procedure works for binary, as well (or any other number system), provided
    that you use powers of the appropriate base. [Table 4-5](ch04.xhtml#ch4tab5) lists
    the first few powers of two, which will help to convert the example decimal value
    422 to binary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的程序适用于二进制（或任何其他数字系统），前提是你使用适当基数的幂。[表4-5](ch04.xhtml#ch4tab5)列出了前几个2的幂，这将有助于将示例十进制值422转换为二进制。
- en: '**Table 4-5:** Powers of Two'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-5：** 2的幂'
- en: '| **2**⁸ | **2**⁷ | **2**⁶ | **2**⁵ | **2**⁴ | **2**³ | **2**² | **2**¹ | **2**⁰
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **2**⁸ | **2**⁷ | **2**⁶ | **2**⁵ | **2**⁴ | **2**³ | **2**² | **2**¹ | **2**⁰
    |'
- en: '| 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: 'Since an individual bit is only allowed to store a 0 or 1, the question is
    no longer “How many multiples of each power fit within a value?” when converting
    to binary. Instead, ask a simpler question: “Does the next power of two fit?”
    For example, in converting 422:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个二进制位只允许存储0或1，转换为二进制时，不再是“每个幂的倍数能适配多少值？”的问题。相反，应该问一个更简单的问题：“下一个二的幂适配吗？”例如，在转换422时：
- en: 256 fits into 422, so *d*[8] should be a 1\. That leaves 422 − 256 = 166.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 256可以整除422，所以*d*[8]应该是1。这剩下422 − 256 = 166。
- en: 128 fits into 166, so *d*[7] should be a 1\. That leaves 166 − 128 = 38.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 128可以整除166，所以*d*[7]应该是1。这剩下166 − 128 = 38。
- en: 64 does not fit into 38, so *d*[6] should be a 0.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64不能整除38，所以*d*[6]应该是0。
- en: 32 fits into 38, so *d*[5] should be a 1\. That leaves 38 − 32 = 6.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32可以整除38，所以*d*[5]应该是1。这剩下38 − 32 = 6。
- en: 16 does not fit into 6, so *d*[4] should be a 0.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16不能整除6，所以*d*[4]应该是0。
- en: 8 does not fit into 6, so *d*[3] should be a 0.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8不能整除6，所以*d*[3]应该是0。
- en: 4 fits into 6, so *d*[2] should be a 1\. That leaves 6 − 4 = 2.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4可以整除6，所以*d*[2]应该是1。这剩下6 − 4 = 2。
- en: 2 fits into 2, so *d*[1] should be a 1\. That leaves 2 − 2 = 0.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2可以整除2，所以*d*[1]应该是1。这剩下2 − 2 = 0。
- en: '(Note: upon reaching 0, all remaining digits will always be 0.)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （注意：当结果为0时，所有剩余位数将始终是0。）
- en: 1 does not fit into 0, so *d*[0] should be a 0.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1不能整除0，所以*d*[0]应该是0。
- en: Thus, decimal 422 corresponds to 0b110100110.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，十进制的422对应二进制的0b110100110。
- en: 'Decimal to Binary: Repeated Division'
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 十进制到二进制：重复除法
- en: The method we just described generally works well for students who are familiar
    with the relevant powers of two (e.g., for 422, the converter must recognize that
    it should start at *d*[8] because 2⁹ = 512 is too large).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的方法通常适用于熟悉相关二的幂的学生（例如，对于422，转换器必须知道从*d*[8]开始，因为2⁹ = 512太大）。
- en: An alternative method doesn’t require knowing powers of two. Instead, this method
    builds a binary result by checking the parity (even or odd) status of a decimal
    number and repeatedly dividing it by two (rounding halves down) to determine each
    successive bit. Note that it builds the resulting bit sequence from *right to
    left*. If the decimal value is even, the next bit should be a zero; if it’s odd,
    the next bit should be a one. When the division reaches zero, the conversion is
    complete.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代方法不需要知道二的幂。相反，这种方法通过检查十进制数的奇偶性（偶数或奇数），并通过重复除以二（向下舍入）的方式来确定每一位的值，从而构建二进制结果。请注意，它是从*右到左*构建结果的位序列。如果十进制值是偶数，下一位应该是零；如果是奇数，下一位应该是1。当除法结果为零时，转换完成。
- en: 'For example, when converting 422:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在转换422时：
- en: 422 is even, so *d*[0] should be a 0\. (This is the rightmost bit.)
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 422是偶数，所以*d*[0]应该是0。（这是最右边的位。）
- en: 422/2 = 211, which is odd, so *d*[1] should be a 1.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 422/2 = 211，这是奇数，所以*d*[1]应该是1。
- en: 211/2 = 105, which is odd, so *d*[2] should be a 1.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 211/2 = 105，这是奇数，所以*d*[2]应该是1。
- en: 105/2 = 52, which is even, so *d*[3] should be a 0.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 105/2 = 52，这是偶数，所以*d*[3]应该是0。
- en: 52/2 = 26, which is even, so *d*[4] should be a 0.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 52/2 = 26，这是偶数，所以*d*[4]应该是0。
- en: 26/2 = 13, which is odd, so *d*[5] should be a 1.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 26/2 = 13，这是奇数，所以*d*[5]应该是1。
- en: 13/2 = 6, which is even, so *d*[6] should be a 0.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 13/2 = 6，这是偶数，所以*d*[6]应该是0。
- en: 6/2 = 3, which is odd, so *d*[7] should be a 1.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6/2 = 3，这是奇数，所以*d*[7]应该是1。
- en: 3/2 = 1, which is odd, so *d*[8] should be a 1.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3/2 = 1，这是奇数，所以*d*[8]应该是1。
- en: 1/2 = 0, so any digit numbered nine or above will be 0, and the algorithm terminates.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1/2 = 0，所以任何编号为九或以上的数字将是0，算法结束。
- en: 'As expected, this method produces the same binary sequence: 0b110100110.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这种方法生成相同的二进制序列：0b110100110。
- en: 4.3 Signed Binary Integers
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 带符号的二进制整数
- en: So far, we’ve limited the discussion of binary numbers to *unsigned* (strictly
    non-negative) integers. This section presents an alternative interpretation of
    binary that incorporates negative numbers. Given that a variable has finite storage
    space, a signed binary encoding must distinguish between negative values, zero,
    and positive values. Manipulating signed numbers additionally requires a procedure
    for negating a number.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的二进制数仅限于*无符号*（严格非负）整数。本节介绍了一种二进制的替代解释，涵盖了负数。鉴于变量具有有限的存储空间，带符号的二进制编码必须区分负值、零值和正值。操作带符号的数字还需要一个取反的过程。
- en: A signed binary encoding must divide bit sequences between negative and non-negative
    values. In practice, systems designers build *general-purpose* systems, so a 50%
    / 50% split is a good middle-of-the-road choice. Therefore, the signed number
    encodings that this chapter presents represent an equal number of negative and
    non-negative values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号的二进制编码必须在负值和非负值之间划分比特序列。在实践中，系统设计师通常构建*通用*系统，因此50% / 50%的划分是一个比较折中的选择。因此，本章介绍的有符号数字编码代表了相等数量的负值和非负值。
- en: '**Note NON-NEGATIVE VERSUS POSITIVE**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 非负数与正数的区别**'
- en: Note that there’s a subtle but important difference between *non-negative* and
    *positive*. The set of strictly positive values excludes zero, whereas the non-negative
    set includes zero. Even after dividing the available bit sequences 50% / 50% between
    negative and non-negative values, one of the non-negative values must still be
    reserved for zero. Thus, with a fixed number of bits, a number system may end
    up representing more negative values than positive values (e.g., in the two’s
    complement system).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*非负数*和*正数*之间有一个微妙但重要的区别。严格的正数集合排除了零，而非负数集合包括零。即使在负值和非负值之间将可用的比特序列划分为50%
    / 50%，仍然必须为零保留一个非负值。因此，在固定比特数的情况下，数字系统可能会表示更多的负值而不是正值（例如，在二补码系统中）。
- en: Signed number encodings use one bit to distinguish between the sets of *negative*
    numbers and *non-negative* numbers. By convention, the leftmost bit indicates
    whether a number is negative (1) or non-negative (0). This leftmost bit is known
    as the *high-order bit* or the *most significant bit*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号数字编码使用一个比特来区分*负数*和*非负数*。按照约定，最左边的比特表示数字是负数（1）还是非负数（0）。这个最左边的比特被称为*高位比特*或*最重要的比特*。
- en: This chapter presents two potential signed binary encodings—*signed magnitude*
    and *two’s complement*. Even though only one of these encodings (two’s complement)
    is still used in practice, comparing them will help to illustrate their important
    characteristics.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种可能的有符号二进制编码——*符号大小*和*二补码*。尽管在实践中只有其中一种编码（二补码）仍然在使用，但比较它们有助于说明它们的重要特性。
- en: 4.3.1 Signed Magnitude
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1 符号大小
- en: 'The *signed magnitude* representation treats the high-order bit exclusively
    as a sign bit. That is, whether the high-order bit is a 0 or a 1 does not affect
    the absolute value of the number, it determines *only* whether the value is positive
    (high-order bit 0) or negative (high-order bit 1). Compared to two’s complement,
    signed magnitude makes the decimal conversion and negation procedures relatively
    straightforward:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号大小*表示法将高位比特专门作为符号位。这意味着，无论高位比特是0还是1，都不会影响数字的绝对值，它*仅仅*决定该值是正数（高位比特为0）还是负数（高位比特为1）。与二补码相比，符号大小使得十进制转换和取反过程相对直接：'
- en: 'To compute a decimal value for an *N*-bit signed magnitude sequence, compute
    the value of digits *d*[0] through *d*[*N–*2] using the familiar unsigned method
    from “Unsigned Binary Numbers” on [page 193](ch04.xhtml#lev2_62). Then, check
    the most significant bit, *d*[*N–*1]: if it’s 1, the value is negative; otherwise
    it isn’t.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要计算一个*N*位符号大小序列的十进制值，使用“无符号二进制数”中提到的熟悉方法计算*数字*d*[0]到*d*[*N–*2]的值（见[第193页](ch04.xhtml#lev2_62)）。然后，检查最重要的比特*d*[*N–*1]：如果它是1，值为负；否则为正。
- en: To negate a value, simply flip the most significant bit to change its sign.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要取反一个值，只需翻转最重要的比特位来改变其符号。
- en: '**Warning NEGATION MISCONCEPTION**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 取反误解**'
- en: Signed magnitude is presented purely for pedagogical purposes. Although it was
    used by some machines in the past (e.g., IBM’s 7090 in the 1960s), no modern systems
    use signed magnitude to represent integers (although a similar mechanism *is*
    part of the standard for storing floating-point values).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 符号大小表示法纯粹是为了教学目的而介绍的。虽然过去一些计算机使用过符号大小表示法（例如，1960年代的IBM 7090），但现代系统中没有使用符号大小表示法来表示整数（尽管一个类似的机制*确实*是存储浮点数的标准的一部分）。
- en: Unless you’re explicitly asked to consider signed magnitude, you should *not*
    assume that flipping the first bit of a binary number will negate that number’s
    value on a modern system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 除非明确要求考虑符号大小，否则*不*应假设翻转二进制数字的第一个比特会使该数字在现代系统中变为其相反数。
- en: '[Figure 4-5](ch04.xhtml#ch4fig5) shows how four-bit signed magnitude sequences
    correspond to decimal values. At first glance, signed magnitude might seem attractive
    due to its simplicity. Unfortunately, it suffers from two major drawbacks that
    make it unappealing. The first is that it presents *two* representations of zero.
    For example, with four bits, signed magnitude represents both *zero* (0b0000)
    and *negative zero* (0b1000). Consequently, it poses a challenge to hardware designers
    because the hardware will need to account for two possible binary sequences that
    are numerically equal despite having different bit values. The hardware designer’s
    job is much easier with just one way of representing such an important number.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-5](ch04.xhtml#ch4fig5)展示了四位有符号数序列如何对应到十进制值。乍一看，由于其简单性，有符号数可能看起来很有吸引力。不幸的是，它有两个主要缺点，使得它不太受欢迎。第一个缺点是它存在*两个*零的表示。例如，在四位数中，有符号数同时表示*零*（0b0000）和*负零*（0b1000）。因此，这对硬件设计师来说是一个挑战，因为硬件需要处理两个在数值上相等但位值不同的二进制序列。硬件设计师只需要一种表示这样一个重要数字，工作会容易得多。'
- en: '![image](../images/04fig05.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig05.jpg)'
- en: '*Figure 4-5: A logical layout of signed magnitude values for bit sequences
    of length four*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-5：四位二进制序列的有符号数值逻辑布局*'
- en: The other drawback of signed magnitude is that it exhibits an inconvenient discontinuity
    between negative values and zero. While we’ll cover overflow in more detail in
    “Integer Overflow” on [page 211](ch04.xhtml#lev1_32), adding 1 to the four-bit
    sequence 0b1111 “rolls over” back to 0b0000\. With signed magnitude, this effect
    means 0b1111 (–7) + 1 might be mistaken for 0 rather than the expected –6\. This
    problem is solvable, but the solution again complicates the design of the hardware,
    essentially turning any transition between negative and non-negative integers
    into a special case that requires extra care.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号数的另一个缺点是，它在负数和零之间存在不便的间断性。虽然我们将在“整数溢出”章节中详细讨论溢出问题（参见[第211页](ch04.xhtml#lev1_32)），但将1加到四位序列0b1111会“回绕”到0b0000。对于有符号数而言，这种效应意味着0b1111（–7）+1可能会被误认为是0，而不是预期的–6。这个问题是可以解决的，但解决方案又使得硬件设计更加复杂，本质上将负整数和非负整数之间的任何过渡变成了一个需要特别小心的特殊情况。
- en: For these reasons, signed magnitude has largely disappeared in practice, and
    two’s complement reigns supreme.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，有符号数在实际应用中几乎已经消失，而二进制补码则占据了主导地位。
- en: 4.3.2 Two’s Complement
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2 二进制补码
- en: '*Two’s complement* encoding solves signed magnitude’s problems in an elegant
    way. Like signed magnitude, the high-order bit of a two’s complement number indicates
    whether or not the value should be interpreted as negative. In contrast though,
    the high-order bit also affects the value of the number. So, how can it do both?'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制补码*编码优雅地解决了有符号数表示法的问题。像有符号数一样，二进制补码的高位表示值是否应该被解释为负数。不过，与有符号数不同的是，高位也会影响数值。因此，它是如何同时做到这两点的呢？'
- en: 'Computing a decimal value for an *N*-bit two’s complement number is similar
    to the familiar unsigned method, except the high-order bit’s contribution to the
    overall value is negated. That is, for an *N*-bit two’s complement sequence, instead
    of the first bit contributing *d*[*N–*1] × 2^(*N–*1) to the sum, it contributes
    *– d*[*N–*1] × 2^(*N–*1) (note the negative sign). Therefore, if the most significant
    bit is a 1, the overall value will be negative, since that first bit contributes
    the largest absolute value to the sum. Otherwise, the first bit contributes nothing
    to the sum, and the result is non-negative. Following is the full formula:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个*N*位二进制补码的十进制值与熟悉的无符号方法类似，区别在于高位的贡献被抵消了。也就是说，对于一个*N*位二进制补码序列，第一位的贡献不是*d*[*N–*1]
    × 2^(*N–*1)加到总和中，而是贡献*– d*[*N–*1] × 2^(*N–*1)（注意负号）。因此，如果最高位是1，那么总值将是负数，因为该第一位对总和的贡献最大。否则，第一位对总和没有任何贡献，结果就是非负数。以下是完整的公式：
- en: –(*d*[*N*–1] × 2^(*N*–1)) + (*d*[*N*–2] × 2^(*N*–2)) + … + (*d*[2] × 2²) + (*d*[1]
    × 2¹) + (*d*[0] × 2⁰)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: –(*d*[*N*–1] × 2^(*N*–1)) + (*d*[*N*–2] × 2^(*N*–2)) + … + (*d*[2] × 2²) + (*d*[1]
    × 2¹) + (*d*[0] × 2⁰)
- en: (note the leading negative sign for just the first term!).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: （注意仅第一项的前导负号！）
- en: '[Figure 4-6](ch04.xhtml#ch4fig6) illustrates the layout of four-bit sequences
    in two’s complement. This definition encodes just one representation of zero—a
    sequence of bits that are all 0’s. With only a single *zero* sequence, two’s complement
    represents one more negative value than positive. Using four-bit sequences as
    an example, two’s complement represents a minimum value of 0b1000 (–8), but a
    maximum value of only 0b0111 (7). Fortunately, this quirk doesn’t hinder hardware
    design and rarely causes problems for applications.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-6](ch04.xhtml#ch4fig6)展示了四位序列在二进制补码中的布局。该定义仅编码了零的一个表示——一个全为 0 的位序列。在只有单一
    *零* 序列的情况下，二进制补码表示的负值比正值多一个。以四位序列为例，二进制补码表示的最小值为 0b1000（-8），但最大值仅为 0b0111（7）。幸运的是，这一怪异不会妨碍硬件设计，也很少给应用程序带来问题。'
- en: '![image](../images/04fig06.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig06.jpg)'
- en: '*Figure 4-6: A logical layout of two’s complement values for bit sequences
    of length four*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-6：四位长二进制补码值的逻辑布局*'
- en: Compared to signed magnitude, two’s complement also simplifies the transition
    between negative numbers and zero. Regardless of the number of bits used to store
    it, a two’s complement number consisting of all ones will always hold the value
    –1\. Adding 1 to a bit sequence of all 1s “rolls over” to zero, which makes two’s
    complement convenient, since –1 + 1 *should* produce zero.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与符号大小（signed magnitude）相比，二进制补码还简化了负数与零之间的转换。无论用于存储它的位数是多少，所有为 1 的二进制补码数值总是表示
    -1。将 1 加到所有为 1 的位序列上会“溢出”到零，这使得二进制补码非常方便，因为 -1 + 1 *应该*产生零。
- en: Negation
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 取反
- en: Negating a two’s complement number is slightly trickier than negating a signed
    magnitude value. To negate an *N*-bit value, determine it’s *complement* with
    respect to 2^(*N*) (this is where the encoding’s name comes from). In other words,
    to negate an *N*-bit value *X*, find a bit sequence *Y* (*X*’s complement) such
    that *X* + *Y* = 2^(*N*).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对二进制补码数值取反比对符号大小数值取反稍微复杂一些。要取反一个 *N* 位的数值，首先确定它相对于 2^(*N*) 的*补码*（这也是该编码名称的由来）。换句话说，要取反一个
    *N* 位数值 *X*，找到一个位序列 *Y*（*X* 的补码），使得 *X* + *Y* = 2^(*N*)。
- en: 'Fortunately, there’s a quick shortcut for negating a two’s complement number
    in practice: flip all the bits and add one. For example, to negate the eight-bit
    value 13, first determine the binary value of 13 (see “Converting from Decimal”
    on [page 199](ch04.xhtml#lev2_67)). Since 13 is the sum of 8, 4, and 1, set the
    bits in positions 3, 2, and 0:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，实际应用中有一个快速的二进制补码取反捷径：翻转所有的位并加 1。例如，要取反八位数值 13，首先确定 13 的二进制值（请参见“从十进制转换”[第
    199 页](ch04.xhtml#lev2_67)）。由于 13 是 8、4 和 1 的和，所以在第 3 位、第 2 位和第 0 位设置 1：
- en: '[PRE2]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, “flip the bits” (change all zeros to ones, and vice versa):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，“翻转位”（将所有 0 改为 1，反之亦然）：
- en: '[PRE3]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, adding one yields 0b11110011\. Sure enough, applying the formula for
    interpreting a two’s complement bit sequence shows that the value is –13:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，加上 1 得到 0b11110011。果然，应用二进制补码位序列解释公式可以显示该数值是 -13：
- en: –(1 × 2⁷) + (1 × 2⁶) + (1 × 2⁵) + (1 × 2⁴) + (0 × 2³) + (0 × 2²) + (1 × 2¹)
    + (1 × 2⁰) = –128 + 64 + 32 + 16 + 0 + 0 + 2 + 1 = –13
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: –(1 × 2⁷) + (1 × 2⁶) + (1 × 2⁵) + (1 × 2⁴) + (0 × 2³) + (0 × 2²) + (1 × 2¹)
    + (1 × 2⁰) = –128 + 64 + 32 + 16 + 0 + 0 + 2 + 1 = –13
- en: 'If you’re curious as to why this seemingly magical shortcut works, consider
    the eight-bit negation of 13 more formally. To find 13’s complement, solve 0b00001101
    (13) + *Y* = 0b100000000 (2⁸, which requires an extra bit to represent). The equation
    can be rearranged as *Y* = 0b100000000 – 0b00001101\. This is clearly now a subtraction
    problem:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个看似神奇的捷径为何有效感到好奇，可以更正式地考虑 13 的八位取反。为了找到 13 的补码，求解 0b00001101（13）+ *Y* =
    0b100000000（2⁸，表示需要额外的位）。这个方程可以重排为 *Y* = 0b100000000 - 0b00001101。现在，这显然是一个减法问题：
- en: '[PRE4]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Even though such a subtraction might seem daunting, we can express it in a
    way that’s easier to compute as (0b011111111 + 1) – 0b00001101\. Note that this
    change simply expresses 2⁸ (256) as (255 + 1). After that change, the arithmetic
    looks like:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这种减法看起来令人望而生畏，我们也可以以一种更容易计算的方式表达它，即 (0b011111111 + 1) – 0b00001101。请注意，这种变化只是将
    2⁸（256）表示为 (255 + 1)。做出此变化后，算式变成：
- en: '[PRE5]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As it turns out, for *any* bit value *b*, 1 *– b* is equivalent to “flipping”
    that bit. Thus, the entire subtraction in the preceding example can be reduced
    to just flipping all the bits of the lower number. All that’s left is to add the
    remaining +1 from expressing 256 as 255 + 1\. Putting it all together, we can
    simply flip a value’s bits and add one to compute its complement!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，对于 *任何* 位值 *b*，1 *– b* 等同于“翻转”该位。因此，前面示例中的整个减法可以简化为只翻转较小数字的所有位。剩下的就是加上表示
    256 为 255 + 1 的剩余 +1。将所有内容结合起来，我们可以简单地翻转一个值的位并加一来计算其补码！
- en: '**Warning C PROGRAMMING WITH SIGNED VERSUS UNSIGNED INTEGERS**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 C 程序设计中的带符号与不带符号整数**'
- en: In addition to allocating space, declaring variables in C also tells the compiler
    how you’d like the variable to be interpreted. When you declare an `int`, the
    compiler interprets the variable as a signed two’s complement integer. To allocate
    an unsigned value, declare an `unsigned int`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分配空间，在 C 语言中声明变量还告诉编译器你希望如何解释该变量。当你声明一个 `int` 时，编译器将其解释为带符号的二进制补码整数。要分配一个无符号值，可以声明一个
    `unsigned int`。
- en: 'The distinction is also relevant to C in other places, like the `printf` function.
    As this chapter has been stressing throughout, a bit sequence can be interpreted
    in different ways! With `printf`, the interpretation depends on the formatting
    placeholder you use. For example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别在 C 语言的其他地方也很重要，比如 `printf` 函数。正如本章一直强调的，位序列可以以不同的方式进行解释！在 `printf` 中，解释方式取决于你使用的格式占位符。例如：
- en: '#include <stdio.h>'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: int main() {
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: int main() {
- en: int example = -100;
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: int example = -100;
- en: /* Print example int using both signed and unsigned placeholders. */
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: /* 使用带符号和无符号占位符打印 example 整数。 */
- en: printf("%d  %u\n", example, example);
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: printf("%d  %u\n", example, example);
- en: return 0;
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: return 0;
- en: '}'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Even though this code passes `printf` the same variable (`example`) twice, it
    prints `-100 4294967196`. Be careful to interpret your values correctly!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码将相同的变量（`example`）传递给 `printf` 两次，但它打印出的是 `-100 4294967196`。小心正确解释你的值！
- en: Sign Extension
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 符号扩展
- en: Occasionally, you may find yourself wanting to perform an arithmetic operation
    on two numbers that are stored using different numbers of bits. For example, in
    C you may want to add a 32-bit `int` and a 16-bit `short`. In such cases, the
    smaller number needs to be *sign extended*, which is a fancy way of saying that
    its most significant bit gets repeated as many times as necessary to extend the
    length of the bit sequence to the target length. Though the compiler will take
    care of wrangling the bits for you in C, it’s still helpful to understand how
    the process works.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你可能会遇到需要对两个使用不同位数存储的数字进行算术运算的情况。例如，在 C 语言中，你可能想将一个 32 位的 `int` 与一个 16 位的
    `short` 相加。在这种情况下，较小的数字需要进行 *符号扩展*，这是一种 fancy 的说法，意思是将其最高有效位重复足够多次，以将位序列的长度扩展到目标长度。尽管编译器会为你处理位操作，但了解这个过程是如何运作的仍然很有帮助。
- en: 'For example, to extend the four-bit sequence 0b0110 (6) to an eight-bit sequence,
    take the high-order bit (0) and prepend it four times to produce the extended
    value: 0b00000110 (still 6). Extending 0b1011 (–5) to an eight-bit sequence similarly
    takes the high-order bit (this time, 1) and prepends it four times to the resulting
    extended value: 0b11111011 (still –5). To verify the correctness, consider how
    the value changes after adding each new bit:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将四位序列 0b0110（6）扩展为八位序列，只需取高位（0），并将其前置四次，得到扩展值：0b00000110（仍然是 6）。同样，将 0b1011（–5）扩展为八位序列时，取高位（这次是
    1），并将其前置四次，得到扩展值：0b11111011（仍然是 –5）。为了验证其正确性，考虑每次添加新位后值的变化：
- en: '[PRE6]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As evidenced by the examples, numbers that are non-negative (high-order bit
    of zero) remain non-negative after adding zeros to the front. Likewise, negatives
    (high-order bit of one) remain negative after prepending ones to extended values.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如例子所示，非负数（高位为零）在前面添加零后仍然是非负的。同样，负数（高位为一）在前面添加一后仍然是负数。
- en: '**Note UNSIGNED ZERO EXTENSION**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意 无符号零扩展**'
- en: For an unsigned value (e.g., a C variable explicitly declared with an `unsigned`
    qualifier), extending it to a longer bit sequence instead requires *zero extension*,
    since the `unsigned` qualifier prevents the value from ever being interpreted
    as negative. Zero extension simply prepends zeros to the high-order bits of the
    extended bit sequence. For example, 0b1110 (14 when interpreted as unsigned!)
    extends to 0b00001110 despite the original leading 1.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无符号值（例如，一个显式声明为`unsigned`的C语言变量），扩展它到更长的位序列需要使用*零扩展*，因为`unsigned`修饰符防止该值被解释为负数。零扩展只是将零添加到扩展位序列的高位部分。例如，0b1110（在无符号情况下是14！）扩展为0b00001110，尽管原始的高位是1。
- en: 4.4 Binary Integer Arithmetic
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4 二进制整数算术
- en: Earlier, we presented binary representations for unsigned (“Unsigned Binary
    Numbers” on [page 193](ch04.xhtml#lev2_62)) and signed (“Unsigned Binary Numbers”
    on [page 193](ch04.xhtml#lev2_62)) integers; now we’re ready to use them in arithmetic
    operations. Fortunately, due to their encoding, it *does not matter* to the arithmetic
    procedures whether we choose to interpret the operands or result as signed or
    unsigned. This observation is great news for hardware designers because it allows
    them to build one set of hardware components that can be shared for both unsigned
    and signed operations. “Circuits” on [page 246](ch05.xhtml#lev1_41) describes
    the circuitry for performing arithmetic in more detail.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面我们介绍了无符号（“无符号二进制数”在[第193页](ch04.xhtml#lev2_62)）和有符号（“无符号二进制数”在[第193页](ch04.xhtml#lev2_62)）整数的二进制表示；现在我们已经准备好在算术运算中使用它们。幸运的是，由于它们的编码方式，*无论我们选择将操作数或结果解释为有符号还是无符号*，对算术过程都没有影响。这一观察对于硬件设计师来说是一个好消息，因为它允许他们构建一套硬件组件，这些组件可以在无符号和有符号操作之间共享。[第246页](ch05.xhtml#lev1_41)的“电路”部分更详细地描述了执行算术运算的电路。
- en: Luckily, the same pencil-and-paper algorithms you learned in grade school for
    performing arithmetic on decimal numbers also work for binary numbers. Though
    the hardware might not compute them in exactly the same way, you should at least
    be able to make sense of the calculations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你在小学时学习的用于执行十进制数算术运算的纸笔算法同样适用于二进制数。虽然硬件可能不会完全以相同的方式计算它们，但你至少能够理解这些计算。
- en: 4.4.1 Addition
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1 加法
- en: Recall that in a binary number, each digit holds only 0 or 1\. Consequently,
    when adding two bits that are *both* 1, the result *carries out* to the next digit
    (e.g., 1 + 1 = 0b10, which requires two bits to represent). In practice, programs
    add multibit variables, where the result of one digit’s *carry out* influences
    the next digit by *carrying in*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在二进制数中，每一位只能是0或1。因此，当两个位都为1时，结果会*进位*到下一位（例如，1 + 1 = 0b10，需要两个位来表示）。实际上，程序会对多位变量进行加法，其中一位的*进位输出*会影响下一位的*进位输入*。
- en: In general, when summing digits from two binary numbers (*A* and *B*), there
    are *eight* possible outcomes depending on the values of *Digit[A]*, *Digit[B]*,
    and a *Carry[in]* from the previous digit. [Table 4-6](ch04.xhtml#ch4tab6) enumerates
    the eight possibilities that may result from adding one pair of bits. The *Carry[in]*
    column refers to a carry feeding into the sum from the previous digit, and the
    *Carry[out]* column indicates whether adding the pair of digits will feed a carry
    out to the next digit.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当从两个二进制数（*A*和*B*）中加法时，*有八*种可能的结果，这取决于*位[A]*、*位[B]*和前一位的*进位输入*。 [表4-6](ch04.xhtml#ch4tab6)列出了从加一对位可能得到的八种结果。*进位输入*列指的是从前一位传入和的进位，*进位输出*列则指示加这对位是否会将进位输出到下一位。
- en: '**Table 4-6:** The Eight Possible Outcomes of Adding Two Binary Digits (*A*
    and *B*) with a Potential Carry In from the Previous Digit'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-6：** 添加两个二进制数字（*A*和*B*）并可能从前一位获取进位时的八种可能结果'
- en: '| **Inputs** | **Outputs** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **输入** | **输出** |'
- en: '| **Digit**[**A**] | **Digit**[**B**] | **Carry**[**in**] | **Result (Sum)**
    | **Carry**[**out**] |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **位**[**A**] | **位**[**B**] | **进位**[**输入**] | **结果（和）** | **进位**[**输出**]
    |'
- en: '| 0 | 0 | 0 | 0 | 0 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 1 | 1 | 0 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 0 |'
- en: '| 0 | 1 | 0 | 1 | 0 |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 | 1 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 0 | 1 | 0 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 0 |'
- en: '| 1 | 0 | 1 | 0 | 1 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 | 0 | 1 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 |'
- en: 'Consider the addition of two four-bit binary numbers. Start by lining up the
    numbers so that their corresponding digits match vertically, and then sum each
    corresponding digit in order, from the low-order digit (*d*[0]) to the high-order
    digit (*d*[3]). For example, adding 0b0010 + 0b1011:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个四位二进制数的加法。首先，将数字对齐，使其对应的数字垂直匹配，然后按顺序对每个对应的数字求和，从低位数字（*d*[0]）到高位数字（*d*[3]）。例如，添加
    0b0010 + 0b1011：
- en: '| **Problem Setup** | **Worked Example** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **问题设置** | **实例操作** |'
- en: '| ![image](../images/t0208-01.jpg) | ![image](../images/t0208-02.jpg) |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| ![image](../images/t0208-01.jpg) | ![image](../images/t0208-02.jpg) |'
- en: The example shows a 1 carrying from *d*[1] into *d*[2]. This situation is analogous
    to adding two decimal digits that sum to a value larger than 9\. For example,
    when adding 5 + 8 = 13, the resulting ones place contains 3, and a 1 carries into
    the tens place.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例显示从*d*[1]进入*d*[2]的1。这种情况类似于添加两个十进制数字，它们的和大于9。例如，当添加5 + 8 = 13时，结果的个位数为3，并且1进位到十位数。
- en: 'The first operand (0b0010) has a leading 0, so it represents 2 for both two’s
    complement and unsigned interpretations. The second operand (0b1011) represents
    –5 if interpreted as a signed two’s complement value. Otherwise, it represents
    11 if interpreted as an unsigned value. Fortunately, the interpretation of the
    operands doesn’t affect the steps for computing the result. That is, the computed
    result (0b1101) represents either 13 (unsigned: 2 + 11) or –3 (signed: 2 + –5),
    both of which are correct depending on the interpretation of the second operand.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作数（0b0010）有一个前导0，因此在二进制补码和无符号解释中均表示2。第二个操作数（0b1011）如果作为有符号的二进制补码值解释，则表示-5。否则，如果作为无符号值解释，则表示11。幸运的是，操作数的解释并不影响计算结果的步骤。也就是说，计算结果（0b1101）表示无论第二个操作数的解释如何，都是正确的，分别表示13（无符号：2
    + 11）或-3（有符号：2 + -5）。
- en: 'More generally, a four-bit sequence represents values in the range [0, 15]
    when interpreted as *unsigned*. When interpreted as *signed*, it represents the
    range [–8, 7]. In the previous example, the result fits within the representable
    range either way, but we may not always be so lucky. For example, when adding
    0b1100 (unsigned 12) + 0b0111 (7), the answer should be 19, but four bits can’t
    represent 19:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，四位序列在解释为*无符号*时表示范围[0, 15]的值。当解释为*有符号*时，它表示范围[-8, 7]。在前面的示例中，无论如何计算结果都在可表示的范围内，但我们可能并不总是那么幸运。例如，当添加
    0b1100（无符号12）+ 0b0111（7）时，答案应为19，但四位无法表示19：
- en: '| **Problem Setup** | **Worked Example** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **问题设置** | **实例操作** |'
- en: '| ![image](../images/t0209-01.jpg) | ![image](../images/t0209-02.jpg) |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| ![image](../images/t0209-01.jpg) | ![image](../images/t0209-02.jpg) |'
- en: Note that the addition in this example carries a 1 from the most significant
    bit, a condition known as a *carry out* for the overall arithmetic operation.
    In this example, the carry out suggests that the arithmetic output needs an extra
    bit to store the intended result. However, when performing four-bit arithmetic,
    there’s nowhere to put the carry out’s extra bit, so the hardware simply drops
    or *truncates* it, leaving 0b0011 as the result. Of course, if the goal was to
    add 12 + 7, a result of 3 is likely to be surprising. The surprise is a consequence
    of *overflow*. We’ll explore how to detect overflow and why it produces the results
    that it does in “Integer Overflow” on [page 211](ch04.xhtml#lev1_32).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中的加法从最高有效位中带有1，这种情况被称为整体算术运算的*Carry out*。在这个例子中，Carry out表明算术输出需要额外的位来存储预期的结果。然而，在进行四位算术运算时，没有地方可以放置Carry
    out的额外位，因此硬件简单地丢弃或*截断*它，将0b0011作为结果。当然，如果目标是加法12 + 7，结果3可能会让人感到意外。这种意外是*溢出*的后果。我们将在第211页的“整数溢出”中探讨如何检测溢出以及它产生的结果原因。
- en: '**Note**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Multibit adder circuits also support a *carry in* that behaves like a carry
    into the rightmost digit (i.e., it serves as the *Carry[in]* input for *d*[0]).
    The carry in isn’t useful when performing addition—it’s implicitly set to 0, which
    is why it doesn’t appear in the preceding example. However, the carry in does
    become relevant for other operations that use adder circuitry, most notably subtraction.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 多位加法器电路还支持一个*进位*，其行为类似于进位到最右边的数字（即它作为*d*[0]的*Carry[in]*输入）。在执行加法时，进位并不实际使用，因为它被隐式设置为0，这就是为什么它不出现在前面的示例中的原因。然而，对于使用加法器电路的其他操作，进位就变得相关，尤其是减法。
- en: 4.4.2 Subtraction
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2 减法
- en: 'Subtraction combines two familiar operations: negation and addition. In other
    words, subtracting 7 – 3 is equivalent to expressing the operation as 7 + (–3).
    This portrayal of subtraction aligns well with how the hardware behaves—a CPU
    already contains circuits for negation and addition, so it makes sense to reuse
    those circuits rather than build an entirely new subtractor. Recall that a simple
    procedure to negate a binary number is to flip the bits and add one (see “Negation”
    on [page 205](ch04.xhtml#lev3_41)).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 减法结合了两种常见操作：取反和加法。换句话说，7 - 3 等同于将该操作表示为 7 + (–3)。这种减法的表现形式与硬件的行为非常一致——CPU已经包含了用于取反和加法的电路，因此利用这些现有电路比构建全新的减法电路更为高效。回想一下，取反二进制数的简单方法是翻转位并加一（详见
    [第205页](ch04.xhtml#lev3_41)中的“取反”）。
- en: 'Consider the example 0b0111 (7) – 0b0011 (3), which starts by sending the 3
    to a bit-flipping circuit. To get the “plus one,” it takes advantage of the *carry
    in* to the adder circuit. That is, rather than carrying from one digit to another,
    subtraction feeds a *carry in* to *d*[0] of the adder. Setting the carry in to
    1 increases the resulting “ones place” value by one, which is exactly what it
    needs to get the “plus one” part of the negation. Putting it all together, the
    example would look like the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑示例 0b0111（7）- 0b0011（3），首先将3发送到位翻转电路。为了得到“加一”，它利用了加法器电路的*进位输入*。即，减法不是从一位进位到另一位，而是将*进位输入*传递给加法器的*d*[0]。将进位输入设置为1会使得结果的“个位”值加一，这正是它需要的“加一”部分。将所有步骤组合在一起，示例结果如下：
- en: '| **Problem Setup** | **Converted to Addition** | **Worked Example** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **问题设置** | **转化为加法** | **演示示例** |'
- en: '| ![image](../images/t0210-01.jpg) | ![image](../images/t0210-02.jpg) | ![image](../images/t0210-03.jpg)
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| ![image](../images/t0210-01.jpg) | ![image](../images/t0210-02.jpg) | ![image](../images/t0210-03.jpg)
    |'
- en: While the full result of the addition carries into an extra digit, the truncated
    result (0b0100) represents the expected result (4). Unlike the previous addition
    example, a carry out from the high-order bit is not necessarily indicative of
    an overflow problem for subtraction.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管加法的完整结果会扩展为额外的一位，但截断后的结果（0b0100）表示预期的结果（4）。与之前的加法示例不同，来自高位的进位并不一定意味着减法中的溢出问题。
- en: 'Performing subtraction as negation followed by addition also works when subtracting
    a negative value. For example, 7 – (–3) produces 10:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当减去负值时，执行取反后加法的方式同样适用。例如，7 - (–3) 得到 10：
- en: '| **Problem Setup** | **Converted to Addition** | **Worked Example** |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **问题设置** | **转化为加法** | **演示示例** |'
- en: '| ![image](../images/t0210-04.jpg) | ![image](../images/t0210-05.jpg) | ![image](../images/t0210-06.jpg)
    |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| ![image](../images/t0210-04.jpg) | ![image](../images/t0210-05.jpg) | ![image](../images/t0210-06.jpg)
    |'
- en: We further explore the implications of carrying out (or not) in “Integer Overflow”
    on [page 211](ch04.xhtml#lev1_32).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步探讨在“整数溢出”中执行（或不执行）进位操作的影响，详见 [第211页](ch04.xhtml#lev1_32)。
- en: 4.4.3 Multiplication and Division
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3 乘法与除法
- en: This section briefly describes binary multiplication and division with integers.
    In particular, it shows methods for computing results by hand and does not reflect
    the behavior of modern hardware. This description is not meant to be comprehensive,
    as the remainder of the chapter focuses primarily on addition and subtraction.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了带整数的二进制乘法和除法。特别是，它展示了手动计算结果的方法，并未反映现代硬件的行为。此描述并非详尽无遗，因为本章的其余部分主要集中在加法和减法。
- en: Multiplication
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 乘法
- en: 'To multiply binary numbers, use the common pencil-and-paper strategy of considering
    one digit at a time and adding the results. For example, multiplying 0b0101 (5)
    and 0b0011 (3) is equivalent to summing:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行二进制数的乘法，可以使用常见的笔算策略，一次考虑一个数字并加总结果。例如，0b0101（5）和0b0011（3）的乘法等同于求和：
- en: 'the result of multiplying *d*[0] by 0b101 (5): 0b0101 (5)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *d*[0] 与 0b101（5）相乘：0b0101（5）
- en: 'the result of multiplying *d*[1] by 0b101 (5) and shifting the result to the
    left by one digit: 0b1010 (10).'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 *d*[1] 与 0b101（5）相乘，并将结果左移一位：0b1010（10）。
- en: '[PRE7]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (Integer) Division
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: （整数）除法
- en: 'Unlike the other operations just described, division has the potential to produce
    a non-integral result. The primary thing to keep in mind when dividing integers
    is that in most languages (e.g., C, Python 2, and Java) the fractional portion
    of the result gets truncated. Otherwise, binary division uses the same long form
    method that most students learn in grade school. For example, here’s how computing
    11 / 3 produces an integer result of 3:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面描述的其他运算不同，除法可能产生非整数结果。进行整数除法时，最需要记住的是，在大多数编程语言中（例如C、Python 2和Java），结果的小数部分会被截断。否则，二进制除法使用的是大多数学生在小学时学习的长除法方法。例如，下面是计算11
    / 3如何得到整数结果3的过程：
- en: '[PRE8]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At this point, the arithmetic has produced the expected integer result, 0011
    (3), and the hardware truncates any fractional parts. If you’re interested in
    determining the integral remainder, use the modulus operator (%), e.g., 11 % 3
    = 2.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，算术已经得出了预期的整数结果0011（3），硬件会截断任何小数部分。如果你有兴趣确定整数余数，可以使用取模运算符（%），例如，11 % 3 =
    2。
- en: 4.5 Integer Overflow
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5 整数溢出
- en: Although the number of integers is mathematically infinite, in practice, numeric
    types in a computer’s memory occupy a fixed number of bits (see “Storage Limitations”
    on [page 196](ch04.xhtml#lev2_64)). As we’ve hinted throughout this chapter, using
    a fixed number of bits implies that programs might be unable to represent values
    that they’d like to store. For example, the discussion of addition showed that
    adding two legitimate values can produce a result that can’t be represented (see
    [page 208](ch04.xhtml#table04in01)). A computation that lacks the storage to represent
    its result has *overflowed*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管整数的数量在数学上是无限的，但在实际应用中，计算机内存中的数字类型占用固定数量的位（参见[第196页](ch04.xhtml#lev2_64)的“存储限制”）。正如本章始终暗示的，使用固定数量的位意味着程序可能无法表示它们希望存储的值。例如，加法讨论中显示，两个合法值相加可能会产生无法表示的结果（参见[第208页](ch04.xhtml#table04in01)）。如果一个计算没有足够的存储空间来表示其结果，那么它就发生了*溢出*。
- en: 4.5.1 Odometer Analogy
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1 里程表类比
- en: 'To characterize overflow, consider an example from the non-computing world:
    a car’s odometer. An odometer counts the number of miles a car has driven, and
    whether it’s digital or analog, it can display only so many (base 10) digits.
    If the car drives more miles than the odometer can represent, the odometer “rolls
    over” back to zero, since the true value can’t be expressed. For example, with
    a standard six-digit odometer, the maximum value it represents is 999999\. Driving
    just one additional mile *should* display 1000000, but like the overflowing addition
    example of [page 208](ch04.xhtml#page_208), the 1 carries out from the six available
    digits, leaving only 000000.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了描述溢出，我们可以从非计算领域举个例子：汽车的里程表。里程表记录了汽车行驶的里程数，不论是数字式还是模拟式，都只能显示有限的（十进制）数字。如果汽车行驶的里程数超过了里程表所能表示的范围，里程表会“回绕”回到零，因为实际的值无法表示。例如，对于一个标准的六位数里程表，它能表示的最大值是999999。再多行驶一英里*本应*显示1000000，但就像[第208页](ch04.xhtml#page_208)中溢出的加法例子一样，1会从六个可用数字中溢出，最终只留下000000。
- en: For simplicity, let’s continue analyzing an odometer that’s limited to just
    one decimal digit. That is, the odometer represents the range [0, 9], so after
    every 10 miles the odometer resets back to zero. Illustrating the odometer’s range
    visually, it might look like [Figure 4-7](ch04.xhtml#ch4fig7).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们继续分析一个仅限于一个十进制数字的里程表。也就是说，里程表表示的范围是[0, 9]，因此每行驶10英里，里程表就会重置回零。将里程表的范围通过视觉方式展示出来，它可能像[图4-7](ch04.xhtml#ch4fig7)这样。
- en: '![image](../images/04fig07.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig07.jpg)'
- en: '*Figure 4-7: A visual depiction of a one-digit odometer’s potential values*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：一个一位数里程表潜在值的视觉呈现*'
- en: Because a one-digit odometer rolls over upon reaching 10, drawing a circular
    shape emphasizes the discontinuity at the top of the circle (and *only* at the
    top). Specifically, by adding one to any value *other than nine*, the result lands
    on the expected value. On the other hand, adding one to nine jumps to a value
    that doesn’t naturally follow it (zero). More generally, when performing *any*
    arithmetic that crosses the discontinuity between nine and zero, the computation
    will overflow. For example, consider adding 8 + 4, as in [Figure 4-8](ch04.xhtml#ch4fig8).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个一位数的里程表在达到10时就会回绕，绘制一个圆形强调了圆顶的断裂点（*仅仅是*在圆顶处）。具体来说，通过对除九以外的任何值加一，结果会得到预期的值。另一方面，对九加一则跳转到一个不自然的值（零）。更一般地，当执行*任何*跨越九与零之间断裂点的算术运算时，计算将会溢出。例如，考虑加法8
    + 4，如[图4-8](ch04.xhtml#ch4fig8)所示。
- en: '![image](../images/04fig08.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig08.jpg)'
- en: '*Figure 4-8: The result of adding 8 + 4 with only one decimal digit. Crossing
    the discontinuity between 0 and 9 indicates that an overflow has occurred.*'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：仅有一个十进制位时，8 + 4 的结果。越过 0 和 9 之间的不连续性表示发生了溢出。*'
- en: Here, the sum yields 2 instead of the expected 12\. Note that many other values
    added to 8 (e.g., 8 + 14) would also land on two, with the only difference being
    that the computations would take additional trips around the circle. Consequently,
    it doesn’t matter whether the car drives 2, 12, or 152 miles—in the end, the odometer
    will read 2 regardless.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，和预期的 12 相比，结果是 2。请注意，许多其他加到 8 上的值（例如，8 + 14）也会得到 2，唯一的区别是这些计算会绕圈进行多次。因此，无论汽车行驶了
    2 英里、12 英里还是 152 英里——最终，里程表都会显示 2。
- en: 'Any device that behaves like an odometer performs *modular arithmetic*. In
    this case, all arithmetic is modular with respect to a modulus of 10, since one
    decimal digit represents only 10 values. Therefore, given any number of miles
    traveled, we can compute what the odometer will read by dividing the distance
    by 10 and taking the remainder as the result. If the odometer had two decimal
    digits instead of one, the modulus would change to 100, since it could represent
    a larger range of values: [0, 99]. Similarly, clocks perform modular arithmetic
    with an hour modulus of 12.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 任何像里程表一样工作的设备都执行 *模运算*。在这种情况下，所有算术运算都相对于 10 进行模运算，因为一个十进制数字仅表示 10 个值。因此，给定任何行驶的英里数，我们可以通过将距离除以
    10 并取余数作为结果来计算里程表显示的数值。如果里程表有两个十进制数字而不是一个，模数将变为 100，因为它可以表示更大的值范围：[0, 99]。类似地，时钟执行模运算，小时数模数为
    12。
- en: 4.5.2 Binary Integer Overflow
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.2 二进制整数溢出
- en: Having seen a familiar form of overflow, let’s turn to binary number encodings.
    Recall that *N* bits of storage represent 2^(*N*) unique bit sequences and that
    those sequences can be interpreted in different ways (as *unsigned* or *signed*).
    Some operations that yield correct results under one interpretation may exhibit
    overflow according to the other, so the hardware needs to recognize overflow differently
    for each.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 看到一种熟悉的溢出形式后，让我们来看看二进制数字编码。回忆一下，*N* 位存储表示 2^(*N*) 个独特的比特序列，而这些序列可以以不同的方式解读（作为
    *无符号* 或 *有符号*）。在某些解释下，某些运算可能会得到正确的结果，但在另一种解释下却会发生溢出，因此硬件需要根据每种情况不同地识别溢出。
- en: For example, suppose that a machine is using four-bit sequences to compute 0b0010
    (2) – 0b0101 (5). Running this operation through the subtraction procedure (see
    “Subtraction” on [page 209](ch04.xhtml#lev2_71)) produces a binary result of 0b1101\.
    Interpreting this result as a *signed* value produces –3 (–8 + 4 + 1), the expected
    result for 2 – 5 without overflow. Alternatively, interpreting it as an *unsigned*
    value yields 13 (8 + 4 + 1), which is incorrect and clearly indicative of overflow.
    Scrutinizing this example further, it instinctively makes some sense—the result
    should be negative, and a signed interpretation allows for negatives, whereas
    unsigned does not.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一台机器使用四位序列计算 0b0010 (2) - 0b0101 (5)。将此运算通过减法过程（参见 [第 209 页](ch04.xhtml#lev2_71)
    的“减法”）进行计算，得到的二进制结果是 0b1101。将此结果解释为 *有符号* 值会得到 -3（-8 + 4 + 1），这是 2 - 5 的预期结果，没有溢出。另一方面，将其解释为
    *无符号* 值则得到 13（8 + 4 + 1），这是不正确的，明显表明发生了溢出。进一步审视这个例子，它直觉上是有道理的——结果应该是负数，而有符号解释允许负数，而无符号则不允许。
- en: Unsigned Overflow
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无符号溢出
- en: '*Unsigned* numbers behave similarly to the decimal odometer examples given
    that both represent only non-negative values. *N* bits represent unsigned values
    in the range [0, 2^(*N*) – 1], making all arithmetic modular with respect to 2^(*N*).
    [Figure 4-9](ch04.xhtml#ch4fig9) illustrates an arrangement of the unsigned interpretations
    of four-bit sequences into a modular space.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*无符号* 数字的行为与十进制里程表的示例相似，因为它们都仅表示非负值。*N* 位表示的无符号值范围是 [0, 2^(*N*) – 1]，使得所有的算术运算都相对于
    2^(*N*) 进行模运算。[图 4-9](ch04.xhtml#ch4fig9)展示了四位序列的无符号解释在模空间中的排列。'
- en: '![image](../images/04fig09.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig09.jpg)'
- en: '*Figure 4-9: An arrangement of four-bit unsigned values into a modular space.
    All arithmetic is modular with respect to 2⁴ (16).*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9：四位无符号值在模空间中的排列。所有算术运算都相对于 2⁴ (16) 进行模运算。*'
- en: Given that unsigned interpretations can’t hold negative values, the discontinuity
    again sits between the maximum value and zero. Therefore, unsigned overflow results
    from any operation that crosses the divide between 2^(*N*) – 1 and 0\. Stated
    more plainly, if performing addition (which should make the result *larger*) produces
    a smaller result, the addition caused unsigned overflow. Symmetrically, if performing
    subtraction (which should make the result *smaller*) produces a larger result,
    the subtraction caused unsigned overflow.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无符号解释不能表示负值，因此断点再次出现在最大值和零之间。因此，无符号溢出发生在任何操作跨越2^(*N*) - 1和0之间的界限时。简单来说，如果执行加法（应使结果*增大*）却得到较小的结果，则加法引起了无符号溢出。对称地，如果执行减法（应使结果*减小*）却得到较大的结果，则减法引起了无符号溢出。
- en: As a shortcut for detecting unsigned overflow for addition and subtraction,
    recall the carry out ([page 208](ch04.xhtml#page_208)) and carry in ([page 209](ch04.xhtml#page_209))
    bits of those operations. A *carry out* is a carry from the most significant bit
    in the result of the computation. When set, a *carry in* increments the value
    of the result by carrying one into the least significant bit of the arithmetic
    operation. The *carry in* is only set to 1 for subtraction as part of the negation
    procedure.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 作为检测加法和减法无符号溢出的捷径，回顾这些操作的进位（[第208页](ch04.xhtml#page_208)）和进位输入（[第209页](ch04.xhtml#page_209)）位。*进位*是指计算结果中从最高有效位向外进位的位。当设置时，*进位输入*通过将1进位到算术操作的最低有效位，来增加结果的值。*进位输入*只有在减法时才会设置为1，作为取反过程的一部分。
- en: 'The shortcut for unsigned arithmetic is: the carry out must match the carry
    in, otherwise the operation causes overflow. Intuitively, this shortcut works
    because:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号算术的捷径是：进位输出必须与进位输入匹配，否则该操作会导致溢出。直观地，这个捷径之所以有效，是因为：
- en: For addition (carry in = 0), the result should be larger than (or equal to)
    the first operand. However, if the sum requires an extra bit of storage (carry
    out = 1), then truncating that extra bit from the sum yields a smaller result
    (overflow). For example, in the unsigned four-bit number space, adding 0b1100
    (12) + 0b1101 (13) requires *five* bits to store the result 0b11001 (25). When
    truncated to only four bits, the result represents 0b1001 (9), which is smaller
    than the operands (therefore, overflow).
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于加法（进位输入 = 0），结果应大于或等于第一个操作数。然而，如果和需要额外的存储位（进位 = 1），则从和中截断该额外的位会导致较小的结果（溢出）。例如，在无符号四位数空间中，0b1100（12）+
    0b1101（13）的和需要*五*个位来存储结果0b11001（25）。当截断为四个位时，结果变为0b1001（9），小于操作数（因此，发生溢出）。
- en: For subtraction (carry in = 1), the result should be smaller than (or equal
    to) the first operand. Since subtraction executes as a combination of addition
    and negation, the addition subproblem should produce a smaller result. The only
    way addition can end up with a smaller value is by truncating its sum (carry out
    = 1). If it doesn’t require truncation (carry out = 0), the subtraction yields
    a larger result (overflow).
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于减法（进位输入 = 1），结果应小于或等于第一个操作数。由于减法是加法和取反的组合，求解加法子问题时应得出较小的结果。加法只能通过截断其和（进位 =
    1）来得到较小的值。如果不需要截断（进位 = 0），则减法将得到较大的结果（溢出）。
- en: 'Let’s examine two examples of four-bit subtraction: one that overflows, and
    one that doesn’t. First, consider 0b0111 (7) – 0b1001 (9). The subtraction procedure
    treats this computation as:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析两个四位减法的例子，一个发生溢出，另一个没有。首先，考虑0b0111（7）– 0b1001（9）。减法过程将此计算视为：
- en: '| **Problem Setup** | **Converted to Addition** | **Worked Example** |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| **问题设置** | **转换为加法** | **示例** |'
- en: '| ![image](../images/t0215-01.jpg) | ![image](../images/t0215-02.jpg) | ![image](../images/t0215-03.jpg)
    |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| ![image](../images/t0215-01.jpg) | ![image](../images/t0215-02.jpg) | ![image](../images/t0215-03.jpg)
    |'
- en: The computation *did not* carry out of *d*[3], so no truncation occurs and the
    carry in (1) fails to match the carry out (0). The result, 0b1110 (14), is larger
    than either operand and thus clearly incorrect for 7 – 9 (overflow).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 计算*没有*从*d*[3]中进位，因此没有发生截断，且进位输入（1）未与进位输出（0）匹配。结果0b1110（14）大于任一操作数，因此对于7 – 9（溢出）来说显然是错误的。
- en: 'Next, consider 0b0111 (7) – 0b0101 (5). The subtraction procedure treats this
    computation as:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑0b0111（7）– 0b0101（5）。减法过程将此计算视为：
- en: '| **Problem Setup** | **Converted to Addition** | **Worked Example** |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| **问题设置** | **转换为加法** | **示例** |'
- en: '| ![image](../images/t0215-04.jpg) | ![image](../images/t0215-05.jpg) | ![image](../images/t0215-06.jpg)
    |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| ![image](../images/t0215-04.jpg) | ![image](../images/t0215-05.jpg) | ![image](../images/t0215-06.jpg)
    |'
- en: The computation carries out a bit to *d*[4], causing the carry in (1) to match
    the carry out (1). The truncated result, 0b0010 (2), correctly represents the
    expected outcome of the subtraction operation (no overflow).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 计算会向*d*[4]传递一个进位，导致进位输入（1）与进位输出（1）匹配。截断后的结果0b0010（2）正确地表示了减法操作的预期结果（没有溢出）。
- en: Signed Overflow
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有符号溢出
- en: 'The same intuition behind overflow applies to *signed* binary interpretations:
    there exists a discontinuity in the modular number space. However, because a signed
    interpretation allows for negatives, the discontinuity doesn’t occur around 0\.
    Recall that two’s complement (see [page 204](ch04.xhtml#lev2_69)) “rolls over”
    cleanly from –1 (0b1111 . . . 111) to 0 (0b0000 . . . 0em000). Thus, the discontinuity
    exists at the *other* end of the number space, where the largest positive value
    and smallest negative value meet.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出的直觉也适用于*有符号*二进制解释：在模数空间中存在一个不连续性。然而，由于有符号解释允许负数，故此不连续性不会出现在0附近。回想一下，二的补码（参见[第204页](ch04.xhtml#lev2_69)）从–1
    (0b1111 . . . 111) “平滑地过渡”到0 (0b0000 . . . 0em000)。因此，不连续性出现在数字空间的*另一端*，即最大正值和最小负值相遇的地方。
- en: '[Figure 4-10](ch04.xhtml#ch4fig10) shows an arrangement of the signed interpretations
    of four-bit sequences into a modular space. Note that half of the values are negative,
    the other half are non-negative, and the discontinuity lies at the min/max divide
    between them.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-10](ch04.xhtml#ch4fig10)展示了四位序列的有符号解释在模数空间中的排列。请注意，一半的值是负数，另一半是非负数，且不连续性位于它们之间的最小/最大分隔处。'
- en: '![image](../images/04fig10.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig10.jpg)'
- en: '*Figure 4-10: An arrangement of four-bit signed values into a modular space.
    Because a signed interpretation allows for negative values, the discontinuity
    no longer resides at zero.*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-10：四位有符号值在模数空间中的排列。由于有符号解释允许负值，不连续性不再位于零处。*'
- en: When performing signed arithmetic, it’s always safe to generate a result that
    moves closer to zero. That is, any operation that reduces the absolute value of
    the result cannot overflow, because the overflow discontinuity resides where the
    magnitude of the representable values is the largest.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行有符号算术时，始终安全生成一个趋近零的结果。也就是说，任何减少结果绝对值的操作都不会发生溢出，因为溢出的不连续性位于可表示值的幅度最大的位置。
- en: Consequently, systems detect overflow in signed addition and subtraction by
    comparing the most significant bit of the operands with the most significant bit
    of the result. For subtraction, first rearrange the arithmetic in terms of addition
    (e.g., rewrite 5 – 2 as 5 + –2).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，系统通过将操作数的最高有效位与结果的最高有效位进行比较，来检测有符号加法和减法中的溢出。对于减法，首先将算式转换为加法形式（例如，将5 – 2改写为5
    + –2）。
- en: If the addition’s operands have *different* high-order bit values (i.e., one
    operand is negative and the other is positive), there can be no signed overflow,
    because the absolute value of the result must be smaller than (or equal to) either
    operand. The result is moving *toward* zero.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加法的操作数具有*不同*的高位位值（即一个操作数是负数，另一个是正数），则不可能发生有符号溢出，因为结果的绝对值必定小于（或等于）任一操作数。结果是*向*零靠近的。
- en: If the addition’s operands have the *same* high-order bit value (i.e., both
    are positive or both are negative), then a correct result must also have the same
    high-order bit value. Thus, when adding two operands with the same sign, a signed
    overflow occurs if the result’s sign differs from that of the operands.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加法的操作数具有*相同*的高位位值（即，两者都是正数或两者都是负数），则正确的结果也必须具有相同的高位位值。因此，当加上两个符号相同的操作数时，如果结果的符号与操作数的符号不同，则会发生有符号溢出。
- en: 'Consider the following four-bit signed binary examples:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下四位有符号二进制示例：
- en: '*   5 – 4 is equivalent to 5 + –4\. The first operand (5) is positive, whereas
    the second (–4) is negative, so the result must be moving toward zero where *no
    overflow* is possible.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*   5 – 4 等价于 5 + –4。第一个操作数（5）是正数，而第二个操作数（–4）是负数，因此结果必须趋近于零，*没有溢出*的可能。'
- en: 4 + 2 (both positive) yields 6 (also positive), so *no overflow* occurs.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 + 2（都是正数）得出6（也是正数），所以*没有溢出*发生。
- en: –5 – 1 is equivalent to –5 + –1 (both negative) and yields –6 (also negative),
    so *no overflow* occurs.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: –5 – 1 等价于 –5 + –1（都是负数），得出–6（也是负数），所以*没有溢出*发生。
- en: 4 + 5 (both positive) yields –7 (negative). Since the operands have the same
    sign and it doesn’t match the result’s sign, this operation *overflows*.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 + 5（都是正数）得到–7（负数）。由于操作数具有相同的符号，并且与结果的符号不匹配，此操作*溢出*。
- en: –3 – 8 is equivalent to –3 + –8 (both negative) and yields 5 (positive). Since
    the operands have the same sign and it doesn’t match the result’s sign, this operation
    *overflows*.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: –3 – 8等同于–3 + –8（都是负数），结果为5（正数）。由于操作数具有相同的符号，并且与结果的符号不匹配，此操作*溢出*。
- en: 4.5.3 Overflow Summary
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.3 溢出总结
- en: 'In general, integer overflow occurs when an arithmetic operation moves between
    the minimum and maximum values that its result can represent. If you’re ever in
    doubt about the rules for signed versus unsigned overflow, consider the minimum
    and maximum values of an *N*-bit sequence:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，整数溢出发生在算术操作在其结果可以表示的最小和最大值之间移动时。如果对有符号和无符号溢出的规则感到疑惑，考虑*N*位序列的最小值和最大值：
- en: The minimum *unsigned* value is 0 (because unsigned encodings can’t represent
    negative numbers) and the maximum unsigned value is 2^(*N*) – 1 (because one bit
    sequence is reserved for zero). Therefore the discontinuity is between 2^(*N*)
    – 1 and 0.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小的*无符号*值是0（因为无符号编码不能表示负数），最大的无符号值是2^(*N*) – 1（因为一个比特序列用于零）。因此，不连续性出现在2^(*N*)
    – 1和0之间。
- en: The minimum *signed* value is –2^(*N–*1) (because half of the sequences are
    reserved for negative values) and the maximum is 2^(*N–*1) – 1 (because in the
    other half, one value is reserved for zero). Therefore, the discontinuity is between
    2^(*N–*1) – 1 and –2^(*N–*1).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小的*有符号*值是–2^(*N–*1)（因为一半的序列用于负值），最大值是2^(*N–*1) – 1（因为另一半一个值用于零）。因此，不连续性出现在2^(*N–*1)
    – 1和–2^(*N–*1)之间。
- en: 4.5.4 Overflow Consequences
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.4 溢出后果
- en: While you may not run into integer overflow frequently, overflows have the potential
    to break programs in notable (and potentially devastating) ways.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能不经常遇到整数溢出，但溢出有可能以显著（甚至是破坏性的）方式破坏程序。
- en: For example, in 2014, PSY’s popular “Gangnam Style”^([1](ch04.xhtml#fn4_1))
    music video threatened to overflow the 32-bit counter that YouTube used to track
    video hits. As a result, YouTube switched to using a 64-bit counter.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，2014年，PSY的流行曲“江南Style”^([1](ch04.xhtml#fn4_1))音乐视频威胁到YouTube用于跟踪视频点击数的32位计数器溢出。因此，YouTube转而使用64位计数器。
- en: Another relatively harmless example shows up in the 1980 arcade game *Pac-Man*.
    The game’s developers used an unsigned eight-bit value to track the player’s progress
    through the game’s levels. As a result, if an expert player makes it beyond level
    255 (the maximum value of an eight-bit unsigned integer), half of the board ends
    up glitching significantly, as shown in [Figure 4-11](ch04.xhtml#ch4fig11).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相对无害的例子出现在1980年的街机游戏《Pac-Man》中。游戏开发人员使用了一个无符号的八位值来跟踪玩家通过游戏级别的进度。因此，如果一个高手玩家超过了第255级（八位无符号整数的最大值），游戏板的一半会出现显著的故障，如[图4-11](ch04.xhtml#ch4fig11)所示。
- en: '![image](../images/04fig11.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig11.jpg)'
- en: '*Figure 4-11: The *Pac-Man* game board “freaks out” upon reaching level 256.*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-11：当达到第256级时，《Pac-Man》游戏板“疯狂”了起来。*'
- en: A much more tragic example of overflow appears in the history of the Therac-25^([2](ch04.xhtml#fn4_2))
    radiation therapy machine of the mid 1980s. The Therac-25 suffered from several
    design problems, including one that incremented a truth flag variable rather than
    setting it to a constant. After enough uses, the flag overflowed, causing it to
    erroneously roll over to zero (false) and bypass safety mechanisms. The Therac-25
    ultimately caused serious harm to (and in some cases killed) six patients.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更为悲剧性的溢出例子出现在20世纪80年代中期的治疗机器Therac-25^([2](ch04.xhtml#fn4_2))的历史中。Therac-25存在几个设计问题，包括一个递增真值标志变量而不是将其设为常数。经过足够的使用后，标志溢出，导致它错误地回滚到零（假），绕过安全机制。Therac-25最终严重伤害了（在某些情况下还杀死了）六名患者。
- en: 4.6 Bitwise Operators
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6 位运算符
- en: In addition to the standard arithmetic operations described earlier, CPUs also
    support operations that are uncommon outside of binary. These *bitwise operators*
    directly apply the behavior of logic gates (see “Basic Logic Gates” on [page 243](ch05.xhtml#lev2_94))
    to bit sequences, making them straightforward to implement efficiently in hardware.
    Unlike addition and subtraction, which programmers typically use to manipulate
    a variable’s numerical interpretation, programmers commonly use bitwise operators
    to modify specific bits in a variable. For example, a program might encode a certain
    bit position in a variable to hold a true/false meaning, and bitwise operations
    allow the program to manipulate the variable’s individual bits to change that
    specific bit.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面描述的标准算术运算外，CPU 还支持一些在二进制之外较为罕见的运算。这些*按位运算符*直接应用逻辑门的行为（参见 [第 243 页](ch05.xhtml#lev2_94)的“基本逻辑门”）于位序列，使它们能够高效地在硬件中实现。与加法和减法不同，后者通常用于程序员操作变量的数值解释，程序员通常使用按位运算符来修改变量中的特定位。例如，程序可能会在变量中编码某个位的位置以表示真/假值，而按位运算则允许程序操作变量的单独位，从而改变该特定位。
- en: 4.6.1 Bitwise AND
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.1 按位与
- en: The bitwise AND operator (`&`) evaluates two input bit sequences. For each digit
    of the inputs, it outputs a 1 in the corresponding position of the output if *both*
    inputs are 1 in that position. Otherwise, it outputs a 0 for the digit. [Table
    4-7](ch04.xhtml#ch4tab7) shows the truth table for the bitwise AND of two values,
    *A* and *B*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 按位与运算符（`&`）评估两个输入的位序列。对于输入的每个位，如果*两个*输入在该位置都是 1，则输出 1；否则，输出 0。[表 4-7](ch04.xhtml#ch4tab7)展示了两个值
    *A* 和 *B* 进行按位与运算的真值表。
- en: '**Table 4-7:** The Results of Bitwise ANDing Two Values (A AND B)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-7：** 两个值（A 和 B）按位与运算的结果'
- en: '| **A** | **B** | **A & B** |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A & B** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |'
- en: '| 1 | 0 | 0 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: 'For example, to bitwise AND 0b011010 with 0b110110, start by lining up the
    two sequences. Checking vertically through each digit, set the result of the column
    to 1 if *both* digits are 1\. Otherwise, set the result of the column to 0:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要对 0b011010 和 0b110110 进行按位与（AND）操作，首先将这两个序列对齐。然后逐位检查每个数字，如果*两个*数字都是 1，则将该列的结果设置为
    1；否则，将该列的结果设置为 0：
- en: '[PRE9]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To perform a bitwise AND in C, place C’s bitwise AND operator (`&`) between
    two operand variables. Here’s the example again, performed in C:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中执行按位与运算时，在两个操作数变量之间放置 C 的按位与运算符（`&`）。下面是再次在 C 语言中执行的示例：
- en: '[PRE10]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Warning BITWISE OPERATIONS VERSUS LOGICAL TRUTH OPERATIONS**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 位运算与逻辑真值运算的区别**'
- en: 'Be careful not to conflate bitwise operators with logical truth operators (see
    “Boolean Values in C” on [page 32](ch01.xhtml#lev2_6)). Despite having similar
    names (AND, OR, NOT, etc.), the two *are not* the same:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意不要将按位运算符与逻辑真值运算符混淆（参见 [第 32 页](ch01.xhtml#lev2_6)的“C 语言中的布尔值”）。尽管它们有类似的名称（AND、OR、NOT
    等），但这两者*并不相同*：
- en: Bitwise operators consider each bit of their inputs independently and produce
    an output bit sequence as a function of the specific input bits that are set.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位运算符独立地考虑其输入的每一位，并根据特定位是否被设置来生成输出的位序列。
- en: Logical operators consider only the *truth* interpretation of their operands.
    To C, a value of zero is *false*, whereas all other values are considered *true*.
    Logical operators are often used when evaluating conditionals (e.g., `if` statements).
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符仅考虑操作数的*真值*解释。在 C 语言中，零值被视为*假*，而所有其他值都被认为是*真*。逻辑运算符通常在评估条件表达式（如 `if` 语句）时使用。
- en: Note that C often uses similar (but slightly different) operators to distinguish
    between the two. For example, you can indicate bitwise AND and bitwise OR using
    a single `&` and `|`, respectively. Logical AND and logical OR correspond to a
    double `&&` and `||`. Finally, bitwise NOT uses `~`, whereas logical NOT is expressed
    by `!`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，C 语言常常使用类似（但稍有不同）的运算符来区分这两者。例如，你可以使用单个 `&` 和 `|` 来表示按位与和按位或，分别对应逻辑与（AND）和逻辑或（OR）运算。逻辑与和逻辑或则使用双重
    `&&` 和 `||` 表示。最后，按位非运算符是 `~`，而逻辑非则由 `!` 表示。
- en: 4.6.2 Bitwise OR
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.2 位运算 OR
- en: The bitwise OR operator (`|`) behaves like the bitwise AND operator except that
    it outputs a 1 for a digit if *either or both* of the inputs is 1 in the corresponding
    position. Otherwise, it outputs a 0 for the digit. [Table 4-8](ch04.xhtml#ch4tab8)
    shows the truth table for the bitwise OR of two values, *A* and *B*.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 按位或运算符（`|`）的行为与按位与运算符类似，不同之处在于，如果*任意一个或两个*输入在相应位置是 1，则输出 1；否则，输出 0。[表 4-8](ch04.xhtml#ch4tab8)展示了两个值
    *A* 和 *B* 进行按位或运算的真值表。
- en: '**Table 4-8:** The Results of Bitwise ORing Two Values (A OR B)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-8：** 按位或运算两个值的结果（A 或 B）'
- en: '| **A** | **B** | **A&#124;B** |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A&#124;B** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: 'For example, to bitwise OR 0b011010 with 0b110110, start by lining up the two
    sequences. Checking vertically through each digit, set the result of the column
    to 1 if *either* digit is 1:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要对 0b011010 和 0b110110 进行按位或运算，首先将两个序列对齐。逐列检查每一位，如果*任意一个*数字为 1，则该列的结果为 1：
- en: '[PRE11]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To perform a bitwise OR in C, place C’s bitwise OR operator (`|`) between two
    operands. Here’s the same example again, performed in C:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中执行按位或运算时，将 C 的按位或操作符（`|`）放在两个操作数之间。以下是相同的示例，在 C 中执行：
- en: '[PRE12]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 4.6.3 Bitwise XOR (Exclusive OR)
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.3 按位异或（排他或）
- en: The bitwise XOR operator (`^`) behaves like the bitwise OR operator except that
    it outputs a 1 for a digit only if *exactly one* (but not both) of the inputs
    is 1 in the corresponding position. Otherwise, it outputs a 0 for the digit. [Table
    4-9](ch04.xhtml#ch4tab9) shows the truth table for the bitwise XOR of two values,
    *A* and *B*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 按位异或操作符（`^`）的行为类似于按位或操作符，只不过它仅在输入的两个数字中*恰好有一个*（而不是两个）在相应位置为 1 时，输出 1。否则，它将输出
    0。[表 4-9](ch04.xhtml#ch4tab9) 显示了两个值 *A* 和 *B* 的按位异或的真值表。
- en: '**Table 4-9:** The Results of Bitwise XORing Two Values (A XOR B)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-9：** 按位异或两个值的结果（A 异或 B）'
- en: '| **A** | **B** | **A ^ B** |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A ^ B** |'
- en: '| 0 | 0 | 0 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: 'For example, to bitwise XOR 0b011010 with 0b110110, start by lining up the
    two sequences. Checking vertically through each digit, set the result of the column
    to 1 if *only one* digit is 1:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要对 0b011010 和 0b110110 进行按位异或操作，首先将两个序列对齐。逐列检查每一位，如果*只有一个*数字为 1，则该列的结果为 1：
- en: '[PRE13]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To perform a bitwise XOR in C, place C’s bitwise XOR operator (`^`) between
    two operands. Here’s the same example again, performed in C:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中执行按位异或时，将 C 的按位异或操作符（`^`）放在两个操作数之间。以下是相同的示例，在 C 中执行：
- en: '[PRE14]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 4.6.4 Bitwise NOT
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.4 按位取反
- en: The bitwise NOT operator (`~`) operates on just one operand. For each bit in
    the sequence, it simply flips the bit such that a zero becomes a one, or vice
    versa. [Table 4-10](ch04.xhtml#ch4tab10) shows the truth table for the bitwise
    NOT operator.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 按位取反操作符（`~`）仅作用于一个操作数。对于序列中的每一位，它简单地翻转该位，使零变为一，或反之。 [表 4-10](ch04.xhtml#ch4tab10)
    显示了按位取反操作符的真值表。
- en: '**Table 4-10:** The Results of Bitwise NOTing a Value (A)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-10：** 按位取反一个值的结果（A）'
- en: '| **A** | **~A** |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **~A** |'
- en: '| 0 | 1 |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 |'
- en: '| 1 | 0 |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 |'
- en: 'For example, to bitwise NOT 0b011010, invert the value of each bit:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要对 0b011010 进行按位取反，翻转每一位的值：
- en: '[PRE15]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To perform a bitwise NOT in C, place a tilde character (`~`) in front of an
    operand. Here’s the same example again, performed in C:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中执行按位取反时，将波浪号字符（`~`）放在操作数前面。以下是相同的示例，在 C 中执行：
- en: '[PRE16]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Warning BITWISE NOT VERSUS NEGATION**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告 按位取反与否定的区别**'
- en: Note that all modern systems represent integers using two’s complement, so bitwise
    NOT isn’t quite the same as negation. Bitwise NOT *only* flips the bits and *doesn’t*
    add one.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有现代系统使用二进制补码表示整数，因此按位取反与否定并不完全相同。按位取反*仅*翻转位，不*加*一。
- en: 4.6.5 Bit Shifting
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.5 位移
- en: 'Another important bitwise operation involves shifting the position of an operand’s
    bits either to the left (`<<`) or to the right (`>>`). Both the left and right
    shifting operators take two operands: the bit sequence to shift and the number
    of places it should be shifted.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的按位操作涉及将操作数的位移到左边（`<<`）或右边（`>>`）。左移和右移操作符都需要两个操作数：要移位的位序列和它应该移位的位数。
- en: Shifting Left
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向左移位
- en: Shifting a sequence to the left by *N* places moves each of its bits to the
    left *N* times, appending new zeros to the right side of the sequence. For example,
    shifting the eight-bit sequence 0b00101101 to the left by two produces 0b10110100\.
    The two zeros at the right are appended to end of the sequence, since the result
    still needs to be an eight-bit sequence.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个序列向左移动 *N* 位，将其每一位向左移动 *N* 次，在序列的右侧附加新的零。例如，将 8 位序列 0b00101101 向左移动两位，结果是
    0b10110100。右侧的两个零附加到序列的末尾，因为结果仍然需要是一个 8 位的序列。
- en: In the absence of overflow, shifting to the left *increases* the value of the
    result , since bits move toward digits that contribute larger powers of two to
    the value of the number. However, with a fixed number of bits, any bits that shift
    into positions beyond the maximum capacity of the number get truncated. For example,
    shifting the eight-bit sequence 0b11110101 (unsigned interpretation 245) to the
    left by one produces 0b11101010 (unsigned interpretation 234). Here, the truncation
    of the high-order bit that shifted out makes the result smaller.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有溢出的情况下，左移会*增加*结果值，因为位会移向那些贡献更大二次幂的数字位置。然而，对于固定数量的位，任何移到超出数字最大容量位置的位都会被截断。例如，将8位序列0b11110101（无符号解读为245）左移一位，结果为0b11101010（无符号解读为234）。这里，移出高位的位被截断，使得结果变小。
- en: 'To perform a left bit shift in C, place two less-than characters (`<<`) between
    a value and the number of places to shift that value:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C语言中执行左位移，请将两个小于符号（`<<`）放在值与要移位的位数之间：
- en: '[PRE17]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Shifting Right
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 右移
- en: 'Shifting to the right is similar to left shifting—any bits that are shifted
    out of a variable’s capacity (e.g., off the end to the right) disappear due to
    truncation. However, right shifting introduces an additional consideration: the
    new bits prepended to the left side of the result may need to be either all zeros
    or all ones depending on the *type* of the variable being shifted and its high-order
    bit value. Conceptually, the choice to prepend zeros or ones resembles that of
    sign extension (see “Sign Extension” on [page 206](ch04.xhtml#lev3_42)). Thus,
    there exist two distinct variants of right shifting:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 右移类似于左移——任何超出变量容量（例如，右边移出的位）的位都会由于截断而消失。然而，右移引入了额外的考虑因素：新添加到结果左侧的位可能需要是零或一，这取决于移位变量的*类型*及其高位值。从概念上讲，选择填充零或一类似于符号扩展（请参阅[第206页](ch04.xhtml#lev3_42)的“符号扩展”）。因此，右移有两种不同的变体：
- en: A *logical right shift* always prepends zeros to the high-order bits of the
    result. Logical shifting is used to shift *unsigned* variables, since a leading
    1 in the most significant bit of an unsigned value isn’t intended to mean that
    the value is negative. For example, shifting 0b10110011 to the right by two using
    a logical shift yields 0b00101100.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*逻辑右移*始终将零填充到结果的高位。逻辑移位用于移位*无符号*变量，因为无符号值的最高有效位如果为1并不表示该值是负数。例如，使用逻辑右移将0b10110011右移两位，结果为0b00101100。'
- en: An *arithmetic right shift* prepends a copy of the shifted value’s most significant
    bit into each of the new bit positions. Arithmetic shifting applies to *signed*
    variables, for which it’s important to preserve the signedness of the high-order
    bits. For example, shifting 0b10110011 to the right by two using an arithmetic
    shift yields 0b11101100.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*算术右移*将移位值的最高有效位复制到新位位置的每一位上。算术移位适用于*有符号*变量，对于这些变量，保留高位的符号性非常重要。例如，使用算术右移将0b10110011右移两位，结果为0b11101100。'
- en: Fortunately, when programming in C, you don’t typically need to worry about
    the distinction if you’ve declared your variables properly. If your program includes
    a right shift operator (`>>`), virtually every C compiler will automatically perform
    the appropriate type of shifting according to the type of the shifting variable.
    That is, if the shifting variable was declared with the *unsigned* qualifier,
    the compiler will perform a logical shift. Otherwise, it will perform an arithmetic
    shift.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在C语言编程中，如果正确声明了变量，通常不需要担心这种区分。如果程序中包含右移操作符（`>>`），几乎所有C编译器都会根据移位变量的类型自动执行适当的移位操作。也就是说，如果移位变量声明为*无符号*类型，编译器将执行逻辑移位。否则，它将执行算术移位。
- en: '**Note C RIGHT SHIFT EXAMPLE PROGRAM**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：C语言右移示例程序**'
- en: 'You can test the behavior of right shifting with a small example program like
    this one:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个小示例程序测试右移的行为，例如下面这个：
- en: '#include <stdio.h>'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: int main(int argc, char **argv) {
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: int main(int argc, char **argv) {
- en: '/* Unsigned integer value: u_val */'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: /* 无符号整数值：u_val */
- en: unsigned int u_val = 0xFF000000;
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: unsigned int u_val = 0xFF000000;
- en: '/* Signed integer value: s_val */'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: /* 有符号整数值：s_val */
- en: int s_val = 0xFF000000;
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: int s_val = 0xFF000000;
- en: printf("%08X\n", u_val >> 12);  // logical right shift
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: printf("%08X\n", u_val >> 12);  // 逻辑右移
- en: printf("%08X\n", s_val >> 12);  // arithmetic right shift
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: printf("%08X\n", s_val >> 12);  // 算术右移
- en: return 0;
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: return 0;
- en: '}'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This program declares two 32-bit integers: one as an unsigned integer (`u_val`),
    and another as a signed integer (`s_val`). It initializes both integers to the
    same starting value: a sequence of 8 ones followed by 24 zeros (`0b1111111100000000000000000000000000`),
    and then it shifts both values 12 positions to the right. When executed, it prints:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序声明了两个32位整数：一个作为无符号整数（`u_val`），另一个作为有符号整数（`s_val`）。它将这两个整数初始化为相同的起始值：一个由8个1和24个0组成的序列（`0b1111111100000000000000000000000000`），然后将这两个值右移12位。执行时，它会打印：
- en: $ ./a.out
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: $ ./a.out
- en: 000FF000
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 000FF000
- en: FFFFF000
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: FFFFF000
- en: Because a leading 1 doesn’t indicate “negative” for the unsigned `u_val`, the
    compiler uses instructions to prepend it with only zeros. The shifted result contains
    12 zeros, 8 ones, and 12 more zeros (`0b00000000000011111111000000000000`). On
    the other hand, the leading 1 *does* indicate “negative” for `s_val`, so the compiler
    prepends 1’s to the front of the shifted value, yielding 20 ones followed by 12
    zeros (`0b11111111111111111111000000000000`).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无符号的`u_val`中的前导1并不表示“负数”，所以编译器使用指令仅用0填充它的前面。移位结果包含12个0，8个1，和12个0（`0b00000000000011111111000000000000`）。另一方面，`s_val`的前导1确实表示“负数”，所以编译器会在移位后的值前面填充1，得到20个1和12个0（`0b11111111111111111111000000000000`）。
- en: 4.7 Integer Byte Order
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7 整数字节顺序
- en: So far, this chapter has described several schemes for encoding numbers with
    bits, but it hasn’t mentioned how the values are organized in memory. For modern
    systems, the smallest addressable unit of memory is a byte, which consists of
    eight bits. Consequently, to store a one-byte value (e.g., a variable of type
    `char`) starting at address *X*, you don’t really have any options—just store
    the byte at location *X*.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经描述了几种用位编码数字的方案，但还没有提到这些值是如何在内存中组织的。对于现代系统，内存的最小可寻址单元是字节（byte），它由八个位（bit）组成。因此，要在地址*X*开始存储一个字节值（例如，一个`char`类型的变量），你实际上没有什么选择——只需将字节存储在地址*X*处。
- en: However, for multibyte values (e.g., variables of type `short` or `int`), the
    hardware has more options for assigning a value’s bytes to memory addresses. For
    example, consider a two-byte `short` variable `s` whose bytes are labeled A (containing
    the high-order bits of `s`) and B (containing the low-order bits of `s`). When
    a system is asked to store a `short` like `s` at address *X* (i.e., in addresses
    *X* and *X* + 1), it must define which byte of the variable (A or B) should occupy
    which address (*X* or *X* + 1). [Figure 4-12](ch04.xhtml#ch4fig12) shows the two
    options for storing `s` in memory.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于多字节值（例如`short`或`int`类型的变量），硬件在将值的字节分配到内存地址时有更多的选择。例如，考虑一个两字节的`short`类型变量`s`，它的字节标记为A（包含`s`的高位）和B（包含`s`的低位）。当系统被要求将像`s`这样的`short`存储在地址*X*（即在地址*X*和*X*
    + 1中）时，它必须定义该变量的哪个字节（A或B）应该占据哪个地址（*X*或*X* + 1）。[图4-12](ch04.xhtml#ch4fig12)展示了将`s`存储在内存中的两种选择。
- en: '![image](../images/04fig12.jpg)'
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig12.jpg)'
- en: '*Figure 4-12: Two potential memory layouts for a two-byte short starting at
    memory address *X**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-12：从内存地址*X*开始的两种可能的两字节短整型内存布局*'
- en: The *byte order* (or *endianness*) of a system defines how its hardware assigns
    the bytes of a multibyte variable to consecutive memory addresses. Although byte
    order is rarely an issue for programs that only run on a single system, it might
    appear surprising if one of your programs attempts to print bytes one at a time
    or if you’re examining variables with a debugger.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的*字节顺序*（或*字节序*）定义了硬件如何将一个多字节变量的字节分配到连续的内存地址。尽管对于只在单个系统上运行的程序来说，字节顺序很少会成为问题，但如果你的某个程序试图逐字节打印，或者你使用调试器检查变量时，可能会感到惊讶。
- en: 'For example, consider the following program:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下程序：
- en: '[PRE18]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This program allocates a four-byte integer and initializes the bytes, in order
    from most to least significant, to the hexadecimal values `0xAA`, `0xBB`, `0xCC`,
    and `0xDD`. It then prints the bytes one at a time starting from the base address
    of the integer. You’d be forgiven for expecting the bytes to print in alphabetical
    order. However, commonly used CPU architectures (i.e., x86 and most ARM hardware)
    print the bytes in reverse order when executing the example program:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序分配了一个四字节整数，并按照从高位到低位的顺序初始化字节，赋值为十六进制值`0xAA`、`0xBB`、`0xCC`和`0xDD`。然后，它从整数的基地址开始，一次打印每个字节。你可能会认为字节会按字母顺序打印。然而，常用的CPU架构（例如x86和大多数ARM硬件）在执行示例程序时，会反向打印这些字节：
- en: '[PRE19]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: x86 CPUs store integers in a *little-endian* format—from least-significant byte
    (“little end”) to the most-significant byte in consecutive addresses. Other *big-endian*
    CPU architectures store multibyte integers in the opposite order. [Figure 4-13](ch04.xhtml#ch4fig13)
    depicts a four-byte integer in the (a) big-endian and (b) little-endian layouts.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: x86处理器以*小端*格式存储整数——从最低有效字节（“小端”）到最高有效字节，按连续地址存储。其他*大端*CPU架构则按相反顺序存储多字节整数。[图4-13](ch04.xhtml#ch4fig13)展示了一个四字节整数在（a）大端和（b）小端布局中的内存布局。
- en: '![image](../images/04fig13.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig13.jpg)'
- en: '*Figure 4-13: The memory layout of a four-byte integer in the (a) big-endian
    and (b) little-endian formats*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-13：四字节整数在（a）大端和（b）小端格式中的内存布局*'
- en: The seemingly strange “endian” terminology originates from Jonathan Swift’s
    satirical novel *Gulliver’s Travels* (1726).^([3](ch04.xhtml#fn4_3)) In the story,
    Gulliver finds himself among two empires of six-inch-tall people who are fighting
    a war over the proper method for breaking eggs. The “big-endian” empire of Blefuscu
    cracks the large end of their eggs, whereas people in the “little-endian” empire
    of Lilliput crack the small end.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 看似奇怪的“字节序”术语来源于乔纳森·斯威夫特的讽刺小说*《格列佛游记》*（1726年）。^([3](ch04.xhtml#fn4_3)) 在故事中，格列佛发现自己身处两个六英寸高的小人帝国，他们为了争夺正确的破蛋方法而发生战争。布勒弗斯库的“大端”帝国从蛋的大端开始敲破，而利立浦特的“小端”帝国则从蛋的小端开始敲破。
- en: In the computing world, whether a system is *big-endian* or *little-endian*
    typically affects only programs that communicate across machines (e.g., over a
    network). When communicating data between systems, both systems must agree on
    the byte order for the receiver to properly interpret the value. In 1980, Danny
    Cohen authored a note to the Internet Engineering Task Force (IETF) titled *On
    Holy Wars and a Plea for Peace*.^([4](ch04.xhtml#fn4_4)) In that note, Cohen adopts
    Swift’s “endian” terminology and suggests that the IETF adopts a standard byte
    order for network transmissions. The IETF eventually adopted *big-endian* as the
    “network byte order” standard.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机领域，系统是*大端*还是*小端*通常只影响跨机器通信的程序（例如，通过网络）。在系统之间传输数据时，两个系统必须就字节顺序达成一致，接收方才能正确解读数值。1980年，丹尼·科恩向互联网工程任务组（IETF）提交了一篇名为*《圣战与和平呼吁》*的备忘录。^([4](ch04.xhtml#fn4_4))
    在该备忘录中，科恩采用了斯威夫特的“字节序”术语，并建议IETF为网络传输采用标准的字节顺序。IETF最终采纳了*大端*作为“网络字节顺序”标准。
- en: The C language provides two libraries that allow a program to reorder an integer’s
    bytes^([5](ch04.xhtml#fn4_5)) for communication purposes.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: C语言提供了两个库，允许程序重新排列整数的字节顺序^([5](ch04.xhtml#fn4_5))，以便进行通信。
- en: 4.8 Real Numbers in Binary
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8 二进制中的实数
- en: While this chapter mainly focuses on binary integer representations, programmers
    often need to store real numbers, too. Storing real numbers is inherently difficult,
    and no binary encoding represents real values with perfect precision. That is,
    for any binary encoding of real numbers, there exist values that cannot be represented
    *exactly*. Irrational values like *π* clearly can’t be represented precisely,
    since their representation never terminates. Given a fixed number of bits, binary
    encodings still can’t represent some rational values within their range.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章主要关注二进制整数表示，但程序员通常也需要存储实数。存储实数本质上是困难的，且没有任何二进制编码能够完美精确地表示实值。也就是说，对于任何实数的二进制编码，都存在无法*精确*表示的值。像*π*这样的无理数显然无法精确表示，因为它们的表示永远不会终止。在给定的固定位数下，二进制编码仍然无法在其范围内表示某些有理数值。
- en: Unlike integers, which are countably infinite,^([6](ch04.xhtml#fn4_6)) the set
    of real numbers is uncountable.^([7](ch04.xhtml#fn4_7)) In other words, even for
    a narrow range of real values (e.g., between zero and one), the set of values
    within that range is so large that we can’t even begin to enumerate them. Thus,
    real number encodings typically store only approximations of values that have
    been truncated to a predetermined number of bits. Given enough bits, the approximations
    are typically precise enough for most purposes, but be careful when writing applications
    that cannot tolerate rounding.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 与可数的整数不同，实数集是不可数的。^([6](ch04.xhtml#fn4_6))^([7](ch04.xhtml#fn4_7)) 换句话说，即使是一个狭窄范围内的实数值（例如，从零到一之间），该范围内的值集也如此庞大，以至于我们甚至无法开始列举它们。因此，实数编码通常只存储经过截断的、具有预定比特数的值的近似值。只要比特数足够，近似值通常足够精确，适用于大多数用途，但在编写不能容忍四舍五入的应用程序时，需特别小心。
- en: 'The remainder of this section briefly describes two methods for representing
    real numbers in binary: *fixed-point*, which extends the binary integer format,
    and *floating-point*, which represents a large range of values at the cost of
    some extra complexity.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分简要描述了两种在二进制中表示实数的方法：*定点*，它扩展了二进制整数格式，以及*浮点*，它以一定的复杂度代价表示大范围的值。
- en: 4.8.1 Fixed-Point Representation
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.8.1 定点表示
- en: 'In a *fixed-point representation*, the position of a value’s *binary point*
    remains fixed and cannot be changed. Like a *decimal point* in a decimal number,
    the binary point indicates where the fractional portion of the number begins.
    The fixed-point encoding rules resemble the unsigned integer representation (see
    “Unsigned Binary Numbers” on [page 193](ch04.xhtml#lev2_62)), with one major exception:
    the digits after the binary point represent powers of two raised to a *negative*
    value. For example, consider the eight-bit sequence 0b000101.10 in which the first
    six bits represent whole numbers, and the remaining two bits represent the fractional
    part. [Figure 4-14](ch04.xhtml#ch4fig14) labels the digit positions and their
    individual interpretations.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在*定点表示*中，值的*二进制点*位置是固定的，无法改变。就像十进制数中的*小数点*一样，二进制点表示数字的小数部分的起始位置。定点编码规则类似于无符号整数表示（参见[第193页](ch04.xhtml#lev2_62)的“无符号二进制数字”），唯一的重大区别是：二进制点后的数字表示的是指数为*负*值的二的幂。例如，考虑八位序列0b000101.10，其中前六个位表示整数部分，剩下的两个比特表示小数部分。[图4-14](ch04.xhtml#ch4fig14)标出了数字的位置及其各自的解释。
- en: '![image](../images/04fig14.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig14.jpg)'
- en: '*Figure 4-14: The value of each digit in an eight-bit number with two bits
    after the fixed binary point*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-14：带有两个小数位的八位数中每个数字的值*'
- en: 'Applying the formula for converting 0b000101.10 to decimal shows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 应用将0b000101.10转换为十进制的公式得到：
- en: (0 × 2⁵) + (0 × 2⁴) + (0 × 2³) + (1 × 2²) + (0 × 2¹) + (1 × 2⁰) + (1 × 2^(–1))
    + (0 × 2^(–2)) = 0 + 0 + 0 + 4 + 0 + 1 + 0.5 + 0 = 5.5
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: (0 × 2⁵) + (0 × 2⁴) + (0 × 2³) + (1 × 2²) + (0 × 2¹) + (1 × 2⁰) + (1 × 2^(–1))
    + (0 × 2^(–2)) = 0 + 0 + 0 + 4 + 0 + 1 + 0.5 + 0 = 5.5
- en: 'More generally, with two bits after the binary point, the fractional portion
    of a number holds one of four sequences: 00 (.00), 01 (.25), 10 (.50), or 11 (.75).
    Thus, two fractional bits allow a fixed-point number to represent fractional values
    that are precise to 0.25 (2^(–2)). Adding a third bit increases the precision
    to 0.125 (2^(–3)), and the pattern continues similarly, with *N* bits after the
    binary point enabling 2^(*–N*) precision.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，当二进制点后有两个比特时，数字的小数部分包含以下四种序列之一：00（.00）、01（.25）、10（.50）或11（.75）。因此，两个小数位允许定点数表示精确到0.25（2^（–2））的分数值。添加第三个位将精度提高到0.125（2^（–3）），模式类似地继续下去，具有*N*位的小数部分可以实现2^（–N）精度。
- en: 'Because the number of bits after the binary point remains fixed, some computations
    with fully precise operands may produce a result that requires truncation (rounding).
    Consider the same eight-bit fixed-point encoding from the previous example. It
    precisely represents both 0.75 (0b000000.11) and 2 (0b000010.00). However, it
    cannot precisely represent the result of dividing 0.75 by 2: the computation *should*
    produce 0.375, but storing it would require a third bit after the binary point
    (0b000000.011). Truncating the rightmost 1 enables the result to fit within the
    specified format, but it yields a rounded result of 0.75 / 2 = 0.25\. In this
    example, the rounding is egregious due to the small number of bits involved, but
    even longer bit sequences will require truncation at some point.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 因为二进制点后的位数是固定的，一些完全精确的操作数计算结果可能会产生需要截断（四舍五入）的结果。考虑前一个示例中的相同八位定点编码。它精确表示了0.75（0b000000.11）和2（0b000010.00）。然而，它不能精确表示0.75除以2的结果：计算*应该*得到0.375，但存储它会需要在二进制点后多一个比特（0b000000.011）。截断最右边的1使得结果可以适应指定的格式，但这将得到一个四舍五入后的结果0.75
    / 2 = 0.25。在这个例子中，由于涉及的位数较少，四舍五入误差非常明显，但即使是更长的位序列也将需要在某个时刻进行截断。
- en: 'Even worse, rounding errors compound over the course of intermediate calculations,
    and in some cases the result of a sequence of computations might vary according
    to the order in which they’re performed. For example, consider two arithmetic
    sequences under the same eight-bit fixed-point encoding described earlier:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，四舍五入误差会在中间计算过程中累积，在某些情况下，计算序列的结果可能会根据执行顺序的不同而有所变化。例如，考虑两个在前面描述的相同八位定点编码下的算术序列：
- en: 1\. `(0.75 / 2) * 3 = 0.75`
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 1. `(0.75 / 2) * 3 = 0.75`
- en: 2\. `(0.75 * 3) / 2 = 1.00`
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 2. `(0.75 * 3) / 2 = 1.00`
- en: 'Note that the only difference between the two is the order of the multiplication
    and division operations. If no rounding were necessary, both computations should
    produce the same result (1.125). However, due to truncation occurring at different
    locations in the arithmetic, they produce different results:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两者之间唯一的区别在于乘法和除法操作的顺序。如果不需要舍入，两个计算应该得到相同的结果（1.125）。然而，由于截断发生在算术运算中的不同位置，它们会产生不同的结果：
- en: 1\. Proceeding from left to right, the intermediate result (`0.75 / 2`) gets
    rounded to 0.25 and ultimately produces 0.75 when multiplied by 3.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 从左到右进行中间计算（`0.75 / 2`），得到舍入结果 0.25，最终通过乘以 3 得到 0.75。
- en: 2\. Proceeding from left to right, the intermediate computation (`0.75` `* 3`)
    precisely yields 2.25 without any rounding. Dividing 2.25 by 2 rounds to a final
    result of 1.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 从左到右进行中间计算（`0.75` `* 3`），得到精确的结果 2.25，且没有任何舍入。将 2.25 除以 2 后，舍入得到最终结果 1。
- en: In this example, just one additional bit for the 2^(–3) place allows the example
    to succeed with full precision, but the fixed-point position we chose only allowed
    for two bits after the binary point. All the while, the high-order bits of the
    operands went entirely unused (digits *d*[2] through *d*[5] were never set to
    1). At the cost of extra complexity, an alternative representation (floating-point)
    allows the full range of bits to contribute to a value regardless of the split
    between whole and fractional parts.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，仅仅为 2^(–3) 位添加一个额外的比特，就能使例子以全精度成功，但我们选择的定点位置仅允许在二进制点后保留两个比特。与此同时，操作数的高阶比特完全没有被使用（*d*[2]
    到 *d*[5] 的数字从未被设为 1）。以额外的复杂度为代价，另一种表示方式（浮点表示）使得所有的比特都能无论整数部分与小数部分如何分割都能为数值做贡献。
- en: 4.8.2 Floating-Point Representation
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.8.2 浮点表示
- en: In a *floating-point representation*, a value’s binary point is *not* fixed
    into a predefined position. That is, the interpretation of a binary sequence must
    encode how it’s representing the split between the whole and fractional parts
    of a value. While the position of the binary point could be encoded in many possible
    ways, this section focuses on just one, the Institute of Electrical and Electronics
    Engineers (IEEE) standard 754.^([8](ch04.xhtml#fn4_8)) Almost all modern hardware
    follows the IEEE 754 standard to represent floating-point values.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *浮点表示法* 中，数值的二进制点是 *不* 固定在预定义的位置。也就是说，二进制序列的解释必须编码如何表示数值的整数部分和小数部分之间的分割。虽然二进制点的位置可以用多种方式进行编码，但本节仅关注一种方法，即电气和电子工程师协会（IEEE）754标准。^([8](ch04.xhtml#fn4_8))几乎所有现代硬件都遵循
    IEEE 754 标准来表示浮点数值。
- en: '![image](../images/04fig15.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/04fig15.jpg)'
- en: '*Figure 4-15: The 32-bit IEEE 754 floating-point standard*'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-15：32 位 IEEE 754 浮点标准*'
- en: '[Figure 4-15](ch04.xhtml#ch4fig15) illustrates the IEEE 754 interpretation
    of a 32-bit floating-point number (C’s `float` type). The standard partitions
    the bits into three regions:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-15](ch04.xhtml#ch4fig15) 说明了 IEEE 754 对 32 位浮点数（C 的 `float` 类型）的解释。该标准将比特划分为三个区域：'
- en: 1\. The low-order 23 bits (digits *d*[22] through *d*[0]) represent the *significand*
    (sometimes called the *mantissa*). As the largest region of bits, the significand
    serves as the foundation for the value, which ultimately gets altered by multiplying
    it according to the other bit regions. When interpreting the significand, its
    value implicitly follows a 1 and binary point. The fractional portion behaves
    like the fixed-point representation described in the previous section.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 低阶的 23 个比特（*d*[22] 到 *d*[0]）表示 *尾数*（有时称为 *有效数*）。作为比特的最大区域，尾数作为数值的基础，最终通过乘以其他比特区域来改变。当解释尾数时，它的值隐式地跟随
    1 和二进制点。小数部分的行为类似于前面部分描述的定点表示法。
- en: For example, if the bits of the significand contain 0b110000…0000, the first
    bit represents 0.5 (1 × 2^(–1)), the second bit represents 0.25 (1 × 2^(–2)),
    and all the remaining bits are zeros, so they don’t affect the value. Thus, the
    significand contributes 1.(0.5 + 0.25), or 1.75.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果尾数的比特为 0b110000…0000，则第一个比特表示 0.5（1 × 2^(–1)），第二个比特表示 0.25（1 × 2^(–2)），其余比特为零，因此它们不影响数值。因此，尾数贡献的是
    1.(0.5 + 0.25)，即 1.75。
- en: 2\. The next eight bits (digits *d*[30] through *d*[23]) represent the *exponent*,
    which scales the significand’s value to provide a wide representable range. The
    significand gets multiplied by 2^((exponent–127)), where the 127 is a *bias* that
    enables the float to represent both very large and very small values.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 接下来的八个位（数字 *d*[30] 到 *d*[23]）表示 *指数*，它将有效数字的值进行缩放，以提供广泛的可表示范围。有效数字会乘以2^((指数–127))，其中127是一个
    *偏置*，使得浮点数既能表示非常大的值，也能表示非常小的值。
- en: 3\. The final high-order bit (digit *d*[31]) represents the *sign bit*, which
    encodes whether the value is positive (0) or negative (1).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 最后一个高阶位（数字 *d*[31]）表示 *符号位*，它编码了值是正数（0）还是负数（1）。
- en: As an example, consider decoding the bit sequence 0b110000011011 01000000000000000000\.
    The significand portion is 01101000000000000000000, which represents 2^(–2) +
    2^(–3) + 2^(–5) = 0*.*40625, so the signifcand region contributes 1.40625\. The
    exponent is 10000011, which represents the decimal value 131, so the exponent
    contributes a factor of 2^((131–127)) (16). Finally, the sign bit is 1, so the
    sequence represents a negative value. Putting it all together, the bit sequence
    represents 1*.*40625 × 16 × –1 = –22*.*5.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑解码位序列0b110000011011 01000000000000000000。有效数字部分是01101000000000000000000，它表示2^(–2)
    + 2^(–3) + 2^(–5) = 0*.*40625，因此有效数字部分贡献了1.40625。指数部分是10000011，表示十进制值131，因此指数部分贡献了一个2^((131–127))（16）的因子。最后，符号位是1，因此该序列表示一个负值。综合来看，这个位序列表示1*.*40625
    × 16 × –1 = –22*.*5。
- en: Although clearly more complex than the fixed-point scheme described earlier,
    the IEEE floating-point standard provides additional flexibility for representing
    a wide range of values. Despite the flexibility, a floating-point format with
    a constant number of bits still can’t precisely represent every possible value.
    That is, like fixed-point, rounding problems similarly affect floating-point encodings.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管明显比前面描述的定点方案更复杂，但IEEE浮点标准提供了更多灵活性，可以表示广泛的值范围。尽管具有灵活性，固定数量的位数仍然无法精确表示每一个可能的值。也就是说，与定点一样，舍入问题同样会影响浮点编码。
- en: 4.8.3 Rounding Consequences
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.8.3 舍入后果
- en: While rounding isn’t likely to ruin most of the programs you write, real number
    rounding errors have occasionally caused some high-profile system failures. During
    the Gulf War in 1991, a rounding error caused an American Patriot missile battery
    to fail to intercept an Iraqi missile.^([9](ch04.xhtml#fn4_9)) The missile killed
    28 soldiers and left many others wounded. In 1996, the European Space Agency’s
    first launch of the Ariane 5 rocket exploded 39 seconds after taking off.^([10](ch04.xhtml#fn4_10))
    The rocket, which borrowed much of its code from the Ariane 4, triggered an overflow
    when attempting to convert a floating-point value into an integer value.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然舍入问题不太可能破坏你编写的大多数程序，但实数舍入错误偶尔会导致一些高调的系统故障。在1991年的海湾战争期间，一次舍入错误导致美国“爱国者”导弹电池未能拦截一枚伊拉克导弹。^([9](ch04.xhtml#fn4_9))
    这枚导弹导致28名士兵死亡，另有许多人受伤。1996年，欧洲航天局首次发射的阿丽亚娜5号火箭在起飞39秒后爆炸。^([10](ch04.xhtml#fn4_10))
    这枚火箭借用了大量阿丽亚娜4号的代码，在尝试将浮点数值转换为整数值时触发了溢出。
- en: 4.9 Summary
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9 小结
- en: This chapter examined how modern computers represent information using bits
    and bytes. An important takeaway is that a computer’s memory stores all information
    as binary 0’s and 1’s—it’s up to programs or the people running them to interpret
    the meaning of those bits. This chapter primarily focused on integer representations,
    beginning with unsigned (non-negative) integers before considering signed integers.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了现代计算机如何使用位和字节表示信息。一个重要的结论是，计算机的内存将所有信息存储为二进制的0和1——程序或运行它们的人负责解释这些位的含义。本章主要集中于整数表示，首先讨论了无符号（非负）整数，然后才考虑有符号整数。
- en: Computer hardware supports a variety of operations on integers, including the
    familiar addition, subtraction, multiplication, and division. Systems also provide
    bitwise operations like bitwise AND, OR, NOT, and shifting. When performing *any*
    operation, consider the number of bits used to represent the operands and result.
    If the storage space allocated to the result isn’t large enough, an overflow may
    misrepresent the resulting value.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机硬件支持对整数进行多种操作，包括常见的加法、减法、乘法和除法。系统还提供位操作，如按位与、按位或、按位非和移位。在执行 *任何* 操作时，要考虑用于表示操作数和结果的位数。如果分配给结果的存储空间不足，溢出可能会导致结果值的误表示。
- en: Finally, this chapter explored common schemes for representing real numbers
    in binary, including the standard IEEE 754 standard. Note that when representing
    floating-point values, we sacrifice precision for increased flexibility (i.e.,
    the ability to move the decimal point).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章探讨了表示实数的常见方案，包括标准的IEEE 754标准。请注意，在表示浮动小数点值时，我们牺牲了精度，以换取更大的灵活性（即移动小数点的能力）。
- en: Notes
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[1.](ch04.xhtml#rfn4_1) *[https://en.wikipedia.org/wiki/Gangnam_Style](https://en.wikipedia.org/wiki/Gangnam_Style)*'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.](ch04.xhtml#rfn4_1) *[https://zh.wikipedia.org/wiki/江南style](https://zh.wikipedia.org/wiki/江南style)*'
- en: '[2.](ch04.xhtml#rfn4_2) *[https://en.wikipedia.org/wiki/Therac-25](https://en.wikipedia.org/wiki/Therac-25)*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.](ch04.xhtml#rfn4_2) *[https://zh.wikipedia.org/wiki/Therac-25](https://zh.wikipedia.org/wiki/Therac-25)*'
- en: '[3.](ch04.xhtml#rfn4_3) Jonathan Swift, *Gulliver’s Travels*. *[http://www.gutenberg.org/ebooks/829](http://www.gutenberg.org/ebooks/829)*'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[3.](ch04.xhtml#rfn4_3) 乔纳森·斯威夫特, *格列佛游记*。 *[http://www.gutenberg.org/ebooks/829](http://www.gutenberg.org/ebooks/829)*'
- en: '[4.](ch04.xhtml#rfn4_4) Danny Cohen, *On Holy Wars and a Plea for Peace*. *[https://www.ietf.org/rfc/ien/ien137.txt](https://www.ietf.org/rfc/ien/ien137.txt)*'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[4.](ch04.xhtml#rfn4_4) 丹尼·科恩, *关于圣战与和平的呼吁*。 *[https://www.ietf.org/rfc/ien/ien137.txt](https://www.ietf.org/rfc/ien/ien137.txt)*'
- en: '[5.](ch04.xhtml#rfn4_5) *[https://linux.die.net/man/3/byteorder](https://linux.die.net/man/3/byteorder),
    [https://linux.die.net/man/3/endian](https://linux.die.net/man/3/endian)*'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.](ch04.xhtml#rfn4_5) *[https://linux.die.net/man/3/byteorder](https://linux.die.net/man/3/byteorder),
    [https://linux.die.net/man/3/endian](https://linux.die.net/man/3/endian)*'
- en: '[6.](ch04.xhtml#rfn4_6) *[https://en.wikipedia.org/wiki/Countable_set](https://en.wikipedia.org/wiki/Countable_set)*'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.](ch04.xhtml#rfn4_6) *[https://zh.wikipedia.org/wiki/可数集](https://zh.wikipedia.org/wiki/可数集)*'
- en: '[7.](ch04.xhtml#rfn4_7) *[https://en.wikipedia.org/wiki/Uncountable_set](https://en.wikipedia.org/wiki/Uncountable_set)*'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[7.](ch04.xhtml#rfn4_7) *[https://zh.wikipedia.org/wiki/不可数集](https://zh.wikipedia.org/wiki/不可数集)*'
- en: '[8.](ch04.xhtml#rfn4_8) *[https://en.wikipedia.org/wiki/IEEE_754](https://en.wikipedia.org/wiki/IEEE_754)*'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.](ch04.xhtml#rfn4_8) *[https://zh.wikipedia.org/wiki/IEEE_754](https://zh.wikipedia.org/wiki/IEEE_754)*'
- en: '[9.](ch04.xhtml#rfn4_9) *[http://www-users.math.umn.edu/~arnold/disasters/patriot.html](http://www-users.math.umn.edu/~arnold/disasters/patriot.html)*'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.](ch04.xhtml#rfn4_9) *[http://www-users.math.umn.edu/~arnold/disasters/patriot.html](http://www-users.math.umn.edu/~arnold/disasters/patriot.html)*'
- en: '[10.](ch04.xhtml#rfn4_10) *[https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284](https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284)*'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.](ch04.xhtml#rfn4_10) *[https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284](https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284)*'
