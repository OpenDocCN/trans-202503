- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BINARY AND DATA REPRESENTATION
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From simple stone tablets and cave paintings to written words and phonograph
    grooves, humans have perpetually sought to record and store information. In this
    chapter, we’ll characterize how the latest of humanity’s big storage breakthroughs,
    digital computing, represents information. We also illustrate how to interpret
    meaning from digital data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern computers utilize a variety of media for storing information (e.g.,
    magnetic disks, optical discs, flash memory, tapes, and simple electrical circuits).
    We characterize storage devices later in Section 11.2; however, for this discussion,
    the medium is largely irrelevant—whether there’s a laser scanning the surface
    of a DVD or a disk head gliding over a magnetic platter, the output from the storage
    device is ultimately a sequence of electrical signals. To simplify the circuitry,
    each signal is *binary*, meaning that it can take only one of two states: the
    absence of a voltage (interpreted as zero) and the presence of a voltage (one).
    This chapter explores how systems encode information into binary, regardless of
    the original storage medium.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In binary, each signal corresponds to one *bit* (binary digit) of information:
    a zero or a one. It may be surprising that all data can be represented using just
    zeros and ones. Of course, as the complexity of information increases, so does
    the number of bits needed to represent it. Luckily, the number of unique values
    doubles for each additional bit in a bit sequence, so a sequence of *N* bits can
    represent 2^(*N*) unique values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](ch04.xhtml#ch4fig1) illustrates the growth in the number of representable
    values as the length of a bit sequence increases. A single bit can represent *two*
    values: 0 and 1\. Two bits can represent *four* values: both of the one-bit values
    with a leading 0 (00 and 01), and both of the one-bit values with a leading 1
    (10 and 11). The same pattern applies for any additional bit that extends an existing
    bit sequence: the new bit can be a 0 or 1, and in either case, the remaining bits
    represent the same range of values they did prior to the new bit being added.
    Thus, adding additional bits exponentially increases the number of values the
    new sequence can represent.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: The values that can be represented with one to four bits. The
    underlined bits correspond to the prefix coming from the row above.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because a single bit doesn’t represent much information, storage systems commonly
    group bits into longer sequences for storing more interesting values. The most
    ubiquitous grouping is a *bytes*, which is a collection of eight bits. One byte
    represents 2⁸ = 256 unique values (0–255)—enough to enumerate the letters and
    common punctuation symbols of the English language. Bytes are the smallest unit
    of addressable memory in a computer system, meaning that a program can’t ask for
    fewer than eight bits to store a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern CPUs also typically define a *word* as either 32 bits or 64 bits, depending
    on the design of the hardware. The size of a word determines the “default” size
    a system’s hardware uses to move data from one component to another (e.g., between
    memory and registers). These larger sequences are necessary for storing numbers,
    since programs often need to count higher than 256! If you’ve programmed in C,
    you know that you must declare a variable before using it (see “Variables and
    C Numeric Types” on [page 21](ch01.xhtml#lev3_2)). Such declarations inform the
    C compiler of two important properties regarding the variable’s binary representation:
    the number of bits to allocate for it, and the way in which the program intends
    to interpret those bits. Conceptually, the number of bits is straightforward,
    as the compiler simply looks up how many bits are associated with the declared
    type (e.g., a `char` is one byte—see “C Numeric Types” on [page 23](ch01.xhtml#lev3_2))
    and associates that amount of memory with the variable. The interpretation of
    a sequence of bits is much more conceptually interesting. All data in a computer’s
    memory is stored as bits, but bits have no *inherent* meaning. For example, even
    with just a single bit, you could interpret the bit’s two values in many different
    ways: up and down, black and white, yes and no, on and off, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending the length of a bit sequence expands the range of its interpretations.
    For example, a `char` variable uses the American Standard Code for Information
    Interchange (ASCII) encoding standard, which defines how an eight-bit binary value
    corresponds to English letters and punctuation symbols. [Table 4-1](ch04.xhtml#ch4tab1)
    shows a small subset of the ASCII standard (for a full reference, run `man ascii`
    on the command line). There’s no special reason why the character `’X’` needs
    to correspond to 01011000, so don’t bother memorizing the table. What matters
    is that every program storing letters agrees on their bit sequence interpretation,
    which is why ASCII is defined by a standards committee.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** A Small Snippet of the Eight-Bit ASCII Character Encoding Standard'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binary value** | **Character interpretation** | **Binary value** | **Character
    interpretation** |'
  prefs: []
  type: TYPE_TB
- en: '| 01010111 | W | 00100000 | space |'
  prefs: []
  type: TYPE_TB
- en: '| 01011000 | X | 00100001 | ! |'
  prefs: []
  type: TYPE_TB
- en: '| 01011001 | Y | 00100010 | " |'
  prefs: []
  type: TYPE_TB
- en: '| 01011010 | Z | 00100011 | # |'
  prefs: []
  type: TYPE_TB
- en: Any information can be encoded in binary, including rich data like graphics
    and audio. For example, suppose that an image encoding scheme defines 00, 01,
    10, and 11 to correspond to the colors white, orange, blue, and black. [Figure
    4-2](ch04.xhtml#ch4fig2) illustrates how we might use this simple two-bit encoding
    strategy to draw a crude image of a fish using only 12 bytes. In part (a), each
    cell of the image equates to one two-bit sequence. Parts (b) and (c) show the
    corresponding binary encoding as two-bit and byte sequences, respectively. Although
    this example encoding scheme is simplified for learning purposes, the general
    idea is similar to what real graphics systems use, albeit with many more bits
    for a wider range of colors.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: The (a) image representation, (b) two-bit cell representation,
    and (c) byte representation of a simple fish image.*'
  prefs: []
  type: TYPE_NORMAL
- en: Having just introduced two encoding schemes, the same bit sequence, 01011010,
    might mean the character `’Z’` to a text editor, whereas a graphics program might
    interpret it as part of a fish’s tail fin. Which interpretation is correct depends
    on the context. Despite the underlying bits being the same, humans often find
    some interpretations much easier to comprehend than others (e.g., perceiving the
    fish as colored cells rather than a table of bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of this chapter largely deals with representing and manipulating
    binary numbers, but the overall point bears repeating: all information is stored
    in a computer’s memory as 0s and 1s, and it’s up to programs or the people running
    them to interpret the meaning of those bits.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Number Bases and Unsigned Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having seen that binary sequences can be interpreted in all sorts of nonnumerical
    ways, let’s turn our attention to numbers. Specifically, we’ll start with *unsigned*
    numbers, which can be interpreted as zero or positive, but they can never be negative
    (they have no *sign*).
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1 Decimal Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rather than starting with binary, let’s first examine a number system we’re
    already comfortable using, the *decimal number system*, which uses a *base* of
    10\. *Base 10* implies two important properties for the interpretation and representation
    of decimal values.
  prefs: []
  type: TYPE_NORMAL
- en: First, any individual digit in a base 10 number stores one of 10 unique values
    (0–9). To store a value larger than 9, the value must *carry* to an additional
    digit to the left. For example, if one digit starts at its maximum value (9) and
    we add 1 to it, the result requires two digits (9 + 1 = 10). The same pattern
    holds for any digit, regardless of its position within a number (e.g., 50**8**0
    + **2**0 = 5**10**0).
  prefs: []
  type: TYPE_NORMAL
- en: Second, the position of each digit in the number determines how important that
    digit is to the overall value of the number. Labeling the digits from *right to
    left* as *d*[0], *d*[1], *d*[2], etc., each successive digit contributes a factor
    of *ten* more than the next. For example, take the value 8425 ([Figure 4-3](ch04.xhtml#ch4fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: The importance of each digit in a base 10 number, using names
    that you may have given to each digit in grade school.*'
  prefs: []
  type: TYPE_NORMAL
- en: For the example value 8425, the 5 in the “ones” place contributes 5 (5 × 10⁰).
    The 2 in the “tens” place contributes 20 (2 × 10¹). The 4 in the “hundreds” place
    contributes 400 (4 × 10²), and, finally, the 8 in the “thousands” place contributes
    8000 (8 × 10³). More formally, one could express 8425 as
  prefs: []
  type: TYPE_NORMAL
- en: (8 × 10³) + (4 × 10²) + (2 × 10¹) + (5 × 10⁰)
  prefs: []
  type: TYPE_NORMAL
- en: This pattern of increasing exponents applied to a base of 10 is the reason why
    it’s called a *base 10* number system. Assigning position numbers to digits from
    right to left starting with *d*[0] implies that each digit *d*[*i*] contributes
    10^(*i*) to the overall value. Thus, the overall value of any *N*-digit decimal
    number can be expressed as
  prefs: []
  type: TYPE_NORMAL
- en: (*d*[*N*–1] × 10^(*N*–1)) + (*d*[*N*–2] × 10^(*N*–2)) + … + (*d*[2] × 10²) +
    (*d*[1] × 10¹) + (*d*[0] × 10⁰)
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, as we’ll soon see, a very similar pattern applies to other number
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note DISTINGUISHING NUMBER BASES**'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re about to introduce a second number system, one potential problem
    is a lack of clarity regarding how to interpret a number. For example, consider
    the value 1000\. It’s not immediately obvious whether you should interpret that
    number as a decimal value (i.e., one thousand) or a binary value (i.e., eight,
    for reasons explained soon). To help clarify, the remainder of this chapter will
    explicitly attach a prefix to all nondecimal numbers. We’ll soon introduce binary,
    for which the prefix is 0b, and hexadecimal, which uses a prefix of 0x.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you see 1000, you should assume it’s a decimal “one thousand,”
    and if you see 0b1000, you should interpret it as a binary number, in this case
    the value “eight.”
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 Unsigned Binary Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While you may never have considered the specific formula describing decimal
    numbers as powers of 10, the concept of {*ones*, *tens*, *hundreds*, etc.} places
    should hopefully feel comfortable. Luckily, similar terminology applies to other
    number systems, like binary. Of course, the base is different in other number
    systems, so each digit position contributes a different amount to its numerical
    value.
  prefs: []
  type: TYPE_NORMAL
- en: A *binary number system* uses a base of 2 instead of decimal’s 10\. Analyzing
    it the same way that we just did for decimal reveals several parallels (with 2
    substituted for 10).
  prefs: []
  type: TYPE_NORMAL
- en: First, any individual bit in a base 2 number stores one of two unique values
    (0 or 1). To store a value larger than 1, the binary encoding must *carry* to
    an additional bit to the left. For example, if one bit starts at its maximum value
    (1) and we add 1 to it, the result requires two bits (1 + 1 = 0b10). The same
    pattern holds for any bit, regardless of its position within a number (e.g., 0b100**1**00
    + 0b**1**00 = 0b10**10**00).
  prefs: []
  type: TYPE_NORMAL
- en: Second, the position of each bit in the number determines how important that
    bit is to the numerical value of the number. Labeling the digits from *right to
    left* as *d*[0], *d*[1], *d*[2], etc., each successive bit contributes a factor
    of *two* more than the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first point implies that counting in binary follows the same pattern as
    decimal: by simply enumerating the values and adding digits (bits). Since this
    section focuses on *unsigned* numbers (zero and positives only), it’s natural
    to start counting from zero. [Table 4-2](ch04.xhtml#ch4tab2) shows how to count
    the first few natural numbers in binary. As you can see from the table, counting
    in binary quickly increases the number of digits. Intuitively, this growth makes
    sense, since each binary digit (two possible values) represents less information
    than a decimal digit (10 possible values).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-2:** A Comparison of Counting in Binary versus Decimal'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binary value** | **Decimal value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| ... | ... |'
  prefs: []
  type: TYPE_TB
- en: 'The second point about labeling digits looks really familiar! In fact, it’s
    so similar to decimal that it leads to a nearly identical formula for interpreting
    a binary number. Simply replace the 10 at the base of each exponent with a 2:'
  prefs: []
  type: TYPE_NORMAL
- en: (*d*[*N*–1] × 2^(*N*–1)) + (*d*[*N*–2] × 2^(*N*–2)) + … + (*d*[2] × 2²) + (*d*[1]
    × 2¹) + (*d*[0] × 2⁰)
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying this formula yields the *unsigned* interpretation of any binary number.
    For example, take 0b1000:'
  prefs: []
  type: TYPE_NORMAL
- en: (1 × 2³) + (0 × 2²) + (0 × 2¹) + (0 × 2⁰) = 8 + 0 + 0 + 0 = 8
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a longer one-byte example, 0b10110100:'
  prefs: []
  type: TYPE_NORMAL
- en: (1 × 2⁷) + (0 × 2⁶) + (1 × 2⁵) + (1 × 2⁴) + (0 × 2³) + (1 × 2²) + (0 × 2¹) +
    (0 × 2⁰) = 128 + 0 + 32 + 16 + 0 + 4 + 0 + 0 = 180
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.3 Hexadecimal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Thus far, we’ve examined two number systems, decimal and binary. Decimal is
    notable due to its comfort for humans, whereas binary matches the way data is
    stored in hardware. It’s important to note that they are equivalent in their expressive
    power. That is, there’s no number you can represent in one system that you can’t
    represent in the other. Given their equivalence, it may surprise you that we’re
    going to discuss one more number system: the base 16 *hexadecimal* system.'
  prefs: []
  type: TYPE_NORMAL
- en: With two perfectly good number systems, you may wonder why we need another.
    The answer is primarily convenience. As shown in [Table 4-2](ch04.xhtml#ch4tab2),
    binary bit sequences quickly grow to a large number of digits. Humans tend to
    have a tough time making sense of long sequences containing only 0’s and 1’s.
    And whereas decimal is more compact, its base of 10 is a mismatch with binary’s
    base 2.
  prefs: []
  type: TYPE_NORMAL
- en: Decimal doesn’t easily capture the range that can be expressed using a fixed
    number of bits. For example, suppose that an old computer uses 16-bit memory addresses.
    It’s valid addresses range from 0b0000000000000000 to 0b1111111111111111\. Represented
    in decimal, the addresses range from 0 to 65535\. Clearly, the decimal representations
    are more compact than the long binary sequences, but unless you memorize their
    conversions, it’s more difficult to reason about the decimal numbers. Both problems
    only get worse on modern devices, which use 32- or 64-bit addresses!
  prefs: []
  type: TYPE_NORMAL
- en: These long bit sequences are where hexadecimal’s base 16 shines. The large base
    allows each digit to represent enough information for hexadecimal numbers to be
    compact. Furthermore, because the base is itself a power of two (2⁴ = 16), it’s
    easy to map hexadecimal to binary, and vice versa. For the sake of completeness,
    let’s analyze hexadecimal in the same way as decimal and binary.
  prefs: []
  type: TYPE_NORMAL
- en: First, any individual digit in a base 16 number stores one of 16 unique values.
    Any more than 10 values presents a new challenge for hexadecimal—traditional base
    10 digits stop at a maximum value of 9\. By convention, hexadecimal uses letters
    to represent values larger than 9, with A for 10, B for 11, up to F for 15\. Like
    the other systems, to store a value larger than 15, the number must *carry* to
    an additional digit to the left. For example, if one digit starts at its maximum
    value (F) and we add 1 to it, the result requires two digits (0xF + 0x1 = 0x10;
    note that we use 0x to indicate hexadecimal numbers).
  prefs: []
  type: TYPE_NORMAL
- en: Second, the position of each digit in the number determines how important that
    digit is to the numerical value of the number. Labeling the digits from *right
    to left* as *d*[0], *d*[1], *d*[2], etc., each successive digit contributes a
    factor of 16 more than the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsurprisingly, the same trusty formula for interpreting a number applies to
    hexadecimal, with 16 as the base:'
  prefs: []
  type: TYPE_NORMAL
- en: (*d*[*N*–1] × 16^(*N*–1)) + (*d*[*N*–2] × 16^(*N*–2)) + … + (*d*[2] × 16²) +
    (*d*[1] × 16¹) + (*d*[0] × 16⁰)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to determine the decimal value of 0x23C8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0196-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Warning HEXADECIMAL MISCONCEPTION**'
  prefs: []
  type: TYPE_NORMAL
- en: You may not encounter hexadecimal numbers frequently as you’re first learning
    about systems programming. In fact, the only context where you’re likely to find
    them is in representing memory addresses. For example, if you print the address
    of a variable using the `%p` (pointer) format code for `printf`, you’ll get hexadecimal
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Many students often begin to equate memory addresses (e.g., C pointer variables)
    with hexadecimal. While you may get used to seeing addresses represented that
    way, keep in mind that *they are still stored using binary in the hardware*, just
    like all other data!
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4 Storage Limitations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Conceptually, there are infinitely many unsigned integers. In practice, a programmer
    must choose how many bits to dedicate to a variable *prior to storing it*, for
    a variety of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Before storing a value, a program must allocate storage space for it. In C,
    declaring a variable tells the compiler how much memory it needs based on its
    type (see “C Numeric Types” on [page 24](ch01.xhtml#lev3_2)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware storage devices have finite capacity. Whereas a system’s main memory
    is typically large and unlikely to be a limiting factor, storage locations inside
    the CPU that are used as temporary “scratch space” (i.e., registers, see “CPU
    Register” on [page 260](ch05.xhtml#lev3_51)) are more constrained. A CPU uses
    registers that are limited to its word size (typically 32 or 64 bits, depending
    on the CPU architecture).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs often move data from one storage device to another (e.g., between CPU
    registers and main memory). As values get larger, storage devices need more wires
    to communicate signals between them. Hence, expanding storage increases the complexity
    of the hardware and leaves less physical space for other components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of bits used to store an integer dictates the range of its representable
    values. [Figure 4-4](ch04.xhtml#ch4fig4) depicts how we might conceptualize infinite
    and finite unsigned integer storage spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Illustrations of (a) an infinite unsigned number line and (b)
    a finite unsigned number line. The latter “wraps around” at either endpoint (overflow).*'
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to store a larger value to a variable than the variable’s size allows
    is known as *integer overflow*. This chapter defers the details of overflow to
    a later section (see “Integer Overflow” on [page 211](ch04.xhtml#lev1_32)). For
    now, think of it like a car’s odometer that “rolls over” back to zero if it attempts
    to increase beyond its maximum value. Similarly, subtracting one from zero yields
    the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, a natural question to ask about unsigned binary is “What’s the
    largest positive value that *N* bits can store?” In other words, given a sequence
    of *N* bits that are all 1, what value does the sequence represent? Reasoning
    about this question informally, the analysis in the previous section shows that
    *N* bits yield 2^(*N*) unique bit sequences. Since one of those sequences must
    represent the number 0, that leaves 2^(*N*) – 1 positive values ranging from 1
    to 2^(*N*) – 1\. Thus, the maximum value for an unsigned binary number of *N*
    bits must be 2^(*N*) – 1.
  prefs: []
  type: TYPE_NORMAL
- en: For example, 8 bits provide 2⁸ = 256 unique sequences. One of those sequences,
    0b00000000, is reserved for 0, leaving 255 sequences for storing positive values.
    Therefore, an 8-bit variable represents the positive values 1 through 255, the
    largest of which is 255.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Converting Between Bases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re likely to encounter each of the three number bases we’ve introduced in
    this chapter in different contexts. In some cases, you may need to convert from
    one base to another. This section starts by showing how to convert between binary
    and hexadecimal, since those two map easily to each other. After that, we’ll explore
    conversions to and from decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Converting Between Binary and Hexadecimal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because the bases for both binary and hexadecimal are powers of 2, converting
    between the two is relatively straightforward. Specifically, each hexadecimal
    digit holds one of 16 unique values, and four bits also represents 2⁴ = 16 unique
    values, making their expressive power equivalent. [Table 4-3](ch04.xhtml#ch4tab3)
    enumerates the one-to-one mapping between any sequence of four bits and any single
    hexadecimal digit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-3:** The Correspondence Between All Four-Bit Sequences and One-Digit
    Hexadecimal Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binary** | **Hexadecimal** | **Binary** | **Hexadecimal** |'
  prefs: []
  type: TYPE_TB
- en: '| 0000 | 0 | 1000 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 0001 | 1 | 1001 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 0010 | 2 | 1010 | A |'
  prefs: []
  type: TYPE_TB
- en: '| 0011 | 3 | 1011 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 0100 | 4 | 1100 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 0101 | 5 | 1101 | D |'
  prefs: []
  type: TYPE_TB
- en: '| 0110 | 6 | 1110 | E |'
  prefs: []
  type: TYPE_TB
- en: '| 0111 | 7 | 1111 | F |'
  prefs: []
  type: TYPE_TB
- en: Note that the content of [Table 4-3](ch04.xhtml#ch4tab3) is equivalent to simply
    counting from 0 to 15 in both number systems, so there’s no need to memorize it.
    Armed with this mapping, you can convert any number of consecutive bits or hex
    digits in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert 0xB491 to binary, simply substitute the corresponding binary value
    for each hexadecimal digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert 0b1111011001 to hexadecimal, first divide up the bits into chunks
    of four, from *right to left*. If the leftmost chunk doesn’t have four bits, you
    can pad with leading zeros. Then, substitute the corresponding hexadecimal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 4.2.2 Converting to Decimal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Fortunately, converting values to decimal is what we’ve been doing throughout
    previous sections of this chapter. Given a number in *any* base *B*, labeling
    the digits from *right to left* as *d*[0], *d*[1], *d*[2], etc. enables a general
    formula for converting values to decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: (*d*[*N*–1] × B^(*N*–1)) + (*d*[*N*–2] × B^(*N*–2)) + … + (*d*[2] × *B*²) +
    (*d*[1] × *B*¹) + (*d*[0] × *B*⁰)
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.3 Converting from Decimal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting from decimal to other systems requires a little more work. Informally,
    the goal is to do the reverse of the previous formula: determine the value of
    each digit such that, based on the position of the digit, adding each term results
    in the source decimal number. It may help to think about each digit in the target
    base system in the same way that we described the places (e.g., the “ones” place,
    the “tens” place, etc.) for decimal. For example, consider converting from decimal
    to hexadecimal. Each digit of a hexadecimal number corresponds to an increasingly
    large power of 16, and [Table 4-4](ch04.xhtml#ch4tab4) lists the first few powers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-4:** Powers of 16'
  prefs: []
  type: TYPE_NORMAL
- en: '| **16**⁴ | **16**³ | **16**² | **16**¹ | **16**⁰ |'
  prefs: []
  type: TYPE_TB
- en: '| 65536 | 4096 | 256 | 16 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'For example, to convert 9742 to hexadecimal, consider:'
  prefs: []
  type: TYPE_NORMAL
- en: How many multiples of 65536 fit into 9742? (In other words, what is the value
    of the “65536s” place?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting hexadecimal value doesn’t need any multiples of 65536, since
    the value (9742) is smaller than 65536, so *d*[4] should be set to 0\. Note that
    by the same logic, all higher-numbered digits will also be 0 because each digit
    would contribute values even larger than 65536\. Thus far, the result contains
    only:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| 0 |  |  |  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: How many multiples of 4096 fit into 9742? (In other words, what is the value
    of the “4096s” place?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4096 fits into 9742 twice (2 × 4096 = 8192), so the value of *d*[3] should be
    2\. Thus, *d*[3] will contribute 8192 to the overall value, so the result must
    still account for 9742 − 8192 = 1550.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| 0 | 2 |  |  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: How many multiples of 256 fit into 1550? (In other words, what is the value
    of the “256s” place?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 256 fits into 1550 six times (6 × 256 = 1536), so the value of *d*[2] should
    be 6, leaving 1550 − 1536 = 14.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| 0 | 2 | 6 |  |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: How many multiples of 16 fit into 14? (In other words, what is the value of
    the “sixteens” place?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None, so *d*[1] must be 0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| 0 | 2 | 6 | 0 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Finally, how many multiples of 1 fit into 14? (In other words, what is the value
    of the “ones” place?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answer is 14, of course, which hexadecimal represents with the digit E.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| 0 | 2 | 6 | 0 | E |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| *d*[4] | *d*[3] | *d*[2] | *d*[1] | *d*[0] |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Thus, decimal 9742 corresponds to 0x260E.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decimal to Binary: Powers of Two'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The same procedure works for binary, as well (or any other number system), provided
    that you use powers of the appropriate base. [Table 4-5](ch04.xhtml#ch4tab5) lists
    the first few powers of two, which will help to convert the example decimal value
    422 to binary.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-5:** Powers of Two'
  prefs: []
  type: TYPE_NORMAL
- en: '| **2**⁸ | **2**⁷ | **2**⁶ | **2**⁵ | **2**⁴ | **2**³ | **2**² | **2**¹ | **2**⁰
    |'
  prefs: []
  type: TYPE_TB
- en: '| 256 | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Since an individual bit is only allowed to store a 0 or 1, the question is
    no longer “How many multiples of each power fit within a value?” when converting
    to binary. Instead, ask a simpler question: “Does the next power of two fit?”
    For example, in converting 422:'
  prefs: []
  type: TYPE_NORMAL
- en: 256 fits into 422, so *d*[8] should be a 1\. That leaves 422 − 256 = 166.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 128 fits into 166, so *d*[7] should be a 1\. That leaves 166 − 128 = 38.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 64 does not fit into 38, so *d*[6] should be a 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32 fits into 38, so *d*[5] should be a 1\. That leaves 38 − 32 = 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 16 does not fit into 6, so *d*[4] should be a 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 does not fit into 6, so *d*[3] should be a 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 fits into 6, so *d*[2] should be a 1\. That leaves 6 − 4 = 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 fits into 2, so *d*[1] should be a 1\. That leaves 2 − 2 = 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(Note: upon reaching 0, all remaining digits will always be 0.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 does not fit into 0, so *d*[0] should be a 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, decimal 422 corresponds to 0b110100110.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decimal to Binary: Repeated Division'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The method we just described generally works well for students who are familiar
    with the relevant powers of two (e.g., for 422, the converter must recognize that
    it should start at *d*[8] because 2⁹ = 512 is too large).
  prefs: []
  type: TYPE_NORMAL
- en: An alternative method doesn’t require knowing powers of two. Instead, this method
    builds a binary result by checking the parity (even or odd) status of a decimal
    number and repeatedly dividing it by two (rounding halves down) to determine each
    successive bit. Note that it builds the resulting bit sequence from *right to
    left*. If the decimal value is even, the next bit should be a zero; if it’s odd,
    the next bit should be a one. When the division reaches zero, the conversion is
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when converting 422:'
  prefs: []
  type: TYPE_NORMAL
- en: 422 is even, so *d*[0] should be a 0\. (This is the rightmost bit.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 422/2 = 211, which is odd, so *d*[1] should be a 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 211/2 = 105, which is odd, so *d*[2] should be a 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 105/2 = 52, which is even, so *d*[3] should be a 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 52/2 = 26, which is even, so *d*[4] should be a 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 26/2 = 13, which is odd, so *d*[5] should be a 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13/2 = 6, which is even, so *d*[6] should be a 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6/2 = 3, which is odd, so *d*[7] should be a 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3/2 = 1, which is odd, so *d*[8] should be a 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1/2 = 0, so any digit numbered nine or above will be 0, and the algorithm terminates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As expected, this method produces the same binary sequence: 0b110100110.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Signed Binary Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve limited the discussion of binary numbers to *unsigned* (strictly
    non-negative) integers. This section presents an alternative interpretation of
    binary that incorporates negative numbers. Given that a variable has finite storage
    space, a signed binary encoding must distinguish between negative values, zero,
    and positive values. Manipulating signed numbers additionally requires a procedure
    for negating a number.
  prefs: []
  type: TYPE_NORMAL
- en: A signed binary encoding must divide bit sequences between negative and non-negative
    values. In practice, systems designers build *general-purpose* systems, so a 50%
    / 50% split is a good middle-of-the-road choice. Therefore, the signed number
    encodings that this chapter presents represent an equal number of negative and
    non-negative values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note NON-NEGATIVE VERSUS POSITIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that there’s a subtle but important difference between *non-negative* and
    *positive*. The set of strictly positive values excludes zero, whereas the non-negative
    set includes zero. Even after dividing the available bit sequences 50% / 50% between
    negative and non-negative values, one of the non-negative values must still be
    reserved for zero. Thus, with a fixed number of bits, a number system may end
    up representing more negative values than positive values (e.g., in the two’s
    complement system).
  prefs: []
  type: TYPE_NORMAL
- en: Signed number encodings use one bit to distinguish between the sets of *negative*
    numbers and *non-negative* numbers. By convention, the leftmost bit indicates
    whether a number is negative (1) or non-negative (0). This leftmost bit is known
    as the *high-order bit* or the *most significant bit*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents two potential signed binary encodings—*signed magnitude*
    and *two’s complement*. Even though only one of these encodings (two’s complement)
    is still used in practice, comparing them will help to illustrate their important
    characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.1 Signed Magnitude
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *signed magnitude* representation treats the high-order bit exclusively
    as a sign bit. That is, whether the high-order bit is a 0 or a 1 does not affect
    the absolute value of the number, it determines *only* whether the value is positive
    (high-order bit 0) or negative (high-order bit 1). Compared to two’s complement,
    signed magnitude makes the decimal conversion and negation procedures relatively
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute a decimal value for an *N*-bit signed magnitude sequence, compute
    the value of digits *d*[0] through *d*[*N–*2] using the familiar unsigned method
    from “Unsigned Binary Numbers” on [page 193](ch04.xhtml#lev2_62). Then, check
    the most significant bit, *d*[*N–*1]: if it’s 1, the value is negative; otherwise
    it isn’t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To negate a value, simply flip the most significant bit to change its sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning NEGATION MISCONCEPTION**'
  prefs: []
  type: TYPE_NORMAL
- en: Signed magnitude is presented purely for pedagogical purposes. Although it was
    used by some machines in the past (e.g., IBM’s 7090 in the 1960s), no modern systems
    use signed magnitude to represent integers (although a similar mechanism *is*
    part of the standard for storing floating-point values).
  prefs: []
  type: TYPE_NORMAL
- en: Unless you’re explicitly asked to consider signed magnitude, you should *not*
    assume that flipping the first bit of a binary number will negate that number’s
    value on a modern system.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-5](ch04.xhtml#ch4fig5) shows how four-bit signed magnitude sequences
    correspond to decimal values. At first glance, signed magnitude might seem attractive
    due to its simplicity. Unfortunately, it suffers from two major drawbacks that
    make it unappealing. The first is that it presents *two* representations of zero.
    For example, with four bits, signed magnitude represents both *zero* (0b0000)
    and *negative zero* (0b1000). Consequently, it poses a challenge to hardware designers
    because the hardware will need to account for two possible binary sequences that
    are numerically equal despite having different bit values. The hardware designer’s
    job is much easier with just one way of representing such an important number.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: A logical layout of signed magnitude values for bit sequences
    of length four*'
  prefs: []
  type: TYPE_NORMAL
- en: The other drawback of signed magnitude is that it exhibits an inconvenient discontinuity
    between negative values and zero. While we’ll cover overflow in more detail in
    “Integer Overflow” on [page 211](ch04.xhtml#lev1_32), adding 1 to the four-bit
    sequence 0b1111 “rolls over” back to 0b0000\. With signed magnitude, this effect
    means 0b1111 (–7) + 1 might be mistaken for 0 rather than the expected –6\. This
    problem is solvable, but the solution again complicates the design of the hardware,
    essentially turning any transition between negative and non-negative integers
    into a special case that requires extra care.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, signed magnitude has largely disappeared in practice, and
    two’s complement reigns supreme.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 Two’s Complement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Two’s complement* encoding solves signed magnitude’s problems in an elegant
    way. Like signed magnitude, the high-order bit of a two’s complement number indicates
    whether or not the value should be interpreted as negative. In contrast though,
    the high-order bit also affects the value of the number. So, how can it do both?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing a decimal value for an *N*-bit two’s complement number is similar
    to the familiar unsigned method, except the high-order bit’s contribution to the
    overall value is negated. That is, for an *N*-bit two’s complement sequence, instead
    of the first bit contributing *d*[*N–*1] × 2^(*N–*1) to the sum, it contributes
    *– d*[*N–*1] × 2^(*N–*1) (note the negative sign). Therefore, if the most significant
    bit is a 1, the overall value will be negative, since that first bit contributes
    the largest absolute value to the sum. Otherwise, the first bit contributes nothing
    to the sum, and the result is non-negative. Following is the full formula:'
  prefs: []
  type: TYPE_NORMAL
- en: –(*d*[*N*–1] × 2^(*N*–1)) + (*d*[*N*–2] × 2^(*N*–2)) + … + (*d*[2] × 2²) + (*d*[1]
    × 2¹) + (*d*[0] × 2⁰)
  prefs: []
  type: TYPE_NORMAL
- en: (note the leading negative sign for just the first term!).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-6](ch04.xhtml#ch4fig6) illustrates the layout of four-bit sequences
    in two’s complement. This definition encodes just one representation of zero—a
    sequence of bits that are all 0’s. With only a single *zero* sequence, two’s complement
    represents one more negative value than positive. Using four-bit sequences as
    an example, two’s complement represents a minimum value of 0b1000 (–8), but a
    maximum value of only 0b0111 (7). Fortunately, this quirk doesn’t hinder hardware
    design and rarely causes problems for applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: A logical layout of two’s complement values for bit sequences
    of length four*'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to signed magnitude, two’s complement also simplifies the transition
    between negative numbers and zero. Regardless of the number of bits used to store
    it, a two’s complement number consisting of all ones will always hold the value
    –1\. Adding 1 to a bit sequence of all 1s “rolls over” to zero, which makes two’s
    complement convenient, since –1 + 1 *should* produce zero.
  prefs: []
  type: TYPE_NORMAL
- en: Negation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Negating a two’s complement number is slightly trickier than negating a signed
    magnitude value. To negate an *N*-bit value, determine it’s *complement* with
    respect to 2^(*N*) (this is where the encoding’s name comes from). In other words,
    to negate an *N*-bit value *X*, find a bit sequence *Y* (*X*’s complement) such
    that *X* + *Y* = 2^(*N*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there’s a quick shortcut for negating a two’s complement number
    in practice: flip all the bits and add one. For example, to negate the eight-bit
    value 13, first determine the binary value of 13 (see “Converting from Decimal”
    on [page 199](ch04.xhtml#lev2_67)). Since 13 is the sum of 8, 4, and 1, set the
    bits in positions 3, 2, and 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, “flip the bits” (change all zeros to ones, and vice versa):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, adding one yields 0b11110011\. Sure enough, applying the formula for
    interpreting a two’s complement bit sequence shows that the value is –13:'
  prefs: []
  type: TYPE_NORMAL
- en: –(1 × 2⁷) + (1 × 2⁶) + (1 × 2⁵) + (1 × 2⁴) + (0 × 2³) + (0 × 2²) + (1 × 2¹)
    + (1 × 2⁰) = –128 + 64 + 32 + 16 + 0 + 0 + 2 + 1 = –13
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re curious as to why this seemingly magical shortcut works, consider
    the eight-bit negation of 13 more formally. To find 13’s complement, solve 0b00001101
    (13) + *Y* = 0b100000000 (2⁸, which requires an extra bit to represent). The equation
    can be rearranged as *Y* = 0b100000000 – 0b00001101\. This is clearly now a subtraction
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though such a subtraction might seem daunting, we can express it in a
    way that’s easier to compute as (0b011111111 + 1) – 0b00001101\. Note that this
    change simply expresses 2⁸ (256) as (255 + 1). After that change, the arithmetic
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As it turns out, for *any* bit value *b*, 1 *– b* is equivalent to “flipping”
    that bit. Thus, the entire subtraction in the preceding example can be reduced
    to just flipping all the bits of the lower number. All that’s left is to add the
    remaining +1 from expressing 256 as 255 + 1\. Putting it all together, we can
    simply flip a value’s bits and add one to compute its complement!
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning C PROGRAMMING WITH SIGNED VERSUS UNSIGNED INTEGERS**'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to allocating space, declaring variables in C also tells the compiler
    how you’d like the variable to be interpreted. When you declare an `int`, the
    compiler interprets the variable as a signed two’s complement integer. To allocate
    an unsigned value, declare an `unsigned int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The distinction is also relevant to C in other places, like the `printf` function.
    As this chapter has been stressing throughout, a bit sequence can be interpreted
    in different ways! With `printf`, the interpretation depends on the formatting
    placeholder you use. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: int main() {
  prefs: []
  type: TYPE_NORMAL
- en: int example = -100;
  prefs: []
  type: TYPE_NORMAL
- en: /* Print example int using both signed and unsigned placeholders. */
  prefs: []
  type: TYPE_NORMAL
- en: printf("%d  %u\n", example, example);
  prefs: []
  type: TYPE_NORMAL
- en: return 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Even though this code passes `printf` the same variable (`example`) twice, it
    prints `-100 4294967196`. Be careful to interpret your values correctly!
  prefs: []
  type: TYPE_NORMAL
- en: Sign Extension
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Occasionally, you may find yourself wanting to perform an arithmetic operation
    on two numbers that are stored using different numbers of bits. For example, in
    C you may want to add a 32-bit `int` and a 16-bit `short`. In such cases, the
    smaller number needs to be *sign extended*, which is a fancy way of saying that
    its most significant bit gets repeated as many times as necessary to extend the
    length of the bit sequence to the target length. Though the compiler will take
    care of wrangling the bits for you in C, it’s still helpful to understand how
    the process works.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to extend the four-bit sequence 0b0110 (6) to an eight-bit sequence,
    take the high-order bit (0) and prepend it four times to produce the extended
    value: 0b00000110 (still 6). Extending 0b1011 (–5) to an eight-bit sequence similarly
    takes the high-order bit (this time, 1) and prepends it four times to the resulting
    extended value: 0b11111011 (still –5). To verify the correctness, consider how
    the value changes after adding each new bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As evidenced by the examples, numbers that are non-negative (high-order bit
    of zero) remain non-negative after adding zeros to the front. Likewise, negatives
    (high-order bit of one) remain negative after prepending ones to extended values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note UNSIGNED ZERO EXTENSION**'
  prefs: []
  type: TYPE_NORMAL
- en: For an unsigned value (e.g., a C variable explicitly declared with an `unsigned`
    qualifier), extending it to a longer bit sequence instead requires *zero extension*,
    since the `unsigned` qualifier prevents the value from ever being interpreted
    as negative. Zero extension simply prepends zeros to the high-order bits of the
    extended bit sequence. For example, 0b1110 (14 when interpreted as unsigned!)
    extends to 0b00001110 despite the original leading 1.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Binary Integer Arithmetic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, we presented binary representations for unsigned (“Unsigned Binary
    Numbers” on [page 193](ch04.xhtml#lev2_62)) and signed (“Unsigned Binary Numbers”
    on [page 193](ch04.xhtml#lev2_62)) integers; now we’re ready to use them in arithmetic
    operations. Fortunately, due to their encoding, it *does not matter* to the arithmetic
    procedures whether we choose to interpret the operands or result as signed or
    unsigned. This observation is great news for hardware designers because it allows
    them to build one set of hardware components that can be shared for both unsigned
    and signed operations. “Circuits” on [page 246](ch05.xhtml#lev1_41) describes
    the circuitry for performing arithmetic in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the same pencil-and-paper algorithms you learned in grade school for
    performing arithmetic on decimal numbers also work for binary numbers. Though
    the hardware might not compute them in exactly the same way, you should at least
    be able to make sense of the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.1 Addition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that in a binary number, each digit holds only 0 or 1\. Consequently,
    when adding two bits that are *both* 1, the result *carries out* to the next digit
    (e.g., 1 + 1 = 0b10, which requires two bits to represent). In practice, programs
    add multibit variables, where the result of one digit’s *carry out* influences
    the next digit by *carrying in*.
  prefs: []
  type: TYPE_NORMAL
- en: In general, when summing digits from two binary numbers (*A* and *B*), there
    are *eight* possible outcomes depending on the values of *Digit[A]*, *Digit[B]*,
    and a *Carry[in]* from the previous digit. [Table 4-6](ch04.xhtml#ch4tab6) enumerates
    the eight possibilities that may result from adding one pair of bits. The *Carry[in]*
    column refers to a carry feeding into the sum from the previous digit, and the
    *Carry[out]* column indicates whether adding the pair of digits will feed a carry
    out to the next digit.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-6:** The Eight Possible Outcomes of Adding Two Binary Digits (*A*
    and *B*) with a Potential Carry In from the Previous Digit'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Inputs** | **Outputs** |'
  prefs: []
  type: TYPE_TB
- en: '| **Digit**[**A**] | **Digit**[**B**] | **Carry**[**in**] | **Result (Sum)**
    | **Carry**[**out**] |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Consider the addition of two four-bit binary numbers. Start by lining up the
    numbers so that their corresponding digits match vertically, and then sum each
    corresponding digit in order, from the low-order digit (*d*[0]) to the high-order
    digit (*d*[3]). For example, adding 0b0010 + 0b1011:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Problem Setup** | **Worked Example** |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](../images/t0208-01.jpg) | ![image](../images/t0208-02.jpg) |'
  prefs: []
  type: TYPE_TB
- en: The example shows a 1 carrying from *d*[1] into *d*[2]. This situation is analogous
    to adding two decimal digits that sum to a value larger than 9\. For example,
    when adding 5 + 8 = 13, the resulting ones place contains 3, and a 1 carries into
    the tens place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first operand (0b0010) has a leading 0, so it represents 2 for both two’s
    complement and unsigned interpretations. The second operand (0b1011) represents
    –5 if interpreted as a signed two’s complement value. Otherwise, it represents
    11 if interpreted as an unsigned value. Fortunately, the interpretation of the
    operands doesn’t affect the steps for computing the result. That is, the computed
    result (0b1101) represents either 13 (unsigned: 2 + 11) or –3 (signed: 2 + –5),
    both of which are correct depending on the interpretation of the second operand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, a four-bit sequence represents values in the range [0, 15]
    when interpreted as *unsigned*. When interpreted as *signed*, it represents the
    range [–8, 7]. In the previous example, the result fits within the representable
    range either way, but we may not always be so lucky. For example, when adding
    0b1100 (unsigned 12) + 0b0111 (7), the answer should be 19, but four bits can’t
    represent 19:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Problem Setup** | **Worked Example** |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](../images/t0209-01.jpg) | ![image](../images/t0209-02.jpg) |'
  prefs: []
  type: TYPE_TB
- en: Note that the addition in this example carries a 1 from the most significant
    bit, a condition known as a *carry out* for the overall arithmetic operation.
    In this example, the carry out suggests that the arithmetic output needs an extra
    bit to store the intended result. However, when performing four-bit arithmetic,
    there’s nowhere to put the carry out’s extra bit, so the hardware simply drops
    or *truncates* it, leaving 0b0011 as the result. Of course, if the goal was to
    add 12 + 7, a result of 3 is likely to be surprising. The surprise is a consequence
    of *overflow*. We’ll explore how to detect overflow and why it produces the results
    that it does in “Integer Overflow” on [page 211](ch04.xhtml#lev1_32).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Multibit adder circuits also support a *carry in* that behaves like a carry
    into the rightmost digit (i.e., it serves as the *Carry[in]* input for *d*[0]).
    The carry in isn’t useful when performing addition—it’s implicitly set to 0, which
    is why it doesn’t appear in the preceding example. However, the carry in does
    become relevant for other operations that use adder circuitry, most notably subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 Subtraction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Subtraction combines two familiar operations: negation and addition. In other
    words, subtracting 7 – 3 is equivalent to expressing the operation as 7 + (–3).
    This portrayal of subtraction aligns well with how the hardware behaves—a CPU
    already contains circuits for negation and addition, so it makes sense to reuse
    those circuits rather than build an entirely new subtractor. Recall that a simple
    procedure to negate a binary number is to flip the bits and add one (see “Negation”
    on [page 205](ch04.xhtml#lev3_41)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example 0b0111 (7) – 0b0011 (3), which starts by sending the 3
    to a bit-flipping circuit. To get the “plus one,” it takes advantage of the *carry
    in* to the adder circuit. That is, rather than carrying from one digit to another,
    subtraction feeds a *carry in* to *d*[0] of the adder. Setting the carry in to
    1 increases the resulting “ones place” value by one, which is exactly what it
    needs to get the “plus one” part of the negation. Putting it all together, the
    example would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Problem Setup** | **Converted to Addition** | **Worked Example** |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](../images/t0210-01.jpg) | ![image](../images/t0210-02.jpg) | ![image](../images/t0210-03.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: While the full result of the addition carries into an extra digit, the truncated
    result (0b0100) represents the expected result (4). Unlike the previous addition
    example, a carry out from the high-order bit is not necessarily indicative of
    an overflow problem for subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing subtraction as negation followed by addition also works when subtracting
    a negative value. For example, 7 – (–3) produces 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Problem Setup** | **Converted to Addition** | **Worked Example** |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](../images/t0210-04.jpg) | ![image](../images/t0210-05.jpg) | ![image](../images/t0210-06.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: We further explore the implications of carrying out (or not) in “Integer Overflow”
    on [page 211](ch04.xhtml#lev1_32).
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.3 Multiplication and Division
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This section briefly describes binary multiplication and division with integers.
    In particular, it shows methods for computing results by hand and does not reflect
    the behavior of modern hardware. This description is not meant to be comprehensive,
    as the remainder of the chapter focuses primarily on addition and subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To multiply binary numbers, use the common pencil-and-paper strategy of considering
    one digit at a time and adding the results. For example, multiplying 0b0101 (5)
    and 0b0011 (3) is equivalent to summing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the result of multiplying *d*[0] by 0b101 (5): 0b0101 (5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the result of multiplying *d*[1] by 0b101 (5) and shifting the result to the
    left by one digit: 0b1010 (10).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: (Integer) Division
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unlike the other operations just described, division has the potential to produce
    a non-integral result. The primary thing to keep in mind when dividing integers
    is that in most languages (e.g., C, Python 2, and Java) the fractional portion
    of the result gets truncated. Otherwise, binary division uses the same long form
    method that most students learn in grade school. For example, here’s how computing
    11 / 3 produces an integer result of 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the arithmetic has produced the expected integer result, 0011
    (3), and the hardware truncates any fractional parts. If you’re interested in
    determining the integral remainder, use the modulus operator (%), e.g., 11 % 3
    = 2.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Integer Overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the number of integers is mathematically infinite, in practice, numeric
    types in a computer’s memory occupy a fixed number of bits (see “Storage Limitations”
    on [page 196](ch04.xhtml#lev2_64)). As we’ve hinted throughout this chapter, using
    a fixed number of bits implies that programs might be unable to represent values
    that they’d like to store. For example, the discussion of addition showed that
    adding two legitimate values can produce a result that can’t be represented (see
    [page 208](ch04.xhtml#table04in01)). A computation that lacks the storage to represent
    its result has *overflowed*.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.1 Odometer Analogy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To characterize overflow, consider an example from the non-computing world:
    a car’s odometer. An odometer counts the number of miles a car has driven, and
    whether it’s digital or analog, it can display only so many (base 10) digits.
    If the car drives more miles than the odometer can represent, the odometer “rolls
    over” back to zero, since the true value can’t be expressed. For example, with
    a standard six-digit odometer, the maximum value it represents is 999999\. Driving
    just one additional mile *should* display 1000000, but like the overflowing addition
    example of [page 208](ch04.xhtml#page_208), the 1 carries out from the six available
    digits, leaving only 000000.'
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, let’s continue analyzing an odometer that’s limited to just
    one decimal digit. That is, the odometer represents the range [0, 9], so after
    every 10 miles the odometer resets back to zero. Illustrating the odometer’s range
    visually, it might look like [Figure 4-7](ch04.xhtml#ch4fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: A visual depiction of a one-digit odometer’s potential values*'
  prefs: []
  type: TYPE_NORMAL
- en: Because a one-digit odometer rolls over upon reaching 10, drawing a circular
    shape emphasizes the discontinuity at the top of the circle (and *only* at the
    top). Specifically, by adding one to any value *other than nine*, the result lands
    on the expected value. On the other hand, adding one to nine jumps to a value
    that doesn’t naturally follow it (zero). More generally, when performing *any*
    arithmetic that crosses the discontinuity between nine and zero, the computation
    will overflow. For example, consider adding 8 + 4, as in [Figure 4-8](ch04.xhtml#ch4fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: The result of adding 8 + 4 with only one decimal digit. Crossing
    the discontinuity between 0 and 9 indicates that an overflow has occurred.*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the sum yields 2 instead of the expected 12\. Note that many other values
    added to 8 (e.g., 8 + 14) would also land on two, with the only difference being
    that the computations would take additional trips around the circle. Consequently,
    it doesn’t matter whether the car drives 2, 12, or 152 miles—in the end, the odometer
    will read 2 regardless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any device that behaves like an odometer performs *modular arithmetic*. In
    this case, all arithmetic is modular with respect to a modulus of 10, since one
    decimal digit represents only 10 values. Therefore, given any number of miles
    traveled, we can compute what the odometer will read by dividing the distance
    by 10 and taking the remainder as the result. If the odometer had two decimal
    digits instead of one, the modulus would change to 100, since it could represent
    a larger range of values: [0, 99]. Similarly, clocks perform modular arithmetic
    with an hour modulus of 12.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.5.2 Binary Integer Overflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Having seen a familiar form of overflow, let’s turn to binary number encodings.
    Recall that *N* bits of storage represent 2^(*N*) unique bit sequences and that
    those sequences can be interpreted in different ways (as *unsigned* or *signed*).
    Some operations that yield correct results under one interpretation may exhibit
    overflow according to the other, so the hardware needs to recognize overflow differently
    for each.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose that a machine is using four-bit sequences to compute 0b0010
    (2) – 0b0101 (5). Running this operation through the subtraction procedure (see
    “Subtraction” on [page 209](ch04.xhtml#lev2_71)) produces a binary result of 0b1101\.
    Interpreting this result as a *signed* value produces –3 (–8 + 4 + 1), the expected
    result for 2 – 5 without overflow. Alternatively, interpreting it as an *unsigned*
    value yields 13 (8 + 4 + 1), which is incorrect and clearly indicative of overflow.
    Scrutinizing this example further, it instinctively makes some sense—the result
    should be negative, and a signed interpretation allows for negatives, whereas
    unsigned does not.
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned Overflow
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Unsigned* numbers behave similarly to the decimal odometer examples given
    that both represent only non-negative values. *N* bits represent unsigned values
    in the range [0, 2^(*N*) – 1], making all arithmetic modular with respect to 2^(*N*).
    [Figure 4-9](ch04.xhtml#ch4fig9) illustrates an arrangement of the unsigned interpretations
    of four-bit sequences into a modular space.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: An arrangement of four-bit unsigned values into a modular space.
    All arithmetic is modular with respect to 2⁴ (16).*'
  prefs: []
  type: TYPE_NORMAL
- en: Given that unsigned interpretations can’t hold negative values, the discontinuity
    again sits between the maximum value and zero. Therefore, unsigned overflow results
    from any operation that crosses the divide between 2^(*N*) – 1 and 0\. Stated
    more plainly, if performing addition (which should make the result *larger*) produces
    a smaller result, the addition caused unsigned overflow. Symmetrically, if performing
    subtraction (which should make the result *smaller*) produces a larger result,
    the subtraction caused unsigned overflow.
  prefs: []
  type: TYPE_NORMAL
- en: As a shortcut for detecting unsigned overflow for addition and subtraction,
    recall the carry out ([page 208](ch04.xhtml#page_208)) and carry in ([page 209](ch04.xhtml#page_209))
    bits of those operations. A *carry out* is a carry from the most significant bit
    in the result of the computation. When set, a *carry in* increments the value
    of the result by carrying one into the least significant bit of the arithmetic
    operation. The *carry in* is only set to 1 for subtraction as part of the negation
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shortcut for unsigned arithmetic is: the carry out must match the carry
    in, otherwise the operation causes overflow. Intuitively, this shortcut works
    because:'
  prefs: []
  type: TYPE_NORMAL
- en: For addition (carry in = 0), the result should be larger than (or equal to)
    the first operand. However, if the sum requires an extra bit of storage (carry
    out = 1), then truncating that extra bit from the sum yields a smaller result
    (overflow). For example, in the unsigned four-bit number space, adding 0b1100
    (12) + 0b1101 (13) requires *five* bits to store the result 0b11001 (25). When
    truncated to only four bits, the result represents 0b1001 (9), which is smaller
    than the operands (therefore, overflow).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For subtraction (carry in = 1), the result should be smaller than (or equal
    to) the first operand. Since subtraction executes as a combination of addition
    and negation, the addition subproblem should produce a smaller result. The only
    way addition can end up with a smaller value is by truncating its sum (carry out
    = 1). If it doesn’t require truncation (carry out = 0), the subtraction yields
    a larger result (overflow).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine two examples of four-bit subtraction: one that overflows, and
    one that doesn’t. First, consider 0b0111 (7) – 0b1001 (9). The subtraction procedure
    treats this computation as:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Problem Setup** | **Converted to Addition** | **Worked Example** |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](../images/t0215-01.jpg) | ![image](../images/t0215-02.jpg) | ![image](../images/t0215-03.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: The computation *did not* carry out of *d*[3], so no truncation occurs and the
    carry in (1) fails to match the carry out (0). The result, 0b1110 (14), is larger
    than either operand and thus clearly incorrect for 7 – 9 (overflow).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, consider 0b0111 (7) – 0b0101 (5). The subtraction procedure treats this
    computation as:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Problem Setup** | **Converted to Addition** | **Worked Example** |'
  prefs: []
  type: TYPE_TB
- en: '| ![image](../images/t0215-04.jpg) | ![image](../images/t0215-05.jpg) | ![image](../images/t0215-06.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: The computation carries out a bit to *d*[4], causing the carry in (1) to match
    the carry out (1). The truncated result, 0b0010 (2), correctly represents the
    expected outcome of the subtraction operation (no overflow).
  prefs: []
  type: TYPE_NORMAL
- en: Signed Overflow
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The same intuition behind overflow applies to *signed* binary interpretations:
    there exists a discontinuity in the modular number space. However, because a signed
    interpretation allows for negatives, the discontinuity doesn’t occur around 0\.
    Recall that two’s complement (see [page 204](ch04.xhtml#lev2_69)) “rolls over”
    cleanly from –1 (0b1111 . . . 111) to 0 (0b0000 . . . 0em000). Thus, the discontinuity
    exists at the *other* end of the number space, where the largest positive value
    and smallest negative value meet.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-10](ch04.xhtml#ch4fig10) shows an arrangement of the signed interpretations
    of four-bit sequences into a modular space. Note that half of the values are negative,
    the other half are non-negative, and the discontinuity lies at the min/max divide
    between them.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: An arrangement of four-bit signed values into a modular space.
    Because a signed interpretation allows for negative values, the discontinuity
    no longer resides at zero.*'
  prefs: []
  type: TYPE_NORMAL
- en: When performing signed arithmetic, it’s always safe to generate a result that
    moves closer to zero. That is, any operation that reduces the absolute value of
    the result cannot overflow, because the overflow discontinuity resides where the
    magnitude of the representable values is the largest.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, systems detect overflow in signed addition and subtraction by
    comparing the most significant bit of the operands with the most significant bit
    of the result. For subtraction, first rearrange the arithmetic in terms of addition
    (e.g., rewrite 5 – 2 as 5 + –2).
  prefs: []
  type: TYPE_NORMAL
- en: If the addition’s operands have *different* high-order bit values (i.e., one
    operand is negative and the other is positive), there can be no signed overflow,
    because the absolute value of the result must be smaller than (or equal to) either
    operand. The result is moving *toward* zero.
  prefs: []
  type: TYPE_NORMAL
- en: If the addition’s operands have the *same* high-order bit value (i.e., both
    are positive or both are negative), then a correct result must also have the same
    high-order bit value. Thus, when adding two operands with the same sign, a signed
    overflow occurs if the result’s sign differs from that of the operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following four-bit signed binary examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*   5 – 4 is equivalent to 5 + –4\. The first operand (5) is positive, whereas
    the second (–4) is negative, so the result must be moving toward zero where *no
    overflow* is possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 4 + 2 (both positive) yields 6 (also positive), so *no overflow* occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: –5 – 1 is equivalent to –5 + –1 (both negative) and yields –6 (also negative),
    so *no overflow* occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 + 5 (both positive) yields –7 (negative). Since the operands have the same
    sign and it doesn’t match the result’s sign, this operation *overflows*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: –3 – 8 is equivalent to –3 + –8 (both negative) and yields 5 (positive). Since
    the operands have the same sign and it doesn’t match the result’s sign, this operation
    *overflows*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.5.3 Overflow Summary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In general, integer overflow occurs when an arithmetic operation moves between
    the minimum and maximum values that its result can represent. If you’re ever in
    doubt about the rules for signed versus unsigned overflow, consider the minimum
    and maximum values of an *N*-bit sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum *unsigned* value is 0 (because unsigned encodings can’t represent
    negative numbers) and the maximum unsigned value is 2^(*N*) – 1 (because one bit
    sequence is reserved for zero). Therefore the discontinuity is between 2^(*N*)
    – 1 and 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minimum *signed* value is –2^(*N–*1) (because half of the sequences are
    reserved for negative values) and the maximum is 2^(*N–*1) – 1 (because in the
    other half, one value is reserved for zero). Therefore, the discontinuity is between
    2^(*N–*1) – 1 and –2^(*N–*1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.5.4 Overflow Consequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While you may not run into integer overflow frequently, overflows have the potential
    to break programs in notable (and potentially devastating) ways.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in 2014, PSY’s popular “Gangnam Style”^([1](ch04.xhtml#fn4_1))
    music video threatened to overflow the 32-bit counter that YouTube used to track
    video hits. As a result, YouTube switched to using a 64-bit counter.
  prefs: []
  type: TYPE_NORMAL
- en: Another relatively harmless example shows up in the 1980 arcade game *Pac-Man*.
    The game’s developers used an unsigned eight-bit value to track the player’s progress
    through the game’s levels. As a result, if an expert player makes it beyond level
    255 (the maximum value of an eight-bit unsigned integer), half of the board ends
    up glitching significantly, as shown in [Figure 4-11](ch04.xhtml#ch4fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: The *Pac-Man* game board “freaks out” upon reaching level 256.*'
  prefs: []
  type: TYPE_NORMAL
- en: A much more tragic example of overflow appears in the history of the Therac-25^([2](ch04.xhtml#fn4_2))
    radiation therapy machine of the mid 1980s. The Therac-25 suffered from several
    design problems, including one that incremented a truth flag variable rather than
    setting it to a constant. After enough uses, the flag overflowed, causing it to
    erroneously roll over to zero (false) and bypass safety mechanisms. The Therac-25
    ultimately caused serious harm to (and in some cases killed) six patients.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Bitwise Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the standard arithmetic operations described earlier, CPUs also
    support operations that are uncommon outside of binary. These *bitwise operators*
    directly apply the behavior of logic gates (see “Basic Logic Gates” on [page 243](ch05.xhtml#lev2_94))
    to bit sequences, making them straightforward to implement efficiently in hardware.
    Unlike addition and subtraction, which programmers typically use to manipulate
    a variable’s numerical interpretation, programmers commonly use bitwise operators
    to modify specific bits in a variable. For example, a program might encode a certain
    bit position in a variable to hold a true/false meaning, and bitwise operations
    allow the program to manipulate the variable’s individual bits to change that
    specific bit.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 Bitwise AND
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The bitwise AND operator (`&`) evaluates two input bit sequences. For each digit
    of the inputs, it outputs a 1 in the corresponding position of the output if *both*
    inputs are 1 in that position. Otherwise, it outputs a 0 for the digit. [Table
    4-7](ch04.xhtml#ch4tab7) shows the truth table for the bitwise AND of two values,
    *A* and *B*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-7:** The Results of Bitwise ANDing Two Values (A AND B)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **B** | **A & B** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'For example, to bitwise AND 0b011010 with 0b110110, start by lining up the
    two sequences. Checking vertically through each digit, set the result of the column
    to 1 if *both* digits are 1\. Otherwise, set the result of the column to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a bitwise AND in C, place C’s bitwise AND operator (`&`) between
    two operand variables. Here’s the example again, performed in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning BITWISE OPERATIONS VERSUS LOGICAL TRUTH OPERATIONS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful not to conflate bitwise operators with logical truth operators (see
    “Boolean Values in C” on [page 32](ch01.xhtml#lev2_6)). Despite having similar
    names (AND, OR, NOT, etc.), the two *are not* the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators consider each bit of their inputs independently and produce
    an output bit sequence as a function of the specific input bits that are set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operators consider only the *truth* interpretation of their operands.
    To C, a value of zero is *false*, whereas all other values are considered *true*.
    Logical operators are often used when evaluating conditionals (e.g., `if` statements).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that C often uses similar (but slightly different) operators to distinguish
    between the two. For example, you can indicate bitwise AND and bitwise OR using
    a single `&` and `|`, respectively. Logical AND and logical OR correspond to a
    double `&&` and `||`. Finally, bitwise NOT uses `~`, whereas logical NOT is expressed
    by `!`.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.2 Bitwise OR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The bitwise OR operator (`|`) behaves like the bitwise AND operator except that
    it outputs a 1 for a digit if *either or both* of the inputs is 1 in the corresponding
    position. Otherwise, it outputs a 0 for the digit. [Table 4-8](ch04.xhtml#ch4tab8)
    shows the truth table for the bitwise OR of two values, *A* and *B*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-8:** The Results of Bitwise ORing Two Values (A OR B)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **B** | **A&#124;B** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'For example, to bitwise OR 0b011010 with 0b110110, start by lining up the two
    sequences. Checking vertically through each digit, set the result of the column
    to 1 if *either* digit is 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a bitwise OR in C, place C’s bitwise OR operator (`|`) between two
    operands. Here’s the same example again, performed in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 4.6.3 Bitwise XOR (Exclusive OR)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The bitwise XOR operator (`^`) behaves like the bitwise OR operator except that
    it outputs a 1 for a digit only if *exactly one* (but not both) of the inputs
    is 1 in the corresponding position. Otherwise, it outputs a 0 for the digit. [Table
    4-9](ch04.xhtml#ch4tab9) shows the truth table for the bitwise XOR of two values,
    *A* and *B*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-9:** The Results of Bitwise XORing Two Values (A XOR B)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **B** | **A ^ B** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'For example, to bitwise XOR 0b011010 with 0b110110, start by lining up the
    two sequences. Checking vertically through each digit, set the result of the column
    to 1 if *only one* digit is 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a bitwise XOR in C, place C’s bitwise XOR operator (`^`) between
    two operands. Here’s the same example again, performed in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 4.6.4 Bitwise NOT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The bitwise NOT operator (`~`) operates on just one operand. For each bit in
    the sequence, it simply flips the bit such that a zero becomes a one, or vice
    versa. [Table 4-10](ch04.xhtml#ch4tab10) shows the truth table for the bitwise
    NOT operator.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-10:** The Results of Bitwise NOTing a Value (A)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **A** | **~A** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'For example, to bitwise NOT 0b011010, invert the value of each bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a bitwise NOT in C, place a tilde character (`~`) in front of an
    operand. Here’s the same example again, performed in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning BITWISE NOT VERSUS NEGATION**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that all modern systems represent integers using two’s complement, so bitwise
    NOT isn’t quite the same as negation. Bitwise NOT *only* flips the bits and *doesn’t*
    add one.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.5 Bit Shifting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another important bitwise operation involves shifting the position of an operand’s
    bits either to the left (`<<`) or to the right (`>>`). Both the left and right
    shifting operators take two operands: the bit sequence to shift and the number
    of places it should be shifted.'
  prefs: []
  type: TYPE_NORMAL
- en: Shifting Left
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Shifting a sequence to the left by *N* places moves each of its bits to the
    left *N* times, appending new zeros to the right side of the sequence. For example,
    shifting the eight-bit sequence 0b00101101 to the left by two produces 0b10110100\.
    The two zeros at the right are appended to end of the sequence, since the result
    still needs to be an eight-bit sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of overflow, shifting to the left *increases* the value of the
    result , since bits move toward digits that contribute larger powers of two to
    the value of the number. However, with a fixed number of bits, any bits that shift
    into positions beyond the maximum capacity of the number get truncated. For example,
    shifting the eight-bit sequence 0b11110101 (unsigned interpretation 245) to the
    left by one produces 0b11101010 (unsigned interpretation 234). Here, the truncation
    of the high-order bit that shifted out makes the result smaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a left bit shift in C, place two less-than characters (`<<`) between
    a value and the number of places to shift that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Shifting Right
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Shifting to the right is similar to left shifting—any bits that are shifted
    out of a variable’s capacity (e.g., off the end to the right) disappear due to
    truncation. However, right shifting introduces an additional consideration: the
    new bits prepended to the left side of the result may need to be either all zeros
    or all ones depending on the *type* of the variable being shifted and its high-order
    bit value. Conceptually, the choice to prepend zeros or ones resembles that of
    sign extension (see “Sign Extension” on [page 206](ch04.xhtml#lev3_42)). Thus,
    there exist two distinct variants of right shifting:'
  prefs: []
  type: TYPE_NORMAL
- en: A *logical right shift* always prepends zeros to the high-order bits of the
    result. Logical shifting is used to shift *unsigned* variables, since a leading
    1 in the most significant bit of an unsigned value isn’t intended to mean that
    the value is negative. For example, shifting 0b10110011 to the right by two using
    a logical shift yields 0b00101100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *arithmetic right shift* prepends a copy of the shifted value’s most significant
    bit into each of the new bit positions. Arithmetic shifting applies to *signed*
    variables, for which it’s important to preserve the signedness of the high-order
    bits. For example, shifting 0b10110011 to the right by two using an arithmetic
    shift yields 0b11101100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, when programming in C, you don’t typically need to worry about
    the distinction if you’ve declared your variables properly. If your program includes
    a right shift operator (`>>`), virtually every C compiler will automatically perform
    the appropriate type of shifting according to the type of the shifting variable.
    That is, if the shifting variable was declared with the *unsigned* qualifier,
    the compiler will perform a logical shift. Otherwise, it will perform an arithmetic
    shift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note C RIGHT SHIFT EXAMPLE PROGRAM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the behavior of right shifting with a small example program like
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: int main(int argc, char **argv) {
  prefs: []
  type: TYPE_NORMAL
- en: '/* Unsigned integer value: u_val */'
  prefs: []
  type: TYPE_NORMAL
- en: unsigned int u_val = 0xFF000000;
  prefs: []
  type: TYPE_NORMAL
- en: '/* Signed integer value: s_val */'
  prefs: []
  type: TYPE_NORMAL
- en: int s_val = 0xFF000000;
  prefs: []
  type: TYPE_NORMAL
- en: printf("%08X\n", u_val >> 12);  // logical right shift
  prefs: []
  type: TYPE_NORMAL
- en: printf("%08X\n", s_val >> 12);  // arithmetic right shift
  prefs: []
  type: TYPE_NORMAL
- en: return 0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'This program declares two 32-bit integers: one as an unsigned integer (`u_val`),
    and another as a signed integer (`s_val`). It initializes both integers to the
    same starting value: a sequence of 8 ones followed by 24 zeros (`0b1111111100000000000000000000000000`),
    and then it shifts both values 12 positions to the right. When executed, it prints:'
  prefs: []
  type: TYPE_NORMAL
- en: $ ./a.out
  prefs: []
  type: TYPE_NORMAL
- en: 000FF000
  prefs: []
  type: TYPE_NORMAL
- en: FFFFF000
  prefs: []
  type: TYPE_NORMAL
- en: Because a leading 1 doesn’t indicate “negative” for the unsigned `u_val`, the
    compiler uses instructions to prepend it with only zeros. The shifted result contains
    12 zeros, 8 ones, and 12 more zeros (`0b00000000000011111111000000000000`). On
    the other hand, the leading 1 *does* indicate “negative” for `s_val`, so the compiler
    prepends 1’s to the front of the shifted value, yielding 20 ones followed by 12
    zeros (`0b11111111111111111111000000000000`).
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Integer Byte Order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, this chapter has described several schemes for encoding numbers with
    bits, but it hasn’t mentioned how the values are organized in memory. For modern
    systems, the smallest addressable unit of memory is a byte, which consists of
    eight bits. Consequently, to store a one-byte value (e.g., a variable of type
    `char`) starting at address *X*, you don’t really have any options—just store
    the byte at location *X*.
  prefs: []
  type: TYPE_NORMAL
- en: However, for multibyte values (e.g., variables of type `short` or `int`), the
    hardware has more options for assigning a value’s bytes to memory addresses. For
    example, consider a two-byte `short` variable `s` whose bytes are labeled A (containing
    the high-order bits of `s`) and B (containing the low-order bits of `s`). When
    a system is asked to store a `short` like `s` at address *X* (i.e., in addresses
    *X* and *X* + 1), it must define which byte of the variable (A or B) should occupy
    which address (*X* or *X* + 1). [Figure 4-12](ch04.xhtml#ch4fig12) shows the two
    options for storing `s` in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: Two potential memory layouts for a two-byte short starting at
    memory address *X**'
  prefs: []
  type: TYPE_NORMAL
- en: The *byte order* (or *endianness*) of a system defines how its hardware assigns
    the bytes of a multibyte variable to consecutive memory addresses. Although byte
    order is rarely an issue for programs that only run on a single system, it might
    appear surprising if one of your programs attempts to print bytes one at a time
    or if you’re examining variables with a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This program allocates a four-byte integer and initializes the bytes, in order
    from most to least significant, to the hexadecimal values `0xAA`, `0xBB`, `0xCC`,
    and `0xDD`. It then prints the bytes one at a time starting from the base address
    of the integer. You’d be forgiven for expecting the bytes to print in alphabetical
    order. However, commonly used CPU architectures (i.e., x86 and most ARM hardware)
    print the bytes in reverse order when executing the example program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: x86 CPUs store integers in a *little-endian* format—from least-significant byte
    (“little end”) to the most-significant byte in consecutive addresses. Other *big-endian*
    CPU architectures store multibyte integers in the opposite order. [Figure 4-13](ch04.xhtml#ch4fig13)
    depicts a four-byte integer in the (a) big-endian and (b) little-endian layouts.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: The memory layout of a four-byte integer in the (a) big-endian
    and (b) little-endian formats*'
  prefs: []
  type: TYPE_NORMAL
- en: The seemingly strange “endian” terminology originates from Jonathan Swift’s
    satirical novel *Gulliver’s Travels* (1726).^([3](ch04.xhtml#fn4_3)) In the story,
    Gulliver finds himself among two empires of six-inch-tall people who are fighting
    a war over the proper method for breaking eggs. The “big-endian” empire of Blefuscu
    cracks the large end of their eggs, whereas people in the “little-endian” empire
    of Lilliput crack the small end.
  prefs: []
  type: TYPE_NORMAL
- en: In the computing world, whether a system is *big-endian* or *little-endian*
    typically affects only programs that communicate across machines (e.g., over a
    network). When communicating data between systems, both systems must agree on
    the byte order for the receiver to properly interpret the value. In 1980, Danny
    Cohen authored a note to the Internet Engineering Task Force (IETF) titled *On
    Holy Wars and a Plea for Peace*.^([4](ch04.xhtml#fn4_4)) In that note, Cohen adopts
    Swift’s “endian” terminology and suggests that the IETF adopts a standard byte
    order for network transmissions. The IETF eventually adopted *big-endian* as the
    “network byte order” standard.
  prefs: []
  type: TYPE_NORMAL
- en: The C language provides two libraries that allow a program to reorder an integer’s
    bytes^([5](ch04.xhtml#fn4_5)) for communication purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 Real Numbers in Binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While this chapter mainly focuses on binary integer representations, programmers
    often need to store real numbers, too. Storing real numbers is inherently difficult,
    and no binary encoding represents real values with perfect precision. That is,
    for any binary encoding of real numbers, there exist values that cannot be represented
    *exactly*. Irrational values like *π* clearly can’t be represented precisely,
    since their representation never terminates. Given a fixed number of bits, binary
    encodings still can’t represent some rational values within their range.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike integers, which are countably infinite,^([6](ch04.xhtml#fn4_6)) the set
    of real numbers is uncountable.^([7](ch04.xhtml#fn4_7)) In other words, even for
    a narrow range of real values (e.g., between zero and one), the set of values
    within that range is so large that we can’t even begin to enumerate them. Thus,
    real number encodings typically store only approximations of values that have
    been truncated to a predetermined number of bits. Given enough bits, the approximations
    are typically precise enough for most purposes, but be careful when writing applications
    that cannot tolerate rounding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remainder of this section briefly describes two methods for representing
    real numbers in binary: *fixed-point*, which extends the binary integer format,
    and *floating-point*, which represents a large range of values at the cost of
    some extra complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.1 Fixed-Point Representation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In a *fixed-point representation*, the position of a value’s *binary point*
    remains fixed and cannot be changed. Like a *decimal point* in a decimal number,
    the binary point indicates where the fractional portion of the number begins.
    The fixed-point encoding rules resemble the unsigned integer representation (see
    “Unsigned Binary Numbers” on [page 193](ch04.xhtml#lev2_62)), with one major exception:
    the digits after the binary point represent powers of two raised to a *negative*
    value. For example, consider the eight-bit sequence 0b000101.10 in which the first
    six bits represent whole numbers, and the remaining two bits represent the fractional
    part. [Figure 4-14](ch04.xhtml#ch4fig14) labels the digit positions and their
    individual interpretations.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-14: The value of each digit in an eight-bit number with two bits
    after the fixed binary point*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the formula for converting 0b000101.10 to decimal shows:'
  prefs: []
  type: TYPE_NORMAL
- en: (0 × 2⁵) + (0 × 2⁴) + (0 × 2³) + (1 × 2²) + (0 × 2¹) + (1 × 2⁰) + (1 × 2^(–1))
    + (0 × 2^(–2)) = 0 + 0 + 0 + 4 + 0 + 1 + 0.5 + 0 = 5.5
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, with two bits after the binary point, the fractional portion
    of a number holds one of four sequences: 00 (.00), 01 (.25), 10 (.50), or 11 (.75).
    Thus, two fractional bits allow a fixed-point number to represent fractional values
    that are precise to 0.25 (2^(–2)). Adding a third bit increases the precision
    to 0.125 (2^(–3)), and the pattern continues similarly, with *N* bits after the
    binary point enabling 2^(*–N*) precision.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the number of bits after the binary point remains fixed, some computations
    with fully precise operands may produce a result that requires truncation (rounding).
    Consider the same eight-bit fixed-point encoding from the previous example. It
    precisely represents both 0.75 (0b000000.11) and 2 (0b000010.00). However, it
    cannot precisely represent the result of dividing 0.75 by 2: the computation *should*
    produce 0.375, but storing it would require a third bit after the binary point
    (0b000000.011). Truncating the rightmost 1 enables the result to fit within the
    specified format, but it yields a rounded result of 0.75 / 2 = 0.25\. In this
    example, the rounding is egregious due to the small number of bits involved, but
    even longer bit sequences will require truncation at some point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even worse, rounding errors compound over the course of intermediate calculations,
    and in some cases the result of a sequence of computations might vary according
    to the order in which they’re performed. For example, consider two arithmetic
    sequences under the same eight-bit fixed-point encoding described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. `(0.75 / 2) * 3 = 0.75`
  prefs: []
  type: TYPE_NORMAL
- en: 2\. `(0.75 * 3) / 2 = 1.00`
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the only difference between the two is the order of the multiplication
    and division operations. If no rounding were necessary, both computations should
    produce the same result (1.125). However, due to truncation occurring at different
    locations in the arithmetic, they produce different results:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Proceeding from left to right, the intermediate result (`0.75 / 2`) gets
    rounded to 0.25 and ultimately produces 0.75 when multiplied by 3.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Proceeding from left to right, the intermediate computation (`0.75` `* 3`)
    precisely yields 2.25 without any rounding. Dividing 2.25 by 2 rounds to a final
    result of 1.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, just one additional bit for the 2^(–3) place allows the example
    to succeed with full precision, but the fixed-point position we chose only allowed
    for two bits after the binary point. All the while, the high-order bits of the
    operands went entirely unused (digits *d*[2] through *d*[5] were never set to
    1). At the cost of extra complexity, an alternative representation (floating-point)
    allows the full range of bits to contribute to a value regardless of the split
    between whole and fractional parts.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.2 Floating-Point Representation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a *floating-point representation*, a value’s binary point is *not* fixed
    into a predefined position. That is, the interpretation of a binary sequence must
    encode how it’s representing the split between the whole and fractional parts
    of a value. While the position of the binary point could be encoded in many possible
    ways, this section focuses on just one, the Institute of Electrical and Electronics
    Engineers (IEEE) standard 754.^([8](ch04.xhtml#fn4_8)) Almost all modern hardware
    follows the IEEE 754 standard to represent floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/04fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-15: The 32-bit IEEE 754 floating-point standard*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-15](ch04.xhtml#ch4fig15) illustrates the IEEE 754 interpretation
    of a 32-bit floating-point number (C’s `float` type). The standard partitions
    the bits into three regions:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The low-order 23 bits (digits *d*[22] through *d*[0]) represent the *significand*
    (sometimes called the *mantissa*). As the largest region of bits, the significand
    serves as the foundation for the value, which ultimately gets altered by multiplying
    it according to the other bit regions. When interpreting the significand, its
    value implicitly follows a 1 and binary point. The fractional portion behaves
    like the fixed-point representation described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the bits of the significand contain 0b110000…0000, the first
    bit represents 0.5 (1 × 2^(–1)), the second bit represents 0.25 (1 × 2^(–2)),
    and all the remaining bits are zeros, so they don’t affect the value. Thus, the
    significand contributes 1.(0.5 + 0.25), or 1.75.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The next eight bits (digits *d*[30] through *d*[23]) represent the *exponent*,
    which scales the significand’s value to provide a wide representable range. The
    significand gets multiplied by 2^((exponent–127)), where the 127 is a *bias* that
    enables the float to represent both very large and very small values.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The final high-order bit (digit *d*[31]) represents the *sign bit*, which
    encodes whether the value is positive (0) or negative (1).
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider decoding the bit sequence 0b110000011011 01000000000000000000\.
    The significand portion is 01101000000000000000000, which represents 2^(–2) +
    2^(–3) + 2^(–5) = 0*.*40625, so the signifcand region contributes 1.40625\. The
    exponent is 10000011, which represents the decimal value 131, so the exponent
    contributes a factor of 2^((131–127)) (16). Finally, the sign bit is 1, so the
    sequence represents a negative value. Putting it all together, the bit sequence
    represents 1*.*40625 × 16 × –1 = –22*.*5.
  prefs: []
  type: TYPE_NORMAL
- en: Although clearly more complex than the fixed-point scheme described earlier,
    the IEEE floating-point standard provides additional flexibility for representing
    a wide range of values. Despite the flexibility, a floating-point format with
    a constant number of bits still can’t precisely represent every possible value.
    That is, like fixed-point, rounding problems similarly affect floating-point encodings.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8.3 Rounding Consequences
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While rounding isn’t likely to ruin most of the programs you write, real number
    rounding errors have occasionally caused some high-profile system failures. During
    the Gulf War in 1991, a rounding error caused an American Patriot missile battery
    to fail to intercept an Iraqi missile.^([9](ch04.xhtml#fn4_9)) The missile killed
    28 soldiers and left many others wounded. In 1996, the European Space Agency’s
    first launch of the Ariane 5 rocket exploded 39 seconds after taking off.^([10](ch04.xhtml#fn4_10))
    The rocket, which borrowed much of its code from the Ariane 4, triggered an overflow
    when attempting to convert a floating-point value into an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 4.9 Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter examined how modern computers represent information using bits
    and bytes. An important takeaway is that a computer’s memory stores all information
    as binary 0’s and 1’s—it’s up to programs or the people running them to interpret
    the meaning of those bits. This chapter primarily focused on integer representations,
    beginning with unsigned (non-negative) integers before considering signed integers.
  prefs: []
  type: TYPE_NORMAL
- en: Computer hardware supports a variety of operations on integers, including the
    familiar addition, subtraction, multiplication, and division. Systems also provide
    bitwise operations like bitwise AND, OR, NOT, and shifting. When performing *any*
    operation, consider the number of bits used to represent the operands and result.
    If the storage space allocated to the result isn’t large enough, an overflow may
    misrepresent the resulting value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this chapter explored common schemes for representing real numbers
    in binary, including the standard IEEE 754 standard. Note that when representing
    floating-point values, we sacrifice precision for increased flexibility (i.e.,
    the ability to move the decimal point).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch04.xhtml#rfn4_1) *[https://en.wikipedia.org/wiki/Gangnam_Style](https://en.wikipedia.org/wiki/Gangnam_Style)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch04.xhtml#rfn4_2) *[https://en.wikipedia.org/wiki/Therac-25](https://en.wikipedia.org/wiki/Therac-25)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch04.xhtml#rfn4_3) Jonathan Swift, *Gulliver’s Travels*. *[http://www.gutenberg.org/ebooks/829](http://www.gutenberg.org/ebooks/829)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch04.xhtml#rfn4_4) Danny Cohen, *On Holy Wars and a Plea for Peace*. *[https://www.ietf.org/rfc/ien/ien137.txt](https://www.ietf.org/rfc/ien/ien137.txt)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch04.xhtml#rfn4_5) *[https://linux.die.net/man/3/byteorder](https://linux.die.net/man/3/byteorder),
    [https://linux.die.net/man/3/endian](https://linux.die.net/man/3/endian)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch04.xhtml#rfn4_6) *[https://en.wikipedia.org/wiki/Countable_set](https://en.wikipedia.org/wiki/Countable_set)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch04.xhtml#rfn4_7) *[https://en.wikipedia.org/wiki/Uncountable_set](https://en.wikipedia.org/wiki/Uncountable_set)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch04.xhtml#rfn4_8) *[https://en.wikipedia.org/wiki/IEEE_754](https://en.wikipedia.org/wiki/IEEE_754)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[9.](ch04.xhtml#rfn4_9) *[http://www-users.math.umn.edu/~arnold/disasters/patriot.html](http://www-users.math.umn.edu/~arnold/disasters/patriot.html)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[10.](ch04.xhtml#rfn4_10) *[https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284](https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284)*'
  prefs: []
  type: TYPE_NORMAL
