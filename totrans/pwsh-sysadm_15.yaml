- en: '13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WORKING WITH AWS
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding chapter, you learned about using Microsoft Azure with PowerShell.
    Now let’s see what we can do with Amazon Web Services (AWS). In this chapter,
    you’ll go deep into using PowerShell with AWS. Once you’ve learned how to authenticate
    to AWS with PowerShell, you’ll learn how to create an EC2 instance from scratch,
    deploy an Elastic Beanstalk (EBS) application, and create an Amazon Relational
    Database Service (Amazon RDS) Microsoft SQL Server database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Azure, AWS is a juggernaut in the cloud world. Chances are high that if
    you’re in IT, you’ll be working with AWS in some way in your career. And as with
    Azure, there’s a handy PowerShell module for working with AWS: `AWSPowerShell`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can install `AWSPowerShell` from the PowerShell Gallery the same way you
    installed the `Az` module, by calling Install-Module AWSPowerShell. Once this
    module is downloaded and installed, you’re ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’m assuming you already have an AWS account and that you have access to the
    root user. You can sign up for an AWS free tier account at *[https://aws.amazon.com/free/](https://aws.amazon.com/free/)*.
    You won’t need to do everything as root, but you will need it to create your first
    *identity and access management* *(IAM)* user. You’ll also need to have the `AWSPowerShell`
    module downloaded and installed, as noted earlier.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In AWS, authentication is done using the IAM service, which handles authentication,
    authorization, accounting, and auditing in AWS. To authenticate to AWS, you must
    have an IAM user created under your subscription, and that user has to have access
    to the appropriate resources. The first step to working with AWS is creating an
    IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: When an AWS account is created, a root user is automatically created, so you’ll
    use the root user to create your IAM user. *Technically*, you could use the root
    user to do anything in AWS, but that is highly discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating with the Root User
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s create the IAM user you’ll use throughout the rest of the chapter. First,
    however, you need to somehow authenticate it. Without another IAM user, the only
    way to do that is with the root user. Sadly, this means you have to abandon PowerShell
    for a moment. You’ll have to use the AWS Management Console’s GUI to get the root
    user’s access and secret keys.
  prefs: []
  type: TYPE_NORMAL
- en: Your first move is to log into your AWS account. Navigate to the right-hand
    corner of the screen and click the account drop-down menu, shown in [Figure 13-1](ch13.xhtml#ch13fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: My Security Credentials option*'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **My Security Credentials** option. A screen will pop up, warning
    that messing with your security credentials isn’t a good idea; see [Figure 13-2](ch13.xhtml#ch13fig2).
    But you need to do it here to create an IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: Authentication warning*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Continue to Security Credentials**, then click **Access Keys**. Clicking
    **Create New Access Key** should present a way to view your account’s access key
    ID and secret key. It should also give you an option to download a key file containing
    both. If you haven’t already, download the file and put it in a safe spot. For
    now, though, you need to copy the access key and secret key from this page and
    add them to your default profile in your PowerShell session.
  prefs: []
  type: TYPE_NORMAL
- en: Pass both of these keys to the `Set-AWSCredential` command, which saves them
    so they can be reused by the commands that’ll create an IAM user. Check out [Listing
    13-1](ch13.xhtml#ch13list1) for the full command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-1: Setting AWS access keys*'
  prefs: []
  type: TYPE_NORMAL
- en: With that done, you’re ready to create an IAM user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an IAM User and Role
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’re authenticated as the root user, you can create an IAM user.
    Use the `New-IAMUser` command, specifying the name of the IAM user you’d like
    to use (in this example, `Automator`). When you create the user, you should see
    output like that in [Listing 13-2](ch13.xhtml#ch13list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-2: Creating an IAM user*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the `Arn` property in Listing 13-2\. You'll need this value coming up
    when you create the IAM role.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to give the user the appropriate permission. You do that by
    assigning this user a role that’s assigned a policy. AWS groups certain permissions
    in units called *roles*, which allow the administrator to more easily delegate
    permissions (a strategy known as *role-based access control*, or *RBAC*). The
    *policy* then determines what permissions a role has access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a role by using the `New-IAMRole` command, but first you need
    to create what AWS calls a *trust relationship policy document*: a string of text
    in JSON that defines the services that this user can access and the level at which
    they can access them.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-3](ch13.xhtml#ch13list3) is an example of a trust relationship
    policy document. Important: Notice the XXXXXX on the Principal line. Be sure to
    replace the ARN of the IAM user you just created there.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-3: Example trust policy document*'
  prefs: []
  type: TYPE_NORMAL
- en: This JSON changes the role itself (modifying its trust policy) to allow your
    `Automator` user to use it. It is giving the `AssumeRole` permission to your user.
    This is required to create the role. For more information about how to create
    a trust relationship policy document, refer to [*https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_manage_modify.html*](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_manage_modify.html).
  prefs: []
  type: TYPE_NORMAL
- en: Assign this JSON string to a `$json` variable and then pass it as the value
    of the `AssumeRolePolicyDocument` parameter in `New-IamRole`, as shown in [Listing
    13-4](ch13.xhtml#ch13list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-4: Creating a new IAM role*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the IAM role is created, you need to give it permission to access the
    various resources you’ll be working with. Rather than spend the next 12 dozen
    pages detailing AWS IAM roles and security, let’s do something simple and give
    the `Automator` full access to everything (effectively making it a root user).
  prefs: []
  type: TYPE_NORMAL
- en: Note that in practice, you should *not* do this. It’s always best to limit access
    to only those necessary. Check out the AWS IAM Best Practices guide (*[https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html)*)
    for more information. But for now, let’s assign this user the `AdministratorAccess`
    managed policy by using the `Register-IAMUserPolicy` command. You’ll need the
    Amazon Resource Name (ARN) of the policy. To do that, you can use the `Get-IAMPolicies`
    command and filter by policy name, storing that name in a variable, and passing
    the variable into `Register-IAMUserPolicy` (all of which you can see in [Listing
    13-5](ch13.xhtml#ch13list5)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-5: Attaching a policy to the user*'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing you need to do is generate an access key that will let you authenticate
    your user. Do this with the `New-IAMAcessKey` command, as shown in [Listing 13-6](ch13.xhtml#ch13list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-6: Creating an IAM access key*'
  prefs: []
  type: TYPE_NORMAL
- en: Your new IAM user is all set up. Now let’s authenticate it.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating Your IAM User
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In an earlier section, you authenticated with the root user—this was a temporary
    measure. You need to authenticate your IAM user so you can actually get some work
    done! You need to authenticate your IAM user before you can do just about anything
    in AWS. You’ll again use the `Set-AWSCredential` command to update your profile
    with your new access and secret keys. Change the command a bit, though, by using
    the `StoreAs` parameter, as shown in [Listing 13-7](ch13.xhtml#ch13list7). Because
    you’ll be using this IAM user throughout the rest of the session, you’ll store
    the access and secret key in the AWS default profile so you don’t have to run
    this command again for every session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-7: Setting default AWS access keys*'
  prefs: []
  type: TYPE_NORMAL
- en: The final command to run is Initialize-AWSDefaultConfiguration -Region 'your
    region here', which prevents having to specify the region every time you call
    a command. This is a one-time step. You can find all regions by running `Get-AWSRegion`
    to find the closest region to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it! You now have an authenticated session in AWS and can move on to
    working with AWS services. To confirm, run `Get-AWSCredentials` with the `ListProfileDetail`
    parameter to look for all saved credentials. If all is well, you will see the
    default profile show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating an AWS EC2 Instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 12](ch12.xhtml#ch12), you created an Azure virtual machine. Here,
    you’ll do something similar by creating an *AWS EC2 instance*. An AWS EC2 instance
    offers the same learning opportunity that an Azure virtual machine does; creating
    VMs is an extremely common occurrence, whether you’re using Azure or AWS. However,
    to create a VM in AWS, you need to approach provisioning in a different way than
    with Azure. Here, the underlying APIs are different, meaning the commands you
    run will be different, but in a nutshell, you’ll be performing essentially the
    same task: creating a virtual machine. It doesn’t help that AWS has its own lingo!
    I’ve tried to mirror the steps we took to create the VM in the preceding chapter,
    but of course, because of the architectural and syntactic differences between
    Azure and AWS, you will see some noticeable differences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, just as with Azure, you have a module called `AWSPowerShell` that
    makes it easier to write everything from scratch. Just as you did in the preceding
    chapter, you’ll build from the ground up: setting up all the dependencies you
    need and then creating the EC2 instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The Virtual Private Cloud
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first dependency you need is a network. You can use an existing network
    or build your own. Because this book is hands-on, you’ll build your own network
    from scratch. In Azure, you did this with a vNet, but in AWS, you’ll work with
    *virtual private clouds (VPCs)*, which are a network fabric that allows the virtual
    machine to connect with the rest of the cloud. To replicate the same settings
    an Azure vNet might have, you’ll simply create a VPC with a single subnet set
    to its most basic level. Because there is such a wide range of configuration options
    to choose from, I decided it’s best to mirror our Azure network configuration
    as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Before you get started, you need to know the subnet you’d like to create. Let’s
    use 10.10.0.0/24 as our example network. You’ll store that information and a variable,
    and use the `New-EC2Vpc` command, as shown in [Listing 13-8](ch13.xhtml#ch13list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-8: Creating an AWS VPC*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you create the VPC, you have to manually enable DNS support (Azure did
    this for you automatically). Manually enabling DNS support should point the servers
    attached to this VPC to an internal Amazon DNS server. Likewise, you need to manually
    give a public hostname (another thing Azure took care of for you). To do this,
    you need to enable DNS hostnames. Do both of these by using the code in [Listing
    13-9](ch13.xhtml#ch13list9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-9: Enabling VPC DNS support and hostnames*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you use the `Edit-EC2VpcAttribute` command for both. As its name
    suggests, this command lets you edit several of your EC2 VPC’s attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The Internet Gateway
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step is creating an internet gateway. This allows your EC2 instance
    to route traffic to and from the internet. Again, you need to do this manually,
    here using the `New-EC2InternetGateway` command ([Listing 13-10](ch13.xhtml#ch13list10)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-10: Creating an internet gateway*'
  prefs: []
  type: TYPE_NORMAL
- en: Once the gateway is created, you have to attach it to your VPC by using the
    `Add-EC2InternetGateway` command, as shown in [Listing 13-11](ch13.xhtml#ch13list11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-11: Attaching a VPC to an internet gateway*'
  prefs: []
  type: TYPE_NORMAL
- en: With the VPC out of the way, let’s take the next step and add a route to your
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Routes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the gateway created, you now need to create a route table and a route so
    that the EC2 instances on your VPC can access the internet. A *route* is a path
    that network traffic takes to find the destination. A *route table* is a, well,
    table of routes. Your route needs to go in a table, so you’ll create the route
    table first. Use the `New-EC2RouteTable` command, passing in your VPC ID ([Listing
    13-12](ch13.xhtml#ch13list12)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-12: Creating a route table*'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the route table, you create a route that points to the gateway you just
    created. You’re creating a *default route*, or *default gateway*, meaning a route
    that outgoing network traffic will take if a more specific route isn’t defined.
    You’ll route all traffic (0.0.0.0/0) through your internet gateway. Use the `New-EC2Route`
    command, which will return `True` if successful, as shown in [Listing 13-13](ch13.xhtml#ch13list13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-13: Creating a route*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, your route should be successfully created!
  prefs: []
  type: TYPE_NORMAL
- en: Subnet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you have to create a subnet inside your larger VPC and associate it with
    your route table. Remember that a subnet defines the logical network that your
    EC2 instance’s network adapter will be a part of. To create one, you use the `New-EC2Subnet`
    command, and then use the `Register-EC2RouteTable` command to register the subnet
    to the route table you built earlier. First, though, you need to define an *availability
    zone* (where AWS datacenters will be hosting your subnet) for the subnet. If you’re
    not sure which availability zone you want to use, you can use the `Get-EC2AvailabilityZone`
    command to enumerate all of them. [Listing 13-14](ch13.xhtml#ch13list14) shows
    what should happen if you do.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-14: Enumerating EC2 availability zones*'
  prefs: []
  type: TYPE_NORMAL
- en: If it’s all the same to you, let’s use the `us-east-1d` availability zone. [Listing
    13-15](ch13.xhtml#ch13list15) shows the code to create the subnet, using the `New-EC2Subnet`
    command, which takes the VPC ID you created earlier, a CIDR block (subnet), and
    finally that availability zone you found as well as the code to register the table
    (using the `Register-EC2RouteTable` command).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-15: Creating and registering a subnet*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the subnet created and registered, you’re all done with the
    network stack!
  prefs: []
  type: TYPE_NORMAL
- en: Assigning an AMI to Your EC2 Instance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After building the network stack, you have to assign an Amazon Machine Image
    (AMI) to your VM. An *AMI*, which is a “snapshot” of a disk, is used as a template
    to prevent having to install the operating system on EC2 instances from scratch.
    You need to find an existing AMI that suits your needs: you need an AMI that can
    support a Windows Server 2016 instance, so first you need to find the name of
    that instance. Enumerate all of the available instances with the Get-EC2ImageByName
    command, and you should see an image called `WINDOWS_2016_BASE`. Perfect.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the image name, use `Get-EC2ImageByName` again, and this time,
    specify the image you’d like to use. Doing so will tell the command to return
    the image object you need, as you can see in [Listing 13-16](ch13.xhtml#ch13list16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-16: Finding the AMI*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your image is stored and ready to go. Finally, you can create your EC2 instance.
    All you need is the instance type; unfortunately, you can’t get a list of them
    with a PowerShell cmdlet, but you can find them at [*https://aws.amazon.com/ec2/instance-types/*](https://aws.amazon.com/ec2/instance-types/).
    Let’s use the free one: `t2.micro`. Load up your parameters—the image ID, whether
    you want to associate with a public IP, the instance type, and subnet ID—and run
    the `New-EC2Instance` command ([Listing 13-17](ch13.xhtml#ch13list17)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-17: Creating an EC2 instance*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s done! You should see a brand-new EC2 instance in your AWS Management Console,
    or you can use the `Get-EC2Instance` command to return your newly created instance.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You nailed down the code to create the EC2 instance, but, as is, the code is
    cumbersome to use. Let’s make this code easier to use over and over again. Chances
    are, creating an EC2 instance will be a frequent occurrence, so you’ll create
    a custom function to avoid doing everything one step at a time. At a high level,
    this function works the same way as the one you created in [Chapter 12](ch12.xhtml#ch12)
    in Azure; I won’t go through the specifics of the function here, but the script
    can be found in the book’s resources, and I highly recommend you try to build
    the function on your own.
  prefs: []
  type: TYPE_NORMAL
- en: When the script is called and all dependencies already exist *except* for the
    EC2 instance itself, you’ll see output similar to [Listing 13-18](ch13.xhtml#ch13list18)
    when you run it with the `Verbose` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-18: Running the custom EC2 instance creation function*'
  prefs: []
  type: TYPE_NORMAL
- en: You now have the tools you need to automate the boring task of creating EC2
    instances in AWS!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an Elastic Beanstalk Application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much like Microsoft Azure’s Web App service, AWS has a web app service of its
    own. *Elastic Beanstalk (EB)* is a service that allows you to upload web packages
    to be hosted on the AWS infrastructure. In this section, you’ll see what it takes
    to create an EB application and then deploy a package to one. This process requires
    five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the package to make it available to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new version of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the new version to the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s start by creating a new application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create a new application, use the `New-EBApplication` command, which provides
    the application’s name. Let’s call it `AutomateWorkflow`. Run the command, and
    you should see something like [Listing 13-19](ch13.xhtml#ch13list19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-19: Creating a new Elastic Beanstalk application*'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is creating the *environment*, which is the infrastructure the
    application will be hosted on. The command to create a new environment is `New-EBEnvironment`.
    Unfortunately, creating the environment isn’t quite as straightforward as creating
    the application. A couple of the parameters, such as the application name and
    name of the environment, are up to you, but you need to know the `SolutionStackName`,
    `Tier_Type`, and `Tier_Name`. Let’s look at these a little more closely.
  prefs: []
  type: TYPE_NORMAL
- en: You use the `SolutionStackName` to specify the operating system and IIS version
    you’d like your app to run under. For a list of available solution stacks, run
    the `Get-EBAvailableSolutionStackList` command and inspect the `SolutionStackDetails`
    property, as shown in [Listing 13-20](ch13.xhtml#ch13list20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-20: Finding available solution stacks*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you have a lot of options. For this example, choose 64-bit Windows
    Server Core 2012 R2 running IIS 8.5.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the `Tier_Type`. The `Tier_Type` specifies the kind of environment
    your web service will be running under. The `Standard` type is required if you’ll
    be using this environment to host a website.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, for the `Tier_Name` parameter, you have the options of `WebServer`
    and `Worker`. Choose `WebServer` here because you’d like to host a website (`Worker`
    would be required if you were creating an API).
  prefs: []
  type: TYPE_NORMAL
- en: Now that your parameters are all figured out, let’s run `New-EBEnvironment`.
    [Listing 13-21](ch13.xhtml#ch13list21) shows the command and the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-21: Creating an Elastic Beanstalk application*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that the status shows `Launching`. This means the app isn’t available
    yet, so you may have to wait a bit for the environment to come up. You can periodically
    check on the status of the app by running Get-EBEnvironment -ApplicationName 'AutomateWorkflow'
    -EnvironmentName 'Testing'. The environment may stay in a `Launching` state for
    a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: When you see the `Status` property turn to `Ready`, the environment is up, and
    it’s time to deploy a package to the site.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s deploy. The package you’ll deploy should contain any files you want your
    website to host. You can put whatever you’d like in there—for our purposes, it
    doesn’t matter. All you have to make sure of is that it’s in a ZIP file. Use the
    `Compress-Archive` command to zip up whatever files you want to deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With your package nice and zipped up, you need to put it somewhere the application
    can find. You could put it in a couple of places, but for this example, you’ll
    put it in an Amazon S3 bucket, a common way to store data in AWS. But to put it
    in an Amazon S3 bucket, you first need an Amazon S3 bucket! Let’s make one in
    PowerShell. Go ahead and run New-S3Bucket -BucketName 'automateworkflow'.
  prefs: []
  type: TYPE_NORMAL
- en: With your S3 bucket up and waiting for contents, upload the ZIP file by using
    the `Write-S3Object` command, as shown in [Listing 13-22](ch13.xhtml#ch13list22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-22: Uploading the package to S3*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you have to point the application to the S3 key you just created and specify
    a version label for it. The version label can be anything, but typically, you
    use a unique number based on the time. So let’s use the number of ticks representing
    the current date and time. Once you have the version label, run `New-EBApplicationVersion`
    with a few more parameters, as shown in [Listing 13-23](ch13.xhtml#ch13list23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-23: Creating a new application version*'
  prefs: []
  type: TYPE_NORMAL
- en: Your application version has now been created! It’s time to deploy this version
    to your environment. Do that by using the `Update-EBEnvironment` command, as shown
    in [Listing 13-24](ch13.xhtml#ch13list24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-24: Deploying the application to the EB environment*'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the status has gone from `Ready` to `Updating` ❶. Again, you
    need to wait a bit until the status turns back to `Ready` as you can see in [Listing
    13-25](ch13.xhtml#ch13list25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-25: Confirming the application is ready*'
  prefs: []
  type: TYPE_NORMAL
- en: As you check in, the status is `Ready` again ❶. Everything looks good!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SQL Server Database in AWS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an AWS administrator, you may need to set up different types of relational
    databases. AWS provides the Amazon Relational Database Service (Amazon RDS), which
    allows for administrators to easily provision a few types of databases. There
    a few options, but for now, you’ll stick with SQL.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll create a blank Microsoft SQL Server database in RDS.
    The main command you’ll use is `New-RDSDBInstance`. Like `New-AzureRmSqlDatabase`,
    `New-RDSDBInstance` has *a lot* of parameters, more than I can possibly cover
    in this section. If you’re curious about other ways to provision RDS instances,
    I encourage you to review the help contents for `New-RDSDBInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, though, you need the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database engine (SQL Server, MariaDB, MySQL, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instance class that specifies the type of resources the SQL Server runs
    on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The master username and password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the database (in GB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few of these things you can figure out easily: the name, username/password,
    and size. The others require further investigation.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the engine version. You can get a list of all available engines
    and their versions by using the `Get-RDSDBEngineVersion` command. When run with
    no parameters, this command returns a lot of information—too much for what you’re
    doing. You can use the `Group-Object` command to group all the objects by engine,
    which will provide a list of all engine versions grouped by the engine name. As
    you can see in [Listing 13-26](ch13.xhtml#ch13list26), you now have a more manageable
    output that shows all the available engines you can use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-26: Investigating RDS DB engine versions*'
  prefs: []
  type: TYPE_NORMAL
- en: You have four `sqlserver` entries, representing SQL Server Express, Web, Standard
    Edition, and Enterprise Edition. Since this is just an example, you’ll go with
    SQL Server Express; it’s a no-frills database engine and, most important, it’s
    free, which allows you to tune and tweak it if necessary. Select the SQL Server
    Express engine by using sqlserver-ex.
  prefs: []
  type: TYPE_NORMAL
- en: After picking an engine, you have to specify a version. By default, `New-RDSDBInstance`
    provisions the latest version (which you’ll be using), but you can specify a different
    version by using the `EngineVersion` parameter. To see all the available versions,
    you’ll run `Get-RDSDBEngineVersion` again, limit the search to `sqlserver-ex`,
    and return only the engine versions ([Listing 13-27](ch13.xhtml#ch13list27)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-27: Finding SQL Server Express engine versions*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next parameter value you need to provide to `New-RDSDBInstance` is the
    instance class. The instance class represents the performance of the underlying
    infrastructure—memory, CPU, and so forth—that the database will be hosted on.
    Unfortunately, there’s no PowerShell command to easily find all available instance
    class options, but you can check out this link to get a full rundown: [*https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide**/Concepts.DBInstanceClass.html*](https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html).'
  prefs: []
  type: TYPE_NORMAL
- en: When selecting an instance class, it’s important to verify that it’s supported
    by the engine you chose. Here, you’ll use the `db2.t2.micro` instance class to
    create your RDS DB, but many of the other options will not work. For a full breakdown
    on which instance classes are supported under which RDS DB, refer to the AWS RDS
    FAQs (*[https://aws.amazon.com/rds/faqs/](https://aws.amazon.com/rds/faqs/)*).
    If you choose an instance class that’s not supported by the engine you’re using,
    you’ll receive an error as in [Listing 13-28](ch13.xhtml#ch13list28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-28: Error when specifying an invalid instance configuration*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve selected a (supported) instance class, you have to decide on a
    username and password. Note that AWS will not accept any old password: you cannot
    have a slash, `@` sign, comma, or space in your password, or you will receive
    an error message like the one in [Listing 13-29](ch13.xhtml#ch13list29).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-29: Specifying an invalid password with `New-RDSDBInstance`*'
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have all the parameters needed to fire off `New-RDSDBInstance`!
    You can see the expected output in [Listing 13-30](ch13.xhtml#ch13list30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-30: Provisioning a new RDS database instance*'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Your AWS should have a shiny, new RDS database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter covered the basics of using AWS with PowerShell. You looked at
    AWS authentication and then went through several common AWS tasks: creating EC2
    instances, deploying Elastic Beanstalk web applications, and provisioning an Amazon
    RDS SQL database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this chapter and the preceding one, you should have a good sense of how
    to use PowerShell to work with the cloud. Of course, there’s much more to learn—more
    than I could ever cover in this book—but for now, you’ll be moving on to the next
    part of this book: creating your own fully functional PowerShell module.'
  prefs: []
  type: TYPE_NORMAL
