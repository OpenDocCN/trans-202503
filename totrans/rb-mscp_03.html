<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;How Ruby Executes Your Code"><div class="titlepage"><div><div><h1 class="title"><a id="how_ruby_executes_your_code"/>Chapter 3. How Ruby Executes Your Code</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00059"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>YARV is not just a stack machine—it’s a double-stack machine!</em></span></p></blockquote></div><p><a class="indexterm" id="iddle1959"/>Now that Ruby has tokenized, parsed, and compiled your code, it’s finally ready to execute it. But just how does it do that? We’ve seen how the Ruby compiler creates YARV (Yet Another Ruby Virtual Machine) instructions, but how does YARV actually run them? How does it track variables and return values and arguments? How does it implement <code class="literal">if</code> statements and other control structures?</p><p>Koichi Sasada and the Ruby core team designed YARV to use a stack pointer and a program counter—that is, to function like your computer’s actual microprocessor. In this chapter, I’ll examine the basics of YARV instructions; namely, how they pop arguments off of and push return values onto an internal stack. We’ll also see how YARV keeps track of <a class="indexterm" id="iddle1110"/><a class="indexterm" id="iddle2109"/><a class="indexterm" id="iddle2135"/>your Ruby call stack along with its own internal stack. I’ll explain how Ruby accesses local variables and how it can find variables farther down your call stack using dynamic access. We’ll finish with a look at how Ruby implements special variables. In <a class="xref" href="ch04.html" title="Chapter 4. Control Structures and Method Dispatch">Chapter 4</a> I’ll continue the discussion of YARV by examining how it implements control structures and method dispatch.</p><div class="sidebar"><a id="roadmap-id00009"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch03.html#yarvapostrophes_internal_stack_and_your" title="YARV’s Internal Stack and Your Ruby Stack">YARV’s Internal Stack and Your Ruby Stack</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch03.html#stepping_through_how_ruby_executes_a_sim" title="Stepping Through How Ruby Executes a Simple Script">Stepping Through How Ruby Executes a Simple Script</a></p></li><li class="listitem"><p><a class="xref" href="ch03.html#executing_a_call_to_a_block" title="Executing a Call to a Block">Executing a Call to a Block</a></p></li><li class="listitem"><p><a class="xref" href="ch03.html#taking_a_close_look_at_a_yarv_instructio" title="Taking a Close Look at a YARV Instruction">Taking a Close Look at a YARV Instruction</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch03.html#experiment_3-1_benchmarking_ruby_2dot0_a" title="Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8">Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch03.html#local_and_dynamic_access_of_ruby_variabl" title="Local and Dynamic Access of Ruby Variables">Local and Dynamic Access of Ruby Variables</a></p></li><li class="listitem"><p><a class="xref" href="ch03.html#local_variable_access" title="Local Variable Access">Local Variable Access</a></p></li><li class="listitem"><p><a class="xref" href="ch03.html#method_arguments_are_treated_like_local" title="Method Arguments Are Treated Like Local Variables">Method Arguments Are Treated Like Local Variables</a></p></li><li class="listitem"><p><a class="xref" href="ch03.html#dynamic_variable_access" title="Dynamic Variable Access">Dynamic Variable Access</a></p></li><li class="listitem"><p><a class="xref" href="ch03.html#climbing_the_environment_pointer_ladder" title="Climbing the Environment Pointer Ladder in C">Climbing the Environment Pointer Ladder in C</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch03.html#experiment_3-2_exploring_special_variabl" title="Experiment 3-2: Exploring Special Variables">Experiment 3-2: Exploring Special Variables</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch03.html#definitive_list_of_special_variables" title="A Definitive List of Special Variables">A Definitive List of Special Variables</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch03.html#summary-id00011" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="YARV’s Internal Stack and Your Ruby Stack"><div class="titlepage"><div><div><h1 class="title"><a id="yarvapostrophes_internal_stack_and_your"/>YARV’s Internal Stack and Your Ruby Stack</h1></div></div></div><p>As we’ll see in a moment, YARV uses a stack internally to track intermediate values, arguments, and return values. YARV is a stack-oriented virtual machine.</p><p>In addition to its own internal stack, YARV keeps track of your Ruby program’s <span class="emphasis"><em>call stack</em></span>, recording which methods call which other methods, functions, blocks, lambdas, and so on. In fact, YARV is not just a stack machine—it’s a double-stack machine! It has to track the arguments and return values not only for its own internal instructions but also for your Ruby program.</p><p><a class="xref" href="ch03.html#some_of_yarvapostrophes_internal_registe" title="Figure 3-1. Some of YARV’s internal registers, including the program counter and stack pointer">Figure 3-1</a> shows YARV’s basic registers and internal stack.</p><div class="figure"><a id="some_of_yarvapostrophes_internal_registe"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00060"/><img alt="Some of YARV’s internal registers, including the program counter and stack pointer" src="httpatomoreillycomsourcenostarchimages1853939.png.jpg"/></div></div><p class="title">Figure 3-1. Some of YARV’s internal registers, including the program counter and stack pointer</p></div><p><a class="indexterm" id="iddle1112"/><a class="indexterm" id="iddle1221"/><a class="indexterm" id="iddle1783"/><a class="indexterm" id="iddle1788"/><a class="indexterm" id="iddle1815"/><a class="indexterm" id="iddle1818"/><a class="indexterm" id="iddle1821"/><a class="indexterm" id="iddle1839"/><a class="indexterm" id="iddle1864"/><a class="indexterm" id="iddle1979"/><a class="indexterm" id="iddle1996"/><a class="indexterm" id="iddle2016"/>YARV’s internal stack is on the left. The <code class="literal">SP</code> label is the <span class="emphasis"><em>stack pointer</em></span>, or the location of the top of the stack. On the right are the instructions that YARV is executing. <code class="literal">PC</code> is the <span class="emphasis"><em>program counter</em></span>, or the location of the current instruction.</p><p>You can see the YARV instructions that Ruby compiled from the <code class="literal">puts 2+2</code> example on the right side of <a class="xref" href="ch03.html#some_of_yarvapostrophes_internal_registe" title="Figure 3-1. Some of YARV’s internal registers, including the program counter and stack pointer">Figure 3-1</a>. YARV stores both the <code class="literal">SP</code> and <code class="literal">PC</code> registers in a C structure called <code class="literal">rb_control_frame_t</code>, along with a <code class="literal">type</code> field, the current value of Ruby’s <code class="literal">self</code> variable, and some other values not shown here.</p><p>At the same time, YARV maintains another stack of these <code class="literal">rb_control_frame_t</code> structures, as shown in <a class="xref" href="ch03.html#yarv_keeps_track_of_your_ruby_call_stack" title="Figure 3-2. YARV keeps track of your Ruby call stack using a series of rb_control_frame_t structures.">Figure 3-2</a>.</p><div class="figure"><a id="yarv_keeps_track_of_your_ruby_call_stack"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00061"/><img alt="YARV keeps track of your Ruby call stack using a series of rb_control_frame_t structures." src="httpatomoreillycomsourcenostarchimages1853941.png.jpg"/></div></div><p class="title">Figure 3-2. YARV keeps track of your Ruby call stack using a series of <code class="literal">rb_control_frame_t structures</code>.</p></div><p>This second stack of <code class="literal">rb_control_frame_t</code> structures represents the path that YARV has taken through your Ruby program, and YARV’s current location. In other words, this is your Ruby call stack—what you would see if you ran <code class="literal">puts caller</code>.</p><p>The <code class="literal">CFP</code> pointer indicates the <span class="emphasis"><em>current frame pointer</em></span>. Each stack frame in your Ruby program stack contains, in turn, a different value for the <code class="literal">self</code>, <code class="literal">PC</code>, and <code class="literal">SP</code> registers, as shown in <a class="xref" href="ch03.html#some_of_yarvapostrophes_internal_registe" title="Figure 3-1. Some of YARV’s internal registers, including the program counter and stack pointer">Figure 3-1</a>. The <code class="literal">type</code> field in each <code class="literal">rb_control_frame_t</code> structure indicates the type of code running at this level in your Ruby call stack. As Ruby calls into the methods, blocks, or other structures in your program, the type might be set to <code class="literal">METHOD</code>, <code class="literal">BLOCK</code>, or one of a few other values.</p><div class="sect2" title="Stepping Through How Ruby Executes a Simple Script"><div class="titlepage"><div><div><h2 class="title"><a id="stepping_through_how_ruby_executes_a_sim"/>Stepping Through How Ruby Executes a Simple Script</h2></div></div></div><p><a class="indexterm" id="iddle1263"/><a class="indexterm" id="iddle1653"/><a class="indexterm" id="iddle1845"/><a class="indexterm" id="iddle1970"/><a class="indexterm" id="iddle1988"/><a class="indexterm" id="iddle2125"/>In order to help you understand this a bit better, here are a couple of examples. I’ll begin with the simple <code class="literal">2+2</code> example from <a class="xref" href="ch01.html" title="Chapter 1. Tokenization and Parsing">Chapter 1</a> and <a class="xref" href="ch02.html" title="Chapter 2. Compilation">Chapter 2</a>, shown again in <a class="xref" href="ch03.html#one-line_ruby_program_that_weapostroph" title="Example 3-1. A one-line Ruby program that we’ll execute as an example">Example 3-1</a>.</p><div class="example"><a id="one-line_ruby_program_that_weapostroph"/><p class="title">Example 3-1. A one-line Ruby program that we’ll execute as an example</p><div class="example-contents"><pre class="programlisting">puts 2+2</pre></div></div><p>This one-line Ruby script doesn’t have a Ruby call stack, so I’ll focus on the internal YARV stack for now. <a class="xref" href="ch03.html#on_the_left_is_yarvapostrophes_internal" title="Figure 3-3. On the left is YARV’s internal stack, and on the right is the compiled version of my puts 2+2 program.">Figure 3-3</a> shows how YARV will execute this script, beginning with the first instruction, <code class="literal">trace</code>.</p><div class="figure"><a id="on_the_left_is_yarvapostrophes_internal"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00062"/><img alt="On the left is YARV’s internal stack, and on the right is the compiled version of my puts 2+2 program." src="httpatomoreillycomsourcenostarchimages1853943.png.jpg"/></div></div><p class="title">Figure 3-3. On the left is YARV’s internal stack, and on the right is the compiled version of my <code class="literal">puts 2+2</code> program.</p></div><p>As you can see in <a class="xref" href="ch03.html#on_the_left_is_yarvapostrophes_internal" title="Figure 3-3. On the left is YARV’s internal stack, and on the right is the compiled version of my puts 2+2 program.">Figure 3-3</a>, YARV starts the program counter (<code class="literal">PC</code>) at the first instruction, and initially the stack is empty. Now YARV will execute the <code class="literal">trace</code> instruction, incrementing the <code class="literal">PC</code> register, as shown in <a class="xref" href="ch03.html#ruby_executes_the_first_instructioncomma" title="Figure 3-4. Ruby executes the first instruction, trace.">Figure 3-4</a>.</p><div class="figure"><a id="ruby_executes_the_first_instructioncomma"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00063"/><img alt="Ruby executes the first instruction, trace." src="httpatomoreillycomsourcenostarchimages1853945.png.jpg"/></div></div><p class="title">Figure 3-4. Ruby executes the first instruction, <code class="literal">trace</code>.</p></div><p>Ruby uses the <code class="literal">trace</code> instruction to support the <code class="literal">set_trace_func</code> feature. If you call <code class="literal">set_trace_func</code> and provide a function, Ruby will call it each time it executes a line of Ruby code.</p><p>Next, YARV executes <code class="literal">putself</code> and pushes the current value of <code class="literal">self</code> onto the stack, as shown in <a class="xref" href="ch03.html#putself_pushes_the_top_self_value_onto_t" title="Figure 3-5. putself pushes the top self value onto the stack.">Figure 3-5</a>.</p><div class="figure"><a id="putself_pushes_the_top_self_value_onto_t"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00064"/><img alt="putself pushes the top self value onto the stack." src="httpatomoreillycomsourcenostarchimages1853947.png.jpg"/></div></div><p class="title">Figure 3-5. <code class="literal">putself</code> pushes the <code class="literal">top self</code> value onto the stack.</p></div><p><a class="indexterm" id="iddle1843"/><a class="indexterm" id="iddle1892"/><a class="indexterm" id="iddle2049"/><a class="indexterm" id="iddle2123"/>Because this simple script contains no Ruby objects or classes, the <code class="literal">self</code> pointer is set to the default <code class="literal">top self</code> object. This is an instance of the <code class="literal">Object</code> class that Ruby automatically creates when YARV starts. It serves as the receiver for method calls and the container for instance variables in the top-level scope. The <code class="literal">top self</code> object contains a single, predefined <code class="literal">to_s</code> method, which returns the string <code class="literal">main</code>. You can call this method by running the following command in the console:</p><a id="pro_id00006"/><pre class="programlisting">$ <span class="strong"><strong>ruby -e 'puts self'</strong></span>
 =&gt; main</pre><p>YARV will use this <code class="literal">self</code> value on the stack when it executes the <code class="literal">opt_send_simple</code> instruction: <code class="literal">self</code> is the receiver of the <code class="literal">puts</code> method because I didn’t specify a receiver for this method call.</p><p>Next, YARV executes <code class="literal">putobject 2</code>. It pushes the numeric value <code class="literal">2</code> onto the stack and increments the <code class="literal">PC</code> again, as shown in <a class="xref" href="ch03.html#ruby_pushes_the_value_2_onto_the_stackco" title="Figure 3-6. Ruby pushes the value 2 onto the stack, the receiver of the + method.">Figure 3-6</a>.</p><div class="figure"><a id="ruby_pushes_the_value_2_onto_the_stackco"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00065"/><img alt="Ruby pushes the value 2 onto the stack, the receiver of the + method." src="httpatomoreillycomsourcenostarchimages1853949.png.jpg"/></div></div><p class="title">Figure 3-6. Ruby pushes the value <code class="literal">2</code> onto the stack, the receiver of the <code class="literal">+</code> method.</p></div><p>This is the first step of the receiver (arguments) operation pattern described in <a class="xref" href="ch02.html#how_ruby_compiles_a_simple_script" title="How Ruby Compiles a Simple Script">How Ruby Compiles a Simple Script</a>. First, Ruby pushes the receiver onto the internal YARV stack. In this example, the <code class="literal">Fixnum</code> object <code class="literal">2</code> is the receiver of the message/method <code class="literal">+</code>, which takes a single argument, also a <code class="literal">2</code>. Next, Ruby pushes the argument <code class="literal">2</code>, as shown in <a class="xref" href="ch03.html#ruby_pushes_another_value_2_onto_the_sta" title="Figure 3-7. Ruby pushes another value 2 onto the stack, the argument of the + method.">Figure 3-7</a>.</p><div class="figure"><a id="ruby_pushes_another_value_2_onto_the_sta"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00066"/><img alt="Ruby pushes another value 2 onto the stack, the argument of the + method." src="httpatomoreillycomsourcenostarchimages1853951.png.jpg"/></div></div><p class="title">Figure 3-7. Ruby pushes another value <code class="literal">2</code> onto the stack, the argument of the <code class="literal">+</code> method.</p></div><p><a class="indexterm" id="iddle1534"/><a class="indexterm" id="iddle1760"/><a class="indexterm" id="iddle1762"/><a class="indexterm" id="iddle2117"/><a class="indexterm" id="iddle2120"/><a class="indexterm" id="iddle2122"/>Finally, Ruby executes the <code class="literal">+</code> operation. In this case, <code class="literal">opt_plus</code> is an optimized instruction that will add two values: the receiver and the argument, as shown in <a class="xref" href="ch03.html#optunderscoreplus_instruction_calcul" title="Figure 3-8. The opt_plus instruction calculates 2 + 2 = 4.">Figure 3-8</a>.</p><div class="figure"><a id="optunderscoreplus_instruction_calcul"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00067"/><img alt="The opt_plus instruction calculates 2 + 2 = 4." src="httpatomoreillycomsourcenostarchimages1853953.png.jpg"/></div></div><p class="title">Figure 3-8. The <code class="literal">opt_plus</code> instruction calculates 2 + 2 = 4.</p></div><p>As you can see in <a class="xref" href="ch03.html#optunderscoreplus_instruction_calcul" title="Figure 3-8. The opt_plus instruction calculates 2 + 2 = 4.">Figure 3-8</a>, the <code class="literal">opt_plus</code> instruction leaves the result, <code class="literal">4</code>, at the top of the stack. Now Ruby is perfectly positioned to execute the <code class="literal">puts</code> function call: The receiver <code class="literal">self</code> is first on the stack, and the single argument, <code class="literal">4</code>, is at the top of the stack. (I’ll describe how method lookup works in <a class="xref" href="ch06.html" title="Chapter 6. Method Lookup and Constant Lookup">Chapter 6</a>.)</p><p>Next, <a class="xref" href="ch03.html#ruby_calls_the_puts_method_on_the_top_se" title="Figure 3-9. Ruby calls the puts method on the top self object.">Figure 3-9</a> shows what happens when Ruby executes the <code class="literal">puts</code> method call. As you can see, the <code class="literal">opt_send_simple</code> instruction leaves the return value, <code class="literal">nil</code>, at the top of the stack. Finally, Ruby executes the last instruction, <code class="literal">leave</code>, which finishes the execution of our simple, one-line Ruby program. Of course, when Ruby executes the <code class="literal">puts</code> call, the C code implementing the <code class="literal">puts</code> function will actually display the value <code class="literal">4</code> in the console output.</p><div class="figure"><a id="ruby_calls_the_puts_method_on_the_top_se"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00068"/><img alt="Ruby calls the puts method on the top self object." src="httpatomoreillycomsourcenostarchimages1853955.png.jpg"/></div></div><p class="title">Figure 3-9. Ruby calls the <code class="literal">puts</code> method on the <code class="literal">top self</code> object.</p></div></div><div class="sect2" title="Executing a Call to a Block"><div class="titlepage"><div><div><h2 class="title"><a id="executing_a_call_to_a_block"/>Executing a Call to a Block</h2></div></div></div><p><a class="indexterm" id="iddle1081"/><a class="indexterm" id="iddle1102"/><a class="indexterm" id="iddle1115"/><a class="indexterm" id="iddle1260"/><a class="indexterm" id="iddle1668"/>Now let’s see how the Ruby call stack works. In <a class="xref" href="ch03.html#this_example_program_calls_a_block_10_ti" title="Example 3-2. This example program calls a block 10 times.">Example 3-2</a>, a slightly more complicated example, you see a simple Ruby script that calls a block 10 times, printing out a string.</p><div class="example"><a id="this_example_program_calls_a_block_10_ti"/><p class="title">Example 3-2. This example program calls a block 10 times.</p><div class="example-contents"><pre class="programlisting">10.times do
  puts "The quick brown fox jumps over the lazy dog."
end</pre></div></div><p>Let’s skip over a few steps and start where YARV is about to call the <code class="literal">times</code> method, as shown in <a class="xref" href="ch03.html#every_ruby_program_starts_with_these_two" title="Figure 3-10. Every Ruby program starts with these two control frames.">Figure 3-10</a>.</p><div class="figure"><a id="every_ruby_program_starts_with_these_two"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00069"/><img alt="Every Ruby program starts with these two control frames." src="httpatomoreillycomsourcenostarchimages1853957.png.jpg"/></div></div><p class="title">Figure 3-10. Every Ruby program starts with these two control frames.</p></div><p>On the left side of the diagram are the YARV instructions that Ruby is executing. On the right, you see two control frame structures.</p><p>At the bottom of the stack, you see a control frame with the type set to <code class="literal">TOP</code>. Ruby always creates this frame first when starting a new program. At the top of the stack, at least initially, a frame of type <code class="literal">EVAL</code> corresponds to the top level or main scope of the Ruby script.</p><p>Next, Ruby calls the <code class="literal">times</code> message on the <code class="literal">Fixnum</code> object <code class="literal">10</code>—the receiver of the <code class="literal">times</code> message. When it does so, it adds a new level to the control frame stack, as shown in <a class="xref" href="ch03.html#ruby_uses_the_cfunc_frame_when_you_call" title="Figure 3-11. Ruby uses the CFUNC frame when you call built-in functions implemented in C.">Figure 3-11</a>.</p><div class="figure"><a id="ruby_uses_the_cfunc_frame_when_you_call"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00070"/><img alt="Ruby uses the CFUNC frame when you call built-in functions implemented in C." src="httpatomoreillycomsourcenostarchimages1853959.png.jpg"/></div></div><p class="title">Figure 3-11. Ruby uses the <code class="literal">CFUNC</code> frame when you call built-in functions implemented in C.</p></div><p><a class="indexterm" id="iddle1131"/><a class="indexterm" id="iddle1444"/>This new entry (at the right of <a class="xref" href="ch03.html#ruby_uses_the_cfunc_frame_when_you_call" title="Figure 3-11. Ruby uses the CFUNC frame when you call built-in functions implemented in C.">Figure 3-11</a>) represents a new level in the program’s Ruby call stack, and the <code class="literal">CFP</code> pointer has moved up to point at the new control frame structure. Also, notice that because the <code class="literal">Integer#times</code> method is built into Ruby, there are no YARV instructions for it. Instead, Ruby will call some internal C code to pop the argument <code class="literal">10</code> off the stack and call the provided block 10 times. Ruby gives this control frame a type of <code class="literal">CFUNC</code>.</p><p>Finally, <a class="xref" href="ch03.html#cfp_stack_when_we_pause_the_code_fro" title="Figure 3-12. The CFP stack when we pause the code from Example 3-2 inside the block">Figure 3-12</a> shows what the YARV and control frame stacks will look like if we interrupt the program inside the inner block.</p><div class="figure"><a id="cfp_stack_when_we_pause_the_code_fro"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00071"/><img alt="The CFP stack when we pause the code from inside the block" src="httpatomoreillycomsourcenostarchimages1853961.png.jpg"/></div></div><p class="title">Figure 3-12. The <code class="literal">CFP</code> stack when we pause the code from <a class="xref" href="ch03.html#this_example_program_calls_a_block_10_ti" title="Example 3-2. This example program calls a block 10 times.">Example 3-2</a> inside the block</p></div><p>There will now be four entries, as follows, in the control frame stack on the right:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">TOP</code> and <code class="literal">EVAL</code> frames that Ruby always starts with</p></li><li class="listitem"><p>The <code class="literal">CFUNC</code> frame for the call to <code class="literal">10.times</code></p></li><li class="listitem"><p>A <code class="literal">BLOCK</code> frame at the top of the stack that corresponds to the code running inside the block</p></li></ul></div><div class="sidebar"><a id="taking_a_close_look_at_a_yarv_instructio"/><p class="title">Taking a Close Look at a YARV Instruction</p><p><a class="indexterm" id="iddle1420"/><a class="indexterm" id="iddle1682"/><a class="indexterm" id="iddle1846"/><a class="indexterm" id="iddle2096"/><a class="indexterm" id="iddle2111"/><a class="indexterm" id="iddle2126"/><a class="indexterm" id="iddle2130"/>As it does with most other things, Ruby implements all YARV instructions, like <code class="literal">putobject</code> or <code class="literal">send</code>, using C code that is then compiled into machine language and executed directly by your hardware. Strangely, however, you won’t find the C source code for each YARV instruction in a C source file. Instead, the Ruby core team put the YARV-instruction C code in a single large file called <code class="literal">insns.def</code>. <a class="xref" href="ch03.html#definition_of_the_putself_yarv_instr" title="Example 3-3. The definition of the putself YARV instruction">Example 3-3</a> shows a small snippet from <span class="emphasis"><em>insns.def</em></span>, where Ruby implements the <code class="literal">putself</code> YARV instruction internally.</p><div class="example"><a id="definition_of_the_putself_yarv_instr"/><p class="title">Example 3-3. The definition of the <span class="emphasis"><em><code class="literal">putself</code></em></span> YARV instruction</p><div class="example-contents"><pre class="programlisting">    /**
      @c put
      @e put self.
      @j スタックに self をプッシュする。
     */
    DEFINE_INSN
    putself
    ()
    ()
    (VALUE val)
    {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   val = GET_SELF();
    }</pre></div></div><p>This doesn’t look like C at all and, in fact, most of it is not. Instead, what you see here is a bit of C code (<code class="literal">val = GET_SELF()</code>) at <span class="inlinemediaobject"><a id="inline_id00063"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> that appears below a call to <code class="literal">DEFINE_INSN</code>.</p><p>It’s not hard to figure out that <code class="literal">DEFINE_INSN</code> stands for <span class="emphasis"><em>define instruction</em></span>. In fact, Ruby processes and converts the <span class="emphasis"><em>insns.def</em></span> file into real C code during the Ruby build process, similar to the way that Bison converts the <span class="emphasis"><em>parse.y</em></span> file into <span class="emphasis"><em>parse.c</em></span>, as shown in <a class="xref" href="ch03.html#ruby_compiles_the_yarv-instruction_defin" title="Figure 3-13. Ruby compiles the YARV-instruction definition script insns.def into C code during the Ruby build process.">Figure 3-13</a>.</p><div class="figure"><a id="ruby_compiles_the_yarv-instruction_defin"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00072"/><img alt="Ruby compiles the YARV-instruction definition script insns.def into C code during the Ruby build process." src="httpatomoreillycomsourcenostarchimages1853963.png.jpg"/></div></div><p class="title">Figure 3-13. Ruby compiles the YARV-instruction definition script <span class="emphasis"><em><code class="literal">insns.def</code></em></span> into C code during the Ruby build process.</p></div><p>Ruby processes the <span class="emphasis"><em>insns.def</em></span> file using Ruby: The build process first compiles a smaller version of Ruby called <span class="emphasis"><em>Miniruby</em></span> and then uses this to run some Ruby code <a class="indexterm" id="iddle2094"/>that processes <span class="emphasis"><em>insns.def</em></span> and converts it into a C source code file called <span class="emphasis"><em>vm.inc</em></span>. Later the Ruby build process hands <span class="emphasis"><em>vm.inc</em></span> to the C compiler, which includes the generated C code in the final, compiled version of Ruby.</p><p><a class="xref" href="ch03.html#definition_of_putself_is_transformed" title="Example 3-4. The definition of putself is transformed into this C code during the Ruby build process.">Example 3-4</a> shows what the snippet for <code class="literal">putself</code> looks like in <span class="emphasis"><em>vm.inc</em></span> once Ruby has processed it.</p><div class="example"><a id="definition_of_putself_is_transformed"/><p class="title">Example 3-4. The definition of <code class="literal">putself</code> is transformed into this C code during the Ruby build process.</p><div class="example-contents"><pre class="programlisting">    INSN_ENTRY(putself){
    {
      VALUE val;
      DEBUG_ENTER_INSN("putself");
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   ADD_PC(1+0);
      PREFETCH(GET_PC());
      #define CURRENT_INSN_putself 1
      #define INSN_IS_SC()     0
      #define INSN_LABEL(lab)  LABEL_putself_##lab
      #define LABEL_IS_SC(lab) LABEL_##lab##_##t
      COLLECT_USAGE_INSN(BIN(putself));
    {
    #line 282 "insns.def"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     val = GET_SELF();
    #line 408 "vm.inc"
      CHECK_VM_STACK_OVERFLOW(REG_CFP, 1);
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   PUSH(val);
    #undef CURRENT_INSN_putself
    #undef INSN_IS_SC
    #undef INSN_LABEL
    #undef LABEL_IS_SC
      END_INSN(putself);}}}</pre></div></div><p>The single line <code class="literal">val = GET_SELF()</code> appears in the middle of the listing at <span class="inlinemediaobject"><a id="inline_id00067"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. Above and below this line, Ruby calls a few different C macros to do various things, like add <code class="literal">1</code> to the program counter (<code class="literal">PC</code>) register at <span class="inlinemediaobject"><a id="inline_id00068"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and push the <code class="literal">val</code> value onto the YARV internal stack at <span class="inlinemediaobject"><a id="inline_id00069"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>. If you look through <span class="emphasis"><em>vm.inc</em></span>, you’ll see this same C code repeated over and over again for the definition of each YARV instruction.</p><p>The <span class="emphasis"><em>vm.inc</em></span> C source code file, in turn, is included by the <span class="emphasis"><em>vm_exec.c</em></span> file, which contains the primary YARV instruction loop that steps through the YARV instructions in your program one after another and calls the C code corresponding to each one.</p></div></div></div><div class="sect1" title="Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_3-1_benchmarking_ruby_2dot0_a"/>Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8</h1></div></div></div><p><a class="indexterm" id="iddle1026"/><a class="indexterm" id="iddle1068"/><a class="indexterm" id="iddle1284"/><a class="indexterm" id="iddle1951"/><a class="indexterm" id="iddle2006"/><a class="indexterm" id="iddle2042"/>The Ruby core team introduced the YARV virtual machine with Ruby 1.9. Earlier versions of Ruby executed programs by directly stepping through the nodes of the <span class="emphasis"><em>abstract syntax tree (AST)</em></span>. There was no compile step: Ruby just tokenized, parsed, and then immediately executed your code.</p><p>Ruby 1.8 worked just fine. In fact, for years it was the most commonly used version. Then why did the Ruby core team do all of the extra work required to write a compiler and a new virtual machine? Speed. Executing a compiled Ruby program using YARV is much faster than walking through the AST directly.</p><p>How much faster is YARV? Let’s take a look! In this experiment, we’ll measure how much faster Ruby 2.0 and 1.9 are compared to Ruby 1.8 by executing the very simple Ruby script shown in <a class="xref" href="ch03.html#simple_test_script_for_benchmarking_ru" title="Example 3-5. A simple test script for benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8">Example 3-5</a>.</p><div class="example"><a id="simple_test_script_for_benchmarking_ru"/><p class="title">Example 3-5. A simple test script for benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8</p><div class="example-contents"><pre class="programlisting">i = 0
while i &lt; ARGV[0].to_i
  i += 1
end</pre></div></div><p>This script receives a count value from the command line via the <code class="literal">ARGV</code> array and then just iterates in a <code class="literal">while</code> loop counting up to that value. This Ruby script is very, very simple: By measuring the time it takes to execute this script for different values of <code class="literal">ARGV[0]</code>, we should get a good sense of whether executing YARV instructions is actually faster than iterating over AST nodes. (There are no database calls or other external code involved.)</p><p>We can use the Unix <code class="literal">time</code> command to measure how long it takes Ruby to iterate one time:</p><a id="pro_id00007"/><pre class="programlisting">$ <span class="strong"><strong>time ruby benchmark1.rb</strong></span> 1
ruby benchmark1.rb 1  0.02s user 0.00s system 92% cpu 0.023 total</pre><p>ten times:</p><a id="pro_id00008"/><pre class="programlisting">$ <span class="strong"><strong>time ruby benchmark1.rb 10</strong></span>
ruby benchmark1.rb 10  0.02s user 0.00s system 94% cpu 0.027 total</pre><p>and so on.</p><p><a class="xref" href="ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby" title="Figure 3-14. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds) vs. number of iterations on a logarithmic scale">Figure 3-14</a> shows a plot of the measured times on a logarithmic scale for Ruby 1.8.7, 1.9.3, and 2.0.</p><div class="figure"><a id="performance_of_ruby_1dot8dot7_vsdot_ruby"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00073"/><img alt="Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds) vs. number of iterations on a logarithmic scale" src="httpatomoreillycomsourcenostarchimages1853965.png.jpg"/></div></div><p class="title">Figure 3-14. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds) vs. number of iterations on a logarithmic scale</p></div><p>Looking at the chart, you can see that for short-lived processes, such as loops with a small number of iterations (see the left side of <a class="xref" href="ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby" title="Figure 3-14. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds) vs. number of iterations on a logarithmic scale">Figure 3-14</a>), Ruby 1.8.7 is actually faster than Ruby 1.9.3 and 2.0 because there is no need to compile the Ruby code into YARV instructions. Instead, after tokenizing and parsing the code, Ruby 1.8.7 immediately executes it. The time difference between Ruby 1.8.7 and Ruby 1.9.3 and 2.0 at the left side of the chart, about 0.01 seconds, tells us how long it takes Ruby 1.9.3 or 2.0 to compile the script into YARV instructions. You can also see that Ruby 2.0 is actually a bit slower than Ruby 1.9.3 for short loops.</p><p>However, after about 11,000 iterations, Ruby 1.9.3 and 2.0 are faster. This crossover occurs when the additional speed provided by executing YARV instructions begins to pay off and make up for the additional time spent compiling. For long-lived processes, such as loops with a large number of iterations (see the right side of <a class="xref" href="ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby" title="Figure 3-14. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds) vs. number of iterations on a logarithmic scale">Figure 3-14</a>), Ruby 1.9 and 2.0 are about 4.25 times faster! Also, we can see that Ruby 2.0 and 1.9.3 execute YARV instructions at exactly the same speed for many iterations.</p><p>This speed up doesn’t look like much on the logarithmic chart in <a class="xref" href="ch03.html#performance_of_ruby_1dot8dot7_vsdot_ruby" title="Figure 3-14. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 and Ruby 2.0; time (in seconds) vs. number of iterations on a logarithmic scale">Figure 3-14</a>, but notice what happens if we redraw the right side of this chart using a linear scale instead, as shown in <a class="xref" href="ch03.html#performance_of_ruby_1dot8dot7_vs-id00010" title="Figure 3-15. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 vs. Ruby 2.0; time (in seconds) for 10 or 100 million iterations on a linear scale">Figure 3-15</a>.</p><div class="figure"><a id="performance_of_ruby_1dot8dot7_vs-id00010"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00074"/><img alt="Performance of Ruby 1.8.7 vs. Ruby 1.9.3 vs. Ruby 2.0; time (in seconds) for 10 or 100 million iterations on a linear scale" src="httpatomoreillycomsourcenostarchimages1853967.png.jpg"/></div></div><p class="title">Figure 3-15. Performance of Ruby 1.8.7 vs. Ruby 1.9.3 vs. Ruby 2.0; time (in seconds) for 10 or 100 million iterations on a linear scale</p></div><p><a class="indexterm" id="iddle1554"/><a class="indexterm" id="iddle2082"/><a class="indexterm" id="iddle2083"/>The difference is dramatic! Executing this simple Ruby script using Ruby 1.9.3 or Ruby 2.0 with YARV is about 4.25 times faster than it is using Ruby 1.8.7 without YARV.</p></div><div class="sect1" title="Local and Dynamic Access of Ruby Variables"><div class="titlepage"><div><div><h1 class="title"><a id="local_and_dynamic_access_of_ruby_variabl"/>Local and Dynamic Access of Ruby Variables</h1></div></div></div><p>In the previous section, we saw how Ruby maintained an internal stack used by YARV as well as your Ruby program’s call stack. But something obvious was missing from both of the code examples: variables. Neither script used any Ruby variables. A more realistic example program would have used variables many times. How does Ruby handle variables internally? And where are they stored?</p><p>Ruby stores all of the values you save in variables on YARV’s stack, along with the parameters to and return values from the YARV instructions. However, accessing these variables is not so simple. Internally, Ruby uses two very different methods for saving and retrieving a value you save in a variable: <span class="emphasis"><em>local access</em></span> and <span class="emphasis"><em>dynamic access</em></span>.</p><div class="sect2" title="Local Variable Access"><div class="titlepage"><div><div><h2 class="title"><a id="local_variable_access"/>Local Variable Access</h2></div></div></div><p>Whenever you make a method call, Ruby sets aside some space on the YARV stack for any local variables declared inside the method you are calling. <a class="indexterm" id="iddle1219"/><a class="indexterm" id="iddle1246"/><a class="indexterm" id="iddle1250"/><a class="indexterm" id="iddle1536"/><a class="indexterm" id="iddle1793"/><a class="indexterm" id="iddle1795"/><a class="indexterm" id="iddle1826"/><a class="indexterm" id="iddle1999"/><a class="indexterm" id="iddle2037"/><a class="indexterm" id="iddle2090"/>Ruby knows how many variables you are using by consulting the <span class="emphasis"><em>local table</em></span> created for each method during the compilation step discussed in <a class="xref" href="ch02.html#local_table" title="The Local Table">The Local Table</a>.</p><p>For example, suppose we write the silly Ruby function you see in <a class="xref" href="ch03.html#example_ruby_script_that_uses_a_local" title="Figure 3-16. An example Ruby script that uses a local variable">Figure 3-16</a>.</p><div class="figure"><a id="example_ruby_script_that_uses_a_local"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00075"/><img alt="An example Ruby script that uses a local variable" src="httpatomoreillycomsourcenostarchimages1853969.png.jpg"/></div></div><p class="title">Figure 3-16. An example Ruby script that uses a local variable</p></div><p>The Ruby code is at the left of the figure; on the right is a diagram showing the YARV stack and stack pointer. You can see that Ruby stores the variables on the stack just under the stack pointer. (Notice that a space is reserved for the <code class="literal">str</code> value on the stack, three slots under <code class="literal">SP</code>, at <code class="literal">SP-3</code>.)</p><p>Ruby uses <code class="literal">svar/cref</code> to contain one of two things: either a pointer to a table of the special variables in the current method (values such as <code class="literal">$!</code> for <span class="emphasis"><em>last exception message</em></span> or <code class="literal">$&amp;</code> for <span class="emphasis"><em>last regular expression match</em></span>) or to the current lexical scope. <span class="emphasis"><em>Lexical scope</em></span> indicates which class or module you are currently adding methods to. (In <a class="xref" href="ch03.html#experiment_3-2_exploring_special_variabl" title="Experiment 3-2: Exploring Special Variables">Experiment 3-2: Exploring Special Variables</a> we’ll explore special variables in more detail, and I’ll discuss lexical scope further in <a class="xref" href="ch06.html" title="Chapter 6. Method Lookup and Constant Lookup">Chapter 6</a>.) Ruby uses the first slot—the <code class="literal">special</code> variable—to track information related to blocks. (More in a moment when we discuss dynamic variable access.)</p><p>When the example code saves a value into <code class="literal">str</code>, Ruby just needs to write the value into that space on the stack, as shown in <a class="xref" href="ch03.html#ruby_saves_local_variables_on_its_stack" title="Figure 3-17. Ruby saves local variables on its stack near the environment pointer (EP).">Figure 3-17</a>.</p><div class="figure"><a id="ruby_saves_local_variables_on_its_stack"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00076"/><img alt="Ruby saves local variables on its stack near the environment pointer (EP)." src="httpatomoreillycomsourcenostarchimages1853971.png.jpg"/></div></div><p class="title">Figure 3-17. Ruby saves local variables on its stack near the environment pointer (EP).</p></div><p>To implement this internally, YARV uses another pointer similar to the stack pointer, called the <code class="literal">EP</code> or <span class="emphasis"><em>environment pointer</em></span>. This points to where the local variables for the current method are located on the stack. Initially, <code class="literal">EP</code> is set to <code class="literal">SP-1</code>. Later on, the value of <code class="literal">SP</code> will change as YARV executes instructions, while the <code class="literal">EP</code> value will normally remain constant.</p><p><a class="xref" href="ch03.html#displayunderscorestring_method_compi" title="Figure 3-18. The display_string method compiled into YARV instructions">Figure 3-18</a> shows the YARV instructions that Ruby compiled my <code class="literal">display_string</code> function into.</p><div class="figure"><a id="displayunderscorestring_method_compi"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00077"/><img alt="The display_string method compiled into YARV instructions" src="httpatomoreillycomsourcenostarchimages1853973.png.jpg"/></div></div><p class="title">Figure 3-18. The <code class="literal">display_string</code> method compiled into YARV instructions</p></div><p><a class="indexterm" id="iddle1753"/><a class="indexterm" id="iddle1989"/><a class="indexterm" id="iddle2129"/>Ruby uses the <code class="literal">setlocal</code> YARV instruction to set the value of a local variable. However, instead of <code class="literal">setlocal</code> in <a class="xref" href="ch03.html#displayunderscorestring_method_compi" title="Figure 3-18. The display_string method compiled into YARV instructions">Figure 3-18</a>, I show an instruction called <code class="literal">setlocal_OP__WC__0</code>.</p><p>As it turns out, beginning with version 2.0, Ruby uses an optimized instruction with this confusing name instead of the simple <code class="literal">setlocal</code>. The difference is that Ruby 2.0 includes one of the parameters of the instruction, <code class="literal">0</code>, in the instruction name itself.</p><p>Internally, Ruby 2.0 calls this the <span class="emphasis"><em>operand</em></span> optimization. (In the optimized instruction name, <span class="emphasis"><em>OP</em></span> stands for <span class="emphasis"><em>operand</em></span> and <span class="emphasis"><em>WC</em></span> for <span class="emphasis"><em>wildcard</em></span>.) In other words, <code class="literal">getlocal_OP__WC__0</code> is equivalent to <code class="literal">getlocal *, 0</code>, and <code class="literal">setlocal_OP__WC__0</code> is the same as <code class="literal">setlocal *, 0</code>. The instruction now requires only one parameter, as indicated by <code class="literal">*</code>. This trick allows Ruby 2.0 to save a bit of time because it doesn’t need to pass the <code class="literal">0</code> argument separately.</p><p>But to keep things simple, let’s ignore the operand optimization. <a class="xref" href="ch03.html#compiled_version_of_displayunderscor" title="Figure 3-19. The compiled version of display_string shown without operand optimization">Figure 3-19</a> repeats the YARV instructions for my example but shows <code class="literal">getlocal</code> and <code class="literal">setlocal</code> with the second operand listed normally.</p><div class="figure"><a id="compiled_version_of_displayunderscor"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00078"/><img alt="The compiled version of display_string shown without operand optimization" src="httpatomoreillycomsourcenostarchimages1853975.png.jpg"/></div></div><p class="title">Figure 3-19. The compiled version of <code class="literal">display_string</code> shown without operand optimization</p></div><p>This a bit easier to understand. As you can see, first the <code class="literal">putstring</code> instruction saves the <code class="literal">Local access</code> string on top of the stack, incrementing the <code class="literal">SP</code> pointer. Then, YARV uses the <code class="literal">setlocal</code> instruction to get the value at the top of the stack and save it in the space allocated on the stack for the <code class="literal">str</code> local variable. The two dashed arrows on the left side of <a class="xref" href="ch03.html#compiled_version_of_displayunderscor" title="Figure 3-19. The compiled version of display_string shown without operand optimization">Figure 3-19</a> show the <code class="literal">setlocal</code> instruction copying the value. This type of operation is called <span class="emphasis"><em>local variable access</em></span>.</p><p><a class="indexterm" id="iddle1020"/><a class="indexterm" id="iddle1591"/>To determine which variable to set, <code class="literal">setlocal</code> uses the <code class="literal">EP</code> pointer and the numerical index provided as the first parameter. In this example, that would be <code class="literal">address of str = EP-2</code>. We’ll discuss what the second parameter, <code class="literal">0</code>, means in <a class="xref" href="ch03.html#dynamic_variable_access" title="Dynamic Variable Access">Dynamic Variable Access</a>.</p><p>Next, for the call to <code class="literal">puts str</code>, Ruby uses the <code class="literal">getlocal</code> instruction, as shown in <a class="xref" href="ch03.html#getting_the_value_of_a_local_variable_us" title="Figure 3-20. Getting the value of a local variable using getlocal">Figure 3-20</a>.</p><div class="figure"><a id="getting_the_value_of_a_local_variable_us"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00079"/><img alt="Getting the value of a local variable using getlocal" src="httpatomoreillycomsourcenostarchimages1853977.png.jpg"/></div></div><p class="title">Figure 3-20. Getting the value of a local variable using <code class="literal">getlocal</code></p></div><p>Here, Ruby has pushed the string value back onto the top of the stack, where it can be used as an argument for the call to the <code class="literal">puts</code> function. Again, the first parameter to <code class="literal">getlocal</code>, <code class="literal">2</code>, indicates which local variable to access. Ruby uses the local table for this snippet to find out <code class="literal">2</code> corresponds to the variable <code class="literal">str</code>.</p></div><div class="sect2" title="Method Arguments Are Treated Like Local Variables"><div class="titlepage"><div><div><h2 class="title"><a id="method_arguments_are_treated_like_local"/>Method Arguments Are Treated Like Local Variables</h2></div></div></div><p>Passing in a <span class="emphasis"><em>method argument</em></span> works the same way as accessing a local variable, as shown in <a class="xref" href="ch03.html#ruby_stores_method_arguments_on_the_stac" title="Figure 3-21. Ruby stores method arguments on the stack just like local variables.">Figure 3-21</a>.</p><div class="figure"><a id="ruby_stores_method_arguments_on_the_stac"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00080"/><img alt="Ruby stores method arguments on the stack just like local variables." src="httpatomoreillycomsourcenostarchimages1853979.png.jpg"/></div></div><p class="title">Figure 3-21. Ruby stores method arguments on the stack just like local variables.</p></div><p>Method arguments are essentially the same as local variables. The only difference between the two is that the calling code pushes the arguments onto the stack before the method call even occurs. In this example there are no local variables, but the single argument appears on the stack just like a local variable, as shown in <a class="xref" href="ch03.html#calling_code_saves_the_argument_valu" title="Figure 3-22. The calling code saves the argument values before the method is called.">Figure 3-22</a>.</p><div class="figure"><a id="calling_code_saves_the_argument_valu"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00081"/><img alt="The calling code saves the argument values before the method is called." src="httpatomoreillycomsourcenostarchimages1853981.png.jpg"/></div></div><p class="title">Figure 3-22. The calling code saves the argument values before the method is called.</p></div></div><div class="sect2" title="Dynamic Variable Access"><div class="titlepage"><div><div><h2 class="title"><a id="dynamic_variable_access"/>Dynamic Variable Access</h2></div></div></div><p><a class="indexterm" id="iddle1079"/><a class="indexterm" id="iddle1108"/><a class="indexterm" id="iddle1239"/><a class="indexterm" id="iddle1615"/><a class="indexterm" id="iddle1998"/><a class="indexterm" id="iddle2077"/><a class="indexterm" id="iddle2081"/>Now let’s see how dynamic variable access works and what that <code class="literal">special</code> value is. Ruby uses dynamic access when you use a variable that’s defined in a different scope—for example, when you write a block that references values in the surrounding code. <a class="xref" href="ch03.html#code_inside_the_block_accesses_str_i" title="Example 3-6. The code inside the block accesses str in the surrounding method.">Example 3-6</a> shows an example.</p><div class="example"><a id="code_inside_the_block_accesses_str_i"/><p class="title">Example 3-6. The code inside the block accesses <code class="literal">str</code> in the surrounding method.</p><div class="example-contents"><pre class="programlisting">def display_string
  str = "Dynamic access."
  10.times do
    puts str
  end
end</pre></div></div><p>Here, <code class="literal">str</code> is a local variable in <code class="literal">display_string</code>. As you can see in <a class="xref" href="ch03.html#ruby_saves_the_value_of_the_str_local_va" title="Figure 3-23. Ruby saves the value of the str local variable on the stack as usual.">Figure 3-23</a>, Ruby will save <code class="literal">str</code> using the <code class="literal">setlocal</code> instruction in just the same way we saw in <a class="xref" href="ch03.html#displayunderscorestring_method_compi" title="Figure 3-18. The display_string method compiled into YARV instructions">Figure 3-18</a>.</p><div class="figure"><a id="ruby_saves_the_value_of_the_str_local_va"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00082"/><img alt="Ruby saves the value of the str local variable on the stack as usual." src="httpatomoreillycomsourcenostarchimages1853983.png.jpg"/></div></div><p class="title">Figure 3-23. Ruby saves the value of the <code class="literal">str</code> local variable on the stack as usual.</p></div><p>Next, Ruby will call the <code class="literal">10.times</code> method, passing a block in as an argument. Let’s step through the process of calling a method with a block. <a class="indexterm" id="iddle1132"/><a class="indexterm" id="iddle1445"/><a class="indexterm" id="iddle1857"/><a class="xref" href="ch03.html#when_ruby_calls_a_method_passing_in_a_bl" title="Figure 3-24. When Ruby calls a method passing in a block, it saves a pointer to a new rb_block_t structure as the special value in the new stack frame.">Figure 3-24</a> shows the same process we saw in <a class="xref" href="ch03.html#every_ruby_program_starts_with_these_two" title="Figure 3-10. Every Ruby program starts with these two control frames.">Figure 3-10</a>, <a class="xref" href="ch03.html#ruby_uses_the_cfunc_frame_when_you_call" title="Figure 3-11. Ruby uses the CFUNC frame when you call built-in functions implemented in C.">Figure 3-11</a>, and <a class="xref" href="ch03.html#cfp_stack_when_we_pause_the_code_fro" title="Figure 3-12. The CFP stack when we pause the code from Example 3-2 inside the block">Figure 3-12</a> but with more details about YARV’s internal stack.</p><div class="figure"><a id="when_ruby_calls_a_method_passing_in_a_bl"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00083"/><img alt="When Ruby calls a method passing in a block, it saves a pointer to a new rb_block_t structure as the special value in the new stack frame." src="httpatomoreillycomsourcenostarchimages1853985.png.jpg"/></div></div><p class="title">Figure 3-24. When Ruby calls a method passing in a block, it saves a pointer to a new <code class="literal">rb_block_t</code> structure as the special value in the new stack frame.</p></div><p>Notice the value <code class="literal">10</code> on the stack: This is the actual receiver of the <code class="literal">times</code> method. Notice too that Ruby has created a new stack frame with <code class="literal">svar/cref</code> and <code class="literal">special</code> above the value <code class="literal">10</code> for the C code that implements <code class="literal">Integer#times</code> to use. Because we passed a block into the method call, Ruby saves a pointer to this block in the <code class="literal">special</code> variable in the new stack frame. Each frame on the YARV stack corresponding to a method call tracks whether there was a block argument using this <code class="literal">special</code> variable. (I’ll discuss blocks and the <code class="literal">rb_block_t</code> structure in more detail in <a class="xref" href="ch08.html" title="Chapter 8. How Ruby Borrowed a Decades-Old Idea from Lisp">Chapter 8</a>.)</p><p>Now the <code class="literal">Integer#times</code> method yields to or calls the block’s code 10 times. <a class="xref" href="ch03.html#how_yarvapostrophes_stack_would_appear_i" title="Figure 3-25. How YARV’s stack would appear if we halted execution inside the block">Figure 3-25</a> shows how the YARV stack appears when Ruby is executing the code inside the block.</p><div class="figure"><a id="how_yarvapostrophes_stack_would_appear_i"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00084"/><img alt="How YARV’s stack would appear if we halted execution inside the block" src="httpatomoreillycomsourcenostarchimages1853987.png.jpg"/></div></div><p class="title">Figure 3-25. How YARV’s stack would appear if we halted execution inside the block</p></div><p>Just as we saw in <a class="xref" href="ch03.html#ruby_saves_local_variables_on_its_stack" title="Figure 3-17. Ruby saves local variables on its stack near the environment pointer (EP).">Figure 3-17</a> through <a class="xref" href="ch03.html#calling_code_saves_the_argument_valu" title="Figure 3-22. The calling code saves the argument values before the method is called.">Figure 3-22</a>, Ruby sets <code class="literal">EP</code> to point to the location of the <code class="literal">special</code> value in each stack frame. <a class="xref" href="ch03.html#how_yarvapostrophes_stack_would_appear_i" title="Figure 3-25. How YARV’s stack would appear if we halted execution inside the block">Figure 3-25</a> shows one value of <code class="literal">EP</code> for the new stack frame used by the block near the top of the stack and a second value of <code class="literal">EP</code> in the original method’s stack frame near the bottom. In <a class="xref" href="ch03.html#how_yarvapostrophes_stack_would_appear_i" title="Figure 3-25. How YARV’s stack would appear if we halted execution inside the block">Figure 3-25</a> this second pointer is labeled <span class="emphasis"><em>Previous EP</em></span>.</p><p>Now, what happens when Ruby executes the <code class="literal">puts str</code> code inside the block? Ruby needs to obtain the value of the local variable <code class="literal">str</code> and pass it to the <code class="literal">puts</code> function as an argument. But notice in <a class="xref" href="ch03.html#how_yarvapostrophes_stack_would_appear_i" title="Figure 3-25. How YARV’s stack would appear if we halted execution inside the block">Figure 3-25</a> that <code class="literal">str</code> is located farther down the stack. It’s not a local variable inside the block; rather, it’s a variable in the surrounding method, <code class="literal">display_string</code>. How does Ruby obtain the value from farther down the stack while executing code inside the block?</p><p>This is where dynamic variable access comes in and why Ruby needs those <code class="literal">special</code> values in each stack frame. <a class="xref" href="ch03.html#ruby_using_dynamic_variable_access_to_ob" title="Figure 3-26. Ruby using dynamic variable access to obtain the value of str from farther down the stack">Figure 3-26</a> shows how dynamic variable access works.</p><div class="figure"><a id="ruby_using_dynamic_variable_access_to_ob"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00085"/><img alt="Ruby using dynamic variable access to obtain the value of str from farther down the stack" src="httpatomoreillycomsourcenostarchimages1853989.png.jpg"/></div></div><p class="title">Figure 3-26. Ruby using dynamic variable access to obtain the value of <code class="literal">str</code> from farther down the stack</p></div><p>The dashed arrows indicate dynamic variable access: The <code class="literal">getlocal</code> YARV instruction copies the value of <code class="literal">str</code> from the lower stack frame (from the parent or outer Ruby scope) to the top of the stack, where the block can access it. Notice how the <code class="literal">EP</code> pointers form a kind of ladder that Ruby can climb to access the local variables in the parent scope, the grandparent scope, and so on.</p><p>In the <code class="literal">getlocal 2, 1</code> call in <a class="xref" href="ch03.html#ruby_using_dynamic_variable_access_to_ob" title="Figure 3-26. Ruby using dynamic variable access to obtain the value of str from farther down the stack">Figure 3-26</a>, the second parameter, <code class="literal">1</code>, tells Ruby where to find the variable. In this example, Ruby will follow the ladder of <code class="literal">EP</code> pointers one level down the stack to find <code class="literal">str</code>. That is, <code class="literal">1</code> means step once from the block’s scope to the surrounding method’s scope.</p><p><a class="indexterm" id="iddle1165"/><a class="indexterm" id="iddle1249"/><a class="indexterm" id="iddle1356"/><a class="indexterm" id="iddle1357"/><a class="indexterm" id="iddle1520"/><a class="indexterm" id="iddle1791"/><a class="indexterm" id="iddle2097"/><a class="indexterm" id="iddle2114"/><a class="xref" href="ch03.html#in_this_examplecomma_ruby_would_step_two" title="Example 3-7. In this example, Ruby would step two levels down the stack to find str using dynamic variable access.">Example 3-7</a> shows another example of dynamic variable access.</p><div class="example"><a id="in_this_examplecomma_ruby_would_step_two"/><p class="title">Example 3-7. In this example, Ruby would step two levels down the stack to find <span class="emphasis"><em>str</em></span> using dynamic variable access.</p><div class="example-contents"><pre class="programlisting">def display_string
  str = "Dynamic access."
  10.times do
    10.times do
      puts str
    end
  end
end</pre></div></div><p>If I had two nested blocks, as in <a class="xref" href="ch03.html#in_this_examplecomma_ruby_would_step_two" title="Example 3-7. In this example, Ruby would step two levels down the stack to find str using dynamic variable access.">Example 3-7</a>, Ruby would have used <code class="literal">getlocal 2, 2</code> instead of <code class="literal">getlocal 2, 1</code>.</p><div class="sidebar"><a id="climbing_the_environment_pointer_ladder"/><p class="title">Climbing the Environment Pointer Ladder in C</p><p>Let’s look at the actual C implementation of <code class="literal">getlocal</code>. As it does with most YARV instructions, Ruby implements <code class="literal">getlocal</code> in the <span class="emphasis"><em>insns.def</em></span> code file, using the code shown in <a class="xref" href="ch03.html#c_implementation_of_the_getlocal_yar" title="Example 3-8. The C implementation of the getlocal YARV instruction">Example 3-8</a>.</p><div class="example"><a id="c_implementation_of_the_getlocal_yar"/><p class="title">Example 3-8. The C implementation of the <code class="literal">getlocal</code> YARV instruction</p><div class="example-contents"><pre class="programlisting">    /**
      @c variable
      @e Get local variable (pointed by `idx' and `level').
         'level' indicates the nesting depth from the current block.
      @j level, idx で指定されたローカル変数の値をスタックに置く。
         level はブロックのネストレベルで、何段上かを示す。
     */
    DEFINE_INSN
    getlocal
    (lindex_t idx, rb_num_t level)
    ()
    (VALUE val)
    {
        int i, lev = (int)level;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>     VALUE *ep = GET_EP();
    
        for (i = 0; i &lt; lev; i++) {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>         ep = GET_PREV_EP(ep);
        }
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>     val = *(ep - idx);
    }</pre></div></div><p>First, the <code class="literal">GET_EP</code> macro <span class="inlinemediaobject"><a id="inline_id00073"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> returns the <code class="literal">EP</code> from the current scope. (This macro is defined in the <span class="emphasis"><em>vm_insnhelper.h</em></span> file along with a number of other macros related to <a class="indexterm" id="iddle1027"/><a class="indexterm" id="iddle1286"/><a class="indexterm" id="iddle1358"/><a class="indexterm" id="iddle1825"/><a class="indexterm" id="iddle2000"/><a class="indexterm" id="iddle2036"/>YARV instructions.) Next, Ruby iterates over the <code class="literal">EP</code> pointers, moving from the current to the parent scope and then from the parent to the grandparent scope by repeatedly dereferencing the <code class="literal">EP</code> pointers. Ruby uses the <code class="literal">GET_PREV_EP</code> macro at <span class="inlinemediaobject"><a id="inline_id00074"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> (also defined in <span class="emphasis"><em>vm_insnhelper.h</em></span>) to move from one <code class="literal">EP</code> to another. The <code class="literal">level</code> parameter tells Ruby how many times to iterate or how many rungs of the ladder to climb.</p><p>Finally, Ruby obtains the target variable using the <code class="literal">idx</code> parameter at <span class="inlinemediaobject"><a id="inline_id00075"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>, which is the index of the target variable. As a result, this line of code gets the value from the target variable.</p><a id="pro_id00009"/><pre class="programlisting">val = *(ep – idx);</pre><p>This code means the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Start from the address of the <code class="literal">EP</code> for the target scope <code class="literal">ep</code>, obtained previously from the <code class="literal">GET_PREV_EP</code> iterations.</p></li><li class="listitem"><p>Subtract <code class="literal">idx</code> from this address. The integer value <code class="literal">idx</code> gives <code class="literal">getlocal</code> the index of the local variable that you want to load from the local table. In other words, it tells <code class="literal">getlocal</code> how far down the stack the target variable is located.</p></li><li class="listitem"><p>Get the value from the YARV stack at the adjusted address.</p></li></ul></div><p>Therefore, in the call to <code class="literal">getlocal</code> in <a class="xref" href="ch03.html#ruby_using_dynamic_variable_access_to_ob" title="Figure 3-26. Ruby using dynamic variable access to obtain the value of str from farther down the stack">Figure 3-26</a>, YARV will take the <code class="literal">EP</code> from the scope one level down on the YARV stack and subtract the index value <code class="literal">str</code> (in this case, <code class="literal">2</code>) to obtain a pointer to the <code class="literal">str</code> variable.</p><a id="pro_id00010"/><pre class="programlisting">getlocal 2, 1</pre></div></div></div><div class="sect1" title="Experiment 3-2: Exploring Special Variables"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_3-2_exploring_special_variabl"/>Experiment 3-2: Exploring Special Variables</h1></div></div></div><p>In <a class="xref" href="ch03.html#example_ruby_script_that_uses_a_local" title="Figure 3-16. An example Ruby script that uses a local variable">Figure 3-16</a> through <a class="xref" href="ch03.html#ruby_using_dynamic_variable_access_to_ob" title="Figure 3-26. Ruby using dynamic variable access to obtain the value of str from farther down the stack">Figure 3-26</a>, I showed you a value called <code class="literal">svar/cref</code> in the <code class="literal">EP-1</code> position on the stack. What are these two values, and how can Ruby save two values in one location on the stack? For that matter, why does it do this? Let’s find out.</p><p>Usually, the <code class="literal">EP-1</code> slot in the stack will contain the <code class="literal">svar</code> value, which is a pointer to a table of any special variables defined in this stack frame. In Ruby the term <span class="emphasis"><em>special variables</em></span> refers to values that Ruby automatically creates as a matter of convenience, based on the environment or on recent operations. For example, Ruby sets <code class="literal">$*</code> to the <code class="literal">ARGV</code> array and <code class="literal">$!</code> to the last exception raised.</p><p>All special variables begin with the dollar sign (<code class="literal">$</code>) character, which usually indicates a global variable. Does that mean that special variables are global variables? If so, then why does Ruby save a pointer to them on the stack?</p><p><a class="indexterm" id="iddle1002"/><a class="indexterm" id="iddle2001"/>To answer this question, let’s create a simple Ruby script to match a string using a regular expression.</p><a id="pro_id00011"/><pre class="programlisting">/fox/.match("The quick brown fox jumped over the lazy dog.\n")
puts "Value of $&amp; in the top level scope: #{$&amp;}"</pre><p>Here I match the word <code class="literal">fox</code> in the string using a regex, and then I print the matching string using the <code class="literal">$&amp;</code> special variable. Here’s the output I get running this at the console.</p><a id="pro_id00012"/><pre class="programlisting">$ <span class="strong"><strong>ruby regex.rb</strong></span>
Value of $&amp; in the top level scope: fox</pre><p><a class="xref" href="ch03.html#referring_to_dollarampersand_from_two_di" title="Example 3-9. Referring to $&amp; from two different scopes">Example 3-9</a> shows another example, this time searching for the same string twice: first in the top-level scope and then again from inside a method call.</p><div class="example"><a id="referring_to_dollarampersand_from_two_di"/><p class="title">Example 3-9. Referring to <code class="literal">$&amp;</code> from two different scopes</p><div class="example-contents"><pre class="programlisting">    str = "The quick brown fox jumped over the lazy dog.\n"
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> /fox/.match(str)
    
    def search(str)
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   /dog/.match(str)
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   puts "Value of $&amp; inside method: #{$&amp;}"
    end
    search(str)
    
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/> puts "Value of $&amp; in the top level scope: #{$&amp;}"</pre></div></div><p>This is simple Ruby code, but it still may be a bit confusing. Here’s how this works:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>We search the string in the top scope for <code class="literal">fox</code> at <span class="inlinemediaobject"><a id="inline_id00080"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. This matches and saves <code class="literal">fox</code> into the <code class="literal">$&amp;</code> special variable.</p></li><li class="listitem"><p>We call the <code class="literal">search</code> method and search for <code class="literal">dog</code> at <span class="inlinemediaobject"><a id="inline_id00081"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span><code class="literal">.</code> I immediately print the match using the same <code class="literal">$&amp;</code> variable inside the method at <span class="inlinemediaobject"><a id="inline_id00082"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>.</p></li><li class="listitem"><p>Finally, we return to the top-level scope and print the value of <code class="literal">$&amp;</code> again at <span class="inlinemediaobject"><a id="inline_id00083"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span>.</p></li></ul></div><p>Running this test gives the following output.</p><a id="pro_id00013"/><pre class="programlisting">$ <span class="strong"><strong>ruby regex_method.rb</strong></span>
Value of $&amp; inside method: dog
Value of $&amp; in the top level scope: fox</pre><p>This is what we expect, but consider the following for a moment. The <code class="literal">$&amp;</code> variable is obviously not global because it has different values at different places in my Ruby script. Ruby preserves the value of <code class="literal">$&amp;</code> from the top-level scope when executing the <code class="literal">search</code> method, which allows me to print the matching word <code class="literal">fox</code> from the original search. Ruby provides for this behavior by saving a separate set of special variables at each level of the stack using the <code class="literal">svar</code> value, as shown in <a class="xref" href="ch03.html#each_stack_frame_has_its_own_set_of_spec" title="Figure 3-27. Each stack frame has its own set of special variables.">Figure 3-27</a>.</p><div class="figure"><a id="each_stack_frame_has_its_own_set_of_spec"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00086"/><img alt="Each stack frame has its own set of special variables." src="httpatomoreillycomsourcenostarchimages1853991.png"/></div></div><p class="title">Figure 3-27. Each stack frame has its own set of special variables.</p></div><p>Notice that Ruby saved the <code class="literal">fox</code> string in a table referred to by the <code class="literal">svar</code> pointer for the top-level scope and saved the <code class="literal">dog</code> string in a different table for the inner-method scope. Ruby finds the proper special variable table using the <code class="literal">EP</code> pointer for each stack frame.</p><p>Ruby saves actual global variables (variables you define using a dollar sign prefix) in a single, global hash table. Regardless of where you save or retrieve the value of a normal global variable, Ruby accesses the same global hash table.</p><p>Now for one more test: What if I perform the search inside a block and not a method? <a class="xref" href="ch03.html#displaying_the_value_of_dollarampersand" title="Example 3-10. Displaying the value of $&amp; from inside a block">Example 3-10</a> shows this new search.</p><div class="example"><a id="displaying_the_value_of_dollarampersand"/><p class="title">Example 3-10. Displaying the value of <code class="literal">$&amp;</code> from inside a block</p><div class="example-contents"><pre class="programlisting">str = "The quick brown fox jumped over the lazy dog.\n"
/fox/.match(str)

2.times do
  /dog/.match(str)
  puts "Value of $&amp; inside block: #{$&amp;}"
end

puts "Value of $&amp; in the top-level scope: #{$&amp;}"</pre></div></div><p><a class="indexterm" id="iddle1220"/><a class="indexterm" id="iddle1254"/><a class="indexterm" id="iddle1422"/><a class="indexterm" id="iddle1537"/><a class="indexterm" id="iddle1633"/><a class="indexterm" id="iddle1638"/><a class="indexterm" id="iddle1794"/>Here’s the output I get at the console this time.</p><a id="pro_id00014"/><pre class="programlisting">$ <span class="strong"><strong>ruby regex_block.rb</strong></span>
Value of $&amp; inside block: dog
Value of $&amp; inside block: dog
Value of $&amp; in the top-level scope: dog</pre><p>Notice that now Ruby has overwritten the value of <code class="literal">$&amp;</code> in the top scope with the matching word <code class="literal">dog</code> from the search I performed inside the block! This is by design: Ruby considers the top-level and inner-block scope to be the same with regard to special variables. This is similar to how dynamic variable access works; we expect variables inside the block to have the same values as those in the parent scope.</p><p><a class="xref" href="ch03.html#ruby_uses_the_ep-1_stack_position_for_cr" title="Figure 3-28. Ruby uses the EP-1 stack position for cref in blocks and for svar otherwise.">Figure 3-28</a> shows how Ruby implements this behavior.</p><div class="figure"><a id="ruby_uses_the_ep-1_stack_position_for_cr"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00087"/><img alt="Ruby uses the EP-1 stack position for cref in blocks and for svar otherwise." src="httpatomoreillycomsourcenostarchimages1853993.png.jpg"/></div></div><p class="title">Figure 3-28. Ruby uses the <code class="literal">EP-1</code> stack position for <code class="literal">cref</code> in blocks and for <code class="literal">svar</code> otherwise.</p></div><p>As you can see in <a class="xref" href="ch03.html#ruby_uses_the_ep-1_stack_position_for_cr" title="Figure 3-28. Ruby uses the EP-1 stack position for cref in blocks and for svar otherwise.">Figure 3-28</a>, Ruby has just a single special variable table for the top-level scope. It finds the special variables using the previous <code class="literal">EP</code> pointer, which points to the top-level scope. Inside the block scope (because there is no need for a separate copy of the special variables), Ruby takes advantage of the <code class="literal">EP-1</code> open slot and saves the value <code class="literal">cref</code> there instead. Ruby uses the <code class="literal">cref</code> value to keep track of which lexical scope this block belongs to. <span class="emphasis"><em>Lexical scope</em></span> refers to a section of code within the syntactical structure of your program and is used by Ruby to look up constant values. (See <a class="xref" href="ch06.html" title="Chapter 6. Method Lookup and Constant Lookup">Chapter 6</a> for more on lexical scope.) Specifically, Ruby uses the <code class="literal">cref</code> value here to implement metaprogramming API calls, such as <code class="literal">eval</code> and <code class="literal">instance_eval</code>. The <code class="literal">cref</code> value indicates whether the given block should be executed in a different lexical scope compared to the parent scope. (See <a class="xref" href="ch09.html#instanceunderscoreeval_creates_a_singlet" title="instance_eval Creates a Singleton Class for a New Lexical Scope">instance_eval Creates a Singleton Class for a New Lexical Scope</a>.)</p><div class="sidebar"><a id="definitive_list_of_special_variables"/><p class="title">A Definitive List of Special Variables</p><p><a class="indexterm" id="iddle1028"/><a class="indexterm" id="iddle1774"/><a class="indexterm" id="iddle1777"/><a class="indexterm" id="iddle2002"/>One place to find an accurate list of all the special variables that Ruby supports is the C source itself. For example, <a class="xref" href="ch03.html#consulting_parsedoty_is_a_good_way_to_fi" title="Example 3-11. Consulting parse.y is a good way to find a definitive list of Ruby’s many special variables.">Example 3-11</a> is a piece of Ruby’s C source code that tokenizes your Ruby program, as snipped from the <code class="literal">parser_yylex</code> function located in <span class="emphasis"><em>parse.y</em></span>:</p><div class="example"><a id="consulting_parsedoty_is_a_good_way_to_fi"/><p class="title">Example 3-11. Consulting <span class="emphasis"><em>parse.y</em></span> is a good way to find a definitive list of Ruby’s many special variables.</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> case '$':
    lex_state = EXPR_END;
    newtok();
    c = nextc();
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> switch (c) {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   case '_':            /* $_: last read line string */
        c = nextc();
        if (parser_is_identchar()) {
            tokadd('$');
            tokadd('_');
            break;
        }
        pushback(c);
        c = '_';
        /* fall through */
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>   case '~':            /* $~: match-data */
      case '*':            /* $*: argv */
      case '$':            /* $$: pid */
      case '?':            /* $?: last status */
      case '!':            /* $!: error string */
      case '@':            /* $@: error position */
      case '/':            /* $/: input record separator */
      case '\\':           /* $\: output record separator */
      case ';':            /* $;: field separator */
      case ',':            /* $,: output field separator */
      case '.':            /* $.: last read line number */
      case '=':            /* $=: ignorecase */
      case ':':            /* $:: load path */
      case '&lt;':            /* $&lt;: reading filename */
      case '&gt;':            /* $&gt;: default output handle */
      case '\"':           /* $": already loaded files */
        tokadd('$');
        tokadd(c);
        tokfix();
        set_yylval_name(rb_intern(tok()));
        return tGVAR;</pre></div></div><p>Notice at <span class="inlinemediaobject"><a id="inline_id00088"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> that Ruby matches a dollar sign character (<code class="literal">$</code>). This is part of the large C <code class="literal">switch</code> statement that tokenizes your Ruby code—the process I discussed in <a class="xref" href="ch01.html#tokens_the_words_that_make_up_the_ruby_l" title="Tokens: The Words That Make Up the Ruby Language">Tokens: The Words That Make Up the Ruby Language</a>. This is <a class="indexterm" id="iddle1733"/><a class="indexterm" id="iddle1901"/><a class="indexterm" id="iddle2003"/><a class="indexterm" id="iddle2004"/>followed by an inner <code class="literal">switch</code> statement at <span class="inlinemediaobject"><a id="inline_id00089"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> that matches on the following character. Each of these characters and each of the <code class="literal">case</code> statements that follow (at <span class="inlinemediaobject"><a id="inline_id00090"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> and after <span class="inlinemediaobject"><a id="inline_id00091"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span>) correspond to one of Ruby’s special variables.</p><p>Just a bit farther down in the function, more C code (see <a class="xref" href="ch03.html#these_case_statements_correspond_to_ruby" title="Example 3-12. These case statements correspond to Ruby’s regex-related special variables.">Example 3-12</a>) parses other special variable tokens that you write in your Ruby code, such as <code class="literal">$&amp;</code> and related special variables.</p><div class="example"><a id="these_case_statements_correspond_to_ruby"/><p class="title">Example 3-12. These <code class="literal">case</code> statements correspond to Ruby’s regex-related special variables.</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> case '&amp;':                /* $&amp;: last match */
    case '`':                /* $`: string before last match */
    case '\'':               /* $': string after last match */
    case '+':                /* $+: string matches last paren. */
      if (last_state == EXPR_FNAME) {
          tokadd('$');
          tokadd(c);
          goto gvar;
      }
      set_yylval_node(NEW_BACK_REF(c));
      return tBACK_REF;</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00093"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> you can see four more <code class="literal">case</code> statements corresponding to the special variables <code class="literal">$&amp;</code>, <code class="literal">$`</code>, <code class="literal">$/</code>, and <code class="literal">$+</code>, all related to regular expressions.</p><p>Finally, the code in <a class="xref" href="ch03.html#this_c_code_tokenizes_rubyapostrophes_nt" title="Example 3-13. This C code tokenizes Ruby’s nth back reference special variables: $1, $2, and so forth.">Example 3-13</a> tokenizes <code class="literal">$1</code>, <code class="literal">$2</code>, and so on, producing the special variables that return the nth back reference from the last regular expression operation.</p><div class="example"><a id="this_c_code_tokenizes_rubyapostrophes_nt"/><p class="title">Example 3-13. This C code tokenizes Ruby’s nth back reference special variables: <code class="literal">$1</code>, <code class="literal">$2</code>, and so forth.</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> case '1': case '2': case '3':
    case '4': case '5': case '6':
    case '7': case '8': case '9':
      tokadd('$');
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   do {
          tokadd(c);
          c = nextc();
      } while (c != -1 &amp;&amp; ISDIGIT(c));
      pushback(c);
      if (last_state == EXPR_FNAME) goto gvar;
      tokfix();
      set_yylval_node(NEW_NTH_REF(atoi(tok()+1)));
      return tNTH_REF;</pre></div></div><p>The <code class="literal">case</code> statements at <span class="inlinemediaobject"><a id="inline_id00096"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> match the numerical digits 1 through 9, while the C <code class="literal">do...while</code> loop at <span class="inlinemediaobject"><a id="inline_id00097"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> continues to process digits until an entire number is read in. This allows you to create special variables with multiple digits, such as <code class="literal">$12</code>.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00011"/>Summary</h1></div></div></div><p>We’ve covered a lot of ground in this chapter. We began by looking at how Ruby keeps track of two stacks: an internal stack YARV uses and your Ruby call stack. Next, we saw how YARV executed two simple Ruby programs: one that calculated 2 + 2 = 4 and another that called a block 10 times. In <a class="xref" href="ch03.html#experiment_3-1_benchmarking_ruby_2dot0_a" title="Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8">Experiment 3-1: Benchmarking Ruby 2.0 and Ruby 1.9 vs. Ruby 1.8</a> we learned that executing YARV instructions in Ruby 2.0 and 1.9 is almost four times faster than in Ruby 1.8, which executes your program directly from the AST.</p><p>We moved on to look at how Ruby saves variables on the internal YARV stack using two methods: local and dynamic variable access. We also saw how method arguments are handled by Ruby in just the same way as local variables. In <a class="xref" href="ch03.html#experiment_3-2_exploring_special_variabl" title="Experiment 3-2: Exploring Special Variables">Experiment 3-2: Exploring Special Variables</a> we finished with a look at how Ruby handles special variables.</p><p>When you run any Ruby program, you are actually using a virtual machine designed specifically to execute Ruby programs. By examining how this machine works on a detailed level, we’ve acquired a deeper understanding of how the Ruby language works and, for example, what happens when you call a method or save a value in a local variable. In <a class="xref" href="ch04.html" title="Chapter 4. Control Structures and Method Dispatch">Chapter 4</a> we’ll continue to explore this virtual machine by looking at how control structures work and at YARV’s method dispatch process.</p></div></div></body></html>