- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 15 INTERACTIVE BATCH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let me be the one to break it to you if there was any doubt in your mind. Batch
    doesn’t have a graphical user interface (GUI), but it does have a functional user
    interface (UI). In this chapter, I’ll discuss different means of getting input
    from the user into a bat file as it executes, such as selecting one option from
    a list or typing in a response to a question. I’ll also describe how to alter
    the visual display or look and feel of the console including clearing the screen,
    changing colors, and updating the title. Finally, I’ll bring everything together
    to build a fully operational Batch UI (BUI) ready to execute.
  prefs: []
  type: TYPE_NORMAL
- en: UIs, GUIs, and BUIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A user interface at its core is a means for the user to communicate with a
    computer, passing information in and getting something back. Every time you make
    an online purchase, you’re using a graphical user interface, which is a more sophisticated
    user interface with graphics allowing user input from more than just a keyboard.
    A video game is a glorified UI, and every time you touch an icon on your smartphone
    to open an app, you’re using a user interface. Commander Data of *Star Trek: The
    Next Generation* was (or will be) an android, possessing an incredibly advanced
    UI able to interact with humans with use of all five senses.'
  prefs: []
  type: TYPE_NORMAL
- en: Sticking with the science-fiction theme, the Batch UI is more along the lines
    of the 1983 movie *War Games*. There are no panels, drop-downs, icons, menus,
    or radio buttons, and certainly no touchscreen or voice commands in the Batch
    UI, or BUI (pronounced boo-ē). Be warned, if you use this term with coders, you’ll
    likely receive some blank stares and raised eyebrows. I’ve tried but so far failed
    to add BUI to the coding lexicon, but I hold out hope that it’ll still catch on.
  prefs: []
  type: TYPE_NORMAL
- en: The BUI isn’t sexy, but it can ask questions of the user, who can then respond
    by entering a string of text or selecting an option from a list by pressing a
    single key. A coder would be a sadist to use Batch to build a complex UI for a
    large number of users, not to mention soon-to-be unemployed. But there are many
    instances when a bat file needs a piece of data or two from the user, especially
    if the user is also the coder. I’ve coded a number of BUIs, but for each one I
    can count on one hand the number of people who’ve ever used it.
  prefs: []
  type: TYPE_NORMAL
- en: The possible needs for a BUI are plentiful. Your bat file might be copying files
    to or from a server, where you ask the user to specify the server. As another
    example, you might want to create a report but be able to generate it from test
    or production data depending on the user’s preference. Or you might ask the user
    to enter a date range of files to be backed up.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Selection from a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two commands allow the user to input data into a BUI. One asks for the user
    to choose one out of multiple possible selections, and the other asks for a typed
    freeform response. The first one is the choice command, and as the name suggests,
    it allows the user to make a *choice* from a list of two or more selections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let’s ask the user a question—Do you want a Joke, Pun, or Riddle?—and
    allow them to enter J, P, or R for one of the three selections, respectively.
    The following choice command does just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The /C option lists the *choices*, /C:JPR, and the text encased in double quotes
    associated with the /M option is the *message* presented to the user. Both of
    these options also work without the colon delimiter. That is, /C JPR is functionally
    equivalent to /C:JPR, but I much prefer the colon because it nicely ties the option
    to its values or its message, much like a valued rug ties a room together. Also,
    notice the lack of the question mark at the end of the question. The interpreter
    adds the punctuation after giving the user the list of possible selections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous command displays the following to the user on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The execution of the bat file suspends at the choice command until the user
    presses one of the three keys (or exits the command window). If the user presses
    a key not on the list, the computer beeps and continues to wait, but what happens
    when the user selects one of the choices?
  prefs: []
  type: TYPE_NORMAL
- en: Up until this point errorlevel has merely been a return code, usually 0 for
    the successful execution of a command and something greater than 0 for a failure.
    But after a choice command executes, it sets errorlevel to the user’s selection;
    more specifically, it’s set to the integer value corresponding to the position
    of the user’s selection in the list. More simply, if the choices are defined by
    /C:JPR, selecting J returns 1, P returns 2, and R returns 3.
  prefs: []
  type: TYPE_NORMAL
- en: I find it a bit misleading that the variable returning the valid selection contains
    the word *error* in its name, but after getting over the issue of semantics and
    the fact that this reserved word is doing double duty, it’s not difficult to interrogate
    the variable to determine the user’s selection and which logic to execute next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example of a choice command that also appears to be missing
    something (other than a question mark):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The /C option is missing, but this is a yes or no question, and when that option
    is omitted, the implied default is /C:YN, returning 1 for Y and 2 for N.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two additional options always go hand in hand with each other. The /T option
    sets the *timeout*, or the number of seconds given before the command times out
    and the interpreter chooses the *default* selection defined by the /D option.
    The following command gives the user 20 seconds, /T:20, to make a selection before
    a pun, /D:P, is inflicted upon them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes it doesn’t make sense to list the selections. For instance, when
    asking the user to rate something on a scale from 1 to 5, it might instead be
    preferable to explain the rating system with some text. Assume that you want to
    pose the following to the user requesting a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Together, the following echo command and choice command produce the desired
    text and wait for a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You’ll need the /C:12345 option so that the interpreter has the list of possible
    selections, but you don’t want [1,2,3,4,5]? displayed because it’ll compete with
    the instructions on the prior line. The /N option (*no choice keys*) suppresses
    the display of choices, showing only the desired message to the user. The question
    mark is also suppressed with the /N option, but you can include it in the message
    string if the message is posed as a question.
  prefs: []
  type: TYPE_NORMAL
- en: If a bat file is to perform a task on a selected server, a series of echo commands
    could list any number of servers along with their associated keyboard keys as
    a prelude to a choice command. That would work great for a predefined list of
    servers, but if the list is particularly long or unknown at coding time, you can
    instead ask the user to key in any server name with the next command.
  prefs: []
  type: TYPE_NORMAL
- en: Freeform User Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other command allowing the user to input data is the set command (from [Chapter
    2](chapter2.xhtml)) when used with the /P or *prompt string* option. Much like
    its optionless counterpart, the set /P command assigns a value to a variable,
    where that value can be a string of any reasonable length or even null. The difference
    is that the text after the equal sign isn’t the value assigned; it’s the prompt
    string displayed to the user. Whatever the user enters is assigned to the variable
    once they press ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, the question after the equal sign is displayed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The execution is put on hold until the user responds, at which point the interpreter
    assigns that response to the yourAns variable.
  prefs: []
  type: TYPE_NORMAL
- en: Forget to use the /P option, and the variable is assigned to the text after
    the equal sign without prompting of the user. Notice three minor yet important
    details. First, this command doesn’t append the question mark to the message string,
    so I added it. Second, I added a couple of spaces after that question mark to
    move the start of the response away from the question. Finally, I terminated the
    line with an ampersand to make those spaces obvious at a glance. These subtle
    tweaks will be equally appreciated by your users and any readers of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every joke needs a punchline, and it’s displayed to the user on the second
    line of the following code after they have had a chance to ponder the question
    and enter a guess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The third and final line displays the user’s answer encased in double quotes.
    It’s a joke. I didn’t say it was a good joke.
  prefs: []
  type: TYPE_NORMAL
- en: Altering the UI Look and Feel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Batch provides three more commands that alter the look and feel of the console,
    and a couple of them have additional applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating the Title**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a bat file executes, a command window opens, and the title in the white
    bar across its top is likely to be *C:\WINDOWS\system32\cmd.exe*, the program
    that runs a bat file. The title command resets that title to something a little
    more identifiable and far less generic. The following changes the title to the
    text that follows it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The embedded spaces in the argument list aren’t an issue, and if you encase
    the text in double quotes, they’ll also be part of the title.
  prefs: []
  type: TYPE_NORMAL
- en: Use of this command isn’t limited to interactive bat files where its value is
    obvious. Any bat file that runs on a machine where other bat files might also
    be running can only be enhanced by a title. If one of those bat files is hung
    or otherwise trapped in an endless loop, which one should be killed? If none of
    them has a title, they may all look identical, leaving you no way of knowing.
    The title command solves this problem. In fact, I’ll use this command in [Chapter
    26](chapter26.xhtml), where I’ll title a process susceptible to hanging so that
    another bat file can find it and kill it, if it does indeed hang. You can even
    reset the title multiple times during a run, perhaps showing the status or the
    step being executed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clearing the Screen**'
  prefs: []
  type: TYPE_NORMAL
- en: The cls command is a severe abbreviation of *clear screen*. When this optionless
    command executes, the screen or console is cleared, revealing a blank (and for
    now black) canvas. To cut through the noise, you can execute this command before
    posing a question to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing Colors**'
  prefs: []
  type: TYPE_NORMAL
- en: Opening or executing a bat file brings up a command window with white text on
    a black background, which is the exact opposite of how humans have been reading
    since the advent of papyrus and ink. Contemplate for a moment the text you’re
    currently reading as if it were white on jet-black paper. It seems anachronistic
    now, but it must have been avant-garde in the early days of Batch.
  prefs: []
  type: TYPE_NORMAL
- en: The color command provides 16 different colors from which to choose for both
    the foreground text and background, for a total of 240 permutations, although
    certain combinations are virtually unreadable and even painful to the eye.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the help menu, color /?, to get the full list of colors denoted by the
    hexadecimal digits 0 to F, but the set of popular colors includes black (0), blue
    (1), red (4), and white (7). The color command accepts a two-character color attribute
    as its argument, where the first character represents the background color and
    the second represents the foreground or text color. By the way, the interpreter
    is smart enough to reject a command that assigns the same color to both.
  prefs: []
  type: TYPE_NORMAL
- en: 'A black background supporting white text is the default Batch color scheme,
    which you can call for explicitly with this command: color 07. Flipping the attribute
    around to 70 creates a white background supporting black text, but black text
    on a bright white (F) background is more appealing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'My preference for readability is bright white on a blue background, color 1F,
    but aesthetics aside, the greatest use of this command is to flag problems. You
    may run certain bat files daily to perform mundane or repetitive tasks. You may
    run such a bat file upon logon each morning and then ignore it, but on the rare
    instance when a file can’t be copied or a process aborts, the color command offers
    a great means of throwing up a red flag (literally) to alert the user. If using
    the default color settings, after writing an error message to the console, this
    line immediately changes the screen from black to red (4), brightens the white
    text a tad (F), and holds the window open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That should get the user’s attention even if they’ve moved on to other tasks
    and the command window is off to the side. If it doesn’t, you can also use the
    cls command to clear the screen before writing an error message. To heighten the
    contrast, you can make the background green with color 2F, when the process completes
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The cls and color commands are nonfunctional if stdout has been redirected to
    either a trace file or the nul file. If you need to clear the screen only once,
    execute the cls command just before redirecting stdout to the trace; otherwise,
    echo off is the only realistic option for keeping stdout off the console. Likewise,
    you can execute the color command prior to or after the redirection. Do it early,
    and the color will be set for the duration of the redirection. You also can turn
    the screen red for an abort at the end of the execution after returning from the
    redirection. The title command is the favorite child of the bunch, as it works
    anywhere in a bat file, regardless of redirection.
  prefs: []
  type: TYPE_NORMAL
- en: Fully Functional Batch UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s put all of this together into a fully functional bat file that can interactively
    share a joke, a pun, or a riddle, repeatedly. The next two code snippets contain
    the entire bat file. Here’s the first portion of *BatchImprov.bat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After the setlocal command ❶ (my ubiquitous opening command), the echo off command
    suppresses stdout so that only my coder-generated output gets to the console.
    Notice that neither command is written to the console thanks to the leading at
    sign (@). The color command then sets the background to blue and the text to bright
    white, for no other reason than readability. Next, the title command defines the
    title of the command window. After the :Again label ❷, the cls command clears
    the screen to complete the setup.
  prefs: []
  type: TYPE_NORMAL
- en: Three echo. commands are strategically placed in the code to display blank lines
    for readability. The same choice command ❸ from earlier asks the user for their
    jocular liking. Since there are three selections from which to choose, an if command
    with an else if construct interrogates errorlevel ❹. Depending on the user’s response,
    different call commands are invoked for a joke, pun, or riddle, based on the values
    of 1, 2, or 3, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A second choice command ❺ then asks the user if they want more of this humor,
    using the implied default choices of Y and N. If the user selects Y, the interpreter
    returns 1 and we go back to the :Again label ❷, where we clear the screen and
    begin again. A selection of N indicates that the user has had enough, and we exit
    the bat file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three routines called in the previous listing are defined here in the final
    portion of *BatchImprov.bat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The :Joke and :Riddle routines are similarly structured. A set /P command asks
    for a response before revealing the punchline and the user’s answer. The :Pun
    routine simply writes out the witty pun with no input from the user.
  prefs: []
  type: TYPE_NORMAL
- en: This bat file doesn’t capture stdout and stderr, because doing so wouldn’t allow
    for the use of the cls command between each selection. If that were to cause a
    problem during development, you could temporarily comment out the echo off command,
    but be prepared for a messy console impeding your testing.
  prefs: []
  type: TYPE_NORMAL
- en: Each choice and set /P command in *BatchImprov.bat* is a little different from
    the ones shown earlier in this chapter. Along with the echo commands, each one
    is using redirection to explicitly write its prompt or message to the console
    via the > con syntax. This addition would have been required if stdout had been
    redirected to a trace file; otherwise, it would have written unanswerable prompt
    strings to the trace. But since stdout is simply being suppressed, the redirection
    to the console is redundant in this case. I didn’t include the redirection earlier
    in the chapter because I wanted to focus on the new commands alone, but in practice
    it’s best to always define the destination explicitly as I’ve done here, even
    if it isn’t required.
  prefs: []
  type: TYPE_NORMAL
- en: The *BatchImprov.bat* bat file is now fully functional. Run it and you can answer
    questions and see the results until you answer N to the Do you want to try again?
    prompt. Undoubtedly, you’ll soon get bored due to the limited content, but we
    still have many enhancements to discuss. In Appendix A, you’ll find a far more
    dynamic version of this bat file capable of reading files containing libraries
    of jokes, puns, and riddles; storing them in arrays; and randomly accessing the
    arrays to get unique material multiple times during a single execution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I created the most substantial bat file yet, and I did it to
    demonstrate how to communicate interactively with users. You learned how to provide
    users with a list from which to choose a selection and how to store a typed freeform
    user response of any length into a variable. I also introduced useful commands
    for clearing the screen, updating the title, and changing background and text
    colors, including other noninteractive uses for these commands.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the last of [Part I](part1.xhtml), I’ll discuss code blocks,
    which is an integral topic as you move forward. A code block isn’t simply a “block
    of code.” I’ll explain what it is, why it’s important, and how it’s useful in
    the next few pages.
  prefs: []
  type: TYPE_NORMAL
