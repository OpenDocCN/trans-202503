- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**80X86 ASSEMBLY FOR THE HLL PROGRAMMER**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**80X86 为HLL程序员提供的汇编语言**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Throughout this book, you’ll examine high-level language code and compare it
    to the machine code that a compiler generates for it. Making sense of a compiler’s
    output requires some knowledge of assembly language, but fortunately, you don’t
    need to be an expert assembly programmer for this. As discussed in previous chapters,
    all you really need is the ability to read code generated by compilers and other
    assembly language programmers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将研究高级语言代码，并将其与编译器为其生成的机器码进行对比。理解编译器的输出需要一定的汇编语言知识，但幸运的是，你不需要成为专家级汇编程序员。正如前几章所讨论的，你真正需要的只是能够阅读编译器和其他汇编程序员生成的代码。
- en: 'This chapter provides a primer specifically on the 80x86 assembly language,
    covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了专门讲解80x86汇编语言的入门知识，涵盖以下主题：
- en: The basic 80x86 machine architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的80x86机器架构
- en: How to read the 80x86 output produced by various compilers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取由各种编译器生成的80x86输出
- en: The addressing modes that the 32-bit and 64-bit 80x86 CPUs support
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32位和64位80x86 CPU支持的寻址模式
- en: The syntax that several common 80x86 assemblers (HLA, MASM, and Gas) use
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种常见80x86汇编器（HLA、MASM和Gas）使用的语法
- en: How to use constants and declare data in assembly language programs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在汇编语言程序中使用常量并声明数据
- en: '**3.1 Learning One Assembly Language Is Good, Learning More Is Better**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.1 学习一种汇编语言很好，学习更多更好**'
- en: 'If you intend to write code for a processor other than the 80x86, you should
    really learn how to read at least two different assembly languages. By doing so,
    you’ll avoid the pitfall of coding for the 80x86 in an HLL and then finding that
    your “optimizations” work only on the 80x86 CPU. For this reason, this book includes
    several online appendixes that provide additional resources:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算为除80x86之外的其他处理器编写代码，你应该至少学习两种不同的汇编语言。通过这样做，你可以避免在高级语言中为80x86编写代码，然后发现你的“优化”只能在80x86
    CPU上工作。出于这个原因，本书包含了几个在线附录，提供了额外的资源：
- en: Appendix A covers the minimal x86 instruction set.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录A介绍了最小的x86指令集。
- en: Appendix B is a primer on the PowerPC CPU.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录B是PowerPC CPU的入门知识。
- en: Appendix C examines the ARM processor.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录C讲解了ARM处理器。
- en: Appendix D describes the Java bytecode assembly language.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录D描述了Java字节码汇编语言。
- en: Appendix E covers the Microsoft Intermediate Language.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附录E介绍了Microsoft中间语言。
- en: You’ll see that all five architectures rely on many of the same concepts, but
    there are some important differences among them, and advantages and disadvantages
    to each.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到所有五种架构都依赖于许多相同的概念，但它们之间存在一些重要的差异，每种架构也有其优点和缺点。
- en: Perhaps the main difference between *complex instruction set computer (CISC)*
    and *reduced instruction set computer (RISC)* architectures is the way they use
    memory. RISC architectures limit memory access to certain instructions, so applications
    go to great lengths to avoid accessing memory. The 80x86 architecture, on the
    other hand, allows most instructions to access memory, and applications generally
    take advantage of this facility.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 也许*复杂指令集计算机（CISC）*和*精简指令集计算机（RISC）*架构之间的主要区别是它们使用内存的方式。RISC架构将内存访问限制为特定的指令，因此应用程序会尽力避免访问内存。另一方面，80x86架构允许大多数指令访问内存，应用程序通常会利用这一功能。
- en: The Java bytecode (JBC) and Microsoft Intermediate Language (IL) architectures
    differ from the 80x86, PowerPC, and ARM families in that JBC and IL are *virtual
    machines*, not actual CPUs. Generally, software interprets or attempts to compile
    JBC at runtime (IL code is always compiled at runtime).^([1](footnotes.xhtml#ch3fn1))
    This means JBC and IL code tends to run much slower than true machine code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Java字节码（JBC）和Microsoft中间语言（IL）架构与80x86、PowerPC和ARM架构不同，JBC和IL是*虚拟机*，而不是实际的CPU。通常，软件在运行时解释或尝试编译JBC（IL代码始终在运行时编译）。^([1](footnotes.xhtml#ch3fn1))
    这意味着JBC和IL代码通常比真正的机器码运行得要慢。
- en: '**3.2 80x86 Assembly Syntaxes**'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.2 80x86汇编语法**'
- en: 'While 80x86 programmers can choose from a wide variety of program development
    tools, this abundance has a minor drawback: syntactical incompatibility. Different
    compilers and debuggers for the 80x86 family output different assembly language
    listings for the exact same program. This is because those tools emit code for
    different assemblers. For example, Microsoft’s Visual C++ package generates assembly
    code compatible with Microsoft Macro Assembler (MASM). The GNU Compiler Suite
    (GCC) generates Gas-compatible source code (Gas is the GNU Assembler from the
    Free Software Foundation). In addition to the code that compilers emit, you’ll
    find tons of assembly programming examples written with assemblers like FASM,
    NASM, GoAsm, and HLA (High-Level Assembly).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 80x86 程序员可以选择多种程序开发工具，但这种丰富性也有一个小小的缺点：语法不兼容性。不同的 80x86 编译器和调试器对于完全相同的程序输出不同的汇编语言列表。这是因为这些工具为不同的汇编器生成代码。例如，微软的
    Visual C++ 套件生成与微软宏汇编器 (MASM) 兼容的汇编代码。GNU 编译器套件（GCC）生成与 Gas 兼容的源代码（Gas 是来自自由软件基金会的
    GNU 汇编器）。除了编译器生成的代码外，你还会看到大量使用像 FASM、NASM、GoAsm 和 HLA（高级汇编）等汇编器编写的汇编编程示例。
- en: It would be nice to use just a single assembler syntax throughout this book,
    but because our approach is not compiler specific, we must consider the syntaxes
    for several different common assemblers. This book will generally present non-compiler-specific
    examples using HLA. Therefore, this chapter will discuss the syntaxes for HLA
    as well as two other common assemblers, MASM and Gas. Fortunately, once you master
    the syntax for one assembler, learning the syntax of other assemblers is very
    easy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中最好使用单一的汇编语言语法，但由于我们的方法并不特定于某一编译器，因此必须考虑几种不同常见汇编器的语法。本书通常会使用 HLA 提供与编译器无关的示例。因此，本章将讨论
    HLA 语法以及其他两种常见汇编器的语法：MASM 和 Gas。幸运的是，一旦你掌握了某一汇编器的语法，学习其他汇编器的语法就非常容易。
- en: '**3.2.1 Basic 80x86 Architecture**'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.2.1 基本的 80x86 架构**'
- en: 'The Intel CPU is generally classified as a *Von Neumann machine*. Von Neumann
    computer systems contain three main building blocks: the *central processing unit
    (CPU)*, *memory*, and *input/output (I/O) devices*. These three components are
    connected via the *system bus* (consisting of the address, data, and control buses).
    [Figure 3-1](ch03.xhtml#ch3fig1) shows this relationship.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔 CPU 通常被归类为 *冯·诺依曼机*。冯·诺依曼计算机系统包含三个主要构建模块：*中央处理单元 (CPU)*、*内存* 和 *输入/输出 (I/O)
    设备*。这三部分通过 *系统总线* 连接（系统总线由地址总线、数据总线和控制总线组成）。[图 3-1](ch03.xhtml#ch3fig1) 显示了这种关系。
- en: '![Image](../images/03fig01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig01.jpg)'
- en: '*Figure 3-1: Block diagram of a Von Neumann system*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：冯·诺依曼系统的框图*'
- en: The CPU communicates with memory and I/O devices by placing a numeric value
    on the *address bus* to select one of the memory locations or I/O device port
    locations, each of which has a unique binary numeric address. Then the CPU, I/O,
    and memory devices pass data among themselves by placing the data on the *data
    bus*. The *control bus* contains signals that determine the direction of the data
    transfer (to or from memory, and to or from an I/O device).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 通过在 *地址总线* 上放置一个数字值来与内存和 I/O 设备进行通信，以选择其中一个内存位置或 I/O 设备端口位置，每个位置都有一个唯一的二进制数字地址。然后，CPU、I/O
    设备和内存设备通过将数据放置在 *数据总线* 上相互传递数据。*控制总线* 包含信号，决定数据传输的方向（是向内存传输还是从内存传输，或是向 I/O 设备传输还是从
    I/O 设备传输）。
- en: '**3.2.2 Registers**'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.2.2 寄存器**'
- en: The register set is the most prominent feature within the CPU. Almost all calculations
    on the 80x86 CPU involve at least one register. For example, to add the value
    of two variables and store their sum in a third variable, you must load one of
    the variables into a register, add the second operand to the register, and then
    store the register’s value in the destination variable. Registers are middlemen
    in almost every calculation and thus are very important in 80x86 assembly language
    programs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器组是 CPU 内最显著的特征。几乎所有在 80x86 CPU 上的运算都涉及至少一个寄存器。例如，要将两个变量的值相加并将它们的和存储到第三个变量中，必须先将其中一个变量加载到寄存器中，再将第二个操作数加到该寄存器中，最后将寄存器的值存储到目标变量中。寄存器几乎是每次计算中的中介，因此在
    80x86 汇编语言程序中非常重要。
- en: 'The 80x86 CPU registers can be broken down into four categories: general-purpose
    registers, special-purpose application-accessible registers, segment registers,
    and special-purpose kernel-mode registers. We won’t consider the last two categories,
    because the segment registers are not used very much in modern operating systems
    (for example, Windows, BSD, macOS, and Linux), and the special-purpose kernel-mode
    registers are intended for writing operating systems, debuggers, and other system-level
    tools—a topic well beyond the scope of this book.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU寄存器可以分为四类：通用寄存器、特殊用途的应用程序可访问寄存器、段寄存器和特殊用途的内核模式寄存器。我们不会考虑最后两类，因为在现代操作系统中段寄存器的使用并不广泛（例如，Windows、BSD、macOS和Linux），而特殊用途的内核模式寄存器是为编写操作系统、调试器以及其他系统级工具而设计的——这超出了本书的讨论范围。
- en: '**3.2.3 80x86 32-Bit General-Purpose Registers**'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.2.3 80x86 32位通用寄存器**'
- en: 'The 32-bit 80x86 (Intel family) CPUs provide several general-purpose registers
    for application use. These include eight 32-bit registers: EAX, EBX, ECX, EDX,
    ESI, EDI, EBP, and ESP.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 32位80x86（Intel家族）CPU提供了多个供应用程序使用的通用寄存器。这些包括八个32位寄存器：EAX、EBX、ECX、EDX、ESI、EDI、EBP和ESP。
- en: 'The *E* prefix on each name stands for *extended*. This prefix differentiates
    the 32-bit registers from the original eight 16-bit registers: AX, BX, CX, DX,
    SI, DI, BP, and SP.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个寄存器名称前的*E*前缀代表*扩展*。这个前缀区分了32位寄存器和原始的八个16位寄存器：AX、BX、CX、DX、SI、DI、BP和SP。
- en: 'Finally, the 80x86 CPUs provide eight 8-bit registers: AL, AH, BL, BH, CL,
    CH, DL, and DH.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，80x86 CPU提供了八个8位寄存器：AL、AH、BL、BH、CL、CH、DL和DH。
- en: The most important thing to note about the general-purpose registers is that
    they are not independent. That is, the 80x86 architecture does not provide 24
    separate registers. Instead, it overlaps the 32-bit registers with the 16-bit
    registers, and it overlaps the 16-bit registers with the 8-bit registers. [Figure
    3-2](ch03.xhtml#ch3fig2) shows this relationship.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于通用寄存器，最重要的要点是它们不是独立的。也就是说，80x86架构并没有提供24个独立的寄存器。相反，它将32位寄存器与16位寄存器重叠，并且将16位寄存器与8位寄存器重叠。[图3-2](ch03.xhtml#ch3fig2)展示了这种关系。
- en: '![Image](../images/03fig02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig02.jpg)'
- en: '*Figure 3-2: Intel 80x86 CPU general-purpose registers*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：Intel 80x86 CPU通用寄存器*'
- en: The fact that modifying one register may modify as many as three other registers
    cannot be overemphasized. For example, modifying the EAX register may also modify
    the AL, AH, and AX registers. You will often see compiler-generated code using
    this feature of the 80x86\. For example, a compiler may clear (set to `0`) all
    the bits in the EAX register and then load AL with a `1` or `0` in order to produce
    a 32-bit `true` (`1`) or `false` (`0`) value. Some machine instructions manipulate
    only the AL register, yet the program may need to return those instructions’ results
    in EAX. By taking advantage of the register overlap, the compiler-generated code
    can use an instruction that manipulates AL to return that value in all of EAX.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 修改一个寄存器可能会同时修改多达三个其他寄存器这一点非常重要。例如，修改EAX寄存器可能也会修改AL、AH和AX寄存器。你将经常看到编译器生成的代码利用这一点。例如，编译器可能会清除（设置为`0`）EAX寄存器中的所有位，然后将`1`或`0`加载到AL中，以产生一个32位的`true`（`1`）或`false`（`0`）值。某些机器指令仅操作AL寄存器，但程序可能需要将这些指令的结果返回到EAX中。通过利用寄存器的重叠，编译器生成的代码可以使用操作AL的指令，并将该值返回到整个EAX寄存器中。
- en: Although Intel calls these registers *general purpose*, that’s not to suggest
    that you can use any register for any purpose. The SP/ESP register pair, for example,
    has a very special purpose that effectively prevents you from using it for any
    other reason (it’s the *stack pointer*). Likewise, the BP/EBP register has a special
    purpose that limits its usefulness as a general-purpose register. All the 80x86
    registers have their own special purposes that limit their use in certain contexts;
    we’ll consider these special uses as we discuss the machine instructions that
    use them (see the online resources).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Intel将这些寄存器称为*通用寄存器*，但这并不意味着你可以将任何寄存器用于任何目的。例如，SP/ESP寄存器对具有非常特殊的功能，实际上阻止你将它用于其他任何目的（它是*堆栈指针*）。同样，BP/EBP寄存器也有一个特殊用途，限制了它作为通用寄存器的有效性。所有80x86寄存器都有各自的特殊用途，这限制了它们在某些上下文中的使用；我们将在讨论使用这些寄存器的机器指令时考虑这些特殊用途（见在线资源）。
- en: 'Contemporary versions of the 80x86 CPU (typically known as the *x86-64 CPU*)
    provide two important extensions to the 32-bit register set: a set of 64-bit registers
    and a second set of eight registers (64-bit, 32-bit, 16-bit, and 8-bit). The main
    64-bit registers have the following names: RAX, RBX, RCX, RDX, RSI, RDI, RBP,
    and RSP.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当代版本的 80x86 CPU（通常称为 *x86-64 CPU*）为 32 位寄存器集提供了两个重要扩展：一组 64 位寄存器和另一组八个寄存器（64
    位、32 位、16 位和 8 位）。主要的 64 位寄存器具有以下名称：RAX、RBX、RCX、RDX、RSI、RDI、RBP 和 RSP。
- en: These 64-bit registers overlap the 32-bit “E” registers. That is, the 32-bit
    registers comprise the LO (low-order) 32 bits of each of these registers. For
    example, EAX is the LO 32 bits of RAX. Similarly, AX is the LO 16 bits of RAX,
    and AL is the LO 8 bits of RAX.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 64 位寄存器与 32 位的“E”寄存器重叠。也就是说，32 位寄存器包含了这些寄存器的低（低序）32 位。例如，EAX 是 RAX 的低 32
    位。同样，AX 是 RAX 的低 16 位，AL 是 RAX 的低 8 位。
- en: 'In addition to providing 64-bit variants of the existing 80x86 32-bit registers,
    the x86-64 CPUs also add eight other 64/32/16/8-bit registers: R15, R14, R13,
    R12, R11, R10, R9, and R8.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供现有 80x86 32 位寄存器的 64 位变体外，x86-64 CPU 还增加了八个其他的 64/32/16/8 位寄存器：R15、R14、R13、R12、R11、R10、R9
    和 R8。
- en: You can refer to the LO 32 bits of each of these registers as R15d, R14d, R13d,
    R12d, R11d, R10d, R9d, and R8d.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些寄存器的低 32 位称为 R15d、R14d、R13d、R12d、R11d、R10d、R9d 和 R8d。
- en: You can refer to the LO 16 bits of each of these registers as R15w, R14w, R13w,
    R12w, R11w, R10w, R9w, and R8w.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些寄存器的低 16 位称为 R15w、R14w、R13w、R12w、R11w、R10w、R9w 和 R8w。
- en: Finally, you can refer to the LO byte of each of these registers as R15b, R14b,
    R13b, R12b, R11b, R10b, R9b, and R8b.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以将这些寄存器的低字节称为 R15b、R14b、R13b、R12b、R11b、R10b、R9b 和 R8b。
- en: '**3.2.4 The 80x86 EFLAGS Register**'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.2.4 80x86 EFLAGS 寄存器**'
- en: 'The 32-bit EFLAGS register encapsulates numerous single-bit Boolean (`true`/`false`)
    values (or *flags*). Most of these bits are either reserved for kernel-mode (operating
    system) functions or of little interest to application programmers. There are,
    however, 8 bits relevant to application programmers reading (or writing) assembly
    language code: the overflow, direction, interrupt disable,^([2](footnotes.xhtml#ch3fn2))
    sign, zero, auxiliary carry, parity, and carry flags. [Figure 3-3](ch03.xhtml#ch3fig3)
    shows their layout within the EFLAGS register.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位 EFLAGS 寄存器封装了许多单个位的布尔值（`true`/`false`）（或 *标志*）。其中大多数位要么是为内核模式（操作系统）功能保留，要么对于应用程序开发者而言没有太大意义。然而，有
    8 位对于编写（或读取）汇编语言代码的应用程序开发者是相关的：溢出标志、方向标志、禁止中断标志、符号标志、零标志、辅助进位标志、奇偶标志和进位标志。[图 3-3](ch03.xhtml#ch3fig3)
    显示了它们在 EFLAGS 寄存器中的布局。
- en: 'Of the eight flags that application programmers can use, four flags in particular
    are extremely valuable: the overflow, carry, sign, and zero flags. We call these
    four flags the *condition codes*. Each flag has a state—set or cleared—that you
    can use to test the result of previous computations. For example, after comparing
    two values, the condition-code flags will tell you if one value is less than,
    equal to, or greater than the other.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发者可以使用的八个标志中，尤其有四个标志非常有价值：溢出标志、进位标志、符号标志和零标志。我们将这四个标志称为 *条件码*。每个标志都有一个状态——设置或清除——你可以利用它来测试之前计算的结果。例如，在比较两个值之后，条件码标志会告诉你哪个值小于、等于或大于另一个值。
- en: '![Image](../images/03fig03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig03.jpg)'
- en: '*Figure 3-3: Layout of the 80x86 flags register (LO 16 bits)*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：80x86 标志寄存器的布局（低 16 位）*'
- en: The x86-64 64-bit RFLAGS register reserves all bits from bit 32 through bit
    63\. The upper 16 bits of the EFLAGS register are generally useful only to operating
    systems code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 64 位 RFLAGS 寄存器保留了从位 32 到位 63 的所有位。EFLAGS 寄存器的上 16 位通常只对操作系统代码有用。
- en: Because the RFLAGS register doesn’t contain anything of interest when reading
    compiler output, this book will simply refer to the x86 and x86-64 flags register
    as EFLAGs, even on 64-bit variants of the CPU.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 RFLAGS 寄存器在读取编译器输出时不包含任何有用信息，本书将简单地将 x86 和 x86-64 标志寄存器称为 EFLAGS，即使在 64 位
    CPU 变体上也是如此。
- en: '**3.3 Literal Constants**'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.3 字面常量**'
- en: Most assemblers support literal numeric (binary, decimal, and hexadecimal),
    character, and string constants. Unfortunately, just about every assembler out
    there uses a different syntax for literal constants. This section describes the
    syntax for the assemblers we’ll be using in this book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数汇编器支持字面数值（包括二进制、十进制和十六进制）、字符和字符串常量。不幸的是，几乎所有的汇编器都使用不同的字面常量语法。本节将描述本书中使用的汇编器的语法。
- en: '**3.3.1 Binary Literal Constants**'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.3.1 二进制字面常量**'
- en: All assemblers provide the ability to specify base-2 (binary) literal constants.
    Few compilers emit binary constants, so you probably won’t see these values in
    the output a compiler produces, but you may see them in handwritten assembly code.
    C++ 14 supports binary literals (`0b`xxxxx) as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有汇编器都提供了指定基数2（二进制）字面常量的能力。很少有编译器生成二进制常量，因此你可能不会在编译器输出中看到这些值，但在手写的汇编代码中你可能会看到它们。C++
    14 也支持二进制字面常量（`0b`xxxxx）。
- en: '**3.3.1.1 Binary Literal Constants in HLA**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.1.1 HLA 中的二进制字面常量**'
- en: 'Binary literal constants in HLA begin with the percent character (`%`) followed
    by one or more binary digits (`0` or `1`). Underscore characters may appear between
    any two digits in a binary number. By convention, HLA programmers separate each
    group of four digits with an underscore. For example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 中的二进制字面常量以百分号字符（`%`）开头，后跟一个或多个二进制数字（`0` 或 `1`）。下划线字符可以出现在二进制数字的任何两个数字之间。根据惯例，HLA
    程序员使用下划线分隔每四个数字一组。例如：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**3.3.1.2 Binary Literal Constants in Gas**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.1.2 Gas 中的二进制字面常量**'
- en: 'Binary literal constants in Gas begin with the special `0b` prefix followed
    by one or more binary digits (`0` or `1`). For example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 中的二进制字面常量以特殊的 `0b` 前缀开头，后跟一个或多个二进制数字（`0` 或 `1`）。例如：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**3.3.1.3 Binary Literal Constants in MASM**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.1.3 MASM 中的二进制字面常量**'
- en: 'Binary literal constants in MASM consist of one or more binary digits (`0`
    or `1`) followed by the special `b` suffix. For example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 中的二进制字面常量由一个或多个二进制数字（`0` 或 `1`）组成，并以特殊的 `b` 后缀结尾。例如：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**3.3.2 Decimal Literal Constants**'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.3.2 十进制字面常量**'
- en: Decimal constants in most assemblers take the standard form—a sequence of one
    or more decimal digits without any special prefix or suffix. This is one of the
    two common numeric formats that compilers emit, so you’ll often see decimal literal
    constants in compiler output code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数汇编器中的十进制常量采用标准格式——一系列一个或多个十进制数字，没有任何特殊的前缀或后缀。这是编译器生成的两种常见数字格式之一，因此你经常会在编译器输出的代码中看到十进制字面常量。
- en: '**3.3.2.1 Decimal Literal Constants in HLA**'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.2.1 HLA 中的十进制字面常量**'
- en: 'HLA allows you to optionally insert underscores between any two digits in a
    decimal number. HLA programmers generally use underscores to separate groups of
    three digits in a decimal number. For example, for the following numbers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 允许你在十进制数字的任何两个数字之间插入下划线。HLA 程序员通常使用下划线来分隔十进制数字中的每组三个数字。例如，对于以下数字：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'an HLA programmer could insert underscores as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 程序员可以按如下方式插入下划线：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**3.3.2.2 Decimal Literal Constants in Gas and MASM**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.2.2 Gas 和 MASM 中的十进制字面常量**'
- en: 'Gas and MASM use a string of decimal digits (the standard “computer” format
    for decimal values). For example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 和 MASM 使用一串十进制数字（标准的“计算机”格式用于表示十进制值）。例如：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unlike HLA, Gas and MASM do not allow embedded underscores in decimal literal
    constants.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HLA 不同，Gas 和 MASM 不允许在十进制字面常量中嵌入下划线。
- en: '**3.3.3 Hexadecimal Literal Constants**'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.3.3 十六进制字面常量**'
- en: Hexadecimal (base-16) literal constants are the other common numeric format
    you’ll find in assembly language programs (especially those that compilers emit).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '十六进制（基数16）字面常量是汇编语言程序中另一种常见的数字格式（尤其是编译器生成的程序）。 '
- en: '**3.3.3.1 Hexadecimal Literal Constants in HLA**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.3.1 HLA 中的十六进制字面常量**'
- en: 'Hexadecimal literal constants in HLA consist of a string of hexadecimal digits
    (`0..9`, `a..f`, or `A..F`) with a `$` prefix. Underscores may optionally appear
    between any two hexadecimal digits in the number. By convention, HLA programmers
    separate sequences of four digits with underscores. For example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 中的十六进制字面常量由一串十六进制数字（`0..9`，`a..f` 或 `A..F`）组成，并以 `$` 为前缀。下划线可以选择性地出现在数字的任何两个十六进制数字之间。根据惯例，HLA
    程序员使用下划线分隔每四个数字一组。例如：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**3.3.3.2 Hexadecimal Literal Constants in Gas**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.3.2 Gas 中的十六进制字面常量**'
- en: 'Hexadecimal literal constants in Gas consist of a string of hexadecimal digits
    (`0..9`, `a..f`, or `A..F`) with a `0x` prefix. For example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 中的十六进制字面常量由一串十六进制数字（`0..9`，`a..f` 或 `A..F`）组成，并以 `0x` 为前缀。例如：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**3.3.3.3 Hexadecimal Literal Constants in MASM**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.3.3 MASM 中的十六进制字面常量**'
- en: 'Hexadecimal literal constants in MASM consist of a string of hexadecimal digits
    (`0..9`, `a..f`, or `A..F`) with an `h` suffix. The values must begin with a decimal
    digit (`0` if the constant would normally begin with a digit in the range `a..f`).
    For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 中的十六进制字面常量由一串十六进制数字（`0..9`，`a..f` 或 `A..F`）组成，并以 `h` 为后缀。值必须以十进制数字开始（如果常量通常以
    `a..f` 范围内的字母开头，则以 `0` 开头）。例如：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**3.3.4 Character and String Literal Constants**'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.3.4 字符和字符串字面常量**'
- en: Character and string data are also common data types that you’ll find in assembly
    programs. MASM does not differentiate between character or string literal constants.
    HLA and Gas, however, use a different internal representation for characters and
    strings, so the distinction between the two kinds of literal constants is very
    important in those assemblers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 字符和字符串数据也是汇编程序中常见的数据类型。MASM 不区分字符字面常量和字符串字面常量。然而，HLA 和 Gas 使用不同的内部表示来处理字符和字符串，因此在这些汇编器中，区分这两种字面常量非常重要。
- en: '**3.3.4.1 Character and String Literal Constants in HLA**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.1 HLA 中的字符和字符串字面常量**'
- en: 'Character literal constants in HLA take a few different forms. The most common
    is a single printable character surrounded by a pair of apostrophes, such as `''A''`.
    To specify an actual apostrophe as a character literal constant, HLA requires
    that you surround one pair of apostrophes by another (`''''''''`). Finally, you
    can also indicate a character constant using the `#` symbol followed by a binary,
    decimal, or hexadecimal numeric value that specifies the ASCII code of the character
    you want to use. For example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 中的字符字面常量有几种不同的形式。最常见的是一个单一的可打印字符，周围有一对撇号，如 `'A'`。为了指定实际的撇号作为字符字面常量，HLA 要求你用一对撇号包围另一对撇号（`''''`）。最后，你也可以使用
    `#` 符号后跟一个二进制、十进制或十六进制的数值，来指定你要使用的字符的 ASCII 码。例如：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'String literal constants in HLA consist of a sequence of zero or more characters
    surrounded by quotation marks. To indicate an actual quotation mark character
    within a string constant, you use two adjacent quotation marks. For example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 中的字符串字面常量由零个或多个字符组成，字符由引号包围。为了在字符串常量中表示实际的引号字符，你需要使用两个相邻的引号。例如：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**3.3.4.2 Character and String Literal Constants in Gas**'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.2 Gas 中的字符和字符串字面常量**'
- en: 'Character literal constants in Gas consist of an apostrophe followed by a single
    character. More modern versions of Gas (and Gas on the Mac) also allow character
    constants of the form `''a''`. For example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 中的字符字面常量由一个撇号后跟一个字符组成。更新版本的 Gas（以及 Mac 上的 Gas）也允许类似 `'a'` 的字符常量。例如：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'String literal constants in Gas consist of a sequence of zero or more characters
    surrounded by quotes, and use the same syntax as C strings. You use the `\` escape
    sequence to embed special characters in a Gas string. For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 中的字符串字面常量由零个或多个字符组成，字符由引号包围，并且使用与 C 字符串相同的语法。你可以使用 `\` 转义序列在 Gas 字符串中嵌入特殊字符。例如：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**3.3.4.3 Character and String Literal Constants in MASM**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.3.4.3 MASM 中的字符和字符串字面常量**'
- en: 'Character and string literal constants in MASM take the same form: a sequence
    of one or more characters surrounded by either apostrophes or quotes. MASM does
    not differentiate character constants and string constants. For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 中的字符和字符串字面常量采用相同的形式：一个或多个字符组成的序列，由撇号或引号包围。MASM 不区分字符常量和字符串常量。例如：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**3.3.5 Floating-Point Literal Constants**'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.3.5 浮点字面常量**'
- en: 'Floating-point literal constants in assembly language typically take the same
    form you’ll find in HLLs (a sequence of digits, possibly containing a decimal
    point, optionally followed by a signed exponent). For example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言中的浮点字面常量通常采用你在高级语言（HLL）中会看到的形式（一个数字序列，可能包含小数点，可选地跟着一个带符号的指数）。例如：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**3.4 Manifest (Symbolic) Constants in Assembly Language**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.4 汇编语言中的显式（符号）常量**'
- en: Almost every assembler provides a mechanism for declaring symbolic (named) constants.
    In fact, most assemblers provide several ways to associate a value with an identifier
    in the source file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个汇编器都提供了一种声明符号（命名）常量的机制。事实上，大多数汇编器提供了几种方式，将一个值与源文件中的标识符关联起来。
- en: '**3.4.1 Manifest Constants in HLA**'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.4.1 HLA 中的显式常量**'
- en: 'The HLA assembler, true to its name, uses a high-level syntax for declaring
    named constants in the source file. You may define constants in one of three ways:
    in a `const` section, in a `val` section, or with the `?` compile-time operator.
    The `const` and `val` sections appear in the declaration section of an HLA program,
    and their syntax is very similar. The difference between them is that you may
    reassign values to identifiers you define in the `val` section, but you may not
    reassign values to identifiers appearing in a `const` section. Although HLA supports
    a wide range of options in these declaration sections, the basic declaration takes
    the following form:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: HLA汇编器，名副其实，采用高级语法在源文件中声明命名常量。你可以通过三种方式定义常量：在`const`部分、在`val`部分，或使用`?`编译时运算符。`const`和`val`部分出现在HLA程序的声明部分，它们的语法非常相似。它们之间的区别在于，你可以重新赋值给`val`部分中定义的标识符，但不能重新赋值给`const`部分中的标识符。尽管HLA在这些声明部分中支持多种选项，但基本声明的形式如下：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Wherever someIdentifier appears in the source file (after this declaration),
    HLA will substitute the value someValue in the identifier’s place. For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在源文件中，任何出现某个标识符的地方（在此声明之后），HLA将用该标识符所对应的值`someValue`进行替换。例如：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In HLA, the `?` statement allows you to embed `val` declarations anywhere whitespace
    is allowed in the source file. This is sometimes useful because it isn’t always
    convenient to declare constants in a declaration section. For example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在HLA中，`?`语句允许你在源文件中任何允许空格的地方嵌入`val`声明。这有时很有用，因为在声明部分声明常量并不总是方便。例如：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**3.4.2 Manifest Constants in Gas**'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.4.2 Gas中的清单常量**'
- en: 'Gas uses the `.equ` (“equate”) statement to define a symbolic constant in the
    source file. This statement has the following syntax:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Gas使用`.equ`（“等式”）语句在源文件中定义符号常量。该语句的语法如下：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here are some examples of equates within a Gas source file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些Gas源文件中等式的示例：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**3.4.3 Manifest Constants in MASM**'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.4.3 MASM中的清单常量**'
- en: 'MASM also provides a couple of different ways to define manifest constants
    within a source file. One way is with the `equ` directive:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MASM也提供了几种不同的方式来在源文件中定义清单常量。一种方式是使用`equ`指令：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another is with the `=` operator:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是使用`=`运算符：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The difference between the two is minor; see the MASM documentation for details.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的区别很小；有关详细信息，请参阅MASM文档。
- en: '**NOTE**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For the most part, compilers tend to emit the equ form rather than the = form.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*在大多数情况下，编译器倾向于生成equ形式而非=形式。*'
- en: '**3.5 80x86 Addressing Modes**'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.5 80x86寻址模式**'
- en: 'An *addressing mode* is a hardware-specific mechanism for accessing instruction
    operands. The 80x86 family provides three different classes of operands: register,
    immediate, and memory operands. This section discusses each of these addressing
    modes.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*寻址模式*是访问指令操作数的硬件特定机制。80x86系列提供三种不同类型的操作数：寄存器、立即数和内存操作数。本节讨论了每种寻址模式。'
- en: '**3.5.1 80x86 Register Addressing Modes**'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.5.1 80x86寄存器寻址模式**'
- en: Most 80x86 instructions can operate on the 80x86’s general-purpose register
    set. You access a register by specifying its name as an instruction operand.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数80x86指令可以操作80x86的通用寄存器集。你通过指定寄存器的名称作为指令操作数来访问寄存器。
- en: Let’s consider some examples of how our assemblers implement this strategy,
    using the 80x86 `mov` (move) instruction.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些示例，看看我们的汇编器如何使用80x86的`mov`（移动）指令来实现这一策略。
- en: '**3.5.1.1 Register Access in HLA**'
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.1.1 HLA中的寄存器访问**'
- en: 'The HLA `mov` instruction looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: HLA的`mov`指令如下所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This instruction copies the data from the source operand to the destination
    operand. The 8-bit, 16-bit, and 32-bit registers are valid operands for this instruction;
    the only restriction is that both operands must be the same size.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令将数据从源操作数复制到目标操作数。8位、16位和32位寄存器是该指令的有效操作数；唯一的限制是两个操作数必须是相同的大小。
- en: 'Now let’s look at some actual 80x86 `mov` instructions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一些实际的80x86 `mov`指令：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that HLA supports only the 32-bit 80x86 register set, not the 64-bit register
    set.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，HLA仅支持32位的80x86寄存器集，不支持64位寄存器集。
- en: '**3.5.1.2 Register Access in Gas**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.1.2 Gas中的寄存器访问**'
- en: 'Gas prepends each register name with percent sign (`%`). For example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Gas在每个寄存器名称前加上百分号（`%`）。例如：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Gas syntax for the `mov` instruction is similar to HLA’s, except that it
    drops the parentheses and semicolons and requires the assembly language statements
    to fit completely on one physical line of source code. For example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov` 指令的 Gas 语法与 HLA 类似，不同之处在于它去掉了括号和分号，并要求汇编语言语句必须完全适应于一行源代码。例如：'
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**3.5.1.3 Register Access in MASM**'
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.1.3 在 MASM 中的寄存器访问**'
- en: 'The MASM assembler uses the same register names as HLA but adds support for
    the 64-bit register set:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 汇编器使用与 HLA 相同的寄存器名称，但增加了对 64 位寄存器组的支持：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'MASM uses a basic syntax that’s similar to that of Gas, except that MASM reverses
    the operands (which is the standard Intel syntax). That is, a typical instruction
    like `mov` takes this form:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 使用的基础语法与 Gas 类似，不同之处在于 MASM 交换了操作数的顺序（这是标准的 Intel 语法）。即，像 `mov` 这样的典型指令采用以下形式：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here are some examples of the `mov` instruction in MASM syntax:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 MASM 语法中的一些 `mov` 指令示例：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**3.5.2 Immediate Addressing Mode**'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.5.2 立即寻址模式**'
- en: 'Most instructions that allow register and memory operands also allow immediate,
    or *constant*, operands. The following HLA `mov` instructions, for example, load
    appropriate values into the corresponding destination registers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数允许寄存器和内存操作数的指令也允许立即数或 *常量* 操作数。例如，以下 HLA `mov` 指令会将适当的值加载到相应的目标寄存器中：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Most assemblers allow you to specify a wide variety of literal constant types
    when using the immediate addressing mode. For example, you can supply numbers
    in hexadecimal, decimal, or binary form. You can also supply character constants
    as operands. The rule is that the constant must fit in the size specified for
    the destination operand.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数汇编器在使用立即寻址模式时，允许你指定各种字面常量类型。例如，你可以提供十六进制、十进制或二进制形式的数字。你还可以将字符常量作为操作数提供。规则是常量必须符合目标操作数指定的大小。
- en: 'Here are some additional examples with HLA, Gas, and MASM (note that Gas requires
    a `$` before immediate operands):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用 HLA、Gas 和 MASM 的附加示例（请注意，Gas 需要在立即操作数前加上 `$`）：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Almost every assembler lets you create symbolic constant names and supply them
    as source operands. For example, HLA predefines the two Boolean constants `true`
    and `false`, so you can supply those names as `mov` instruction operands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个汇编器都允许你创建符号常量名并将其作为源操作数提供。例如，HLA 预定义了两个布尔常量 `true` 和 `false`，因此你可以将这些名称作为
    `mov` 指令的操作数：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Some assemblers even allow pointer constants and other abstract data type constants.
    (See the reference manual for your assembler for details.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些汇编器甚至允许指针常量和其他抽象数据类型常量。（有关详细信息，请参阅汇编器的参考手册。）
- en: '**3.5.3 Displacement-Only Memory Addressing Mode**'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.5.3 仅位移内存寻址模式**'
- en: The most common 32-bit addressing mode, and the one that’s the easiest to understand,
    is the *displacement-only* (or *direct*) addressing mode, in which a 32-bit constant
    specifies the address of the memory location, which may be either the source or
    the destination operand. Note that this addressing mode is available only on 32-bit
    x86 processors or when operating in 32-bit mode on a 64-bit processor.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的32位寻址模式，也是最容易理解的一种，是 *仅位移*（或 *直接*）寻址模式，在这种模式下，32位常量指定内存位置的地址，这个地址可以是源操作数或目标操作数。请注意，这种寻址模式仅在32位
    x86 处理器或在64位处理器的32位模式下可用。
- en: For example, assuming that variable `J` is a byte variable appearing at address
    `$8088`, the HLA instruction `mov(J,al);` loads the AL register with a copy of
    the byte at memory location `$8088`. Likewise, if the byte variable `K` is at
    address `$1234` in memory, then the instruction `mov(dl,K);` writes the value
    in the DL register to memory location `$1234` (see [Figure 3-4](ch03.xhtml#ch3fig4)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设变量 `J` 是一个位于地址 `$8088` 的字节变量，HLA 指令 `mov(J,al);` 会将内存地址 `$8088` 处的字节加载到
    AL 寄存器中。类似地，如果字节变量 `K` 位于内存地址 `$1234`，那么指令 `mov(dl,K);` 会将 DL 寄存器中的值写入内存地址 `$1234`（参见
    [图 3-4](ch03.xhtml#ch3fig4)）。
- en: '![Image](../images/03fig04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig04.jpg)'
- en: '*Figure 3-4: Displacement-only (direct) addressing mode*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：仅位移（直接）寻址模式*'
- en: The displacement-only addressing mode is perfect for accessing simple scalar
    variables. It is the addressing mode you’d normally use to access static or global
    variables in an HLL program.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 仅位移寻址模式非常适合访问简单的标量变量。这是你通常用来访问HLL程序中的静态或全局变量的寻址模式。
- en: '**NOTE**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Intel named this addressing mode “displacement-only” because a 32-bit constant
    (displacement) follows the mov opcode in memory. On the 80x86 processors, this
    displacement is an offset from the beginning of memory (that is, address `0`).*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*英特尔将此寻址模式命名为“仅位移”，因为一个32位常量（位移）紧跟在mov操作码后面，存储在内存中。在80x86处理器上，这个位移是从内存起始位置（即地址`0`）开始的偏移量。*'
- en: The examples in this chapter will often access byte-sized objects in memory.
    Don’t forget, however, that you can also access words and double words on the
    80x86 processors by specifying the address of their first byte (see [Figure 3-5](ch03.xhtml#ch3fig5)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将经常访问内存中的字节大小对象。然而，别忘了，你也可以通过指定其第一个字节的地址来访问80x86处理器上的字和双字（见[图 3-5](ch03.xhtml#ch3fig5)）。
- en: '![Image](../images/03fig05.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig05.jpg)'
- en: '*Figure 3-5: Accessing a word or double word using the direct addressing mode*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-5：使用直接寻址模式访问字或双字*'
- en: 'MASM and Gas use the same syntax for the displacement addressing mode as HLA:
    for the operand, you simply specify the name of the object you want to access.
    Some MASM programmers put brackets around the variable names, although that isn’t
    strictly necessary with those assemblers.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: MASM和Gas在位移寻址模式的语法上与HLA相同：对于操作数，只需指定要访问的对象名称。一些MASM程序员会将变量名放在方括号中，尽管这些汇编器中并不严格要求这样做。
- en: 'Here are several examples using HLA, Gas, and MASM syntax:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用HLA、Gas和MASM语法的几个示例：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**3.5.4 RIP-Relative Addressing Mode**'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.5.4 RIP相对寻址模式**'
- en: The x86-64 CPUs, when operating in 64-bit mode, do not support the 32-bit direct
    addressing mode. Not wanting to add a 64-bit constant to the end of the instruction
    (to support the entire 64-bit address space), AMD engineers chose to create an
    RIP-relative addressing mode that computes the effective memory address by adding
    a signed 32-bit constant (replacing the direct address) to the value in the RIP
    (instruction pointer) register. This allows for accessing data within a ±2GB range
    around the current instruction.^([3](footnotes.xhtml#ch3fn3))
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 CPU在64位模式下不支持32位直接寻址模式。由于不希望在指令末尾添加一个64位常量（以支持整个64位地址空间），AMD工程师选择创建一个RIP相对寻址模式，通过将一个带符号的32位常量（替代直接地址）加到RIP（指令指针）寄存器中的值来计算有效的内存地址。这允许在当前指令周围的±2GB范围内访问数据。^([3](footnotes.xhtml#ch3fn3))
- en: '**3.5.5 Register Indirect Addressing Mode**'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.5.5 寄存器间接寻址模式**'
- en: The 80x86 CPUs let you access memory indirectly through a register using the
    register indirect addressing modes. These modes are called *indirect* because
    the operand is not the actual address; rather, its value specifies the memory
    address to use. In the case of the register indirect addressing modes, the register’s
    value is the address to access. For example, the HLA instruction `mov(eax,[ebx]);`
    tells the CPU to store EAX’s value at the location whose address is held in EBX.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86 CPU允许通过寄存器使用寄存器间接寻址模式间接访问内存。这些模式被称为*间接*，因为操作数不是实际地址；相反，它的值指定了要使用的内存地址。在寄存器间接寻址模式中，寄存器的值就是要访问的地址。例如，HLA指令`mov(eax,[ebx]);`告诉CPU将EAX的值存储在EBX中保存的地址所指向的位置。
- en: The x86-64 CPUs also support a register indirect addressing mode in 64-bit mode
    using one of the 64-bit registers (for example, RAX, RBX, . . . , R15). The register
    indirect addressing mode allows full access to the 64-bit address space. For example,
    the MASM instruction `mov eax, [rbx]` tells the CPU to load the EAX register from
    the location whose address is in RBX.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 CPU在64位模式下还支持使用64位寄存器（例如RAX、RBX、……、R15）进行寄存器间接寻址模式。寄存器间接寻址模式允许完全访问64位地址空间。例如，MASM指令`mov
    eax, [rbx]`指示CPU从RBX中存储的地址加载EAX寄存器的值。
- en: '**3.5.5.1 Register Indirect Modes in HLA**'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.5.1 HLA中的寄存器间接模式**'
- en: 'There are eight forms of this addressing mode on the 80x86\. Using HLA syntax,
    they look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在80x86上，这种寻址模式有八种形式。使用HLA语法，它们看起来是这样的：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These eight addressing modes reference the memory location at the offset found
    in the register enclosed by brackets (EAX, EBX, ECX, EDX, EDI, ESI, EBP, or ESP,
    respectively).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这八种寻址模式通过寄存器中的偏移量引用内存位置，该寄存器用方括号括起来（分别为EAX、EBX、ECX、EDX、EDI、ESI、EBP或ESP）。
- en: '**NOTE**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The HLA register indirect addressing modes require a 32-bit register. You
    cannot specify a 16-bit or 8-bit register when using an indirect addressing mode.*'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*HLA的寄存器间接寻址模式需要一个32位寄存器。使用间接寻址模式时，不能指定16位或8位寄存器。*'
- en: '**3.5.5.2 Register Indirect Modes in MASM**'
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.5.2 MASM中的寄存器间接模式**'
- en: MASM uses exactly the same syntax as HLA for the register indirect addressing
    modes in 32-bit mode (though keep in mind that MASM reverses the instruction operands;
    only the addressing mode syntax is identical). In 64-bit mode the syntax is the
    same—a pair of brackets around a register name—although this mode uses 64-bit
    registers rather than 32-bit registers.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 在 32 位模式下使用的寄存器间接寻址模式与 HLA 的语法完全相同（不过需要注意的是，MASM 会反转指令操作数；只有寻址模式语法是相同的）。在
    64 位模式下，语法相同——即寄存器名称周围有一对方括号——不过这种模式使用的是 64 位寄存器，而不是 32 位寄存器。
- en: 'Here are the MASM equivalents of the instructions given earlier:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面给出的指令的 MASM 等效实现：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here are the MASM 64-bit register indirect addressing mode examples:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 MASM 64 位寄存器间接寻址模式的示例：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**3.5.5.3 Register Indirect Modes in Gas**'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.5.3 Gas 中的寄存器间接模式**'
- en: 'Gas uses parentheses instead of brackets around the register names. Here are
    the Gas variants of the previous 32-bit HLA `mov` instructions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 使用括号而不是方括号来表示寄存器名称。以下是前述 32 位 HLA `mov` 指令的 Gas 变体：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here are Gas’s 64-bit register indirect variants:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Gas 的 64 位寄存器间接寻址变体：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**3.5.6 Indexed Addressing Mode**'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.5.6 索引寻址模式**'
- en: The *effective address* is the ultimate address in memory that an instruction
    will access once all the address calculations are complete. The indexed addressing
    mode computes an effective address by adding the address (also called the *displacement*
    or *offset*) of the variable to the value held in the 32-bit or 64-bit register
    within the square brackets. Their sum provides the memory address that the instruction
    accesses. For example, if VarName is at address `$1100` in memory and EBX contains
    `8`, then `mov(`VarName`[ebx],al);` loads the byte at address `$1108` into the
    AL register (see [Figure 3-6](ch03.xhtml#ch3fig6)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*有效地址*是指令在所有地址计算完成后将访问的最终内存地址。索引寻址模式通过将变量的地址（也称为*位移量*或*偏移*）与方括号内的 32 位或 64
    位寄存器的值相加，来计算有效地址。它们的和提供了指令访问的内存地址。例如，如果 VarName 在内存中的地址为 `$1100`，而 EBX 寄存器包含值
    `8`，那么 `mov(`VarName`[ebx],al);` 将从地址 `$1108` 加载字节到 AL 寄存器中（见[图 3-6](ch03.xhtml#ch3fig6)）。'
- en: On the x86-64 CPUs, the addressing mode uses one of the 64-bit registers. Note,
    however, that the displacement encoded as part of the instruction is still 32
    bits. Thus, the register must hold the base address while the displacement provides
    an offset (index) from the base address.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x86-64 CPU 上，寻址模式使用其中一个 64 位寄存器。但是，值得注意的是，作为指令一部分编码的位移量仍然是 32 位的。因此，寄存器必须保存基地址，而位移量则提供相对于基地址的偏移（索引）。
- en: '![Image](../images/03fig06.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig06.jpg)'
- en: '*Figure 3-6: Indexed addressing mode*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-6：索引寻址模式*'
- en: '**3.5.6.1 Indexed Addressing Mode in HLA**'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.6.1 HLA 中的索引寻址模式**'
- en: 'The indexed addressing modes use the following HLA syntax, where VarName is
    the name of some static variable in your program:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 索引寻址模式使用以下 HLA 语法，其中 VarName 是你程序中某个静态变量的名称：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**3.5.6.2 Indexed Addressing Mode in MASM**'
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.6.2 MASM 中的索引寻址模式**'
- en: 'MASM supports the same syntax as HLA in 32-bit mode, but it also allows several
    variations of this syntax for specifying the indexed addressing mode. The following
    are equivalent formats that demonstrate some of the variations MASM supports:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 在 32 位模式下支持与 HLA 相同的语法，但它还允许多种变体的语法，用于指定索引寻址模式。以下是展示 MASM 支持的某些变体的等效格式：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Thanks to the commutative nature of addition, MASM also allows many other combinations.
    It treats two juxtaposed items within brackets as though they were separated by
    the `+` operator.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加法的交换律，MASM 还允许许多其他组合。它将括号内的两个并排项视为被 `+` 运算符分隔。
- en: 'Here are the MASM equivalents to the previous HLA example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 MASM 对前述 HLA 示例的等效实现：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In 64-bit mode, MASM requires that you specify 64-bit register names for the
    indexed addressing mode. In 64-bit mode, the register holds the base address of
    the variable in memory, and the displacement encoded into the instruction provides
    an offset from that base address. This means that you cannot use a register as
    an index into a global array (which would normally use the RIP-relative addressing
    mode).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位模式下，MASM 要求你为索引寻址模式指定 64 位寄存器名称。在 64 位模式下，寄存器保存内存中变量的基地址，而编码到指令中的位移量提供了从该基地址的偏移。这意味着你不能使用寄存器作为全局数组的索引（通常使用的是
    RIP 相对寻址模式）。
- en: 'Here are examples of the valid MASM indexed address modes in 64-bit mode:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 64 位模式下有效的 MASM 索引寻址模式示例：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**3.5.6.3 Indexed Addressing Mode in Gas**'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.6.3 Gas 中的索引寻址模式**'
- en: 'As with the register indirect addressing mode, Gas uses parentheses rather
    than brackets. Here is the Gas syntax for the indexed addressing mode:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与寄存器间接寻址模式一样，Gas 使用括号而非方括号。以下是 Gas 的索引寻址模式语法：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here are the Gas equivalents to the HLA instructions given earlier:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Gas 对应于前面给出的 HLA 指令的等价形式：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In 64-bit mode, Gas requires that you specify 64-bit register names for the
    indexed addressing mode. The same rules apply as for MASM.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位模式下，Gas 要求你为索引寻址模式指定 64 位寄存器名称。与 MASM 一样，适用相同的规则。
- en: 'Here are examples of the valid Gas indexed address modes in 64-bit mode:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 64 位模式下有效的 Gas 索引寻址模式示例：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**3.5.7 Scaled-Index Addressing Modes**'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.5.7 缩放索引寻址模式**'
- en: 'The scaled-index addressing modes are similar to the indexed addressing modes,
    but with two differences. The scaled-index addressing modes allow you to:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式与索引寻址模式相似，但有两个不同点。缩放索引寻址模式使你能够：
- en: Combine two registers plus a displacement
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合两个寄存器加上一个位移量
- en: Multiply the index register by a (scaling) factor of 1, 2, 4, or 8
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将索引寄存器乘以 1、2、4 或 8 的（缩放）因子
- en: 'To see what makes this possible, consider the following HLA example:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解是什么使其成为可能，请考虑以下 HLA 示例：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The primary difference between the scaled-index addressing mode and the indexed
    addressing mode is the inclusion of the `esi*4` component. This example computes
    the effective address by adding in the value of ESI multiplied by 4 (see [Figure
    3-7](ch03.xhtml#ch3fig7)).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放索引寻址模式与索引寻址模式之间的主要区别是包含了 `esi*4` 这一部分。这个示例通过加上 ESI 乘以 4 的值来计算有效地址（见 [图 3-7](ch03.xhtml#ch3fig7)）。
- en: '![Image](../images/03fig07.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig07.jpg)'
- en: '*Figure 3-7: Scaled-index addressing mode*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-7：缩放索引寻址模式*'
- en: In 64-bit mode, substitute 64-bit registers for the base and index registers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位模式下，替换基址寄存器和索引寄存器为 64 位寄存器。
- en: '**3.5.7.1 Scaled-Index Addressing in HLA**'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.7.1 HLA 中的缩放索引寻址**'
- en: 'HLA’s syntax provides several different ways to specify the scaled-index addressing
    mode. Here are the various syntactical forms:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: HLA 的语法提供了几种不同的方法来指定缩放索引寻址模式。以下是各种语法形式：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In these examples, BaseReg[32] represents any general-purpose 32-bit register,
    IndexReg[32] represents any general-purpose 32-bit register except ESP, and scale
    must be one of the constants `1`, `2`, `4`, or `8`. VarName represents a static
    variable name and displacement represents a 32-bit constant.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，BaseReg[32] 表示任何通用的 32 位寄存器，IndexReg[32] 表示除 ESP 之外的任何通用 32 位寄存器，缩放因子必须是
    `1`、`2`、`4` 或 `8` 中的常量。VarName 表示一个静态变量名，位移量表示一个 32 位常量。
- en: '**3.5.7.2 Scaled-Index Addressing in MASM**'
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.7.2 MASM 中的缩放索引寻址**'
- en: MASM supports the same syntax for these addressing modes as HLA, but with additional
    forms comparable to those presented for the indexed addressing mode. Those forms
    are just syntactical variants based on the commutativity of the `+` operator.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 支持与 HLA 相同的寻址模式语法，但有一些额外的形式，与索引寻址模式的呈现方式类似。这些形式只是基于 `+` 运算符的交换性而产生的语法变体。
- en: MASM also supports 64-bit scaled-index addressing, which has the same syntax
    as the 32-bit mode except you swap in 64-bit register names. The major difference
    between the 32-bit and 64-bit scaled-index addressing modes is that there is no
    64-bit `disp[reg*index]` addressing mode. On 64-bit addressing modes, this is
    a PC-relative indexed addressing mode, where the displacement is a 32-bit offset
    from the current instruction pointer value.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 还支持 64 位缩放索引寻址，它与 32 位模式具有相同的语法，只不过你需要使用 64 位寄存器名称。32 位和 64 位缩放索引寻址模式之间的主要区别在于，64
    位 `disp[reg*index]` 寻址模式不存在。在 64 位寻址模式中，这是一个相对程序计数器的索引寻址模式，其中位移量是与当前指令指针值的 32
    位偏移量。
- en: '**3.5.7.3 Scaled-Index Addressing in Gas**'
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.5.7.3 Gas 中的缩放索引寻址**'
- en: 'As usual, Gas uses parentheses rather than brackets to surround scaled-index
    operands. Gas also uses a three-operand syntax to specify the *base register*,
    the *index register*, and the *scale factor*, rather than the arithmetic expression
    syntax that the other assemblers employ. The generic syntax for the Gas scaled-index
    addressing mode is:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，Gas 使用括号而非方括号来包围缩放索引操作数。Gas 还使用三操作数语法来指定 *基址寄存器*、*索引寄存器* 和 *缩放因子*，而不是其他汇编程序使用的算术表达式语法。Gas
    缩放索引寻址模式的通用语法是：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'More specifically:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: where scale is one of the values `1`, `2`, `4`, or `8`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其中缩放因子是 `1`、`2`、`4` 或 `8` 中的一个值。
- en: Gas also supports 64-bit scaled-index addressing. It uses the same syntax as
    the 32-bit mode except you swap in 64-bit register names. When using 64-bit addressing,
    you cannot also specify an RIP-relative variable name (VarName in these examples);
    only a 32-bit displacement is legal.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Gas还支持64位缩放索引寻址。它使用与32位模式相同的语法，只是将64位寄存器名称交换进来。在使用64位寻址时，不能同时指定RIP相关的变量名（例如这些示例中的VarName）；只能使用32位位移量。
- en: '**3.6 Declaring Data in Assembly Language**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.6 在汇编语言中声明数据**'
- en: 'The 80x86 architecture provides only a few low-level machine data types on
    which individual machine instructions operate:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86架构提供的仅有少数几种低级机器数据类型，供各个机器指令操作：
- en: byte Holds arbitrary 8-bit values.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: byte 用于存储任意8位值。
- en: word Holds arbitrary 16-bit values.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: word 用于存储任意16位值。
- en: dword “Double word”; holds arbitrary 32-bit values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: dword “双字”；用于存储任意32位值。
- en: qword “Quad word”; holds arbitrary 64-bit values.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: qword “四字双字”；用于存储任意64位值。
- en: real32 **(aka** real4**)** Holds 32-bit single-precision floating-point values.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: real32 **（也叫** real4**）** 用于存储32位单精度浮点值。
- en: real64 **(aka** real8**)** Holds 64-bit double-precision floating-point values.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: real64 **（也叫** real8**）** 用于存储64位双精度浮点值。
- en: '**NOTE**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*80x86 assemblers typically support tbyte (“ten byte”) and real80/real10 data
    types, but we won’t cover those types here because most modern (64-bit) HLL compilers
    don’t use them. (However, certain C/C++ compilers support real80 values using
    the long double data type; Swift also supports real80 values on Intel machines
    using the float80 type.)*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*80x86汇编器通常支持tbyte（“十字节”）和real80/real10数据类型，但我们在这里不讨论这些类型，因为大多数现代（64位）高级语言编译器不使用它们。（然而，某些C/C++编译器使用long
    double数据类型支持real80值；Swift在Intel机器上也通过float80类型支持real80值。）*'
- en: '**3.6.1 Data Declarations in HLA**'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.6.1 在HLA中声明数据**'
- en: The HLA assembler, true to its high-level nature, provides a wide variety of
    single-byte data types including character, signed integer, unsigned integer,
    Boolean, and enumerated types. Were you to write an application in assembly language,
    having all these different data types (along with the type checking that HLA provides)
    would be quite useful. For our purposes, however, we can simply allocate storage
    for byte variables and set aside a block of bytes for larger data structures.
    The HLA `byte` type is all we really need for 8-bit and array objects.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: HLA汇编器忠于其高级语言的特性，提供了多种单字节数据类型，包括字符、带符号整数、无符号整数、布尔值和枚举类型。如果你用汇编语言编写应用程序，拥有所有这些不同的数据类型（以及HLA提供的类型检查）将非常有用。然而，对于我们的目的，我们可以简单地为字节变量分配存储空间，并为更大的数据结构预留一块字节空间。对于8位和数组对象，HLA的`byte`类型就足够了。
- en: 'You can declare `byte` objects in an HLA `static` section as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在HLA的`static`部分声明`byte`对象，方法如下：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To allocate storage for a block of bytes, you’d use the following HLA syntax:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要为一块字节分配存储空间，可以使用以下HLA语法：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'These HLA declarations create *uninitialized* variables. Technically speaking,
    HLA always initializes `static` objects with `0`s, so they aren’t truly uninitialized,
    but the main point is that this code does not explicitly initialize these byte
    objects with a value. You can, however, tell HLA to initialize your byte variables
    with a value when the operating system loads the program into memory using statements
    like the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些HLA声明创建了*未初始化*的变量。从技术上讲，HLA始终将`static`对象初始化为`0`，因此它们并不真正是未初始化的，但关键点是这段代码没有显式地为这些字节对象赋初值。不过，你可以告诉HLA在操作系统将程序加载到内存时，使用如下语句来初始化你的字节变量：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '**3.6.2 Data Declarations in MASM**'
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.6.2 MASM中的数据声明**'
- en: 'In MASM, you would normally use the `db` or `byte` directives within a `.data`
    section to reserve storage for a byte object or an array of byte objects. The
    syntax for a single declaration would take one of these equivalent forms:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在MASM中，通常会在`.data`节中使用`db`或`byte`指令来为字节对象或字节对象数组预留存储空间。单个声明的语法会采取以下等效形式：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding declarations create uninitialized objects (which are actually
    initialized with `0`s, just as with HLA). The `?` in the operand field of the
    `db`/`byte` directive informs the assembler that you don’t want to explicitly
    attach a value to the declaration.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声明创建了未初始化的对象（实际上与HLA一样，初始化为`0`）。`db`/`byte`指令的操作数字段中的`?`告诉汇编器你不想显式地为声明附加值。
- en: 'To declare a variable that is a block of bytes, you’d use syntax like the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个字节块变量，可以使用如下语法：
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To create objects with an initial value other than zero, you could use syntax
    like the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个初始值不为零的对象，你可以使用如下语法：
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To create an initialized array of bytes whose values are not all the same,
    you simply specify a comma-delimited list of values in the operand field of the
    MASM `db`/`byte` directive:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个初始化的字节数组，其值并不完全相同，你只需在MASM的`db`/`byte`指令的操作数字段中指定一个以逗号分隔的值列表：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**3.6.3 Data Declarations in Gas**'
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.6.3 Gas中的数据声明**'
- en: 'Gas uses the `.byte` directive in a `.data` section to declare a byte variable.
    The generic form of this directive is:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Gas在`.data`节中使用`.byte`指令声明字节变量。该指令的通用形式是：
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Gas doesn’t provide an explicit format for creating uninitialized variables;
    instead, you just supply a `0` operand for uninitialized variables. Here are two
    actual byte variable declarations in Gas:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Gas没有提供显式格式来创建未初始化的变量；相反，你只需为未初始化的变量提供一个`0`操作数。以下是两个Gas中的字节变量声明示例：
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Gas does not provide an explicit directive for declaring an array of byte objects,
    but you can use the `.rept`/`.endr` directives to create multiple copies of the
    `.byte` directive as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Gas没有提供一个显式的指令来声明字节对象数组，但你可以使用`.rept`/`.endr`指令创建多个`.byte`指令的副本，如下所示：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**NOTE**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can also supply a comma-delimited list of values if you want to initialize
    the array with different values.*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想使用不同的值初始化数组，你也可以提供一个以逗号分隔的值列表。*'
- en: 'Here are a couple of array declaration examples in Gas:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些Gas中数组声明的示例：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**3.6.3.1 Accessing Byte Variables in Assembly Language**'
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**3.6.3.1 在汇编语言中访问字节变量**'
- en: 'When accessing byte variables, you simply use the variable’s declared name
    in one of the 80x86 addressing modes. For example, given a byte object named `byteVar`
    and an array of bytes named `byteArray`, you could use any of the following instructions
    to load that variable into the AL register using the `mov` instruction (these
    examples assume 32-bit code):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问字节变量时，你只需在80x86寻址模式之一中使用变量声明的名称。例如，给定一个名为`byteVar`的字节对象和一个名为`byteArray`的字节数组，你可以使用以下任一指令，通过`mov`指令将该变量加载到AL寄存器中（这些示例假设是32位代码）：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For 16-bit objects, HLA uses the `word` data type, MASM uses either the `dw`
    or `word` directives, and Gas uses the `.int` directive. Other than the size of
    the object these directives declare, their use is identical to the byte declarations.
    For example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于16位对象，HLA使用`word`数据类型，MASM使用`dw`或`word`指令，Gas使用`.int`指令。除了这些指令声明的对象大小外，它们的使用方式与字节声明完全相同。例如：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'For 32-bit objects, HLA uses the `dword` data type, MASM uses the `dd` or `dword`
    directives, and Gas uses the `.long` directive. For example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于32位对象，HLA使用`dword`数据类型，MASM使用`dd`或`dword`指令，Gas使用`.long`指令。例如：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**3.7 Specifying Operand Sizes in Assembly Language**'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.7 在汇编语言中指定操作数大小**'
- en: '80x86 assemblers use two mechanisms to specify their operand sizes:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 80x86汇编器使用两种机制来指定它们的操作数大小：
- en: The operands specify the size using type checking (most assemblers do this).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作数通过类型检查指定大小（大多数汇编器都会这样做）。
- en: The instructions themselves specify the size (Gas does this).
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令本身指定了大小（Gas这样做）。
- en: 'For example, consider the following three HLA `mov` instructions:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下三个HLA的`mov`指令：
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In each case, the register operand specifies the size of the data that the
    `mov` instruction copies into that register. MASM uses a similar syntax (though
    the operands are reversed):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，寄存器操作数指定`mov`指令将数据复制到该寄存器时的数据大小。MASM使用类似的语法（尽管操作数顺序相反）：
- en: '[PRE64]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The takeaway here is that the instruction mnemonic (`mov`) is exactly the same
    in all six cases. The operand, not the instruction mnemonic, specifies the size
    of the data transfer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要记住的是，指令助记符（`mov`）在所有六种情况下都是完全相同的。是操作数，而不是指令助记符，指定了数据传输的大小。
- en: '**NOTE**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Modern versions of Gas also allow you to specify the size of the operation
    by operand (register) size without using a suffix such as b or w. This book, however,
    will continue to use mnemonics such as movb or movw to avoid confusion with older
    variants of Gas. “Type Coercion in Gas” on [page 45](ch03.xhtml#page_45).*'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*现代版本的Gas也允许你通过操作数（寄存器）大小来指定操作的大小，而不使用如b或w的后缀。然而，本书将继续使用类似`movb`或`movw`的助记符，以避免与旧版本Gas产生混淆。有关“Gas中的类型强制”请参见[第45页](ch03.xhtml#page_45)。*'
- en: '**3.7.1 Type Coercion in HLA**'
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.7.1 HLA中的类型强制**'
- en: 'There is one problem with the preceding approach to specifying the operand
    size. Consider the following HLA example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 关于指定操作数大小的前一种方法有一个问题。考虑以下HLA示例：
- en: '[PRE65]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This instruction is ambiguous. The memory location to which EBX points could
    be a byte, a word, or a double word. Nothing in the instruction tells the assembler
    the size of the operand. Faced with an instruction like this, the assembler will
    report an error, and you’ll have to explicitly tell it the size of the memory
    operand. In HLA’s case, this is done with a type coercion operator as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令不明确。EBX 所指向的内存位置可能是一个字节、一个字或一个双字。指令中没有任何内容可以告诉汇编器操作数的大小。当遇到这样的指令时，汇编器会报告错误，你必须显式地告诉它内存操作数的大小。在
    HLA 的情况下，可以通过如下类型强制操作符来完成：
- en: '[PRE66]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In general, you can coerce any memory operand to an appropriate size using
    the following HLA syntax:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以使用以下 HLA 语法将任何内存操作数强制为适当的大小：
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: where new_type represents a data type (such as `byte`, `word`, or `dword`) and
    memory represents the memory address whose type you would like to override.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，new_type 代表数据类型（如 `byte`、`word` 或 `dword`），memory 代表你希望覆盖类型的内存地址。
- en: '**3.7.2 Type Coercion in MASM**'
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.7.2 MASM 中的类型强制**'
- en: 'MASM suffers from this same problem. You will need to coerce the memory location
    using a coercion operator like the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 也面临同样的问题。你需要使用像以下这样的强制操作符来强制内存位置的类型：
- en: '[PRE68]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Of course, you can substitute `byte` or `dword` for `word` in these two examples
    to coerce the memory location to a byte or double word size.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在这两个例子中将 `byte` 或 `dword` 替换为 `word`，以将内存位置强制为字节或双字大小。
- en: '**3.7.3 Type Coercion in Gas**'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**3.7.3 Gas 中的类型强制**'
- en: 'Gas doesn’t require type coercion operators, because it uses a different technique
    to specify the size of its operands. Rather than using the single mnemonic `mov`,
    Gas uses four mnemonics consisting of `mov` plus a single-character suffix that
    indicates the size:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 不需要类型强制操作符，因为它采用不同的技术来指定操作数的大小。与使用单一助记符 `mov` 不同，Gas 使用四个助记符，其中包括 `mov`
    和一个单字符后缀，后缀表示大小：
- en: movb Copy an 8-bit (`byte`) value
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: movb 复制一个8位（`byte`）值
- en: movw Copy a 16-bit (`word`) value
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: movw 复制一个16位（`word`）值
- en: movl Copy a 32-bit (`long`) value
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: movl 复制一个32位（`long`）值
- en: movq Copy a 64-bit (`long long`) value
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: movq 复制一个64位（`long long`）值
- en: 'There is never any ambiguity when you use these mnemonics, even if their operands
    don’t have an explicit size. For example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些助记符时，永远不会存在任何歧义，即使它们的操作数没有明确的大小。例如：
- en: '[PRE69]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: With this basic information, you should now be able to understand the output
    from a typical compiler.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些基本信息，你现在应该能够理解来自典型编译器的输出。
- en: '**3.8 For More Information**'
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**3.8 更多信息**'
- en: Bartlett, Jonathan. *Programming from the Ground Up*. Edited by Dominick Bruno,
    Jr. Self-published, 2004\. An older, free version of this book, which teaches
    assembly language programming using Gas, can be found online at *[http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf](http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf)*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Bartlett, Jonathan. *从零开始学编程*。由Dominick Bruno Jr. 编辑。自出版，2004年。该书的一个较旧且免费的版本，使用
    Gas 教授汇编语言编程，可以在网上找到，链接为 *[http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf](http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf)*。
- en: 'Blum, Richard. *Professional Assembly Language*. Indianapolis: Wiley, 2005.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Blum, Richard. *专业汇编语言*。印第安纳波利斯：Wiley，2005年。
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Duntemann, Jeff. *从基础开始学汇编语言*。第3版。印第安纳波利斯：Wiley，2009年。
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Hyde, Randall. *汇编语言的艺术*。第2版。旧金山：No Starch Press，2010年。
- en: Intel. “Intel 64 and IA-32 Architectures Software Developer Manuals.” Updated
    November 11, 2019\. *[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Intel. “Intel 64 和 IA-32 架构软件开发者手册。”更新于2019年11月11日。 *[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*。
