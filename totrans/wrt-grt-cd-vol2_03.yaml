- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**80X86 ASSEMBLY FOR THE HLL PROGRAMMER**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this book, you’ll examine high-level language code and compare it
    to the machine code that a compiler generates for it. Making sense of a compiler’s
    output requires some knowledge of assembly language, but fortunately, you don’t
    need to be an expert assembly programmer for this. As discussed in previous chapters,
    all you really need is the ability to read code generated by compilers and other
    assembly language programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides a primer specifically on the 80x86 assembly language,
    covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic 80x86 machine architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read the 80x86 output produced by various compilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The addressing modes that the 32-bit and 64-bit 80x86 CPUs support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax that several common 80x86 assemblers (HLA, MASM, and Gas) use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use constants and declare data in assembly language programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**3.1 Learning One Assembly Language Is Good, Learning More Is Better**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you intend to write code for a processor other than the 80x86, you should
    really learn how to read at least two different assembly languages. By doing so,
    you’ll avoid the pitfall of coding for the 80x86 in an HLL and then finding that
    your “optimizations” work only on the 80x86 CPU. For this reason, this book includes
    several online appendixes that provide additional resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A covers the minimal x86 instruction set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix B is a primer on the PowerPC CPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix C examines the ARM processor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix D describes the Java bytecode assembly language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix E covers the Microsoft Intermediate Language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll see that all five architectures rely on many of the same concepts, but
    there are some important differences among them, and advantages and disadvantages
    to each.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the main difference between *complex instruction set computer (CISC)*
    and *reduced instruction set computer (RISC)* architectures is the way they use
    memory. RISC architectures limit memory access to certain instructions, so applications
    go to great lengths to avoid accessing memory. The 80x86 architecture, on the
    other hand, allows most instructions to access memory, and applications generally
    take advantage of this facility.
  prefs: []
  type: TYPE_NORMAL
- en: The Java bytecode (JBC) and Microsoft Intermediate Language (IL) architectures
    differ from the 80x86, PowerPC, and ARM families in that JBC and IL are *virtual
    machines*, not actual CPUs. Generally, software interprets or attempts to compile
    JBC at runtime (IL code is always compiled at runtime).^([1](footnotes.xhtml#ch3fn1))
    This means JBC and IL code tends to run much slower than true machine code.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2 80x86 Assembly Syntaxes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While 80x86 programmers can choose from a wide variety of program development
    tools, this abundance has a minor drawback: syntactical incompatibility. Different
    compilers and debuggers for the 80x86 family output different assembly language
    listings for the exact same program. This is because those tools emit code for
    different assemblers. For example, Microsoft’s Visual C++ package generates assembly
    code compatible with Microsoft Macro Assembler (MASM). The GNU Compiler Suite
    (GCC) generates Gas-compatible source code (Gas is the GNU Assembler from the
    Free Software Foundation). In addition to the code that compilers emit, you’ll
    find tons of assembly programming examples written with assemblers like FASM,
    NASM, GoAsm, and HLA (High-Level Assembly).'
  prefs: []
  type: TYPE_NORMAL
- en: It would be nice to use just a single assembler syntax throughout this book,
    but because our approach is not compiler specific, we must consider the syntaxes
    for several different common assemblers. This book will generally present non-compiler-specific
    examples using HLA. Therefore, this chapter will discuss the syntaxes for HLA
    as well as two other common assemblers, MASM and Gas. Fortunately, once you master
    the syntax for one assembler, learning the syntax of other assemblers is very
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2.1 Basic 80x86 Architecture**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Intel CPU is generally classified as a *Von Neumann machine*. Von Neumann
    computer systems contain three main building blocks: the *central processing unit
    (CPU)*, *memory*, and *input/output (I/O) devices*. These three components are
    connected via the *system bus* (consisting of the address, data, and control buses).
    [Figure 3-1](ch03.xhtml#ch3fig1) shows this relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Block diagram of a Von Neumann system*'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU communicates with memory and I/O devices by placing a numeric value
    on the *address bus* to select one of the memory locations or I/O device port
    locations, each of which has a unique binary numeric address. Then the CPU, I/O,
    and memory devices pass data among themselves by placing the data on the *data
    bus*. The *control bus* contains signals that determine the direction of the data
    transfer (to or from memory, and to or from an I/O device).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2.2 Registers**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The register set is the most prominent feature within the CPU. Almost all calculations
    on the 80x86 CPU involve at least one register. For example, to add the value
    of two variables and store their sum in a third variable, you must load one of
    the variables into a register, add the second operand to the register, and then
    store the register’s value in the destination variable. Registers are middlemen
    in almost every calculation and thus are very important in 80x86 assembly language
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 80x86 CPU registers can be broken down into four categories: general-purpose
    registers, special-purpose application-accessible registers, segment registers,
    and special-purpose kernel-mode registers. We won’t consider the last two categories,
    because the segment registers are not used very much in modern operating systems
    (for example, Windows, BSD, macOS, and Linux), and the special-purpose kernel-mode
    registers are intended for writing operating systems, debuggers, and other system-level
    tools—a topic well beyond the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2.3 80x86 32-Bit General-Purpose Registers**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The 32-bit 80x86 (Intel family) CPUs provide several general-purpose registers
    for application use. These include eight 32-bit registers: EAX, EBX, ECX, EDX,
    ESI, EDI, EBP, and ESP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *E* prefix on each name stands for *extended*. This prefix differentiates
    the 32-bit registers from the original eight 16-bit registers: AX, BX, CX, DX,
    SI, DI, BP, and SP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the 80x86 CPUs provide eight 8-bit registers: AL, AH, BL, BH, CL,
    CH, DL, and DH.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to note about the general-purpose registers is that
    they are not independent. That is, the 80x86 architecture does not provide 24
    separate registers. Instead, it overlaps the 32-bit registers with the 16-bit
    registers, and it overlaps the 16-bit registers with the 8-bit registers. [Figure
    3-2](ch03.xhtml#ch3fig2) shows this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Intel 80x86 CPU general-purpose registers*'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that modifying one register may modify as many as three other registers
    cannot be overemphasized. For example, modifying the EAX register may also modify
    the AL, AH, and AX registers. You will often see compiler-generated code using
    this feature of the 80x86\. For example, a compiler may clear (set to `0`) all
    the bits in the EAX register and then load AL with a `1` or `0` in order to produce
    a 32-bit `true` (`1`) or `false` (`0`) value. Some machine instructions manipulate
    only the AL register, yet the program may need to return those instructions’ results
    in EAX. By taking advantage of the register overlap, the compiler-generated code
    can use an instruction that manipulates AL to return that value in all of EAX.
  prefs: []
  type: TYPE_NORMAL
- en: Although Intel calls these registers *general purpose*, that’s not to suggest
    that you can use any register for any purpose. The SP/ESP register pair, for example,
    has a very special purpose that effectively prevents you from using it for any
    other reason (it’s the *stack pointer*). Likewise, the BP/EBP register has a special
    purpose that limits its usefulness as a general-purpose register. All the 80x86
    registers have their own special purposes that limit their use in certain contexts;
    we’ll consider these special uses as we discuss the machine instructions that
    use them (see the online resources).
  prefs: []
  type: TYPE_NORMAL
- en: 'Contemporary versions of the 80x86 CPU (typically known as the *x86-64 CPU*)
    provide two important extensions to the 32-bit register set: a set of 64-bit registers
    and a second set of eight registers (64-bit, 32-bit, 16-bit, and 8-bit). The main
    64-bit registers have the following names: RAX, RBX, RCX, RDX, RSI, RDI, RBP,
    and RSP.'
  prefs: []
  type: TYPE_NORMAL
- en: These 64-bit registers overlap the 32-bit “E” registers. That is, the 32-bit
    registers comprise the LO (low-order) 32 bits of each of these registers. For
    example, EAX is the LO 32 bits of RAX. Similarly, AX is the LO 16 bits of RAX,
    and AL is the LO 8 bits of RAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to providing 64-bit variants of the existing 80x86 32-bit registers,
    the x86-64 CPUs also add eight other 64/32/16/8-bit registers: R15, R14, R13,
    R12, R11, R10, R9, and R8.'
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the LO 32 bits of each of these registers as R15d, R14d, R13d,
    R12d, R11d, R10d, R9d, and R8d.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the LO 16 bits of each of these registers as R15w, R14w, R13w,
    R12w, R11w, R10w, R9w, and R8w.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can refer to the LO byte of each of these registers as R15b, R14b,
    R13b, R12b, R11b, R10b, R9b, and R8b.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2.4 The 80x86 EFLAGS Register**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The 32-bit EFLAGS register encapsulates numerous single-bit Boolean (`true`/`false`)
    values (or *flags*). Most of these bits are either reserved for kernel-mode (operating
    system) functions or of little interest to application programmers. There are,
    however, 8 bits relevant to application programmers reading (or writing) assembly
    language code: the overflow, direction, interrupt disable,^([2](footnotes.xhtml#ch3fn2))
    sign, zero, auxiliary carry, parity, and carry flags. [Figure 3-3](ch03.xhtml#ch3fig3)
    shows their layout within the EFLAGS register.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the eight flags that application programmers can use, four flags in particular
    are extremely valuable: the overflow, carry, sign, and zero flags. We call these
    four flags the *condition codes*. Each flag has a state—set or cleared—that you
    can use to test the result of previous computations. For example, after comparing
    two values, the condition-code flags will tell you if one value is less than,
    equal to, or greater than the other.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Layout of the 80x86 flags register (LO 16 bits)*'
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 64-bit RFLAGS register reserves all bits from bit 32 through bit
    63\. The upper 16 bits of the EFLAGS register are generally useful only to operating
    systems code.
  prefs: []
  type: TYPE_NORMAL
- en: Because the RFLAGS register doesn’t contain anything of interest when reading
    compiler output, this book will simply refer to the x86 and x86-64 flags register
    as EFLAGs, even on 64-bit variants of the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3 Literal Constants**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most assemblers support literal numeric (binary, decimal, and hexadecimal),
    character, and string constants. Unfortunately, just about every assembler out
    there uses a different syntax for literal constants. This section describes the
    syntax for the assemblers we’ll be using in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.1 Binary Literal Constants**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All assemblers provide the ability to specify base-2 (binary) literal constants.
    Few compilers emit binary constants, so you probably won’t see these values in
    the output a compiler produces, but you may see them in handwritten assembly code.
    C++ 14 supports binary literals (`0b`xxxxx) as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.1.1 Binary Literal Constants in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Binary literal constants in HLA begin with the percent character (`%`) followed
    by one or more binary digits (`0` or `1`). Underscore characters may appear between
    any two digits in a binary number. By convention, HLA programmers separate each
    group of four digits with an underscore. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.1.2 Binary Literal Constants in Gas**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Binary literal constants in Gas begin with the special `0b` prefix followed
    by one or more binary digits (`0` or `1`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.1.3 Binary Literal Constants in MASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Binary literal constants in MASM consist of one or more binary digits (`0`
    or `1`) followed by the special `b` suffix. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.2 Decimal Literal Constants**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Decimal constants in most assemblers take the standard form—a sequence of one
    or more decimal digits without any special prefix or suffix. This is one of the
    two common numeric formats that compilers emit, so you’ll often see decimal literal
    constants in compiler output code.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.2.1 Decimal Literal Constants in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'HLA allows you to optionally insert underscores between any two digits in a
    decimal number. HLA programmers generally use underscores to separate groups of
    three digits in a decimal number. For example, for the following numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'an HLA programmer could insert underscores as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.2.2 Decimal Literal Constants in Gas and MASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Gas and MASM use a string of decimal digits (the standard “computer” format
    for decimal values). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unlike HLA, Gas and MASM do not allow embedded underscores in decimal literal
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.3 Hexadecimal Literal Constants**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hexadecimal (base-16) literal constants are the other common numeric format
    you’ll find in assembly language programs (especially those that compilers emit).
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.3.1 Hexadecimal Literal Constants in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Hexadecimal literal constants in HLA consist of a string of hexadecimal digits
    (`0..9`, `a..f`, or `A..F`) with a `$` prefix. Underscores may optionally appear
    between any two hexadecimal digits in the number. By convention, HLA programmers
    separate sequences of four digits with underscores. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.3.2 Hexadecimal Literal Constants in Gas**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Hexadecimal literal constants in Gas consist of a string of hexadecimal digits
    (`0..9`, `a..f`, or `A..F`) with a `0x` prefix. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.3.3 Hexadecimal Literal Constants in MASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Hexadecimal literal constants in MASM consist of a string of hexadecimal digits
    (`0..9`, `a..f`, or `A..F`) with an `h` suffix. The values must begin with a decimal
    digit (`0` if the constant would normally begin with a digit in the range `a..f`).
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.4 Character and String Literal Constants**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Character and string data are also common data types that you’ll find in assembly
    programs. MASM does not differentiate between character or string literal constants.
    HLA and Gas, however, use a different internal representation for characters and
    strings, so the distinction between the two kinds of literal constants is very
    important in those assemblers.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3.4.1 Character and String Literal Constants in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Character literal constants in HLA take a few different forms. The most common
    is a single printable character surrounded by a pair of apostrophes, such as `''A''`.
    To specify an actual apostrophe as a character literal constant, HLA requires
    that you surround one pair of apostrophes by another (`''''''''`). Finally, you
    can also indicate a character constant using the `#` symbol followed by a binary,
    decimal, or hexadecimal numeric value that specifies the ASCII code of the character
    you want to use. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'String literal constants in HLA consist of a sequence of zero or more characters
    surrounded by quotation marks. To indicate an actual quotation mark character
    within a string constant, you use two adjacent quotation marks. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.4.2 Character and String Literal Constants in Gas**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Character literal constants in Gas consist of an apostrophe followed by a single
    character. More modern versions of Gas (and Gas on the Mac) also allow character
    constants of the form `''a''`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'String literal constants in Gas consist of a sequence of zero or more characters
    surrounded by quotes, and use the same syntax as C strings. You use the `\` escape
    sequence to embed special characters in a Gas string. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.4.3 Character and String Literal Constants in MASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Character and string literal constants in MASM take the same form: a sequence
    of one or more characters surrounded by either apostrophes or quotes. MASM does
    not differentiate character constants and string constants. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**3.3.5 Floating-Point Literal Constants**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Floating-point literal constants in assembly language typically take the same
    form you’ll find in HLLs (a sequence of digits, possibly containing a decimal
    point, optionally followed by a signed exponent). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**3.4 Manifest (Symbolic) Constants in Assembly Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost every assembler provides a mechanism for declaring symbolic (named) constants.
    In fact, most assemblers provide several ways to associate a value with an identifier
    in the source file.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.4.1 Manifest Constants in HLA**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The HLA assembler, true to its name, uses a high-level syntax for declaring
    named constants in the source file. You may define constants in one of three ways:
    in a `const` section, in a `val` section, or with the `?` compile-time operator.
    The `const` and `val` sections appear in the declaration section of an HLA program,
    and their syntax is very similar. The difference between them is that you may
    reassign values to identifiers you define in the `val` section, but you may not
    reassign values to identifiers appearing in a `const` section. Although HLA supports
    a wide range of options in these declaration sections, the basic declaration takes
    the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Wherever someIdentifier appears in the source file (after this declaration),
    HLA will substitute the value someValue in the identifier’s place. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In HLA, the `?` statement allows you to embed `val` declarations anywhere whitespace
    is allowed in the source file. This is sometimes useful because it isn’t always
    convenient to declare constants in a declaration section. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**3.4.2 Manifest Constants in Gas**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Gas uses the `.equ` (“equate”) statement to define a symbolic constant in the
    source file. This statement has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of equates within a Gas source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**3.4.3 Manifest Constants in MASM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'MASM also provides a couple of different ways to define manifest constants
    within a source file. One way is with the `equ` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another is with the `=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two is minor; see the MASM documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For the most part, compilers tend to emit the equ form rather than the = form.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5 80x86 Addressing Modes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An *addressing mode* is a hardware-specific mechanism for accessing instruction
    operands. The 80x86 family provides three different classes of operands: register,
    immediate, and memory operands. This section discusses each of these addressing
    modes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.1 80x86 Register Addressing Modes**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most 80x86 instructions can operate on the 80x86’s general-purpose register
    set. You access a register by specifying its name as an instruction operand.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider some examples of how our assemblers implement this strategy,
    using the 80x86 `mov` (move) instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.1.1 Register Access in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The HLA `mov` instruction looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This instruction copies the data from the source operand to the destination
    operand. The 8-bit, 16-bit, and 32-bit registers are valid operands for this instruction;
    the only restriction is that both operands must be the same size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at some actual 80x86 `mov` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that HLA supports only the 32-bit 80x86 register set, not the 64-bit register
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.1.2 Register Access in Gas**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Gas prepends each register name with percent sign (`%`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The Gas syntax for the `mov` instruction is similar to HLA’s, except that it
    drops the parentheses and semicolons and requires the assembly language statements
    to fit completely on one physical line of source code. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5.1.3 Register Access in MASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The MASM assembler uses the same register names as HLA but adds support for
    the 64-bit register set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'MASM uses a basic syntax that’s similar to that of Gas, except that MASM reverses
    the operands (which is the standard Intel syntax). That is, a typical instruction
    like `mov` takes this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of the `mov` instruction in MASM syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5.2 Immediate Addressing Mode**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most instructions that allow register and memory operands also allow immediate,
    or *constant*, operands. The following HLA `mov` instructions, for example, load
    appropriate values into the corresponding destination registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Most assemblers allow you to specify a wide variety of literal constant types
    when using the immediate addressing mode. For example, you can supply numbers
    in hexadecimal, decimal, or binary form. You can also supply character constants
    as operands. The rule is that the constant must fit in the size specified for
    the destination operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some additional examples with HLA, Gas, and MASM (note that Gas requires
    a `$` before immediate operands):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost every assembler lets you create symbolic constant names and supply them
    as source operands. For example, HLA predefines the two Boolean constants `true`
    and `false`, so you can supply those names as `mov` instruction operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Some assemblers even allow pointer constants and other abstract data type constants.
    (See the reference manual for your assembler for details.)
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.3 Displacement-Only Memory Addressing Mode**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most common 32-bit addressing mode, and the one that’s the easiest to understand,
    is the *displacement-only* (or *direct*) addressing mode, in which a 32-bit constant
    specifies the address of the memory location, which may be either the source or
    the destination operand. Note that this addressing mode is available only on 32-bit
    x86 processors or when operating in 32-bit mode on a 64-bit processor.
  prefs: []
  type: TYPE_NORMAL
- en: For example, assuming that variable `J` is a byte variable appearing at address
    `$8088`, the HLA instruction `mov(J,al);` loads the AL register with a copy of
    the byte at memory location `$8088`. Likewise, if the byte variable `K` is at
    address `$1234` in memory, then the instruction `mov(dl,K);` writes the value
    in the DL register to memory location `$1234` (see [Figure 3-4](ch03.xhtml#ch3fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: Displacement-only (direct) addressing mode*'
  prefs: []
  type: TYPE_NORMAL
- en: The displacement-only addressing mode is perfect for accessing simple scalar
    variables. It is the addressing mode you’d normally use to access static or global
    variables in an HLL program.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Intel named this addressing mode “displacement-only” because a 32-bit constant
    (displacement) follows the mov opcode in memory. On the 80x86 processors, this
    displacement is an offset from the beginning of memory (that is, address `0`).*'
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter will often access byte-sized objects in memory.
    Don’t forget, however, that you can also access words and double words on the
    80x86 processors by specifying the address of their first byte (see [Figure 3-5](ch03.xhtml#ch3fig5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: Accessing a word or double word using the direct addressing mode*'
  prefs: []
  type: TYPE_NORMAL
- en: 'MASM and Gas use the same syntax for the displacement addressing mode as HLA:
    for the operand, you simply specify the name of the object you want to access.
    Some MASM programmers put brackets around the variable names, although that isn’t
    strictly necessary with those assemblers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are several examples using HLA, Gas, and MASM syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5.4 RIP-Relative Addressing Mode**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The x86-64 CPUs, when operating in 64-bit mode, do not support the 32-bit direct
    addressing mode. Not wanting to add a 64-bit constant to the end of the instruction
    (to support the entire 64-bit address space), AMD engineers chose to create an
    RIP-relative addressing mode that computes the effective memory address by adding
    a signed 32-bit constant (replacing the direct address) to the value in the RIP
    (instruction pointer) register. This allows for accessing data within a ±2GB range
    around the current instruction.^([3](footnotes.xhtml#ch3fn3))
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.5 Register Indirect Addressing Mode**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 80x86 CPUs let you access memory indirectly through a register using the
    register indirect addressing modes. These modes are called *indirect* because
    the operand is not the actual address; rather, its value specifies the memory
    address to use. In the case of the register indirect addressing modes, the register’s
    value is the address to access. For example, the HLA instruction `mov(eax,[ebx]);`
    tells the CPU to store EAX’s value at the location whose address is held in EBX.
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64 CPUs also support a register indirect addressing mode in 64-bit mode
    using one of the 64-bit registers (for example, RAX, RBX, . . . , R15). The register
    indirect addressing mode allows full access to the 64-bit address space. For example,
    the MASM instruction `mov eax, [rbx]` tells the CPU to load the EAX register from
    the location whose address is in RBX.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.5.1 Register Indirect Modes in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are eight forms of this addressing mode on the 80x86\. Using HLA syntax,
    they look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These eight addressing modes reference the memory location at the offset found
    in the register enclosed by brackets (EAX, EBX, ECX, EDX, EDI, ESI, EBP, or ESP,
    respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The HLA register indirect addressing modes require a 32-bit register. You
    cannot specify a 16-bit or 8-bit register when using an indirect addressing mode.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.5.2 Register Indirect Modes in MASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: MASM uses exactly the same syntax as HLA for the register indirect addressing
    modes in 32-bit mode (though keep in mind that MASM reverses the instruction operands;
    only the addressing mode syntax is identical). In 64-bit mode the syntax is the
    same—a pair of brackets around a register name—although this mode uses 64-bit
    registers rather than 32-bit registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the MASM equivalents of the instructions given earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the MASM 64-bit register indirect addressing mode examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5.5.3 Register Indirect Modes in Gas**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Gas uses parentheses instead of brackets around the register names. Here are
    the Gas variants of the previous 32-bit HLA `mov` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are Gas’s 64-bit register indirect variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5.6 Indexed Addressing Mode**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *effective address* is the ultimate address in memory that an instruction
    will access once all the address calculations are complete. The indexed addressing
    mode computes an effective address by adding the address (also called the *displacement*
    or *offset*) of the variable to the value held in the 32-bit or 64-bit register
    within the square brackets. Their sum provides the memory address that the instruction
    accesses. For example, if VarName is at address `$1100` in memory and EBX contains
    `8`, then `mov(`VarName`[ebx],al);` loads the byte at address `$1108` into the
    AL register (see [Figure 3-6](ch03.xhtml#ch3fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: On the x86-64 CPUs, the addressing mode uses one of the 64-bit registers. Note,
    however, that the displacement encoded as part of the instruction is still 32
    bits. Thus, the register must hold the base address while the displacement provides
    an offset (index) from the base address.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: Indexed addressing mode*'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.6.1 Indexed Addressing Mode in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The indexed addressing modes use the following HLA syntax, where VarName is
    the name of some static variable in your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5.6.2 Indexed Addressing Mode in MASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'MASM supports the same syntax as HLA in 32-bit mode, but it also allows several
    variations of this syntax for specifying the indexed addressing mode. The following
    are equivalent formats that demonstrate some of the variations MASM supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the commutative nature of addition, MASM also allows many other combinations.
    It treats two juxtaposed items within brackets as though they were separated by
    the `+` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the MASM equivalents to the previous HLA example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In 64-bit mode, MASM requires that you specify 64-bit register names for the
    indexed addressing mode. In 64-bit mode, the register holds the base address of
    the variable in memory, and the displacement encoded into the instruction provides
    an offset from that base address. This means that you cannot use a register as
    an index into a global array (which would normally use the RIP-relative addressing
    mode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of the valid MASM indexed address modes in 64-bit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5.6.3 Indexed Addressing Mode in Gas**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As with the register indirect addressing mode, Gas uses parentheses rather
    than brackets. Here is the Gas syntax for the indexed addressing mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the Gas equivalents to the HLA instructions given earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In 64-bit mode, Gas requires that you specify 64-bit register names for the
    indexed addressing mode. The same rules apply as for MASM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are examples of the valid Gas indexed address modes in 64-bit mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**3.5.7 Scaled-Index Addressing Modes**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The scaled-index addressing modes are similar to the indexed addressing modes,
    but with two differences. The scaled-index addressing modes allow you to:'
  prefs: []
  type: TYPE_NORMAL
- en: Combine two registers plus a displacement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply the index register by a (scaling) factor of 1, 2, 4, or 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see what makes this possible, consider the following HLA example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The primary difference between the scaled-index addressing mode and the indexed
    addressing mode is the inclusion of the `esi*4` component. This example computes
    the effective address by adding in the value of ESI multiplied by 4 (see [Figure
    3-7](ch03.xhtml#ch3fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-7: Scaled-index addressing mode*'
  prefs: []
  type: TYPE_NORMAL
- en: In 64-bit mode, substitute 64-bit registers for the base and index registers.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.7.1 Scaled-Index Addressing in HLA**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'HLA’s syntax provides several different ways to specify the scaled-index addressing
    mode. Here are the various syntactical forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, BaseReg[32] represents any general-purpose 32-bit register,
    IndexReg[32] represents any general-purpose 32-bit register except ESP, and scale
    must be one of the constants `1`, `2`, `4`, or `8`. VarName represents a static
    variable name and displacement represents a 32-bit constant.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.7.2 Scaled-Index Addressing in MASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: MASM supports the same syntax for these addressing modes as HLA, but with additional
    forms comparable to those presented for the indexed addressing mode. Those forms
    are just syntactical variants based on the commutativity of the `+` operator.
  prefs: []
  type: TYPE_NORMAL
- en: MASM also supports 64-bit scaled-index addressing, which has the same syntax
    as the 32-bit mode except you swap in 64-bit register names. The major difference
    between the 32-bit and 64-bit scaled-index addressing modes is that there is no
    64-bit `disp[reg*index]` addressing mode. On 64-bit addressing modes, this is
    a PC-relative indexed addressing mode, where the displacement is a 32-bit offset
    from the current instruction pointer value.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5.7.3 Scaled-Index Addressing in Gas**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As usual, Gas uses parentheses rather than brackets to surround scaled-index
    operands. Gas also uses a three-operand syntax to specify the *base register*,
    the *index register*, and the *scale factor*, rather than the arithmetic expression
    syntax that the other assemblers employ. The generic syntax for the Gas scaled-index
    addressing mode is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'More specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: where scale is one of the values `1`, `2`, `4`, or `8`.
  prefs: []
  type: TYPE_NORMAL
- en: Gas also supports 64-bit scaled-index addressing. It uses the same syntax as
    the 32-bit mode except you swap in 64-bit register names. When using 64-bit addressing,
    you cannot also specify an RIP-relative variable name (VarName in these examples);
    only a 32-bit displacement is legal.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.6 Declaring Data in Assembly Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The 80x86 architecture provides only a few low-level machine data types on
    which individual machine instructions operate:'
  prefs: []
  type: TYPE_NORMAL
- en: byte Holds arbitrary 8-bit values.
  prefs: []
  type: TYPE_NORMAL
- en: word Holds arbitrary 16-bit values.
  prefs: []
  type: TYPE_NORMAL
- en: dword “Double word”; holds arbitrary 32-bit values.
  prefs: []
  type: TYPE_NORMAL
- en: qword “Quad word”; holds arbitrary 64-bit values.
  prefs: []
  type: TYPE_NORMAL
- en: real32 **(aka** real4**)** Holds 32-bit single-precision floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: real64 **(aka** real8**)** Holds 64-bit double-precision floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*80x86 assemblers typically support tbyte (“ten byte”) and real80/real10 data
    types, but we won’t cover those types here because most modern (64-bit) HLL compilers
    don’t use them. (However, certain C/C++ compilers support real80 values using
    the long double data type; Swift also supports real80 values on Intel machines
    using the float80 type.)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.6.1 Data Declarations in HLA**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The HLA assembler, true to its high-level nature, provides a wide variety of
    single-byte data types including character, signed integer, unsigned integer,
    Boolean, and enumerated types. Were you to write an application in assembly language,
    having all these different data types (along with the type checking that HLA provides)
    would be quite useful. For our purposes, however, we can simply allocate storage
    for byte variables and set aside a block of bytes for larger data structures.
    The HLA `byte` type is all we really need for 8-bit and array objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare `byte` objects in an HLA `static` section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To allocate storage for a block of bytes, you’d use the following HLA syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'These HLA declarations create *uninitialized* variables. Technically speaking,
    HLA always initializes `static` objects with `0`s, so they aren’t truly uninitialized,
    but the main point is that this code does not explicitly initialize these byte
    objects with a value. You can, however, tell HLA to initialize your byte variables
    with a value when the operating system loads the program into memory using statements
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '**3.6.2 Data Declarations in MASM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In MASM, you would normally use the `db` or `byte` directives within a `.data`
    section to reserve storage for a byte object or an array of byte objects. The
    syntax for a single declaration would take one of these equivalent forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding declarations create uninitialized objects (which are actually
    initialized with `0`s, just as with HLA). The `?` in the operand field of the
    `db`/`byte` directive informs the assembler that you don’t want to explicitly
    attach a value to the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a variable that is a block of bytes, you’d use syntax like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To create objects with an initial value other than zero, you could use syntax
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an initialized array of bytes whose values are not all the same,
    you simply specify a comma-delimited list of values in the operand field of the
    MASM `db`/`byte` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '**3.6.3 Data Declarations in Gas**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Gas uses the `.byte` directive in a `.data` section to declare a byte variable.
    The generic form of this directive is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Gas doesn’t provide an explicit format for creating uninitialized variables;
    instead, you just supply a `0` operand for uninitialized variables. Here are two
    actual byte variable declarations in Gas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Gas does not provide an explicit directive for declaring an array of byte objects,
    but you can use the `.rept`/`.endr` directives to create multiple copies of the
    `.byte` directive as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can also supply a comma-delimited list of values if you want to initialize
    the array with different values.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple of array declaration examples in Gas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**3.6.3.1 Accessing Byte Variables in Assembly Language**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When accessing byte variables, you simply use the variable’s declared name
    in one of the 80x86 addressing modes. For example, given a byte object named `byteVar`
    and an array of bytes named `byteArray`, you could use any of the following instructions
    to load that variable into the AL register using the `mov` instruction (these
    examples assume 32-bit code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For 16-bit objects, HLA uses the `word` data type, MASM uses either the `dw`
    or `word` directives, and Gas uses the `.int` directive. Other than the size of
    the object these directives declare, their use is identical to the byte declarations.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'For 32-bit objects, HLA uses the `dword` data type, MASM uses the `dd` or `dword`
    directives, and Gas uses the `.long` directive. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**3.7 Specifying Operand Sizes in Assembly Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '80x86 assemblers use two mechanisms to specify their operand sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: The operands specify the size using type checking (most assemblers do this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions themselves specify the size (Gas does this).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, consider the following three HLA `mov` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In each case, the register operand specifies the size of the data that the
    `mov` instruction copies into that register. MASM uses a similar syntax (though
    the operands are reversed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The takeaway here is that the instruction mnemonic (`mov`) is exactly the same
    in all six cases. The operand, not the instruction mnemonic, specifies the size
    of the data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Modern versions of Gas also allow you to specify the size of the operation
    by operand (register) size without using a suffix such as b or w. This book, however,
    will continue to use mnemonics such as movb or movw to avoid confusion with older
    variants of Gas. “Type Coercion in Gas” on [page 45](ch03.xhtml#page_45).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7.1 Type Coercion in HLA**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one problem with the preceding approach to specifying the operand
    size. Consider the following HLA example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction is ambiguous. The memory location to which EBX points could
    be a byte, a word, or a double word. Nothing in the instruction tells the assembler
    the size of the operand. Faced with an instruction like this, the assembler will
    report an error, and you’ll have to explicitly tell it the size of the memory
    operand. In HLA’s case, this is done with a type coercion operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, you can coerce any memory operand to an appropriate size using
    the following HLA syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: where new_type represents a data type (such as `byte`, `word`, or `dword`) and
    memory represents the memory address whose type you would like to override.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7.2 Type Coercion in MASM**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'MASM suffers from this same problem. You will need to coerce the memory location
    using a coercion operator like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can substitute `byte` or `dword` for `word` in these two examples
    to coerce the memory location to a byte or double word size.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.7.3 Type Coercion in Gas**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Gas doesn’t require type coercion operators, because it uses a different technique
    to specify the size of its operands. Rather than using the single mnemonic `mov`,
    Gas uses four mnemonics consisting of `mov` plus a single-character suffix that
    indicates the size:'
  prefs: []
  type: TYPE_NORMAL
- en: movb Copy an 8-bit (`byte`) value
  prefs: []
  type: TYPE_NORMAL
- en: movw Copy a 16-bit (`word`) value
  prefs: []
  type: TYPE_NORMAL
- en: movl Copy a 32-bit (`long`) value
  prefs: []
  type: TYPE_NORMAL
- en: movq Copy a 64-bit (`long long`) value
  prefs: []
  type: TYPE_NORMAL
- en: 'There is never any ambiguity when you use these mnemonics, even if their operands
    don’t have an explicit size. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: With this basic information, you should now be able to understand the output
    from a typical compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.8 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bartlett, Jonathan. *Programming from the Ground Up*. Edited by Dominick Bruno,
    Jr. Self-published, 2004\. An older, free version of this book, which teaches
    assembly language programming using Gas, can be found online at *[http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf](http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blum, Richard. *Professional Assembly Language*. Indianapolis: Wiley, 2005.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duntemann, Jeff. *Assembly Language Step-by-Step*. 3rd ed. Indianapolis: Wiley,
    2009.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hyde, Randall. *The Art of Assembly Language*. 2nd ed. San Francisco: No Starch
    Press, 2010.'
  prefs: []
  type: TYPE_NORMAL
- en: Intel. “Intel 64 and IA-32 Architectures Software Developer Manuals.” Updated
    November 11, 2019\. *[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*.
  prefs: []
  type: TYPE_NORMAL
