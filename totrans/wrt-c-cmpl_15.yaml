- en: '![](../images/pg294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-28.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FLOATING-POINT
    NUMBERS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your compiler now supports four different integer types, but it still doesn’t
    support non-integral values. It also doesn’t support values outside the range
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. In this chapter, you’ll address these shortcomings by implementing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type. This type
    uses a *floating-point* binary representation, which is totally different from
    the signed and unsigned integer representations we’ve seen so far. The C standard
    also defines two other floating-point types, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>, but we won’t
    implement those in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll have two major tasks in this chapter. The first task is figuring out exactly
    what behavior we’re trying to implement. We can’t just check the C standard, because
    many aspects of floating-point behavior are implementation-defined. Instead, we’ll
    consult yet another standard, *IEEE 754*, to fill in most of the details that
    the C standard doesn’t specify. Our second major task is generating assembly code;
    we’ll need a whole new set of specialized assembly instructions and registers
    to operate on floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a quick look at the IEEE 754 standard, which defines the binary
    format of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and some
    other aspects of floating-point behavior. Then, we’ll consider all the ways that
    rounding error can creep into floating-point operations and decide how our implementation
    will handle them. We won’t cover every aspect of floating-point arithmetic, but
    you can find links to the standard itself and more comprehensive explanations
    of IEEE 754, rounding error, and other aspects of floating-point behavior in “Additional
    Resources” on [page 343](#pg_343).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">IEEE 754, What Is It Good For?</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The IEEE 754 standard specifies several floating-point formats and how to work
    with them. It defines a set of floating-point operations, including basic arithmetic
    operations, conversions, and comparisons. It also defines several rounding modes,
    which control how the results of these operations are rounded, and various floating-point
    exceptions, like overflow and division by zero. The standard can be used as a
    specification for any system that implements floating-point arithmetic, whether
    that system is a processor or a high-level programming language. In processors,
    the required operations are typically implemented as machine instructions. In
    most programming languages, including C, some IEEE 754 operations are implemented
    as primitive operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, while others are implemented
    as standard library functions.
  prefs: []
  type: TYPE_NORMAL
- en: Virtually all modern programming languages represent floating-point numbers
    in IEEE 754 format (because they run on hardware using that format), but they
    have varying degrees of support for other aspects of the standard. For example,
    not all programming languages let you detect floating-point exceptions or use
    nondefault rounding modes.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, you could implement C without using IEEE 754 at all; the C standard
    doesn’t dictate how to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and other floating-point types. However, the standard is designed to be compatible
    with IEEE 754\. Annex F, an optional section of the C standard, specifies how
    to fully support IEEE 754 and explicitly binds C types, operations, and macros
    to their IEEE 754 equivalents. (Note that the standard refers to “IEC 60559,”
    which is just another name for IEEE 754.)
  prefs: []
  type: TYPE_NORMAL
- en: While the C standard doesn’t specify how to represent floating-point types,
    the System V x64 ABI does. Implementations that follow this ABI, including ours,
    must represent these types in IEEE 754 format. However, the ABI doesn’t deal with
    the other aspects of IEEE 754.
  prefs: []
  type: TYPE_NORMAL
- en: Most C implementations provide command line options to control exactly how strictly
    they conform to IEEE 754\. Our compiler won’t provide these options; instead,
    it will roughly match the default behavior of Clang and GCC. This means we’ll
    implement mathematical floating-point operations according to IEEE 754, and we’ll
    correctly handle most special values, but we’ll ignore floating-point exceptions
    and nondefault rounding modes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of sections, I’ll discuss the parts of IEEE 754 that you’ll
    need to know about as you work on your compiler. I won’t discuss operations that
    are implemented in the underlying hardware (like addition and subtraction) or
    in the C standard library (like square root and remainder). You don’t need to
    know the details of how those are specified, since they’re handled for you. But
    you *do* need to know a bit about the binary format of IEEE 754 numbers, so we’ll
    start with that.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The IEEE 754 Double-Precision Format</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The System V x64 ABI tells us to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    using the IEEE 754 *double-precision* format, which is 64 bits wide. [Figure 13-1](#fig13-1)
    illustrates this format. (This figure is reproduced with slight modifications
    from *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The IEEE 754 double-precision
    floating-point format [Description](description-29.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The double-precision floating-point format has three fields: the sign bit,
    the exponent field, and the fraction field. These fields encode three values:
    the sign *s*, the exponent *e*, and the significand *f*, respectively. (Sometimes
    *f* is called the *mantissa* instead of the significand.) A number in this format
    has the value (–1)*^s* × *f* × 2*^e*, except for a few special cases that we’ll
    discuss shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The significand *f* is a *binary fraction*, which is analogous to a decimal
    number. In decimal numbers, the digits to the left of the decimal point (the *integer
    part*) represent nonnegative powers of 10, and the digits to the right (the *fractional
    part*) represent negative powers of 10: 1/10, 1/100, and so on. Similarly, each
    bit in the integer part of a binary fraction represents a nonnegative power of
    2, like 1, 2, 4, or 8, and each bit in the fractional part represents a negative
    power of 2, like 1/2, 1/4, or 1/8.'
  prefs: []
  type: TYPE_NORMAL
- en: The integer part of *f* is always 1; the 52 bits of the fraction field encode
    only the fractional part. This means that the value of *f* is always greater than
    or equal to 1 and less than 2\. For example, the fraction field
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: indicates that the fractional part of *f* is 0.1, so the overall value of *f*
    is the binary fraction 1.1, which is 1.5 in decimal notation. The implied leading
    1 lets the 52-bit fraction field represent binary fractions up to 53 bits long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of *e* is between –1,022 and 1,023\. The exponent field uses a *biased*
    encoding: we interpret the 11 bits in this field as an unsigned integer and then
    subtract 1,023 to get the value of *e*. For example, suppose this field has the
    following bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Interpreted as an ordinary unsigned integer, these bits represent the number
    2\. The value of the exponent *e* is therefore 2 – 1,023, or –1,021\. Setting
    the exponent field to all 1s or all 0s indicates one of the special values we’ll
    discuss in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Since *f* is always positive, the whole floating-point number will be negative
    if the sign bit is 1 and positive if it’s 0\. Essentially, floating point lets
    us express numbers in scientific notation, but with powers of 2 instead of powers
    of 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IEEE 754 standard also defines a few special values that are interpreted
    differently than ordinary floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero and negative zero**'
  prefs: []
  type: TYPE_NORMAL
- en: If a floating-point number is all zeros, its value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>.
    If it’s all zeros except for its sign bit, its value is <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.
    This value compares equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    but follows the usual rules for determining the sign of arithmetic results. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">-1.0 * 0.0</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1.0 * -0.0</samp> both evaluate to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '**Subnormal numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: As we just saw, most floating-point numbers have a significand between 1 and
    2\. We say that these numbers are *normalized*. The smallest magnitude a normalized
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent is 1
    × 2^(–1,022), since the minimum exponent is –1,022\. In a *subnormal* number,
    the significand is smaller than 1, which lets us represent values that are even
    closer to zero. An all-zero exponent field indicates that a number is subnormal,
    so its exponent is –1,022 and the integer part of its significand is 0 instead
    of 1\. Subnormal numbers are much slower to work with in hardware than normalized
    numbers, so some C implementations let users disable them and round any subnormal
    results to zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**Infinity**'
  prefs: []
  type: TYPE_NORMAL
- en: At the opposite end of the spectrum, the largest magnitude a normalized <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent is the largest
    possible value of the significand (just shy of 2) multiplied by 2^(1,023). Anything
    larger gets rounded to infinity. The result of dividing a nonzero number by zero
    is also infinity. The IEEE standard defines both positive and negative infinity;
    for example, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-1.0
    / 0.0</samp> evaluates to negative infinity. A number whose exponent is all 1s
    and whose fraction field is all 0s represents infinity. The sign bit indicates
    whether it’s negative or positive infinity.
  prefs: []
  type: TYPE_NORMAL
- en: '**NaN**'
  prefs: []
  type: TYPE_NORMAL
- en: NaN is short for *not-a-number*. A few operations, including <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0
    / 0.0</samp>, produce NaN. The IEEE 754 standard defines both *signaling NaNs*,
    which raise an exception if you try to use them, and *quiet NaNs*, which don’t.
    A number whose exponent is all 1s and whose fraction field is nonzero represents
    NaN.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll support all of these values except for NaN. Quiet NaNs are an extra credit
    feature because handling them correctly in comparisons requires a bit of extra
    work. We can support negative zero, subnormal numbers, and infinity with no extra
    work on our part; the processor will deal with them for us.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the double-precision format, IEEE 754 defines a few other floating-point
    formats that we won’t use, including *single precision*, which corresponds to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, and *double extended
    precision*, which usually corresponds to <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>. These formats include the same three fields as double precision,
    use the same formula to determine a floating-point number’s value, and have the
    same special values; they just have different widths.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Rounding Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can’t represent every real number exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    There are infinitely many real numbers, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    has only 64 bits. We’re not particularly interested in *all* the real numbers;
    we care only about the numbers that show up in C programs. Unfortunately, a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can’t represent most of
    those exactly either, so we’ll need to round them. Let’s start by examining how
    IEEE 754 tells us to round real numbers to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Then, we’ll look at the three cases where we can encounter rounding error: when
    converting constants from decimal to binary floating point, performing type conversions,
    and performing arithmetic operations.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Modes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: IEEE 754 defines several different rounding modes, including rounding to nearest,
    rounding toward zero, rounding toward positive infinity, and rounding toward negative
    infinity. Modern processors support all four of these rounding modes and provide
    instructions to let programs change the current rounding mode. We’ll support only
    the default IEEE rounding mode, *round-to-nearest, ties-to-even* rounding. As
    the name suggests, in this mode the real value of a result is always rounded to
    the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    “Ties-to-even” means that if a result is exactly between two representable values,
    it’s rounded to the one whose least significant bit is 0\. We’ll use this rounding
    mode when converting constants to floating point, when converting from integer
    types to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and in arithmetic
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Constants</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: C programmers generally write <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constants in decimal. At compile time, we’ll convert constants from this decimal
    representation to a double-precision floating-point representation. This conversion
    is inexact, since most decimal constants can’t be represented exactly in binary
    floating point. For example, you can’t represent the decimal number 0.1 in binary
    floating point, because each bit in a binary fraction represents a power of 2,
    but you can’t add up powers of 2 and get 0.1\. If the source code of a C program
    includes the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">0.1</samp>,
    the compiler will round this constant to the value in [Listing 13-1](chapter13.xhtml#list13-1),
    which is the nearest value we can represent as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: The closest</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    0.1, in decimal notation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike 0.1, this value can be represented exactly as a 53-bit binary fraction
    multiplied by a power of 2, as shown in [Listing 13-2](chapter13.xhtml#list13-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: The closest</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    0.1, represented as a binary fraction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Representing 0.1 as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is analogous to trying to write 1/3 in decimal notation; since you can’t break
    it down into powers of 10, you can’t write it out exactly using any number of
    decimal places. Instead, you have to round 1/3 to the nearest value you can represent
    in the space available. For example, a calculator that can display up to four
    digits would display 1/3 as <samp class="SANS_TheSansMonoCd_W5Regular_11">.3333</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*IEEE 754 defines several* decimal floating-point *formats, which can represent
    decimal constants without this sort of rounding error. These formats encode numbers
    as decimal significands multiplied by powers of 10\. C23 includes new decimal
    floating-point types that correspond to these formats.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Type Conversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We may also need to round when we convert an integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    This issue arises because of the spacing between values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can represent. The gap between representable values grows larger as the magnitude
    of the values themselves increases. At a certain point, the gap becomes larger
    than 1, which means you can’t represent all integers in that range. To illustrate
    this problem, let’s imagine a decimal format with three digits of precision. This
    format can represent any integer smaller than 1,000; for example, we can write
    992 and 993 as 9.92 × 10² and 9.93 × 10². But it can’t represent every integer
    larger than 1,000\. We can represent 1,000 exactly as 1.00 × 10³, but the next
    representable value is 1.01 × 10³, or 1,010; there’s a gap of 10\. The gap increases
    to 100 once we hit 10,000, and continues to grow at larger magnitudes. We’ll encounter
    precisely the same issue when converting from <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. A <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    has 53 bits of precision, since the significand is a 53-bit binary fraction. A
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>, however, has 64 bits of precision. Suppose we need to convert <samp
    class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775803</samp> from a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    The binary representation of this <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That’s 63 bits, so it won’t fit in the significand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>!
    We’ll need to round it to the nearest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    which is <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>,
    or 1 × 2^(63).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Arithmetic
    Operations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we may need to round the results of basic floating-point operations
    like addition, subtraction, and multiplication. Once again, this is due to the
    gaps between representable values. For example, let’s try computing 993 + 45 in
    the three-digit decimal format from the previous section. The correct result,
    1,038, can’t be represented in only three digits; we’ll need to round it to 1.04
    × 10³. Division can also produce values that aren’t representable at any precision,
    just like the result of 1 / 3 isn’t representable in any number of decimal digits.
    Thankfully, we can basically ignore this category of rounding error; the assembly
    instructions for floating-point arithmetic will round correctly without any extra
    effort on our part.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the basics of the IEEE 754 format and the rounding behavior
    you need to implement, you’re ready to get to work on the compiler. We’ll start
    with a change to the compiler driver.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Linking Shared Libraries</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter’s test suite uses functions from <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>,
    the standard math library. We’ll add a new command line option to the compiler
    driver that lets us link in shared libraries like <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>.
    This option takes the form <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><lib></samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><lib></samp>
    is the name of a library. You should pass this option through to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    command to assemble and link the program, placing it after the names of any input
    assembly files in that command. For example, if your compiler is invoked with
    the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'it should assemble and link the program with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you’re on macOS, you don’t need to add this new option, because the standard
    math library is linked in by default. You may want to add it anyway, though, since
    being able to link in shared libraries is generally useful.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll introduce two new tokens in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> A keyword
  prefs: []
  type: TYPE_NORMAL
- en: '**Floating-point constants** Constants that use scientific notation or contain
    a decimal point'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also change how the lexer recognizes the end of a constant token; this
    will affect both the new floating-point constants and the integer constants you
    already support.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by walking through the format of floating-point constants. Then,
    we’ll see how to recognize the end of a constant. Finally, we’ll define the new
    regular expressions for each constant token.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Recognizing Floating-Point
    Constant Tokens</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Numerals with decimal points, like <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.72</samp>, are valid tokens
    that represent floating-point numbers. We’ll call a sequence of digits that includes
    a decimal point a *fractional constant*. A fractional constant may include a decimal
    point with no digits after it. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1.</samp>
    is a valid fractional constant with the same value as <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'A floating-point constant can also be written in scientific notation. A token
    that uses scientific notation consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: A significand, which may be an integer or fractional constant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An uppercase or lowercase <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exponent, which is an integer with an optional leading <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> sign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">100E10</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">.05e-2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">5.E+3</samp> are all valid floating-point
    constants. These constants are all in decimal, and their exponents are powers
    of 10\. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">5.E+3</samp>
    is 5 × 10³, or 5,000\. The C standard also defines hexadecimal floating-point
    constants, but we won’t implement them. There’s no constant for infinity. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp> header defines an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">INFINITY</samp> macro, which is
    supposed to translate to the constant for positive infinity, but our compiler
    can’t include this header, since it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>, and other language
    features we don’t support. Therefore, we won’t support this macro (or any other
    macros defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>,
    for that matter).
  prefs: []
  type: TYPE_NORMAL
- en: It’s a bit tricky to write a regex that will match every floating-point constant,
    so let’s break it down into steps. The regex in [Listing 13-3](chapter13.xhtml#list13-3)
    matches a fractional constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: The regex for
    a fractional constant</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this regex, <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]*\.[0-9]+</samp>,
    matches any constant with digits after the decimal point, like <samp class="SANS_TheSansMonoCd_W5Regular_11">.03</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">3.14</samp>. The part after the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> matches constants like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3.</samp> with nothing after the
    decimal point. [Listing 13-4](chapter13.xhtml#list13-4) defines a similar regex
    to match the significand of a constant in scientific notation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-4: The regex for
    the significand of a constant in scientific notation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference from [Listing 13-3](chapter13.xhtml#list13-3) is that the
    trailing decimal point in the second clause is optional, so it matches both integers
    and fractional constants with trailing decimal points.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the regex in [Listing 13-5](chapter13.xhtml#list13-5) to match the
    exponent part of a floating-point constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-5: The regex for
    the exponent of a constant in scientific notation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This regex includes the case-insensitive <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
    that marks the start of the exponent, an optional sign, and the integer value
    of the exponent. To match any floating-point constant, we’ll assemble one giant
    regex of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><[Listing
    13-4](chapter13.xhtml#list13-4)> <[Listing 13-5](chapter13.xhtml#list13-5)></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><[Listing
    13-3](chapter13.xhtml#list13-3)></samp>, which gives us [Listing 13-6](chapter13.xhtml#list13-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-6: The regex to
    match every part of a floating-point constant</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, a floating-point constant is either a significand followed
    by an exponent, or a fractional constant. [Listing 13-6](chapter13.xhtml#list13-6)
    isn’t quite complete, though: we need one more component to match the boundary
    between the end of this token and the start of the next one.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Matching the End
    of a Constant</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Until now, we’ve required constants to end at word boundaries. Given the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">123foo</samp>, for example, we wouldn’t
    accept the substring <samp class="SANS_TheSansMonoCd_W5Regular_11">123</samp>
    as a constant. Now we’ll add another requirement: a constant token can’t be immediately
    followed by a period. This means, for example, that the lexer will recognize the
    start of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">123L;</samp>
    as a long integer constant token, <samp class="SANS_TheSansMonoCd_W5Regular_11">123L</samp>,
    but it will reject the string <samp class="SANS_TheSansMonoCd_W5Regular_11">123L.bar;</samp>
    as malformed. Along the same lines, the lexer will accept the string <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0+x</samp>
    but reject <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0.+x</samp>, and it
    will accept <samp class="SANS_TheSansMonoCd_W5Regular_11">1.}</samp> but reject
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1..}</samp>. Note that the last
    character in a floating-point constant like <samp class="SANS_TheSansMonoCd_W5Regular_11">1.</samp>
    can be a period, but the first character *after* the constant cannot.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’re curious about where in the C standard this requirement comes from,
    see the definition of preprocessing numbers in section 6.4.8, the list of translation
    phases in section 5.1.1.2, and the discussion of tokens and preprocessing tokens
    in section 6.4, paragraph 3\. These sections describe a multiphase process for
    dividing a source file into preprocessing tokens and then converting them into
    tokens. We don’t follow this process, but we define each token in a way that produces
    the same results for the subset of C that we support.*'
  prefs: []
  type: TYPE_NORMAL
- en: To enforce this new requirement, we’ll end the regular expression for each constant
    token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp> character
    class instead of the special word boundary character <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp> character class
    matches any single character except for a word character (a letter, digit, or
    underscore) or a period. This single non-word, non-period character marks the
    end of the constant but isn’t part of the constant itself, so we’ll define a capture
    group within each regex to match the actual constant.
  prefs: []
  type: TYPE_NORMAL
- en: For example, our old regular expression for a signed integer constant was <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+\b</samp>. Our new regular expression
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)[\w.]</samp>. This regex
    matches the entire string <samp class="SANS_TheSansMonoCd_W5Regular_11">100;</samp>,
    including the <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> at the end.
    The capture group <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)</samp>
    matches just the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>,
    not the final <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> character.
    Whenever your lexer recognizes a constant, it should consume only the constant
    itself from the input, not the character that immediately follows it.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-7](chapter13.xhtml#list13-7), we finally define the whole regular
    expression to recognize a floating-point constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-7: The complete
    regex to recognize a floating-point constant</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This is just the regular expression we defined in [Listing 13-6](chapter13.xhtml#list13-6),
    wrapped in parentheses to form a capture group and followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp>
    character class.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 13-1](chapter13.xhtml#tab13-1) defines the new regular expressions for
    all of our constant tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">Regular
    Expressions for Constant Tokens</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Token</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Regular
    expression</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Signed integer constant</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)[^\w.]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Unsigned integer constant</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+[uU])[^\w.]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Signed long integer constant</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+[lL])[^\w.]</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Unsigned long integer constant</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+([lL][uU]&#124;[uU][lL]))[^\w.]</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Floating-point constant</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(([0-9]*\.[0-9]+&#124;[0-9]+\.?)[Ee][+-]?[0-9]+&#124;[0-9]*\.[0-9]+&#124;[0-9]+\.)[^\w.]</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Go ahead and add the new floating-point constant token and update how you recognize
    the constant tokens from earlier chapters. Don’t forget to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    keyword too!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The changes to the parser are pretty limited. [Listing 13-8](chapter13.xhtml#list13-8)
    gives the updated AST, which includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type and floating-point constants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-8: The abstract
    syntax tree with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">type and floating-point constants</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Your AST should represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constants using the double-precision floating-point format, since that’s how they’ll
    be represented at runtime. You’ll need to look up which type in your implementation
    language uses this format. If you use a representation with less precision than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, you might not be
    able to represent the closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to every constant in the source code, so you’ll end up with incorrectly rounded
    constants in the compiled program.
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, storing constants with *more* precision than <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can also cause problems. Storing a floating-point number in a higher-precision
    format and then rounding to a lower-precision format can produce a different result
    than rounding exactly once. This phenomenon is called *double rounding error*.
    (The word *double* here refers to rounding twice, not to the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type.) We’ll explore double rounding error in more depth during assembly generation.
  prefs: []
  type: TYPE_NORMAL
- en: After updating the AST, we’ll make the corresponding changes to the grammar.
    [Listing 13-9](chapter13.xhtml#list13-9) shows the complete grammar with these
    changes bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-9: The grammar with
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">type specifier and floating-point constants</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last two chapters, we had to deal with the many different ways to specify
    integer types. Luckily, there’s only one way to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type: with the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> keyword.
    [Listing 13-10](chapter13.xhtml#list13-10) demonstrates how to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    when we process a list of type specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-10: Determining
    a type from a list of type specifiers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Either <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> should be
    the only specifier in the list, or it shouldn’t appear at all; it can’t be combined
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>,
    or any other type specifier we’ve introduced so far. (It can, however, appear
    alongside storage-class specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll convert floating-point constant tokens to constants in the AST.
    We saw earlier that most decimal constants can’t be represented exactly in binary
    floating point, so we’ll need to round them. According to the C standard, the
    rounding direction here is implementation-defined and doesn’t necessarily need
    to match the runtime rounding mode. We’ll use round-to-nearest mode here, like
    we do everywhere else. Your implementation language’s built-in string-to-floating
    point conversion utilities should handle this correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When we parse integer constants, we need to ensure that they’re within the range
    the type can hold. Floating-point constants, however, can’t go out of range. Since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> supports positive
    and negative infinity, its range includes all real numbers. So, our parser shouldn’t
    run into any errors when parsing <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constants.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll make a handful of changes to account for <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    in the type checker. First, we’ll make sure to annotate <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constants with the correct type. Then, we’ll update how we find the common real
    type of two values. The rule here is simple: if either value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the common real type is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    [Listing 13-11](chapter13.xhtml#list13-11) shows how to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>
    helper function to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-11: Finding the
    common real type of two values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to detect a couple of new type errors. The bitwise complement operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>, and the remainder operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>, accept only integer operands.
    We’ll validate that both of these operators are used correctly in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>.
    [Listing 13-12](chapter13.xhtml#list13-12) demonstrates how to type check the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-12: Type checking
    a bitwise complement expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we type check the operand. Then, we validate that the operand is an integer
    ❶. Finally, we annotate the expression with the type of its result. Only the validation
    step differs from earlier chapters. We can handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operator in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap up the changes to the type checker, we’ll deal with static variables
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. We’ll add
    a new kind of initializer for these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we’ll convert each initializer to the type of the variable it initializes,
    using the same rules that we’d apply at runtime. The C standard requires us to
    truncate toward zero when we convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an integer type. For example, we would convert <samp class="SANS_TheSansMonoCd_W5Regular_11">2.8</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. If the truncated value
    is out of range of the resulting integer type, the result is undefined, so you
    can handle it however you like. The cleanest option here is to just throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: When we convert an integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    we’ll preserve its value if it can be represented exactly. Otherwise, we’ll round
    to the nearest representable value. You should be able to use your implementation
    language’s built-in type conversion utilities to cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to integer types and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In TACKY, we’ll add a few new instructions to handle conversions between <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and integer types. [Listing
    13-13](chapter13.xhtml#list13-13) gives the updated TACKY IR.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-13: Adding conversions
    between</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">and the integer types to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-13](chapter13.xhtml#list13-13) introduces four new instructions
    to convert between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the signed and unsigned integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>. We don’t
    have different instructions for integer operands of different sizes; for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp> can cast to either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: To update the TACKY generation pass, just emit the appropriate cast instruction
    when you encounter a cast to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Floating-Point Operations in Assembly</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we get to work on the assembly generation pass, we need to understand
    how to work with floating-point numbers in assembly. Because floating-point numbers
    use a completely different binary representation from signed and unsigned integers,
    we can’t operate on them with our existing arithmetic instructions. Instead, we’ll
    use a set of specialized instructions called the *Streaming SIMD Extension (SSE)*
    instructions. This instruction set includes operations on both floating-point
    values and integers. It gets its name because it includes *single-instruction,
    multiple data (SIMD)* instructions, which perform the same operation on a vector
    of several values simultaneously (or two vectors of values, in the case of binary
    operations). For example, a SIMD addition instruction whose operands were the
    two-element vectors <samp class="SANS_TheSansMonoCd_W5Regular_11">[1.0, 2.0]</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">[4.0, 6.0]</samp> would add
    their corresponding elements together to produce the vector <samp class="SANS_TheSansMonoCd_W5Regular_11">[5.0,
    8.0]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The term *SSE* is a bit misleading because only some SSE instructions perform
    SIMD operations on vectors. Others operate on single values. When we talk about
    SSE instructions, we refer to vectors as *packed* operands and single values as
    *scalar* operands. SSE instructions that use these different types of operands
    are called packed and scalar instructions, respectively. Our implementation will
    primarily use scalar instructions, although we will need one packed instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The SSE instructions were first introduced as an extension to the x86 instruction
    set; they weren’t available on every x86 processor. Over time, new groups of SSE
    instructions were added, creatively named SSE2, SSE3, and SSE4\. The SSE and SSE2
    instructions were eventually incorporated into the core x64 instruction set, so
    they’re available on every x64 processor. The first generation of floating-point
    SSE instructions support only single-precision operands, which correspond to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> type in C. SSE2 added
    support for double-precision operands. Since we’re working with double-precision
    operands, we’ll use only SSE2 instructions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The x64 and x86 instruction sets include an older set of floating-point instructions
    that were first introduced with the Intel 8087* floating-point unit (FPU)*, a
    separate processor that handled floating-point math. These are called* x87 *or*
    FPU instructions *(sometimes simply referred to as* floating-point instructions*).
    Be aware that some resources on floating-point assembly—particularly older ones—discuss
    only x87 instructions and don’t mention SSE.*'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the general-purpose instructions we’re already familiar with, SSE
    instructions take suffixes that describe their operands. Instructions that operate
    on scalar double-precision values use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp>
    suffix. Instructions that take packed double-precision values use the <samp class="SANS_TheSansMonoCd_W5Regular_11">pd</samp>
    suffix. Scalar and packed single-precision instructions use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ps</samp> suffixes, respectively.
    The next few sections introduce the SSE instructions we’ll need in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with SSE
    Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two major differences between SSE instructions and the assembly instructions
    you learned about in earlier chapters. The first difference is that SSE instructions
    use a separate set of registers, called the *XMM registers*. There are 16 XMM
    registers: XMM0, XMM1, and so on, up to XMM15\. Each XMM register is 128 bits
    wide, but we’ll use only their lower 64 bits. From now on, I’ll refer to all the
    non-XMM registers we know and love—like RAX, RSP, and so on—as *general-purpose
    registers*. SSE instructions can’t use general-purpose registers, and non-SSE
    instructions can’t use XMM registers. Both SSE and non-SSE instructions can refer
    to values in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is that SSE instructions can’t use immediate operands.
    If we need to use a constant in an SSE instruction, we’ll define that constant
    in read-only memory. Then, the constant can be accessed with RIP-relative addressing,
    just like a static variable. [Listing 13-14](chapter13.xhtml#list13-14), which
    computes <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> in assembly, illustrates
    how to use XMM registers and floating-point constants.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-14: Computing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">1.0 + 1.0</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the listing, we define the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
    We can define and initialize this constant in almost exactly the same way as a
    static variable. The key difference is that we don’t store this value in the data
    or BSS section; instead, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.section
    .rodata</samp> directive to put it in the *read-only data section*. As the name
    suggests, the program can read data from this section at runtime, but it can’t
    write to it.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">.section</samp> directive
    can be used to write to any section. We use it here because we don’t have a dedicated
    directive to write to the read-only data section the way we have dedicated <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.text</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> directives. In
    the object file format used on macOS, there are several read-only data sections;
    we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> directive
    to write to the section that holds 8-byte constants.
  prefs: []
  type: TYPE_NORMAL
- en: We use a new directive, <samp class="SANS_TheSansMonoCd_W5Regular_11">.double</samp>,
    to initialize the memory address labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp>
    to the floating-point value <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> prefix on <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp>
    makes it a local label. As you learned back in [Chapter 4](chapter4.xhtml), local
    labels are omitted from the symbol table in the object file. Compilers typically
    use local labels for floating-point constants.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined the data we need, let’s look at the start of the assembly
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">one_plus_one</samp>. The
    first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd .L_one(%rip),
    %xmm0</samp>, copies the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>
    from memory into the XMM0 register. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    instruction, like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, copies
    data from one location to another. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    to copy values between XMM registers or between an XMM register and memory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    instruction to perform floating-point addition. This instruction adds the constant
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp> to the value in
    XMM0 and stores the result in XMM0\. The source of <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    can be an XMM register or a memory address, and the destination must be an XMM
    register.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a high-level understanding of how to use SSE instructions,
    let’s dig into some specifics. First, we’ll explore how the System V calling convention
    handles floating-point function arguments and return values. Then, we’ll cover
    how individual floating-point operations, like arithmetic, comparisons, and type
    conversions, are implemented in assembly. At that point, you’ll finally be ready
    to add floating-point support to the backend of your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Floating-Point
    Values in the System V Calling Convention</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapter 9](chapter9.xhtml), you learned that a function’s first six arguments
    are passed in general-purpose registers and its return value is passed in the
    EAX register (or RAX, depending on its size). The System V calling convention
    handles floating-point values a bit differently: they’re passed and returned in
    XMM registers instead of general-purpose registers.'
  prefs: []
  type: TYPE_NORMAL
- en: A function’s first eight floating-point arguments are passed in registers XMM0
    through XMM7\. Any remaining floating-point arguments are pushed onto the stack
    in reverse order, just like integer arguments are. Floating-point return values
    are passed in XMM0 instead of RAX. Consider the function in [Listing 13-15](chapter13.xhtml#list13-15),
    which takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> arguments,
    adds them together, and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-15: Adding two</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">arguments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We could compile this function to the assembly in [Listing 13-16](chapter13.xhtml#list13-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-16:</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">add_double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: According to the System V calling convention, arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> will be passed in registers
    XMM0 and XMM1, respectively. The instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd
    %xmm1, %xmm0</samp> will therefore add <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, storing the result
    in XMM0\. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values
    are returned in XMM0, the function’s return value is already in the right place
    after that <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> instruction.
    At that point, the function can return immediately. This code is more optimized
    than what your compiler will produce—it doesn’t include the function prologue
    and epilogue, for example—but it illustrates how to pass and return floating-point
    values in assembly.
  prefs: []
  type: TYPE_NORMAL
- en: When a function contains a mix of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and integer arguments, it can be tricky to push the right arguments onto the stack
    in the right order. First, we need to assign parameters to registers, working
    from the start of the parameter list. Then, we push any remaining unassigned parameters
    of any type onto the stack, starting from the back of the parameter list. Let’s
    work through a few examples, starting with [Listing 13-17](chapter13.xhtml#list13-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-17: A function declaration
    with integer and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This example is simple because we can pass every parameter in a register. [Figure
    13-2](#fig13-2) illustrates the state of each register just before invoking <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pass_parameters_1</samp> with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: Passing parameters
    from [Listing 13-17](chapter13.xhtml#list13-17) [Description](description-30.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-18](chapter13.xhtml#list13-18) shows a slightly more complicated
    example, where some integer parameters are passed on the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-18: A function declaration
    with even more parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll pass every <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    argument to this function in a register, but the last two integer arguments, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>,
    will be passed on the stack. [Figure 13-3](#fig13-3) illustrates where each parameter
    will wind up.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: Passing parameters
    from [Listing 13-18](chapter13.xhtml#list13-18) [Description](description-31.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve assigned parameters to all the available registers, only <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp> are left. Because
    we push stack arguments in reverse order, we push <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>
    first, then <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>, which puts
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> at the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s consider the function declared in [Listing 13-19](chapter13.xhtml#list13-19).
    When we call this function, we’ll need to pass both <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and integer parameters on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-19: A function declaration
    with way too many parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll pass the first six integer parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">i1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">i6</samp>, and the first
    eight <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameters,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">d1</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">d8</samp>,
    in registers. [Listing 13-20](chapter13.xhtml#list13-20) reproduces [Listing 13-19](chapter13.xhtml#list13-19),
    with parameters that will be passed on the stack bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-20: The declaration
    of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">pass_parameters_3</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, with parameters passed on the stack
    bolded</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Going in reverse order, we’ll push <samp class="SANS_TheSansMonoCd_W5Regular_11">i9</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">d11</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">d10</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">d9</samp>. [Figure 13-4](#fig13-4)
    illustrates where we’ll put each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: Passing parameters
    from [Listing 13-19](chapter13.xhtml#list13-19) [Description](description-32.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how our calling convention handles floating-point values,
    let’s look at basic arithmetic and comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Doing Arithmetic
    with SSE Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to support five arithmetic operations on floating-point numbers: addition,
    subtraction, multiplication, division, and negation. We’ve already seen an example
    of addition with the <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    instruction. There are equivalent SSE instructions for the other binary operations:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp> for subtraction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp> for multiplication, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp> for division. All four of
    these SSE instructions follow the same pattern as the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>
    instructions: take a source and destination operand, use them in a binary operation,
    and store the result in the destination. These four floating-point instructions
    all require an XMM register or memory address as a source and an XMM register
    as a destination. Floating-point division follows the same pattern as the other
    arithmetic instructions; it doesn’t require special handling like integer division
    does.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no floating-point negation instruction. To negate a floating-point value,
    we’ll XOR it with <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>, which
    has its sign bit set but is otherwise all zeros. This has the effect of flipping
    the value’s sign bit, which negates it. This operation correctly negates normal
    numbers, subnormal numbers, positive and negative zero, and positive and negative
    infinity.
  prefs: []
  type: TYPE_NORMAL
- en: The only complication is that there’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">xorsd</samp>
    instruction to XOR two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s.
    Instead, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    instruction, which XORs two packed vectors of two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s
    each. Each operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    is 16 bytes wide; the lower 8 bytes hold the first element of the vector and the
    upper 8 bytes hold the second. We’ll use the lower 8 bytes of each operand and
    ignore the upper bytes. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    and the other arithmetic floating-point instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    takes an XMM register or memory address as a source operand and an XMM register
    as a destination. Unlike those other instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    only accepts memory addresses that are 16-byte aligned; using a misaligned source
    operand causes a runtime exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to negate the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>, then store the
    result in <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>. First,
    we define the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align 16</samp> directive
    to ensure that this constant is 16-byte aligned. Next, we XOR it with our source
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> instruction
    moves the source value into the lower 8 bytes of XMM0, zeroing out the upper 8
    bytes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction
    XORs the lower 8 bytes of XMM0 with the 8-byte value at <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_negative.zero</samp>,
    which is <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. It simultaneously
    XORs the upper 8 bytes of XMM0 with 8 bytes of whatever happens to immediately
    follow <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> in memory. After
    this instruction, the lower bytes of XMM0 hold our negated value, and the upper
    8 bytes hold junk. The final <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    instruction copies the lower bytes of XMM0 to their final destination at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> to
    zero out registers. Because the result of XORing any number with itself is 0,
    an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd %xmm0,
    %xmm0</samp> is the easiest way to zero out a floating-point register.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The XOR trick works for general-purpose registers too; for example, xorq %rax,
    %rax will zero out RAX. In fact, most compilers zero out both floating-point and
    general-purpose registers this way because it’s slightly faster than using a mov
    instruction. Since we’re prioritizing clarity and simplicity over performance,
    we use mov instead of xor to zero out general-purpose registers. But for XMM registers,
    zeroing with xor is the simpler option.*'
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparing Floating-Point
    Numbers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll compare floating-point values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    instruction, which works similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>.
    Executing <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd b, a</samp> sets
    ZF to 1 if the values are equal and 0 otherwise. It sets CF to 1 if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and 0 otherwise.
    These are the same flags that characterize the result of an unsigned comparison.
    Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    instruction always sets SF and OF to 0\. We’ll therefore use the same condition
    codes for floating-point comparisons that we use for unsigned comparisons: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction
    handles subnormal numbers, infinity, and negative zero correctly without any special
    effort on our part. It treats <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> as equal, like the
    IEEE 754 standard requires. Handling NaN, which is an extra credit feature in
    this chapter, *does* require special effort. When either operand is NaN, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> reports an *unordered* result,
    which we can’t detect with the condition codes we’ve learned about so far. For
    more details, see “Extra Credit: NaN” on [page 342](#pg_342).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    Floating-Point and Integer Types</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Listing 13-13](chapter13.xhtml#list13-13), we defined TACKY instructions
    for four different type conversions: <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>. The SSE
    instruction set includes conversions to and from signed integer types, so implementing
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>
    is easy. It doesn’t include conversions to and from unsigned integer types, so
    implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> takes a
    little ingenuity. There’s more than one way to implement these trickier conversions;
    we’ll implement them roughly the same way that GCC does.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through these four conversions one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a double to a Signed
    Integer</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> instruction
    converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to a signed
    integer. It truncates its source operand toward zero, which is what the C standard
    requires for conversions from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to integer types. This instruction takes a suffix that indicates the size of the
    result: <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2sil</samp> converts
    the source value to a 32-bit integer, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    converts it to a 64-bit integer.'
  prefs: []
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent
    a much wider range of values than either <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, the source of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> might be outside the
    range of the destination type. In that case, the instruction results in the special
    *indefinite integer* value, which is the minimum integer the destination type
    supports. It also sets a status flag indicating that the operation was invalid.
    Converting a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to an
    integer type is undefined behavior when it’s outside the range of that type, so
    we’re free to handle this case however we want. We’ll just use the indefinite
    integer as the result of the conversion and ignore the status flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more user-friendly compiler might check the status flag and raise a runtime
    error when a conversion is out of range, instead of silently returning a bogus
    result. It might do the same for the conversions from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to the unsigned integer types, which we’ll consider next. Our approach makes it
    easy for C programmers to shoot themselves in the foot, but at least we’re in
    good company: by default, GCC and Clang handle out-of-range conversions the same
    way we do.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a double to an
    Unsigned Integer</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It’s not always possible to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an unsigned integer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp>
    instruction. We’ll run into trouble when the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is in the range of an unsigned integer type but outside the range of the corresponding
    signed type. Consider the following C cast expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This should evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp>,
    which is a perfectly valid <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. But if we try to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290.0</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2sil</samp> instruction,
    it will produce the indefinite integer instead of the right answer, because that
    value is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>. There’s no SSE instruction to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an unsigned integer, either. We’ll need to be a bit clever to work around these
    limitations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A newer instruction set extension called* AVX *does include conversions from
    double to unsigned integer types, but not all x64 processors support this extension.*'
  prefs: []
  type: TYPE_NORMAL
- en: To convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, we’ll first
    convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>
    and then truncate the result. For example, to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    in XMM0 to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    and then store it on the stack, we can use the assembly in [Listing 13-21](chapter13.xhtml#list13-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-21: Converting a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned int</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Any value in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> is also in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    will handle it correctly. If the value is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>, the behavior is undefined, so we don’t care what the result will be.
  prefs: []
  type: TYPE_NORMAL
- en: Converting from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> is trickier.
    First, we’ll check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    we want to convert is in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp>. If it is, we can convert it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    instruction. If it’s not, we’ll subtract the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    from our <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to get a
    result in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>.
    We’ll convert that result to an integer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    instruction, then add <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    again after the conversion. [Listing 13-22](chapter13.xhtml#list13-22) demonstrates
    how we might convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    stored in XMM0 to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>
    in RAX.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-22: Converting a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned long</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We define a constant <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    or 2^(63) ❶. To perform the conversion, we first check whether the value in XMM0
    is below this constant ❷. If it is, we can convert it to an integer with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> instruction ❸, then
    jump over the instructions for the other case.
  prefs: []
  type: TYPE_NORMAL
- en: If XMM0 is greater than the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>
    constant, it’s too large for <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    to convert. To handle this case, we jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_out_of_range</samp>
    label. We first copy the source value into XMM1 to avoid overwriting the original
    value, then subtract <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>
    from it ❹. If the original value was within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>, the new value will be within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
    Therefore, we can convert XMM1 to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    instruction. (If the original value wasn’t within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>, the behavior is undefined according to the C standard and <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    will result in the indefinite integer.) At this point, the value in RAX is exactly
    2^(63) (or 9,223,372,036,854,775,808) less than the correct answer, so we add
    <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808</samp> to get
    the final result.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-22](chapter13.xhtml#list13-22) includes a decimal value, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>, which the assembler
    will convert to a double-precision floating-point number. It also includes floating-point
    subtraction. We know that both of these operations can potentially introduce rounding
    error. Could this rounding error lead to an incorrect result?'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, it won’t. We can prove that [Listing 13-22](chapter13.xhtml#list13-22)
    won’t require any rounding at all. First of all, <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>
    can be represented exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    where the significand is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    and the exponent is <samp class="SANS_TheSansMonoCd_W5Regular_11">63</samp>. (That’s
    why we use this constant instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>,
    which <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> cannot represent
    exactly.) A <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can also
    represent the exact result of <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd
    .L_upper_bound(%rip), %xmm0</samp> in every case we care about. Specifically,
    we care about the cases where the source value is greater than or equal to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>, which is
    2^(63), but not greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX</samp>,
    which is 2^(64) – 1\. That means we can write this value as 1.*x* × 2^(63), for
    some sequence of bits *x*. Because a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    has 53 bits of precision, *x* can’t be more than 52 bits long. When we subtract
    1 × 2^(63) from the source value, the result will be exactly *x* × 2^(62), which
    requires at most 52 bits of precision to represent exactly. (This is a special
    case of the *Sterbenz lemma*, in case you want to look it up.)
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this subtraction will give us an exact result, and adding <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808</samp>
    to that result after converting it to an integer will give us an exact final answer.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a Signed Integer
    to a double</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction
    converts a signed integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    You write it with an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> suffix, depending on whether
    the source operand is a 32-bit or 64-bit integer. If the result can’t be represented
    exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, it will
    be rounded according to the CPU’s current rounding mode, which we can assume is
    round-to-nearest.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting an Unsigned Integer
    to a double</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction
    interprets its source operand as a two’s complement value, meaning any value with
    its upper bit set gets converted to a negative <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Unfortunately, there’s no unsigned equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp>
    that we can use instead. We’re back in a similar situation to the previous section
    on unsigned integers, so we’ll rely on similar techniques.
  prefs: []
  type: TYPE_NORMAL
- en: To convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we can zero
    extend it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and then
    convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>. [Listing 13-23](chapter13.xhtml#list13-23)
    illustrates how we can use this approach to convert the unsigned integer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-23: Converting an</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that a <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction
    moves a value into a register’s lower 32 bits and zeroes out its upper 32 bits.
    The first instruction in this listing effectively moves and zero extends <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp> into the RAX register.
    This zero-extended number has the same value whether we interpret it as signed
    or unsigned, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    instruction will convert it correctly, storing the floating-point value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4294967290.0</samp> in XMM0.
  prefs: []
  type: TYPE_NORMAL
- en: That leaves the conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. To
    handle this case, we’ll first check whether the value is in the range that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp> can represent. If it
    is, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    directly. Otherwise, we’ll halve the source value to bring it into the range of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>, convert it with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>, and then double
    the result of the conversion. A naive attempt to perform this conversion in assembly
    might look like [Listing 13-24](chapter13.xhtml#list13-24).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-24: Incorrectly
    converting an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned
    long</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We first check whether the source value, at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>,
    is out of bounds by performing a signed comparison to zero ❶. If the signed value
    is greater than or equal to zero, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    directly ❷ and then jump over the instructions for the out-of-range case.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_out_of_range</samp>
    label. We copy the source value into RAX, then halve it by shifting it 1 bit to
    the right with the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    instruction ❸. (The mnemonic <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>
    is short for *shift right*.) Next, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    to convert the halved value to the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Finally, we add the result to itself, producing the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    representation of the original value (or at least the closest value that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent exactly).
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s a problem with this code: the result won’t always be correctly
    rounded. When we halve an integer with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>,
    we round down; halving <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>,
    for example, gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> as
    the result. If this rounded-down integer happens to be at the exact midpoint between
    two consecutive values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can represent, <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    might round down again, even though the original integer was closer to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> above it than the one below
    it. We’ve hit a double rounding error!'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through a concrete example. (To make this example more readable,
    I’ll bold the digits that differ between large numbers that are near each other.)
    We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    according to [Listing 13-24](chapter13.xhtml#list13-24). The closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values to our source operand are <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">5808.0</samp>, which is 1,025 less than
    the source value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">7856.0</samp>, which is 1,023 more than
    it. We should convert the source value to the higher <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    since it’s closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Halving the source value with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">8416</samp>. This integer is exactly at
    the midpoint between two adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values: <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">7904.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">8928.0</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Written out as a binary fraction, the lower value is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'and the higher one is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This notation shows us the significands of both values, written out with the
    full available precision. Since we round ties to even, we pick the value with
    a 0 in the least significant bit of the significand. In this particular example,
    that means rounding down, so <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp>
    produces the lower <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7904.0</samp>.
    We then add that to itself, which gives us a final answer of <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">5808.0</samp>. Instead of getting the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> just above our initial value,
    which was the correctly rounded result, we got the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    just below it. [Figure 13-5](#fig13-5) illustrates how double rounding here leads
    to an incorrect result. (To reduce the size of the figure, we only show the first
    and last few digits of each number.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: A double rounding
    error when converting from an unsigned long to a double [Description](description-33.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The dotted arrow shows the correct rounding of <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/
    2</samp> to the nearest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    The two solid lines demonstrate the actual result of double rounding.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this error, we need to make sure that when we halve the initial value,
    we don’t round the result to a midpoint between two values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can represent. We’ll do this with a technique called *rounding to odd*. When we
    halve the source value, we won’t truncate it toward zero. Instead, we’ll round
    to the nearest odd number. Using this rounding rule, we’ll round <samp class="SANS_TheSansMonoCd_W5Regular_11">9
    / 2</samp> up to <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> instead
    of down to <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. Similarly,
    we’ll round <samp class="SANS_TheSansMonoCd_W5Regular_11">7 / 2</samp> down to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, and we’ll round <samp
    class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/ 2</samp> up to <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">8417</samp>. If the result of dividing
    by 2 is already an integer, we don’t need to round; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">16
    / 2</samp> will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.
    (Only the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    needs to be rounded to odd; <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    will still round to nearest.)
  prefs: []
  type: TYPE_NORMAL
- en: Rounding to odd works in this situation because the midpoints we want to avoid
    are always even integers. The gaps between binary floating-point numbers are always
    powers of 2, and they get bigger at larger magnitudes. Remember that we halve
    an integer for this conversion only if it’s too big to fit in a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
    The halved value will therefore be between <samp class="SANS_TheSansMonoCd_W5Regular_11">(LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1)
    / 2</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX / 2</samp>.
    In that range, the gap between representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values is 1,024, so every midpoint is a multiple of 512, which is even.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-6](#fig13-6) illustrates a few different cases of rounding to odd
    in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig13-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: Using rounding
    to odd to avoid a double rounding error [Description](description-34.xhtml)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, rounding to odd prevents us from rounding to a midpoint and
    then down to an incorrect result. In the remaining cases, it doesn’t change the
    final result; whether we round these cases to odd or toward zero on the first
    rounding, we’ll get the same answer as if we’d rounded only once using round-to-nearest,
    ties-to-even mode. Sometimes rounding to odd is necessary to get the right answer,
    and sometimes it has no impact, but it never gives us the wrong answer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand why rounding to odd works, let’s figure out how to implement
    it in assembly. [Listing 13-25](chapter13.xhtml#list13-25) demonstrates how to
    halve the value stored in RAX and round the result to odd.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-25: Rounding to
    odd after halving an integer with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">shrq</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing includes two new instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>. If you did the extra
    credit section in [Chapter 3](chapter3.xhtml), you’re already familiar with them.
    These instructions perform bitwise AND and OR operations, respectively; they’re
    used exactly like our other instructions that perform binary operations on integers,
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s figure out why this code works. First, we copy the value we want to halve
    into RDX and halve it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>.
    Next, we take the bitwise AND of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    and the original value in RAX; this produces <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    if the original value was odd and <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    if it was even.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to decide what to do about the halved value in RDX. At this point,
    one of three things is true:'
  prefs: []
  type: TYPE_NORMAL
- en: The original value was even, so RDX contains the exact result of halving that
    value. Therefore, we don’t need to round it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original value was odd, and the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    is also odd. For example, if the original value was <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>,
    halving it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> will
    produce <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. In this case,
    the result is already rounded to odd and doesn’t need to change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original value was odd, and the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    is even. For example, if the original value was <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>,
    halving it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> will
    produce <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. In this case,
    the result is not rounded to odd, and we need to increment it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In each of these three cases, the final instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">orq
    %rax, %rdx</samp>, has the desired effect. In the first case, it does nothing
    because RAX is 0, thanks to the prior <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    instruction. In the second case, it does nothing because the least significant
    bit of RDX is already 1\. In the third case, it flips the least significant bit
    of RDX from 0 to 1 and makes the value odd.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together, [Listing 13-26](chapter13.xhtml#list13-26) shows the
    complete assembly to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to a correctly rounded <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-26: Correctly converting
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned long</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is identical to the original conversion in [Listing 13-24](chapter13.xhtml#list13-24),
    except for the bolded changes: we round the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    to odd and use the rounded value in RDX as the source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now discussed how to implement every floating-point operation we need;
    we’re ready to update the assembly generation pass!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, our first task is to update the assembly AST. We’ll add a new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> assembly type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also add a new top-level construct to represent floating-point constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This construct is almost identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>.
    The one difference is that we can omit the <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp>
    attribute, since we’ll never define global constants. For now, we’ll define only
    floating-point constants; in later chapters, we’ll use this construct to define
    constants of other types as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll add two new instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvtsi2sd</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Each of these takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp>
    parameter to specify whether it operates on <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll reuse the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions to
    represent floating-point comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    and arithmetic with <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>, and so on. We’ll add
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">DivDouble</samp> binary operator
    to represent floating-point division. (Recall that the assembly AST doesn’t include
    a binary operator for integer division because <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> don’t follow the
    same pattern as the other arithmetic instructions.) We’ll also add the <samp class="SANS_TheSansMonoCd_W5Regular_11">Xor</samp>
    binary operator we need to negate floating-point values, as well as the bitwise
    <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp>
    operators we need to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We need the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp>
    operator for that type conversion too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll add the XMM registers. We’ll need XMM0 through XMM7 for parameter
    passing, plus a couple more scratch registers for instruction rewrites. You can
    use any registers apart from XMM0 through XMM7 for scratch; I’ll use XMM14 and
    XMM15\. You can either add all 16 registers to the AST or just add the ones we
    need right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 13-27](chapter13.xhtml#list13-27) gives the entire assembly AST, with
    changes bolded.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-27: The assembly
    AST with floating-point constants, instructions, and registers</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We already understand how to perform floating-point operations in assembly,
    but there are a few implementation details we still need to discuss. We’ll deal
    with constants first.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point
    Constants</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous chapters, we converted integer constants in TACKY to <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp>
    operands in assembly. This approach won’t work for floating-point constants. Instead,
    when we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constant in TACKY, we’ll generate a new top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    construct with a unique identifier. To use that constant in an instruction, we
    refer to it with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand,
    just like a static variable. For example, suppose we need to convert the following
    TACKY instruction to assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we’ll generate a unique label, <samp class="SANS_TheSansMonoCd_W5Regular_11">const_label</samp>,
    that won’t conflict with any of the names in the symbol table or any of the internal
    labels we use as jump targets. Then, we’ll define a new top-level constant like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This top-level constant must be 8-byte aligned to conform to the System V ABI.
    After defining this constant, we’ll emit the following assembly instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Keep track of every <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    you define throughout the entire assembly generation pass. Then, at the end of
    this pass, add these constants to your list of top-level constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from constant handling, this example demonstrates a few things about assembly
    generation that won’t change. First, we’ll still convert the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    in assembly, whether we’re copying an integer or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Second, TACKY variables are still converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operands, regardless of their type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of optional tweaks you can make here to bring your top-level
    constants more in line with what a production compiler would generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoiding duplicate constants**'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t generate multiple equivalent <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    constructs. Instead, whenever you see a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constant in TACKY, check whether you’ve already generated a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    with the same value and alignment. If you have, refer to that constant in your
    assembly code instead of generating a new one. Just keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> are distinct constants
    that require separate <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    constructs, even though they compare equal in most languages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using local labels for top-level constants**'
  prefs: []
  type: TYPE_NORMAL
- en: Compilers typically use local labels starting with <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>
    (on macOS) or <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> (on Linux)
    for floating-point constants, so they don’t show up as symbols in the final executable.
    (Recall that we already use local labels for jump targets.) If you want to follow
    this naming convention, don’t add the local label prefix just yet; wait until
    the code emission pass. For now, add top-level constants to the backend symbol
    table and use a new attribute to distinguish them from variables. [Listing 13-28](chapter13.xhtml#list13-28)
    shows how to update the original backend symbol table entry from [Listing 11-26](chapter11.xhtml#list11-26)
    to include this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-28: Definition of
    an entry in the backend symbol table, including the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is_constant</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">attribute</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: During code emission, we’ll use this new attribute to figure out which operands
    should get a local label prefix. The <samp class="SANS_TheSansMonoCd_W5Regular_11">is_static</samp>
    attribute should also be true for constants, since we store them in the read-only
    data section and access them with RIP-relative addressing. We’re waiting until
    code emission to add local labels instead of generating them right off the bat
    because it will be easier to extend this approach when we add more kinds of top-level
    constants in [Chapter 16](chapter16.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to make both of these tweaks, skip both of them, or make one but not
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unary Instructions,
    Binary Instructions, and Conditional Jumps</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll convert floating-point addition, subtraction, and multiplication instructions
    from TACKY to assembly just like their integer equivalents. Floating-point division
    will follow the same pattern as these other instructions, even though integer
    division doesn’t. Consider the following TACKY instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If the type of its operands is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    we’ll generate the following assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We’ll also translate floating-point negation differently from its integer counterpart.
    To negate a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll
    XOR it with <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. For example,
    to translate the TACKY instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'we’ll start by defining a new 16-byte-aligned constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll generate the following assembly instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We need to align <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> to
    16 bytes so that we can use it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    instruction. This is the only time we align a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to 16 bytes instead of 8\. We don’t need to worry about the alignment of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>; <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>’s
    destination must be a register, and we’ll take care of that requirement during
    instruction fix-up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s talk about how to handle our relational binary operators: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>,
    and so on. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    sets the CF and ZF flags, we’ll handle floating-point comparisons just like unsigned
    integer comparisons. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are floating-point values, we’ll produce the following assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll take a similar approach to the three TACKY instructions that compare
    a value to zero: <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>, and the unary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> operation. We’ll convert'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'to the following assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to zero out an XMM register with <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    in order to perform the comparison. You don’t need to use XMM0 here, but you shouldn’t
    use the scratch registers you’ve chosen for the rewrite pass. It’s easier to avoid
    conflicting uses of registers if you strictly separate which registers you introduce
    in each backend pass.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Conversions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we’ve already covered the assembly for each of our type conversions, I
    won’t present it again here, but I will flag a couple of details we haven’t discussed
    yet. First, you’ll need to choose which hard registers to use in these conversions.
    All four conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the unsigned integer types use XMM registers, general-purpose registers, or
    both. For example, [Listing 13-26](chapter13.xhtml#list13-26) uses RAX and RDX
    to halve an integer and then round to odd. You don’t need to stick with the same
    registers we used when we walked through these conversions earlier; just avoid
    the callee-saved registers (RBX, R12, R13, R14, and R15) and the registers you
    use in the rewrite pass (R10 and R11, plus your two scratch XMM registers; mine
    are XMM14 and XMM15).
  prefs: []
  type: TYPE_NORMAL
- en: Second, when you process a conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, be
    sure to generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instruction to explicitly zero extend the source value, rather than a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction. This will become important when we implement register allocation
    in [Part III](part3.xhtml). We’ll use a technique called *register coalescing*
    to delete redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    as we allocate registers; using <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> here signals
    that you’re using this instruction to zero out bytes and not just to move values
    around, so it shouldn’t be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Concretely, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, you’ll translate
    the TACKY instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'into this assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You can use a register other than RAX here, as long as it meets the requirements
    we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Calls</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The tricky part of handling floating-point values in function calls is figuring
    out where each argument is passed. We’ll use this information in two places. First,
    we’ll need it to pass arguments correctly when we translate the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction. Second, we’ll use it to set up parameters at the beginning of each
    function body. We’ll write a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>,
    to handle the bookkeeping we need in both of these places. Given a list of TACKY
    values, this helper function will convert each one to an assembly operand and
    determine its assembly type. It will also partition the list in three: one list
    of operands passed in general-purpose registers, one list of operands passed in
    XMM registers, and one list of operands passed on the stack. [Listing 13-29](chapter13.xhtml#list13-29)
    gives the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-29: Classifying
    function arguments or parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To process each parameter, we first convert it from a TACKY value to an assembly
    operand and convert its type to the corresponding assembly type. (I won’t give
    you the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type_of</samp>,
    which just finds the type of a TACKY value and converts it to assembly.) We package
    these up into a pair, <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp>
    ❶. The elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">int_reg_args</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> will all be
    pairs in this form. The elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">double_reg_args</samp>
    will be plain assembly operands; since they’re all <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s,
    it would be redundant to specify each one’s type explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we figure out which list to add the operand to. We’ll see if we can pass
    it in an available register for its type. For example, if its type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>,
    we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">double_reg_args</samp>
    already contains eight values ❷. If it does, registers XMM0 through XMM7 are already
    taken. If it doesn’t, there’s at least one XMM register still available.
  prefs: []
  type: TYPE_NORMAL
- en: If we can pass the operand in an XMM register, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double_arg_regs</samp> ❸. If
    we can pass it in a general-purpose register, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int_arg_regs</samp> ❹. If there
    are no registers of the correct type available, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>. Once we’ve
    processed every value, we return all three lists.
  prefs: []
  type: TYPE_NORMAL
- en: As we build up these three lists, we preserve the order in which the values
    appear. In particular, we add values to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>
    in the same order they appear in the original list of values, not in reverse.
    That means the first value in <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>
    will be pushed last and will appear at the top of the stack. From the callee’s
    perspective, the first value will be stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>,
    the second value at <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that at the start of a function body, we copy any parameters from their
    initial locations into pseudoregisters. [Listing 13-30](chapter13.xhtml#list13-30)
    demonstrates how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    to perform this setup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-30: Setting up parameters
    in function bodies</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>
    takes a list of a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>s
    representing a function’s parameter list. We process this list with <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>,
    then handle the three resulting lists of assembly operands. To process parameters
    passed in general-purpose registers, we copy the value in EDI (or RDI, depending
    on the type) to the pseudoregister for the first parameter, copy the value in
    ESI to the second parameter, and so on. We handle parameters passed in XMM registers
    the same way. Finally, we handle parameters passed on the stack: we copy the value
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(16)</samp> to the first
    pseudoregister in <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_params</samp>,
    then increase the stack offset by 8 for each subsequent parameter until we’ve
    processed the whole list.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    to implement the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction. Let’s revisit the pseudocode to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    to assembly, which we first introduced in [Listing 9-31](chapter9.xhtml#list9-31)
    and updated in [Listing 11-25](chapter11.xhtml#list11-25). [Listing 13-31](chapter13.xhtml#list13-31)
    presents this pseudocode again, with the new logic to process floating-point arguments
    and return values bolded. (I haven’t bolded minor changes like renaming <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg_registers</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int_registers</samp>.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-31: Supporting</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    function calls</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through the changes in this listing. To start, we need to categorize
    our arguments with <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    The arguments in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_args</samp>
    are passed in general-purpose registers the same way as before (possibly with
    a few tweaks, not bolded here, to account for the fact that we’re iterating over
    typed assembly operands rather than TACKY values). We add a new step to copy each
    argument in <samp class="SANS_TheSansMonoCd_W5Regular_11">double_args</samp> into
    the corresponding XMM register.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we update how we pass arguments on the stack. We make two tiny changes
    from [Listing 11-25](chapter11.xhtml#list11-25), where we last looked at this
    step. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operands
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> type, like operands
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> type, are pushed
    directly onto the stack without copying them into a register first, since they’re
    the correct operand size for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>
    instruction. Second, in cases where we move an operand into the <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp>
    register before we push it onto the stack, we no longer hardcode <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>
    as the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction;
    instead, we use the operand type we determined in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    This future-proofs our code against later chapters, where we’ll add more assembly
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update how we retrieve the function’s return value. If the return
    value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll
    copy it from XMM0 to the destination. Otherwise, we’ll copy it from EAX (or RAX),
    as usual. We don’t need to change how we adjust the stack alignment before a function
    call, issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction
    itself, or clean up arguments afterward.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Return Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Last but not least, we’ll change how we translate the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. For example, given the TACKY instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'we’ll look up the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in the backend symbol table. If it’s an integer, we can handle it as before. If
    it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll copy
    it into XMM0 and then return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we’ve covered every update to the assembly genera- tion pass.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Complete Conversion
    from TACKY to Assembly</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Tables 13-2](chapter13.xhtml#tab13-2) through [13-7](chapter13.xhtml#tab13-7)
    summarize this chapter’s changes to the conversion from TACKY to assembly. As
    usual, new constructs and changes to the conversions for existing constructs are
    bolded. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp> placeholders
    in [Table 13-3](chapter13.xhtml#tab13-3) indicate arbitrary general-purpose and
    XMM registers, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(top_level_defs)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Book_11">Integer</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Not, src, dst)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Integer</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Unary(Negate, src, dst) (double</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">negation)</samp> |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2,
    dst)</samp> <samp class="SANS_Futura_Std_Heavy_B_11">(integer division)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Signed</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero(condition, target)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Integer</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero(condition, target)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Integer</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall(fun_name, args, dst)</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IntToDouble(src, dst)</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleToInt(src, dst)</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">UIntToDouble(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned long</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleToUInt(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned int</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned long</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Arithmetic Operators to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operator</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Divide</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DivDouble</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">(double</samp> <samp class="SANS_Futura_Std_Heavy_B_11">division)</samp>
    |  |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-6:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstDouble(double))</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-7:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp> |'
  prefs: []
  type: TYPE_TB
- en: As the row for the top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp>
    construct in [Table 13-2](chapter13.xhtml#tab13-2) indicates, you’ll need to add
    every <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> you
    define in this pass to the list of top-level definitions. From this point on,
    updating the rest of the backend is relatively smooth sailing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pseudoregister Replacement</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should allocate 8 bytes on the stack for each <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    pseudoregister and make sure it’s 8-byte aligned. If the backend symbol table
    indicates that a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has
    static storage duration, you should replace any references to it with <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands, like you do for other static variables. In short, this pass can treat
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    pseudoregisters identically, since they have the same size and alignment.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you should also extend this pass to handle the new assembly instructions
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instruction Fix-Up</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll rewrite invalid SSE instructions. We’ll also need to rewrite the
    new bitwise instructions that operate on integers. Let’s handle the SSE instructions
    first. You should dedicate one XMM register to fixing instructions’ source operands
    and one to fixing destinations. I’ll use XMM14 for the former and XMM15 for the
    latter.
  prefs: []
  type: TYPE_NORMAL
- en: The destination of <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp>
    must be a register. For example, we’ll rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction
    has two constraints: the source can’t be a constant, and the destination must
    be a register. We’ll therefore rewrite'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction
    has different constraints from <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>.
    Its second operand, in the “destination” position, must be a register. So, we’ll
    rewrite
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The destination of an <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    instruction must be a register as well, so we’ll rewrite all of these instructions
    accordingly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction
    also requires either a register or a 16-byte-aligned memory address as its source
    operand, but we don’t need a rewrite rule for this since all the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    instructions we generate already satisfy this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the same rewrite rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    that we introduced for the general-purpose <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction in [Chapter 2](chapter2.xhtml), because it’s subject to the same constraint:
    its operands can’t both be in memory. (The one difference, of course, is that
    we’ll use an XMM register instead of R10 as the scratch register.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'That leaves the new bitwise instructions. We won’t need to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    instructions are subject to the same constraints as integer <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>: the operands can’t
    both be memory addresses, and they can’t take immediate source operands outside
    the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one other constraint that we’ll ignore for now: the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instruction can’t push an XMM register. We’ll wait until the next chapter to add
    the rewrite rule for invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instructions because it will use a new kind of assembly operand that we haven’t
    added yet. We won’t actually need this rewrite rule until we implement register
    allocation in [Part III](part3.xhtml); until then, we’ll push only immediate values
    and memory operands (and the RBP register in the function prologue).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, the last step is printing out the newest additions to the assembly
    AST. The most fiddly bit of this pass is emitting floating-point constants and
    static variables. Let’s walk through how to format floating-point numbers in assembly,
    how to label floating-point constants, and how to store floating-point constants
    and variables in the correct section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatting Floating-Point
    Numbers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are a few different ways to format floating-point numbers in assembly.
    One option is to print these numbers as *hexadecimal floating-point* constants,
    where the significand is a hexadecimal number and the exponent is a power of 2\.
    This notation can represent a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    exactly, without any rounding. The significand of a hexadecimal floating-point
    constant has an <samp class="SANS_TheSansMonoCd_W5Regular_11">0x</samp> prefix,
    and the exponent has a <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">P</samp> prefix. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">20.0</samp> in hexadecimal floating
    point is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2.8p+3</samp>. The hexadecimal
    number <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2.8</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">2.5</samp>
    in decimal, and 2.5 × 2³ = 20\. We can use this notation in a <samp class="SANS_TheSansMonoCd_W5Regular_11">.double</samp>
    directive, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: When you emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    in this notation, you’ll need up to 14 hexadecimal digits to represent it exactly.
    Unfortunately, not every assembler understands this format. The LLVM assembler,
    which is the default assembler on macOS, does; GAS, the GNU assembler, doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your assembler doesn’t support hexadecimal floating-point constants, you
    can emit a quadword with the same binary representation as the required <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Printing out <samp class="SANS_TheSansMonoCd_W5Regular_11">20.0</samp>
    with this approach results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn’t the most readable assembly, but it works perfectly well as long
    as your implementation language provides a way for you to get at the binary representation
    of a floating-point number. Your last option is to use decimal floating-point
    constants, which we used in earlier assembly examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Decimal can be less compact than hexadecimal floating point. For example, consider
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>, the
    closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to the decimal
    number 0.1\. The exact decimal representation of this value is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t need to emit this entire value; 17 digits is always enough to guarantee
    a *round-trip conversion* back to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    In other words, you can print out a 17-digit decimal approximation of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t exactly the right value, but it’s close enough that when the assembler
    converts it back to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    you’ll get the original value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Labeling Floating-Point
    Constants</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re using local labels for top-level constants, you should include the
    local label prefix (<samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> on
    macOS, <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> on Linux) any time
    you emit these constants’ identifiers. You’ll need to check the backend symbol
    table to distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands that represent static variables and those that represent constants. If
    an object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp> attribute
    is true, it takes a local label prefix; otherwise, it’s a variable, so it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not using local labels, you’ll need to emit all <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands uniformly. On macOS, that means prefixing the labels for both constants
    and static variables with an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Storing Constants
    in the Read-Only Data Section</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The name of the section that holds constants is platform-specific. On Linux,
    you should specify this section with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.section
    .rodata</samp> directive. On macOS, 8-byte-aligned and 16-byte-aligned constants
    are stored in different sections. If a constant is 8-byte aligned, use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> directive to store it
    in the correct section. For our one 16-byte-aligned constant (<samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>,
    which we use to implement negation), use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal16</samp>
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: The macOS linker expects 16-byte-aligned constants to be 16 bytes long, but
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> is only 8 bytes. Emit
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad 0</samp> directive right
    after the directive for <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>
    to bring the total size of the section holding this constant up to 16 bytes and
    satisfy the linker’s requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing
    Static Variables to 0.0 or –0.0</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t store static variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    in the BSS section or initialize them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp>
    directive, even if they’re initialized to zero. This sidesteps any potential confusion
    about whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> is
    really initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. (These two values
    usually compare equal, but we can’t store <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>
    in the BSS section or initialize it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp>
    directive because its binary representation isn’t all zeros.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Aside from floating-point constants and static variables, the code emission
    stage needs to handle the new XMM registers, the new instructions, and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sd</samp> suffix on the floating-point
    versions of existing instructions. These changes are extensive, but they don’t
    require much discussion. [Tables 13-8](chapter13.xhtml#tab13-8) through [13-13](chapter13.xhtml#tab13-13)
    summarize this chapter’s updates to the code emission pass. New constructs and
    changes to the way we emit existing constructs are bolded.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Book_11">Integer initialized to zero</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Book_11">Integer with nonzero initializer,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">or any</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Linux</samp> |'
  prefs: []
  type: TYPE_TB
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-9:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleInit(d)</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">.double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><d></samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">or .quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><d-interpreted-as-long></samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-10:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvtsi2sd(t, src, dst)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(t, src, dst)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Xor, Double, src, dst)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Mult, Double, src, dst)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cmp(Double, operand, operand)</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-11:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shr</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shr</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DivDouble</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">div</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">And</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Or</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-12:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Assembly Types</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sd</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-13:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM0)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm0</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM1)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM2)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm2</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM3)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm3</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM4)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm4</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM5)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm5</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM6)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm6</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM7)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm7</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM14)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm14</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM15)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm15</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Note that [Table 13-8](chapter13.xhtml#tab13-8) doesn’t include local label
    prefixes on constants, although you have the option to include them, as we’ve
    discussed. Also note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp>
    instructions in [Table 13-10](chapter13.xhtml#tab13-10) require special handling.
    As a packed instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    doesn’t use the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp>
    suffix, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp> instructions have different
    names than their integer counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve worked through all these changes, you’re ready to test the whole
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: NaN</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add support for quiet NaNs as an extra credit feature. Arithmetic operations
    should just work, without any extra effort on your part, because the SSE instructions
    will propagate NaNs appropriately. You don’t need to handle type conversions,
    either, since conversions from NaN to integers are undefined. The only operations
    you need to worry about are comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you compare any value to NaN, the result is unordered. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is NaN, then <samp class="SANS_TheSansMonoCd_W5Regular_11">x > y</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x < y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are all false. NaN even compares unequal to itself. The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    instruction indicates an unordered result by setting three flags to 1: ZF, CF,
    and PF, the *parity flag*. Just as there are condition codes that rely on ZF,
    CF, and the other status flags we’ve already encountered, the <samp class="SANS_TheSansMonoCd_W5Regular_11">P</samp>
    condition code relies on the parity flag. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">jp</samp>
    instruction will jump only if PF is 1\. You’ll need to use this condition code
    to properly account for NaN in floating-point comparisons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--nan</samp> flag to
    include test cases with NaN when you run the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag to enable all extra credit tests, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your compiler now supports floating-point numbers! In this chapter, you learned
    how to define floating-point constants in assembly, how to use SSE instructions,
    and how to pass floating-point arguments according to the System V calling convention.
    You also dealt with rounding error throughout the compiler, from the parser all
    the way through code emission. Above all, you’ve seen how difficult floating-point
    arithmetic is to get right. Many programmers know, in a general way, that floating-point
    arithmetic can be imprecise; writing a compiler forces you to understand exactly
    how it can go awry. In the next chapter, you’ll add a very different type: pointers.
    You’ll deal with tricky parsing issues, expand the type checker, and add a few
    extremely useful constructs to the TACKY and assembly ASTs.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are the resources I relied on while writing this chapter, roughly organized
    by the section where they’re most relevant. I’ve also included a couple of online
    floating-point visualization tools that I found particularly helpful.
  prefs: []
  type: TYPE_NORMAL
- en: '**IEEE 754**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The IEEE 754 standard is available for purchase on the IEEE website for $100
    (*[https://<wbr>ieeexplore<wbr>.ieee<wbr>.org<wbr>/document<wbr>/8766229](https://ieeexplore.ieee.org/document/8766229)*).
    But you can probably get any answers you need from the following resources, which
    are free:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “Double-Precision Floating-Point Format” article on Wikipedia gives a thorough
    description of the binary encoding of IEEE 754 double-precision values (*[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: “What Every Computer Scientist Should Know About Floating-Point Arithmetic”
    by David Goldberg is one of the best-known introductions to floating-point math,
    if not the most readable (*[https://<wbr>docs<wbr>.oracle<wbr>.com<wbr>/cd<wbr>/E19957<wbr>-01<wbr>/806<wbr>-3568<wbr>/ncg<wbr>_goldberg<wbr>.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*).
    I found the discussion of the IEEE 754 format in the section “The IEEE Standard”
    especially useful. The article also covers some important topics that I’ve glossed
    over completely, like exceptions and error handling.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Floating-Point Guide, a website created by Michael Borgwardt, covers the
    basics of working with IEEE 754 floating-point numbers in an approachable way
    (*[https://<wbr>floating<wbr>-point<wbr>-gui<wbr>.de](https://floating-point-gui.de)*).
    Start here if the other two articles are too dense.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To learn more about support for the IEEE 754 standard in GCC and Clang, see
    the following resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Semantics of Floating Point Math in GCC” on the GCC wiki summarizes the state
    of floating-point support in GCC, describes the default floating-point behavior,
    and discusses some of the challenges of fully conforming to IEEE 754 (*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/wiki<wbr>/FloatingPointMath](https://gcc.gnu.org/wiki/FloatingPointMath)*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The section “Controlling Floating-Point Behavior” in the Clang Compiler User’s
    Manual discusses IEEE 754 compliance in Clang (*[https://<wbr>clang<wbr>.llvm<wbr>.org<wbr>/docs<wbr>/UsersManual<wbr>.html#controlling<wbr>-floating<wbr>-point<wbr>-behavior](https://clang.llvm.org/docs/UsersManual.html#controlling-floating-point-behavior)*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference for “Rounding Behavior” on [page 299](#pg_299)**'
  prefs: []
  type: TYPE_NORMAL
- en: “The Spacing of Binary Floating-Point Numbers,” a blog post by Rick Regan, discusses
    the gaps between consecutive floating-point numbers (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/the<wbr>-spacing<wbr>-of<wbr>-binary<wbr>-floating<wbr>-point<wbr>-numbers<wbr>/](https://www.exploringbinary.com/the-spacing-of-binary-floating-point-numbers/)*).
    I found that focusing on the gaps in the number line was the key to understanding
    floating-point rounding error. After I read this blog post, other discussions
    of this topic suddenly made a lot more sense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References for “Floating-Point Operations in Assembly” on [page 310](#pg_310)**'
  prefs: []
  type: TYPE_NORMAL
- en: For details about the System V calling convention, see the System V x64 ABI
    (*[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details about individual SSE instructions, including how they deal with
    overflow and rounding, see the Intel 64 Software Developer’s Manual (*[https://<wbr>www<wbr>.intel<wbr>.com<wbr>/content<wbr>/www<wbr>/us<wbr>/en<wbr>/developer<wbr>/articles<wbr>/technical<wbr>/intel<wbr>-sdm<wbr>.html](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Sometimes Floating Point Math Is Perfect,” a blog post by Bruce Dawson, gives
    an overview of cases where floating-point calculations *don’t* produce rounding
    error (*[https://<wbr>randomascii<wbr>.wordpress<wbr>.com<wbr>/2017<wbr>/06<wbr>/19<wbr>/sometimes<wbr>-floating<wbr>-point<wbr>-math<wbr>-is<wbr>-perfect<wbr>/](https://randomascii.wordpress.com/2017/06/19/sometimes-floating-point-math-is-perfect/)*).
    It helped me think through why our assembly to convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> won’t have
    rounding error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pascal Cuoq has written an excellent answer to a Stack Overflow question about
    the assembly-level conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> (*[https://<wbr>stackoverflow<wbr>.com<wbr>/a<wbr>/26799227](https://stackoverflow.com/a/26799227)*).
    This is the best explanation of this conversion I’ve been able to find.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “GCC Avoids Double Rounding Errors with Round-to-Odd,” another post by Rick
    Regan, provides more background information on double rounding error (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/gcc<wbr>-avoids<wbr>-double<wbr>-rounding<wbr>-errors<wbr>-with<wbr>-round<wbr>-to<wbr>-odd<wbr>/](https://www.exploringbinary.com/gcc-avoids-double-rounding-errors-with-round-to-odd/)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References for “Code Emission” on [page 338](#pg_338)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'I drew on two of Rick Regan’s blog posts on Exploring Binary to handle floating-point
    constants during code emission:'
  prefs: []
  type: TYPE_NORMAL
- en: “Hexadecimal Floating-Point Constants” talks about representing floating-point
    numbers in hexadecimal to avoid rounding error (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/hexadecimal<wbr>-floating<wbr>-point<wbr>-constants<wbr>/](https://www.exploringbinary.com/hexadecimal-floating-point-constants/)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Number of Digits Required for Round-Trip Conversions” explains why 17 decimal
    digits is enough to represent a floating-point constant (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/number<wbr>-of<wbr>-digits<wbr>-required<wbr>-for<wbr>-round<wbr>-trip<wbr>-conversions<wbr>/](https://www.exploringbinary.com/number-of-digits-required-for-round-trip-conversions/)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating-point visualization tools**'
  prefs: []
  type: TYPE_NORMAL
- en: 'These tools let you experiment with the IEEE 754 representations of decimal
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: The Decimal to Floating-Point Converter, created by Rick Regan, lets you convert
    a decimal number to the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and display it in a wide range of formats, including raw binary, hexadecimal floating
    point, and binary scientific notation (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/floating<wbr>-point<wbr>-converter<wbr>/](https://www.exploringbinary.com/floating-point-converter/)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Float Exposed, created by Bartosz Ciechanowski, lets you view and edit the sign,
    exponent, and significand fields within a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    as well as its raw binary representation (*[https://<wbr>float<wbr>.exposed](https://float.exposed)*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
