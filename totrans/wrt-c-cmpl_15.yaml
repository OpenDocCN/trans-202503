- en: '![](../images/pg294.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg294.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-28.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-28.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">FLOATING-POINT
    NUMBERS</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">浮动点数字</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: Your compiler now supports four different integer types, but it still doesn’t
    support non-integral values. It also doesn’t support values outside the range
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>. In this chapter, you’ll address these shortcomings by implementing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> type. This type
    uses a *floating-point* binary representation, which is totally different from
    the signed and unsigned integer representations we’ve seen so far. The C standard
    also defines two other floating-point types, <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>, but we won’t
    implement those in this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编译器现在支持四种不同的整数类型，但它仍然不支持非整数值。它也不支持超出<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>范围的值。在本章中，你将通过实现<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>类型来解决这些不足。此类型使用*浮动点*二进制表示法，与我们目前看到的有符号和无符号整数表示法完全不同。C标准还定义了另外两种浮动点类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">float</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>，但我们在本书中不会实现它们。
- en: We’ll have two major tasks in this chapter. The first task is figuring out exactly
    what behavior we’re trying to implement. We can’t just check the C standard, because
    many aspects of floating-point behavior are implementation-defined. Instead, we’ll
    consult yet another standard, *IEEE 754*, to fill in most of the details that
    the C standard doesn’t specify. Our second major task is generating assembly code;
    we’ll need a whole new set of specialized assembly instructions and registers
    to operate on floating-point numbers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将有两个主要任务。第一个任务是弄清楚我们到底要实现什么行为。我们不能仅仅检查C标准，因为许多浮动点行为是由实现定义的。相反，我们将参考另一个标准——*IEEE
    754*，以填补C标准未指定的大部分细节。我们的第二个主要任务是生成汇编代码；我们将需要一整套新的专用汇编指令和寄存器来处理浮动点数字。
- en: We’ll start with a quick look at the IEEE 754 standard, which defines the binary
    format of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and some
    other aspects of floating-point behavior. Then, we’ll consider all the ways that
    rounding error can creep into floating-point operations and decide how our implementation
    will handle them. We won’t cover every aspect of floating-point arithmetic, but
    you can find links to the standard itself and more comprehensive explanations
    of IEEE 754, rounding error, and other aspects of floating-point behavior in “Additional
    Resources” on [page 343](#pg_343).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从快速了解IEEE 754标准开始，该标准定义了<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>的二进制格式以及浮动点行为的其他方面。接下来，我们将考虑浮动点操作中可能引入舍入误差的所有方式，并决定我们的实现将如何处理这些误差。我们不会覆盖浮动点算术的每个方面，但你可以在“附加资源”中找到指向标准本身的链接，以及对IEEE
    754、舍入误差和浮动点行为其他方面的更全面的解释，链接在[343页](#pg_343)。
- en: <samp class="SANS_Futura_Std_Bold_B_11">IEEE 754, What Is It Good For?</samp>
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">IEEE 754，它有什么用？</samp>
- en: The IEEE 754 standard specifies several floating-point formats and how to work
    with them. It defines a set of floating-point operations, including basic arithmetic
    operations, conversions, and comparisons. It also defines several rounding modes,
    which control how the results of these operations are rounded, and various floating-point
    exceptions, like overflow and division by zero. The standard can be used as a
    specification for any system that implements floating-point arithmetic, whether
    that system is a processor or a high-level programming language. In processors,
    the required operations are typically implemented as machine instructions. In
    most programming languages, including C, some IEEE 754 operations are implemented
    as primitive operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, while others are implemented
    as standard library functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 754 标准指定了几种浮点格式以及如何处理它们。它定义了一组浮点运算，包括基本的算术运算、转换和比较。它还定义了几种舍入模式，控制这些运算结果如何舍入，并定义了各种浮点异常，如溢出和除零错误。该标准可以作为实现浮点运算的任何系统的规范，无论该系统是处理器还是高级编程语言。在处理器中，所需的操作通常作为机器指令实现。在大多数编程语言中，包括
    C，一些 IEEE 754 操作作为基本运算符，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>，而其他操作则作为标准库函数实现。
- en: Virtually all modern programming languages represent floating-point numbers
    in IEEE 754 format (because they run on hardware using that format), but they
    have varying degrees of support for other aspects of the standard. For example,
    not all programming languages let you detect floating-point exceptions or use
    nondefault rounding modes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代编程语言都以 IEEE 754 格式表示浮点数（因为它们运行在使用该格式的硬件上），但它们对标准的其他方面支持的程度各不相同。例如，并非所有编程语言都允许你检测浮点异常或使用非默认舍入模式。
- en: In theory, you could implement C without using IEEE 754 at all; the C standard
    doesn’t dictate how to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and other floating-point types. However, the standard is designed to be compatible
    with IEEE 754\. Annex F, an optional section of the C standard, specifies how
    to fully support IEEE 754 and explicitly binds C types, operations, and macros
    to their IEEE 754 equivalents. (Note that the standard refers to “IEC 60559,”
    which is just another name for IEEE 754.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，你可以在不使用 IEEE 754 的情况下实现 C 语言；C 标准并没有规定如何表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    和其他浮点类型。然而，标准的设计是与 IEEE 754 兼容的。C 标准的附录 F 是一个可选部分，规定了如何完全支持 IEEE 754，并明确将 C 类型、操作和宏与其
    IEEE 754 等效项绑定。（注意，标准中提到的“IEC 60559”其实就是 IEEE 754 的另一个名称。）
- en: While the C standard doesn’t specify how to represent floating-point types,
    the System V x64 ABI does. Implementations that follow this ABI, including ours,
    must represent these types in IEEE 754 format. However, the ABI doesn’t deal with
    the other aspects of IEEE 754.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C 标准并没有指定如何表示浮点类型，但 System V x64 ABI 却有明确要求。遵循此 ABI 的实现，包括我们的实现，必须将这些类型表示为
    IEEE 754 格式。然而，ABI 并没有处理 IEEE 754 的其他方面。
- en: Most C implementations provide command line options to control exactly how strictly
    they conform to IEEE 754\. Our compiler won’t provide these options; instead,
    it will roughly match the default behavior of Clang and GCC. This means we’ll
    implement mathematical floating-point operations according to IEEE 754, and we’ll
    correctly handle most special values, but we’ll ignore floating-point exceptions
    and nondefault rounding modes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 C 实现提供命令行选项，精确控制它们遵循 IEEE 754 的严格程度。我们的编译器将不提供这些选项；相反，它将大致匹配 Clang 和 GCC
    的默认行为。这意味着我们将根据 IEEE 754 实现数学浮点运算，并正确处理大多数特殊值，但我们将忽略浮点异常和非默认舍入模式。
- en: In the next couple of sections, I’ll discuss the parts of IEEE 754 that you’ll
    need to know about as you work on your compiler. I won’t discuss operations that
    are implemented in the underlying hardware (like addition and subtraction) or
    in the C standard library (like square root and remainder). You don’t need to
    know the details of how those are specified, since they’re handled for you. But
    you *do* need to know a bit about the binary format of IEEE 754 numbers, so we’ll
    start with that.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我将讨论你在编写编译器时需要了解的 IEEE 754 的部分内容。我不会讨论底层硬件（如加法和减法）或 C 标准库中的操作（如平方根和余数）。你不需要了解它们的详细规格，因为这些操作已经为你处理好了。但你
    *确实* 需要了解 IEEE 754 数字的二进制格式，所以我们将从这一部分开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The IEEE 754 Double-Precision Format</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">IEEE 754 双精度格式</samp>
- en: The System V x64 ABI tells us to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    using the IEEE 754 *double-precision* format, which is 64 bits wide. [Figure 13-1](#fig13-1)
    illustrates this format. (This figure is reproduced with slight modifications
    from *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 系统 V x64 ABI 告诉我们要使用 IEEE 754 *双精度* 格式表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，该格式宽度为
    64 位。[图 13-1](#fig13-1) 说明了该格式。（此图经过轻微修改，来源于 *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*。）
- en: '![](../images/fig13-1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: The IEEE 754 double-precision
    floating-point format [Description](description-29.xhtml)</samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-1：IEEE 754 双精度浮点格式 [描述](description-29.xhtml)</samp>
- en: 'The double-precision floating-point format has three fields: the sign bit,
    the exponent field, and the fraction field. These fields encode three values:
    the sign *s*, the exponent *e*, and the significand *f*, respectively. (Sometimes
    *f* is called the *mantissa* instead of the significand.) A number in this format
    has the value (–1)*^s* × *f* × 2*^e*, except for a few special cases that we’ll
    discuss shortly.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 双精度浮点格式有三个字段：符号位、指数字段和尾数字段。这些字段分别编码三个值：符号 *s*，指数 *e* 和尾数 *f*。（有时 *f* 被称为 *尾数*，而不是
    significand。）这种格式的数字的值为 (–1)*^s* × *f* × 2*^e*，除了一些特殊情况，我们稍后会讨论这些情况。
- en: 'The significand *f* is a *binary fraction*, which is analogous to a decimal
    number. In decimal numbers, the digits to the left of the decimal point (the *integer
    part*) represent nonnegative powers of 10, and the digits to the right (the *fractional
    part*) represent negative powers of 10: 1/10, 1/100, and so on. Similarly, each
    bit in the integer part of a binary fraction represents a nonnegative power of
    2, like 1, 2, 4, or 8, and each bit in the fractional part represents a negative
    power of 2, like 1/2, 1/4, or 1/8.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尾数 *f* 是一个 *二进制分数*，类似于十进制数。在十进制数中，小数点左侧的数字（*整数部分*）表示非负的 10 的幂，而右侧的数字（*小数部分*）表示负的
    10 的幂：1/10、1/100 等。类似地，二进制分数中整数部分的每一位代表 2 的非负幂，如 1、2、4 或 8，而小数部分的每一位代表 2 的负幂，如
    1/2、1/4 或 1/8。
- en: The integer part of *f* is always 1; the 52 bits of the fraction field encode
    only the fractional part. This means that the value of *f* is always greater than
    or equal to 1 and less than 2\. For example, the fraction field
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*f* 的整数部分始终为 1；52 位的尾数字段仅编码小数部分。这意味着 *f* 的值始终大于或等于 1 且小于 2。例如，尾数字段'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: indicates that the fractional part of *f* is 0.1, so the overall value of *f*
    is the binary fraction 1.1, which is 1.5 in decimal notation. The implied leading
    1 lets the 52-bit fraction field represent binary fractions up to 53 bits long.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表示 *f* 的小数部分是 0.1，因此 *f* 的整体值是二进制分数 1.1，在十进制表示中为 1.5。隐含的前导 1 使得 52 位的尾数字段可以表示最长达
    53 位的二进制分数。
- en: 'The value of *e* is between –1,022 and 1,023\. The exponent field uses a *biased*
    encoding: we interpret the 11 bits in this field as an unsigned integer and then
    subtract 1,023 to get the value of *e*. For example, suppose this field has the
    following bits:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*e* 的值在 –1,022 和 1,023 之间。指数字段使用 *偏移* 编码：我们将该字段中的 11 位解读为无符号整数，然后减去 1,023 得到
    *e* 的值。例如，假设该字段有以下位：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Interpreted as an ordinary unsigned integer, these bits represent the number
    2\. The value of the exponent *e* is therefore 2 – 1,023, or –1,021\. Setting
    the exponent field to all 1s or all 0s indicates one of the special values we’ll
    discuss in a moment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些位解释为普通无符号整数时，它们表示数字2。因此，指数 *e* 的值为 2 – 1,023，即 –1,021。当指数域全为1或全为0时，表示我们稍后将讨论的某些特殊值。
- en: Since *f* is always positive, the whole floating-point number will be negative
    if the sign bit is 1 and positive if it’s 0\. Essentially, floating point lets
    us express numbers in scientific notation, but with powers of 2 instead of powers
    of 10.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *f* 总是正数，如果符号位为1，则整个浮点数为负数；如果符号位为0，则为正数。本质上，浮点数让我们用科学记数法表示数字，但使用的是2的幂而不是10的幂。
- en: 'The IEEE 754 standard also defines a few special values that are interpreted
    differently than ordinary floating-point numbers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 754标准还定义了一些特殊值，它们的解释与普通浮点数不同：
- en: '**Zero and negative zero**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**零和负零**'
- en: If a floating-point number is all zeros, its value is <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>.
    If it’s all zeros except for its sign bit, its value is <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.
    This value compares equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    but follows the usual rules for determining the sign of arithmetic results. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">-1.0 * 0.0</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1.0 * -0.0</samp> both evaluate to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个浮点数的所有位都是零，它的值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>。如果它的所有位都是零，除了符号位外，它的值是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>。这个值与 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    相等，但遵循常规规则来确定算术结果的符号。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">-1.0 * 0.0</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0 * -0.0</samp> 都计算为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>。
- en: '**Subnormal numbers**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**次正规数**'
- en: As we just saw, most floating-point numbers have a significand between 1 and
    2\. We say that these numbers are *normalized*. The smallest magnitude a normalized
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent is 1
    × 2^(–1,022), since the minimum exponent is –1,022\. In a *subnormal* number,
    the significand is smaller than 1, which lets us represent values that are even
    closer to zero. An all-zero exponent field indicates that a number is subnormal,
    so its exponent is –1,022 and the integer part of its significand is 0 instead
    of 1\. Subnormal numbers are much slower to work with in hardware than normalized
    numbers, so some C implementations let users disable them and round any subnormal
    results to zero.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们刚才所见，大多数浮点数的有效数字在1和2之间。我们称这些数值为*正规化*的。标准化的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    所能表示的最小幅度是 1 × 2^(-1,022)，因为最小指数为 –1,022。在*次正规数*中，有效数字小于1，这使得我们能够表示更接近零的值。一个全零的指数域表示该数字是次正规数，因此它的指数为
    –1,022，有效数字的整数部分为0，而不是1。次正规数在硬件中比正规化数要慢得多，因此一些C语言实现允许用户禁用次正规数，并将任何次正规结果四舍五入为零。
- en: '**Infinity**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**无限**'
- en: At the opposite end of the spectrum, the largest magnitude a normalized <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent is the largest
    possible value of the significand (just shy of 2) multiplied by 2^(1,023). Anything
    larger gets rounded to infinity. The result of dividing a nonzero number by zero
    is also infinity. The IEEE standard defines both positive and negative infinity;
    for example, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">-1.0
    / 0.0</samp> evaluates to negative infinity. A number whose exponent is all 1s
    and whose fraction field is all 0s represents infinity. The sign bit indicates
    whether it’s negative or positive infinity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，标准化的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 所能表示的最大幅度是有效数字的最大值（接近2）乘以
    2^(1,023)。任何更大的数值都会被四舍五入为无限大。将非零数除以零的结果也是无限大。IEEE标准定义了正无穷和负无穷；例如，表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1.0
    / 0.0</samp> 计算为负无穷大。一个指数全为1且分数域全为0的数值表示无限大。符号位指示它是正无穷还是负无穷。
- en: '**NaN**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**NaN**'
- en: NaN is short for *not-a-number*. A few operations, including <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0
    / 0.0</samp>, produce NaN. The IEEE 754 standard defines both *signaling NaNs*,
    which raise an exception if you try to use them, and *quiet NaNs*, which don’t.
    A number whose exponent is all 1s and whose fraction field is nonzero represents
    NaN.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: NaN是*非数字*（not-a-number）的缩写。一些操作，包括<samp class="SANS_TheSansMonoCd_W5Regular_11">0.0
    / 0.0</samp>，会产生NaN。IEEE 754标准定义了*信号NaN*，如果你尝试使用它们会引发异常，和*安静NaN*，它们则不会。一个指数全为1且分数域非零的数字表示NaN。
- en: We’ll support all of these values except for NaN. Quiet NaNs are an extra credit
    feature because handling them correctly in comparisons requires a bit of extra
    work. We can support negative zero, subnormal numbers, and infinity with no extra
    work on our part; the processor will deal with them for us.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将支持所有这些值，除了NaN。安静的NaN是额外的附加功能，因为在比较中正确处理它们需要一些额外的工作。我们可以支持负零、次正规数和无穷大，而不需要额外的工作；处理器将为我们处理这些。
- en: Aside from the double-precision format, IEEE 754 defines a few other floating-point
    formats that we won’t use, including *single precision*, which corresponds to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, and *double extended
    precision*, which usually corresponds to <samp class="SANS_TheSansMonoCd_W5Regular_11">long
    double</samp>. These formats include the same three fields as double precision,
    use the same formula to determine a floating-point number’s value, and have the
    same special values; they just have different widths.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了双精度格式，IEEE 754还定义了几个我们不会使用的浮点格式，包括*单精度*，对应于<samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>，以及*双扩展精度*，通常对应于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long double</samp>。这些格式包括与双精度相同的三个字段，使用相同的公式来确定浮点数的值，并具有相同的特殊值；它们只是具有不同的位宽。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Rounding Behavior</samp>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">舍入行为</samp>
- en: 'You can’t represent every real number exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    There are infinitely many real numbers, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    has only 64 bits. We’re not particularly interested in *all* the real numbers;
    we care only about the numbers that show up in C programs. Unfortunately, a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can’t represent most of
    those exactly either, so we’ll need to round them. Let’s start by examining how
    IEEE 754 tells us to round real numbers to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Then, we’ll look at the three cases where we can encounter rounding error: when
    converting constants from decimal to binary floating point, performing type conversions,
    and performing arithmetic operations.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能准确地表示每一个实数作为<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。实数是无限的，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>只有64位。我们并不特别关心*所有*的实数；我们只关心在C程序中出现的数字。不幸的是，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>也不能准确地表示大多数这些数字，所以我们需要对它们进行舍入。让我们首先看看IEEE
    754是如何告诉我们将实数舍入为<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>的。然后，我们将讨论三种可能遇到舍入误差的情况：从十进制到二进制浮点数的常量转换、执行类型转换和进行算术操作时。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Modes</samp>
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">舍入模式</samp>
- en: IEEE 754 defines several different rounding modes, including rounding to nearest,
    rounding toward zero, rounding toward positive infinity, and rounding toward negative
    infinity. Modern processors support all four of these rounding modes and provide
    instructions to let programs change the current rounding mode. We’ll support only
    the default IEEE rounding mode, *round-to-nearest, ties-to-even* rounding. As
    the name suggests, in this mode the real value of a result is always rounded to
    the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    “Ties-to-even” means that if a result is exactly between two representable values,
    it’s rounded to the one whose least significant bit is 0\. We’ll use this rounding
    mode when converting constants to floating point, when converting from integer
    types to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, and in arithmetic
    operations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 754 定义了几种不同的舍入模式，包括舍入到最接近值、舍入到零、舍入到正无穷大和舍入到负无穷大。现代处理器支持这四种舍入模式，并提供指令让程序更改当前的舍入模式。我们将仅支持默认的
    IEEE 舍入模式，即 *舍入到最接近值，四舍五入时舍入偶数*。顾名思义，在这种模式下，结果的真实值总是舍入到最接近的可表示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。
    “舍入偶数”意味着如果结果恰好在两个可表示值之间，则舍入到最低有效位为 0 的那个值。我们将在将常量转换为浮点数、将整数类型转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    以及在算术操作中使用这种舍入模式。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Constants</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">四舍五入常量</samp>'
- en: C programmers generally write <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constants in decimal. At compile time, we’ll convert constants from this decimal
    representation to a double-precision floating-point representation. This conversion
    is inexact, since most decimal constants can’t be represented exactly in binary
    floating point. For example, you can’t represent the decimal number 0.1 in binary
    floating point, because each bit in a binary fraction represents a power of 2,
    but you can’t add up powers of 2 and get 0.1\. If the source code of a C program
    includes the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">0.1</samp>,
    the compiler will round this constant to the value in [Listing 13-1](chapter13.xhtml#list13-1),
    which is the nearest value we can represent as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: C 程序员通常使用十进制表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 常量。在编译时，我们会将常量从十进制表示转换为双精度浮点表示。这个转换是不精确的，因为大多数十进制常量无法在二进制浮点中精确表示。例如，你无法在二进制浮点中表示十进制数
    0.1，因为二进制小数的每一位代表 2 的幂次方，但你无法通过加起来的 2 的幂次方得到 0.1。如果 C 程序的源代码中包含常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.1</samp>，编译器会将这个常量四舍五入为
    [列表 13-1](chapter13.xhtml#list13-1) 中的值，这个值是我们可以表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型的最接近值。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-1: The closest</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    0.1, in decimal notation</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-1：最接近</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">到 0.1 的十进制表示</samp>
- en: Unlike 0.1, this value can be represented exactly as a 53-bit binary fraction
    multiplied by a power of 2, as shown in [Listing 13-2](chapter13.xhtml#list13-2).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与 0.1 不同，这个值可以精确表示为一个 53 位的二进制小数乘以 2 的某个幂，如 [列表 13-2](chapter13.xhtml#list13-2)
    中所示。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-2: The closest</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    0.1, represented as a binary fraction</samp>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-2：最接近</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">到 0.1 的二进制表示</samp>
- en: Representing 0.1 as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is analogous to trying to write 1/3 in decimal notation; since you can’t break
    it down into powers of 10, you can’t write it out exactly using any number of
    decimal places. Instead, you have to round 1/3 to the nearest value you can represent
    in the space available. For example, a calculator that can display up to four
    digits would display 1/3 as <samp class="SANS_TheSansMonoCd_W5Regular_11">.3333</samp>.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将 0.1 表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类似于尝试用十进制表示
    1/3；因为你无法将其分解为 10 的幂，所以无法用任何数量的小数位精确表示它。相反，你必须将 1/3 四舍五入为你可以在可用空间中表示的最接近值。例如，一个最多可以显示四位数字的计算器会将
    1/3 显示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">.3333</samp>。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*IEEE 754 defines several* decimal floating-point *formats, which can represent
    decimal constants without this sort of rounding error. These formats encode numbers
    as decimal significands multiplied by powers of 10\. C23 includes new decimal
    floating-point types that correspond to these formats.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*IEEE 754定义了几种*十进制浮动点*格式，这些格式能够表示十进制常数而不会出现这种舍入误差。这些格式将数字编码为十进制有效数字与10的幂相乘的形式。C23包含了与这些格式对应的新十进制浮动点类型。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Type Conversions</samp>
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">舍入类型转换</samp>
- en: 'We may also need to round when we convert an integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    This issue arises because of the spacing between values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can represent. The gap between representable values grows larger as the magnitude
    of the values themselves increases. At a certain point, the gap becomes larger
    than 1, which means you can’t represent all integers in that range. To illustrate
    this problem, let’s imagine a decimal format with three digits of precision. This
    format can represent any integer smaller than 1,000; for example, we can write
    992 and 993 as 9.92 × 10² and 9.93 × 10². But it can’t represent every integer
    larger than 1,000\. We can represent 1,000 exactly as 1.00 × 10³, but the next
    representable value is 1.01 × 10³, or 1,010; there’s a gap of 10\. The gap increases
    to 100 once we hit 10,000, and continues to grow at larger magnitudes. We’ll encounter
    precisely the same issue when converting from <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. A <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    has 53 bits of precision, since the significand is a 53-bit binary fraction. A
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>, however, has 64 bits of precision. Suppose we need to convert <samp
    class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775803</samp> from a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    The binary representation of this <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>
    is:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在将整数转换为<​samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>时，我们也可能需要进行舍入。这个问题产生的原因是<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>能够表示的值之间的间距。随着值的大小增加，表示值之间的间距也变得更大。到了一定程度，间距变得大于1，这意味着你无法表示该范围内的所有整数。为了说明这个问题，让我们假设一个精度为三位数的十进制格式。这个格式可以表示任何小于1000的整数；例如，我们可以将992和993分别表示为9.92
    × 10²和9.93 × 10²。但它无法表示大于1000的每个整数。我们可以将1000精确表示为1.00 × 10³，但下一个可表示的值是1.01 × 10³，或1010；之间有10的间距。一旦达到10,000，这个间距将增大到100，并且在更大的数值下，间距会继续增长。当从<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>或<​samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>转换为<​samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>时，我们会遇到完全相同的问题。<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>具有53位精度，因为有效数字是一个53位的二进制分数。然而，<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>或<​samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>具有64位精度。假设我们需要将<​samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775803</samp>从<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>转换为<​samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。这个<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>的二进制表示为：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That’s 63 bits, so it won’t fit in the significand of a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>!
    We’ll need to round it to the nearest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    which is <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>,
    or 1 × 2^(63).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是63位，因此无法适应<​samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>的有效数字！我们需要将其舍入为最接近的<​samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，即<​samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>，或1
    × 2^(63)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rounding Arithmetic
    Operations</samp>
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">舍入算术操作</samp>
- en: Finally, we may need to round the results of basic floating-point operations
    like addition, subtraction, and multiplication. Once again, this is due to the
    gaps between representable values. For example, let’s try computing 993 + 45 in
    the three-digit decimal format from the previous section. The correct result,
    1,038, can’t be represented in only three digits; we’ll need to round it to 1.04
    × 10³. Division can also produce values that aren’t representable at any precision,
    just like the result of 1 / 3 isn’t representable in any number of decimal digits.
    Thankfully, we can basically ignore this category of rounding error; the assembly
    instructions for floating-point arithmetic will round correctly without any extra
    effort on our part.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可能需要对基本的浮点操作结果进行舍入，比如加法、减法和乘法。再次强调，这是因为可表示值之间的间隙。例如，让我们试着计算 993 + 45，使用上一节中的三位十进制格式。正确的结果是
    1,038，但三位数无法表示它；我们需要将其舍入为 1.04 × 10³。除法也可能产生无法在任何精度下表示的值，就像 1 / 3 的结果无法用任何数量的十进制数字表示一样。幸运的是，我们基本上可以忽略这一类舍入误差；浮点算术的汇编指令会在没有额外努力的情况下正确地进行舍入。
- en: Now that you understand the basics of the IEEE 754 format and the rounding behavior
    you need to implement, you’re ready to get to work on the compiler. We’ll start
    with a change to the compiler driver.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 IEEE 754 格式的基础和需要实现的舍入行为，你可以开始着手编写编译器了。我们将从编译器驱动程序的修改开始。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Linking Shared Libraries</samp>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">链接共享库</samp>
- en: This chapter’s test suite uses functions from <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>,
    the standard math library. We’ll add a new command line option to the compiler
    driver that lets us link in shared libraries like <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>.
    This option takes the form <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><lib></samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><lib></samp>
    is the name of a library. You should pass this option through to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    command to assemble and link the program, placing it after the names of any input
    assembly files in that command. For example, if your compiler is invoked with
    the command
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的测试套件使用了来自 <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp> 的函数，这是标准数学库。我们将向编译器驱动程序添加一个新命令行选项，允许我们链接共享库，如
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>。这个选项的形式是 <samp class="SANS_TheSansMonoCd_W5Regular_11">-l</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><lib></samp>，其中 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><lib></samp>
    是库的名称。你应该将这个选项传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> 命令来组装和链接程序，并将其放在命令中任何输入汇编文件的名称之后。例如，如果你的编译器是通过以下命令调用的
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'it should assemble and link the program with the command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该使用以下命令来组装和链接程序：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you’re on macOS, you don’t need to add this new option, because the standard
    math library is linked in by default. You may want to add it anyway, though, since
    being able to link in shared libraries is generally useful.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 macOS，你不需要添加这个新选项，因为标准数学库默认已经链接。不过，你可能还是希望添加这个选项，因为能够链接共享库通常是有用的。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>'
- en: 'You’ll introduce two new tokens in this chapter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将引入两个新标记：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> A keyword
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> 一个关键字
- en: '**Floating-point constants** Constants that use scientific notation or contain
    a decimal point'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**浮点常量** 使用科学计数法或包含小数点的常量'
- en: You’ll also change how the lexer recognizes the end of a constant token; this
    will affect both the new floating-point constants and the integer constants you
    already support.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要修改词法分析器识别常量标记的结束方式；这将影响新引入的浮点常量以及你已经支持的整数常量。
- en: Let’s start by walking through the format of floating-point constants. Then,
    we’ll see how to recognize the end of a constant. Finally, we’ll define the new
    regular expressions for each constant token.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解浮点常量的格式。然后，我们将看到如何识别常量的结束。最后，我们将为每个常量标记定义新的正则表达式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Recognizing Floating-Point
    Constant Tokens</samp>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">识别浮点常量标记</samp>
- en: Numerals with decimal points, like <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.72</samp>, are valid tokens
    that represent floating-point numbers. We’ll call a sequence of digits that includes
    a decimal point a *fractional constant*. A fractional constant may include a decimal
    point with no digits after it. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1.</samp>
    is a valid fractional constant with the same value as <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 带有小数点的数字，如 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.5</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.72</samp>，是有效的标记，表示浮点数。我们将包括小数点的数字序列称为
    *分数常量*。分数常量可以包括没有小数位的点。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">1.</samp>
    是一个有效的分数常量，值与 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> 相同。
- en: 'A floating-point constant can also be written in scientific notation. A token
    that uses scientific notation consists of:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点常量也可以用科学计数法表示。使用科学计数法的标记由以下部分组成：
- en: A significand, which may be an integer or fractional constant
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个尾数，它可以是一个整数或分数常量
- en: An uppercase or lowercase <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个大写或小写的 <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
- en: An exponent, which is an integer with an optional leading <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> sign
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指数，它是一个整数，前面可以有一个可选的 <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> 符号
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">100E10</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">.05e-2</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">5.E+3</samp> are all valid floating-point
    constants. These constants are all in decimal, and their exponents are powers
    of 10\. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">5.E+3</samp>
    is 5 × 10³, or 5,000\. The C standard also defines hexadecimal floating-point
    constants, but we won’t implement them. There’s no constant for infinity. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp> header defines an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">INFINITY</samp> macro, which is
    supposed to translate to the constant for positive infinity, but our compiler
    can’t include this header, since it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>, and other language
    features we don’t support. Therefore, we won’t support this macro (or any other
    macros defined in <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp>,
    for that matter).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">100E10</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">.05e-2</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">5.E+3</samp> 都是有效的浮点常量。这些常量都是十进制的，其指数是10的幂。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">5.E+3</samp> 是 5 × 10³，或者 5000。C标准还定义了十六进制浮点常量，但我们不会实现它们。没有表示无穷大的常量。<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp> 头文件定义了一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">INFINITY</samp>
    宏，它应该表示正无穷大常量，但我们的编译器无法包含这个头文件，因为它使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> 以及其他我们不支持的语言特性。因此，我们不会支持这个宏（或者说，不支持
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><math.h></samp> 中定义的任何其他宏）。
- en: It’s a bit tricky to write a regex that will match every floating-point constant,
    so let’s break it down into steps. The regex in [Listing 13-3](chapter13.xhtml#list13-3)
    matches a fractional constant.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个正则表达式来匹配每个浮点常量有点棘手，所以让我们将其分解为几个步骤。[列表 13-3](chapter13.xhtml#list13-3)中的正则表达式匹配的是分数常量。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-3: The regex for
    a fractional constant</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-3：分数常量的正则表达式</samp>
- en: The first part of this regex, <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]*\.[0-9]+</samp>,
    matches any constant with digits after the decimal point, like <samp class="SANS_TheSansMonoCd_W5Regular_11">.03</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">3.14</samp>. The part after the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> matches constants like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3.</samp> with nothing after the
    decimal point. [Listing 13-4](chapter13.xhtml#list13-4) defines a similar regex
    to match the significand of a constant in scientific notation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式的第一部分，<samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]*\.[0-9]+</samp>，匹配任何小数点后有数字的常量，比如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">.03</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">3.14</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">|</samp>后面的部分匹配像<samp class="SANS_TheSansMonoCd_W5Regular_11">3.</samp>这样的常量，即小数点后没有数字。[列表13-4](chapter13.xhtml#list13-4)定义了一个类似的正则表达式，用来匹配科学计数法中常量的有效数值。
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-4: The regex for
    the significand of a constant in scientific notation</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表13-4：科学计数法中常量有效数值的正则表达式</samp>
- en: The only difference from [Listing 13-3](chapter13.xhtml#list13-3) is that the
    trailing decimal point in the second clause is optional, so it matches both integers
    and fractional constants with trailing decimal points.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与[列表13-3](chapter13.xhtml#list13-3)的唯一不同之处在于，第二个子句中的尾随小数点是可选的，因此它既能匹配整数，也能匹配带尾随小数点的分数常量。
- en: We’ll use the regex in [Listing 13-5](chapter13.xhtml#list13-5) to match the
    exponent part of a floating-point constant.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[列表13-5](chapter13.xhtml#list13-5)中的正则表达式来匹配浮点常量的指数部分。
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-5: The regex for
    the exponent of a constant in scientific notation</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表13-5：科学计数法中常量指数部分的正则表达式</samp>
- en: This regex includes the case-insensitive <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>
    that marks the start of the exponent, an optional sign, and the integer value
    of the exponent. To match any floating-point constant, we’ll assemble one giant
    regex of the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><[Listing
    13-4](chapter13.xhtml#list13-4)> <[Listing 13-5](chapter13.xhtml#list13-5)></samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><[Listing
    13-3](chapter13.xhtml#list13-3)></samp>, which gives us [Listing 13-6](chapter13.xhtml#list13-6).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式包括大小写不敏感的<samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp>，表示指数的开始，一个可选符号和指数的整数值。为了匹配任何浮点常量，我们将组合一个巨大的正则表达式，其形式为<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><[列表13-4](chapter13.xhtml#list13-4)>
    <[列表13-5](chapter13.xhtml#list13-5)></samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><[列表13-3](chapter13.xhtml#list13-3)></samp>，这给出了[列表13-6](chapter13.xhtml#list13-6)。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-6: The regex to
    match every part of a floating-point constant</samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表13-6：匹配浮点常量每个部分的正则表达式</samp>
- en: 'In other words, a floating-point constant is either a significand followed
    by an exponent, or a fractional constant. [Listing 13-6](chapter13.xhtml#list13-6)
    isn’t quite complete, though: we need one more component to match the boundary
    between the end of this token and the start of the next one.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，浮点常量要么是一个尾随指数的有效数值，要么是一个分数常量。不过，[列表13-6](chapter13.xhtml#list13-6)并不完全：我们还需要一个额外的组件来匹配该标记的结束与下一个标记开始之间的边界。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Matching the End
    of a Constant</samp>
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">匹配常量的结尾</samp>
- en: 'Until now, we’ve required constants to end at word boundaries. Given the string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">123foo</samp>, for example, we wouldn’t
    accept the substring <samp class="SANS_TheSansMonoCd_W5Regular_11">123</samp>
    as a constant. Now we’ll add another requirement: a constant token can’t be immediately
    followed by a period. This means, for example, that the lexer will recognize the
    start of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">123L;</samp>
    as a long integer constant token, <samp class="SANS_TheSansMonoCd_W5Regular_11">123L</samp>,
    but it will reject the string <samp class="SANS_TheSansMonoCd_W5Regular_11">123L.bar;</samp>
    as malformed. Along the same lines, the lexer will accept the string <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0+x</samp>
    but reject <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0.+x</samp>, and it
    will accept <samp class="SANS_TheSansMonoCd_W5Regular_11">1.}</samp> but reject
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1..}</samp>. Note that the last
    character in a floating-point constant like <samp class="SANS_TheSansMonoCd_W5Regular_11">1.</samp>
    can be a period, but the first character *after* the constant cannot.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们一直要求常量以单词边界结束。例如，给定字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">123foo</samp>，我们不会接受子字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">123</samp> 作为常量。现在我们将添加另一个要求：常量符号后面不能紧跟一个句点。这意味着，例如，词法分析器将识别字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">123L;</samp> 的开始部分作为长整型常量符号 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">123L</samp>，但它会拒绝字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">123L.bar;</samp>
    作为格式错误。同样，词法分析器将接受字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0+x</samp>，但拒绝
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0.+x</samp>，并且它会接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.}</samp>，但拒绝
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1..}</samp>。请注意，像 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.</samp>
    这样的浮点常量的最后一个字符可以是句点，但常量*之后*的第一个字符不能是句点。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*If you’re curious about where in the C standard this requirement comes from,
    see the definition of preprocessing numbers in section 6.4.8, the list of translation
    phases in section 5.1.1.2, and the discussion of tokens and preprocessing tokens
    in section 6.4, paragraph 3\. These sections describe a multiphase process for
    dividing a source file into preprocessing tokens and then converting them into
    tokens. We don’t follow this process, but we define each token in a way that produces
    the same results for the subset of C that we support.*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你对这个要求在 C 标准中的来源感到好奇，可以查看第 6.4.8 节中对预处理数字的定义、第 5.1.1.2 节中关于翻译阶段的列表，以及第 6.4
    节第 3 段中关于符号和预处理符号的讨论。这些章节描述了一个多阶段过程，用于将源文件划分为预处理符号，然后将它们转换为符号。我们并不完全遵循这个过程，但我们定义了每个符号的方式，以便在我们支持的
    C 子集上产生相同的结果。*'
- en: To enforce this new requirement, we’ll end the regular expression for each constant
    token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp> character
    class instead of the special word boundary character <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp> character class
    matches any single character except for a word character (a letter, digit, or
    underscore) or a period. This single non-word, non-period character marks the
    end of the constant but isn’t part of the constant itself, so we’ll define a capture
    group within each regex to match the actual constant.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制执行这个新要求，我们将在每个常量符号的正则表达式末尾使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp>
    字符类，而不是特殊的单词边界字符 <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp> 字符类匹配任何单个字符，除了单词字符（字母、数字或下划线）或句点。这个单一的非单词、非句点字符标记了常量的结束，但不属于常量本身，因此我们将在每个正则表达式中定义一个捕获组来匹配实际的常量。
- en: For example, our old regular expression for a signed integer constant was <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+\b</samp>. Our new regular expression
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)[\w.]</samp>. This regex
    matches the entire string <samp class="SANS_TheSansMonoCd_W5Regular_11">100;</samp>,
    including the <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> at the end.
    The capture group <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)</samp>
    matches just the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>,
    not the final <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> character.
    Whenever your lexer recognizes a constant, it should consume only the constant
    itself from the input, not the character that immediately follows it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们之前用于有符号整型常量的正则表达式是 <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+\b</samp>。我们的新正则表达式是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)[\w.]</samp>。这个正则表达式匹配整个字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">100;</samp>，包括结尾的 <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>。捕获组
    <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)</samp> 只匹配常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">100</samp>，而不包括最终的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> 字符。每当词法分析器识别到一个常量时，它应该只消耗输入中的常量本身，而不是紧随其后的字符。
- en: In [Listing 13-7](chapter13.xhtml#list13-7), we finally define the whole regular
    expression to recognize a floating-point constant.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 13-7](chapter13.xhtml#list13-7)中，我们最终定义了整个正则表达式来识别浮点常量。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-7: The complete
    regex to recognize a floating-point constant</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-7：识别浮点常量的完整正则表达式</samp>
- en: This is just the regular expression we defined in [Listing 13-6](chapter13.xhtml#list13-6),
    wrapped in parentheses to form a capture group and followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp>
    character class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是我们在[清单 13-6](chapter13.xhtml#list13-6)中定义的正则表达式，用括号括起来形成捕获组，并跟随 <samp class="SANS_TheSansMonoCd_W5Regular_11">[^\w.]</samp>
    字符类。
- en: '[Table 13-1](chapter13.xhtml#tab13-1) defines the new regular expressions for
    all of our constant tokens.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 13-1](chapter13.xhtml#tab13-1) 定义了所有常量标记的新正则表达式。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">Regular
    Expressions for Constant Tokens</samp>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-1:</samp> <samp class="SANS_Futura_Std_Book_11">常量标记的正则表达式</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Token</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Regular
    expression</samp> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标记</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">正则表达式</samp>
    |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Signed integer constant</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)[^\w.]</samp> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">有符号整型常量</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+)[^\w.]</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Unsigned integer constant</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+[uU])[^\w.]</samp> |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">无符号整型常量</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+[uU])[^\w.]</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Signed long integer constant</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+[lL])[^\w.]</samp> |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">有符号长整型常量</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+[lL])[^\w.]</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Unsigned long integer constant</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+([lL][uU]&#124;[uU][lL]))[^\w.]</samp>
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">无符号长整型常量</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">([0-9]+([lL][uU]&#124;[uU][lL]))[^\w.]</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Book_11">Floating-point constant</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">(([0-9]*\.[0-9]+&#124;[0-9]+\.?)[Ee][+-]?[0-9]+&#124;[0-9]*\.[0-9]+&#124;[0-9]+\.)[^\w.]</samp>
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">浮点常量</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">(([0-9]*\.[0-9]+&#124;[0-9]+\.?)[Ee][+-]?[0-9]+&#124;[0-9]*\.[0-9]+&#124;[0-9]+\.)[^\w.]</samp>
    |'
- en: Go ahead and add the new floating-point constant token and update how you recognize
    the constant tokens from earlier chapters. Don’t forget to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    keyword too!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 继续添加新的浮点常量标记，并更新你如何识别前面章节中的常量标记。别忘了也要添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    关键字！
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: The changes to the parser are pretty limited. [Listing 13-8](chapter13.xhtml#list13-8)
    gives the updated AST, which includes the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type and floating-point constants.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器的更改相对有限。[清单 13-8](chapter13.xhtml#list13-8) 给出了更新后的 AST，其中包含了 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型和浮点常量。
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-8: The abstract
    syntax tree with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">type and floating-point constants</samp>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-8：带有</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">类型和浮点常量的抽象语法树</samp>
- en: Your AST should represent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constants using the double-precision floating-point format, since that’s how they’ll
    be represented at runtime. You’ll need to look up which type in your implementation
    language uses this format. If you use a representation with less precision than
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, you might not be
    able to represent the closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to every constant in the source code, so you’ll end up with incorrectly rounded
    constants in the compiled program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 AST 应该使用双精度浮点格式表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    常量，因为它们在运行时就是以这种格式表示的。你需要查找在你的实现语言中，哪种类型使用这种格式。如果你使用的表示方式比 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    精度低，你可能无法准确表示源代码中每个常量最接近的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    值，从而导致编译后的程序中常量的四舍五入错误。
- en: Surprisingly, storing constants with *more* precision than <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can also cause problems. Storing a floating-point number in a higher-precision
    format and then rounding to a lower-precision format can produce a different result
    than rounding exactly once. This phenomenon is called *double rounding error*.
    (The word *double* here refers to rounding twice, not to the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type.) We’ll explore double rounding error in more depth during assembly generation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，使用比 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 精度更高的格式存储常量也可能会导致问题。将浮点数存储为更高精度的格式后，再将其四舍五入到较低精度的格式，可能会产生与直接四舍五入一次不同的结果。这种现象被称为
    *双重四舍五入误差*。（这里的 *double* 指的是两次四舍五入，而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型。）我们将在生成汇编代码时更深入地探讨双重四舍五入误差。
- en: After updating the AST, we’ll make the corresponding changes to the grammar.
    [Listing 13-9](chapter13.xhtml#list13-9) shows the complete grammar with these
    changes bolded.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 AST 后，我们将对语法做出相应的更改。[清单 13-9](chapter13.xhtml#list13-9) 显示了包含这些更改的完整语法，已将更改部分加粗。
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-9: The grammar with
    the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">type specifier and floating-point constants</samp>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-9：带有</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">类型说明符和浮点常量的语法</samp>
- en: 'In the last two chapters, we had to deal with the many different ways to specify
    integer types. Luckily, there’s only one way to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    type: with the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> keyword.
    [Listing 13-10](chapter13.xhtml#list13-10) demonstrates how to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    when we process a list of type specifiers.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们不得不处理许多不同的整数类型指定方式。幸运的是，指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型只有一种方式：使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 关键字。[清单
    13-10](chapter13.xhtml#list13-10) 演示了在处理类型说明符列表时如何处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-10: Determining
    a type from a list of type specifiers</samp>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-10：从类型说明符列表中确定类型</samp>
- en: Either <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> should be
    the only specifier in the list, or it shouldn’t appear at all; it can’t be combined
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>,
    or any other type specifier we’ve introduced so far. (It can, however, appear
    alongside storage-class specifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp>.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要么 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 应该是列表中唯一的修饰符，要么根本不应该出现；它不能与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp>
    或我们迄今为止引入的任何其他类型修饰符一起使用（然而，它可以与存储类修饰符如 <samp class="SANS_TheSansMonoCd_W5Regular_11">static</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">extern</samp> 一起出现）。
- en: Next, we’ll convert floating-point constant tokens to constants in the AST.
    We saw earlier that most decimal constants can’t be represented exactly in binary
    floating point, so we’ll need to round them. According to the C standard, the
    rounding direction here is implementation-defined and doesn’t necessarily need
    to match the runtime rounding mode. We’ll use round-to-nearest mode here, like
    we do everywhere else. Your implementation language’s built-in string-to-floating
    point conversion utilities should handle this correctly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把浮点常量标记转换为抽象语法树（AST）中的常量。我们之前看到，大多数十进制常量在二进制浮点表示中无法精确表示，因此我们需要对它们进行四舍五入。根据
    C 标准，这里的舍入方向是由实现决定的，不一定需要与运行时舍入模式匹配。我们在这里使用四舍五入模式，就像在其他地方一样。你的实现语言的内置字符串到浮点数转换工具应能正确处理此问题。
- en: When we parse integer constants, we need to ensure that they’re within the range
    the type can hold. Floating-point constants, however, can’t go out of range. Since
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> supports positive
    and negative infinity, its range includes all real numbers. So, our parser shouldn’t
    run into any errors when parsing <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constants.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解析整数常量时，需要确保它们在该类型可表示的范围内。然而，浮点常量不能超出范围。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    支持正无穷大和负无穷大，它的范围包括所有实数。因此，我们的解析器在解析 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    常量时不会遇到任何错误。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">类型检查器</samp>'
- en: 'We’ll make a handful of changes to account for <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    in the type checker. First, we’ll make sure to annotate <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constants with the correct type. Then, we’ll update how we find the common real
    type of two values. The rule here is simple: if either value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    the common real type is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    [Listing 13-11](chapter13.xhtml#list13-11) shows how to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>
    helper function to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行一些修改，以便在类型检查器中考虑到 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。首先，我们将确保用正确的类型注释
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 常量。然后，我们将更新查找两个值的共同实数类型的方式。这里的规则很简单：如果任一值是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，那么共同实数类型就是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。[列表
    13-11](chapter13.xhtml#list13-11)展示了如何更新 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_common_type</samp>
    辅助函数以处理 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-11: Finding the
    common real type of two values</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-11：查找两个值的共同实数类型</samp>
- en: We also need to detect a couple of new type errors. The bitwise complement operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>, and the remainder operator,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>, accept only integer operands.
    We’ll validate that both of these operators are used correctly in <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp>.
    [Listing 13-12](chapter13.xhtml#list13-12) demonstrates how to type check the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp> operator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要检测一些新的类型错误。按位取反运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    和求余运算符 <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> 只接受整数操作数。我们将验证这两个运算符在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_exp</samp> 中的正确使用。[列表
    13-12](chapter13.xhtml#list13-12)演示了如何对 <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>
    运算符进行类型检查。
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-12: Type checking
    a bitwise complement expression</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表13-12：类型检查按位补码表达式</samp>
- en: First, we type check the operand. Then, we validate that the operand is an integer
    ❶. Finally, we annotate the expression with the type of its result. Only the validation
    step differs from earlier chapters. We can handle the <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>
    operator in a similar way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们对操作数进行类型检查。然后，我们验证操作数是否为整数❶。最后，我们用其结果的类型注解该表达式。只有验证步骤与早期章节不同。我们可以以类似的方式处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">%</samp>运算符。
- en: 'To wrap up the changes to the type checker, we’ll deal with static variables
    of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. We’ll add
    a new kind of initializer for these variables:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结类型检查器的变更，我们将处理类型为<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>的静态变量。我们将为这些变量添加一种新的初始化器：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As usual, we’ll convert each initializer to the type of the variable it initializes,
    using the same rules that we’d apply at runtime. The C standard requires us to
    truncate toward zero when we convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an integer type. For example, we would convert <samp class="SANS_TheSansMonoCd_W5Regular_11">2.8</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. If the truncated value
    is out of range of the resulting integer type, the result is undefined, so you
    can handle it however you like. The cleanest option here is to just throw an error.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们会将每个初始化器转换为它初始化的变量类型，使用在运行时应用的相同规则。C标准要求我们在将<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>转换为整数类型时进行向零截断。例如，我们会将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2.8</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。如果截断后的值超出结果整数类型的范围，则结果是未定义的，因此你可以根据需要处理它。最干净的做法是直接抛出错误。
- en: When we convert an integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    we’ll preserve its value if it can be represented exactly. Otherwise, we’ll round
    to the nearest representable value. You should be able to use your implementation
    language’s built-in type conversion utilities to cast from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to integer types and vice versa.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个整数转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>时，如果它能够被精确表示，我们将保留其值。否则，我们将舍入到最接近的可表示值。你应该能够使用你所使用的实现语言的内置类型转换工具从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>转换为整数类型，反之亦然。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: In TACKY, we’ll add a few new instructions to handle conversions between <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> and integer types. [Listing
    13-13](chapter13.xhtml#list13-13) gives the updated TACKY IR.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在TACKY中，我们将添加一些新指令来处理<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>和整数类型之间的转换。[列表13-13](chapter13.xhtml#list13-13)给出了更新后的TACKY
    IR。
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-13: Adding conversions
    between</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">and the integer types to TACKY</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表13-13：在TACKY中添加double和整数类型之间的转换</samp>
- en: '[Listing 13-13](chapter13.xhtml#list13-13) introduces four new instructions
    to convert between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the signed and unsigned integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>. We don’t
    have different instructions for integer operands of different sizes; for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp> can cast to either
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13-13](chapter13.xhtml#list13-13)介绍了四条新指令，用于在<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>和有符号与无符号整数类型之间转换：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>。对于不同大小的整数操作数，我们没有不同的指令；例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>可以转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>。'
- en: To update the TACKY generation pass, just emit the appropriate cast instruction
    when you encounter a cast to or from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 TACKY 生成通道，只需在遇到转换为或从 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    时发出适当的转换指令。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Floating-Point Operations in Assembly</samp>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编中的浮点操作</samp>
- en: Before we get to work on the assembly generation pass, we need to understand
    how to work with floating-point numbers in assembly. Because floating-point numbers
    use a completely different binary representation from signed and unsigned integers,
    we can’t operate on them with our existing arithmetic instructions. Instead, we’ll
    use a set of specialized instructions called the *Streaming SIMD Extension (SSE)*
    instructions. This instruction set includes operations on both floating-point
    values and integers. It gets its name because it includes *single-instruction,
    multiple data (SIMD)* instructions, which perform the same operation on a vector
    of several values simultaneously (or two vectors of values, in the case of binary
    operations). For example, a SIMD addition instruction whose operands were the
    two-element vectors <samp class="SANS_TheSansMonoCd_W5Regular_11">[1.0, 2.0]</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">[4.0, 6.0]</samp> would add
    their corresponding elements together to produce the vector <samp class="SANS_TheSansMonoCd_W5Regular_11">[5.0,
    8.0]</samp>.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写汇编生成通道之前，我们需要理解如何在汇编中处理浮点数。因为浮点数采用与有符号和无符号整数完全不同的二进制表示方式，我们不能使用现有的算术指令对它们进行操作。相反，我们将使用一组专用指令，称为*流式
    SIMD 扩展（SSE）*指令。这个指令集包括对浮点值和整数的操作。它之所以得名，是因为它包含了*单指令，多数据（SIMD）*指令，这些指令在一个包含多个值的向量上同时执行相同的操作（或者在二元操作的情况下，在两个值向量上执行）。例如，一个
    SIMD 加法指令，其操作数为两个元素向量 <samp class="SANS_TheSansMonoCd_W5Regular_11">[1.0, 2.0]</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">[4.0, 6.0]</samp>，将分别将它们对应的元素相加，得到向量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">[5.0, 8.0]</samp>。
- en: The term *SSE* is a bit misleading because only some SSE instructions perform
    SIMD operations on vectors. Others operate on single values. When we talk about
    SSE instructions, we refer to vectors as *packed* operands and single values as
    *scalar* operands. SSE instructions that use these different types of operands
    are called packed and scalar instructions, respectively. Our implementation will
    primarily use scalar instructions, although we will need one packed instruction.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*SSE* 这个术语有点误导，因为只有一些 SSE 指令对向量执行 SIMD 操作。其他的则对单一值进行操作。当我们谈论 SSE 指令时，我们将向量称为*打包*操作数，而将单一值称为*标量*操作数。使用这些不同类型操作数的
    SSE 指令分别被称为打包指令和标量指令。我们的实现将主要使用标量指令，尽管我们将需要一个打包指令。'
- en: The SSE instructions were first introduced as an extension to the x86 instruction
    set; they weren’t available on every x86 processor. Over time, new groups of SSE
    instructions were added, creatively named SSE2, SSE3, and SSE4\. The SSE and SSE2
    instructions were eventually incorporated into the core x64 instruction set, so
    they’re available on every x64 processor. The first generation of floating-point
    SSE instructions support only single-precision operands, which correspond to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> type in C. SSE2 added
    support for double-precision operands. Since we’re working with double-precision
    operands, we’ll use only SSE2 instructions in this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 指令最初作为 x86 指令集的扩展被引入；它们并非在每个 x86 处理器上都可用。随着时间的推移，新增了几组 SSE 指令，分别命名为 SSE2、SSE3
    和 SSE4。SSE 和 SSE2 指令最终被纳入到核心 x64 指令集，因此在每个 x64 处理器上都可以使用。第一代浮点 SSE 指令只支持单精度操作数，这些操作数对应
    C 语言中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp> 类型。SSE2 添加了对双精度操作数的支持。由于我们正在处理双精度操作数，因此本章中我们将仅使用
    SSE2 指令。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*The x64 and x86 instruction sets include an older set of floating-point instructions
    that were first introduced with the Intel 8087* floating-point unit (FPU)*, a
    separate processor that handled floating-point math. These are called* x87 *or*
    FPU instructions *(sometimes simply referred to as* floating-point instructions*).
    Be aware that some resources on floating-point assembly—particularly older ones—discuss
    only x87 instructions and don’t mention SSE.*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*x64 和 x86 指令集包括一套较旧的浮点指令，这些指令最早是在英特尔 8087* 浮点单元（FPU）*中引入的，该单元是一个处理浮点运算的独立处理器。这些指令被称为*
    x87 *或* FPU 指令*（有时简称为*浮点指令*）。请注意，一些关于浮点汇编的资源—特别是较旧的资源—仅讨论 x87 指令，而不提及 SSE。*'
- en: Just like the general-purpose instructions we’re already familiar with, SSE
    instructions take suffixes that describe their operands. Instructions that operate
    on scalar double-precision values use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp>
    suffix. Instructions that take packed double-precision values use the <samp class="SANS_TheSansMonoCd_W5Regular_11">pd</samp>
    suffix. Scalar and packed single-precision instructions use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ps</samp> suffixes, respectively.
    The next few sections introduce the SSE instructions we’ll need in this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们已经熟悉的通用指令一样，SSE 指令也使用描述其操作数的后缀。对标量双精度值进行操作的指令使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp>
    后缀。对打包双精度值进行操作的指令使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">pd</samp> 后缀。标量和打包单精度指令分别使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ss</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ps</samp>
    后缀。接下来的几节将介绍本章所需的 SSE 指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with SSE
    Instructions</samp>
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用 SSE 指令</samp>
- en: 'There are two major differences between SSE instructions and the assembly instructions
    you learned about in earlier chapters. The first difference is that SSE instructions
    use a separate set of registers, called the *XMM registers*. There are 16 XMM
    registers: XMM0, XMM1, and so on, up to XMM15\. Each XMM register is 128 bits
    wide, but we’ll use only their lower 64 bits. From now on, I’ll refer to all the
    non-XMM registers we know and love—like RAX, RSP, and so on—as *general-purpose
    registers*. SSE instructions can’t use general-purpose registers, and non-SSE
    instructions can’t use XMM registers. Both SSE and non-SSE instructions can refer
    to values in memory.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: SSE 指令和你在之前章节学习的汇编指令之间有两个主要区别。第一个区别是 SSE 指令使用一组单独的寄存器，称为 *XMM 寄存器*。共有 16 个 XMM
    寄存器：XMM0、XMM1，以此类推，直到 XMM15。每个 XMM 寄存器的宽度为 128 位，但我们只会使用它们的低 64 位。从现在开始，我将所有非
    XMM 寄存器（例如 RAX、RSP 等）称为 *通用寄存器*。SSE 指令不能使用通用寄存器，而非 SSE 指令也不能使用 XMM 寄存器。SSE 和非
    SSE 指令都可以引用内存中的值。
- en: The second difference is that SSE instructions can’t use immediate operands.
    If we need to use a constant in an SSE instruction, we’ll define that constant
    in read-only memory. Then, the constant can be accessed with RIP-relative addressing,
    just like a static variable. [Listing 13-14](chapter13.xhtml#list13-14), which
    computes <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> in assembly, illustrates
    how to use XMM registers and floating-point constants.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是 SSE 指令不能使用立即数操作数。如果我们需要在 SSE 指令中使用常量，我们将在只读内存中定义该常量。然后，可以通过 RIP 相对寻址访问该常量，就像访问静态变量一样。[清单
    13-14](chapter13.xhtml#list13-14) 计算 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>
    的汇编示例，演示了如何使用 XMM 寄存器和浮点常量。
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-14: Computing</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">1.0 + 1.0</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-14：计算</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">1.0
    + 1.0</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">在汇编中</samp>
- en: At the start of the listing, we define the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
    We can define and initialize this constant in almost exactly the same way as a
    static variable. The key difference is that we don’t store this value in the data
    or BSS section; instead, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.section
    .rodata</samp> directive to put it in the *read-only data section*. As the name
    suggests, the program can read data from this section at runtime, but it can’t
    write to it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在清单的开头，我们定义了常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>。我们几乎可以像定义静态变量一样定义并初始化这个常量。关键的不同之处在于，我们并不把这个值存储在数据或
    BSS 段中；相反，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">.section .rodata</samp>
    指令将它放在 *只读数据段* 中。顾名思义，程序在运行时可以从这个段读取数据，但不能写入数据。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">.section</samp> directive
    can be used to write to any section. We use it here because we don’t have a dedicated
    directive to write to the read-only data section the way we have dedicated <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.text</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> directives. In
    the object file format used on macOS, there are several read-only data sections;
    we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> directive
    to write to the section that holds 8-byte constants.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">.section</samp> 指令可以用来写入任何段。我们在这里使用它，因为我们没有专门的指令来写入只读数据段，正如我们有专门的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.text</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">.bss</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> 指令一样。在 macOS 使用的目标文件格式中，有几个只读数据段；我们将使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> 指令来写入包含 8 字节常量的段。
- en: We use a new directive, <samp class="SANS_TheSansMonoCd_W5Regular_11">.double</samp>,
    to initialize the memory address labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp>
    to the floating-point value <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> prefix on <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp>
    makes it a local label. As you learned back in [Chapter 4](chapter4.xhtml), local
    labels are omitted from the symbol table in the object file. Compilers typically
    use local labels for floating-point constants.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个新指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">.double</samp>，将标记为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp> 的内存地址初始化为浮点值 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>。<samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>
    前缀使得 <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp> 成为一个局部标签。正如你在[第4章](chapter4.xhtml)中学到的，局部标签会在目标文件的符号表中被省略。编译器通常使用局部标签来表示浮点常量。
- en: Now that we’ve defined the data we need, let’s look at the start of the assembly
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">one_plus_one</samp>. The
    first instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd .L_one(%rip),
    %xmm0</samp>, copies the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp>
    from memory into the XMM0 register. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    instruction, like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, copies
    data from one location to another. We’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    to copy values between XMM registers or between an XMM register and memory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了所需的数据，让我们看看汇编函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">one_plus_one</samp>
    的开头。第一条指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">movsd .L_one(%rip), %xmm0</samp>，将常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1.0</samp> 从内存复制到 XMM0 寄存器。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> 指令与 <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    指令类似，都是将数据从一个位置复制到另一个位置。我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    在 XMM 寄存器之间，或在 XMM 寄存器与内存之间复制值。
- en: Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    instruction to perform floating-point addition. This instruction adds the constant
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp> to the value in
    XMM0 and stores the result in XMM0\. The source of <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    can be an XMM register or a memory address, and the destination must be an XMM
    register.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> 指令执行浮点加法。该指令将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_one</samp> 中的常量加到 XMM0 中的值，并将结果存储回
    XMM0。<samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> 的源可以是一个 XMM 寄存器或一个内存地址，目标必须是一个
    XMM 寄存器。
- en: Now that you have a high-level understanding of how to use SSE instructions,
    let’s dig into some specifics. First, we’ll explore how the System V calling convention
    handles floating-point function arguments and return values. Then, we’ll cover
    how individual floating-point operations, like arithmetic, comparisons, and type
    conversions, are implemented in assembly. At that point, you’ll finally be ready
    to add floating-point support to the backend of your compiler.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对如何使用SSE指令有了一个高级的了解，我们来深入探讨一些具体的内容。首先，我们将探索System V调用约定如何处理浮点函数参数和返回值。接着，我们将讲解如何在汇编中实现个别浮点操作，例如算术运算、比较和类型转换。到那时，你将最终准备好为你的编译器后端添加浮点支持。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Floating-Point
    Values in the System V Calling Convention</samp>
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在System V调用约定中使用浮点值</samp>
- en: 'In [Chapter 9](chapter9.xhtml), you learned that a function’s first six arguments
    are passed in general-purpose registers and its return value is passed in the
    EAX register (or RAX, depending on its size). The System V calling convention
    handles floating-point values a bit differently: they’re passed and returned in
    XMM registers instead of general-purpose registers.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](chapter9.xhtml)中，你学习了函数的前六个参数是通过通用寄存器传递的，而返回值是通过EAX寄存器（或RAX，具体取决于其大小）传递的。System
    V调用约定处理浮点值的方式稍有不同：它们是通过XMM寄存器而不是通用寄存器传递和返回的。
- en: A function’s first eight floating-point arguments are passed in registers XMM0
    through XMM7\. Any remaining floating-point arguments are pushed onto the stack
    in reverse order, just like integer arguments are. Floating-point return values
    are passed in XMM0 instead of RAX. Consider the function in [Listing 13-15](chapter13.xhtml#list13-15),
    which takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> arguments,
    adds them together, and returns the result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的前八个浮点参数是通过寄存器XMM0到XMM7传递的。任何剩余的浮点参数都会按反向顺序压入堆栈，就像整数参数一样。浮点返回值通过XMM0传递，而不是RAX。考虑[清单13-15](chapter13.xhtml#list13-15)中的函数，它接受两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>参数，将它们相加并返回结果。
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-15: Adding two</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">arguments</samp>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单13-15：添加两个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">参数</samp>
- en: We could compile this function to the assembly in [Listing 13-16](chapter13.xhtml#list13-16).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个函数编译成[清单13-16](chapter13.xhtml#list13-16)中的汇编代码。
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-16:</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">add_double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单13-16：</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">add_double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">在汇编中的实现</samp>
- en: According to the System V calling convention, arguments <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> will be passed in registers
    XMM0 and XMM1, respectively. The instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd
    %xmm1, %xmm0</samp> will therefore add <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, storing the result
    in XMM0\. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values
    are returned in XMM0, the function’s return value is already in the right place
    after that <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp> instruction.
    At that point, the function can return immediately. This code is more optimized
    than what your compiler will produce—it doesn’t include the function prologue
    and epilogue, for example—but it illustrates how to pass and return floating-point
    values in assembly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据System V调用约定，参数<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>将分别通过寄存器XMM0和XMM1传递。因此，指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">addsd %xmm1, %xmm0</samp>将会把<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>上，并将结果存储在XMM0中。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值是通过XMM0返回的，因此函数的返回值在执行完该<samp
    class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>指令后已经在正确的位置。此时，函数可以立即返回。此代码比你的编译器生成的代码更优化——例如，它不包含函数的前言和尾声——但它展示了如何在汇编中传递和返回浮点值。
- en: When a function contains a mix of <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and integer arguments, it can be tricky to push the right arguments onto the stack
    in the right order. First, we need to assign parameters to registers, working
    from the start of the parameter list. Then, we push any remaining unassigned parameters
    of any type onto the stack, starting from the back of the parameter list. Let’s
    work through a few examples, starting with [Listing 13-17](chapter13.xhtml#list13-17).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数包含混合的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型和整数类型的参数时，将正确的参数按正确的顺序压入栈中可能会很棘手。首先，我们需要将参数分配给寄存器，从参数列表的开始处开始工作。然后，我们将任何剩余的未分配参数（无论类型如何）从参数列表的末尾开始推送到栈中。让我们通过一些例子来逐步解决，从
    [列表 13-17](chapter13.xhtml#list13-17) 开始。
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-17: A function declaration
    with integer and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">parameters</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-17：一个包含整数和</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">参数的函数声明</samp>
- en: This example is simple because we can pass every parameter in a register. [Figure
    13-2](#fig13-2) illustrates the state of each register just before invoking <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pass_parameters_1</samp> with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，因为我们可以通过寄存器传递每个参数。[图 13-2](#fig13-2)展示了在使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">pass_parameters_1</samp>
    函数并调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> 指令之前，各个寄存器的状态。
- en: '![](../images/fig13-2.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: Passing parameters
    from [Listing 13-17](chapter13.xhtml#list13-17) [Description](description-30.xhtml)</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-2：从 [列表 13-17](chapter13.xhtml#list13-17)
    传递参数 [描述](description-30.xhtml)</samp>
- en: '[Listing 13-18](chapter13.xhtml#list13-18) shows a slightly more complicated
    example, where some integer parameters are passed on the stack.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-18](chapter13.xhtml#list13-18)展示了一个稍微复杂的例子，其中一些整数参数通过栈传递。'
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-18: A function declaration
    with even more parameters</samp>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-18：一个包含更多参数的函数声明</samp>
- en: We’ll pass every <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    argument to this function in a register, but the last two integer arguments, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>,
    will be passed on the stack. [Figure 13-3](#fig13-3) illustrates where each parameter
    will wind up.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过寄存器将每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 参数传递给这个函数，但最后两个整数参数，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>，将通过栈传递。[图
    13-3](#fig13-3)展示了每个参数将落到的位置。
- en: '![](../images/fig13-3.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: Passing parameters
    from [Listing 13-18](chapter13.xhtml#list13-18) [Description](description-31.xhtml)</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-3：从 [列表 13-18](chapter13.xhtml#list13-18)
    传递参数 [描述](description-31.xhtml)</samp>
- en: After we’ve assigned parameters to all the available registers, only <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp> are left. Because
    we push stack arguments in reverse order, we push <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>
    first, then <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>, which puts
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> at the top of the stack.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将所有可用的寄存器分配给参数之后，只有 <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp> 剩下。因为我们按反向顺序将栈参数压入栈中，所以我们先压入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>，然后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>，这将使
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp> 位于栈的顶部。
- en: Finally, let’s consider the function declared in [Listing 13-19](chapter13.xhtml#list13-19).
    When we call this function, we’ll need to pass both <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and integer parameters on the stack.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑在 [列表 13-19](chapter13.xhtml#list13-19) 中声明的函数。当我们调用这个函数时，我们需要将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 和整数类型的参数都传递到栈中。
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-19: A function declaration
    with way too many parameters</samp>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-19：一个包含过多参数的函数声明</samp>
- en: We’ll pass the first six integer parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">i1</samp>
    through <samp class="SANS_TheSansMonoCd_W5Regular_11">i6</samp>, and the first
    eight <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> parameters,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">d1</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">d8</samp>,
    in registers. [Listing 13-20](chapter13.xhtml#list13-20) reproduces [Listing 13-19](chapter13.xhtml#list13-19),
    with parameters that will be passed on the stack bolded.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把前六个整数参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">i1</samp> 到 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">i6</samp>，以及前八个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型参数，<samp class="SANS_TheSansMonoCd_W5Regular_11">d1</samp> 到 <samp class="SANS_TheSansMonoCd_W5Regular_11">d8</samp>，放在寄存器中。[Listing
    13-20](chapter13.xhtml#list13-20) 复制了 [Listing 13-19](chapter13.xhtml#list13-19)，并且将传递在堆栈上的参数加粗显示。
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-20: The declaration
    of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">pass_parameters_3</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, with parameters passed on the stack
    bolded</samp>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-20: The declaration
    of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">pass_parameters_3</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">, with parameters passed on the stack
    bolded</samp>'
- en: Going in reverse order, we’ll push <samp class="SANS_TheSansMonoCd_W5Regular_11">i9</samp>,
    then <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">d11</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">d10</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">d9</samp>. [Figure 13-4](#fig13-4)
    illustrates where we’ll put each parameter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相反的顺序，我们将依次压入 <samp class="SANS_TheSansMonoCd_W5Regular_11">i9</samp>，然后是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i8</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">d11</samp>，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i7</samp>，<samp class="SANS_TheSansMonoCd_W5Regular_11">d10</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">d9</samp>。[Figure 13-4](#fig13-4)
    图示了我们将把每个参数放置的位置。
- en: '![](../images/fig13-4.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: Passing parameters
    from [Listing 13-19](chapter13.xhtml#list13-19) [Description](description-32.xhtml)</samp>'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: Passing parameters
    from [Listing 13-19](chapter13.xhtml#list13-19) [Description](description-32.xhtml)</samp>'
- en: Now that we understand how our calling convention handles floating-point values,
    let’s look at basic arithmetic and comparisons.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了调用约定如何处理浮点值，让我们来看一下基本的算术和比较操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Doing Arithmetic
    with SSE Instructions</samp>
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用SSE指令进行算术运算</samp>
- en: 'We need to support five arithmetic operations on floating-point numbers: addition,
    subtraction, multiplication, division, and negation. We’ve already seen an example
    of addition with the <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    instruction. There are equivalent SSE instructions for the other binary operations:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp> for subtraction, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp> for multiplication, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp> for division. All four of
    these SSE instructions follow the same pattern as the integer <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>
    instructions: take a source and destination operand, use them in a binary operation,
    and store the result in the destination. These four floating-point instructions
    all require an XMM register or memory address as a source and an XMM register
    as a destination. Floating-point division follows the same pattern as the other
    arithmetic instructions; it doesn’t require special handling like integer division
    does.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要支持五种浮点数算术操作：加法、减法、乘法、除法和取反。我们已经看到过一个使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    指令进行加法的例子。其他的二元操作也有对应的SSE指令：减法使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>，乘法使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp>，除法使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp>。这四条SSE指令的模式与整数的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> 指令相同：接收一个源操作数和一个目标操作数，进行二元操作，并将结果存储到目标操作数中。这四条浮点指令都需要一个XMM寄存器或内存地址作为源操作数，以及一个XMM寄存器作为目标操作数。浮点除法遵循与其他算术指令相同的模式，不需要像整数除法那样特殊处理。
- en: There’s no floating-point negation instruction. To negate a floating-point value,
    we’ll XOR it with <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>, which
    has its sign bit set but is otherwise all zeros. This has the effect of flipping
    the value’s sign bit, which negates it. This operation correctly negates normal
    numbers, subnormal numbers, positive and negative zero, and positive and negative
    infinity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 没有浮点取反指令。为了取反浮点值，我们将其与<samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>进行异或，后者的符号位已设置，但其他位均为零。这将翻转值的符号位，从而实现取反操作。该操作正确地取反了正常数、非正规数、正负零以及正负无穷大。
- en: The only complication is that there’s no <samp class="SANS_TheSansMonoCd_W5Regular_11">xorsd</samp>
    instruction to XOR two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s.
    Instead, we’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    instruction, which XORs two packed vectors of two <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s
    each. Each operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    is 16 bytes wide; the lower 8 bytes hold the first element of the vector and the
    upper 8 bytes hold the second. We’ll use the lower 8 bytes of each operand and
    ignore the upper bytes. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>
    and the other arithmetic floating-point instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    takes an XMM register or memory address as a source operand and an XMM register
    as a destination. Unlike those other instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    only accepts memory addresses that are 16-byte aligned; using a misaligned source
    operand causes a runtime exception.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的复杂之处在于，不能使用<samp class="SANS_TheSansMonoCd_W5Regular_11">xorsd</samp>指令来对两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>进行异或。相反，我们将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>指令，它会对两个包含各两个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>的打包向量进行异或操作。每个<samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>的操作数宽度为16字节；低8字节存储向量的第一个元素，高8字节存储第二个元素。我们将使用每个操作数的低8字节，并忽略高字节。像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>和其他算术浮点指令一样，<samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>使用XMM寄存器或内存地址作为源操作数，并使用XMM寄存器作为目标。与其他指令不同，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>仅接受16字节对齐的内存地址；使用未对齐的源操作数会导致运行时异常。
- en: 'Suppose we want to negate the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>, then store the
    result in <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>. First,
    we define the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要取反<samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>处的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值，并将结果存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>。首先，我们定义常量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>：
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.align 16</samp> directive
    to ensure that this constant is 16-byte aligned. Next, we XOR it with our source
    value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">.align 16</samp>指令来确保该常量是16字节对齐的。接下来，我们将其与源值进行异或（XOR）操作：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp> instruction
    moves the source value into the lower 8 bytes of XMM0, zeroing out the upper 8
    bytes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction
    XORs the lower 8 bytes of XMM0 with the 8-byte value at <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_negative.zero</samp>,
    which is <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. It simultaneously
    XORs the upper 8 bytes of XMM0 with 8 bytes of whatever happens to immediately
    follow <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> in memory. After
    this instruction, the lower bytes of XMM0 hold our negated value, and the upper
    8 bytes hold junk. The final <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    instruction copies the lower bytes of XMM0 to their final destination at <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条<samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>指令将源值移动到XMM0的低8字节，并将高8字节置零。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>指令将XMM0的低8字节与<samp class="SANS_TheSansMonoCd_W5Regular_11">.L_negative.zero</samp>处的8字节值进行异或，后者是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>。它同时将XMM0的高8字节与紧接在内存中<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>后面的8字节进行异或。执行此指令后，XMM0的低字节保存了我们取反的值，而高8字节则是无效的。最后一条<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>指令将XMM0的低字节复制到最终目的地<samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>。
- en: We’ll also use <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> to
    zero out registers. Because the result of XORing any number with itself is 0,
    an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd %xmm0,
    %xmm0</samp> is the easiest way to zero out a floating-point register.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> 来清零寄存器。由于任何数字与自身异或的结果为
    0，像 <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd %xmm0, %xmm0</samp> 这样的指令是清零浮点寄存器的最简单方法。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*The XOR trick works for general-purpose registers too; for example, xorq %rax,
    %rax will zero out RAX. In fact, most compilers zero out both floating-point and
    general-purpose registers this way because it’s slightly faster than using a mov
    instruction. Since we’re prioritizing clarity and simplicity over performance,
    we use mov instead of xor to zero out general-purpose registers. But for XMM registers,
    zeroing with xor is the simpler option.*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*XOR技巧同样适用于通用寄存器；例如，xorq %rax, %rax 会将 RAX 清零。实际上，大多数编译器会以这种方式清零浮点寄存器和通用寄存器，因为这种方法比使用
    mov 指令稍微快一些。由于我们更注重清晰和简洁而非性能，所以我们使用 mov 来清零通用寄存器。但对于 XMM 寄存器，使用 xor 来清零是更简单的选择。*'
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Comparing Floating-Point
    Numbers</samp>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮点数比较</samp>'
- en: 'We’ll compare floating-point values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    instruction, which works similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>.
    Executing <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd b, a</samp> sets
    ZF to 1 if the values are equal and 0 otherwise. It sets CF to 1 if <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and 0 otherwise.
    These are the same flags that characterize the result of an unsigned comparison.
    Unlike <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    instruction always sets SF and OF to 0\. We’ll therefore use the same condition
    codes for floating-point comparisons that we use for unsigned comparisons: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">A</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> 指令比较浮点值，其工作原理类似于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>。执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd
    b, a</samp> 时，如果两个值相等，ZF 设置为 1，反之为 0。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    小于 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，CF 设置为 1，否则为 0。这些标志与无符号比较的结果相同。与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> 不同，<samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    指令始终将 SF 和 OF 设置为 0。因此，我们将使用与无符号比较相同的条件码进行浮点比较：<samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>。
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction
    handles subnormal numbers, infinity, and negative zero correctly without any special
    effort on our part. It treats <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> as equal, like the
    IEEE 754 standard requires. Handling NaN, which is an extra credit feature in
    this chapter, *does* require special effort. When either operand is NaN, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> reports an *unordered* result,
    which we can’t detect with the condition codes we’ve learned about so far. For
    more details, see “Extra Credit: NaN” on [page 342](#pg_342).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> 指令能够正确处理次正规数、无穷大和负零，而无需我们额外操作。它将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>
    视为相等，正如 IEEE 754 标准要求的那样。处理 NaN（本章的额外内容）*确实*需要特别处理。当任一操作数为 NaN 时，<samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    会报告*无序*结果，而这个结果我们无法通过到目前为止学习的条件码检测到。有关更多细节，请参见 [第342页](#pg_342)的“额外内容：NaN”。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between
    Floating-Point and Integer Types</samp>
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮点类型与整数类型之间的转换</samp>
- en: 'In [Listing 13-13](chapter13.xhtml#list13-13), we defined TACKY instructions
    for four different type conversions: <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>. The SSE
    instruction set includes conversions to and from signed integer types, so implementing
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>
    is easy. It doesn’t include conversions to and from unsigned integer types, so
    implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp> takes a
    little ingenuity. There’s more than one way to implement these trickier conversions;
    we’ll implement them roughly the same way that GCC does.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单13-13](chapter13.xhtml#list13-13)中，我们为四种不同的类型转换定义了TACKY指令：<samp class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>。SSE指令集包括有符号整数类型的转换，因此实现<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">IntToDouble</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToInt</samp>非常容易。它不包括无符号整数类型之间的转换，因此实现<ssamp
    class="SANS_TheSansMonoCd_W5Regular_11">UIntToDouble</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">DoubleToUInt</samp>则需要一些巧思。实现这些更为复杂的转换方式有不止一种方法，我们将以大致与GCC相同的方式实现它们。
- en: Let’s walk through these four conversions one at a time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讲解这四种转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a double to a Signed
    Integer</samp>
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将double转换为有符号整数</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> instruction
    converts a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to a signed
    integer. It truncates its source operand toward zero, which is what the C standard
    requires for conversions from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to integer types. This instruction takes a suffix that indicates the size of the
    result: <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2sil</samp> converts
    the source value to a 32-bit integer, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    converts it to a 64-bit integer.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp>指令将<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>转换为有符号整数。它会将源操作数截断到零，这是C标准对于从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>到整数类型转换的要求。此指令接受一个后缀，表示结果的大小：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2sil</samp>将源值转换为32位整数，<samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>将其转换为64位整数。
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent
    a much wider range of values than either <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, the source of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> might be outside the
    range of the destination type. In that case, the instruction results in the special
    *indefinite integer* value, which is the minimum integer the destination type
    supports. It also sets a status flag indicating that the operation was invalid.
    Converting a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to an
    integer type is undefined behavior when it’s outside the range of that type, so
    we’re free to handle this case however we want. We’ll just use the indefinite
    integer as the result of the conversion and ignore the status flag.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>可以表示比<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>更广泛的数值范围，因此<samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp>的源值可能超出目标类型的范围。在这种情况下，指令会返回特殊的*不确定整数*值，这个值是目标类型所能支持的最小整数。同时，它会设置一个状态标志，表示操作无效。当将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>转换为整数类型时，如果超出了该类型的范围，这是未定义行为，因此我们可以自由地处理这种情况。我们将使用不确定整数作为转换结果，并忽略状态标志。
- en: 'A more user-friendly compiler might check the status flag and raise a runtime
    error when a conversion is out of range, instead of silently returning a bogus
    result. It might do the same for the conversions from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to the unsigned integer types, which we’ll consider next. Our approach makes it
    easy for C programmers to shoot themselves in the foot, but at least we’re in
    good company: by default, GCC and Clang handle out-of-range conversions the same
    way we do.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更加用户友好的编译器可能会检查状态标志，并在转换超出范围时引发运行时错误，而不是默默返回一个虚假的结果。它也可能对从 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    到无符号整数类型的转换进行相同的处理，我们接下来将讨论这个问题。我们的方法虽然容易让 C 程序员“自作自受”，但至少我们并不孤单：默认情况下，GCC 和 Clang
    也会以与我们相同的方式处理超出范围的转换。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a double to an
    Unsigned Integer</samp>
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将 double 转换为无符号整数</samp>
- en: 'It’s not always possible to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an unsigned integer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp>
    instruction. We’ll run into trouble when the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    is in the range of an unsigned integer type but outside the range of the corresponding
    signed type. Consider the following C cast expression:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总能使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> 指令将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 转换为无符号整数。当 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    位于无符号整数类型的范围内，但超出了相应有符号类型的范围时，我们就会遇到问题。考虑以下 C 类型转换表达式：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This should evaluate to <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp>,
    which is a perfectly valid <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>. But if we try to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290.0</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2sil</samp> instruction,
    it will produce the indefinite integer instead of the right answer, because that
    value is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp>. There’s no SSE instruction to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to an unsigned integer, either. We’ll need to be a bit clever to work around these
    limitations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这应评估为 <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp>，它是一个完全有效的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>。但是，如果我们尝试使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2sil</samp> 指令将 <samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290.0</samp>
    转换，它将产生不确定的整数，而不是正确的答案，因为该值超出了 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    int</samp> 的范围。同时也没有 SSE 指令可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    转换为无符号整数。我们需要有些聪明才智来解决这些限制。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*A newer instruction set extension called* AVX *does include conversions from
    double to unsigned integer types, but not all x64 processors support this extension.*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*一种更新的指令集扩展，名为* AVX *，确实包括了从 double 到无符号整数类型的转换，但并不是所有的 x64 处理器都支持此扩展。*'
- en: To convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, we’ll first
    convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>
    and then truncate the result. For example, to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    in XMM0 to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    and then store it on the stack, we can use the assembly in [Listing 13-21](chapter13.xhtml#list13-21).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>，我们首先将其转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>，然后截断结果。例如，要将
    XMM0 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> 并将其存储到栈上，我们可以使用 [Listing
    13-21](chapter13.xhtml#list13-21) 中的汇编代码。
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-21: Converting a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned int</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-21：将</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的汇编代码</samp>
- en: Any value in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> is also in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    will handle it correctly. If the value is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>, the behavior is undefined, so we don’t care what the result will be.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 所有位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号整型</samp> 范围内的值，也在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">有符号长整型</samp> 范围内，因此 <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    会正确处理这些值。如果值超出了 <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号整型</samp> 的范围，行为是未定义的，因此我们不关心结果会是什么。
- en: Converting from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> is trickier.
    First, we’ll check whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    we want to convert is in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp>. If it is, we can convert it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    instruction. If it’s not, we’ll subtract the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    from our <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to get a
    result in the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>.
    We’ll convert that result to an integer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    instruction, then add <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    again after the conversion. [Listing 13-22](chapter13.xhtml#list13-22) demonstrates
    how we might convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    stored in XMM0 to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>
    in RAX.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号长整型</samp>
    更加复杂。首先，我们检查要转换的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 是否位于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">有符号长整型</samp> 的范围内。如果是，我们可以通过 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> 指令进行转换。如果不是，我们将从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 中减去 <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    的值，以便得到一个落在 <samp class="SANS_TheSansMonoCd_W5Regular_11">有符号长整型</samp> 范围内的结果。然后，我们将该结果通过
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> 指令转换为整数，转换后再加上
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。 [列表 13-22](chapter13.xhtml#list13-22)
    演示了如何将存储在 XMM0 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    转换为 RAX 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号长整型</samp>。
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-22: Converting a</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned long</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp>'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-22：将一个</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">无符号长整型</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">在汇编中的实现</samp>
- en: We define a constant <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    with a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    or 2^(63) ❶. To perform the conversion, we first check whether the value in XMM0
    is below this constant ❷. If it is, we can convert it to an integer with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> instruction ❸, then
    jump over the instructions for the other case.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个常量 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，其值为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，即 2^(63) ❶。为了执行转换，首先我们检查
    XMM0 中的值是否低于这个常量 ❷。如果是，我们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    指令将其转换为整数 ❸，然后跳过处理其他情况的指令。
- en: If XMM0 is greater than the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>
    constant, it’s too large for <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    to convert. To handle this case, we jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_out_of_range</samp>
    label. We first copy the source value into XMM1 to avoid overwriting the original
    value, then subtract <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>
    from it ❹. If the original value was within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>, the new value will be within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
    Therefore, we can convert XMM1 to a <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    instruction. (If the original value wasn’t within the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp>, the behavior is undefined according to the C standard and <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    will result in the indefinite integer.) At this point, the value in RAX is exactly
    2^(63) (or 9,223,372,036,854,775,808) less than the correct answer, so we add
    <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808</samp> to get
    the final result.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 XMM0 大于 <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>
    常量，那么它对 <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> 来说太大，无法转换。为了处理这种情况，我们跳转到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_out_of_range</samp> 标签。我们首先将源值复制到
    XMM1，以避免覆盖原始值，然后从中减去 <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>
    ❹。如果原始值在 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> 范围内，则新值将位于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 范围内。因此，我们可以使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp> 指令将 XMM1 转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">signed
    long</samp>。（如果原始值不在 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>
    范围内，行为将根据 C 标准未定义，<samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2siq</samp>
    将导致不确定的整数。）此时，RAX 中的值正好比正确答案小 2^(63)（或 9,223,372,036,854,775,808），因此我们加上 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808</samp> 以得到最终结果。
- en: '[Listing 13-22](chapter13.xhtml#list13-22) includes a decimal value, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>, which the assembler
    will convert to a double-precision floating-point number. It also includes floating-point
    subtraction. We know that both of these operations can potentially introduce rounding
    error. Could this rounding error lead to an incorrect result?'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 13-22](chapter13.xhtml#list13-22) 包含一个十进制值，<samp class="SANS_TheSansMonoCd_W5Regular_11">.L_upper_bound</samp>，汇编器将其转换为双精度浮点数。它还包含浮点数相减。我们知道，这两种操作都可能引入舍入误差。这个舍入误差会导致结果不正确吗？'
- en: Luckily for us, it won’t. We can prove that [Listing 13-22](chapter13.xhtml#list13-22)
    won’t require any rounding at all. First of all, <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>
    can be represented exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    where the significand is <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    and the exponent is <samp class="SANS_TheSansMonoCd_W5Regular_11">63</samp>. (That’s
    why we use this constant instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>,
    which <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> cannot represent
    exactly.) A <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can also
    represent the exact result of <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd
    .L_upper_bound(%rip), %xmm0</samp> in every case we care about. Specifically,
    we care about the cases where the source value is greater than or equal to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>, which is
    2^(63), but not greater than <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX</samp>,
    which is 2^(64) – 1\. That means we can write this value as 1.*x* × 2^(63), for
    some sequence of bits *x*. Because a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    has 53 bits of precision, *x* can’t be more than 52 bits long. When we subtract
    1 × 2^(63) from the source value, the result will be exactly *x* × 2^(62), which
    requires at most 52 bits of precision to represent exactly. (This is a special
    case of the *Sterbenz lemma*, in case you want to look it up.)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，它不会出现问题。我们可以证明 [示例 13-22](chapter13.xhtml#list13-22) 完全不需要任何舍入。首先，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp> 可以精确表示为一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，其中有效数字是 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，指数是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">63</samp>。（这就是我们使用这个常量而不是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp> 的原因，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    无法精确表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">LONG_MAX</samp>。）<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    还可以在我们关心的每种情况下精确表示 <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd .L_upper_bound(%rip),
    %xmm0</samp> 的结果。具体来说，我们关心的是源值大于或等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808.0</samp>（即
    2^(63)），但小于或等于 <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX</samp>（即
    2^(64) – 1）。这意味着我们可以将该值写为 1.*x* × 2^(63)，其中 *x* 是某个比特序列。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型具有 53 位精度，*x* 的长度不能超过 52 位。当我们从源值中减去 1 × 2^(63) 时，结果将是 *x* × 2^(62)，该结果最多需要
    52 位精度才能精确表示。（这是 *Sterbenz 引理* 的一个特例，如果你有兴趣可以查阅。）
- en: Therefore, this subtraction will give us an exact result, and adding <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808</samp>
    to that result after converting it to an integer will give us an exact final answer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这次减法会给我们一个精确的结果，转换为整数后再加上 <samp class="SANS_TheSansMonoCd_W5Regular_11">9223372036854775808</samp>
    将会得到一个精确的最终答案。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting a Signed Integer
    to a double</samp>
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将有符号整数转换为双精度浮点数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction
    converts a signed integer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    You write it with an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> suffix, depending on whether
    the source operand is a 32-bit or 64-bit integer. If the result can’t be represented
    exactly as a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, it will
    be rounded according to the CPU’s current rounding mode, which we can assume is
    round-to-nearest.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> 指令将一个有符号整数转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型。你可以根据源操作数是 32 位还是
    64 位整数，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>
    后缀。如果结果无法精确表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 类型，它将根据
    CPU 当前的舍入模式进行舍入，我们可以假设使用的是四舍五入到最近的模式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Converting an Unsigned Integer
    to a double</samp>
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">将无符号整数转换为双精度浮点数</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction
    interprets its source operand as a two’s complement value, meaning any value with
    its upper bit set gets converted to a negative <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Unfortunately, there’s no unsigned equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp>
    that we can use instead. We’re back in a similar situation to the previous section
    on unsigned integers, so we’ll rely on similar techniques.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp>指令将其源操作数解释为二进制补码值，这意味着任何上位位设置的值都会被转换为负的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。不幸的是，我们没有可以代替的无符号版本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp>指令。因此，我们又回到了类似于上一节关于无符号整数的情况，因此我们将依赖于类似的技术。
- en: To convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we can zero
    extend it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and then
    convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>. [Listing 13-23](chapter13.xhtml#list13-23)
    illustrates how we can use this approach to convert the unsigned integer <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一个<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，我们可以将其零扩展为<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，然后使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>将其转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。[Listing
    13-23](chapter13.xhtml#list13-23)展示了如何使用这种方法将无符号整数<samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp>转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-23: Converting an</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-23: 在汇编中将</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned int</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>'
- en: Recall that a <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction
    moves a value into a register’s lower 32 bits and zeroes out its upper 32 bits.
    The first instruction in this listing effectively moves and zero extends <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp> into the RAX register.
    This zero-extended number has the same value whether we interpret it as signed
    or unsigned, so the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    instruction will convert it correctly, storing the floating-point value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">4294967290.0</samp> in XMM0.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，<samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>指令将一个值移动到寄存器的低32位，并将其高32位清零。该示例中的第一条指令实际上是将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">4294967290</samp>移动到RAX寄存器中，并进行零扩展。这个零扩展后的数字，无论我们将其解释为有符号还是无符号，其值都是相同的，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>指令将正确转换它，将浮点值<samp class="SANS_TheSansMonoCd_W5Regular_11">4294967290.0</samp>存储在XMM0中。
- en: That leaves the conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. To
    handle this case, we’ll first check whether the value is in the range that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp> can represent. If it
    is, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    directly. Otherwise, we’ll halve the source value to bring it into the range of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>, convert it with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>, and then double
    the result of the conversion. A naive attempt to perform this conversion in assembly
    might look like [Listing 13-24](chapter13.xhtml#list13-24).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这就剩下从<samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>转换到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>的部分了。为了处理这种情况，我们首先检查值是否在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>能够表示的范围内。如果在范围内，我们可以直接使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>。否则，我们将源值减半，使其进入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp>的范围，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>进行转换，然后将转换结果乘以二。尝试在汇编中执行这种转换可能会像[Listing
    13-24](chapter13.xhtml#list13-24)一样。
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-24: Incorrectly
    converting an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned
    long</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    assembly</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 13-24: 在汇编中错误地将</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">无符号长整型</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>'
- en: We first check whether the source value, at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>,
    is out of bounds by performing a signed comparison to zero ❶. If the signed value
    is greater than or equal to zero, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    directly ❷ and then jump over the instructions for the out-of-range case.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查源值（位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>）是否越界，通过与零进行有符号比较
    ❶。如果该有符号值大于或等于零，我们可以直接使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    ❷，然后跳过处理越界情况的指令。
- en: Otherwise, we jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_out_of_range</samp>
    label. We copy the source value into RAX, then halve it by shifting it 1 bit to
    the right with the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    instruction ❸. (The mnemonic <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>
    is short for *shift right*.) Next, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    to convert the halved value to the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Finally, we add the result to itself, producing the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    representation of the original value (or at least the closest value that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> can represent exactly).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们跳转到 <samp class="SANS_TheSansMonoCd_W5Regular_11">.L_out_of_range</samp>
    标签。我们将源值复制到 RAX 中，然后通过将其右移 1 位，使用单目 <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    指令将其减半 ❸。（助记符 <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp> 是 *shift
    right* 的缩写。）接下来，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    将减半后的值转换为最接近的可表示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。最后，我们将结果加到自己身上，得到原始值的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 表示（或者至少是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    能精确表示的最接近的值）。
- en: 'But there’s a problem with this code: the result won’t always be correctly
    rounded. When we halve an integer with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>,
    we round down; halving <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>,
    for example, gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> as
    the result. If this rounded-down integer happens to be at the exact midpoint between
    two consecutive values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can represent, <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    might round down again, even though the original integer was closer to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> above it than the one below
    it. We’ve hit a double rounding error!'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这段代码存在一个问题：结果并不总是正确四舍五入。当我们用 <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    将一个整数减半时，会向下舍入；例如，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> 减半的结果是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。如果这个向下舍入的整数恰好位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    能表示的两个连续值之间的精确中点位置，<samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    可能再次向下舍入，尽管原始整数离上方的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    值更近，而不是下方的那个。这就造成了双重舍入错误！
- en: Let’s work through a concrete example. (To make this example more readable,
    I’ll bold the digits that differ between large numbers that are near each other.)
    We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    according to [Listing 13-24](chapter13.xhtml#list13-24). The closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values to our source operand are <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">5808.0</samp>, which is 1,025 less than
    the source value, and <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">7856.0</samp>, which is 1,023 more than
    it. We should convert the source value to the higher <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    since it’s closer.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来演示。（为了让这个例子更易读，我会将相邻大数之间不同的数字用**粗体**显示。）我们将根据[示例 13-24](chapter13.xhtml#list13-24)将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp>转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>类型。与我们的源操作数最接近的<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">5808.0</samp>，比源值少了1,025，以及<samp
    class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7856.0</samp>，比源值多了1,023。我们应该将源值转换为更高的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值，因为它更接近。
- en: 'Halving the source value with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    gives us <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">8416</samp>. This integer is exactly at
    the midpoint between two adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values: <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">7904.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">8928.0</samp>.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>将源值减半得到<samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">8416</samp>。这个整数正好位于两个相邻的<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值的中间：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7904.0</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">8928.0</samp>。
- en: Written out as a binary fraction, the lower value is
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以二进制分数形式写出时，较低的值是：
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'and the higher one is:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 而更高的一个是：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This notation shows us the significands of both values, written out with the
    full available precision. Since we round ties to even, we pick the value with
    a 0 in the least significant bit of the significand. In this particular example,
    that means rounding down, so <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp>
    produces the lower <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7904.0</samp>.
    We then add that to itself, which gives us a final answer of <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">5808.0</samp>. Instead of getting the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> just above our initial value,
    which was the correctly rounded result, we got the <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    just below it. [Figure 13-5](#fig13-5) illustrates how double rounding here leads
    to an incorrect result. (To reduce the size of the figure, we only show the first
    and last few digits of each number.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法显示了两个值的有效数位，写出了所有可用的精度。由于我们按四舍五入规则将值四舍五入到最接近的偶数，所以我们选择有效数位的最低有效位为0的那个值。在这个特定的例子中，这意味着向下舍入，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp>产生了较低的<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">7904.0</samp>。然后我们将其加到自身上，最终得到的答案是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">5808.0</samp>。我们并没有得到比初始值稍大的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，即正确的四舍五入结果，而是得到了比它稍小的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。 [图 13-5](#fig13-5)展示了双重舍入如何导致错误结果。（为了缩小图形大小，我们只显示了每个数字的前几位和最后几位。）
- en: '![](../images/fig13-5.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-5: A double rounding
    error when converting from an unsigned long to a double [Description](description-33.xhtml)</samp>'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-5：从无符号长整型转换到双精度浮点型时的双重四舍五入错误
    [描述](description-33.xhtml)</samp>
- en: The dotted arrow shows the correct rounding of <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/
    2</samp> to the nearest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    The two solid lines demonstrate the actual result of double rounding.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线箭头表示将 <samp class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">/
    2</samp> 四舍五入到最近的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    的正确结果。两条实线则展示了双重四舍五入的实际结果。
- en: To avoid this error, we need to make sure that when we halve the initial value,
    we don’t round the result to a midpoint between two values that <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can represent. We’ll do this with a technique called *rounding to odd*. When we
    halve the source value, we won’t truncate it toward zero. Instead, we’ll round
    to the nearest odd number. Using this rounding rule, we’ll round <samp class="SANS_TheSansMonoCd_W5Regular_11">9
    / 2</samp> up to <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> instead
    of down to <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. Similarly,
    we’ll round <samp class="SANS_TheSansMonoCd_W5Regular_11">7 / 2</samp> down to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, and we’ll round <samp
    class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/ 2</samp> up to <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">8417</samp>. If the result of dividing
    by 2 is already an integer, we don’t need to round; for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">16
    / 2</samp> will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>.
    (Only the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    needs to be rounded to odd; <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    will still round to nearest.)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种错误，我们需要确保在将初始值减半时，不会将结果四舍五入到两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    可以表示的值之间的中点。我们将使用一种名为 *四舍五入到奇数* 的技巧。当我们将源值减半时，不会将其截断为零，而是四舍五入到最近的奇数。使用这种四舍五入规则，我们将把
    <samp class="SANS_TheSansMonoCd_W5Regular_11">9 / 2</samp> 四舍五入到 <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>，而不是四舍五入到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。类似地，我们将把 <samp class="SANS_TheSansMonoCd_W5Regular_11">7
    / 2</samp> 四舍五入到 <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>，而将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">922337203685477</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">6833</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/ 2</samp> 四舍五入到 <samp class="SANS_TheSansMonoCd_W5Regular_11">461168601842738</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">8417</samp>。如果除以 2 的结果已经是一个整数，我们就不需要四舍五入；例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">16 / 2</samp> 仍然是 <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>。（只有
    <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> 的结果需要四舍五入到奇数；<samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    仍然会四舍五入到最近的值。）
- en: Rounding to odd works in this situation because the midpoints we want to avoid
    are always even integers. The gaps between binary floating-point numbers are always
    powers of 2, and they get bigger at larger magnitudes. Remember that we halve
    an integer for this conversion only if it’s too big to fit in a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>.
    The halved value will therefore be between <samp class="SANS_TheSansMonoCd_W5Regular_11">(LONG_MAX</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1)
    / 2</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX / 2</samp>.
    In that range, the gap between representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    values is 1,024, so every midpoint is a multiple of 512, which is even.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入到奇数在这种情况下有效，因为我们想避免的中点总是偶数。二进制浮点数之间的间隔总是 2 的幂，并且在更大的数量级上间隔会增大。请记住，我们仅在整数太大以至于无法适应
    <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> 时，才会对其进行减半转换。因此，减半后的值将在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">(LONG_MAX</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1) / 2</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ULONG_MAX
    / 2</samp> 之间。在这个范围内，可表示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    值之间的间隔是 1,024，因此每个中点都是 512 的倍数，而 512 是偶数。
- en: '[Figure 13-6](#fig13-6) illustrates a few different cases of rounding to odd
    in action.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-6](#fig13-6) 展示了几种不同的四舍五入到奇数的情况。'
- en: '![](../images/fig13-6.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig13-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-6: Using rounding
    to odd to avoid a double rounding error [Description](description-34.xhtml)</samp>'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 13-6：使用奇数舍入以避免双重舍入误差 [描述](description-34.xhtml)</samp>
- en: In the first case, rounding to odd prevents us from rounding to a midpoint and
    then down to an incorrect result. In the remaining cases, it doesn’t change the
    final result; whether we round these cases to odd or toward zero on the first
    rounding, we’ll get the same answer as if we’d rounded only once using round-to-nearest,
    ties-to-even mode. Sometimes rounding to odd is necessary to get the right answer,
    and sometimes it has no impact, but it never gives us the wrong answer.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，舍入到奇数可以防止我们将结果舍入到中点然后向下舍入到不正确的结果。在其余情况下，它不会改变最终结果；无论是在第一次舍入时舍入到奇数还是朝向零，我们得到的答案都与仅使用最近舍入、平均分割模式下舍入一次相同。有时舍入到奇数是必要的，以获得正确的答案，有时它没有影响，但它永远不会给我们错误的答案。
- en: Now that we understand why rounding to odd works, let’s figure out how to implement
    it in assembly. [Listing 13-25](chapter13.xhtml#list13-25) demonstrates how to
    halve the value stored in RAX and round the result to odd.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道为什么向奇数舍入有效了，让我们来看看如何在汇编中实现它。[清单 13-25](chapter13.xhtml#list13-25) 展示了如何将存储在
    RAX 中的值减半并将结果舍入为奇数。
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-25: Rounding to
    odd after halving an integer with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">shrq</samp>'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-25：使用 <samp class="SANS_Futura_Std_Book_Oblique_I_11">shrq</samp>
    减半整数后进行奇数舍入</samp>
- en: 'This listing includes two new instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>. If you did the extra
    credit section in [Chapter 3](chapter3.xhtml), you’re already familiar with them.
    These instructions perform bitwise AND and OR operations, respectively; they’re
    used exactly like our other instructions that perform binary operations on integers,
    including <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单包含两条新指令：<samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">or</samp>。如果你在[第 3 章](chapter3.xhtml)中做了额外的学分部分，你应该已经熟悉它们了。这些指令执行位与和位或操作，分别与我们的其他整数二进制操作指令（包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>）完全相同。
- en: Let’s figure out why this code works. First, we copy the value we want to halve
    into RDX and halve it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>.
    Next, we take the bitwise AND of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    and the original value in RAX; this produces <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    if the original value was odd and <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    if it was even.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码为什么有效。首先，我们将要减半的值复制到 RDX 中，并用 <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    减半。接下来，我们取原始值在 RAX 中和 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 的位与操作；如果原始值是奇数，则结果为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，如果是偶数，则为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: 'Now we need to decide what to do about the halved value in RDX. At this point,
    one of three things is true:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要决定如何处理 RDX 中的减半值。此时有三种可能性：
- en: The original value was even, so RDX contains the exact result of halving that
    value. Therefore, we don’t need to round it.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始值是偶数，因此 RDX 包含减半后的确切结果。因此，我们不需要再舍入。
- en: The original value was odd, and the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    is also odd. For example, if the original value was <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>,
    halving it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> will
    produce <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. In this case,
    the result is already rounded to odd and doesn’t need to change.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始值为奇数，并且 <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> 的结果也是奇数。例如，如果原始值是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>，用 <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    减半将得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。在这种情况下，结果已经舍入为奇数，无需更改。
- en: The original value was odd, and the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    is even. For example, if the original value was <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>,
    halving it with <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> will
    produce <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. In this case,
    the result is not rounded to odd, and we need to increment it.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始值是奇数，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> 的结果是偶数。例如，如果原始值是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    将其除以 2 会得到 <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。在这种情况下，结果没有四舍五入为奇数，我们需要将其递增。
- en: In each of these three cases, the final instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">orq
    %rax, %rdx</samp>, has the desired effect. In the first case, it does nothing
    because RAX is 0, thanks to the prior <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    instruction. In the second case, it does nothing because the least significant
    bit of RDX is already 1\. In the third case, it flips the least significant bit
    of RDX from 0 to 1 and makes the value odd.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种情况下，最后一条指令 <samp class="SANS_TheSansMonoCd_W5Regular_11">orq %rax, %rdx</samp>
    达到了预期效果。在第一种情况下，由于之前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp>
    指令，RAX 为 0，所以它不做任何操作。在第二种情况下，由于 RDX 的最低有效位已经是 1，它也不做任何操作。在第三种情况下，它将 RDX 的最低有效位从
    0 翻转为 1，并使得值变为奇数。
- en: Putting it all together, [Listing 13-26](chapter13.xhtml#list13-26) shows the
    complete assembly to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to a correctly rounded <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 综合来看，[清单 13-26](chapter13.xhtml#list13-26)展示了将一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> 转换为正确四舍五入的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    的完整汇编代码。
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-26: Correctly converting
    an</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned long</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">to a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">in assembly</samp>'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 13-26：在汇编中正确地将一个</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">unsigned long</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">转换为</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">类型</samp>
- en: 'This code is identical to the original conversion in [Listing 13-24](chapter13.xhtml#list13-24),
    except for the bolded changes: we round the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp>
    to odd and use the rounded value in RDX as the source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp>
    instruction.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[清单 13-24](chapter13.xhtml#list13-24)中的原始转换完全相同，唯一的不同之处在于加粗部分：我们将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">shrq</samp> 的结果四舍五入为奇数，并使用四舍五入后的值（在 RDX
    中）作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sdq</samp> 指令的源。
- en: We’ve now discussed how to implement every floating-point operation we need;
    we’re ready to update the assembly generation pass!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论了如何实现我们所需的每个浮点操作；我们准备更新汇编生成阶段！
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">汇编生成</samp>
- en: 'As usual, our first task is to update the assembly AST. We’ll add a new <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> assembly type:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，我们的第一项任务是更新汇编抽象语法树（AST）。我们将添加一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    汇编类型：
- en: '[PRE37]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ll also add a new top-level construct to represent floating-point constants:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个新的顶级构造，表示浮点常量：
- en: '[PRE38]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This construct is almost identical to <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>.
    The one difference is that we can omit the <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp>
    attribute, since we’ll never define global constants. For now, we’ll define only
    floating-point constants; in later chapters, we’ll use this construct to define
    constants of other types as well.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造几乎与 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticVariable</samp>
    相同。唯一的区别是我们可以省略 <samp class="SANS_TheSansMonoCd_W5Regular_11">global</samp> 属性，因为我们不会定义全局常量。目前，我们仅定义浮点常量；在后续章节中，我们将使用该构造来定义其他类型的常量。
- en: 'Next, we’ll add two new instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvtsi2sd</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si</samp>:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加两个新的指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">Cvtsi2sd</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Cvttsd2si</samp>：
- en: '[PRE39]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each of these takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp>
    parameter to specify whether it operates on <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> integers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作都需要一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type</samp>
    参数，用来指定它是作用于 <samp class="SANS_TheSansMonoCd_W5Regular_11">长字（Longword）</samp>
    还是 <samp class="SANS_TheSansMonoCd_W5Regular_11">四字（Quadword）</samp> 整数。
- en: 'We’ll reuse the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions to
    represent floating-point comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    and arithmetic with <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>, and so on. We’ll add
    a new <samp class="SANS_TheSansMonoCd_W5Regular_11">DivDouble</samp> binary operator
    to represent floating-point division. (Recall that the assembly AST doesn’t include
    a binary operator for integer division because <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> don’t follow the
    same pattern as the other arithmetic instructions.) We’ll also add the <samp class="SANS_TheSansMonoCd_W5Regular_11">Xor</samp>
    binary operator we need to negate floating-point values, as well as the bitwise
    <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp>
    operators we need to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用现有的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Cmp</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    指令来表示使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> 进行的浮点比较和使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>
    等进行的算术运算。我们还将添加一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">DivDouble</samp>
    二元操作符来表示浮点除法。（回忆一下，汇编 AST 并不包括整数除法的二元操作符，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> 的模式与其他算术指令不同。）我们还将添加用于取反浮点值的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Xor</samp> 二元操作符，以及用于将 <samp class="SANS_TheSansMonoCd_W5Regular_11">无符号长整数</samp>
    转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">双精度浮点数（double）</samp> 的位运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">And</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Or</samp>：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We need the unary <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp>
    operator for that type conversion too:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种类型的转换，我们还需要一元操作符 <samp class="SANS_TheSansMonoCd_W5Regular_11">Shr</samp>：
- en: '[PRE41]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we’ll add the XMM registers. We’ll need XMM0 through XMM7 for parameter
    passing, plus a couple more scratch registers for instruction rewrites. You can
    use any registers apart from XMM0 through XMM7 for scratch; I’ll use XMM14 and
    XMM15\. You can either add all 16 registers to the AST or just add the ones we
    need right now:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加 XMM 寄存器。我们需要 XMM0 到 XMM7 用于参数传递，再加上一些额外的临时寄存器用于指令重写。你可以使用 XMM0 到 XMM7
    之外的任何寄存器作为临时寄存器；我将使用 XMM14 和 XMM15。你可以将所有 16 个寄存器都添加到 AST 中，或者只添加当前需要的寄存器：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Listing 13-27](chapter13.xhtml#list13-27) gives the entire assembly AST, with
    changes bolded.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13-27](chapter13.xhtml#list13-27) 给出了完整的汇编 AST，其中的更改部分已加粗。'
- en: '[PRE43]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-27: The assembly
    AST with floating-point constants, instructions, and registers</samp>'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-27：带有浮点常量、指令和寄存器的汇编 AST</samp>
- en: We already understand how to perform floating-point operations in assembly,
    but there are a few implementation details we still need to discuss. We’ll deal
    with constants first.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何在汇编中执行浮点运算，但仍有一些实现细节需要讨论。我们将首先处理常量。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Floating-Point
    Constants</samp>'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮点常量</samp>'
- en: 'In previous chapters, we converted integer constants in TACKY to <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp>
    operands in assembly. This approach won’t work for floating-point constants. Instead,
    when we encounter a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constant in TACKY, we’ll generate a new top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    construct with a unique identifier. To use that constant in an instruction, we
    refer to it with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> operand,
    just like a static variable. For example, suppose we need to convert the following
    TACKY instruction to assembly:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们将 TACKY 中的整数常量转换为汇编中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp>
    操作数。对于浮点常量，这种方法不适用。相反，当我们遇到 TACKY 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    常量时，我们将生成一个具有唯一标识符的新的顶层 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    构造。为了在指令中使用该常量，我们像使用静态变量一样，通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    操作数来引用它。例如，假设我们需要将以下 TACKY 指令转换为汇编：
- en: '[PRE44]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'First, we’ll generate a unique label, <samp class="SANS_TheSansMonoCd_W5Regular_11">const_label</samp>,
    that won’t conflict with any of the names in the symbol table or any of the internal
    labels we use as jump targets. Then, we’ll define a new top-level constant like
    this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将生成一个唯一的标签 <samp class="SANS_TheSansMonoCd_W5Regular_11">const_label</samp>，该标签不会与符号表中的任何名称或我们作为跳转目标使用的内部标签冲突。然后，我们将像这样定义一个新的顶层常量：
- en: '[PRE45]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This top-level constant must be 8-byte aligned to conform to the System V ABI.
    After defining this constant, we’ll emit the following assembly instruction:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶层常量必须按 8 字节对齐，以符合 System V ABI。在定义此常量后，我们将生成以下汇编指令：
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Keep track of every <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    you define throughout the entire assembly generation pass. Then, at the end of
    this pass, add these constants to your list of top-level constructs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪您在整个汇编生成过程中定义的每一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>。然后，在该过程结束时，将这些常量添加到您的顶层构造列表中。
- en: Aside from constant handling, this example demonstrates a few things about assembly
    generation that won’t change. First, we’ll still convert the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction
    in assembly, whether we’re copying an integer or a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    Second, TACKY variables are still converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    operands, regardless of their type.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常量处理之外，这个示例还展示了汇编生成中的一些不变事项。首先，无论我们是复制整数还是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，我们依然会将
    TACKY 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> 指令转换为汇编中的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> 指令。其次，TACKY 变量仍然会被转换为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> 操作数，无论它们的类型是什么。
- en: 'There are a couple of optional tweaks you can make here to bring your top-level
    constants more in line with what a production compiler would generate:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可选的调整，您可以进行修改，以便让您的顶层常量更符合生产环境编译器生成的格式：
- en: '**Avoiding duplicate constants**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免重复常量**'
- en: Don’t generate multiple equivalent <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    constructs. Instead, whenever you see a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    constant in TACKY, check whether you’ve already generated a <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    with the same value and alignment. If you have, refer to that constant in your
    assembly code instead of generating a new one. Just keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> are distinct constants
    that require separate <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    constructs, even though they compare equal in most languages.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 不要生成多个等效的 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    构造。相反，每当您在 TACKY 中看到一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    常量时，请检查您是否已经生成了具有相同值和对齐方式的 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>。如果已经生成了，请在汇编代码中引用该常量，而不是生成一个新的常量。只需记住，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>
    是不同的常量，即使它们在大多数语言中比较时相等，仍然需要分别生成 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    构造。
- en: '**Using local labels for top-level constants**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用局部标签来处理顶层常量**'
- en: Compilers typically use local labels starting with <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>
    (on macOS) or <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> (on Linux)
    for floating-point constants, so they don’t show up as symbols in the final executable.
    (Recall that we already use local labels for jump targets.) If you want to follow
    this naming convention, don’t add the local label prefix just yet; wait until
    the code emission pass. For now, add top-level constants to the backend symbol
    table and use a new attribute to distinguish them from variables. [Listing 13-28](chapter13.xhtml#list13-28)
    shows how to update the original backend symbol table entry from [Listing 11-26](chapter11.xhtml#list11-26)
    to include this attribute.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常使用以 <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>（在macOS上）或 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>（在Linux上）开头的本地标签来表示浮点常量，这样它们就不会作为符号出现在最终的可执行文件中。（回想一下，我们已经为跳转目标使用了本地标签。）如果你想遵循这种命名约定，请暂时不要添加本地标签前缀；等到代码生成阶段再添加。现在，先将顶级常量添加到后端符号表中，并使用一个新属性将它们与变量区分开来。[示例
    13-28](chapter13.xhtml#list13-28) 展示了如何从[示例 11-26](chapter11.xhtml#list11-26)更新原始后端符号表条目，加入这个属性。
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-28: Definition of
    an entry in the backend symbol table, including the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is_constant</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">attribute</samp>'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 13-28：后端符号表中条目的定义，包括</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">is_constant</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">属性</samp>
- en: During code emission, we’ll use this new attribute to figure out which operands
    should get a local label prefix. The <samp class="SANS_TheSansMonoCd_W5Regular_11">is_static</samp>
    attribute should also be true for constants, since we store them in the read-only
    data section and access them with RIP-relative addressing. We’re waiting until
    code emission to add local labels instead of generating them right off the bat
    because it will be easier to extend this approach when we add more kinds of top-level
    constants in [Chapter 16](chapter16.xhtml).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码生成期间，我们将使用这个新属性来确定哪些操作数应该添加本地标签前缀。<samp class="SANS_TheSansMonoCd_W5Regular_11">is_static</samp>
    属性对于常量也应该为真，因为我们将常量存储在只读数据段中，并通过RIP相对寻址方式访问它们。我们会等到代码生成时才添加本地标签，而不是一开始就生成它们，因为当我们在[第16章](chapter16.xhtml)添加更多种类的顶级常量时，这种方法更容易扩展。
- en: Feel free to make both of these tweaks, skip both of them, or make one but not
    the other.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可以自由选择执行这两项修改，跳过这两项，或者只做其中一项。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unary Instructions,
    Binary Instructions, and Conditional Jumps</samp>
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一元指令、二元指令和条件跳转</samp>
- en: 'We’ll convert floating-point addition, subtraction, and multiplication instructions
    from TACKY to assembly just like their integer equivalents. Floating-point division
    will follow the same pattern as these other instructions, even though integer
    division doesn’t. Consider the following TACKY instruction:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像处理整数等效指令一样，将浮点加法、减法和乘法指令从 TACKY 转换为汇编。浮点除法将遵循与这些指令相同的模式，尽管整数除法则不然。考虑以下 TACKY
    指令：
- en: '[PRE48]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the type of its operands is <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>,
    we’ll generate the following assembly:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其操作数的类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，我们将生成以下汇编：
- en: '[PRE49]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We’ll also translate floating-point negation differently from its integer counterpart.
    To negate a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll
    XOR it with <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. For example,
    to translate the TACKY instruction
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将以不同于整数的方式来处理浮点数的取反操作。为了取反一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    类型的值，我们将它与 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> 进行异或操作。例如，要转换
    TACKY 指令
- en: '[PRE50]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'we’ll start by defining a new 16-byte-aligned constant:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义一个新的16字节对齐的常量开始：
- en: '[PRE51]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then we’ll generate the following assembly instructions:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将生成以下汇编指令：
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We need to align <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> to
    16 bytes so that we can use it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    instruction. This is the only time we align a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to 16 bytes instead of 8\. We don’t need to worry about the alignment of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>; <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>’s
    destination must be a register, and we’ll take care of that requirement during
    instruction fix-up.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> 对齐到 16 字节，以便在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> 指令中使用。这是我们唯一一次将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 对齐到 16 字节，而不是 8 字节。我们不需要担心
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> 的对齐；<samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    的目标必须是一个寄存器，我们将在指令修正过程中处理这个要求。
- en: 'Next, let’s talk about how to handle our relational binary operators: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>,
    and so on. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    sets the CF and ZF flags, we’ll handle floating-point comparisons just like unsigned
    integer comparisons. Here’s an example:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何处理关系二元运算符：<samp class="SANS_TheSansMonoCd_W5Regular_11">Equal</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> 等。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    设置了 CF 和 ZF 标志，因此我们将像无符号整数比较一样处理浮点数比较。以下是一个示例：
- en: '[PRE53]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are floating-point values, we’ll produce the following assembly:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    是浮点值，我们将生成以下汇编代码：
- en: '[PRE54]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We’ll take a similar approach to the three TACKY instructions that compare
    a value to zero: <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>, and the unary
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp> operation. We’ll convert'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用与三个 TACKY 指令相似的方法，这些指令将一个值与零进行比较：<samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp> 和一元 <samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp>
    操作。我们将进行转换。
- en: '[PRE55]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'to the following assembly:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下汇编代码：
- en: '[PRE56]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that we need to zero out an XMM register with <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    in order to perform the comparison. You don’t need to use XMM0 here, but you shouldn’t
    use the scratch registers you’ve chosen for the rewrite pass. It’s easier to avoid
    conflicting uses of registers if you strictly separate which registers you introduce
    in each backend pass.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> 清零一个 XMM
    寄存器，以便进行比较。在这里你不需要使用 XMM0，但不应使用在重写过程中选择的临时寄存器。如果你严格区分每个后端过程引入的寄存器，避免寄存器使用冲突会更加容易。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Conversions</samp>
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型转换</samp>
- en: Since we’ve already covered the assembly for each of our type conversions, I
    won’t present it again here, but I will flag a couple of details we haven’t discussed
    yet. First, you’ll need to choose which hard registers to use in these conversions.
    All four conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and the unsigned integer types use XMM registers, general-purpose registers, or
    both. For example, [Listing 13-26](chapter13.xhtml#list13-26) uses RAX and RDX
    to halve an integer and then round to odd. You don’t need to stick with the same
    registers we used when we walked through these conversions earlier; just avoid
    the callee-saved registers (RBX, R12, R13, R14, and R15) and the registers you
    use in the rewrite pass (R10 and R11, plus your two scratch XMM registers; mine
    are XMM14 and XMM15).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经覆盖了每种类型转换的汇编代码，因此这里不再重复，但我会标出一些我们尚未讨论的细节。首先，你需要选择用于这些转换的硬件寄存器。所有四种 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 与无符号整数类型之间的转换都使用 XMM 寄存器、通用寄存器或两者。例如，[列表
    13-26](chapter13.xhtml#list13-26) 使用 RAX 和 RDX 将整数减半并四舍五入为奇数。在这里你不需要坚持使用我们之前讲解这些转换时所用的寄存器；只需避免使用被调用方保存的寄存器（RBX、R12、R13、R14
    和 R15）以及你在重写过程中使用的寄存器（R10 和 R11，以及你的两个临时 XMM 寄存器；我的分别是 XMM14 和 XMM15）。
- en: Second, when you process a conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, be
    sure to generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instruction to explicitly zero extend the source value, rather than a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>
    instruction. This will become important when we implement register allocation
    in [Part III](part3.xhtml). We’ll use a technique called *register coalescing*
    to delete redundant <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions
    as we allocate registers; using <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> here signals
    that you’re using this instruction to zero out bytes and not just to move values
    around, so it shouldn’t be deleted.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，当你处理从 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> 到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的转换时，务必生成一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> 指令，显式地将源值零扩展，而不是使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> 指令。这一点在我们实现[第三部分](part3.xhtml)的寄存器分配时非常重要。我们将使用一种叫做*寄存器合并*的技术来删除冗余的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> 指令，在分配寄存器时；在这里使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> 而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>，表示你正在使用该指令清零字节，而不仅仅是移动值，因此不应将其删除。
- en: Concretely, if <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is an
    <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, you’ll translate
    the TACKY instruction
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 具体而言，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    int</samp>，你将转换TACKY指令
- en: '[PRE57]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'into this assembly:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 转换成以下汇编：
- en: '[PRE58]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can use a register other than RAX here, as long as it meets the requirements
    we just discussed.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用除RAX之外的其他寄存器，只要它满足我们刚刚讨论的要求。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Calls</samp>
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">函数调用</samp>
- en: 'The tricky part of handling floating-point values in function calls is figuring
    out where each argument is passed. We’ll use this information in two places. First,
    we’ll need it to pass arguments correctly when we translate the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction. Second, we’ll use it to set up parameters at the beginning of each
    function body. We’ll write a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>,
    to handle the bookkeeping we need in both of these places. Given a list of TACKY
    values, this helper function will convert each one to an assembly operand and
    determine its assembly type. It will also partition the list in three: one list
    of operands passed in general-purpose registers, one list of operands passed in
    XMM registers, and one list of operands passed on the stack. [Listing 13-29](chapter13.xhtml#list13-29)
    gives the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中处理浮动点值的棘手部分是弄清楚每个参数是如何传递的。我们将在两个地方使用这些信息。首先，当我们翻译TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    指令时，我们需要它来正确传递参数。其次，我们将在每个函数体的开始部分使用它来设置参数。我们将编写一个辅助函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>，来处理这两个地方所需的记账工作。给定一组TACKY值，这个辅助函数将把每个值转换为汇编操作数，并确定它的汇编类型。它还会将列表分成三部分：一部分是通过通用寄存器传递的操作数，一部分是通过XMM寄存器传递的操作数，另一部分是通过栈传递的操作数。[列表
    13-29](chapter13.xhtml#list13-29)给出了<ssamp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>的伪代码。
- en: '[PRE59]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-29: Classifying
    function arguments or parameters</samp>'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 13-29：分类函数参数或参数列表</samp>
- en: To process each parameter, we first convert it from a TACKY value to an assembly
    operand and convert its type to the corresponding assembly type. (I won’t give
    you the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type_of</samp>,
    which just finds the type of a TACKY value and converts it to assembly.) We package
    these up into a pair, <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp>
    ❶. The elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">int_reg_args</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp> will all be
    pairs in this form. The elements of <samp class="SANS_TheSansMonoCd_W5Regular_11">double_reg_args</samp>
    will be plain assembly operands; since they’re all <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>s,
    it would be redundant to specify each one’s type explicitly.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理每个参数，我们首先将其从TACKY值转换为汇编操作数，并将其类型转换为相应的汇编类型。（我不会给出<samp class="SANS_TheSansMonoCd_W5Regular_11">assembly_type_of</samp>的伪代码，它只是查找TACKY值的类型并将其转换为汇编类型。）我们将这些打包成一对，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp> ❶。<samp class="SANS_TheSansMonoCd_W5Regular_11">int_reg_args</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>的元素将都是这种形式的对。<samp class="SANS_TheSansMonoCd_W5Regular_11">double_reg_args</samp>的元素将是普通的汇编操作数；因为它们都是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>类型，因此显式指定每个类型是多余的。
- en: Next, we figure out which list to add the operand to. We’ll see if we can pass
    it in an available register for its type. For example, if its type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>,
    we check whether <samp class="SANS_TheSansMonoCd_W5Regular_11">double_reg_args</samp>
    already contains eight values ❷. If it does, registers XMM0 through XMM7 are already
    taken. If it doesn’t, there’s at least one XMM register still available.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确定将操作数添加到哪个列表中。我们会检查是否可以通过其类型的可用寄存器传递它。例如，如果它的类型是<samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>，我们会检查<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double_reg_args</samp>是否已经包含了八个值 ❷。如果包含了，寄存器XMM0至XMM7已被占用。如果没有，至少还有一个XMM寄存器是可用的。
- en: If we can pass the operand in an XMM register, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double_arg_regs</samp> ❸. If
    we can pass it in a general-purpose register, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int_arg_regs</samp> ❹. If there
    are no registers of the correct type available, we’ll add <samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>. Once we’ve
    processed every value, we return all three lists.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以通过XMM寄存器传递操作数，我们将把<samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double_arg_regs</samp> ❸。如果我们可以通过通用寄存器传递它，我们将把<samp
    class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp>添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">int_arg_regs</samp>
    ❹。如果没有可用的正确类型的寄存器，我们将把<samp class="SANS_TheSansMonoCd_W5Regular_11">typed_operand</samp>添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>。处理完每个值后，我们将返回这三个列表。
- en: As we build up these three lists, we preserve the order in which the values
    appear. In particular, we add values to <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>
    in the same order they appear in the original list of values, not in reverse.
    That means the first value in <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>
    will be pushed last and will appear at the top of the stack. From the callee’s
    perspective, the first value will be stored at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>,
    the second value at <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>,
    and so on.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建这三个列表时，我们会保留值出现的顺序。特别是，我们将按值在原始列表中出现的顺序将值添加到<samp class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>中，而不是倒序。这意味着，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">stack_args</samp>中的第一个值将最后被压入栈中，并会出现在栈顶。从被调用者的角度来看，第一个值将存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>，第二个值将存储在<samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>，依此类推。
- en: Recall that at the start of a function body, we copy any parameters from their
    initial locations into pseudoregisters. [Listing 13-30](chapter13.xhtml#list13-30)
    demonstrates how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    to perform this setup.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在函数体开始时，我们会将任何参数从它们的初始位置复制到伪寄存器中。[Listing 13-30](chapter13.xhtml#list13-30)演示了如何使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>来执行此设置。
- en: '[PRE60]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-30: Setting up parameters
    in function bodies</samp>'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单13-30：在函数体内设置参数</samp>
- en: 'In this listing, <samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>
    takes a list of a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>s
    representing a function’s parameter list. We process this list with <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>,
    then handle the three resulting lists of assembly operands. To process parameters
    passed in general-purpose registers, we copy the value in EDI (or RDI, depending
    on the type) to the pseudoregister for the first parameter, copy the value in
    ESI to the second parameter, and so on. We handle parameters passed in XMM registers
    the same way. Finally, we handle parameters passed on the stack: we copy the value
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(16)</samp> to the first
    pseudoregister in <samp class="SANS_TheSansMonoCd_W5Regular_11">stack_params</samp>,
    then increase the stack offset by 8 for each subsequent parameter until we’ve
    processed the whole list.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个清单中，<samp class="SANS_TheSansMonoCd_W5Regular_11">set_up_parameters</samp>接受一个TACKY的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>列表，表示函数的参数列表。我们通过<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>处理这个列表，然后处理由此产生的三个汇编操作数列表。对于通过通用寄存器传递的参数，我们将EDI（或RDI，取决于类型）中的值复制到第一个参数的伪寄存器，将ESI中的值复制到第二个参数，以此类推。我们以相同的方式处理通过XMM寄存器传递的参数。最后，我们处理通过栈传递的参数：我们将<sup
    class="SANS_TheSansMonoCd_W5Regular_11">Stack(16)</sup>中的值复制到<sup class="SANS_TheSansMonoCd_W5Regular_11">stack_params</sup>中的第一个伪寄存器，然后将栈偏移量增加8，以处理每个后续的参数，直到处理完整个列表。
- en: We’ll also use <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>
    to implement the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    instruction. Let’s revisit the pseudocode to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>
    to assembly, which we first introduced in [Listing 9-31](chapter9.xhtml#list9-31)
    and updated in [Listing 11-25](chapter11.xhtml#list11-25). [Listing 13-31](chapter13.xhtml#list13-31)
    presents this pseudocode again, with the new logic to process floating-point arguments
    and return values bolded. (I haven’t bolded minor changes like renaming <samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg_registers</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">int_registers</samp>.)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>来实现TACKY的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>指令。让我们重新审视将<samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp>转换为汇编的伪代码，这段代码最早在[清单9-31](chapter9.xhtml#list9-31)中介绍，并在[清单11-25](chapter11.xhtml#list11-25)中更新。[清单13-31](chapter13.xhtml#list13-31)再次展示了这个伪代码，并将处理浮点参数和返回值的新逻辑加粗。（我没有加粗像将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arg_registers</samp>重命名为<samp class="SANS_TheSansMonoCd_W5Regular_11">int_registers</samp>这样的细节变化。）
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 13-31: Supporting</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in
    function calls</samp>'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单13-31：支持</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">double</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">在函数调用中的使用</samp>
- en: Let’s walk through the changes in this listing. To start, we need to categorize
    our arguments with <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    The arguments in <samp class="SANS_TheSansMonoCd_W5Regular_11">int_args</samp>
    are passed in general-purpose registers the same way as before (possibly with
    a few tweaks, not bolded here, to account for the fact that we’re iterating over
    typed assembly operands rather than TACKY values). We add a new step to copy each
    argument in <samp class="SANS_TheSansMonoCd_W5Regular_11">double_args</samp> into
    the corresponding XMM register.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这个清单中的变化。首先，我们需要用<samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>对参数进行分类。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int_args</samp>中的参数与之前一样通过通用寄存器传递（可能会有一些小的调整，这里没有加粗，以适应我们迭代的是带类型的汇编操作数，而不是TACKY值）。我们新增了一个步骤，将每个参数从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double_args</samp>复制到相应的XMM寄存器中。
- en: Next, we update how we pass arguments on the stack. We make two tiny changes
    from [Listing 11-25](chapter11.xhtml#list11-25), where we last looked at this
    step. First, <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operands
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> type, like operands
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> type, are pushed
    directly onto the stack without copying them into a register first, since they’re
    the correct operand size for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>
    instruction. Second, in cases where we move an operand into the <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp>
    register before we push it onto the stack, we no longer hardcode <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>
    as the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction;
    instead, we use the operand type we determined in <samp class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp>.
    This future-proofs our code against later chapters, where we’ll add more assembly
    types.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新了如何通过栈传递参数。我们对 [清单 11-25](chapter11.xhtml#list11-25) 做了两项小改动，上次我们查看这个步骤时就在其中。首先，像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> 类型的操作数一样，<samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    类型的伪操作数直接推入栈中，而不需要先将其复制到寄存器中，因为它们是符合 <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp>
    指令的正确操作数大小。其次，在我们将操作数移动到 <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp>
    寄存器中然后再推入栈的情况下，我们不再硬编码 <samp class="SANS_TheSansMonoCd_W5Regular_11">Longword</samp>
    作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> 指令的类型；而是使用我们在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">classify_parameters</samp> 中确定的操作数类型。这确保了我们的代码能够适应后续章节，其中我们将添加更多汇编类型。
- en: Finally, we update how we retrieve the function’s return value. If the return
    value is a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll
    copy it from XMM0 to the destination. Otherwise, we’ll copy it from EAX (or RAX),
    as usual. We don’t need to change how we adjust the stack alignment before a function
    call, issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction
    itself, or clean up arguments afterward.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新了如何获取函数的返回值。如果返回值是 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，我们将其从
    XMM0 复制到目标位置。否则，我们会像往常一样从 EAX（或 RAX）复制返回值。我们无需更改如何在函数调用前调整栈对齐、发出 <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp>
    指令或在调用后清理参数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Return Instructions</samp>
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">返回指令</samp>
- en: Last but not least, we’ll change how we translate the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction. For example, given the TACKY instruction
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将改变如何翻译 TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    指令。例如，给定 TACKY 指令
- en: '[PRE62]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'we’ll look up the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    in the backend symbol table. If it’s an integer, we can handle it as before. If
    it’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, we’ll copy
    it into XMM0 and then return:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后台符号表中查找 <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> 的类型。如果它是整数，我们可以像之前一样处理。如果它是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，我们会将其复制到 XMM0，然后返回：
- en: '[PRE63]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And with that, we’ve covered every update to the assembly genera- tion pass.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经覆盖了汇编生成过程中所有的更新。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Complete Conversion
    from TACKY to Assembly</samp>
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">从 TACKY 到汇编的完整转换</samp>
- en: '[Tables 13-2](chapter13.xhtml#tab13-2) through [13-7](chapter13.xhtml#tab13-7)
    summarize this chapter’s changes to the conversion from TACKY to assembly. As
    usual, new constructs and changes to the conversions for existing constructs are
    bolded. The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp> placeholders
    in [Table 13-3](chapter13.xhtml#tab13-3) indicate arbitrary general-purpose and
    XMM registers, respectively.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 13-2](chapter13.xhtml#tab13-2) 到 [13-7](chapter13.xhtml#tab13-7) 总结了本章关于从
    TACKY 到汇编的转换的变化。像往常一样，新的结构和现有结构的转换变化以粗体标出。 [表格 13-3](chapter13.xhtml#tab13-3)
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><R></samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><X></samp>
    占位符分别表示任意的通用和 XMM 寄存器。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Top-Level TACKY Constructs to Assembly</samp>
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表格 13-2：</samp> <samp class="SANS_Futura_Std_Book_11">将顶层
    TACKY 结构转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    |  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 顶层构造</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层构造</samp>
    |  |'
- en: '| --- | --- | --- |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(top_level_defs)</samp>
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">程序（top_level_defs）</samp> |'
- en: '[PRE64]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '|'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE65]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '|'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE66]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '|'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-3:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Instructions to Assembly</samp>
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-3：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 指令转换为汇编代码</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp> |  | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp> |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 指令</samp> |  | <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp>
    |'
- en: '| --- | --- | --- |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp> | <samp
    class="SANS_Futura_Std_Book_11">Integer</samp> |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">返回（val）</samp> | <samp class="SANS_Futura_Std_Book_11">整数</samp>
    |'
- en: '[PRE67]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">双精度</samp> |'
- en: '[PRE68]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Not, src, dst)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Integer</samp> |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">一元运算（非，src，dst）</samp> | <samp
    class="SANS_Futura_Std_Book_11">整数</samp> |'
- en: '[PRE69]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">双精度</samp> |'
- en: '[PRE70]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Unary(Negate, src, dst) (double</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">negation)</samp> |  |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">一元运算（取反，src，dst）（双精度</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">取反运算）</samp> |  |'
- en: '[PRE71]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2,
    dst)</samp> <samp class="SANS_Futura_Std_Heavy_B_11">(integer division)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Signed</samp> |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">二元运算（除法，src1，src2，dst）</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">（整数除法）</samp> | <samp class="SANS_Futura_Std_Book_11">有符号</samp>
    |'
- en: '[PRE73]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无符号</samp> |'
- en: '[PRE74]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '|'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero(condition, target)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Integer</samp> |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">跳转如果为零（condition，target）</samp>
    | <samp class="SANS_Futura_Std_Book_11">整数</samp> |'
- en: '[PRE75]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '|'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">双精度</samp> |'
- en: '[PRE76]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '|'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero(condition, target)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Integer</samp> |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">跳转如果不为零（condition，target）</samp>
    | <samp class="SANS_Futura_Std_Book_11">整数</samp> |'
- en: '[PRE77]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '|'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">双精度</samp> |'
- en: '[PRE78]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '|'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall(fun_name, args, dst)</samp>
    |  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">函数调用（fun_name，args，dst）</samp>
    |  |'
- en: '[PRE79]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IntToDouble(src, dst)</samp>
    |  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">IntToDouble(src, dst)</samp>
    |  |'
- en: '[PRE80]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '|'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleToInt(src, dst)</samp>
    |  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleToInt(src, dst)</samp>
    |  |'
- en: '[PRE81]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">UIntToDouble(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned int</samp> |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">UIntToDouble(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">无符号整数</samp> |'
- en: '[PRE82]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '|'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned long</samp> |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">无符号长整型</samp> |'
- en: '[PRE83]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '|'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleToUInt(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned int</samp> |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleToUInt(src, dst)</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">无符号整数</samp> |'
- en: '[PRE84]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned long</samp> |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">无符号长整型</samp> |'
- en: '[PRE85]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '|'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-4:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Arithmetic Operators to Assembly</samp>
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-4：</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 算术运算符转换为汇编代码</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operator</samp> |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 运算符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编运算符</samp>
    |'
- en: '| --- | --- |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Divide</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DivDouble</samp>
    |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">除法</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DivDouble</samp>
    |'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">(double</samp> <samp class="SANS_Futura_Std_Heavy_B_11">division)</samp>
    |  |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">(double</samp> <samp class="SANS_Futura_Std_Heavy_B_11">除法)</samp>
    |  |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-5:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Comparisons to Assembly</samp>
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-5:</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 比较转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp> |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 比较</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编条件代码</samp>
    |'
- en: '| --- | --- |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp> | <samp class="SANS_Futura_Std_Book_11">Signed</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无符号</samp> <samp class="SANS_Futura_Std_Heavy_B_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>
    |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无符号</samp> <samp class="SANS_Futura_Std_Heavy_B_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp> | <samp
    class="SANS_Futura_Std_Book_11">Signed</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp>
    |'
- en: '|  | <samp class="SANS_Futura_Std_Book_11">Unsigned</samp> <samp class="SANS_Futura_Std_Heavy_B_11">or</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>
    |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '|  | <samp class="SANS_Futura_Std_Book_11">无符号</samp> <samp class="SANS_Futura_Std_Heavy_B_11">或</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-6:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    TACKY Operands to Assembly</samp>
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-6:</samp> <samp class="SANS_Futura_Std_Book_11">将
    TACKY 操作数转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    operand</samp> |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">TACKY 操作数</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编操作数</samp>
    |'
- en: '| --- | --- |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstDouble(double))</samp>
    |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">常量(ConstDouble(double))</samp>
    |'
- en: '[PRE87]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '|'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-7:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    Types to Assembly</samp>
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-7:</samp> <samp class="SANS_Futura_Std_Book_11">将类型转换为汇编</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp> |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">源类型</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">汇编类型</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">对齐</samp> |'
- en: '| --- | --- | --- |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp> |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp>
    | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp> |'
- en: As the row for the top-level <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp>
    construct in [Table 13-2](chapter13.xhtml#tab13-2) indicates, you’ll need to add
    every <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp> you
    define in this pass to the list of top-level definitions. From this point on,
    updating the rest of the backend is relatively smooth sailing.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 [表 13-2](chapter13.xhtml#tab13-2) 中顶级 <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp>
    构造所示，你需要将此过程中新定义的每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">StaticConstant</samp>
    添加到顶级定义列表中。从这一点开始，更新后端的其余部分相对顺利。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pseudoregister Replacement</samp>
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">伪寄存器替换</samp>
- en: You should allocate 8 bytes on the stack for each <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    pseudoregister and make sure it’s 8-byte aligned. If the backend symbol table
    indicates that a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> has
    static storage duration, you should replace any references to it with <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands, like you do for other static variables. In short, this pass can treat
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp>
    pseudoregisters identically, since they have the same size and alignment.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为每个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 伪寄存器在栈上分配
    8 字节，并确保它是 8 字节对齐的。如果后端符号表表明某个 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    具有静态存储持续时间，你应该将对它的任何引用替换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    操作数，就像处理其他静态变量一样。简而言之，这个过程可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Double</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Quadword</samp> 伪寄存器视为相同，因为它们具有相同的大小和对齐方式。
- en: As usual, you should also extend this pass to handle the new assembly instructions
    in this chapter.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你还应该扩展此过程以处理本章中的新汇编指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instruction Fix-Up</samp>
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">指令修复</samp>
- en: Next, we’ll rewrite invalid SSE instructions. We’ll also need to rewrite the
    new bitwise instructions that operate on integers. Let’s handle the SSE instructions
    first. You should dedicate one XMM register to fixing instructions’ source operands
    and one to fixing destinations. I’ll use XMM14 for the former and XMM15 for the
    latter.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重新编写无效的 SSE 指令。我们还需要重写对整数操作的新的位运算指令。首先，我们处理 SSE 指令。你应该为修复指令的源操作数分配一个
    XMM 寄存器，另一个用于修复目标。我将使用 XMM14 来修复源操作数，XMM15 来修复目标。
- en: The destination of <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp>
    must be a register. For example, we’ll rewrite
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">cvttsd2si</samp> 的目标必须是寄存器。例如，我们将重新编写
- en: '[PRE88]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'as:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 为：
- en: '[PRE89]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> instruction
    has two constraints: the source can’t be a constant, and the destination must
    be a register. We’ll therefore rewrite'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">cvtsi2sd</samp> 指令有两个约束条件：源操作数不能是常量，目标必须是寄存器。因此，我们将重新编写
- en: '[PRE90]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'as:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 为：
- en: '[PRE91]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> instruction
    has different constraints from <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>.
    Its second operand, in the “destination” position, must be a register. So, we’ll
    rewrite
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> 指令与 <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>
    指令有不同的约束条件。其第二个操作数（即“目标”位置）必须是寄存器。因此，我们将重新编写
- en: '[PRE92]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'as:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 为：
- en: '[PRE93]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The destination of an <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    instruction must be a register as well, so we’ll rewrite all of these instructions
    accordingly. The <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp> instruction
    also requires either a register or a 16-byte-aligned memory address as its source
    operand, but we don’t need a rewrite rule for this since all the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    instructions we generate already satisfy this requirement.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">addsd</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">subsd</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">divsd</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>指令的目标也必须是一个寄存器，因此我们会相应地重写所有这些指令。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>指令还要求源操作数为寄存器或16字节对齐的内存地址，但我们不需要为此编写重写规则，因为我们生成的所有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>指令已经满足这一要求。
- en: 'We’ll use the same rewrite rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>
    that we introduced for the general-purpose <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction in [Chapter 2](chapter2.xhtml), because it’s subject to the same constraint:
    its operands can’t both be in memory. (The one difference, of course, is that
    we’ll use an XMM register instead of R10 as the scratch register.)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用与[第2章](chapter2.xhtml)中介绍的通用<samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>指令相同的重写规则来处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">movsd</samp>，因为它也受到相同的约束：操作数不能都在内存中。（当然，唯一的不同是我们将使用XMM寄存器而不是R10作为临时寄存器。）
- en: 'That leaves the new bitwise instructions. We won’t need to rewrite <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>
    instructions are subject to the same constraints as integer <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>: the operands can’t
    both be memory addresses, and they can’t take immediate source operands outside
    the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这就剩下新的按位指令了。我们不需要重写<samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">and</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">or</samp>指令的约束与整数的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>相同：操作数不能都为内存地址，且它们不能接受超出<int>范围的立即数操作数。
- en: 'There’s one other constraint that we’ll ignore for now: the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instruction can’t push an XMM register. We’ll wait until the next chapter to add
    the rewrite rule for invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>
    instructions because it will use a new kind of assembly operand that we haven’t
    added yet. We won’t actually need this rewrite rule until we implement register
    allocation in [Part III](part3.xhtml); until then, we’ll push only immediate values
    and memory operands (and the RBP register in the function prologue).'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个约束我们现在暂时忽略：<samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>指令不能压入XMM寄存器。我们将等到下一章再为无效的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">push</samp>指令添加重写规则，因为它将使用一种新的汇编操作数类型，我们还没有添加该类型。实际上，直到我们在[第三部分](part3.xhtml)中实现寄存器分配时，我们才需要这个重写规则；在此之前，我们只会压入立即数值和内存操作数（以及函数序言中的RBP寄存器）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">代码生成</samp>
- en: As always, the last step is printing out the newest additions to the assembly
    AST. The most fiddly bit of this pass is emitting floating-point constants and
    static variables. Let’s walk through how to format floating-point numbers in assembly,
    how to label floating-point constants, and how to store floating-point constants
    and variables in the correct section.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，最后一步是输出最新的汇编抽象语法树（AST）。这一步最复杂的部分是发射浮点常数和静态变量。让我们来逐步了解如何在汇编中格式化浮点数，如何标记浮点常数，以及如何将浮点常数和变量存储到正确的段中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatting Floating-Point
    Numbers</samp>
  id: totrans-494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">浮点数格式化</samp>
- en: 'There are a few different ways to format floating-point numbers in assembly.
    One option is to print these numbers as *hexadecimal floating-point* constants,
    where the significand is a hexadecimal number and the exponent is a power of 2\.
    This notation can represent a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    exactly, without any rounding. The significand of a hexadecimal floating-point
    constant has an <samp class="SANS_TheSansMonoCd_W5Regular_11">0x</samp> prefix,
    and the exponent has a <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">P</samp> prefix. For example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">20.0</samp> in hexadecimal floating
    point is <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2.8p+3</samp>. The hexadecimal
    number <samp class="SANS_TheSansMonoCd_W5Regular_11">0x2.8</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">2.5</samp>
    in decimal, and 2.5 × 2³ = 20\. We can use this notation in a <samp class="SANS_TheSansMonoCd_W5Regular_11">.double</samp>
    directive, like so:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编中有几种不同的方式来格式化浮点数。一种选择是将这些数字作为*十六进制浮点*常量打印，其中尾数是一个十六进制数字，指数是2的幂。这个表示法可以精确地表示一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>，没有任何舍入。十六进制浮点常量的尾数有一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x</samp>前缀，指数有一个<samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">P</samp>前缀。例如，十六进制浮点数中的<samp class="SANS_TheSansMonoCd_W5Regular_11">20.0</samp>是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x2.8p+3</samp>。十六进制数<samp class="SANS_TheSansMonoCd_W5Regular_11">0x2.8</samp>在十进制中是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2.5</samp>，而2.5 × 2³ = 20。我们可以在<double>指令中使用这种表示法，如下所示：
- en: '[PRE94]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: When you emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    in this notation, you’ll need up to 14 hexadecimal digits to represent it exactly.
    Unfortunately, not every assembler understands this format. The LLVM assembler,
    which is the default assembler on macOS, does; GAS, the GNU assembler, doesn’t.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种表示法输出<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>时，你需要最多14个十六进制数字才能精确表示它。不幸的是，并不是每个汇编器都理解这种格式。LLVM汇编器（macOS上的默认汇编器）可以理解，然而GNU汇编器（GAS）则不行。
- en: 'If your assembler doesn’t support hexadecimal floating-point constants, you
    can emit a quadword with the same binary representation as the required <samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Printing out <samp class="SANS_TheSansMonoCd_W5Regular_11">20.0</samp>
    with this approach results in:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的汇编器不支持十六进制浮点常量，你可以输出一个四字节数（quadword），它与所需的<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>有相同的二进制表示。使用这种方法打印出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">20.0</samp>的结果是：
- en: '[PRE95]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This isn’t the most readable assembly, but it works perfectly well as long
    as your implementation language provides a way for you to get at the binary representation
    of a floating-point number. Your last option is to use decimal floating-point
    constants, which we used in earlier assembly examples:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是最具可读性的汇编，但只要你的实现语言提供一种方式让你访问浮点数的二进制表示，它就能完美工作。你的最后一个选择是使用十进制浮点常量，这在之前的汇编示例中使用过：
- en: '[PRE96]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Decimal can be less compact than hexadecimal floating point. For example, consider
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>, the
    closest <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> to the decimal
    number 0.1\. The exact decimal representation of this value is:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制可能比十六进制浮点数更不紧凑。例如，考虑<samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>，它是最接近十进制数0.1的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。这个值的精确十进制表示是：
- en: '[PRE97]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You don’t need to emit this entire value; 17 digits is always enough to guarantee
    a *round-trip conversion* back to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>.
    In other words, you can print out a 17-digit decimal approximation of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>,
    like this:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要输出整个值；17个数字足以确保进行*往返转换*回到原始的<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>。换句话说，你可以输出一个17位数字的十进制近似值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>，像这样：
- en: '[PRE98]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This isn’t exactly the right value, but it’s close enough that when the assembler
    converts it back to a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    you’ll get the original value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是完全正确的值，但它足够接近，以至于当汇编器将其转换回<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>时，你将得到原始值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x1.999999999999ap-4</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Labeling Floating-Point
    Constants</samp>
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">标记浮点常量</samp>
- en: If you’re using local labels for top-level constants, you should include the
    local label prefix (<samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp> on
    macOS, <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp> on Linux) any time
    you emit these constants’ identifiers. You’ll need to check the backend symbol
    table to distinguish between <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands that represent static variables and those that represent constants. If
    an object’s <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp> attribute
    is true, it takes a local label prefix; otherwise, it’s a variable, so it doesn’t.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在顶层常量中使用局部标签，发出这些常量标识符时，应该包含局部标签前缀（在 macOS 上为 <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>，在
    Linux 上为 <samp class="SANS_TheSansMonoCd_W5Regular_11">.L</samp>）。你需要检查后端符号表，以区分表示静态变量和表示常量的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> 操作数。如果对象的 <samp class="SANS_TheSansMonoCd_W5Regular_11">is_constant</samp>
    属性为真，它需要使用局部标签前缀；否则，它是一个变量，不需要。
- en: If you’re not using local labels, you’ll need to emit all <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    operands uniformly. On macOS, that means prefixing the labels for both constants
    and static variables with an underscore.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用局部标签，你需要统一发出所有 <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    操作数。在 macOS 上，这意味着常量和静态变量的标签都需要加上下划线前缀。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Storing Constants
    in the Read-Only Data Section</samp>
  id: totrans-510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将常量存储在只读数据区</samp>
- en: The name of the section that holds constants is platform-specific. On Linux,
    you should specify this section with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.section
    .rodata</samp> directive. On macOS, 8-byte-aligned and 16-byte-aligned constants
    are stored in different sections. If a constant is 8-byte aligned, use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> directive to store it
    in the correct section. For our one 16-byte-aligned constant (<samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>,
    which we use to implement negation), use the <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal16</samp>
    directive.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 存储常量的区段名称是平台特定的。在 Linux 上，你应使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">.section
    .rodata</samp> 指令来指定该区段。在 macOS 上，8 字节对齐和 16 字节对齐的常量存储在不同的区段。如果常量是 8 字节对齐的，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal8</samp> 指令将其存储在正确的区段中。对于我们的
    16 字节对齐常量（<samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>，用于实现取反），使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.literal16</samp> 指令。
- en: The macOS linker expects 16-byte-aligned constants to be 16 bytes long, but
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> is only 8 bytes. Emit
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad 0</samp> directive right
    after the directive for <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>
    to bring the total size of the section holding this constant up to 16 bytes and
    satisfy the linker’s requirements.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: macOS 链接器期望 16 字节对齐的常量长度为 16 字节，但 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>
    只有 8 字节。紧跟在 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> 指令之后，发出
    <samp class="SANS_TheSansMonoCd_W5Regular_11">.quad 0</samp> 指令，以将该常量所在区段的总大小提升到
    16 字节，从而满足链接器的要求。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Initializing
    Static Variables to 0.0 or –0.0</samp>'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将静态变量初始化为 0.0
    或 -0.0</samp>'
- en: We won’t store static variables of type <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    in the BSS section or initialize them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp>
    directive, even if they’re initialized to zero. This sidesteps any potential confusion
    about whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> is
    really initialized to <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>. (These two values
    usually compare equal, but we can’t store <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>
    in the BSS section or initialize it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp>
    directive because its binary representation isn’t all zeros.)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 的静态变量存储在
    BSS 区段中，也不会使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> 指令初始化它们，即使它们被初始化为零。这避免了关于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> 是否真的是初始化为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp> 的潜在混淆。（这两个值通常比较相等，但我们不能在
    BSS 区段中存储 <samp class="SANS_TheSansMonoCd_W5Regular_11">-0.0</samp>，也不能使用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.zero</samp> 指令初始化它，因为其二进制表示并非全为零。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  id: totrans-515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">将所有内容结合起来</samp>
- en: Aside from floating-point constants and static variables, the code emission
    stage needs to handle the new XMM registers, the new instructions, and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sd</samp> suffix on the floating-point
    versions of existing instructions. These changes are extensive, but they don’t
    require much discussion. [Tables 13-8](chapter13.xhtml#tab13-8) through [13-13](chapter13.xhtml#tab13-13)
    summarize this chapter’s updates to the code emission pass. New constructs and
    changes to the way we emit existing constructs are bolded.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 除了浮点常量和静态变量之外，代码生成阶段还需要处理新的 XMM 寄存器、新的指令以及现有指令的浮点版本上的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp>
    后缀。这些更改很广泛，但不需要过多讨论。[表 13-8](chapter13.xhtml#tab13-8) 到 [13-13](chapter13.xhtml#tab13-13)
    总结了本章对代码生成阶段的更新。新的结构和我们生成现有结构的方式的更改以粗体显示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-8:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-8：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编顶层结构</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编顶层结构</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE99]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '| <samp class="SANS_Futura_Std_Book_11">Integer initialized to zero</samp>
    |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">初始化为零的整数</samp> |'
- en: '[PRE100]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '|'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| <samp class="SANS_Futura_Std_Book_11">Integer with nonzero initializer,</samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">or any</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp>
    |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Book_11">具有非零初始化器的整数，</samp> <samp class="SANS_Futura_Std_Heavy_B_11">或任何</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">double</samp> |'
- en: '[PRE101]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '|'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE102]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Linux</samp> |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Linux</samp> |'
- en: '[PRE103]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '|'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE104]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '|'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE105]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '|'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE106]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '|'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE107]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '|'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-9:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Static Initializers</samp>
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-9：</samp> <samp class="SANS_Futura_Std_Book_11">格式化静态初始化器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">静态初始化器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleInit(d)</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">.double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><d></samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">or .quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><d-interpreted-as-long></samp>
    |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DoubleInit(d)</samp> | <samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">.double</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><d></samp>
    <samp class="SANS_Futura_Std_Heavy_B_11">或 .quad</samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"><d-interpreted-as-long></samp>
    |'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-10:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 13-10：</samp> <samp class="SANS_Futura_Std_Book_11">格式化汇编指令</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">汇编指令</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">输出</samp>
    |'
- en: '| --- | --- |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvtsi2sd(t, src, dst)</samp>
    |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
- en: '[PRE108]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '|'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cvttsd2si(t, src, dst)</samp>
    |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
- en: '[PRE109]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '|'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Xor, Double, src, dst)</samp>
    |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
- en: '[PRE110]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '|'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Mult, Double, src, dst)</samp>
    |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
- en: '[PRE111]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '|'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cmp(Double, operand, operand)</samp>
    |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
- en: '[PRE112]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '|'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-11:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Names for Assembly Operators</samp>
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp> |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Shr</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">shr</samp>
    |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">DivDouble</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">div</samp>
    |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">And</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">and</samp>
    |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Or</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">or</samp>
    |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-12:</samp> <samp class="SANS_Futura_Std_Book_11">Instruction
    Suffixes for Assembly Types</samp>
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Instruction
    suffix</samp> |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Double</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sd</samp>
    |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 13-13:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM0)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm0</samp>
    |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM1)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm1</samp>
    |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM2)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm2</samp>
    |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM3)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm3</samp>
    |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM4)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm4</samp>
    |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM5)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm5</samp>
    |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM6)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm6</samp>
    |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM7)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm7</samp>
    |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM14)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm14</samp>
    |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(XMM15)</samp> | <samp class="SANS_TheSansMonoCd_W7Bold_B_11">%xmm15</samp>
    |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
- en: Note that [Table 13-8](chapter13.xhtml#tab13-8) doesn’t include local label
    prefixes on constants, although you have the option to include them, as we’ve
    discussed. Also note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp>
    instructions in [Table 13-10](chapter13.xhtml#tab13-10) require special handling.
    As a packed instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">xorpd</samp>
    doesn’t use the standard <samp class="SANS_TheSansMonoCd_W5Regular_11">sd</samp>
    suffix, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mulsd</samp> instructions have different
    names than their integer counterparts.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve worked through all these changes, you’re ready to test the whole
    compiler.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: NaN</samp>'
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add support for quiet NaNs as an extra credit feature. Arithmetic operations
    should just work, without any extra effort on your part, because the SSE instructions
    will propagate NaNs appropriately. You don’t need to handle type conversions,
    either, since conversions from NaN to integers are undefined. The only operations
    you need to worry about are comparisons.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: 'When you compare any value to NaN, the result is unordered. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is NaN, then <samp class="SANS_TheSansMonoCd_W5Regular_11">x > y</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">x < y</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    are all false. NaN even compares unequal to itself. The <samp class="SANS_TheSansMonoCd_W5Regular_11">comisd</samp>
    instruction indicates an unordered result by setting three flags to 1: ZF, CF,
    and PF, the *parity flag*. Just as there are condition codes that rely on ZF,
    CF, and the other status flags we’ve already encountered, the <samp class="SANS_TheSansMonoCd_W5Regular_11">P</samp>
    condition code relies on the parity flag. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">jp</samp>
    instruction will jump only if PF is 1\. You’ll need to use this condition code
    to properly account for NaN in floating-point comparisons.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--nan</samp> flag to
    include test cases with NaN when you run the test suite:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Or use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag to enable all extra credit tests, as usual.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Your compiler now supports floating-point numbers! In this chapter, you learned
    how to define floating-point constants in assembly, how to use SSE instructions,
    and how to pass floating-point arguments according to the System V calling convention.
    You also dealt with rounding error throughout the compiler, from the parser all
    the way through code emission. Above all, you’ve seen how difficult floating-point
    arithmetic is to get right. Many programmers know, in a general way, that floating-point
    arithmetic can be imprecise; writing a compiler forces you to understand exactly
    how it can go awry. In the next chapter, you’ll add a very different type: pointers.
    You’ll deal with tricky parsing issues, expand the type checker, and add a few
    extremely useful constructs to the TACKY and assembly ASTs.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编译器现在支持浮点数了！在这一章中，你学习了如何在汇编中定义浮点常量，如何使用SSE指令，以及如何根据System V调用约定传递浮点参数。你还处理了编译器中的四舍五入误差，从解析器到代码生成。最重要的是，你看到浮点运算是多么难以正确实现。许多程序员大致知道浮点运算可能不精确；而编写编译器迫使你准确理解它是如何出错的。在下一章中，你将添加一个完全不同的类型：指针。你将处理棘手的解析问题，扩展类型检查器，并向TACKY和汇编AST中添加一些非常有用的构造。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">附加资源</samp>
- en: These are the resources I relied on while writing this chapter, roughly organized
    by the section where they’re most relevant. I’ve also included a couple of online
    floating-point visualization tools that I found particularly helpful.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我在编写本章时依赖的资源，按照它们与章节的相关性进行大致分类。我还包括了一些我认为特别有用的在线浮点可视化工具。
- en: '**IEEE 754**'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**IEEE 754**'
- en: 'The IEEE 754 standard is available for purchase on the IEEE website for $100
    (*[https://<wbr>ieeexplore<wbr>.ieee<wbr>.org<wbr>/document<wbr>/8766229](https://ieeexplore.ieee.org/document/8766229)*).
    But you can probably get any answers you need from the following resources, which
    are free:'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IEEE 754标准可以在IEEE官网上购买，价格为100美元（*[https://<wbr>ieeexplore<wbr>.ieee<wbr>.org<wbr>/document<wbr>/8766229](https://ieeexplore.ieee.org/document/8766229)*）。但你可能可以通过以下免费的资源获得所需的答案：
- en: The “Double-Precision Floating-Point Format” article on Wikipedia gives a thorough
    description of the binary encoding of IEEE 754 double-precision values (*[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*).
  id: totrans-603
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wikipedia上的《双精度浮点格式》文章详细描述了IEEE 754双精度值的二进制编码（*[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*）。
- en: “What Every Computer Scientist Should Know About Floating-Point Arithmetic”
    by David Goldberg is one of the best-known introductions to floating-point math,
    if not the most readable (*[https://<wbr>docs<wbr>.oracle<wbr>.com<wbr>/cd<wbr>/E19957<wbr>-01<wbr>/806<wbr>-3568<wbr>/ncg<wbr>_goldberg<wbr>.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*).
    I found the discussion of the IEEE 754 format in the section “The IEEE Standard”
    especially useful. The article also covers some important topics that I’ve glossed
    over completely, like exceptions and error handling.
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: David Goldberg的《每个计算机科学家都应该知道的浮点运算》是浮点数学的最著名入门书籍之一，虽然可能不是最易读的（*[https://<wbr>docs<wbr>.oracle<wbr>.com<wbr>/cd<wbr>/E19957<wbr>-01<wbr>/806<wbr>-3568<wbr>/ncg<wbr>_goldberg<wbr>.html](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)*）。我发现“IEEE标准”部分中关于IEEE
    754格式的讨论尤其有用。文章还涉及了一些我完全忽略的重要主题，例如异常和错误处理。
- en: The Floating-Point Guide, a website created by Michael Borgwardt, covers the
    basics of working with IEEE 754 floating-point numbers in an approachable way
    (*[https://<wbr>floating<wbr>-point<wbr>-gui<wbr>.de](https://floating-point-gui.de)*).
    Start here if the other two articles are too dense.
  id: totrans-605
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Michael Borgwardt创建的《浮点指南》网站以通俗易懂的方式介绍了如何使用IEEE 754浮点数（*[https://<wbr>floating<wbr>-point<wbr>-gui<wbr>.de](https://floating-point-gui.de)*）。如果前两篇文章内容过于密集，可以从这里开始。
- en: 'To learn more about support for the IEEE 754 standard in GCC and Clang, see
    the following resources:'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于GCC和Clang中对IEEE 754标准的支持，请查看以下资源：
- en: “Semantics of Floating Point Math in GCC” on the GCC wiki summarizes the state
    of floating-point support in GCC, describes the default floating-point behavior,
    and discusses some of the challenges of fully conforming to IEEE 754 (*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/wiki<wbr>/FloatingPointMath](https://gcc.gnu.org/wiki/FloatingPointMath)*).
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The section “Controlling Floating-Point Behavior” in the Clang Compiler User’s
    Manual discusses IEEE 754 compliance in Clang (*[https://<wbr>clang<wbr>.llvm<wbr>.org<wbr>/docs<wbr>/UsersManual<wbr>.html#controlling<wbr>-floating<wbr>-point<wbr>-behavior](https://clang.llvm.org/docs/UsersManual.html#controlling-floating-point-behavior)*).
  id: totrans-608
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference for “Rounding Behavior” on [page 299](#pg_299)**'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: “The Spacing of Binary Floating-Point Numbers,” a blog post by Rick Regan, discusses
    the gaps between consecutive floating-point numbers (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/the<wbr>-spacing<wbr>-of<wbr>-binary<wbr>-floating<wbr>-point<wbr>-numbers<wbr>/](https://www.exploringbinary.com/the-spacing-of-binary-floating-point-numbers/)*).
    I found that focusing on the gaps in the number line was the key to understanding
    floating-point rounding error. After I read this blog post, other discussions
    of this topic suddenly made a lot more sense.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References for “Floating-Point Operations in Assembly” on [page 310](#pg_310)**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: For details about the System V calling convention, see the System V x64 ABI
    (*[https://<wbr>gitlab<wbr>.com<wbr>/x86<wbr>-psABIs<wbr>/x86<wbr>-64<wbr>-ABI](https://gitlab.com/x86-psABIs/x86-64-ABI)*).
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details about individual SSE instructions, including how they deal with
    overflow and rounding, see the Intel 64 Software Developer’s Manual (*[https://<wbr>www<wbr>.intel<wbr>.com<wbr>/content<wbr>/www<wbr>/us<wbr>/en<wbr>/developer<wbr>/articles<wbr>/technical<wbr>/intel<wbr>-sdm<wbr>.html](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)*).
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Sometimes Floating Point Math Is Perfect,” a blog post by Bruce Dawson, gives
    an overview of cases where floating-point calculations *don’t* produce rounding
    error (*[https://<wbr>randomascii<wbr>.wordpress<wbr>.com<wbr>/2017<wbr>/06<wbr>/19<wbr>/sometimes<wbr>-floating<wbr>-point<wbr>-math<wbr>-is<wbr>-perfect<wbr>/](https://randomascii.wordpress.com/2017/06/19/sometimes-floating-point-math-is-perfect/)*).
    It helped me think through why our assembly to convert from <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> won’t have
    rounding error.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pascal Cuoq has written an excellent answer to a Stack Overflow question about
    the assembly-level conversion from <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    long</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> (*[https://<wbr>stackoverflow<wbr>.com<wbr>/a<wbr>/26799227](https://stackoverflow.com/a/26799227)*).
    This is the best explanation of this conversion I’ve been able to find.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “GCC Avoids Double Rounding Errors with Round-to-Odd,” another post by Rick
    Regan, provides more background information on double rounding error (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/gcc<wbr>-avoids<wbr>-double<wbr>-rounding<wbr>-errors<wbr>-with<wbr>-round<wbr>-to<wbr>-odd<wbr>/](https://www.exploringbinary.com/gcc-avoids-double-rounding-errors-with-round-to-odd/)*).
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**References for “Code Emission” on [page 338](#pg_338)**'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'I drew on two of Rick Regan’s blog posts on Exploring Binary to handle floating-point
    constants during code emission:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: “Hexadecimal Floating-Point Constants” talks about representing floating-point
    numbers in hexadecimal to avoid rounding error (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/hexadecimal<wbr>-floating<wbr>-point<wbr>-constants<wbr>/](https://www.exploringbinary.com/hexadecimal-floating-point-constants/)*).
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Number of Digits Required for Round-Trip Conversions” explains why 17 decimal
    digits is enough to represent a floating-point constant (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/number<wbr>-of<wbr>-digits<wbr>-required<wbr>-for<wbr>-round<wbr>-trip<wbr>-conversions<wbr>/](https://www.exploringbinary.com/number-of-digits-required-for-round-trip-conversions/)*).
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating-point visualization tools**'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: 'These tools let you experiment with the IEEE 754 representations of decimal
    numbers:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: The Decimal to Floating-Point Converter, created by Rick Regan, lets you convert
    a decimal number to the nearest representable <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    and display it in a wide range of formats, including raw binary, hexadecimal floating
    point, and binary scientific notation (*[https://<wbr>www<wbr>.exploringbinary<wbr>.com<wbr>/floating<wbr>-point<wbr>-converter<wbr>/](https://www.exploringbinary.com/floating-point-converter/)*).
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Float Exposed, created by Bartosz Ciechanowski, lets you view and edit the sign,
    exponent, and significand fields within a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    as well as its raw binary representation (*[https://<wbr>float<wbr>.exposed](https://float.exposed)*).
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
