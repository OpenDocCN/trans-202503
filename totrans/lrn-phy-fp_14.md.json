["```\nPrelude> :m Graphics.Gloss\nPrelude Graphics.Gloss> :t display\ndisplay :: Display -> Color -> Picture -> IO ()\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Graphics.Gloss\n\ndisplayMode :: Display\ndisplayMode = InWindow \"Axes\" (1000, 700) (10, 10)\n\naxes :: Picture\naxes = Pictures [Color red   $ Line [(0,0),(100,  0)]\n                ,Color green $ Line [(0,0),(  0,100)]\n                ]\n\nmain :: IO ()\nmain = display displayMode black axes\n```", "```\nPrelude Graphics.Gloss> :t Line [(0,0),(100,0)]\nLine [(0,0),(100,0)] :: Picture\nPrelude Graphics.Gloss> :t Color green $ Line [(0,0),(0,100)]\nColor green $ Line [(0,0),(0,100)] :: Picture\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Graphics.Gloss\n\ndisplayMode :: Display\ndisplayMode = InWindow \"My Window\" (1000, 700) (10, 10)\n\nblueCircle :: Picture\nblueCircle = Color blue (Circle 100)\n\ndisk :: Float -> Picture\ndisk radius = ThickCircle (radius / 2) radius\n\nredDisk :: Picture\nredDisk = Color red (disk 100)\n\nwholePicture :: Picture\nwholePicture = Pictures [Translate (-120) 0 blueCircle\n                        ,Translate   120  0 redDisk\n                        ]\n\nmain :: IO ()\nmain = display displayMode black wholePicture\n```", "```\nPrelude> :m Graphics.Gloss\nPrelude Graphics.Gloss> :t animate\nanimate :: Display -> Color -> (Float -> Picture) -> IO ()\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Graphics.Gloss\n\ndisplayMode :: Display\ndisplayMode = InWindow \"My Window\" (1000, 700) (10, 10)\n\ndisk :: Float -> Picture\ndisk radius = ThickCircle (radius / 2) radius\n\nredDisk :: Picture\nredDisk = Color red (disk 25)\n\nprojectileMotion :: Float -> Picture\nprojectileMotion t = Translate (xDisk t) (yDisk t) redDisk\n\nxDisk :: Float -> Float\nxDisk t = 40 * t\n\nyDisk :: Float -> Float\nyDisk t = 80 * t - 4.9 * t**2\n\nmain :: IO ()\nmain = animate displayMode black projectileMotion\n```", "```\nPrelude> :m Graphics.Gloss\nPrelude Graphics.Gloss> :t simulate\nsimulate\n  :: Display\n     -> Color\n     -> Int\n     -> model\n     -> (model -> Picture)\n     -> (Graphics.Gloss.Data.ViewPort.ViewPort\n         -> Float -> model -> model)\n     -> IO ()\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Graphics.Gloss\n\ndisplayMode :: Display\ndisplayMode = InWindow \"My Window\" (1000, 700) (10, 10)\n\n-- updates per second of real time\nrate :: Int\nrate = 2\n\ndisk :: Float -> Picture\ndisk radius = ThickCircle (radius / 2) radius\n\nredDisk :: Picture\nredDisk = Color red (disk 25)\n\ntype State = (Float,Float)\n\ninitialState :: State\ninitialState = (0,0)\n\ndisplayFunc :: State -> Picture\ndisplayFunc (x,y) = Translate x y redDisk\n\nupdateFunc :: Float -> State -> State\nupdateFunc dt (x,y) = (x + 10 * dt, y - 5 * dt)\n\nmain :: IO ()\nmain = simulate displayMode black rate initialState displayFunc\n       (\\_ -> updateFunc)\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Graphics.Gloss\n\ndisplayMode :: Display\ndisplayMode = InWindow \"My Window\" (1000, 700) (10, 10)\n\n-- updates per second of real time\nrate :: Int rate = 24\n\ndisk :: Float -> Picture\ndisk radius = ThickCircle (radius / 2) radius\n\nredDisk :: Picture\nredDisk = Color red (disk 25)\n\ntype Position = (Float,Float)\ntype Velocity = (Float,Float)\ntype State = (Position,Velocity)\n\ninitialState :: State\ninitialState = ((0,0),(40,80))\n\ndisplayFunc :: State -> Picture\ndisplayFunc ((x,y),_) = Translate x y redDisk\n\nupdateFunc :: Float -> State -> State\nupdateFunc dt ((x,y),(vx,vy))\n   = (( x + vx * dt, y +  vy * dt)\n     ,(vx         ,vy - 9.8 * dt))\n\nmain :: IO ()\nmain = simulate displayMode black rate initialState displayFunc\n       (\\_ -> updateFunc)\n```", "```\nPrelude> :m Vis\nPrelude Vis> :t display\ndisplay :: Real b => Options -> VisObject b -> IO ()\n```", "```\nPrelude Vis> :i Real\nclass (Num a, Ord a) => Real a where\n  toRational :: a -> Rational\n  {-# MINIMAL toRational #-}\n   -- Defined in 'GHC.Real'\ninstance Real Word -- Defined in 'GHC.Real'\ninstance Real Integer -- Defined in 'GHC.Real'\ninstance Real Int -- Defined in 'GHC.Real'\ninstance Real Float -- Defined in 'GHC.Float'\ninstance Real Double -- Defined in 'GHC.Float'\n```", "```\ndisplay :: Options -> VisObject R -> IO ()\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Vis\n\ntype R = Double\n\nblueCube :: VisObject R\nblueCube = Cube 1 Solid blue\n\nmain :: IO ()\nmain = display defaultOpts blueCube\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Vis\nimport Linear\n\ntype R = Double\n\naxes :: VisObject R\naxes = VisObjects [Line Nothing [V3 0 0 0, V3 1 0 0] red\n                  ,Line Nothing [V3 0 0 0, V3 0 1 0] green\n                  ,Line Nothing [V3 0 0 0, V3 0 0 1] blue\n                  ]\n\nmain :: IO ()\nmain = display defaultOpts axes\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Vis\nimport Linear\nimport SpatialMath\n\ntype R = Double\n\naxes :: VisObject R\naxes = VisObjects [Line Nothing [V3 0 0 0, V3 1 0 0] red\n                  ,Line Nothing [V3 0 0 0, V3 0 1 0] green\n                  ,Line Nothing [V3 0 0 0, V3 0 0 1] blue\n                  ]\n\norient :: VisObject R -> VisObject R\norient pict = RotEulerDeg (Euler 270 180 0) $ pict\n\nmain :: IO ()\nmain = display defaultOpts (orient axes)\n```", "```\nmyDisplay :: VisObject R -> IO ()\nmyDisplay pict = display defaultOpts (orient pict)\n```", "```\nPrelude> :m Vis\nPrelude Vis> :t animate\nanimate :: Real b => Options -> (Float -> VisObject b) -> IO ()\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Vis\nimport SpatialMath\n\nrotatingCube :: Float -> VisObject Float\nrotatingCube t = RotEulerRad (Euler 0 0 t) (Cube 1 Solid blue)\n\norient :: VisObject Float -> VisObject Float\norient pict = RotEulerDeg (Euler 270 180 0) $ pict\n\nmain :: IO ()\nmain = animate defaultOpts (orient . rotatingCube)\n```", "```\nPrelude> :m Vis\nPrelude Vis> :t simulate\nsimulate\n  :: Real b =>\n     Options\n     -> Double\n     -> world\n     -> (world -> VisObject b)\n     -> (Float -> world -> world)\n     -> IO ()\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Vis\n\ntype State = (Int,[Float])\n\n-- seconds / update\ndt :: Double dt = 0.5\n\ndisplayFunc :: State -> VisObject Double\ndisplayFunc (n,ts) = Text2d (show n ++ \" \" ++ show (take 4 ts))\n                     (100,100) Fixed9By15 orange\n\nupdateFunc :: Float -> State -> State\nupdateFunc t (n,ts) = (n+1,t:ts)\n\nmain :: IO ()\nmain = simulate defaultOpts dt (0,[]) displayFunc updateFunc\n```"]