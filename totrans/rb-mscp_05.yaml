- en: Chapter 5. Objects and Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Every Ruby object is the combination of a class pointer and an array of instance
    variables.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We learn early on that Ruby is an object-oriented language, descended from
    languages like Smalltalk and Simula. Every value is an object, and all Ruby programs
    consist of a set of objects and the messages sent between them. Typically, we
    learn about object-oriented programming by looking at how to use objects and what
    they can do: how they can group together data values and behavior related to those
    values; how each class should have a single responsibility or purpose; and how
    different classes can be related to each other through encapsulation or inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: But what are Ruby objects? What information does an object contain? If we were
    to look at a Ruby object through a microscope, what would we see? Are there any
    moving parts inside? And what about Ruby classes? What exactly is a class?
  prefs: []
  type: TYPE_NORMAL
- en: I’ll answer these questions in this chapter by exploring how Ruby works internally.
    By looking at how Ruby implements objects and classes, you’ll learn how to use
    them and how to write object-oriented programs using Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Roadmap
  prefs: []
  type: TYPE_NORMAL
- en: '[Inside a Ruby Object](ch05.html#inside_a_ruby_object "Inside a Ruby Object")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Inspecting klass and ivptr](ch05.html#inspecting_klass_and_ivptr "Inspecting
    klass and ivptr")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Visualizing Two Instances of One Class](ch05.html#visualizing_two_instances_of_one_class
    "Visualizing Two Instances of One Class")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Generic Objects](ch05.html#generic_objects "Generic Objects")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Simple Ruby Values Don’t Require a Structure at All](ch05.html#simple_ruby_values_donapostrophet_requir
    "Simple Ruby Values Don’t Require a Structure at All")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Do Generic Objects Have Instance Variables?](ch05.html#do_generic_objects_have_instance_variabl
    "Do Generic Objects Have Instance Variables?")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reading the RBasic and RObject C Structure Definitions](ch05.html#reading_the_rbasic_and_robject_c_structu
    "Reading the RBasic and RObject C Structure Definitions")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Where Does Ruby Save Instance Variables for Generic Objects?](ch05.html#where_does_ruby_save_instance_variables
    "Where Does Ruby Save Instance Variables for Generic Objects?")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Experiment 5-1: How Long Does It Take to Save a New Instance Variable?](ch05.html#experiment_5-1_how_long_does_it_take_to
    "Experiment 5-1: How Long Does It Take to Save a New Instance Variable?")**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[What’s Inside the RClass Structure?](ch05.html#whatapostrophes_inside_the_rclass_struct
    "What’s Inside the RClass Structure?")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Inheritance](ch05.html#inheritance "Inheritance")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Class Instance Variables vs. Class Variables](ch05.html#class_instance_variables_vsdot_class_var
    "Class Instance Variables vs. Class Variables")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting and Setting Class Variables](ch05.html#getting_and_setting_class_variables
    "Getting and Setting Class Variables")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Constants](ch05.html#constants "Constants")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Actual RClass Structure](ch05.html#actual_rclass_structure "The Actual
    RClass Structure")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reading the RClass C Structure Definition](ch05.html#reading_the_rclass_c_structure_definitio
    "Reading the RClass C Structure Definition")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Experiment 5-2: Where Does Ruby Save Class Methods?](ch05.html#experiment_5-2_where_does_ruby_save_clas
    "Experiment 5-2: Where Does Ruby Save Class Methods?")**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](ch05.html#summary-id00017 "Summary")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside a Ruby Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby saves each of your custom objects in a C structure called `RObject`, which
    looks like [Figure 5-1](ch05.html#robject_structure "Figure 5-1. The RObject structure")
    in Ruby 1.9 and 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1854029.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*If I could slice open a Ruby object, what would I see?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the figure is a pointer to the `RObject` structure. (Internally,
    Ruby always refers to any value with a `VALUE` pointer.) Below this pointer, the
    `RObject` structure contains an inner `RBasic` structure and information specific
    to custom objects. The `RBasic` section contains information that all values use:
    a set of Boolean values called `flags` that store a variety of internal technical
    values, and a class pointer called `klass`. The class pointer indicates which
    class an object is an instance of. In the `RObject` section, Ruby saves an array
    of instance variables that each object contains, using `numiv`, the instance variable
    count, and `ivptr`, a pointer to an array of values.'
  prefs: []
  type: TYPE_NORMAL
- en: If we were to define the Ruby object structure in technical terms, we could
    say
  prefs: []
  type: TYPE_NORMAL
- en: Every Ruby object is the combination of a class pointer and an array of instance
    variables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At first glance, this definition doesn’t seem very useful because it doesn’t
    help us understand the meaning or purpose behind objects or how to use them in
    a Ruby program.
  prefs: []
  type: TYPE_NORMAL
- en: '![The RObject structure](httpatomoreillycomsourcenostarchimages1854031.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1. The `RObject` structure
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting klass and ivptr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how Ruby uses `RObject` in programs, we’ll create a simple Ruby
    class and then inspect an instance of this class using IRB. For example, suppose
    I have the simple Ruby class shown in [Example 5-1](ch05.html#simple_ruby_class
    "Example 5-1. A simple Ruby class").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1. A simple Ruby class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Ruby needs to save the class pointer in `RObject` because every object must
    track the class you used to create it. When you create an instance of a class,
    Ruby internally saves a pointer to that class inside `RObject`, as shown in [Example 5-2](ch05.html#creating_an_object_instance_in_irb
    "Example 5-2. Creating an object instance in IRB").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2. Creating an object instance in IRB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By displaying the class name `#<Mathematician` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    Ruby displays the value of the class pointer for the `euler` object. The hex string
    that follows is actually the `VALUE` pointer for the object. (This will differ
    for every instance of `Mathematician`.)
  prefs: []
  type: TYPE_NORMAL
- en: Ruby also uses the instance variable array to track the values you save in an
    object, as shown in [Example 5-3](ch05.html#inspecting_instance_variables_in_irb
    "Example 5-3. Inspecting instance variables in IRB").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3. Inspecting instance variables in IRB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in IRB Ruby also displays the instance variable array for `euler`
    at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg). Ruby needs to save
    this array of values in each object because every object instance can have different
    values for the same instance variables, as shown at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    in [Example 5-4](ch05.html#different_instance_of_the_mathematicia "Example 5-4. A
    different instance of the Mathematician class").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4. A different instance of the `Mathematician` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing Two Instances of One Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at Ruby’s C structures in a bit more detail. When you run the Ruby
    code shown in [Figure 5-2](ch05.html#creating_two_instances_of_one_class "Figure 5-2. Creating
    two instances of one class"), Ruby creates one `RClass` structure and two `RObject`
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating two instances of one class](httpatomoreillycomsourcenostarchimages1854033.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2. Creating two instances of one class
  prefs: []
  type: TYPE_NORMAL
- en: I’ll discuss how Ruby implements classes with the `RClass` structure in the
    next section. For now, let’s look at [Figure 5-3](ch05.html#visualizing_two_instances_of_one-id00016
    "Figure 5-3. Visualizing two instances of one class"), which shows how Ruby saves
    the `Mathematician` information in the two `RObject` structures.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing two instances of one class](httpatomoreillycomsourcenostarchimages1854035.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3. Visualizing two instances of one class
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, each `klass` value points to the `Mathematician RClass` structure,
    and each `RObject` structure has a separate array of instance variables. Both
    arrays contain `VALUE` pointers—the same pointer that Ruby uses to refer to the
    `RObject` structure. (Notice that one of the objects contains two instance variables,
    while the other contains only one.)
  prefs: []
  type: TYPE_NORMAL
- en: Generic Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you know how Ruby saves custom classes, like the `Mathematician` class,
    in `RObject` structures. But remember that every Ruby value—including basic data
    types such as integers, strings, and symbols—is an object. The Ruby source code
    internally refers to these built-in types as “generic” types. How does Ruby store
    these generic objects? Do they also use the `RObject` structure?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no. Internally, Ruby uses a different C structure, not `RObject`,
    to save values for each of its generic data types. For example, Ruby saves string
    values in `RString` structures, arrays in `RArray` structures, regular expressions
    in `RRegexp` structures, and so on. Ruby uses `RObject` only to save instances
    of custom object classes that you create and a few custom object classes that
    Ruby creates internally. However, all of these different structures share the
    same `RBasic` information that we saw in `RObject`, as shown in [Figure 5-4](ch05.html#different_ruby_object_structures_all_use
    "Figure 5-4. Different Ruby object structures all use the RBasic structure.").
  prefs: []
  type: TYPE_NORMAL
- en: Since the `RBasic` structure contains the class pointer, each of these generic
    data types is also an object. Each is an instance of some Ruby class, as indicated
    by the class pointer saved inside `RBasic`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Different Ruby object structures all use the RBasic structure.](httpatomoreillycomsourcenostarchimages1854037.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4. Different Ruby object structures all use the `RBasic` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Ruby Values Don’t Require a Structure at All
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a performance optimization, Ruby saves small integers, symbols, and a few
    other simple values without any structure at all, placing them right inside the
    `VALUE` pointer, as shown in [Figure 5-5](ch05.html#ruby_saves_integers_in_the_value_pointer
    "Figure 5-5. Ruby saves integers in the VALUE pointer.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby saves integers in the VALUE pointer.](httpatomoreillycomsourcenostarchimages1854039.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5. Ruby saves integers in the `VALUE` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: These `VALUE`s are not pointers at all; they’re values themselves. For these
    simple data types, there is no class pointer. Instead, Ruby remembers the class
    using a series of bit flags saved in the first few bits of the `VALUE`. For example,
    all small integers have the `FIXNUM_FLAG` bit set, as shown in [Figure 5-6](ch05.html#fixnumunderscoreflag_indicates_this_is_a
    "Figure 5-6. FIXNUM_FLAG indicates this is an instance of the Fixnum class.").
  prefs: []
  type: TYPE_NORMAL
- en: '![FIXNUM_FLAG indicates this is an instance of the Fixnum class.](httpatomoreillycomsourcenostarchimages1854041.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6. `FIXNUM_FLAG` indicates this is an instance of the `Fixnum` class.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the `FIXNUM_FLAG` is set, Ruby knows that this `VALUE` is really a
    small integer, an instance of the `Fixnum` class, and not a pointer to a value
    structure. (A similar bit flag indicates whether the `VALUE` is a symbol, and
    values such as `nil`, `true`, and `false` also have their own flags.)
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to see that integers, strings, and other generic values are all objects
    by using IRB, as you can see in [Example 5-5](ch05.html#inspecting_classes_for_some_generic_valu
    "Example 5-5. Inspecting classes for some generic values").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5. Inspecting classes for some generic values
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that Ruby saves a class pointer or the equivalent bit flag for
    all values by calling the `class` method on each. In turn, the `class` method
    returns the class pointer, or at least the name of the class that each `klass`
    pointer refers to.
  prefs: []
  type: TYPE_NORMAL
- en: Do Generic Objects Have Instance Variables?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go back to our definition of a Ruby object:'
  prefs: []
  type: TYPE_NORMAL
- en: Every Ruby object is the combination of a class pointer and an array of instance
    variables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What about instance variables for generic objects? Do integers, strings, and
    other generic data values have instance variables? That would seem odd, but if
    integers and strings are objects, this must be true! And if it is true, where
    does Ruby save these values if it doesn’t use the `RObject` structure?
  prefs: []
  type: TYPE_NORMAL
- en: Using the `instance_variables` method, shown in [Example 5-6](ch05.html#saving_instance_variables_in_a_ruby_stri
    "Example 5-6. Saving instance variables in a Ruby string object"), you can see
    that each of these basic values can also contain an array of instance variables,
    strange as that may seem.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6. Saving instance variables in a Ruby string object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this exercise using symbols, arrays, or any Ruby value, and you’ll find
    that every Ruby value is an object and every object contains a class pointer and
    an array of instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the RBasic and RObject C Structure Definitions
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-7](ch05.html#definitions_of_the_rbasic_and_robjec "Example 5-7. The
    definitions of the RBasic and RObject C structures") shows the definitions of
    the `RBasic` and `RObject` C structures. (You can find this code in the *include/ruby/ruby.h*
    header file.)'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7. The definitions of the `RBasic` and `RObject` C structures
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top, you see the definition of `RBasic`. This definition contains the
    two values: `flags` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `klass` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Below,
    you see the `RObject` definition. Notice that it contains a copy of the `RBasic`
    structure at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg). Following
    this, the `union` keyword contains a structure called `heap` at ![](httpatomoreillycomsourcenostarchimages1854047.png.jpg),
    followed by an array called `ary` at ![](httpatomoreillycomsourcenostarchimages1854049.png.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `heap` structure at ![](httpatomoreillycomsourcenostarchimages1854047.png.jpg)
    contains the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the value `numiv` at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    tracks the number of instance variables contained in this object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, `ivptr` at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)
    is a pointer to an array containing the values of this object’s instance variables.
    Notice that the names, or IDs, of the instance variables are not stored here;
    only the values are stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iv_index_tbl` at ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)
    points to a hash table that maps between the name, or ID, of each instance variable
    and its location in the `ivptr` array. This value is actually stored in the `RClass`
    structure for this object’s class; this pointer is simply a cache, or shortcut,
    that Ruby uses to obtain that hash table quickly. (The `st_table` type refers
    to Ruby’s implementation of hash tables, which I’ll discuss in [Chapter 7](ch07.html
    "Chapter 7. The Hash Table: The Workhorse of Ruby Internals").)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last member of the `RObject` structure, `ary` at ![](httpatomoreillycomsourcenostarchimages1854049.png.jpg),
    occupies the same memory space as all previous values because of the `union` keyword
    at the top. Using this `ary` value, Ruby can save all of the instance variables
    right inside the `RObject` structure—if they’ll fit. This eliminates the need
    to call `malloc` to allocate extra memory to hold the instance variable value
    array. (Ruby also uses this sort of optimization for the `RString`, `RArray`,
    `RStruct`, and `RBignum` structures.)
  prefs: []
  type: TYPE_NORMAL
- en: Where Does Ruby Save Instance Variables for Generic Objects?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, Ruby uses a bit of a hack to save instance variables for generic
    objects—that is, for objects that don’t use an `RObject` structure. When you save
    an instance variable in a generic object, Ruby saves it in a special hash called
    `generic_iv_tbl`. This hash maintains a map between generic objects and pointers
    to other hashes that contain each object’s instance variables. [Figure 5-7](ch05.html#genericunderscoreivunderscoretbl_stores
    "Figure 5-7. generic_iv_tbl stores instance variables for generic objects.") shows
    how this would look for the `str` string example in [Example 5-6](ch05.html#saving_instance_variables_in_a_ruby_stri
    "Example 5-6. Saving instance variables in a Ruby string object").
  prefs: []
  type: TYPE_NORMAL
- en: '![generic_iv_tbl stores instance variables for generic objects.](httpatomoreillycomsourcenostarchimages1854051.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7. `generic_iv_tbl` stores instance variables for generic objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 5-1: How Long Does It Take to Save a New Instance Variable?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about how Ruby saves instance variables internally, let’s measure
    how long it takes Ruby to save one in an object. To do this, I’ll create a large
    number of test objects, as shown in [Example 5-8](ch05.html#creating_test_objects_using_classdotnew
    "Example 5-8. Creating test objects using Class.new").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-8. Creating test objects using `Class.new`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’m using `Class.new` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    to create a unique class for each new object in order to make sure they’re all
    independent. I’ve also disabled garbage collection at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    to avoid skewing the results with GC operations. Then, in [Example 5-9](ch05.html#adding_instance_variables_to_each_test_o
    "Example 5-9. Adding instance variables to each test object"), I add instance
    variables to each.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9. Adding instance variables to each test object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5-9](ch05.html#adding_instance_variables_to_each_test_o "Example 5-9. Adding
    instance variables to each test object") iterates 20 times, repeatedly saving
    one more new instance variable to each of the objects. [Figure 5-8](ch05.html#time_to_add_one_more_instance_variable_l
    "Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs.
    instance variable count") shows the time that it takes Ruby 2.0 to add each variable:
    The first bar on the left is the time it takes to save the first instance variable
    in all the objects, and each subsequent bar is the additional time taken to save
    one more instance variable in each object.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time to add one more instance variable (in seconds x 100,000) vs. instance
    variable count](httpatomoreillycomsourcenostarchimages1854053.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs.
    instance variable count
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-8](ch05.html#time_to_add_one_more_instance_variable_l "Figure 5-8. Time
    to add one more instance variable (in seconds x 100,000) vs. instance variable
    count") shows a strange pattern. Sometimes it takes Ruby longer to add a new instance
    variable. What’s going on here?'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this behavior has to do with the `ivptr` array where Ruby stores
    the instance variables, as shown in [Figure 5-9](ch05.html#two_instance_variables_saved_in_an_objec
    "Figure 5-9. Two instance variables saved in an object").
  prefs: []
  type: TYPE_NORMAL
- en: '![Two instance variables saved in an object](httpatomoreillycomsourcenostarchimages1854055.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9. Two instance variables saved in an object
  prefs: []
  type: TYPE_NORMAL
- en: In Ruby 1.8 this array is a hash table containing both the variable names (the
    hash keys) and the values, which will automatically expand to accommodate any
    number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby 1.9 and 2.0 speed things up a bit by saving the values in a simple array.
    The instance variable names are saved in the object’s class instead, because they’re
    the same for all instances of a class. As a result, Ruby 1.9 and 2.0 need to either
    preallocate a large array to handle any number of instance variables or repeatedly
    increase the size of this array as you save more variables.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, as you can see in [Figure 5-8](ch05.html#time_to_add_one_more_instance_variable_l
    "Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs.
    instance variable count"), Ruby 1.9 and 2.0 repeatedly increase the array size.
    For example, suppose you have seven instance variables in a given object, as shown
    in [Figure 5-10](ch05.html#seven_instance_variables_in_an_object "Figure 5-10. Seven
    instance variables in an object").
  prefs: []
  type: TYPE_NORMAL
- en: '![Seven instance variables in an object](httpatomoreillycomsourcenostarchimages1854057.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10. Seven instance variables in an object
  prefs: []
  type: TYPE_NORMAL
- en: When you add the eighth variable—bar 8 in [Figure 5-8](ch05.html#time_to_add_one_more_instance_variable_l
    "Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs.
    instance variable count")—Ruby 1.9 and 2.0 increase the array size by three, anticipating
    that you will soon add more variables, as shown in [Figure 5-11](ch05.html#adding_an_eighth_value_allocates_extra_s
    "Figure 5-11. Adding an eighth value allocates extra space.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an eighth value allocates extra space.](httpatomoreillycomsourcenostarchimages1854059.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-11. Adding an eighth value allocates extra space.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating more memory takes extra time, which is why bar 8 is higher. Now if
    you add two more instance variables, Ruby 1.9 and 2.0 won’t need to reallocate
    memory for this array because the space will already be available. This explains
    the shorter times for bars 9 and 10.
  prefs: []
  type: TYPE_NORMAL
- en: What’s Inside the RClass Structure?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every object remembers its class by saving a pointer to an `RClass` structure.
    What information does each `RClass` structure contain? What would we see if we
    could look inside a Ruby class? Let’s build a model of the information that must
    be present in `RClass`. This model will give us a technical definition of what
    a Ruby class is, based on what we know classes can do.
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1854061.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Two objects, one class*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Ruby developer knows how to write a class: You type the `class` keyword,
    specify a name for the new class, and then type in the class’s methods. [Example 5-10](ch05.html#same_simple_ruby_class_we_saw_in_lis
    "Example 5-10. The same simple Ruby class we saw in Example 5-1") shows a familiar
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10. The same simple Ruby class we saw in [Example 5-1](ch05.html#simple_ruby_class
    "Example 5-1. A simple Ruby class")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`attr_accessor` is shorthand for defining get and set methods for an attribute.
    (The methods defined by `attr_accessor` also check for `nil` values). [Example 5-11](ch05.html#same_class_written_without_attrunder
    "Example 5-11. The same class written without attr_accessor") shows a more verbose
    way of defining the same `Mathematician` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-11. The same class written without `attr_accessor`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears that this class—and every Ruby class—is just a group of method definitions.
    You can assign behavior to an object by adding methods to its class, and when
    you call a method on an object, Ruby looks for the method in the object’s class.
    This leads to our first definition of a Ruby class:'
  prefs: []
  type: TYPE_NORMAL
- en: A Ruby class is a group of method definitions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Therefore, the `RClass` structure for `Mathematician` must save a list of all
    the methods defined in the class, as shown in [Figure 5-12](ch05.html#ruby_classes_contain_a_method_tabledot
    "Figure 5-12. Ruby classes contain a method table.").
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in [Example 5-11](ch05.html#same_class_written_without_attrunder "Example 5-11. The
    same class written without attr_accessor") that I’ve also created two instance
    variables: `@first_name` and `@last_name`. We saw earlier how Ruby stores these
    values in each `RObject` structure, but you may have noticed that only the *values*
    of these variables are stored in `RObject`, not their names. (Ruby 1.8 does store
    the names in `RObject`.) Ruby must store the attribute names in `RClass`, which
    makes sense because the names will be the same for every `Mathematician` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby classes contain a method table.](httpatomoreillycomsourcenostarchimages1854063.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-12. Ruby classes contain a method table.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s redraw `RClass` again and include a table of attribute names this time,
    as shown in [Figure 5-13](ch05.html#ruby_classes_also_contain_a_table_of_att "Figure 5-13. Ruby
    classes also contain a table of attribute names.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby classes also contain a table of attribute names.](httpatomoreillycomsourcenostarchimages1854065.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-13. Ruby classes also contain a table of attribute names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our definition of a Ruby class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A Ruby class is a group of method definitions and a table of attribute names.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the beginning of this chapter, I mentioned that every value in Ruby is an
    object. This might be true for classes, too. Let’s prove this using IRB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Ruby classes are all instances of the `Class` class; therefore,
    classes are also objects. Now to update our definition of a Ruby class again:'
  prefs: []
  type: TYPE_NORMAL
- en: A Ruby class is a Ruby object that also contains method definitions and attribute
    names.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because Ruby classes are objects, we know that the `RClass` structure must also
    contain a class pointer and an instance variable array, the values that we know
    every Ruby object contains, as shown in [Figure 5-14](ch05.html#ruby_classes_also_contain_a_class_pointe
    "Figure 5-14. Ruby classes also contain a class pointer and instance variables.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby classes also contain a class pointer and instance variables.](httpatomoreillycomsourcenostarchimages1854067.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-14. Ruby classes also contain a class pointer and instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, I’ve added a pointer to the `Class` class, which is in theory
    the class of every Ruby class object. However, in [Experiment 5-2: Where Does
    Ruby Save Class Methods?](ch05.html#experiment_5-2_where_does_ruby_save_clas "Experiment
    5-2: Where Does Ruby Save Class Methods?"), I’ll show that this diagram is in
    fact not accurate—that `klass` actually points to something else! I’ve also added
    a table of instance variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*These are the class-level instance variables. Don’t confuse these with the
    table of attribute names for the object-level instance variables.*'
  prefs: []
  type: TYPE_NORMAL
- en: This is rapidly getting out of control! The `RClass` structure seems to be much
    more complex than the `RObject` structure. But don’t worry—we’re getting close
    to an accurate picture of the `RClass` structure. Next we need to consider two
    more important types of information contained in each Ruby class.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance is an essential feature of object-oriented programming. Ruby implements
    single inheritance by allowing us to optionally specify one superclass when we
    create a class. If we don’t specify a superclass, Ruby assigns the `Object` class
    as the superclass. For example, we could rewrite the `Mathematician` class using
    a superclass like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now every instance of `Mathematician` will include the same methods that instances
    of `Person` have. In this example, we might want to move the `first_name` and
    `last_name` accessor methods into `Person`. We could also move the `@first_name`
    and `@last_name` attributes into the `Person` class. Every instance of `Mathematician`
    will contain these methods and attributes, even though we moved them to the `Person`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The `Mathematician` class must contain a reference to the `Person` class (its
    superclass) so that Ruby can find any methods or attributes defined in the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update our definition again, assuming that Ruby tracks the superclass
    using another pointer similar to `klass`:'
  prefs: []
  type: TYPE_NORMAL
- en: A Ruby class is a Ruby object that also contains method definitions, attribute
    names, and a superclass pointer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And let’s redraw the `RClass` structure to include the new superclass pointer,
    as shown in [Figure 5-15](ch05.html#ruby_classes_also_contain_a_superclass_p "Figure 5-15. Ruby
    classes also contain a superclass pointer.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby classes also contain a superclass pointer.](httpatomoreillycomsourcenostarchimages1854069.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-15. Ruby classes also contain a superclass pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it is critical to understand the difference between the `klass`
    pointer and the `super` pointer. The `klass` pointer indicates which class the
    Ruby class object is an instance of. This will always be the `Class` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Ruby uses the `klass` pointer to find the methods of the `Mathematician` class
    object, such as the `new` method that every Ruby class implements. However, the
    `super` pointer records the class’s superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Ruby uses the `super` pointer to help find methods contained in each `Mathematician`
    instance, such as `first_name=` or `last_name`. As we’ll see next, Ruby also uses
    the `super` pointer when getting or setting class variables.
  prefs: []
  type: TYPE_NORMAL
- en: Class Instance Variables vs. Class Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One confusing bit of Ruby syntax is the concept of *class variables*. You might
    think that these are simply the instance variables of a class (the class-level
    instance variables from [Figure 5-14](ch05.html#ruby_classes_also_contain_a_class_pointe
    "Figure 5-14. Ruby classes also contain a class pointer and instance variables.")),
    but class instance variables and class variables are distinctly different.
  prefs: []
  type: TYPE_NORMAL
- en: To create a class instance variable, you simply create an instance variable
    using the `@` symbol, but in the context of a class rather than an object. For
    example, [Example 5-12](ch05.html#creating_a_class-level_instance_variable "Example 5-12. Creating
    a class-level instance variable") shows how we could use an instance variable
    of `Mathematician` to indicate a branch of mathematics this class corresponds
    to. We create the `@type` instance variable at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12. Creating a class-level instance variable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In contrast, to create a class variable, you would use the `@@` notation. [Example 5-13](ch05.html#creating_a_class_variable
    "Example 5-13. Creating a class variable") shows the same example, with the class
    variable `@@type` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) created.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-13. Creating a class variable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What’s the difference? When you create a class variable, Ruby creates a single
    value for you to use in that class and in any subclasses you might define. On
    the other hand, using a class *instance* variable causes Ruby to create a separate
    value for each class or subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review [Example 5-14](ch05.html#each_class_and_subclass_has_its_own_inst
    "Example 5-14. Each class and subclass has its own instance variables.") to see
    how Ruby handles these two types of variables differently. First, I define a class
    instance variable called `@type` in the `Mathematician` class and set its value
    to the string `General`. Next, I create a second class called `Statistician`,
    which is a subclass of `Mathematician`, and change the value of `@type` to the
    string `Statistics`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-14. Each class and subclass has its own instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the values of `@type` in `Statistician` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `Mathematician` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    are different. Each class has its own separate copy of `@type`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if I use a class variable instead, Ruby shares that value between `Mathematician`
    and `Statistician`, as demonstrated in [Example 5-15](ch05.html#ruby_shares_class_variables_among_a_clas
    "Example 5-15. Ruby shares class variables among a class and all of its subclasses.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-15. Ruby shares class variables among a class and all of its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, Ruby shows the same value for `@@type` in `Statistician` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and in `Mathematician` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Internally, however, Ruby actually saves both class variables and class instance
    variables in the same table inside the `RClass` structure. [Figure 5-16](ch05.html#ruby_saves_class_variables_and_class_ins
    "Figure 5-16. Ruby saves class variables and class instance variables in the same
    table.") shows how the `Mathematician` class would save the `@type` and `@@type`
    values if you created both of them. The extra `@` symbol in the name allows Ruby
    to distinguish between the two types of variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby saves class variables and class instance variables in the same table.](httpatomoreillycomsourcenostarchimages1854071.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-16. Ruby saves class variables and class instance variables in the
    same table.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Setting Class Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s true: Ruby saves both class variables and class instance variables in
    the same table. However, the ways Ruby gets or sets these two types of variables
    are quite different.'
  prefs: []
  type: TYPE_NORMAL
- en: When you get or set a class instance variable, Ruby looks up the variable in
    the `RClass` structure corresponding to the target class and either saves or retrieves
    the value. [Figure 5-17](ch05.html#ruby_saves_class_instance_variables_in_t "Figure 5-17. Ruby
    saves class instance variables in the RClass structure of the target class.")
    shows how Ruby saves the class instance variables from [Example 5-14](ch05.html#each_class_and_subclass_has_its_own_inst
    "Example 5-14. Each class and subclass has its own instance variables.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby saves class instance variables in the RClass structure of the target
    class.](httpatomoreillycomsourcenostarchimages1854073.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-17. Ruby saves class instance variables in the `RClass` structure of
    the target class.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the figure, you can see a line of code that saves a class instance
    variable in `Mathematician`. Below that is a similar line of code that saves a
    value in `Statistician`. In both cases, Ruby saves the class instance variable
    in the `RClass` structure for the current class.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby uses a more complex algorithm for class variables. To produce the behavior
    we saw in [Example 5-15](ch05.html#ruby_shares_class_variables_among_a_clas "Example 5-15. Ruby
    shares class variables among a class and all of its subclasses."), Ruby needs
    to search through all the superclasses to see whether any of them define the same
    class variable. [Figure 5-18](ch05.html#before_saving_itcomma_ruby_checks_whethe
    "Figure 5-18. Before saving it, Ruby checks whether the class variable exists
    in the target class or any of its superclasses.") shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Before saving it, Ruby checks whether the class variable exists in the target
    class or any of its superclasses.](httpatomoreillycomsourcenostarchimages1854075.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-18. Before saving it, Ruby checks whether the class variable exists
    in the target class or any of its superclasses.
  prefs: []
  type: TYPE_NORMAL
- en: When you save a class variable, Ruby looks in the target class and all of its
    superclasses for an existing variable. It will use the copy found in the highest
    superclass. In [Figure 5-18](ch05.html#before_saving_itcomma_ruby_checks_whethe
    "Figure 5-18. Before saving it, Ruby checks whether the class variable exists
    in the target class or any of its superclasses.") you can see Ruby checks both
    the `Statistician` and `Mathematician` classes when saving the `@@type` class
    variable in `Statistician`. Because I already saved the same class variable in
    `Mathematician` ([Example 5-15](ch05.html#ruby_shares_class_variables_among_a_clas
    "Example 5-15. Ruby shares class variables among a class and all of its subclasses.")),
    Ruby will use that and overwrite it with the new value, as shown in [Figure 5-19](ch05.html#ruby_uses_the_class_variable_copy_found
    "Figure 5-19. Ruby uses the class variable copy found in the highest superclass.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby uses the class variable copy found in the highest superclass.](httpatomoreillycomsourcenostarchimages1854077.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-19. Ruby uses the class variable copy found in the highest superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have one more feature of Ruby classes to cover: *constants*. As you may
    know, Ruby allows you to define constant values inside a class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Constant values must start with a capital letter, and they are valid within
    the scope of the current class. (Curiously, Ruby allows you to change a constant
    value, but it will display a warning when you do so.) Let’s add a constant table
    to our `RClass` structure, because Ruby must save these values inside each class,
    as shown in [Figure 5-20](ch05.html#ruby_classes_also_contain_a_constants_ta "Figure 5-20. Ruby
    classes also contain a constants table.").
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write a complete, technical definition of a Ruby class:'
  prefs: []
  type: TYPE_NORMAL
- en: A Ruby class is a Ruby object that also contains method definitions, attribute
    names, a superclass pointer, and a constants table.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Granted, this isn’t as concise as the simple definition we had for a Ruby object,
    but each Ruby class contains much more information than each Ruby object. Ruby
    classes are obviously fundamental to the language.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby classes also contain a constants table.](httpatomoreillycomsourcenostarchimages1854079.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-20. Ruby classes also contain a constants table.
  prefs: []
  type: TYPE_NORMAL
- en: The Actual RClass Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having built up a conceptual model for what information must be stored in `RClass`,
    let’s look at the actual structure that Ruby uses to represent classes, as shown
    in [Figure 5-21](ch05.html#how_ruby_actually_represents_a_class "Figure 5-21. How
    Ruby actually represents a class").
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, Ruby uses two separate structures to represent each class:
    `RClass` and `rb_classext_struct`. But these two structures act as one large structure
    because each `RClass` always contains a pointer (`ptr`) to a corresponding `rb_classext_struct`.
    You might guess that the Ruby core team decided to use two different structures
    because there are so many different values to save, but in fact they probably
    created `rb_classext_struct` to save internal values that they didn’t want to
    expose in the public Ruby C extension API.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `RObject`, `RClass` has a `VALUE` pointer (shown on the left of [Figure 5-21](ch05.html#how_ruby_actually_represents_a_class
    "Figure 5-21. How Ruby actually represents a class")). Ruby always accesses classes
    using these `VALUE` pointers. The right side of the figure shows the technical
    names for the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flags` and `klass` are the same `RBasic` values that every Ruby value contains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m_tbl` is the method table, a hash whose keys are the names, or IDs, of each
    method and whose values are pointers to the definition of each method, including
    the compiled YARV instructions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iv_index_tbl` is the attribute names table, a hash that maps each instance
    variable name to the index of the attribute’s value in each `RObject` instance
    variable array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`super` is a pointer to the `RClass` structure for this class’s superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How Ruby actually represents a class](httpatomoreillycomsourcenostarchimages1854081.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5-21. How Ruby actually represents a class
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`iv_tbl` contains the class-level instance variables and class variables, including
    both their names and values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const_tbl` is a hash containing all of the constants (names and values) defined
    in this class’s scope. You can see that Ruby implements `iv_tbl` and `const_tbl`
    in the same way: Class-level instance variables and constants are almost the same
    thing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby uses `origin` to implement the `Module#prepend` feature. I’ll discuss what
    `prepend` does and how Ruby implements it in [Chapter 6](ch06.html "Chapter 6. Method
    Lookup and Constant Lookup").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby uses the `refined_class` pointer to implement the new experimental refinements
    feature, which I’ll discuss further in [Chapter 9](ch09.html "Chapter 9. Metaprogramming").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Ruby uses `allocator` internally to allocate memory for new instances
    of this class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the RClass C Structure Definition
  prefs: []
  type: TYPE_NORMAL
- en: Now for a quick look at the actual `RClass` structure definition, as shown in
    [Example 5-16](ch05.html#definition_of_the_rclass_c_structure "Example 5-16. The
    definition of the RClass C structure").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-16. The definition of the `RClass` C structure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Like the `RObject` definition we saw in [Example 5-7](ch05.html#definitions_of_the_rbasic_and_robjec
    "Example 5-7. The definitions of the RBasic and RObject C structures"), this structure
    definition—including all of the values shown in [Figure 5-21](ch05.html#how_ruby_actually_represents_a_class
    "Figure 5-21. How Ruby actually represents a class")—can be found in the *`include/ruby/ruby.h`*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The `rb_classext_struct` structure definition, on the other hand, can be found
    in the *internal.h* C header file, as shown in [Example 5-17](ch05.html#definition_of_the_rbunderscoreclasse
    "Example 5-17. The definition of the rb_classext_struct C structure").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-17. The definition of the `rb_classext_struct` C structure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you can see the values from [Figure 5-21](ch05.html#how_ruby_actually_represents_a_class
    "Figure 5-21. How Ruby actually represents a class"). Notice that the `st_table`
    C type appears four times in [Example 5-16](ch05.html#definition_of_the_rclass_c_structure
    "Example 5-16. The definition of the RClass C structure") and [Example 5-17](ch05.html#definition_of_the_rbunderscoreclasse
    "Example 5-17. The definition of the rb_classext_struct C structure"); this is
    Ruby’s hash table data structure. Internally, Ruby saves much of the information
    for each class using hash tables: the attribute names table, the method table,
    the class-level instance variable table, and the constants table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 5-2: Where Does Ruby Save Class Methods?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve seen how each `RClass` structure saves all methods defined in a certain
    class. In this example, Ruby stores information about the `first_name` method
    inside the `RClass` structure for `Mathematician` using the method table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But what about class methods? It’s common in Ruby to save methods in a class
    directly, using the syntax shown in [Example 5-18](ch05.html#defining_a_class_method_using_def_self
    "Example 5-18. Defining a class method using def self").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-18. Defining a class method using `def self`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can use the syntax shown in [Example 5-19](ch05.html#defining_a_class_method_using_class_less
    "Example 5-19. Defining a class method using class << self").
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-19. Defining a class method using `class << self`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Are they saved in the `RClass` structure along with the normal methods for each
    class, perhaps with a flag to indicate they are class methods and not normal methods?
    Or are they saved somewhere else? Let’s find out!
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easy to see where class methods are *not* saved. They are obviously not
    saved in the `RClass` method table along with normal methods, because instances
    of `Mathematician` cannot call them, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, keeping in mind that `Mathematician` is also a Ruby object, recall the
    following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: A Ruby class is a Ruby object that also contains method definitions, attribute
    names, a superclass pointer, and a constants table.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We assume that Ruby should save methods for `Mathematician` just as it saves
    them for any object: in the method table for the object’s class. In other words,
    Ruby should get `Mathematician`’s class using the `klass` pointer and save the
    method in the method table in that `RClass` structure, as shown in [Figure 5-22](ch05.html#shouldnapostrophet_ruby_save_class_metho
    "Figure 5-22. Shouldn’t Ruby save class methods in the method table for the class’s
    class?").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shouldn’t Ruby save class methods in the method table for the class’s class?](httpatomoreillycomsourcenostarchimages1854083.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-22. Shouldn’t Ruby save class methods in the method table for the class’s
    class?
  prefs: []
  type: TYPE_NORMAL
- en: 'But Ruby doesn’t actually do this, as you can discover by creating another
    class and trying to call the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If Ruby had added the class method to the method table in the `Class` class,
    all classes in your application would have the method. Obviously this isn’t what
    we intended by writing a class method, and thankfully Ruby doesn’t implement class
    methods this way.
  prefs: []
  type: TYPE_NORMAL
- en: Then where do the class methods go? For a clue, use the method `ObjectSpace.count_objects`,
    `shown in [Example 5-20](ch05.html#using_objectspacedotcountunderscoreobjec "Example 5-20. Using
    ObjectSpace.count_objects with :T_CLASS"):`
  prefs: []
  type: TYPE_NORMAL
- en: '`` Example 5-20. Using `ObjectSpace.count_objects` with `:T_CLASS` ``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`` `ObjectSpace.count_objects` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    returns the number of objects of a given type that exist. In this test, I’m passing
    the :`T_CLASS` symbol to get the count of class objects that exist in my IRB session.
    Before I create `Mathematician`, there are 859 classes at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    After I declare `Mathematician`, there are 861 at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)—two
    more. That’s odd. I declared one new class, but Ruby actually created two! What
    is the second one for and where is it? ``'
  prefs: []
  type: TYPE_NORMAL
- en: '``It turns out that whenever you create a new class, internally Ruby creates
    two classes! The first class is your new class: Ruby creates a new `RClass` structure
    to represent your class, as described above. But internally Ruby also creates
    a second, hidden class called the *metaclass*. Why? To save any class methods
    that you might later create for your new class. In fact, Ruby sets the metaclass
    to be the class of your new class: It sets the `klass` pointer of your new `RClass`
    structure to point to the metaclass.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``Without writing C code, there’s no easy way to see the metaclass or the `klass`
    pointer value, but you can obtain the metaclass as a Ruby object like this:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '``The first print statement displays the object’s class, while the second displays
    the object’s metaclass. The odd `#<Class:Mathematician>` syntax indicates that
    the second class is the metaclass for `Mathematician`. This is the second `RClass`
    structure that Ruby automatically created for me when I declared the `Mathematician`
    class. And this second `RClass` structure is where Ruby saves my class method,
    as shown in [Figure 5-23](ch05.html#objectcomma_its_classcomma_and_its_me "Figure 5-23. An
    object, its class, and its metaclass").``'
  prefs: []
  type: TYPE_NORMAL
- en: '`![An object, its class, and its metaclass](httpatomoreillycomsourcenostarchimages1854085.png.jpg)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Figure 5-23. An object, its class, and its metaclass`'
  prefs: []
  type: TYPE_NORMAL
- en: '``If we now display the methods for the metaclass, we’ll see all the methods
    of the `Class` class, along with the new class method for `Mathematician`:``'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`Summary`'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '``In this chapter we’ve seen how Ruby represents objects and classes internally:
    Ruby uses the `RObject` structure to represent instances of any custom classes
    you define in your code and of some classes predefined by Ruby itself. The `RObject`
    structure is remarkably simple, containing just a pointer to the object’s class
    and a table of instance variable values, along with a count of the variables.
    The simplicity of its structure leads us to a very simple definition of a Ruby
    object:``'
  prefs: []
  type: TYPE_NORMAL
- en: '`Every Ruby object is the combination of a class pointer and an array of instance
    variables.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`This definition is powerful and useful because everything in Ruby is an object:
    Whenever you use a value in your Ruby program, regardless of what it is, remember
    that it will be an object and will therefore have a class pointer and instance
    variables.`'
  prefs: []
  type: TYPE_NORMAL
- en: '``We also saw that Ruby uses special C structures to represent instances of
    many commonly used, built-in Ruby classes called “generic” objects. For example,
    Ruby uses the `RString` structure to represent an instance of the `String` class,
    `RArray` for an instance of the `Array` class, or `RRegexp` for an instance of
    the `Regexp` class. While these structures are different, Ruby also saves a class
    pointer and an array of instance variables for each of these generic objects.
    Finally, we saw that Ruby saves some simple values, such as small integers and
    symbols, without using a C structure at all. Ruby saves these values right inside
    the `VALUE` pointers that otherwise would point to the structure holding the value.``'
  prefs: []
  type: TYPE_NORMAL
- en: '``While Ruby objects are simple, we learned in this chapter that Ruby classes
    aren’t quite so simple. The `RClass` structure working with the `rb_classext_struct`
    structure saves a large set of information. Learning this forced us to write a
    more complex definition for Ruby classes:``'
  prefs: []
  type: TYPE_NORMAL
- en: '`A Ruby class is a Ruby object that also contains method definitions, attribute
    names, a superclass pointer, and a constants table.`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '``Looking inside `RClass` and `rb_classext_struct`, we saw that Ruby classes
    are also Ruby objects, which therefore also contain instance variables and a class
    pointer. We looked at the difference between a class’s instance variables and
    class variables and learned that Ruby saves both of these variable types in the
    same hash table. We discovered how classes also contain a series of hash tables
    that store their methods, the names of the object-level instance variables, and
    constants defined within the class. Finally, we saw how each Ruby class records
    its superclass using the `super` pointer.``'
  prefs: []
  type: TYPE_NORMAL
