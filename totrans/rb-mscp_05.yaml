- en: Chapter 5. Objects and Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 对象与类
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Every Ruby object is the combination of a class pointer and an array of instance
    variables.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*每个 Ruby 对象是类指针和实例变量数组的结合体。*'
- en: 'We learn early on that Ruby is an object-oriented language, descended from
    languages like Smalltalk and Simula. Every value is an object, and all Ruby programs
    consist of a set of objects and the messages sent between them. Typically, we
    learn about object-oriented programming by looking at how to use objects and what
    they can do: how they can group together data values and behavior related to those
    values; how each class should have a single responsibility or purpose; and how
    different classes can be related to each other through encapsulation or inheritance.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们早期就学到，Ruby 是一种面向对象的语言，源自像 Smalltalk 和 Simula 这样的语言。每个值都是一个对象，所有 Ruby 程序由一组对象和它们之间发送的消息组成。通常，我们通过了解如何使用对象以及它们能做什么来学习面向对象编程：如何将数据值和与这些值相关的行为组合在一起；如何使每个类具有单一责任或目的；以及不同的类如何通过封装或继承彼此关联。
- en: But what are Ruby objects? What information does an object contain? If we were
    to look at a Ruby object through a microscope, what would we see? Are there any
    moving parts inside? And what about Ruby classes? What exactly is a class?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Ruby 对象是什么？一个对象包含什么信息？如果我们通过显微镜查看 Ruby 对象，我们会看到什么？内部有运动的部分吗？那么 Ruby 类呢？类究竟是什么？
- en: I’ll answer these questions in this chapter by exploring how Ruby works internally.
    By looking at how Ruby implements objects and classes, you’ll learn how to use
    them and how to write object-oriented programs using Ruby.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章中通过探讨 Ruby 的内部工作原理来回答这些问题。通过查看 Ruby 如何实现对象和类，您将学习如何使用它们以及如何使用 Ruby 编写面向对象的程序。
- en: Roadmap
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[Inside a Ruby Object](ch05.html#inside_a_ruby_object "Inside a Ruby Object")'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 对象内部](ch05.html#inside_a_ruby_object "Ruby 对象内部")'
- en: '[Inspecting klass and ivptr](ch05.html#inspecting_klass_and_ivptr "Inspecting
    klass and ivptr")'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[检查 klass 和 ivptr](ch05.html#inspecting_klass_and_ivptr "检查 klass 和 ivptr")'
- en: '[Visualizing Two Instances of One Class](ch05.html#visualizing_two_instances_of_one_class
    "Visualizing Two Instances of One Class")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可视化一个类的两个实例](ch05.html#visualizing_two_instances_of_one_class "可视化一个类的两个实例")'
- en: '[Generic Objects](ch05.html#generic_objects "Generic Objects")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通用对象](ch05.html#generic_objects "通用对象")'
- en: '[Simple Ruby Values Don’t Require a Structure at All](ch05.html#simple_ruby_values_donapostrophet_requir
    "Simple Ruby Values Don’t Require a Structure at All")'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[简单的 Ruby 值根本不需要结构](ch05.html#simple_ruby_values_donapostrophet_requir "简单的
    Ruby 值根本不需要结构")'
- en: '[Do Generic Objects Have Instance Variables?](ch05.html#do_generic_objects_have_instance_variabl
    "Do Generic Objects Have Instance Variables?")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通用对象有实例变量吗？](ch05.html#do_generic_objects_have_instance_variabl "通用对象有实例变量吗？")'
- en: '[Reading the RBasic and RObject C Structure Definitions](ch05.html#reading_the_rbasic_and_robject_c_structu
    "Reading the RBasic and RObject C Structure Definitions")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[阅读 RBasic 和 RObject C 结构定义](ch05.html#reading_the_rbasic_and_robject_c_structu
    "阅读 RBasic 和 RObject C 结构定义")'
- en: '[Where Does Ruby Save Instance Variables for Generic Objects?](ch05.html#where_does_ruby_save_instance_variables
    "Where Does Ruby Save Instance Variables for Generic Objects?")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Ruby 为通用对象保存实例变量的位置在哪里？](ch05.html#where_does_ruby_save_instance_variables
    "Ruby 为通用对象保存实例变量的位置在哪里？")'
- en: '**[Experiment 5-1: How Long Does It Take to Save a New Instance Variable?](ch05.html#experiment_5-1_how_long_does_it_take_to
    "Experiment 5-1: How Long Does It Take to Save a New Instance Variable?")**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 5-1：保存一个新的实例变量需要多长时间？](ch05.html#experiment_5-1_how_long_does_it_take_to
    "实验 5-1：保存一个新的实例变量需要多长时间？")**'
- en: '[What’s Inside the RClass Structure?](ch05.html#whatapostrophes_inside_the_rclass_struct
    "What’s Inside the RClass Structure?")'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RClass 结构内部是什么？](ch05.html#whatapostrophes_inside_the_rclass_struct "RClass
    结构内部是什么？")'
- en: '[Inheritance](ch05.html#inheritance "Inheritance")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[继承](ch05.html#inheritance "继承")'
- en: '[Class Instance Variables vs. Class Variables](ch05.html#class_instance_variables_vsdot_class_var
    "Class Instance Variables vs. Class Variables")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[类实例变量与类变量](ch05.html#class_instance_variables_vsdot_class_var "类实例变量与类变量")'
- en: '[Getting and Setting Class Variables](ch05.html#getting_and_setting_class_variables
    "Getting and Setting Class Variables")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[获取和设置类变量](ch05.html#getting_and_setting_class_variables "获取和设置类变量")'
- en: '[Constants](ch05.html#constants "Constants")'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[常量](ch05.html#constants "常量")'
- en: '[The Actual RClass Structure](ch05.html#actual_rclass_structure "The Actual
    RClass Structure")'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实际的RClass结构](ch05.html#actual_rclass_structure "实际的RClass结构")'
- en: '[Reading the RClass C Structure Definition](ch05.html#reading_the_rclass_c_structure_definitio
    "Reading the RClass C Structure Definition")'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[读取RClass C结构定义](ch05.html#reading_the_rclass_c_structure_definitio "读取RClass
    C结构定义")'
- en: '**[Experiment 5-2: Where Does Ruby Save Class Methods?](ch05.html#experiment_5-2_where_does_ruby_save_clas
    "Experiment 5-2: Where Does Ruby Save Class Methods?")**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验5-2：Ruby将类方法保存在哪里？](ch05.html#experiment_5-2_where_does_ruby_save_clas
    "实验5-2：Ruby将类方法保存在哪里？")**'
- en: '[Summary](ch05.html#summary-id00017 "Summary")'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[摘要](ch05.html#summary-id00017 "摘要")'
- en: Inside a Ruby Object
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruby对象内部
- en: Ruby saves each of your custom objects in a C structure called `RObject`, which
    looks like [Figure 5-1](ch05.html#robject_structure "Figure 5-1. The RObject structure")
    in Ruby 1.9 and 2.0.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby将你的每个自定义对象保存在一个名为`RObject`的C结构中，在Ruby 1.9和2.0中，它的结构如[图5-1](ch05.html#robject_structure
    "图5-1. RObject结构")所示。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1854029.png.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明的图片](httpatomoreillycomsourcenostarchimages1854029.png.jpg)'
- en: '*If I could slice open a Ruby object, what would I see?*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我能切开一个Ruby对象，我会看到什么？*'
- en: 'At the top of the figure is a pointer to the `RObject` structure. (Internally,
    Ruby always refers to any value with a `VALUE` pointer.) Below this pointer, the
    `RObject` structure contains an inner `RBasic` structure and information specific
    to custom objects. The `RBasic` section contains information that all values use:
    a set of Boolean values called `flags` that store a variety of internal technical
    values, and a class pointer called `klass`. The class pointer indicates which
    class an object is an instance of. In the `RObject` section, Ruby saves an array
    of instance variables that each object contains, using `numiv`, the instance variable
    count, and `ivptr`, a pointer to an array of values.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图形顶部是指向`RObject`结构的指针。（在内部，Ruby始终使用`VALUE`指针来引用任何值。）在此指针下，`RObject`结构包含一个内部的`RBasic`结构和与自定义对象相关的特定信息。`RBasic`部分包含所有值都使用的信息：一组名为`flags`的布尔值，存储各种内部技术值，以及一个名为`klass`的类指针。类指针指示对象是哪个类的实例。在`RObject`部分，Ruby保存了每个对象包含的实例变量数组，使用`numiv`表示实例变量计数，`ivptr`是指向值数组的指针。
- en: If we were to define the Ruby object structure in technical terms, we could
    say
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用技术术语定义Ruby对象结构，我们可以说
- en: Every Ruby object is the combination of a class pointer and an array of instance
    variables.
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个Ruby对象都是类指针和实例变量数组的组合。
- en: At first glance, this definition doesn’t seem very useful because it doesn’t
    help us understand the meaning or purpose behind objects or how to use them in
    a Ruby program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，这个定义似乎并不特别有用，因为它并没有帮助我们理解对象的意义或用途，也没有说明如何在Ruby程序中使用它们。
- en: '![The RObject structure](httpatomoreillycomsourcenostarchimages1854031.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![RObject结构](httpatomoreillycomsourcenostarchimages1854031.png.jpg)'
- en: Figure 5-1. The `RObject` structure
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1. `RObject`结构
- en: Inspecting klass and ivptr
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查klass和ivptr
- en: To understand how Ruby uses `RObject` in programs, we’ll create a simple Ruby
    class and then inspect an instance of this class using IRB. For example, suppose
    I have the simple Ruby class shown in [Example 5-1](ch05.html#simple_ruby_class
    "Example 5-1. A simple Ruby class").
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Ruby如何在程序中使用`RObject`，我们将创建一个简单的Ruby类，并使用IRB检查该类的实例。例如，假设我有[示例5-1](ch05.html#simple_ruby_class
    "示例5-1. 一个简单的Ruby类")所示的简单Ruby类。
- en: Example 5-1. A simple Ruby class
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5-1. 一个简单的Ruby类
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ruby needs to save the class pointer in `RObject` because every object must
    track the class you used to create it. When you create an instance of a class,
    Ruby internally saves a pointer to that class inside `RObject`, as shown in [Example 5-2](ch05.html#creating_an_object_instance_in_irb
    "Example 5-2. Creating an object instance in IRB").
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby需要在`RObject`中保存类指针，因为每个对象都必须追踪用于创建它的类。当你创建一个类的实例时，Ruby会在内部将该类的指针保存在`RObject`中，如[示例5-2](ch05.html#creating_an_object_instance_in_irb
    "示例5-2. 在IRB中创建一个对象实例")所示。
- en: Example 5-2. Creating an object instance in IRB
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 示例5-2. 在IRB中创建一个对象实例
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By displaying the class name `#<Mathematician` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    Ruby displays the value of the class pointer for the `euler` object. The hex string
    that follows is actually the `VALUE` pointer for the object. (This will differ
    for every instance of `Mathematician`.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)上显示类名`#<Mathematician`，Ruby显示了`euler`对象的类指针值。随后的十六进制字符串实际上是该对象的`VALUE`指针。（这对于每个`Mathematician`实例都会有所不同。）
- en: Ruby also uses the instance variable array to track the values you save in an
    object, as shown in [Example 5-3](ch05.html#inspecting_instance_variables_in_irb
    "Example 5-3. Inspecting instance variables in IRB").
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 还使用实例变量数组来跟踪你保存在对象中的值，正如 [示例 5-3](ch05.html#inspecting_instance_variables_in_irb
    "示例 5-3. 在 IRB 中检查实例变量") 中所示。
- en: Example 5-3. Inspecting instance variables in IRB
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-3. 在 IRB 中检查实例变量
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, in IRB Ruby also displays the instance variable array for `euler`
    at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg). Ruby needs to save
    this array of values in each object because every object instance can have different
    values for the same instance variables, as shown at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    in [Example 5-4](ch05.html#different_instance_of_the_mathematicia "Example 5-4. A
    different instance of the Mathematician class").
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在 IRB 中，Ruby 还显示了 `euler` 的实例变量数组，见 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。Ruby
    需要在每个对象中保存这个值数组，因为每个对象实例可能对相同的实例变量有不同的值，正如 [示例 5-4](ch05.html#different_instance_of_the_mathematicia
    "示例 5-4. `Mathematician` 类的不同实例") 中所示，见 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。
- en: Example 5-4. A different instance of the `Mathematician` class
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-4. `Mathematician` 类的不同实例
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Visualizing Two Instances of One Class
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化同一类的两个实例
- en: Let’s look at Ruby’s C structures in a bit more detail. When you run the Ruby
    code shown in [Figure 5-2](ch05.html#creating_two_instances_of_one_class "Figure 5-2. Creating
    two instances of one class"), Ruby creates one `RClass` structure and two `RObject`
    structures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一下 Ruby 的 C 结构。当你运行 [图 5-2](ch05.html#creating_two_instances_of_one_class
    "图 5-2. 创建同一类的两个实例") 中显示的 Ruby 代码时，Ruby 会创建一个 `RClass` 结构和两个 `RObject` 结构。
- en: '![Creating two instances of one class](httpatomoreillycomsourcenostarchimages1854033.png.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![创建同一类的两个实例](httpatomoreillycomsourcenostarchimages1854033.png.jpg)'
- en: Figure 5-2. Creating two instances of one class
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2. 创建同一类的两个实例
- en: I’ll discuss how Ruby implements classes with the `RClass` structure in the
    next section. For now, let’s look at [Figure 5-3](ch05.html#visualizing_two_instances_of_one-id00016
    "Figure 5-3. Visualizing two instances of one class"), which shows how Ruby saves
    the `Mathematician` information in the two `RObject` structures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一节讨论 Ruby 如何通过 `RClass` 结构实现类。现在，让我们来看一下 [图 5-3](ch05.html#visualizing_two_instances_of_one-id00016
    "图 5-3. 可视化同一类的两个实例")，该图展示了 Ruby 如何将 `Mathematician` 信息保存在两个 `RObject` 结构中。
- en: '![Visualizing two instances of one class](httpatomoreillycomsourcenostarchimages1854035.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![可视化同一类的两个实例](httpatomoreillycomsourcenostarchimages1854035.png.jpg)'
- en: Figure 5-3. Visualizing two instances of one class
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3. 可视化同一类的两个实例
- en: As you can see, each `klass` value points to the `Mathematician RClass` structure,
    and each `RObject` structure has a separate array of instance variables. Both
    arrays contain `VALUE` pointers—the same pointer that Ruby uses to refer to the
    `RObject` structure. (Notice that one of the objects contains two instance variables,
    while the other contains only one.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个 `klass` 值都指向 `Mathematician RClass` 结构，而每个 `RObject` 结构都有一个单独的实例变量数组。这两个数组都包含
    `VALUE` 指针——这是 Ruby 用来引用 `RObject` 结构的相同指针。（注意，其中一个对象包含两个实例变量，而另一个仅包含一个。）
- en: Generic Objects
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用对象
- en: Now you know how Ruby saves custom classes, like the `Mathematician` class,
    in `RObject` structures. But remember that every Ruby value—including basic data
    types such as integers, strings, and symbols—is an object. The Ruby source code
    internally refers to these built-in types as “generic” types. How does Ruby store
    these generic objects? Do they also use the `RObject` structure?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道 Ruby 如何将自定义类（例如 `Mathematician` 类）保存在 `RObject` 结构中。但请记住，每个 Ruby 值——包括整数、字符串和符号等基本数据类型——都是一个对象。Ruby
    源代码内部将这些内建类型称为“通用”类型。那 Ruby 是如何存储这些通用对象的呢？它们是否也使用 `RObject` 结构？
- en: The answer is no. Internally, Ruby uses a different C structure, not `RObject`,
    to save values for each of its generic data types. For example, Ruby saves string
    values in `RString` structures, arrays in `RArray` structures, regular expressions
    in `RRegexp` structures, and so on. Ruby uses `RObject` only to save instances
    of custom object classes that you create and a few custom object classes that
    Ruby creates internally. However, all of these different structures share the
    same `RBasic` information that we saw in `RObject`, as shown in [Figure 5-4](ch05.html#different_ruby_object_structures_all_use
    "Figure 5-4. Different Ruby object structures all use the RBasic structure.").
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。在内部，Ruby 使用不同的 C 结构，而不是 `RObject`，来保存每种通用数据类型的值。例如，Ruby 将字符串值保存在 `RString`
    结构中，将数组保存在 `RArray` 结构中，将正则表达式保存在 `RRegexp` 结构中，等等。Ruby 仅使用 `RObject` 来保存你创建的自定义对象类的实例以及
    Ruby 内部创建的少数自定义对象类的实例。然而，所有这些不同的结构共享相同的 `RBasic` 信息，就像我们在 `RObject` 中看到的那样，如 [图
    5-4](ch05.html#different_ruby_object_structures_all_use "图 5-4. 所有 Ruby 对象结构都使用
    RBasic 结构。") 所示。
- en: Since the `RBasic` structure contains the class pointer, each of these generic
    data types is also an object. Each is an instance of some Ruby class, as indicated
    by the class pointer saved inside `RBasic`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `RBasic` 结构包含类指针，因此每种通用数据类型也是一个对象。每个数据类型都是某个 Ruby 类的实例，正如 `RBasic` 中保存的类指针所指示的那样。
- en: '![Different Ruby object structures all use the RBasic structure.](httpatomoreillycomsourcenostarchimages1854037.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![所有 Ruby 对象结构都使用 RBasic 结构。](httpatomoreillycomsourcenostarchimages1854037.png)'
- en: Figure 5-4. Different Ruby object structures all use the `RBasic` structure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4。所有 Ruby 对象结构都使用 `RBasic` 结构。
- en: Simple Ruby Values Don’t Require a Structure at All
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的 Ruby 值根本不需要结构
- en: As a performance optimization, Ruby saves small integers, symbols, and a few
    other simple values without any structure at all, placing them right inside the
    `VALUE` pointer, as shown in [Figure 5-5](ch05.html#ruby_saves_integers_in_the_value_pointer
    "Figure 5-5. Ruby saves integers in the VALUE pointer.").
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为性能优化，Ruby 不使用任何结构来保存小整数、符号以及其他一些简单的值，而是将它们直接保存在 `VALUE` 指针中，如 [图 5-5](ch05.html#ruby_saves_integers_in_the_value_pointer
    "图 5-5. Ruby 将整数保存在 VALUE 指针中。") 所示。
- en: '![Ruby saves integers in the VALUE pointer.](httpatomoreillycomsourcenostarchimages1854039.png.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 将整数保存在 `VALUE` 指针中。](httpatomoreillycomsourcenostarchimages1854039.png.jpg)'
- en: Figure 5-5. Ruby saves integers in the `VALUE` pointer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-5。Ruby 将整数保存在 `VALUE` 指针中。
- en: These `VALUE`s are not pointers at all; they’re values themselves. For these
    simple data types, there is no class pointer. Instead, Ruby remembers the class
    using a series of bit flags saved in the first few bits of the `VALUE`. For example,
    all small integers have the `FIXNUM_FLAG` bit set, as shown in [Figure 5-6](ch05.html#fixnumunderscoreflag_indicates_this_is_a
    "Figure 5-6. FIXNUM_FLAG indicates this is an instance of the Fixnum class.").
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `VALUE` 根本不是指针；它们是值本身。对于这些简单的数据类型，没有类指针。相反，Ruby 使用一系列位标志来记住类，这些位标志保存在 `VALUE`
    的前几个位中。例如，所有小整数都设置了 `FIXNUM_FLAG` 位，如 [图 5-6](ch05.html#fixnumunderscoreflag_indicates_this_is_a
    "图 5-6. FIXNUM_FLAG 表示这是 `Fixnum` 类的一个实例。") 所示。
- en: '![FIXNUM_FLAG indicates this is an instance of the Fixnum class.](httpatomoreillycomsourcenostarchimages1854041.png.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![FIXNUM_FLAG 表示这是 `Fixnum` 类的一个实例。](httpatomoreillycomsourcenostarchimages1854041.png.jpg)'
- en: Figure 5-6. `FIXNUM_FLAG` indicates this is an instance of the `Fixnum` class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-6。`FIXNUM_FLAG` 表示这是 `Fixnum` 类的一个实例。
- en: Whenever the `FIXNUM_FLAG` is set, Ruby knows that this `VALUE` is really a
    small integer, an instance of the `Fixnum` class, and not a pointer to a value
    structure. (A similar bit flag indicates whether the `VALUE` is a symbol, and
    values such as `nil`, `true`, and `false` also have their own flags.)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每当设置 `FIXNUM_FLAG` 时，Ruby 就知道这个 `VALUE` 实际上是一个小整数，是 `Fixnum` 类的实例，而不是指向值结构的指针。（类似的位标志指示该
    `VALUE` 是否是符号，并且像 `nil`、`true` 和 `false` 这样的值也有各自的标志。）
- en: It’s easy to see that integers, strings, and other generic values are all objects
    by using IRB, as you can see in [Example 5-5](ch05.html#inspecting_classes_for_some_generic_valu
    "Example 5-5. Inspecting classes for some generic values").
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 IRB，很容易看出整数、字符串和其他通用值都是对象，正如 [示例 5-5](ch05.html#inspecting_classes_for_some_generic_valu
    "示例 5-5. 检查一些通用值的类") 中所看到的那样。
- en: Example 5-5. Inspecting classes for some generic values
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-5. 检查一些通用值的类
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we see that Ruby saves a class pointer or the equivalent bit flag for
    all values by calling the `class` method on each. In turn, the `class` method
    returns the class pointer, or at least the name of the class that each `klass`
    pointer refers to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 Ruby 通过调用每个对象的 `class` 方法，保存类指针或等效的位标志。反过来，`class` 方法返回类指针，或者至少返回每个
    `klass` 指针所指向的类名。
- en: Do Generic Objects Have Instance Variables?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用对象有实例变量吗？
- en: 'Let’s go back to our definition of a Ruby object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 Ruby 对象的定义：
- en: Every Ruby object is the combination of a class pointer and an array of instance
    variables.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个 Ruby 对象是类指针和实例变量数组的结合。
- en: What about instance variables for generic objects? Do integers, strings, and
    other generic data values have instance variables? That would seem odd, but if
    integers and strings are objects, this must be true! And if it is true, where
    does Ruby save these values if it doesn’t use the `RObject` structure?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，通用对象的实例变量呢？整数、字符串和其他通用数据值是否有实例变量？这看起来很奇怪，但如果整数和字符串是对象，那么这一定是真的！如果这是真的，Ruby
    将这些值保存在什么地方呢，如果它不使用 `RObject` 结构的话？
- en: Using the `instance_variables` method, shown in [Example 5-6](ch05.html#saving_instance_variables_in_a_ruby_stri
    "Example 5-6. Saving instance variables in a Ruby string object"), you can see
    that each of these basic values can also contain an array of instance variables,
    strange as that may seem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `instance_variables` 方法，如 [示例 5-6](ch05.html#saving_instance_variables_in_a_ruby_stri
    "示例 5-6. 在 Ruby 字符串对象中保存实例变量") 中所示，你可以看到每个这些基本值也可以包含一个实例变量数组，尽管这看起来很奇怪。
- en: Example 5-6. Saving instance variables in a Ruby string object
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-6. 在 Ruby 字符串对象中保存实例变量
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Repeat this exercise using symbols, arrays, or any Ruby value, and you’ll find
    that every Ruby value is an object and every object contains a class pointer and
    an array of instance variables.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重复此练习，使用符号、数组或任何 Ruby 值，你会发现每个 Ruby 值都是一个对象，并且每个对象都包含一个类指针和一个实例变量数组。
- en: Reading the RBasic and RObject C Structure Definitions
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读 RBasic 和 RObject C 结构定义
- en: '[Example 5-7](ch05.html#definitions_of_the_rbasic_and_robjec "Example 5-7. The
    definitions of the RBasic and RObject C structures") shows the definitions of
    the `RBasic` and `RObject` C structures. (You can find this code in the *include/ruby/ruby.h*
    header file.)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-7](ch05.html#definitions_of_the_rbasic_and_robjec "示例 5-7. `RBasic` 和
    `RObject` C 结构的定义") 显示了 `RBasic` 和 `RObject` C 结构的定义。（你可以在 *include/ruby/ruby.h*
    头文件中找到这段代码。）'
- en: Example 5-7. The definitions of the `RBasic` and `RObject` C structures
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-7. `RBasic` 和 `RObject` C 结构的定义
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the top, you see the definition of `RBasic`. This definition contains the
    two values: `flags` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `klass` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Below,
    you see the `RObject` definition. Notice that it contains a copy of the `RBasic`
    structure at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg). Following
    this, the `union` keyword contains a structure called `heap` at ![](httpatomoreillycomsourcenostarchimages1854047.png.jpg),
    followed by an array called `ary` at ![](httpatomoreillycomsourcenostarchimages1854049.png.jpg).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，你看到 `RBasic` 的定义。这个定义包含两个值：`flags` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    和 `klass` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。下面，你看到 `RObject`
    的定义。注意，它包含了一个 `RBasic` 结构的副本，位于 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)。接下来，`union`
    关键字包含一个名为 `heap` 的结构，位于 ![](httpatomoreillycomsourcenostarchimages1854047.png.jpg)，后面跟着一个名为
    `ary` 的数组，位于 ![](httpatomoreillycomsourcenostarchimages1854049.png.jpg)。
- en: 'The `heap` structure at ![](httpatomoreillycomsourcenostarchimages1854047.png.jpg)
    contains the following values:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`heap` 结构位于 ![](httpatomoreillycomsourcenostarchimages1854047.png.jpg)，包含以下值：'
- en: First, the value `numiv` at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    tracks the number of instance variables contained in this object.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，值 `numiv` 位于 ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)，它跟踪此对象中包含的实例变量的数量。
- en: Next, `ivptr` at ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)
    is a pointer to an array containing the values of this object’s instance variables.
    Notice that the names, or IDs, of the instance variables are not stored here;
    only the values are stored.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，`ivptr` 位于 ![](httpatomoreillycomsourcenostarchimages1854043.png.jpg)，是指向包含此对象实例变量值的数组的指针。注意，这里并没有存储实例变量的名称或
    ID；这里只存储了值。
- en: '`iv_index_tbl` at ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)
    points to a hash table that maps between the name, or ID, of each instance variable
    and its location in the `ivptr` array. This value is actually stored in the `RClass`
    structure for this object’s class; this pointer is simply a cache, or shortcut,
    that Ruby uses to obtain that hash table quickly. (The `st_table` type refers
    to Ruby’s implementation of hash tables, which I’ll discuss in [Chapter 7](ch07.html
    "Chapter 7. The Hash Table: The Workhorse of Ruby Internals").)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iv_index_tbl` 在 ![](httpatomoreillycomsourcenostarchimages1854045.png.jpg)
    处指向一个哈希表，该哈希表将每个实例变量的名称或 ID 与其在 `ivptr` 数组中的位置进行映射。这个值实际上存储在该对象的类的 `RClass` 结构中；这个指针只是一个缓存或快捷方式，Ruby
    用它来快速获取那个哈希表。（`st_table` 类型是指 Ruby 对哈希表的实现，我将在[第 7 章](ch07.html "第 7 章. 哈希表：Ruby
    内部的主力")中讨论。）'
- en: The last member of the `RObject` structure, `ary` at ![](httpatomoreillycomsourcenostarchimages1854049.png.jpg),
    occupies the same memory space as all previous values because of the `union` keyword
    at the top. Using this `ary` value, Ruby can save all of the instance variables
    right inside the `RObject` structure—if they’ll fit. This eliminates the need
    to call `malloc` to allocate extra memory to hold the instance variable value
    array. (Ruby also uses this sort of optimization for the `RString`, `RArray`,
    `RStruct`, and `RBignum` structures.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`RObject` 结构的最后一个成员，位于 ![](httpatomoreillycomsourcenostarchimages1854049.png.jpg)
    处的 `ary`，由于顶部的 `union` 关键字，与所有先前的值共享相同的内存空间。通过这个 `ary` 值，Ruby 可以将所有实例变量直接保存在 `RObject`
    结构中——如果它们足够容纳的话。这避免了调用 `malloc` 来分配额外的内存以存储实例变量值数组。（Ruby 还在 `RString`、`RArray`、`RStruct`
    和 `RBignum` 结构中使用了类似的优化。）'
- en: Where Does Ruby Save Instance Variables for Generic Objects?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ruby 为通用对象保存实例变量的位置在哪里？
- en: Internally, Ruby uses a bit of a hack to save instance variables for generic
    objects—that is, for objects that don’t use an `RObject` structure. When you save
    an instance variable in a generic object, Ruby saves it in a special hash called
    `generic_iv_tbl`. This hash maintains a map between generic objects and pointers
    to other hashes that contain each object’s instance variables. [Figure 5-7](ch05.html#genericunderscoreivunderscoretbl_stores
    "Figure 5-7. generic_iv_tbl stores instance variables for generic objects.") shows
    how this would look for the `str` string example in [Example 5-6](ch05.html#saving_instance_variables_in_a_ruby_stri
    "Example 5-6. Saving instance variables in a Ruby string object").
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 内部来说，Ruby 使用一种技巧来保存通用对象的实例变量——也就是对于不使用 `RObject` 结构的对象。当你在通用对象中保存实例变量时，Ruby
    会将其保存在一个特殊的哈希表中，称为 `generic_iv_tbl`。这个哈希表维护了通用对象与指向包含各自实例变量的其他哈希表的指针之间的映射。[图 5-7](ch05.html#genericunderscoreivunderscoretbl_stores
    "图 5-7. generic_iv_tbl 存储通用对象的实例变量。") 展示了在[示例 5-6](ch05.html#saving_instance_variables_in_a_ruby_stri
    "示例 5-6. 在 Ruby 字符串对象中保存实例变量")中如何应用于 `str` 字符串的例子。
- en: '![generic_iv_tbl stores instance variables for generic objects.](httpatomoreillycomsourcenostarchimages1854051.png.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![generic_iv_tbl 存储通用对象的实例变量。](httpatomoreillycomsourcenostarchimages1854051.png.jpg)'
- en: Figure 5-7. `generic_iv_tbl` stores instance variables for generic objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7. `generic_iv_tbl` 存储通用对象的实例变量。
- en: 'Experiment 5-1: How Long Does It Take to Save a New Instance Variable?'
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 5-1：保存一个新实例变量需要多长时间？
- en: To learn more about how Ruby saves instance variables internally, let’s measure
    how long it takes Ruby to save one in an object. To do this, I’ll create a large
    number of test objects, as shown in [Example 5-8](ch05.html#creating_test_objects_using_classdotnew
    "Example 5-8. Creating test objects using Class.new").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 Ruby 如何在内部保存实例变量，让我们测量一下 Ruby 在一个对象中保存实例变量需要多长时间。为此，我将创建大量测试对象，如[示例 5-8](ch05.html#creating_test_objects_using_classdotnew
    "示例 5-8. 使用 Class.new 创建测试对象")所示。
- en: Example 5-8. Creating test objects using `Class.new`
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-8. 使用 `Class.new` 创建测试对象
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, I’m using `Class.new` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    to create a unique class for each new object in order to make sure they’re all
    independent. I’ve also disabled garbage collection at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    to avoid skewing the results with GC operations. Then, in [Example 5-9](ch05.html#adding_instance_variables_to_each_test_o
    "Example 5-9. Adding instance variables to each test object"), I add instance
    variables to each.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用 `Class.new` 在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    处为每个新对象创建一个独特的类，以确保它们都是独立的。我还在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    处禁用了垃圾回收，以避免垃圾回收操作影响结果。然后，在 [示例 5-9](ch05.html#adding_instance_variables_to_each_test_o
    "示例 5-9. 向每个测试对象添加实例变量") 中，我为每个对象添加实例变量。
- en: Example 5-9. Adding instance variables to each test object
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-9. 向每个测试对象添加实例变量
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Example 5-9](ch05.html#adding_instance_variables_to_each_test_o "Example 5-9. Adding
    instance variables to each test object") iterates 20 times, repeatedly saving
    one more new instance variable to each of the objects. [Figure 5-8](ch05.html#time_to_add_one_more_instance_variable_l
    "Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs.
    instance variable count") shows the time that it takes Ruby 2.0 to add each variable:
    The first bar on the left is the time it takes to save the first instance variable
    in all the objects, and each subsequent bar is the additional time taken to save
    one more instance variable in each object.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-9](ch05.html#adding_instance_variables_to_each_test_o "示例 5-9. 向每个测试对象添加实例变量")
    迭代了 20 次，每次将一个新的实例变量保存到每个对象中。[图 5-8](ch05.html#time_to_add_one_more_instance_variable_l
    "图 5-8. 添加一个新的实例变量所需时间（以秒为单位 x 100,000）与实例变量数量的关系") 显示了 Ruby 2.0 添加每个变量所需的时间：左侧的第一条柱状图是保存所有对象中第一个实例变量所需的时间，每个后续的柱状图则表示在每个对象中保存一个额外实例变量所需的时间。'
- en: '![Time to add one more instance variable (in seconds x 100,000) vs. instance
    variable count](httpatomoreillycomsourcenostarchimages1854053.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![添加一个新的实例变量所需时间（以秒为单位 x 100,000）与实例变量数量的关系](httpatomoreillycomsourcenostarchimages1854053.png)'
- en: Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs.
    instance variable count
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-8. 添加一个新的实例变量所需时间（以秒为单位 x 100,000）与实例变量数量的关系
- en: '[Figure 5-8](ch05.html#time_to_add_one_more_instance_variable_l "Figure 5-8. Time
    to add one more instance variable (in seconds x 100,000) vs. instance variable
    count") shows a strange pattern. Sometimes it takes Ruby longer to add a new instance
    variable. What’s going on here?'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-8](ch05.html#time_to_add_one_more_instance_variable_l "图 5-8. 添加一个新的实例变量所需时间（以秒为单位
    x 100,000）与实例变量数量的关系") 展示了一个奇怪的模式。有时 Ruby 添加一个新的实例变量所需的时间更长。这是怎么回事呢？'
- en: The reason for this behavior has to do with the `ivptr` array where Ruby stores
    the instance variables, as shown in [Figure 5-9](ch05.html#two_instance_variables_saved_in_an_objec
    "Figure 5-9. Two instance variables saved in an object").
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的原因与 Ruby 存储实例变量的 `ivptr` 数组有关，如 [图 5-9](ch05.html#two_instance_variables_saved_in_an_objec
    "图 5-9. 一个对象中保存的两个实例变量") 所示。
- en: '![Two instance variables saved in an object](httpatomoreillycomsourcenostarchimages1854055.png.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![一个对象中保存的两个实例变量](httpatomoreillycomsourcenostarchimages1854055.png.jpg)'
- en: Figure 5-9. Two instance variables saved in an object
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-9. 一个对象中保存的两个实例变量
- en: In Ruby 1.8 this array is a hash table containing both the variable names (the
    hash keys) and the values, which will automatically expand to accommodate any
    number of elements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 1.8 中，这个数组是一个哈希表，包含了变量名（哈希键）和对应的值，该哈希表会自动扩展以容纳任意数量的元素。
- en: Ruby 1.9 and 2.0 speed things up a bit by saving the values in a simple array.
    The instance variable names are saved in the object’s class instead, because they’re
    the same for all instances of a class. As a result, Ruby 1.9 and 2.0 need to either
    preallocate a large array to handle any number of instance variables or repeatedly
    increase the size of this array as you save more variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 1.9 和 2.0 通过将值保存在一个简单的数组中稍微加快了速度。实例变量名则保存在对象的类中，因为它们对类的所有实例来说都是相同的。因此，Ruby
    1.9 和 2.0 需要预先分配一个大数组来处理任意数量的实例变量，或者在保存更多变量时反复增大该数组的大小。
- en: In fact, as you can see in [Figure 5-8](ch05.html#time_to_add_one_more_instance_variable_l
    "Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs.
    instance variable count"), Ruby 1.9 and 2.0 repeatedly increase the array size.
    For example, suppose you have seven instance variables in a given object, as shown
    in [Figure 5-10](ch05.html#seven_instance_variables_in_an_object "Figure 5-10. Seven
    instance variables in an object").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，正如你在[图 5-8](ch05.html#time_to_add_one_more_instance_variable_l "图 5-8. 添加一个实例变量的时间（单位：秒
    x 100,000）与实例变量个数的关系")中看到的，Ruby 1.9 和 2.0 会反复增加数组的大小。例如，假设你在一个给定的对象中有七个实例变量，如[图 5-10](ch05.html#seven_instance_variables_in_an_object
    "图 5-10. 一个对象中的七个实例变量")所示。
- en: '![Seven instance variables in an object](httpatomoreillycomsourcenostarchimages1854057.png.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![一个对象中的七个实例变量](httpatomoreillycomsourcenostarchimages1854057.png.jpg)'
- en: Figure 5-10. Seven instance variables in an object
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-10. 一个对象中的七个实例变量
- en: When you add the eighth variable—bar 8 in [Figure 5-8](ch05.html#time_to_add_one_more_instance_variable_l
    "Figure 5-8. Time to add one more instance variable (in seconds x 100,000) vs.
    instance variable count")—Ruby 1.9 and 2.0 increase the array size by three, anticipating
    that you will soon add more variables, as shown in [Figure 5-11](ch05.html#adding_an_eighth_value_allocates_extra_s
    "Figure 5-11. Adding an eighth value allocates extra space.").
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加第八个变量时——在[图 5-8](ch05.html#time_to_add_one_more_instance_variable_l "图 5-8.
    添加一个实例变量的时间（单位：秒 x 100,000）与实例变量个数的关系")中的第8条——Ruby 1.9 和 2.0 会将数组大小增加三，以预期你很快会添加更多变量，如[图 5-11](ch05.html#adding_an_eighth_value_allocates_extra_s
    "图 5-11. 添加第八个值分配了额外的空间。")所示。
- en: '![Adding an eighth value allocates extra space.](httpatomoreillycomsourcenostarchimages1854059.png.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![添加第八个值分配了额外的空间。](httpatomoreillycomsourcenostarchimages1854059.png.jpg)'
- en: Figure 5-11. Adding an eighth value allocates extra space.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-11. 添加第八个值分配了额外的空间。
- en: Allocating more memory takes extra time, which is why bar 8 is higher. Now if
    you add two more instance variables, Ruby 1.9 and 2.0 won’t need to reallocate
    memory for this array because the space will already be available. This explains
    the shorter times for bars 9 and 10.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 分配更多的内存需要额外的时间，这就是为什么第8条比其他条更高的原因。现在，如果你再添加两个实例变量，Ruby 1.9 和 2.0 就不需要重新分配该数组的内存了，因为空间已经预留好了。这也解释了第9条和第10条时间更短的原因。
- en: What’s Inside the RClass Structure?
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RClass 结构体中有什么？
- en: Every object remembers its class by saving a pointer to an `RClass` structure.
    What information does each `RClass` structure contain? What would we see if we
    could look inside a Ruby class? Let’s build a model of the information that must
    be present in `RClass`. This model will give us a technical definition of what
    a Ruby class is, based on what we know classes can do.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象通过保存指向 `RClass` 结构的指针来记住自己的类。每个 `RClass` 结构包含什么信息？如果我们能看到 Ruby 类的内部结构，会看到什么呢？让我们构建一个关于
    `RClass` 中必须存在的信息模型。这个模型将为我们提供 Ruby 类的技术定义，基于我们所知道的类的功能。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1854061.png.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1854061.png.jpg)'
- en: '*Two objects, one class*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*两个对象，一个类*'
- en: 'Every Ruby developer knows how to write a class: You type the `class` keyword,
    specify a name for the new class, and then type in the class’s methods. [Example 5-10](ch05.html#same_simple_ruby_class_we_saw_in_lis
    "Example 5-10. The same simple Ruby class we saw in Example 5-1") shows a familiar
    example.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Ruby 开发者都知道如何编写一个类：你输入`class`关键字，指定新类的名称，然后编写类的方法。[示例 5-10](ch05.html#same_simple_ruby_class_we_saw_in_lis
    "示例 5-10. 我们在示例 5-1 中看到的相同的简单 Ruby 类")展示了一个常见的示例。
- en: Example 5-10. The same simple Ruby class we saw in [Example 5-1](ch05.html#simple_ruby_class
    "Example 5-1. A simple Ruby class")
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-10. 我们在[示例 5-1](ch05.html#simple_ruby_class "示例 5-1. 一个简单的 Ruby 类")中看到的相同的简单
    Ruby 类
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`attr_accessor` is shorthand for defining get and set methods for an attribute.
    (The methods defined by `attr_accessor` also check for `nil` values). [Example 5-11](ch05.html#same_class_written_without_attrunder
    "Example 5-11. The same class written without attr_accessor") shows a more verbose
    way of defining the same `Mathematician` class.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr_accessor`是定义属性的 getter 和 setter 方法的简写。（`attr_accessor`定义的方法还会检查`nil`值）。[示例 5-11](ch05.html#same_class_written_without_attrunder
    "示例 5-11. 没有使用attr_accessor编写的相同类")展示了定义相同 `Mathematician` 类的更冗长的方式。'
- en: Example 5-11. The same class written without `attr_accessor`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-11. 没有使用`attr_accessor`编写的相同类
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It appears that this class—and every Ruby class—is just a group of method definitions.
    You can assign behavior to an object by adding methods to its class, and when
    you call a method on an object, Ruby looks for the method in the object’s class.
    This leads to our first definition of a Ruby class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这个类——以及每个 Ruby 类——只是方法定义的集合。你可以通过向类中添加方法来为对象分配行为，当你在对象上调用方法时，Ruby 会在对象的类中查找该方法。这导致了我们对
    Ruby 类的第一个定义：
- en: A Ruby class is a group of method definitions.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ruby 类是方法定义的集合。
- en: Therefore, the `RClass` structure for `Mathematician` must save a list of all
    the methods defined in the class, as shown in [Figure 5-12](ch05.html#ruby_classes_contain_a_method_tabledot
    "Figure 5-12. Ruby classes contain a method table.").
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Mathematician` 的 `RClass` 结构体必须保存类中定义的所有方法的列表，见 [图 5-12](ch05.html#ruby_classes_contain_a_method_tabledot
    "图 5-12. Ruby 类包含方法表。")。
- en: 'Notice in [Example 5-11](ch05.html#same_class_written_without_attrunder "Example 5-11. The
    same class written without attr_accessor") that I’ve also created two instance
    variables: `@first_name` and `@last_name`. We saw earlier how Ruby stores these
    values in each `RObject` structure, but you may have noticed that only the *values*
    of these variables are stored in `RObject`, not their names. (Ruby 1.8 does store
    the names in `RObject`.) Ruby must store the attribute names in `RClass`, which
    makes sense because the names will be the same for every `Mathematician` instance.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 [示例 5-11](ch05.html#same_class_written_without_attrunder "示例 5-11. 没有使用
    attr_accessor 编写的相同类") 中，我还创建了两个实例变量：`@first_name` 和 `@last_name`。我们之前看到 Ruby
    如何在每个 `RObject` 结构中存储这些值，但你可能已经注意到，`RObject` 中存储的仅仅是这些变量的*值*，而不是它们的名字。（Ruby 1.8
    会在 `RObject` 中存储名字。）Ruby 必须将属性名称存储在 `RClass` 中，这也是有道理的，因为这些名称对于每个 `Mathematician`
    实例来说都是相同的。
- en: '![Ruby classes contain a method table.](httpatomoreillycomsourcenostarchimages1854063.png.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 类包含方法表。](httpatomoreillycomsourcenostarchimages1854063.png.jpg)'
- en: Figure 5-12. Ruby classes contain a method table.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-12. Ruby 类包含方法表。
- en: Let’s redraw `RClass` again and include a table of attribute names this time,
    as shown in [Figure 5-13](ch05.html#ruby_classes_also_contain_a_table_of_att "Figure 5-13. Ruby
    classes also contain a table of attribute names.").
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新绘制 `RClass`，这次加入属性名称表，见 [图 5-13](ch05.html#ruby_classes_also_contain_a_table_of_att
    "图 5-13. Ruby 类还包含属性名称表。")。
- en: '![Ruby classes also contain a table of attribute names.](httpatomoreillycomsourcenostarchimages1854065.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 类还包含属性名称表。](httpatomoreillycomsourcenostarchimages1854065.png)'
- en: Figure 5-13. Ruby classes also contain a table of attribute names.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-13. Ruby 类还包含属性名称表。
- en: 'Now our definition of a Ruby class is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Ruby 类的定义如下：
- en: A Ruby class is a group of method definitions and a table of attribute names.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ruby 类是方法定义的集合和属性名称的表。
- en: At the beginning of this chapter, I mentioned that every value in Ruby is an
    object. This might be true for classes, too. Let’s prove this using IRB.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我提到过 Ruby 中的每个值都是对象。这对类也许同样适用。让我们通过 IRB 来证明这一点。
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, Ruby classes are all instances of the `Class` class; therefore,
    classes are also objects. Now to update our definition of a Ruby class again:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Ruby 类都是 `Class` 类的实例；因此，类也是对象。现在我们再次更新我们对 Ruby 类的定义：
- en: A Ruby class is a Ruby object that also contains method definitions and attribute
    names.
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ruby 类是一个 Ruby 对象，它还包含方法定义和属性名称。
- en: Because Ruby classes are objects, we know that the `RClass` structure must also
    contain a class pointer and an instance variable array, the values that we know
    every Ruby object contains, as shown in [Figure 5-14](ch05.html#ruby_classes_also_contain_a_class_pointe
    "Figure 5-14. Ruby classes also contain a class pointer and instance variables.").
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Ruby 类是对象，我们知道 `RClass` 结构体必须包含一个类指针和一个实例变量数组，这些值是我们知道每个 Ruby 对象都包含的，见 [图
    5-14](ch05.html#ruby_classes_also_contain_a_class_pointe "图 5-14. Ruby 类还包含类指针和实例变量。")。
- en: '![Ruby classes also contain a class pointer and instance variables.](httpatomoreillycomsourcenostarchimages1854067.png.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 类还包含类指针和实例变量。](httpatomoreillycomsourcenostarchimages1854067.png.jpg)'
- en: Figure 5-14. Ruby classes also contain a class pointer and instance variables.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-14. Ruby 类还包含类指针和实例变量。
- en: 'As you can see, I’ve added a pointer to the `Class` class, which is in theory
    the class of every Ruby class object. However, in [Experiment 5-2: Where Does
    Ruby Save Class Methods?](ch05.html#experiment_5-2_where_does_ruby_save_clas "Experiment
    5-2: Where Does Ruby Save Class Methods?"), I’ll show that this diagram is in
    fact not accurate—that `klass` actually points to something else! I’ve also added
    a table of instance variables.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我已经添加了指向 `Class` 类的指针，理论上这是每个 Ruby 类对象的类。然而，在[实验 5-2：Ruby 如何保存类方法？](ch05.html#experiment_5-2_where_does_ruby_save_clas
    "实验 5-2：Ruby 如何保存类方法？")中，我将展示这个图表实际上并不准确——`klass` 实际上指向的是别的东西！我还添加了实例变量的表格。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*These are the class-level instance variables. Don’t confuse these with the
    table of attribute names for the object-level instance variables.*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*这些是类级别的实例变量。不要将它们与对象级别实例变量的属性名称表混淆。*'
- en: This is rapidly getting out of control! The `RClass` structure seems to be much
    more complex than the `RObject` structure. But don’t worry—we’re getting close
    to an accurate picture of the `RClass` structure. Next we need to consider two
    more important types of information contained in each Ruby class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这越来越难以控制了！`RClass` 结构似乎比 `RObject` 结构复杂得多。但别担心——我们正在接近准确的 `RClass` 结构。接下来，我们需要考虑
    Ruby 类中包含的另外两种重要信息。
- en: Inheritance
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'Inheritance is an essential feature of object-oriented programming. Ruby implements
    single inheritance by allowing us to optionally specify one superclass when we
    create a class. If we don’t specify a superclass, Ruby assigns the `Object` class
    as the superclass. For example, we could rewrite the `Mathematician` class using
    a superclass like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的一个基本特性。Ruby 通过允许我们在创建类时可选地指定一个父类来实现单继承。如果我们没有指定父类，Ruby 会将 `Object`
    类作为父类。例如，我们可以像这样使用一个父类重写 `Mathematician` 类：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now every instance of `Mathematician` will include the same methods that instances
    of `Person` have. In this example, we might want to move the `first_name` and
    `last_name` accessor methods into `Person`. We could also move the `@first_name`
    and `@last_name` attributes into the `Person` class. Every instance of `Mathematician`
    will contain these methods and attributes, even though we moved them to the `Person`
    class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个 `Mathematician` 的实例都将包含 `Person` 实例拥有的相同方法。在这个例子中，我们可能想把 `first_name` 和
    `last_name` 访问器方法移到 `Person` 中。我们也可以把 `@first_name` 和 `@last_name` 属性移到 `Person`
    类中。每个 `Mathematician` 的实例将包含这些方法和属性，即使我们已经把它们移到了 `Person` 类。
- en: The `Mathematician` class must contain a reference to the `Person` class (its
    superclass) so that Ruby can find any methods or attributes defined in the superclass.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mathematician` 类必须包含对 `Person` 类（它的父类）的引用，以便 Ruby 能够找到父类中定义的任何方法或属性。'
- en: 'Let’s update our definition again, assuming that Ruby tracks the superclass
    using another pointer similar to `klass`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次更新定义，假设 Ruby 使用类似 `klass` 的另一个指针来跟踪父类：
- en: A Ruby class is a Ruby object that also contains method definitions, attribute
    names, and a superclass pointer.
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ruby 类是一个 Ruby 对象，它还包含方法定义、属性名称和一个指向父类的指针。
- en: And let’s redraw the `RClass` structure to include the new superclass pointer,
    as shown in [Figure 5-15](ch05.html#ruby_classes_also_contain_a_superclass_p "Figure 5-15. Ruby
    classes also contain a superclass pointer.").
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重新绘制 `RClass` 结构，以包括新的父类指针，如[图 5-15](ch05.html#ruby_classes_also_contain_a_superclass_p
    "图 5-15. Ruby 类还包含一个父类指针")所示。
- en: '![Ruby classes also contain a superclass pointer.](httpatomoreillycomsourcenostarchimages1854069.png.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 类还包含一个父类指针。](httpatomoreillycomsourcenostarchimages1854069.png.jpg)'
- en: Figure 5-15. Ruby classes also contain a superclass pointer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-15. Ruby 类还包含一个父类指针。
- en: 'At this point, it is critical to understand the difference between the `klass`
    pointer and the `super` pointer. The `klass` pointer indicates which class the
    Ruby class object is an instance of. This will always be the `Class` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，理解 `klass` 指针和 `super` 指针之间的区别至关重要。`klass` 指针表示 Ruby 类对象是哪个类的实例。这个指针总是指向
    `Class` 类：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Ruby uses the `klass` pointer to find the methods of the `Mathematician` class
    object, such as the `new` method that every Ruby class implements. However, the
    `super` pointer records the class’s superclass:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用 `klass` 指针来查找 `Mathematician` 类对象的方法，例如每个 Ruby 类都实现的 `new` 方法。然而，`super`
    指针记录的是类的父类：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ruby uses the `super` pointer to help find methods contained in each `Mathematician`
    instance, such as `first_name=` or `last_name`. As we’ll see next, Ruby also uses
    the `super` pointer when getting or setting class variables.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用`super`指针帮助查找每个`Mathematician`实例中包含的方法，比如`first_name=` 或 `last_name`。正如我们接下来将看到的，Ruby在获取或设置类变量时也会使用`super`指针。
- en: Class Instance Variables vs. Class Variables
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类实例变量与类变量
- en: One confusing bit of Ruby syntax is the concept of *class variables*. You might
    think that these are simply the instance variables of a class (the class-level
    instance variables from [Figure 5-14](ch05.html#ruby_classes_also_contain_a_class_pointe
    "Figure 5-14. Ruby classes also contain a class pointer and instance variables.")),
    but class instance variables and class variables are distinctly different.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby语法中一个让人困惑的概念是*类变量*。你可能会认为这些只是类的实例变量（来自[图 5-14](ch05.html#ruby_classes_also_contain_a_class_pointe
    "图 5-14. Ruby类还包含一个类指针和实例变量")的类级别实例变量），但类实例变量和类变量是明显不同的。
- en: To create a class instance variable, you simply create an instance variable
    using the `@` symbol, but in the context of a class rather than an object. For
    example, [Example 5-12](ch05.html#creating_a_class-level_instance_variable "Example 5-12. Creating
    a class-level instance variable") shows how we could use an instance variable
    of `Mathematician` to indicate a branch of mathematics this class corresponds
    to. We create the `@type` instance variable at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个类实例变量，你只需使用`@`符号创建一个实例变量，但它是在类的上下文中，而非对象中。例如，[示例 5-12](ch05.html#creating_a_class-level_instance_variable
    "示例 5-12. 创建类级别实例变量")展示了我们如何使用`Mathematician`的实例变量来表示该类对应的数学分支。我们在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    创建了`@type`实例变量。
- en: Example 5-12. Creating a class-level instance variable
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-12. 创建类级别实例变量
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In contrast, to create a class variable, you would use the `@@` notation. [Example 5-13](ch05.html#creating_a_class_variable
    "Example 5-13. Creating a class variable") shows the same example, with the class
    variable `@@type` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) created.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，要创建一个类变量，你需要使用`@@`符号。[示例 5-13](ch05.html#creating_a_class_variable "示例 5-13.
    创建类变量")展示了相同的示例，其中创建了类变量`@@type` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。
- en: Example 5-13. Creating a class variable
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-13. 创建类变量
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What’s the difference? When you create a class variable, Ruby creates a single
    value for you to use in that class and in any subclasses you might define. On
    the other hand, using a class *instance* variable causes Ruby to create a separate
    value for each class or subclass.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么不同吗？当你创建一个类变量时，Ruby 会为你创建一个单一的值，供该类及其任何子类使用。另一方面，使用类*实例*变量会导致 Ruby 为每个类或子类创建一个单独的值。
- en: Let’s review [Example 5-14](ch05.html#each_class_and_subclass_has_its_own_inst
    "Example 5-14. Each class and subclass has its own instance variables.") to see
    how Ruby handles these two types of variables differently. First, I define a class
    instance variable called `@type` in the `Mathematician` class and set its value
    to the string `General`. Next, I create a second class called `Statistician`,
    which is a subclass of `Mathematician`, and change the value of `@type` to the
    string `Statistics`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[示例 5-14](ch05.html#each_class_and_subclass_has_its_own_inst "示例 5-14.
    每个类和子类都有自己的实例变量。")，看看 Ruby 如何不同地处理这两种类型的变量。首先，我在`Mathematician`类中定义了一个类实例变量`@type`，并将其值设置为字符串`General`。接着，我创建了一个名为`Statistician`的类，它是`Mathematician`的子类，并将`@type`的值改为字符串`Statistics`。
- en: Example 5-14. Each class and subclass has its own instance variables.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-14. 每个类和子类都有自己的实例变量。
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the values of `@type` in `Statistician` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and `Mathematician` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    are different. Each class has its own separate copy of `@type`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Statistician`中的`@type`值（在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)）与`Mathematician`中的`@type`值（在
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)）不同。每个类都有自己独立的`@type`副本。
- en: However, if I use a class variable instead, Ruby shares that value between `Mathematician`
    and `Statistician`, as demonstrated in [Example 5-15](ch05.html#ruby_shares_class_variables_among_a_clas
    "Example 5-15. Ruby shares class variables among a class and all of its subclasses.").
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我改为使用类变量，Ruby 会在`Mathematician`和`Statistician`之间共享该值，正如在[示例 5-15](ch05.html#ruby_shares_class_variables_among_a_clas
    "示例 5-15. Ruby在类及其所有子类之间共享类变量")中演示的那样。
- en: Example 5-15. Ruby shares class variables among a class and all of its subclasses.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-15. Ruby 在类和所有子类之间共享类变量。
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, Ruby shows the same value for `@@type` in `Statistician` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    and in `Mathematician` at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Ruby 显示了 `Statistician` 中的 `@@type` 与在 `Mathematician` 中的相同值，分别位于 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    和 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。
- en: Internally, however, Ruby actually saves both class variables and class instance
    variables in the same table inside the `RClass` structure. [Figure 5-16](ch05.html#ruby_saves_class_variables_and_class_ins
    "Figure 5-16. Ruby saves class variables and class instance variables in the same
    table.") shows how the `Mathematician` class would save the `@type` and `@@type`
    values if you created both of them. The extra `@` symbol in the name allows Ruby
    to distinguish between the two types of variables.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，内部实现上，Ruby 实际上将类变量和类实例变量保存在 `RClass` 结构中的同一表中。[图 5-16](ch05.html#ruby_saves_class_variables_and_class_ins
    "图 5-16. Ruby 将类变量和类实例变量保存在同一个表中。") 显示了如果你创建了 `Mathematician` 类的 `@type` 和 `@@type`
    值，它们是如何被保存的。额外的 `@` 符号允许 Ruby 区分这两种变量类型。
- en: '![Ruby saves class variables and class instance variables in the same table.](httpatomoreillycomsourcenostarchimages1854071.png.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 将类变量和类实例变量保存在同一个表中。](httpatomoreillycomsourcenostarchimages1854071.png.jpg)'
- en: Figure 5-16. Ruby saves class variables and class instance variables in the
    same table.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-16. Ruby 将类变量和类实例变量保存在同一个表中。
- en: Getting and Setting Class Variables
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和设置类变量
- en: 'It’s true: Ruby saves both class variables and class instance variables in
    the same table. However, the ways Ruby gets or sets these two types of variables
    are quite different.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真的：Ruby 将类变量和类实例变量保存在同一个表中。然而，Ruby 获取或设置这两种类型的变量的方式却是完全不同的。
- en: When you get or set a class instance variable, Ruby looks up the variable in
    the `RClass` structure corresponding to the target class and either saves or retrieves
    the value. [Figure 5-17](ch05.html#ruby_saves_class_instance_variables_in_t "Figure 5-17. Ruby
    saves class instance variables in the RClass structure of the target class.")
    shows how Ruby saves the class instance variables from [Example 5-14](ch05.html#each_class_and_subclass_has_its_own_inst
    "Example 5-14. Each class and subclass has its own instance variables.").
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你获取或设置类实例变量时，Ruby 会在对应目标类的 `RClass` 结构中查找该变量，然后保存或获取该值。[图 5-17](ch05.html#ruby_saves_class_instance_variables_in_t
    "图 5-17. Ruby 将类实例变量保存在目标类的 RClass 结构中。") 显示了 Ruby 如何从 [示例 5-14](ch05.html#each_class_and_subclass_has_its_own_inst
    "示例 5-14. 每个类和子类都有自己的实例变量。") 中保存类实例变量。
- en: '![Ruby saves class instance variables in the RClass structure of the target
    class.](httpatomoreillycomsourcenostarchimages1854073.png.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 将类实例变量保存在目标类的 RClass 结构中。](httpatomoreillycomsourcenostarchimages1854073.png.jpg)'
- en: Figure 5-17. Ruby saves class instance variables in the `RClass` structure of
    the target class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-17. Ruby 将类实例变量保存在目标类的 `RClass` 结构中。
- en: At the top of the figure, you can see a line of code that saves a class instance
    variable in `Mathematician`. Below that is a similar line of code that saves a
    value in `Statistician`. In both cases, Ruby saves the class instance variable
    in the `RClass` structure for the current class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的顶部，你可以看到一行代码，它将类实例变量保存在 `Mathematician` 中。下面是另一行类似的代码，它将一个值保存在 `Statistician`
    中。在这两种情况下，Ruby 都会将类实例变量保存在当前类的 `RClass` 结构中。
- en: Ruby uses a more complex algorithm for class variables. To produce the behavior
    we saw in [Example 5-15](ch05.html#ruby_shares_class_variables_among_a_clas "Example 5-15. Ruby
    shares class variables among a class and all of its subclasses."), Ruby needs
    to search through all the superclasses to see whether any of them define the same
    class variable. [Figure 5-18](ch05.html#before_saving_itcomma_ruby_checks_whethe
    "Figure 5-18. Before saving it, Ruby checks whether the class variable exists
    in the target class or any of its superclasses.") shows an example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 对类变量使用了更复杂的算法。为了实现我们在 [示例 5-15](ch05.html#ruby_shares_class_variables_among_a_clas
    "示例 5-15. Ruby 在类和所有子类之间共享类变量。") 中看到的行为，Ruby 需要搜索所有父类，以检查它们是否定义了相同的类变量。[图 5-18](ch05.html#before_saving_itcomma_ruby_checks_whethe
    "图 5-18. 在保存之前，Ruby 会检查类变量是否存在于目标类或其任何父类中。") 显示了一个示例。
- en: '![Before saving it, Ruby checks whether the class variable exists in the target
    class or any of its superclasses.](httpatomoreillycomsourcenostarchimages1854075.png.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![在保存之前，Ruby 会检查类变量是否存在于目标类或其任何父类中。](httpatomoreillycomsourcenostarchimages1854075.png.jpg)'
- en: Figure 5-18. Before saving it, Ruby checks whether the class variable exists
    in the target class or any of its superclasses.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-18。 在保存之前，Ruby 会检查类变量是否存在于目标类或其任何父类中。
- en: When you save a class variable, Ruby looks in the target class and all of its
    superclasses for an existing variable. It will use the copy found in the highest
    superclass. In [Figure 5-18](ch05.html#before_saving_itcomma_ruby_checks_whethe
    "Figure 5-18. Before saving it, Ruby checks whether the class variable exists
    in the target class or any of its superclasses.") you can see Ruby checks both
    the `Statistician` and `Mathematician` classes when saving the `@@type` class
    variable in `Statistician`. Because I already saved the same class variable in
    `Mathematician` ([Example 5-15](ch05.html#ruby_shares_class_variables_among_a_clas
    "Example 5-15. Ruby shares class variables among a class and all of its subclasses.")),
    Ruby will use that and overwrite it with the new value, as shown in [Figure 5-19](ch05.html#ruby_uses_the_class_variable_copy_found
    "Figure 5-19. Ruby uses the class variable copy found in the highest superclass.").
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存一个类变量时，Ruby 会在目标类及其所有父类中查找现有的变量。它将使用在最高父类中找到的副本。在 [图 5-18](ch05.html#before_saving_itcomma_ruby_checks_whethe
    "图 5-18. 在保存之前，Ruby 会检查类变量是否存在于目标类或其任何父类中。") 中，你可以看到 Ruby 在保存 `Statistician` 类中的
    `@@type` 类变量时会检查 `Statistician` 和 `Mathematician` 类。因为我已经在 `Mathematician` 类中保存了相同的类变量（[示例
    5-15](ch05.html#ruby_shares_class_variables_among_a_clas "示例 5-15. Ruby 在一个类及其所有子类之间共享类变量")），所以
    Ruby 会使用它并用新值覆盖它，如 [图 5-19](ch05.html#ruby_uses_the_class_variable_copy_found
    "图 5-19. Ruby 使用在最高父类中找到的类变量副本。") 所示。
- en: '![Ruby uses the class variable copy found in the highest superclass.](httpatomoreillycomsourcenostarchimages1854077.png.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 使用在最高父类中找到的类变量副本。](httpatomoreillycomsourcenostarchimages1854077.png.jpg)'
- en: Figure 5-19. Ruby uses the class variable copy found in the highest superclass.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-19。 Ruby 使用在最高父类中找到的类变量副本。
- en: Constants
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: 'We have one more feature of Ruby classes to cover: *constants*. As you may
    know, Ruby allows you to define constant values inside a class, like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有 Ruby 类的一个特性要介绍：*常量*。正如你所知道的，Ruby 允许你在类内部定义常量值，像这样：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Constant values must start with a capital letter, and they are valid within
    the scope of the current class. (Curiously, Ruby allows you to change a constant
    value, but it will display a warning when you do so.) Let’s add a constant table
    to our `RClass` structure, because Ruby must save these values inside each class,
    as shown in [Figure 5-20](ch05.html#ruby_classes_also_contain_a_constants_ta "Figure 5-20. Ruby
    classes also contain a constants table.").
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 常量值必须以大写字母开头，它们在当前类的作用域内有效。（有趣的是，Ruby 允许你更改常量值，但当你这么做时会显示一个警告。）让我们在 `RClass`
    结构中添加一个常量表，因为 Ruby 必须将这些值保存在每个类中，如 [图 5-20](ch05.html#ruby_classes_also_contain_a_constants_ta
    "图 5-20. Ruby 类还包含一个常量表。") 所示。
- en: 'Now we can write a complete, technical definition of a Ruby class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以写出 Ruby 类的完整技术定义：
- en: A Ruby class is a Ruby object that also contains method definitions, attribute
    names, a superclass pointer, and a constants table.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Ruby 类是一个 Ruby 对象，它还包含方法定义、属性名称、父类指针和常量表。
- en: Granted, this isn’t as concise as the simple definition we had for a Ruby object,
    but each Ruby class contains much more information than each Ruby object. Ruby
    classes are obviously fundamental to the language.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不像我们为 Ruby 对象定义的简洁，但每个 Ruby 类包含的信息远多于每个 Ruby 对象。显然，Ruby 类对语言来说是至关重要的。
- en: '![Ruby classes also contain a constants table.](httpatomoreillycomsourcenostarchimages1854079.png.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 类还包含一个常量表。](httpatomoreillycomsourcenostarchimages1854079.png.jpg)'
- en: Figure 5-20. Ruby classes also contain a constants table.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-20。 Ruby 类还包含一个常量表。
- en: The Actual RClass Structure
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际的 RClass 结构
- en: Having built up a conceptual model for what information must be stored in `RClass`,
    let’s look at the actual structure that Ruby uses to represent classes, as shown
    in [Figure 5-21](ch05.html#how_ruby_actually_represents_a_class "Figure 5-21. How
    Ruby actually represents a class").
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 `RClass` 构建了一个概念模型之后，让我们看看 Ruby 实际上用来表示类的结构，如 [图 5-21](ch05.html#how_ruby_actually_represents_a_class
    "图 5-21. Ruby 实际上是如何表示类的") 所示。
- en: 'As you can see, Ruby uses two separate structures to represent each class:
    `RClass` and `rb_classext_struct`. But these two structures act as one large structure
    because each `RClass` always contains a pointer (`ptr`) to a corresponding `rb_classext_struct`.
    You might guess that the Ruby core team decided to use two different structures
    because there are so many different values to save, but in fact they probably
    created `rb_classext_struct` to save internal values that they didn’t want to
    expose in the public Ruby C extension API.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Ruby 使用两个独立的结构来表示每个类：`RClass` 和 `rb_classext_struct`。但是这两个结构作为一个大的结构共同作用，因为每个
    `RClass` 都包含一个指向对应 `rb_classext_struct` 的指针（`ptr`）。你可能猜测 Ruby 核心团队决定使用两种不同的结构，是因为有很多不同的值需要保存，但实际上他们可能创建了
    `rb_classext_struct` 来保存他们不希望在公共 Ruby C 扩展 API 中暴露的内部值。
- en: 'Like `RObject`, `RClass` has a `VALUE` pointer (shown on the left of [Figure 5-21](ch05.html#how_ruby_actually_represents_a_class
    "Figure 5-21. How Ruby actually represents a class")). Ruby always accesses classes
    using these `VALUE` pointers. The right side of the figure shows the technical
    names for the fields:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `RObject` 一样，`RClass` 也有一个 `VALUE` 指针（如 [图 5-21](ch05.html#how_ruby_actually_represents_a_class
    "图 5-21. Ruby 实际上是如何表示一个类的") 中所示左侧）。Ruby 总是通过这些 `VALUE` 指针访问类。图的右侧显示了字段的技术名称：
- en: '`flags` and `klass` are the same `RBasic` values that every Ruby value contains.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 和 `klass` 是每个 Ruby 值都包含的相同 `RBasic` 值。'
- en: '`m_tbl` is the method table, a hash whose keys are the names, or IDs, of each
    method and whose values are pointers to the definition of each method, including
    the compiled YARV instructions.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_tbl` 是方法表，一个哈希表，其键是每个方法的名称或ID，值是指向每个方法定义的指针，包括已编译的 YARV 指令。'
- en: '`iv_index_tbl` is the attribute names table, a hash that maps each instance
    variable name to the index of the attribute’s value in each `RObject` instance
    variable array.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iv_index_tbl` 是属性名称表，一个哈希表，将每个实例变量名称映射到每个 `RObject` 实例变量数组中该属性值的索引。'
- en: '`super` is a pointer to the `RClass` structure for this class’s superclass.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super` 是指向该类的父类的 `RClass` 结构体的指针。'
- en: '![How Ruby actually represents a class](httpatomoreillycomsourcenostarchimages1854081.png.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Ruby 实际上是如何表示一个类的](httpatomoreillycomsourcenostarchimages1854081.png.jpg)'
- en: Figure 5-21. How Ruby actually represents a class
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5-21. Ruby 实际上是如何表示一个类的
- en: '`iv_tbl` contains the class-level instance variables and class variables, including
    both their names and values.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iv_tbl` 包含类级别的实例变量和类变量，包括它们的名称和值。'
- en: '`const_tbl` is a hash containing all of the constants (names and values) defined
    in this class’s scope. You can see that Ruby implements `iv_tbl` and `const_tbl`
    in the same way: Class-level instance variables and constants are almost the same
    thing.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const_tbl` 是一个哈希表，包含在此类作用域中定义的所有常量（名称和值）。可以看到 Ruby 以相同的方式实现了 `iv_tbl` 和 `const_tbl`：类级别的实例变量和常量几乎是一样的。'
- en: Ruby uses `origin` to implement the `Module#prepend` feature. I’ll discuss what
    `prepend` does and how Ruby implements it in [Chapter 6](ch06.html "Chapter 6. Method
    Lookup and Constant Lookup").
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 使用 `origin` 来实现 `Module#prepend` 特性。我将在 [第 6 章](ch06.html "第 6 章：方法查找与常量查找")中讨论
    `prepend` 的作用以及 Ruby 是如何实现它的。
- en: Ruby uses the `refined_class` pointer to implement the new experimental refinements
    feature, which I’ll discuss further in [Chapter 9](ch09.html "Chapter 9. Metaprogramming").
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 使用 `refined_class` 指针来实现新的实验性 refinements 特性，稍后我会在 [第 9 章](ch09.html "第
    9 章：元编程")中进一步讨论。
- en: Finally, Ruby uses `allocator` internally to allocate memory for new instances
    of this class.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，Ruby 内部使用 `allocator` 来分配该类新实例的内存。
- en: Reading the RClass C Structure Definition
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读 RClass C 结构体定义
- en: Now for a quick look at the actual `RClass` structure definition, as shown in
    [Example 5-16](ch05.html#definition_of_the_rclass_c_structure "Example 5-16. The
    definition of the RClass C structure").
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在快速查看实际的 `RClass` 结构体定义，如 [示例 5-16](ch05.html#definition_of_the_rclass_c_structure
    "示例 5-16. `RClass` C 结构体的定义") 所示。
- en: Example 5-16. The definition of the `RClass` C structure
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-16. `RClass` C 结构体的定义
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Like the `RObject` definition we saw in [Example 5-7](ch05.html#definitions_of_the_rbasic_and_robjec
    "Example 5-7. The definitions of the RBasic and RObject C structures"), this structure
    definition—including all of the values shown in [Figure 5-21](ch05.html#how_ruby_actually_represents_a_class
    "Figure 5-21. How Ruby actually represents a class")—can be found in the *`include/ruby/ruby.h`*
    file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 [示例 5-7](ch05.html#definitions_of_the_rbasic_and_robjec "示例 5-7. RBasic
    和 RObject C 结构的定义") 中看到的 `RObject` 定义一样，这个结构定义——包括 [图 5-21](ch05.html#how_ruby_actually_represents_a_class
    "图 5-21. Ruby 如何表示一个类") 中显示的所有值——可以在 *`include/ruby/ruby.h`* 文件中找到。
- en: The `rb_classext_struct` structure definition, on the other hand, can be found
    in the *internal.h* C header file, as shown in [Example 5-17](ch05.html#definition_of_the_rbunderscoreclasse
    "Example 5-17. The definition of the rb_classext_struct C structure").
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`rb_classext_struct` 结构定义可以在 *internal.h* C 头文件中找到，如 [示例 5-17](ch05.html#definition_of_the_rbunderscoreclasse
    "示例 5-17. `rb_classext_struct` C 结构的定义") 所示。
- en: Example 5-17. The definition of the `rb_classext_struct` C structure
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-17. `rb_classext_struct` C 结构的定义
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, you can see the values from [Figure 5-21](ch05.html#how_ruby_actually_represents_a_class
    "Figure 5-21. How Ruby actually represents a class"). Notice that the `st_table`
    C type appears four times in [Example 5-16](ch05.html#definition_of_the_rclass_c_structure
    "Example 5-16. The definition of the RClass C structure") and [Example 5-17](ch05.html#definition_of_the_rbunderscoreclasse
    "Example 5-17. The definition of the rb_classext_struct C structure"); this is
    Ruby’s hash table data structure. Internally, Ruby saves much of the information
    for each class using hash tables: the attribute names table, the method table,
    the class-level instance variable table, and the constants table.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以看到来自 [图 5-21](ch05.html#how_ruby_actually_represents_a_class "图 5-21.
    Ruby 如何表示一个类") 的值。注意，`st_table` C 类型在 [示例 5-16](ch05.html#definition_of_the_rclass_c_structure
    "示例 5-16. `RClass` C 结构的定义") 和 [示例 5-17](ch05.html#definition_of_the_rbunderscoreclasse
    "示例 5-17. `rb_classext_struct` C 结构的定义") 中出现了四次；这就是 Ruby 的哈希表数据结构。内部上，Ruby 使用哈希表保存每个类的大部分信息：属性名称表、方法表、类级实例变量表和常量表。
- en: 'Experiment 5-2: Where Does Ruby Save Class Methods?'
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 5-2：Ruby 如何保存类方法？
- en: 'We’ve seen how each `RClass` structure saves all methods defined in a certain
    class. In this example, Ruby stores information about the `first_name` method
    inside the `RClass` structure for `Mathematician` using the method table:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到每个 `RClass` 结构如何保存某个类中定义的所有方法。在这个例子中，Ruby 使用方法表将 `first_name` 方法的信息存储在
    `Mathematician` 的 `RClass` 结构中：
- en: '[PRE22]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But what about class methods? It’s common in Ruby to save methods in a class
    directly, using the syntax shown in [Example 5-18](ch05.html#defining_a_class_method_using_def_self
    "Example 5-18. Defining a class method using def self").
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 那么类方法呢？在 Ruby 中，通常使用直接将方法保存在类中，语法如 [示例 5-18](ch05.html#defining_a_class_method_using_def_self
    "示例 5-18. 使用 def self 定义类方法") 所示。
- en: Example 5-18. Defining a class method using `def self`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-18. 使用 `def self` 定义类方法
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Alternatively, you can use the syntax shown in [Example 5-19](ch05.html#defining_a_class_method_using_class_less
    "Example 5-19. Defining a class method using class << self").
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用 [示例 5-19](ch05.html#defining_a_class_method_using_class_less "示例 5-19.
    使用 class << self 定义类方法") 中显示的语法。
- en: Example 5-19. Defining a class method using `class << self`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-19. 使用 `class << self` 定义类方法
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Are they saved in the `RClass` structure along with the normal methods for each
    class, perhaps with a flag to indicate they are class methods and not normal methods?
    Or are they saved somewhere else? Let’s find out!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是保存在与每个类的普通方法一起的 `RClass` 结构中吗，可能使用一个标志来指示它们是类方法而不是普通方法？还是它们保存在其他地方？让我们来看看！
- en: 'It’s easy to see where class methods are *not* saved. They are obviously not
    saved in the `RClass` method table along with normal methods, because instances
    of `Mathematician` cannot call them, as demonstrated here:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出类方法**不是**保存在哪里。它们显然没有与普通方法一起保存在 `RClass` 方法表中，因为 `Mathematician` 的实例无法调用它们，正如下例所示：
- en: '[PRE25]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, keeping in mind that `Mathematician` is also a Ruby object, recall the
    following definition:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住 `Mathematician` 也是一个 Ruby 对象，请回顾以下定义：
- en: A Ruby class is a Ruby object that also contains method definitions, attribute
    names, a superclass pointer, and a constants table.
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个 Ruby 类是一个 Ruby 对象，它还包含方法定义、属性名称、父类指针和常量表。
- en: 'We assume that Ruby should save methods for `Mathematician` just as it saves
    them for any object: in the method table for the object’s class. In other words,
    Ruby should get `Mathematician`’s class using the `klass` pointer and save the
    method in the method table in that `RClass` structure, as shown in [Figure 5-22](ch05.html#shouldnapostrophet_ruby_save_class_metho
    "Figure 5-22. Shouldn’t Ruby save class methods in the method table for the class’s
    class?").'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设 Ruby 应该像保存任何对象的方法一样保存 `Mathematician` 的方法：保存在该对象类的方法表中。换句话说，Ruby 应该通过 `klass`
    指针获取 `Mathematician` 的类，并将方法保存在该 `RClass` 结构体的方法表中，如[图 5-22](ch05.html#shouldnapostrophet_ruby_save_class_metho
    "图 5-22. Ruby 是否应将类方法保存在类的方法表中？")所示。
- en: '![Shouldn’t Ruby save class methods in the method table for the class’s class?](httpatomoreillycomsourcenostarchimages1854083.png.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 是否应将类方法保存在类的方法表中？](httpatomoreillycomsourcenostarchimages1854083.png.jpg)'
- en: Figure 5-22. Shouldn’t Ruby save class methods in the method table for the class’s
    class?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-22. Ruby 是否应将类方法保存在类的方法表中？
- en: 'But Ruby doesn’t actually do this, as you can discover by creating another
    class and trying to call the new method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 Ruby 实际上并没有这样做，你可以通过创建另一个类并尝试调用新方法来发现这一点：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If Ruby had added the class method to the method table in the `Class` class,
    all classes in your application would have the method. Obviously this isn’t what
    we intended by writing a class method, and thankfully Ruby doesn’t implement class
    methods this way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Ruby 将类方法添加到 `Class` 类的方法表中，那么你应用程序中的所有类都会有这个方法。显然，这不是我们编写类方法时的意图，幸运的是，Ruby
    并没有这样实现类方法。
- en: Then where do the class methods go? For a clue, use the method `ObjectSpace.count_objects`,
    `shown in [Example 5-20](ch05.html#using_objectspacedotcountunderscoreobjec "Example 5-20. Using
    ObjectSpace.count_objects with :T_CLASS"):`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，类方法去哪了呢？提示是使用方法 `ObjectSpace.count_objects`，如[示例 5-20](ch05.html#using_objectspacedotcountunderscoreobjec
    "示例 5-20. 使用 ObjectSpace.count_objects 与 :T_CLASS")中所示：
- en: '`` Example 5-20. Using `ObjectSpace.count_objects` with `:T_CLASS` ``'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`` 示例 5-20. 使用 `ObjectSpace.count_objects` 与 `:T_CLASS` ``'
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`` `ObjectSpace.count_objects` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    returns the number of objects of a given type that exist. In this test, I’m passing
    the :`T_CLASS` symbol to get the count of class objects that exist in my IRB session.
    Before I create `Mathematician`, there are 859 classes at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg).
    After I declare `Mathematician`, there are 861 at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)—two
    more. That’s odd. I declared one new class, but Ruby actually created two! What
    is the second one for and where is it? ``'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `ObjectSpace.count_objects` 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    返回给定类型的对象数量。在这个测试中，我传递了 `:T_CLASS` 符号来获取在我的 IRB 会话中存在的类对象数量。在我创建 `Mathematician`
    之前，存在 859 个类，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 处显示。声明
    `Mathematician` 后，存在 861 个类，在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    处显示——多了两个。这很奇怪，我只声明了一个新类，但 Ruby 实际上创建了两个！第二个类是干什么的？它在哪里？``'
- en: '``It turns out that whenever you create a new class, internally Ruby creates
    two classes! The first class is your new class: Ruby creates a new `RClass` structure
    to represent your class, as described above. But internally Ruby also creates
    a second, hidden class called the *metaclass*. Why? To save any class methods
    that you might later create for your new class. In fact, Ruby sets the metaclass
    to be the class of your new class: It sets the `klass` pointer of your new `RClass`
    structure to point to the metaclass.``'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '``事实证明，每当你创建一个新类时，Ruby 内部会创建两个类！第一个类就是你创建的新类：Ruby 会创建一个新的 `RClass` 结构体来表示你的类，如上所述。但在内部，Ruby
    还会创建第二个隐藏的类，称为 *元类*。为什么？为了保存你以后可能为新类创建的任何类方法。实际上，Ruby 会将元类设置为你新类的类：它将你新 `RClass`
    结构体的 `klass` 指针指向元类。``'
- en: '``Without writing C code, there’s no easy way to see the metaclass or the `klass`
    pointer value, but you can obtain the metaclass as a Ruby object like this:``'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '``没有编写 C 代码，无法轻松查看元类或 `klass` 指针的值，但你可以像这样将元类作为 Ruby 对象获取：``'
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '``The first print statement displays the object’s class, while the second displays
    the object’s metaclass. The odd `#<Class:Mathematician>` syntax indicates that
    the second class is the metaclass for `Mathematician`. This is the second `RClass`
    structure that Ruby automatically created for me when I declared the `Mathematician`
    class. And this second `RClass` structure is where Ruby saves my class method,
    as shown in [Figure 5-23](ch05.html#objectcomma_its_classcomma_and_its_me "Figure 5-23. An
    object, its class, and its metaclass").``'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '``第一个打印语句显示对象的类，而第二个显示对象的元类。奇怪的 `#<Class:Mathematician>` 语法表示第二个类是 `Mathematician`
    的元类。这是 Ruby 在我声明 `Mathematician` 类时自动为我创建的第二个 `RClass` 结构。而这个第二个 `RClass` 结构是
    Ruby 保存我的类方法的地方，如[图 5-23](ch05.html#objectcomma_its_classcomma_and_its_me "图 5-23。一个对象，它的类和元类")所示。``'
- en: '`![An object, its class, and its metaclass](httpatomoreillycomsourcenostarchimages1854085.png.jpg)`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`![一个对象，它的类和元类](httpatomoreillycomsourcenostarchimages1854085.png.jpg)`'
- en: '`Figure 5-23. An object, its class, and its metaclass`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`图 5-23。一个对象，它的类和元类`'
- en: '``If we now display the methods for the metaclass, we’ll see all the methods
    of the `Class` class, along with the new class method for `Mathematician`:``'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '``如果我们现在显示元类的方法，我们将看到所有 `Class` 类的方法，以及 `Mathematician` 的新类方法：``'
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`Summary`'
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`总结`'
- en: '``In this chapter we’ve seen how Ruby represents objects and classes internally:
    Ruby uses the `RObject` structure to represent instances of any custom classes
    you define in your code and of some classes predefined by Ruby itself. The `RObject`
    structure is remarkably simple, containing just a pointer to the object’s class
    and a table of instance variable values, along with a count of the variables.
    The simplicity of its structure leads us to a very simple definition of a Ruby
    object:``'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '``在本章中，我们已经看到 Ruby 如何在内部表示对象和类：Ruby 使用 `RObject` 结构来表示你在代码中定义的任何自定义类的实例，以及
    Ruby 自身预定义的一些类的实例。`RObject` 结构非常简单，仅包含指向对象类的指针和一个实例变量值的表格，并且还包含变量的计数。其结构的简单性使我们能够给出
    Ruby 对象的非常简单的定义：``'
- en: '`Every Ruby object is the combination of a class pointer and an array of instance
    variables.`'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`每个 Ruby 对象都是类指针和实例变量数组的组合。`'
- en: '`This definition is powerful and useful because everything in Ruby is an object:
    Whenever you use a value in your Ruby program, regardless of what it is, remember
    that it will be an object and will therefore have a class pointer and instance
    variables.`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`这个定义非常强大且有用，因为 Ruby 中的一切都是对象：无论你在 Ruby 程序中使用什么值，记住它都是一个对象，因此它将具有类指针和实例变量。`'
- en: '``We also saw that Ruby uses special C structures to represent instances of
    many commonly used, built-in Ruby classes called “generic” objects. For example,
    Ruby uses the `RString` structure to represent an instance of the `String` class,
    `RArray` for an instance of the `Array` class, or `RRegexp` for an instance of
    the `Regexp` class. While these structures are different, Ruby also saves a class
    pointer and an array of instance variables for each of these generic objects.
    Finally, we saw that Ruby saves some simple values, such as small integers and
    symbols, without using a C structure at all. Ruby saves these values right inside
    the `VALUE` pointers that otherwise would point to the structure holding the value.``'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '``我们还看到 Ruby 使用特殊的 C 结构来表示许多常用的内置 Ruby 类的实例，这些类被称为“通用”对象。例如，Ruby 使用 `RString`
    结构来表示 `String` 类的实例，`RArray` 用于表示 `Array` 类的实例，或者 `RRegexp` 用于表示 `Regexp` 类的实例。虽然这些结构不同，但
    Ruby 同样为每个这些通用对象保存类指针和实例变量数组。最后，我们看到 Ruby 会将一些简单的值（如小整数和符号）保存，而完全不使用 C 结构。Ruby
    将这些值直接保存在 `VALUE` 指针中，而该指针通常指向保存值的结构。``'
- en: '``While Ruby objects are simple, we learned in this chapter that Ruby classes
    aren’t quite so simple. The `RClass` structure working with the `rb_classext_struct`
    structure saves a large set of information. Learning this forced us to write a
    more complex definition for Ruby classes:``'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '``虽然 Ruby 对象很简单，但我们在本章中学到，Ruby 类并没有那么简单。`RClass` 结构与 `rb_classext_struct` 结构一起工作，保存了大量的信息。学习这一点迫使我们为
    Ruby 类写出一个更复杂的定义：``'
- en: '`A Ruby class is a Ruby object that also contains method definitions, attribute
    names, a superclass pointer, and a constants table.`'
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Ruby 类是一个 Ruby 对象，它还包含方法定义、属性名称、父类指针和常量表。`'
- en: '``Looking inside `RClass` and `rb_classext_struct`, we saw that Ruby classes
    are also Ruby objects, which therefore also contain instance variables and a class
    pointer. We looked at the difference between a class’s instance variables and
    class variables and learned that Ruby saves both of these variable types in the
    same hash table. We discovered how classes also contain a series of hash tables
    that store their methods, the names of the object-level instance variables, and
    constants defined within the class. Finally, we saw how each Ruby class records
    its superclass using the `super` pointer.``'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '``通过查看 `RClass` 和 `rb_classext_struct`，我们发现 Ruby 类也是 Ruby 对象，因此它们也包含实例变量和类指针。我们研究了类的实例变量与类变量之间的区别，并了解到
    Ruby 将这两种变量类型保存在同一个哈希表中。我们还发现类包含一系列哈希表，用于存储其方法、对象级实例变量的名称以及类中定义的常量。最后，我们看到了每个
    Ruby 类如何通过 `super` 指针记录其父类。``'
