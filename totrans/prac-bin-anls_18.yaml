- en: A
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A
- en: A CRASH COURSE ON X86 ASSEMBLY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: X86 汇编速成课程
- en: Because assembly language is the standard representation of the machine instructions
    you’ll find in binaries, many binary analyses are based on disassembly. Therefore,
    it’s important that you’re familiar with the basics of x86 assembly language to
    get the most out of this book. This appendix introduces you to the essentials
    that you need to know to follow along.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因为汇编语言是你在二进制文件中找到的机器指令的标准表示方式，许多二进制分析都是基于反汇编的。因此，熟悉x86汇编语言的基础知识对最大化地利用本书非常重要。本附录将介绍你需要了解的基础知识，以便跟上内容。
- en: The purpose of this appendix is not to teach you how to write assembly programs
    (there are books dedicated to that subject) but to show you the essentials you
    need to know to understand disassembled programs. You’ll learn how assembly programs
    and x86 instructions are structured and how they behave at runtime. Moreover,
    you’ll see how common code constructs from C/C++ programs are represented at the
    assembly level. I’ll only cover basic 64-bit user-mode x86 instructions, not floating-point
    instructions or extended instruction sets like SSE or MMX. For brevity, I’ll refer
    to the 64-bit variant of x86 (x86-64 or x64) simply as x86, since that’s the focus
    of this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的目的不是教你如何编写汇编程序（有专门的书籍讲解这个主题），而是展示你理解反汇编程序所需了解的基本内容。你将了解汇编程序和x86指令的结构以及它们在运行时的行为。此外，你还将看到C/C++程序中常见的代码结构如何在汇编级别表现。我只会涵盖基本的64位用户模式x86指令，不包括浮点指令或扩展指令集，如SSE或MMX。为了简洁起见，我将把x86的64位变种（x86-64或x64）简称为x86，因为这是本书的重点。
- en: A.1 Layout of an Assembly Program
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.1 汇编程序的布局
- en: '[Listing A-1](appa.xhtml#appalist1) shows a simple C program, and [Listing
    A-2](appa.xhtml#appalist2) shows the corresponding assembly program produced by
    `gcc` 5.4.0\. ([Chapter 1](ch01.xhtml#ch01) explains how compilers transform C
    programs into assembly listings and eventually into binaries.)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 A-1](appa.xhtml#appalist1) 显示了一个简单的C程序，而 [清单 A-2](appa.xhtml#appalist2)
    显示了由`gcc` 5.4.0生成的相应汇编程序。（[第1章](ch01.xhtml#ch01) 解释了编译器如何将C程序转换为汇编列表，并最终转化为二进制文件。）'
- en: When you disassemble a binary, the disassembler essentially tries to translate
    it back into an accurate assembly listing resembling the compiler-generated assembly
    as closely as possible. For now, let’s take a look at the *layout* of the assembly
    program without going into details on the assembly instructions yet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你反汇编一个二进制文件时，反汇编器本质上会尝试将其翻译回一个准确的汇编列表，尽可能接近编译器生成的汇编代码。现在，让我们先看看汇编程序的*布局*，暂时不深入讨论汇编指令。
- en: '*Listing A-1: “Hello, world!” in C*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 A-1：C语言中的“Hello, world!”*'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing A-2: Assembly generated by* gcc'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 A-2：由* gcc 生成的汇编'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Listing A-1](appa.xhtml#appalist1) consists of a `main` function ➊ that calls
    `printf` ➋ to print a constant `"Hello, world!"` string ➌. At a high level, the
    corresponding assembly program consists of four types of components: instructions,
    directives, labels, and comments.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 A-1](appa.xhtml#appalist1) 由一个 `main` 函数 ➊ 组成，该函数调用 `printf` ➋ 打印常量 `"Hello,
    world!"` 字符串 ➌。从高层次来看，相应的汇编程序包含四种类型的组件：指令、指令、标签和注释。'
- en: '*A.1.1 Assembly Instructions, Directives, Labels, and Comments*'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.1.1 汇编指令、指令、标签和注释*'
- en: '[Table A-1](appa.xhtml#appatab1) shows examples of each component type. Note
    that the exact syntax for each component varies per assembler or disassembler.
    For the purposes of this book, you won’t need to be intimately familiar with any
    assembler’s syntactical quirks; you’ll only need to learn to read and analyze
    disassembled code, not write your own assembly code. Here, I’ll stick to the assembly
    syntax produced by `gcc` with the `-masm=intel` option.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 A-1](appa.xhtml#appatab1) 显示了每种组件类型的示例。请注意，每种组件的确切语法因汇编器或反汇编器而异。对于本书而言，你无需对任何汇编器的语法特性非常熟悉；你只需要学会阅读和分析反汇编代码，而不是编写自己的汇编代码。在这里，我将使用由`gcc`和`-masm=intel`选项生成的汇编语法。'
- en: '**Table A-1:** Components of an Assembly Program'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 A-1：** 汇编程序的组成部分'
- en: '| **Type** | **Example** | **Meaning** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **示例** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Instruction | `mov eax, 0` | Move zero into `eax` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | `mov eax, 0` | 将零存入 `eax` |'
- en: '| Directive | `.section .text` | Place the following content into the `.text`
    section |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | `.section .text` | 将以下内容放入 `.text` 区段 |'
- en: '| Directive | `.string "foobar"` | Define an ASCII string containing `"foobar"`
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | `.string "foobar"` | 定义一个包含 `"foobar"` 的ASCII字符串 |'
- en: '| Directive | `.long 0x12345678` | Define a doubleword with value `0x12345678`
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | `.long 0x12345678` | 定义一个值为`0x12345678`的双字 |'
- en: '| Label | `foo: .string "foobar"` | Define the `"foobar"` string with symbolic
    name `foo` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | `foo: .string "foobar"` | 定义一个符号名为`foo`的`"foobar"`字符串 |'
- en: '| Comment | `# this is a comment` | A human-readable comment |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 注释 | `# this is a comment` | 一条可读的注释 |'
- en: '*Instructions* are the actual operations that the CPU executes. *Directives*
    are commands that tell the assembler to produce a particular piece of data, place
    instructions or data in a particular section, and so on. Finally, *labels* are
    symbolic names that you can use to refer to instructions or data in the assembly
    program, and *comments* are human-readable strings for documentation purposes.
    After the program is assembled and linked into a binary, all symbolic names are
    replaced by addresses.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*指令*是CPU执行的实际操作。*指令*是告诉汇编器生成特定数据、将指令或数据放入特定区域等命令。最后，*标签*是可以用来引用汇编程序中指令或数据的符号名称，*注释*是供文档使用的可读字符串。在程序汇编并链接成二进制文件后，所有符号名称都会被地址替代。'
- en: The assembly program in [Listing A-2](appa.xhtml#appalist2) directs the assembler
    to place the `"Hello, world!"` string in the `.rodata` section ➍➎, which is a
    section dedicated to storing constant data. The directive `.section` tells the
    assembler in which section to place the following content, while `.string` is
    a directive that allows you to define an ASCII string. There are also directives
    to define other types of data, such as `.byte` (define a byte), `.word` (a 2-byte
    word), `.long` (a 4-byte doubleword), and `.quad` (an 8-byte quadword).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 A-2](appa.xhtml#appalist2)中的汇编程序指示汇编器将`"Hello, world!"`字符串放入`.rodata`段
    ➍➎，该段专门用于存储常量数据。指令`.section`告诉汇编器将以下内容放入哪个段，而`.string`是一个指令，用于定义ASCII字符串。还有一些用于定义其他类型数据的指令，例如`.byte`（定义一个字节），`.word`（一个2字节字），`.long`（一个4字节双字），以及`.quad`（一个8字节四字）。'
- en: The `main` function is placed in the `.text` section ➏➐, dedicated to storing
    code. The `.text` directive is shorthand for `.section .text`, and `main:` introduces
    a symbolic label for the `main` function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数被放置在`.text`段 ➏➐，该段专门用于存储代码。`.text`指令是`.section .text`的简写，而`main:`为`main`函数引入了一个符号标签。'
- en: The label is followed by the actual instructions that `main` contains. These
    instructions can refer symbolically to previously declared data, such as `.LC0`
    ➑ (the symbolic name `gcc` chose for the `"Hello, world!"` string). Because the
    program prints a constant string (without variadic arguments), `gcc` replaces
    the `printf` call with a call to `puts` ➒, a simpler function that prints a given
    string to screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 标签后面跟着的是`main`包含的实际指令。这些指令可以通过符号引用之前声明的数据，例如`.LC0` ➑（`gcc`为`"Hello, world!"`字符串选择的符号名称）。因为程序打印一个常量字符串（没有可变参数），`gcc`将`printf`调用替换为`puts`
    ➒调用，这是一个更简单的函数，用来将指定的字符串输出到屏幕上。
- en: '*A.1.2 Separation Between Code and Data*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.1.2 代码与数据的分离*'
- en: One key observation you can make in [Listing A-2](appa.xhtml#appalist2) is that
    compilers usually separate code and data into different sections. That’s convenient
    when you’re disassembling or analyzing a binary because you know which bytes in
    the program to interpret as code and which to interpret as data. However, there’s
    nothing inherent in the x86 architecture preventing you from mixing code and data
    in the same section, and in practice, some compilers or handwritten assembly programs
    do exactly that.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 A-2](appa.xhtml#appalist2)中，你可以观察到一个关键点，即编译器通常将代码和数据分开到不同的段中。这在你反汇编或分析二进制文件时很方便，因为你知道程序中的哪些字节是代码，哪些是数据。然而，x86架构本身并没有限制你将代码和数据混合在同一段中，实际上，有些编译器或手写汇编程序就是这样做的。
- en: '*A.1.3 AT&T vs. Intel Syntax*'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.1.3 AT&T与Intel语法*'
- en: 'As mentioned, different assemblers use different syntaxes for assembly programs.
    On top of that, there are two different syntax formats in use to represent x86
    machine instructions: *Intel syntax* and *AT&T syntax*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，不同的汇编器使用不同的语法来表示汇编程序。除此之外，x86机器指令有两种不同的语法格式：*Intel语法*和*AT&T语法*。
- en: 'AT&T syntax explicitly prefixes every register name with the `%` symbol and
    every constant with a `$` symbol, while Intel syntax omits these symbols. In this
    book, I use Intel syntax because it’s less verbose. The most crucial difference
    between AT&T and Intel is that they order instruction operands in exactly opposite
    ways. In AT&T syntax, the source operand comes before the destination so that
    moving a constant into the `edi` register looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: AT&T 语法在每个寄存器名称前面显式添加 `%` 符号，在每个常量前面添加 `$` 符号，而 Intel 语法则省略这些符号。在本书中，我使用 Intel
    语法，因为它较为简洁。AT&T 和 Intel 语法的最重要区别在于它们的操作数顺序完全相反。在 AT&T 语法中，源操作数在目标操作数之前，因此将常量移动到
    `edi` 寄存器的写法如下：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In contrast, Intel syntax represents the same instruction as follows, with
    the destination operand first:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Intel 语法将相同的指令表示如下，目标操作数在前：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It’s important to keep the operand ordering in mind because you’ll probably
    encounter both syntax styles as you delve further into binary analysis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记操作数的顺序非常重要，因为在深入进行二进制分析时，你可能会遇到两种语法风格。
- en: A.2 Structure of an x86 Instruction
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2 x86 指令的结构
- en: Now that you have an idea of how assembly programs are structured, let’s take
    a look at the format of assembly instructions. You’ll also see the structure of
    the machine-level instructions that the assembly represents.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对汇编程序的结构有了一定的了解，让我们来看看汇编指令的格式。你还将看到汇编所表示的机器级指令的结构。
- en: '*A.2.1 Assembly-Level Representation of x86 Instructions*'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.2.1 x86 指令的汇编级表示*'
- en: At the assembly level, x86 instructions generally have the form `mnemonic destination,
    source`. The mnemonic is a human-readable representation of a machine instruction,
    and source and destination are the operands of the instruction. For example, the
    assembly instruction `mov rbx, rax` copies the value from the `rax` register into
    `rbx`. Note that not all instructions have exactly two operands; some even have
    no operands at all, as you’ll see shortly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编级别，x86 指令通常采用 `助记符 目标操作数, 源操作数` 的形式。助记符是机器指令的可读表示，源操作数和目标操作数是指令的操作数。例如，汇编指令
    `mov rbx, rax` 将 `rax` 寄存器中的值复制到 `rbx` 中。请注意，并非所有指令都有恰好两个操作数；有些指令甚至没有操作数，如你接下来将看到的那样。
- en: As mentioned, mnemonics are higher-level representations of the machine instructions
    the CPU understands. Let’s take a brief look at how x86 instructions are structured
    at the machine level. That’s useful to know in some binary analysis situations,
    such as when you’re modifying an existing binary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，助记符是 CPU 理解的机器指令的高级表示。让我们简要了解一下 x86 指令在机器级别的结构。这在某些二进制分析场景中非常有用，比如当你修改现有的二进制文件时。
- en: '*A.2.2 Machine-Level Structure of x86 Instructions*'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.2.2 x86 指令的机器级结构*'
- en: The x86 ISA uses variable-length instructions; there are x86 instructions that
    consist of only 1 byte, but also multibyte instructions, ranging up to a maximum
    instruction length of 15 bytes. Moreover, instructions can start at any memory
    address. This means that the CPU doesn’t enforce any particular code alignment,
    although compilers often do align code to optimize the performance of fetching
    instructions from memory. [Figure A-1](appa.xhtml#appafig1) shows the machine-level
    structure of an x86 instruction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: x86 ISA 使用可变长度的指令；有些 x86 指令只有 1 个字节，但也有多字节指令，最长可达 15 字节。此外，指令可以从任何内存地址开始。这意味着
    CPU 不强制要求特定的代码对齐，尽管编译器通常会对代码进行对齐，以优化从内存中获取指令的性能。[图 A-1](appa.xhtml#appafig1) 显示了
    x86 指令的机器级结构。
- en: '![image](Images/f377-01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f377-01.jpg)'
- en: '*Figure A-1: Structure of an x86 instruction*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-1：x86 指令的结构*'
- en: An x86 instruction consists of optional prefixes, an opcode, and zero or more
    operands. Note that all parts except for the opcode are optional.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一条 x86 指令由可选的前缀、一个操作码和零个或多个操作数组成。请注意，除了操作码外，其他部分都是可选的。
- en: The opcode is the main designator for the instruction type. For instance, the
    opcode `0x90` encodes a `nop` instruction, which does nothing, while the opcodes
    `0x00`–`0x05` encode various types of `add` instructions. Prefixes can modify
    the behavior of an instruction, for example, causing it to repeat multiple times
    or access a different memory segment. Finally, the operands are the data that
    the instruction operates on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 操作码是指令类型的主要标识符。例如，操作码 `0x90` 编码的是 `nop` 指令，它什么都不做，而操作码 `0x00`–`0x05` 编码的是各种类型的
    `add` 指令。前缀可以修改指令的行为，例如，导致指令重复执行多次或访问不同的内存段。最后，操作数是指令所操作的数据。
- en: The *addressing mode* byte, also known as the *MOD-R/M* or *MOD-REGR/M* byte,
    contains metadata about the instruction’s operand types. The *SIB (scale/index/base)*
    bytes and the *displacement* are used to encode memory operands, and the *immediate*
    field can contain an immediate operand (a constant numeric value). You’ll see
    what these fields mean in more detail shortly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*寻址模式*字节，也称为*MOD-R/M*或*MOD-REGR/M*字节，包含关于指令操作数类型的元数据。*SIB（比例/索引/基址）*字节和*位移*用于编码内存操作数，*立即数*字段可以包含立即数操作数（常量数值）。稍后你将更详细地了解这些字段的含义。'
- en: In addition to the *explicit operands* shown in [Figure A-1](appa.xhtml#appafig1),
    some instructions have *implicit operands*. These aren’t explicitly encoded in
    the instruction but are innate to the opcode. For example, the destination operand
    of opcode `0x05` (an `add` instruction) is always `rax`, and only the source operand
    is variable and needs to be explicitly encoded. As another example, the `push`
    instruction implicitly updates `rsp` (the stack pointer register).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[图A-1](appa.xhtml#appafig1)中显示的*显式操作数*外，一些指令还具有*隐式操作数*。这些操作数并没有在指令中明确编码，但它们是操作码固有的。例如，操作码`0x05`（`add`指令）的目标操作数总是`rax`，只有源操作数是可变的，需要明确编码。另一个例子是，`push`指令隐式地更新`rsp`（栈指针寄存器）。
- en: 'On x86, instructions can have three different types of operands: register operands,
    memory operands, and immediates. Let’s take a look at each of the valid operand
    types.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86中，指令可以有三种不同类型的操作数：寄存器操作数、内存操作数和立即数。我们来看一下每种有效的操作数类型。
- en: '*A.2.3 Register Operands*'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.2.3 寄存器操作数*'
- en: '*Registers* are small, quickly accessible pieces of storage located on the
    CPU itself. Some registers have a special purpose, such as the instruction pointer
    that tracks the current execution address or the stack pointer that tracks the
    top of the stack. Others are general-purpose storage units for variables used
    by whatever program the CPU is executing.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*寄存器*是位于CPU本身的小型、快速访问的存储单元。有些寄存器具有特殊功能，例如跟踪当前执行地址的指令指针，或跟踪栈顶的栈指针。其他寄存器则是用于存储CPU执行的程序中变量的通用存储单元。'
- en: General-Purpose Registers
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通用寄存器
- en: In the original 8086 instruction set on which x86 is based, registers were 16
    bits wide. The 32-bit x86 ISA extended these registers to 32 bits, and x86-64
    extended them further to 64 bits. To retain backward compatibility, the registers
    used in the newer instruction sets are a superset of the older registers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86架构所基于的原始8086指令集上，寄存器是16位宽的。32位的x86指令集扩展了这些寄存器至32位，x86-64进一步扩展至64位。为了保持向后兼容性，较新指令集中的寄存器是较旧寄存器的超集。
- en: To specify a register operand in assembly, you use the register’s name. For
    example, `mov rax,64` moves the value 64 into the `rax` register. [Figure A-2](appa.xhtml#appafig2)
    shows how the 64-bit `rax` register is subdivided into legacy 32-bit and 16-bit
    registers. The lower 32 bits of `rax` form a register named `eax`, and the lower
    16 bits of that form the original 8086 register `ax`. You can access the lower
    byte in `ax` through the register name `al` and the higher byte through `ah`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在汇编中指定一个寄存器操作数，你需要使用寄存器的名称。例如，`mov rax,64` 将值64移动到`rax`寄存器中。[图A-2](appa.xhtml#appafig2)展示了64位的`rax`寄存器如何细分成传统的32位和16位寄存器。`rax`的低32位组成一个名为`eax`的寄存器，而其低16位则组成原始的8086寄存器`ax`。你可以通过寄存器名`al`访问`ax`的低字节，通过`ah`访问高字节。
- en: '![image](Images/f378-01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f378-01.jpg)'
- en: '*Figure A-2: Subdivision of the x86-64* `rax` *register*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-2：x86-64* `rax` *寄存器的细分*'
- en: Other registers have similar naming schemes. [Table A-2](appa.xhtml#appatab2)
    shows the names of the general-purpose registers available on x86-64, as well
    as the available legacy “subregisters.” The `r8`–`r15` registers were added in
    x86-64 and aren’t available in earlier x86 variants. Note that if you set a 32-bit
    subregister like `eax`, this automatically zeros out the other bits in the parent
    register (in this case, `rax`); setting smaller subregisters like `ax`, `al`,
    and `ah` retains the other bits.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其他寄存器有类似的命名规则。[表A-2](appa.xhtml#appatab2)展示了x86-64上可用的通用寄存器名称，以及可用的传统“子寄存器”。`r8`–`r15`寄存器是x86-64中新增的，在早期的x86变种中不可用。请注意，如果你设置了一个32位的子寄存器，如`eax`，这会自动将父寄存器（在这种情况下是`rax`）中的其他位清零；而设置较小的子寄存器，如`ax`、`al`和`ah`，则保留其他位。
- en: '**Table A-2:** x86 General-Purpose Registers'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**表A-2：** x86通用寄存器'
- en: '| **Description** | **64-bit** | **Lower 32 bits** | **Lower 16 bits** | **Lower
    byte** | **2nd byte** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | **64位** | **低32位** | **低16位** | **低字节** | **第二字节** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Accumulator | `rax` | `eax` | `ax` | `al` | `ah` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 累加器 | `rax` | `eax` | `ax` | `al` | `ah` |'
- en: '| Base | `rbx` | `ebx` | `bx` | `bl` | `bh` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 基址 | `rbx` | `ebx` | `bx` | `bl` | `bh` |'
- en: '| Counter | `rcx` | `ecx` | `cx` | `cl` | `ch` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 计数器 | `rcx` | `ecx` | `cx` | `cl` | `ch` |'
- en: '| Data | `rdx` | `edx` | `dx` | `dl` | `dh` |  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 数据 | `rdx` | `edx` | `dx` | `dl` | `dh` |  |'
- en: '| Stack | `pointer` | `rsp` | `esp` | `sp` | `spl` |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 堆栈 | `pointer` | `rsp` | `esp` | `sp` | `spl` |  |'
- en: '| Base | `pointer` | `rbp` | `ebp` | `bp` | `bpl` |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 基址 | `pointer` | `rbp` | `ebp` | `bp` | `bpl` |  |'
- en: '| Source index | `rsi` | `esi` | `si` | `sil` |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 源索引 | `rsi` | `esi` | `si` | `sil` |  |'
- en: '| Destination index | `rdi` | `edi` | `di` | `dil` |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 目标索引 | `rdi` | `edi` | `di` | `dil` |  |'
- en: '| x86-64 GP registers | `r8–r15` | `r8d–r15d` | `r8w–r15w` | `r8l–r15l` |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| x86-64 通用寄存器 | `r8–r15` | `r8d–r15d` | `r8w–r15w` | `r8l–r15l` |  |'
- en: Don’t put too much weight on the description column for most registers. Those
    descriptions stem from the 8086 instruction set, but nowadays most of the registers
    shown in [Table A-2](appa.xhtml#appatab2) are simply used interchangeably. As
    you can see in [Section A.4.1](appa.xhtml#appa_4_1), the stack pointer (`rsp`)
    and base pointer (`rbp`) are considered special because they’re used to track
    the layout of the stack, even though you can in principle use them as general-purpose
    registers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过分关注大多数寄存器的描述列。这些描述源自 8086 指令集，但如今，大多数在[表 A-2](appa.xhtml#appatab2)中显示的寄存器是可以互换使用的。正如你在[第
    A.4.1 节](appa.xhtml#appa_4_1)中看到的那样，栈指针（`rsp`）和基指针（`rbp`）被认为是特殊的，因为它们用于跟踪栈的布局，尽管原则上你可以将它们用作通用寄存器。
- en: Other Registers
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 其他寄存器
- en: In addition to the registers shown in [Table A-2](appa.xhtml#appatab2), x86
    CPUs contain other registers that aren’t general purpose. The two most important
    are `rip` (called `eip` on 32-bit x86 and `ip` on 8086) and `rflags` (called `eflags`
    or `flags` in older ISAs). The instruction pointer always points to the next instruction
    address and is automatically set by the CPU; you can’t manually write it. On x86-64
    you can read the value of the instruction pointer, but on 32-bit x86 you can’t
    even do that. The status flags register is used for comparisons and conditional
    branches and tracks things like whether the last operation yielded zero, resulted
    in an overflow, and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[表 A-2](appa.xhtml#appatab2)中显示的寄存器，x86 CPU 还包含一些非通用寄存器。最重要的两个是 `rip`（在 32
    位 x86 上称为 `eip`，在 8086 上称为 `ip`）和 `rflags`（在较旧的指令集架构中称为 `eflags` 或 `flags`）。指令指针总是指向下一条指令的地址，并由
    CPU 自动设置；你不能手动写入它。在 x86-64 上，你可以读取指令指针的值，但在 32 位 x86 上，甚至连这一点都做不到。状态标志寄存器用于比较和条件跳转，跟踪诸如上次操作是否结果为零、是否溢出等信息。
- en: The x86 ISA also has *segment registers* named `cs`, `ds`, `ss`, `es`, `fs`,
    and `gs` that you can use to divide memory into different segments. Segmentation
    has largely fallen into disuse, and x86-64 has mostly dropped support for it,
    so I won’t go into details on segmentation here. If you’re interested in learning
    more, a dedicated book on x86 assembly should cover this topic.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: x86 指令集架构还有*段寄存器*，如 `cs`、`ds`、`ss`、`es`、`fs` 和 `gs`，你可以使用它们将内存分割成不同的段。段式管理大多已经不再使用，x86-64
    也大部分放弃了对其的支持，所以我在这里不会详细介绍段式管理。如果你有兴趣了解更多，可以参考一本专门讲解 x86 汇编的书籍。
- en: There are also *control registers* such as `cr0`–`cr10` that the kernel uses
    to control the CPU’s behavior, for instance, to switch between protected mode
    and real mode. Additionally, registers `dr0`–`dr7` are *debug registers* that
    provide hardware support for debugging features such as breakpoints. On x86, control
    and debug registers are not accessible from user mode; only the kernel can access
    them. Therefore, I won’t cover these registers further in this appendix.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些*控制寄存器*，如 `cr0`–`cr10`，内核用它们来控制 CPU 的行为，例如切换保护模式和实模式。此外，寄存器 `dr0`–`dr7`
    是*调试寄存器*，提供硬件支持调试功能，如断点。在 x86 上，控制和调试寄存器无法从用户模式访问；只有内核可以访问它们。因此，我在本附录中不会进一步讲解这些寄存器。
- en: There are also various *model-specific registers (MSRs)* and registers used
    in extended instruction sets like SSE and MMX that aren’t present on all x86 CPUs.
    You can use the `cpuid` instruction to find out which features the CPU supports
    and use the `rdmsr` and `wrmsr` instructions to read or write model-specific registers.
    Because many of these special registers are available only from the kernel, you
    won’t have to deal with them in this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还有各种*特定模型寄存器（MSRs）*和在扩展指令集（如SSE和MMX）中使用的寄存器，这些寄存器并非所有x86 CPU都有。你可以使用`cpuid`指令来查找CPU支持哪些特性，并使用`rdmsr`和`wrmsr`指令来读取或写入特定模型寄存器。由于许多这些特殊寄存器仅在内核中可用，因此你在本书中不需要处理它们。
- en: '*A.2.4 Memory Operands*'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.2.4 内存操作数*'
- en: '*Memory operands* specify a memory address where the CPU should fetch one or
    more bytes. The x86 ISA supports only one explicit memory operand per instruction.
    That is, you can’t directly `mov` bytes from one memory location to another in
    one instruction. To accomplish that, you have to use a register as intermediate
    storage.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存操作数*指定CPU应从中获取一个或多个字节的内存地址。x86 ISA每条指令仅支持一个显式内存操作数。也就是说，你不能在一条指令中直接将字节从一个内存位置复制到另一个位置。要做到这一点，你必须使用寄存器作为中介存储。'
- en: On x86, you specify memory operands with `[`*base* `+` *index*`*`*scale* `+`
    *displacement*`]`, where *base* and *index* are 64-bit registers, *scale* is an
    integer with the value 1, 2, 4, or 8, and *displacement* is a 32-bit constant
    or a symbol. All of these components are optional. The CPU computes the result
    of the memory operand expression, yielding the final memory address. The base,
    index, and scale are encoded in the instruction’s SIB byte, while the displacement
    is encoded in the field of the same name. The scale defaults to 1, while the displacement
    defaults to 0.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86中，你通过`[`*基址* `+` *索引*`*`*比例* `+` *位移*`]`来指定内存操作数，其中*基址*和*索引*是64位寄存器，*比例*是一个整数，值为1、2、4或8，*位移*是32位常数或符号。所有这些组件都是可选的。CPU计算内存操作数表达式的结果，得到最终的内存地址。基址、索引和比例被编码在指令的SIB字节中，而位移则被编码在同名字段中。比例默认值为1，位移默认值为0。
- en: This memory operand format is flexible enough to allow many common code paradigms
    in a straightforward way. For instance, you can use an instruction like `mov eax,
    DWORD PTR [rax*4 + arr]` to access an array element, where `arr` is a displacement
    containing the array’s starting address, `rax` contains the index of the element
    you want to access, and each array element is 4 bytes long. Here, `DWORD PTR`
    tells the assembler that you want to fetch 4 bytes (a doubleword or DWORD) from
    memory. Similarly, one way to access a field in a `struct` is to store the `struct`’s
    starting address in a base register and add the displacement of the field you
    want to access.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内存操作数格式足够灵活，可以以简单直接的方式支持许多常见的代码范式。例如，你可以使用类似`mov eax, DWORD PTR [rax*4 + arr]`的指令来访问数组元素，其中`arr`是包含数组起始地址的位移量，`rax`包含你要访问的元素的索引，每个数组元素占4个字节。这里，`DWORD
    PTR`告诉汇编器你想从内存中获取4个字节（一个双字或DWORD）。类似地，访问`struct`中字段的一种方式是将`struct`的起始地址存储在基址寄存器中，并添加你想访问字段的位移量。
- en: On x86-64, you’re allowed to use `rip` (the instruction pointer) as the base
    in a memory operand, though in that case you can’t use an index register. Compilers
    make frequent use of this possibility for position-independent code and data accesses,
    among other things, so you’ll see lots of `rip`-relative addressing in x86-64
    binaries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86-64上，你可以使用`rip`（指令指针）作为内存操作数中的基址，尽管在这种情况下你不能使用索引寄存器。编译器常常利用这一点来实现位置无关代码和数据访问等功能，因此你会在x86-64二进制文件中看到大量`rip`相对寻址。
- en: '*A.2.5 Immediates*'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.2.5 立即数*'
- en: '*Immediates* are constant integer operands hardcoded in the instruction. For
    example, in the instruction `add rax, 42`, the value 42 is an immediate.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*立即数*是指令中硬编码的常数整数操作数。例如，在指令`add rax, 42`中，值42就是一个立即数。'
- en: On x86, immediates are encoded in little-endian format; the least significant
    byte of a multibyte integer comes first in memory. In other words, if you write
    an assembly-level instruction like `mov ecx, 0x10203040`, the corresponding machine-level
    instruction encodes the immediate with the bytes reversed, as `0x40302010`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86中，立即数以小端格式编码；多字节整数的最低有效字节首先出现在内存中。换句话说，如果你编写类似`mov ecx, 0x10203040`的汇编指令，相应的机器级指令会以字节反转的形式编码立即数，变成`0x40302010`。
- en: To encode signed integers, x86 uses two’s complement notation, which encodes
    a negative value by taking the positive version of that value and then flipping
    all the bits and adding 1 while ignoring overflows. For example, to encode a 4-byte
    integer with the value −1, you take the integer `0x00000001` (the hexadecimal
    representation of 1), flip all the bits to produce `0xfffffffe`, and then add
    1 to yield the final two’s complement representation `0xffffffff`. When you’re
    disassembling code and you see an immediate or memory value that starts with lots
    of `0xff` bytes, you’re often dealing with a negative value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编码有符号整数，x86 使用二进制补码表示法，这种方法通过获取该值的正值，然后翻转所有位并加 1，同时忽略溢出，来表示负数。例如，要编码值为 −1
    的 4 字节整数，首先取整数`0x00000001`（十六进制表示 1），翻转所有位得到`0xfffffffe`，然后加 1 得到最终的二进制补码表示`0xffffffff`。当你在反汇编代码时看到一个立即数或内存值以大量`0xff`字节开头时，通常说明它是一个负值。
- en: Now that you’re familiar with the general format and workings of x86 instructions,
    let’s take a look at the semantics of some of the common instructions you’ll encounter
    in this book and your own binary analysis projects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 x86 指令的基本格式和工作原理，接下来让我们看看一些常见指令的语义，这些指令你将在本书以及自己的二进制分析项目中遇到。
- en: A.3 Common x86 Instructions
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3 常见的 x86 指令
- en: '[Table A-3](appa.xhtml#appatab3) describes common x86 instructions. To learn
    more about an instruction not listed in this table, look it up in an online reference
    such as *[http://ref.x86asm.net/](http://ref.x86asm.net/)* or in the Intel manual
    at *[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*.
    Most of the instructions listed in the table are self-explanatory, but a few deserve
    a more detailed discussion.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 A-3](appa.xhtml#appatab3)描述了常见的 x86 指令。要了解表中未列出的指令，可以在在线参考资料中查找，例如*[http://ref.x86asm.net/](http://ref.x86asm.net/)*，或在
    Intel 手册中查找*[https://software.intel.com/en-us/articles/intel-sdm/](https://software.intel.com/en-us/articles/intel-sdm/)*。表中列出的指令大部分是自解释的，但其中有一些需要更详细的讨论。'
- en: '**Table A-3:** Common x86 Instructions'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 A-3：** 常见的 x86 指令'
- en: '| **Instruction** | **Description** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** |'
- en: '| --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Data transfer** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **数据传输** |'
- en: '| ➊ `mov dst, src` | *dst = src* |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| ➊ `mov dst, src` | *dst = src* |'
- en: '|     `xchg dst1, dst2` | Swap *dst1* and *dst2* |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|   `xchg dst1, dst2` | 交换*dst1*和*dst2* |'
- en: '| ➋ `push src` | Push *src* onto the stack and decrement `rsp` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| ➋ `push src` | 将*src*压入堆栈并递减`rsp` |'
- en: '|     `pop dst` | Pop value from stack into *dst* and increment `rsp` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|   `pop dst` | 从堆栈中弹出值到*dst*并递增`rsp` |'
- en: '| **Arithmetic** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **算术操作** |'
- en: '|     `add dst, src` | *dst += src* |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|   `add dst, src` | *dst += src* |'
- en: '|     `sub dst, src` | *dst –= src* |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|   `sub dst, src` | *dst -= src* |'
- en: '|     `inc dst` | *dst += 1* |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|   `inc dst` | *dst += 1* |'
- en: '|     `dec dst` | *dst –= 1* |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   `dec dst` | *dst -= 1* |'
- en: '|     `neg dst` | *dst = –dst* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|   `neg dst` | *dst = –dst* |'
- en: '| ➌ `cmp src1, src2` | Set status flags based on *src1 – src2* |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| ➌ `cmp src1, src2` | 根据*src1 – src2*设置状态标志 |'
- en: '| **Logical/bitwise** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑/按位操作** |'
- en: '|     `and dst, src` | *dst &= src* |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|   `and dst, src` | *dst &= src* |'
- en: '|     `or dst, src` | *dst &#124;= src* |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|   `or dst, src` | *dst |= src* |'
- en: '|     `xor dst, src` | *dst ^= src* |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|   `xor dst, src` | *dst ^= src* |'
- en: '|     `not dst` | *dst = ~dst* |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|   `not dst` | *dst = ~dst* |'
- en: '| ➍ `test src1, src2` | Set status flags based on *src1 & src2* |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| ➍ `test src1, src2` | 根据*src1 & src2*设置状态标志 |'
- en: '| **Unconditional branches** |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **无条件跳转** |'
- en: '|     `jmp addr` | Jump to address |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|   `jmp addr` | 跳转到地址 |'
- en: '|     `call addr` | Push return address on stack, then call function at address
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|   `call addr` | 将返回地址压入堆栈，然后调用位于地址的函数 |'
- en: '|     `ret` | Pop return address from stack and return to that address |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|   `ret` | 从堆栈中弹出返回地址并返回到该地址 |'
- en: '| ➎ `syscall` | Enter the kernel to perform a system call |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| ➎ `syscall` | 进入内核执行系统调用 |'
- en: '| **Conditional branches (based on status flags)** `jcc addr` jumps to address
    only if condition *cc* holds, else it falls through'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '| **条件跳转（基于状态标志）** `jcc addr` 仅在条件*cc*成立时跳转到地址，否则继续执行 |'
- en: '`jncc` inverts the condition, jumping if it does not hold |'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`jncc` 反转条件，如果条件不成立则跳转 |'
- en: '| ➏ `je addr`/`jz addr` | Jump if zero flag is set (for example, operands were
    equal in last `cmp`) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| ➏ `je addr`/`jz addr` | 如果零标志被设置则跳转（例如，操作数在上次`cmp`中相等） |'
- en: '|     `ja addr` | Jump if *dst > src* (“above”) in last comparison (unsigned)
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|   `ja addr` | 如果*dst > src*（“大于”）在上次比较中（无符号）则跳转 |'
- en: '|     `jb addr` | Jump if *dst < src* (“below”) in last comparison (unsigned)
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|   `jb addr` | 如果*dst < src*（“小于”）在上次比较中（无符号）则跳转 |'
- en: '|     `jg addr` | Jump if *dst > src* (“greater than”) in last comparison (signed)
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|   `jg addr` | 如果*dst > src*（“大于”）在上次比较中（有符号）则跳转 |'
- en: '|     `jl addr` | Jump if *dst < src* (“less than”) in last comparison (signed)
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '|     `jge addr` | Jump if *dst >= src* in last comparison (signed) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '|     `jle addr` | Jump of *dst <= src* in last comparison (signed) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '|     `js addr` | Jump if last comparison set the sign bit (meaning the result
    was negative) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| **Miscellaneous** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| ➐ `lea dst, src` | Load memory address into *dst* (*dst = &src*, where *src*
    must be in memory) `nop` Do nothing (for example for code padding) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: First, it’s worth noting that `mov` ➊ is a bit of a misnomer because it doesn’t
    technically *move* the source operand into the destination. Rather, it copies
    it, leaving the source operand intact. The `push` and `pop` instructions ➋ have
    special significance with regard to stack management and function calls, as you’ll
    see shortly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '*A.3.1 Comparing Operands and Setting Status Flags*'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `cmp` instruction ➌ is important for implementing conditional branches.
    It subtracts the second operand from the first, but instead of storing the outcome
    of that operation somewhere, it sets status flags in the `rflags` register based
    on the outcome. Subsequent conditional branches check these status flags to decide
    whether the branch should be taken. Important flags include the *zero flag (ZF)*,
    the *sign flag (SF)*, and the *overflow flag (OF)*, which indicate whether the
    outcome of the comparison was zero, negative, or resulted in an overflow, respectively.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The `test` instruction ➍ is similar to `cmp`, but it sets status flags based
    on the bitwise AND of its operands, rather than the subtraction. It’s worth noting
    that some other instructions, besides `cmp` and `test`, set status flags as well.
    The Intel manual or online instruction reference show exactly which flags each
    instruction sets.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '*A.3.2 Implementing System Calls*'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To perform a system call, you use the `syscall` instruction ➎. Before using
    it, you have to prepare the system call by selecting its number and setting its
    operands as specified by the operating system. For example, to perform a `read`
    system call on Linux, you load the value 0 (the system call number for `read`)
    into `rax`; then load the file descriptor, buffer address, and number of bytes
    to read into `rdi`, `rsi`, and `rdx`, respectively; and finally execute a `syscall`
    instruction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: To find out how to configure system calls on Linux, refer to `man syscalls`
    or an online reference like *[https://filippo.io/linux-syscall-table/](https://filippo.io/linux-syscall-table/)*.
    Note that on 32-bit x86, you make a system call using `sysenter` or `int 0x80`
    (which triggers a software interrupt for interrupt vector `0x80`) instead of `syscall`.
    Also, system call conventions can differ on operating systems other than Linux.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '*A.3.3 Implementing Conditional Jumps*'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Conditional jump instructions ➏ implement branches by working in unison with
    earlier instructions that set status flags, like `cmp` or `test`. They jump to
    a specified address or label if the given condition holds or fall through to the
    next instruction if the condition does not hold. For example, to jump to a program
    location named *label* if `rax < rbx` (using an unsigned comparison), you typically
    use an instruction sequence like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转指令 ➏ 通过与先前设置状态标志的指令（如`cmp`或`test`）配合工作来实现分支。如果给定的条件成立，它们会跳转到指定的地址或标签；如果条件不成立，则会跳转到下一条指令。例如，若要在`rax
    < rbx`（使用无符号比较）的情况下跳转到名为*label*的程序位置，你通常会使用如下的指令序列：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, to jump to *label* if `rax` is not zero, you can use the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果`rax`不为零，要跳转到*label*，可以使用以下代码：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*A.3.4 Loading Memory Addresses*'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.3.4 加载内存地址*'
- en: Finally, the `lea` instruction ➐ (*load effective address*) computes the address
    resulting from a memory operand (formatted as `[base + index*scale + displacement]`)
    and stores it in a register but does not dereference the address. This is equivalent
    to the address-of operator (`&`) in C/C++. For example, `lea r12, [rip+0x2000]`
    loads the address resulting from the expression `rip+0x2000` into the `r12` register.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`lea`指令 ➐ (*加载有效地址*) 计算内存操作数（格式为`[base + index*scale + displacement]`）产生的地址，并将其存储在一个寄存器中，但不会解引用该地址。这等同于C/C++中的地址运算符（`&`）。例如，`lea
    r12, [rip+0x2000]`将表达式`rip+0x2000`产生的地址加载到`r12`寄存器中。
- en: Now that you’re familiar with the most important x86 instructions, let’s see
    how these instructions come together to implement common C/C**++** code constructs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经熟悉了最重要的x86指令，让我们来看一下这些指令如何结合在一起，实现常见的C/C**++**代码结构。
- en: A.4 Common Code Constructs in Assembly
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4 汇编中的常见代码结构
- en: Compilers like `gcc`, `clang`, and Visual Studio emit common code patterns for
    constructs like function calls, `if`/`else` branches, and loops. You’ll also see
    these same code patterns in handwritten assembly code. It helps to be familiar
    with them so that you can quickly understand what a piece of assembly or disassembled
    code is doing. Let’s take a look at code patterns emitted by `gcc 5.4.0`. Other
    compilers use similar patterns.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 像`gcc`、`clang`和Visual Studio等编译器，会生成一些常见的代码模式，用于实现像函数调用、`if`/`else`分支和循环这样的结构。你也会在手写的汇编代码中看到这些相同的代码模式。熟悉这些代码结构非常有帮助，这样你可以快速理解一段汇编或反汇编代码在做什么。让我们来看一下`gcc
    5.4.0`生成的代码模式。其他编译器使用类似的模式。
- en: The first code construct you’ll see are function calls. But before you can understand
    how function calls are implemented at the assembly level, you need to be familiar
    with how *the stack* works on x86.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先看到的代码结构是函数调用。但在你理解函数调用是如何在汇编层面实现之前，你需要了解*栈*在x86上的工作原理。
- en: '*A.4.1 The Stack*'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*A.4.1 栈*'
- en: The stack is a memory region reserved for storing data related to function calls,
    such as return addresses, function arguments, and local variables. On most operating
    systems, each thread has its own stack.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个保留的内存区域，用于存储与函数调用相关的数据，如返回地址、函数参数和局部变量。在大多数操作系统中，每个线程都有自己的栈。
- en: 'The stack gets its name from the way it’s accessed. Rather than writing values
    at random places in the stack, you do so in a *last-in-first-out (LIFO)* order.
    That is, you can write values by *pushing* them to the top of the stack and remove
    values by *popping* them from the top. This makes sense for function calls because
    it matches the way you invoke and return from functions: the last function you
    call returns first. [Figure A-3](appa.xhtml#appafig3) illustrates the stack access
    pattern.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 栈之所以得名，是因为它的访问方式。你不是在栈的任意位置写入值，而是以*后进先出 (LIFO)* 的顺序进行操作。也就是说，你可以通过*压栈*将值写入栈顶，并通过*弹栈*从栈顶移除值。这与函数调用非常吻合，因为它与函数的调用和返回方式一致：你最后调用的函数首先返回。[图
    A-3](appa.xhtml#appafig3)展示了栈的访问模式。
- en: 'In [Figure A-3](appa.xhtml#appafig3), the stack starts at address `0x7fffffff8000`^([1](footnote.xhtml#appafn_1))
    and initially contains five values: *a*–*e*. The rest of the stack contains uninitialized
    memory (marked with “?”). On x86, the stack grows toward lower memory addresses,
    which means that newly pushed values are at lower addresses than older values.
    The stack pointer register (`rsp`) always points to the top of the stack, where
    the most recently pushed value is. Initially, that’s *e* at address `0x7fffffff7fe0`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f384-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-3: Pushing the value* f *onto the stack and then popping it into*
    `rax`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you push a new value *f*, it ends up at the top of the stack, and
    `rsp` is decremented to point there. There are special instructions on x86 called
    `push` and `pop` that insert or remove a value on the stack and automatically
    update `rsp`. Similarly, the x86 `call` instruction automatically pushes the return
    address onto the stack, and `ret` pops the return address and returns there.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: When you execute a `pop` instruction, it copies the value at the top of the
    stack into the `pop` operand and then increments `rsp` to reflect the new top
    of the stack. For example, the `pop rax` instruction in [Figure A-3](appa.xhtml#appafig3)
    copies *f* from the stack into `rax` and then updates `rsp` to point to *e*, the
    new top of the stack. You can push an arbitrary number of values onto the stack
    before popping anything. Of course, this is subject to the available memory reserved
    for the stack.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Note that popping a value from the stack doesn’t clean it up; it merely copies
    the value and updates `rsp`. After the `pop`, *f* is technically still in memory
    until it’s overwritten by a later `push`. It’s important to realize that if you
    place sensitive information on the stack, it might still be accessible later unless
    you explicitly clean it up.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how the stack works, let’s look at how function calls use
    it to store their arguments, return address, and local variables.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '*A.4.2 Function Calls and Function Frames*'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing A-3](appa.xhtml#appalist3) shows a simple C program that contains
    two function calls, omitting any error-checking code for brevity. First, it calls
    `getenv` to get the value of an environment variable specified in `argv[1]`. Then,
    it prints this value with `printf`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing A-4](appa.xhtml#appalist4) shows the corresponding assembly code,
    obtained by compiling the C program with `gcc 5.4.0` and then disassembling it
    with `objdump`. Note that for this example, I’ve compiled the program with `gcc`’s
    default options, and the output will look different if you enable optimizations
    or use another compiler.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing A-3: Function calls in C*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing A-4: Function calls in assembly*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The compiler stores the string constant `%s=%s` used in the `printf` call separately
    from the code, in the `.rodata` (read-only data) section ➊ at address `0x400634`.
    You’ll see this address used later in the code as a `printf` argument.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将`printf`调用中使用的字符串常量`%s=%s`与代码分开存储，存储在`.rodata`（只读数据）区➊，地址为`0x400634`。你将在代码的后续部分看到这个地址作为`printf`参数使用。
- en: In principle, each function in an x86 Linux program has its own *function frame*
    (also called *stack frame*) on the stack, delimited by `rbp` (the base pointer)
    pointing to the base of that function frame and `rsp` pointing to the top. Function
    frames are used to store the function’s stack-based data. Note that with certain
    optimizations, compilers may omit the base pointer (making all stack accesses
    relative to `rsp`) and use `rbp` as an extra general-purpose register. However,
    the following example assumes that all functions use full function frames.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，x86 Linux程序中的每个函数都有自己的*函数框架*（也叫*栈框架*），它被`rbp`（基指针）指向该函数框架的基址，`rsp`指向栈顶。函数框架用于存储函数的栈数据。请注意，在某些优化下，编译器可能会省略基指针（使得所有栈访问相对于`rsp`进行），并将`rbp`作为一个额外的通用寄存器使用。然而，以下示例假设所有函数都使用完整的函数框架。
- en: '[Figure A-4](appa.xhtml#appafig4) shows the function frames created for `main`
    and `getenv` when you run the program shown in [Listing A-4](appa.xhtml#appalist4).
    To understand how this works, let’s go over the assembly listing and see how it
    produces the function frames shown in the figure.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[图A-4](appa.xhtml#appafig4)显示了当你运行[清单A-4](appa.xhtml#appalist4)中展示的程序时，为`main`和`getenv`创建的函数框架。为了理解这一点，让我们一起查看汇编清单，看看它如何生成图中所示的函数框架。'
- en: '![image](Images/f386-01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f386-01.jpg)'
- en: '*Figure A-4: Example of x86 function frames on a Linux system*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-4：Linux系统上x86函数框架示例*'
- en: As explained in [Chapter 2](ch02.xhtml#ch02), `main` isn’t really the first
    function that runs in a typical Linux program. For now, all you need to know is
    that `main` is invoked by a `call` instruction that places a return address on
    the stack where `main` returns when it’s done (shown at the top left of [Figure
    A-4](appa.xhtml#appafig4)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](ch02.xhtml#ch02)所述，`main`并不是典型Linux程序中首先运行的函数。现在，你只需要知道的是，`main`是通过一个`call`指令被调用的，该指令将返回地址放在栈上，`main`完成时会返回到这个地址（如[图A-4](appa.xhtml#appafig4)左上角所示）。
- en: Function Prologues, Local Variables, and Reading Arguments
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 函数序言、局部变量和读取参数
- en: The first thing `main` does is run a *prologue* that sets up its function frame.
    This prologue starts by saving the contents of the `rbp` register on the stack
    and then copying `rsp` into `rbp` ➋ (see [Listing A-4](appa.xhtml#appalist4)).
    This has the effect of saving the start address of the previous function frame
    and creating a fresh function frame at the top of the stack. Because the instruction
    sequence `push rbp; mov rbp,rsp` is so common, x86 has a shorthand instruction
    called `enter` (not used in [Listing A-4](appa.xhtml#appalist4)) that does the
    same thing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`做的第一件事是执行一个*序言*，设置它的函数框架。这个序言首先将`rbp`寄存器的内容保存在栈上，然后将`rsp`的值复制到`rbp`中➋（参见[清单A-4](appa.xhtml#appalist4)）。这样做的效果是保存了上一个函数框架的起始地址，并在栈顶创建了一个新的函数框架。由于`push
    rbp; mov rbp,rsp`指令序列非常常见，x86有一条叫做`enter`的简写指令（在[清单A-4](appa.xhtml#appalist4)中没有使用），它实现了相同的功能。'
- en: On x86-64 Linux, the registers `rbx` and `r12`–`r15` are guaranteed not to be
    polluted by any functions you call. That means that if a function does pollute
    these registers, it must take care to restore them to their original values before
    returning. Typically, functions achieve that by pushing any registers that need
    to be saved onto the stack just after the saved base pointer and popping them
    back off just before returning. In [Listing A-4](appa.xhtml#appalist4), `main`
    doesn’t do this because it doesn’t use any of the registers in question.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86-64 Linux中，`rbx`寄存器和`r12`–`r15`寄存器保证不会被你调用的任何函数污染。这意味着，如果一个函数确实污染了这些寄存器，它必须在返回之前恢复它们的原始值。通常，函数通过将需要保存的寄存器压入栈中（紧接着保存的基指针），并在返回之前将它们弹出栈来实现这一点。在[清单A-4](appa.xhtml#appalist4)中，`main`没有这样做，因为它没有使用这些寄存器。
- en: 'After setting up a basic function frame, `main` decrements `rsp` by `0x10`
    bytes to reserve room for two 8-byte local variables on the stack ➌. Even though
    the C version of the program doesn’t explicitly reserve any local variables, `gcc`
    generated them automatically to serve as temporary storage for `argc` and `argv`.
    On x86-64 Linux systems, the first six arguments to a function are passed in `rdi`,
    `rsi`, `rdx`, `rcx`, `r8`, and `r9`, respectively.^([2](footnote.xhtml#appafn_2))
    If there are more than six arguments or some arguments don’t fit in a 64-bit register,
    the remaining arguments are pushed onto the stack in reverse order (compared to
    the order they appear in the argument list), as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that some popular 32-bit x86 calling conventions (such as cdecl) pass all
    arguments on the stack in reverse order (without using any registers), while other
    calling conventions (such as fastcall) pass some arguments in registers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: After reserving room on the stack, `main` copies `argc` (stored in `rdi`) into
    one of the local variables and `argv` (stored in `rsi`) into the other ➍. The
    left side of [Figure A-4](appa.xhtml#appafig4) shows the layout of the stack after
    `main`’s prologue is done.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The Red Zone
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You may notice the 128-byte “red zone” at the top of the stack in [Figure A-4](appa.xhtml#appafig4).
    On x86-64, functions are allowed to use the red zone as scratch space with the
    guarantee that the operating system won’t touch it (for instance, if a signal
    handler needs to set up a new function frame). Subsequently called functions do
    overwrite the red zone as part of their own function frame, so the red zone is
    most useful for so-called *leaf functions* that don’t call any other functions.
    As long as leaf functions don’t use more than 128 bytes of stack space, the red
    zone frees these functions from having to explicitly set up a function frame,
    thereby reducing execution time. On 32-bit x86, there’s no concept of a red zone.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Preparing Arguments and Calling a Function
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After the prologue, `main` loads `argv[1]` into `rax` by first loading the address
    of `argv[0]` and then adding 8 bytes (the size of a pointer) and dereferencing
    the resulting pointer to `argv[1]`. It copies this pointer into `rdi` to serve
    as the argument for `getenv` ➎ and then calls `getenv` ➏ (see [Listing A-4](appa.xhtml#appalist4)).
    The `call` instruction automatically pushes the return address (the address of
    the instruction right after the `call`) onto the stack, where `getenv` can find
    it when it returns. I won’t go into details on `getenv`’s code here since it’s
    a library function. Let’s simply assume that it sets up a standard function frame
    by saving `rbp`, possibly saving some registers and reserving room for local variables.
    The center part of [Figure A-4](appa.xhtml#appafig4) shows the stack layout after
    `getenv` is called and has completed its prologue, assuming that it didn’t push
    any registers to save.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: After `getenv` completes, it saves its return value in `rax` (the standard register
    designated for that purpose) and then cleans up its local variables from the stack
    by incrementing `rsp`. It then pops the saved base pointer from the stack into
    `rbp`, restoring `main`’s function frame. At this point, the top of the stack
    is the saved return address, which is `0x400588` in `main` in this case. Finally,
    `getenv` executes a `ret` instruction that pops the return address from the stack
    and returns there, restoring control to `main`. The right side of [Figure A-4](appa.xhtml#appafig4)
    shows the stack layout just after `getenv` returns.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Reading Return Values
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `main` function copies the return value (a pointer to the requested environment
    string) into `rdx` to serve as the third argument of the `printf` call ➐. Next,
    `main` loads `argv[1]` again in the same way as before and stores it in `rsi`
    as the second argument for `printf` ➑. The first argument (in `rdi`) is the address
    `0x400634` of the format string `%s=%s` in the `.rodata` section you saw earlier.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Note that unlike the call to `getenv`, `main` sets `rax` to zero before calling
    `printf`. That’s because `printf` is a variadic function, which assumes that `rax`
    specifies the number of floating-point arguments passed in via vector registers
    (in this case there are none). After preparing the arguments, `main` calls `printf`
    ➒, pushing the return address for `printf`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Returning from a Function
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: After `printf` completes, `main` prepares its own return value (the exit status)
    by zeroing out the `rax` register ➓. Then, it executes a `leave` instruction,
    which is x86’s shorthand instruction for `mov rsp,rbp; pop rbp`. This is a standard
    function epilogue that does the opposite of the prologue. It cleans up the function
    frame by pointing `rsp` to the frame base (where the saved `rbp` is) and restoring
    the previous frame’s `rbp`. Finally, `main` executes a `ret` instruction, which
    pops the saved return address from the top of the stack and returns there, ending
    `main` and passing control back to whatever function called `main`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*A.4.3 Conditional Branches*'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at another important construct: conditional branches.
    [Listing A-5](appa.xhtml#appalist5) shows a C program containing an `if`/`else`
    branch that prints the message `argc > 5` if `argc` is greater than 5 or the message
    `argc <= 5` otherwise. [Listing A-6](appa.xhtml#appalist6) shows the corresponding
    assembly-level implementation produced by `gcc 5.4.0` with default options, as
    recovered from the binary with `objdump`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing A-5: A conditional branch in C*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing A-6: A conditional branch in assembly*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just like you saw in [Section A.4.2](appa.xhtml#appa_4_2), the compiler stored
    the `printf` format strings in the `.rodata` section ➊➋, away from the code, which
    is in the `.text` section. The `main` function starts with a prologue and copies
    `argc` and `argv` into local variables.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The conditional branch implementation starts with the `cmp` instruction at ➌,
    which compares the local variable containing `argc` to the immediate value `0x5`.
    It’s followed by a `jle` instruction that jumps to address `0x400547` if `argc`
    is less than or equal to `0x5` ➍ (the `else` branch). At that address, there’s
    a call to `puts` that prints the string `argc <= 5`, followed by `main`’s epilogue
    and `ret` instruction.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: If `argc` is greater than `0x5`, the `jle` is not taken but falls through to
    the next instruction sequence at address `0x40053b` (the `if` branch). It calls
    `puts` to print the string `argc > 5` and then jumps to `main`’s epilogue at address
    `0x400551` ➎. Note that this last `jmp` is necessary to jump over the code for
    the `else` branch at address `0x400547`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '*A.4.4 Loops*'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the assembly level, you can think of loops as special cases of conditional
    branches. Just like regular branches, loops are implemented with `cmp`/`test`
    and conditional jump instructions. [Listing A-7](appa.xhtml#appalist7) shows a
    `while` loop in C that loops over all given command line arguments and prints
    them in reverse order. [Listing A-8](appa.xhtml#appalist8) shows a corresponding
    assembly program.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing A-7: A* while *loop in C*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing A-8: A* while *loop in assembly*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, the compiler chose to place the code that checks the loop condition
    at the end of the loop. So, the loop begins by jumping to address `0x40055a` where
    the loop condition is checked ➊.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: This check is implemented with a `cmp` instruction that compares `argc` to the
    value zero ➋. If `argc` is greater than zero, the code jumps to address `0x400537`
    where the loop body begins ➌. The loop body decrements `argc`, prints the next
    string from `argv`, and then ends up at the loop condition check again.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The loop continues until `argc` is zero, at which point the `jg` instruction
    in the loop condition check falls through into `main`’s epilogue, where `main`
    cleans up its stack frame and returns.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
