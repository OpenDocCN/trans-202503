- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CONTROL FLOW
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s do a quick recap. In [Chapter 3](ch03.xhtml#ch3), you learned how to
    combine commands by using the pipeline and external scripts. In [Chapter 2](ch02.xhtml#ch2),
    you learned how to use variables to store values. One of the major benefits of
    working with variables is they allow you to write code that deals with what a
    value means: instead of working with the number 3, for example, you’ll work with
    the more general `$serverCount`, so you can write code that runs the same whether
    you have one, or two, or a thousand servers. Combine this ability to write general
    solutions with the ability to store your code in a script that you can run on
    many computers, and you can start solving problems at a much bigger scale.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But in the real world, sometimes it matters whether you’re working with one
    server, or two servers, or a thousand. Right now, you don’t have a good way to
    account for that: your scripts run in one direction—top to bottom—and they don’t
    have any way of changing based on the specific values you’re working with. In
    this chapter, you’ll use control flow and conditional logic to write scripts that
    execute different sequences of instructions based on the values they’re working
    with. By the end of the chapter, you’ll know how to use `if/then` statements,
    `switch` statements, and all manner of loops to give your code some much-needed
    flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Control Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re going to write a script that reads the contents of a file stored in various
    remote computers. To follow along, download a file called *App_configuration.txt*
    from the book’s resources at [*https://github.com/adbertram/PowerShellForSysadmins/*](https://github.com/adbertram/PowerShellForSysadmins/)
    and place it in the root of the *C:\* drive of a few remote computers. (If you
    don’t have access to remote servers, just follow along in the text for now.) In
    this example, I’ll be using servers with the names `SRV1`, `SRV2`, `SRV3`, `SRV4`,
    and `SRV5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the file’s contents, you’ll use the `Get-Content` command and provide
    the path to the file as the argument to the `Path` parameter, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As a first attempt, let’s store all our server names in an array, and run this
    command for every server in the array. Open a new *.ps1* file and enter the code
    in [Listing 4-1](ch04.xhtml#ch4list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Getting the contents of a file on multiple servers*'
  prefs: []
  type: TYPE_NORMAL
- en: In theory, this code will run with no problems. But this example assumes that
    everything in your environment is pristine. What if `SRV2` is down? What if someone
    forgot to move *App_configuration.txt* onto `SRV4`? Or used a different file path?
    You could write a different script for each server, but that solution won’t scale—especially
    as you start to add more and more servers. What you need is code that can execute
    differently depending on what it encounters.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the basic idea behind *control flow*, the ability to have your code execute
    different sequences of instructions depending on predetermined logic. You can
    think of your scripts as executing along a certain path. Right now, that path
    goes straight from the first line of code to the last one, but you can use control
    flow statements to add forks in the road, circle back to places you’ve already
    been, or take you over lines. By introducing different paths for your script to
    run along, you allow for much greater flexibility, enabling you to write a single
    script that can handle many situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll start by looking at the most basic type of control flow: the conditional
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Conditional Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.xhtml#ch2), you learned about the concept of a boolean:
    a true or false value. You use booleans to build *conditional statements*, which
    tell PowerShell to execute a certain code block based on whether an expression
    (called a *condition*) evaluates to `True` or `False`. A condition is a yes/no
    question: Do you have more than five servers? Is server 3 up? Does this file path
    exist? To start using conditional statements, let’s see how to translate these
    kinds of questions into expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Building Expressions by Using Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can write expressions by using *comparison operators*, which compare values.
    To use a comparison operator, you put it between two values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the `–eq` operator to determine whether two values are equal. Here’s
    a list of the most common comparison operators you’ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-eq** Compares two values and returns `True` if they are equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-ne** Compares two values and returns `True` if they are not equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-gt** Compares two values and returns `True` if the first is greater than
    the second.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-ge** Compares two values and returns `True` if the first is greater than
    or equal to the second.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-lt** Compares two values and returns `True` if the first is less than the
    second.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-le** Compares two values and returns `True` if the first is less than or
    equal to the second.'
  prefs: []
  type: TYPE_NORMAL
- en: '**-contains** Returns `True` if the second value is “in” the first. You can
    use this to determine whether a value is inside an array.'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell offers more advanced comparison operators. I won’t go into them now,
    but I encourage you to read about them in the Microsoft documentation at [*https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators*](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators)*/*,
    or in the PowerShell help (see [Chapter 1](ch01.xhtml#ch1)).
  prefs: []
  type: TYPE_NORMAL
- en: You can use the preceding operators to compare variables and values. But an
    expression doesn’t have to be a comparison. Sometimes PowerShell commands can
    be used as conditions. In the previous example, you wanted to know whether a server
    was online. You can test to see whether a server can be pinged by using the `Test-Connection`
    cmdlet. Normally, the output of `Test-Connection` returns an object full of information,
    but by using the `Quiet` parameter, you can force the command to return a simple
    `True` or `False` and limit the test to a single attempt via the `Count` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to know whether the server was offline, you could use the `–not`
    operator to convert the expression to its opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve seen the basics of expressions, let’s look at the simplest conditional
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `if` statement is straightforward: if *X* is true, then do *Y*. That’s
    it!'
  prefs: []
  type: TYPE_NORMAL
- en: To write an `if` statement, you begin with an `if` keyword followed by parentheses
    containing a condition. After the expression comes a code block, demarcated in
    curly brackets. PowerShell will execute that code block only when the expression
    evaluates to `True`. If the `if` expression evaluates to `False` or returns nothing
    at all, the code block is skipped. You can see the basic syntax of an `if/then`
    statement in [Listing 4-2](ch04.xhtml#ch4list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-2: The syntax of an if statement*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses a bit of new syntax: the hash mark (`#`) signals a *comment*,
    which is text PowerShell will ignore. You can use comments to leave yourself,
    or anyone else reading your code, helpful notes and descriptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a second look at the code in [Listing 4-1](ch04.xhtml#ch4list1)
    and see how to use an `if` statement to make sure you don’t try to access a server
    that’s not up. In the preceding section, you saw how `Test-Connection` can be
    used as an expression that returns `True` or `False`, so let’s wrap a `Test-Connection`
    command in an `if` statement and then use `Get-Content` in the following code
    block to avoid accessing a server that’s down. For now, you’ll change the code
    for only the first server, as in [Listing 4-3](ch04.xhtml#ch4list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-3: Using an if statement to selectively get server content*'
  prefs: []
  type: TYPE_NORMAL
- en: Because you have `Get-Content` in an `if` statement, you won’t run into any
    errors if you try to access a dead server; if the test fails, your script will
    know not to attempt to read the file. You’ll try to access the server only if
    you *already* know it’s up. But notice that this code handles only the case in
    which the condition is true. Often enough, you’ll want to have one behavior if
    a condition is true and another behavior if it’s false. In the next section, you’ll
    see how to specify behavior for a false condition by using the `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The else Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To add an alternate behavior to your `if` statement, you use the `else` keyword
    after the closing parenthesis of your `if` block, followed by another pair of
    curly brackets containing a code block. As shown in [Listing 4-4](ch04.xhtml#ch4list4),
    use an `else` statement to return an error to the console when the first server
    isn’t responding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-4: Using the else statement to run code if the condition is not
    true*'
  prefs: []
  type: TYPE_NORMAL
- en: The `if/else` statement works perfectly when you have two mutually exclusive
    situations. Here, the server is either online or it’s not; you need only two branches
    of code. Let’s look at how to handle more complex situations.
  prefs: []
  type: TYPE_NORMAL
- en: The elseif Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `else` statement works like a catchall: if the first `if` fails, do this
    no matter what. For a binary condition, such as a server being up or down, this
    works well. But sometimes you’ll need to account for even more variability. For
    example, let’s say you have a server that you know doesn’t have the file you want
    to get, and you’ve stored the name of that server in the variable `$problemServer`
    (add this line of code to the script on your own!). This means you need an extra
    check to see whether the server you’re dealing with is the problem server. You
    could account for this statement by using a nested `if`, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But a cleaner way to write this same logic is to use an `elseif` statement,
    which lets you add an extra condition to check before falling back on the code
    in the `else` block. The syntax of an `elseif` block is identical to that of an
    `if` block. So, to check for the problem server by using `elseif` statements,
    try the code in [Listing 4-5](ch04.xhtml#ch4list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-5: Using an elseif block*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you haven’t just added an `elseif`; you’ve also changed the logic.
    Now you check to see whether the server is offline by first using the `–not` operator
    ❶. Then, once you’ve determined whether the server is online, you check to see
    whether it’s a problem server ❷. If it’s not, you use the `else` statement to
    run the default behavior—getting the file ❸. As you can see, there are multiple
    ways to structure code like this. What matters is that the code works and is readable
    to someone seeing it with fresh eyes, whether that’s a coworker reading it for
    the first time, or you looking back at a script you wrote a while ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can chain together as many `elseif` statements as you like, which allows
    you to account for many scenarios. However, `elseif` statements are mutually exclusive:
    when one `elseif` evaluates to `True`, PowerShell will run only the code in its
    block and will not test the rest of the cases. In [Listing 4-5](ch04.xhtml#ch4list5),
    this didn’t cause any issues, as you needed to test only whether you were working
    with the problem server after you had checked that it was up, but it’s something
    to keep in mind moving forward.'
  prefs: []
  type: TYPE_NORMAL
- en: The `if`, `else`, and `elseif` statements are great for handling simple yes/no
    questions. In the next section, you’ll learn how to handle slightly more complicated
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: The switch Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s tweak our example a bit. Say you have five servers, and *each* server
    has the file in a different path. Based on what you know now, you’d need to write
    a separate `elseif` statement for each individual server. This would work, but
    there’s a cleaner method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that now you’re working with a different kind of condition. Whereas
    before you wanted the answers to yes/no questions, here you want to know the specific
    value of one thing: Is the server `SRV1`? Is it `SRV2`? And so forth. If you were
    working with only one or two specific values, an `if` would do, but in this case,
    using a `switch` statement would be cleaner.'
  prefs: []
  type: TYPE_NORMAL
- en: A `switch` statement allows you to execute various pieces of code based on a
    value. It consists of the `switch` keyword followed by an expression in parentheses.
    Inside the `switch` block are a series of statements that have a value, followed
    by a set of curly brackets containing a code block, and eventually a `default`
    block, as in [Listing 4-6](ch04.xhtml#ch4list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-6: Template for a switch statement*'
  prefs: []
  type: TYPE_NORMAL
- en: A `switch` statement can contain an (almost) unlimited number of values. If
    the expression evaluates to a value, the code inside that value’s block is executed.
    Critically, unlike with `elseif`, after one code block runs, PowerShell will continue
    to evaluate the other conditions unless otherwise specified. If none of the values
    match the evaluated value, PowerShell executes the code embedded under the `default`
    keyword. To force PowerShell to stop evaluating conditions in the `switch` statement,
    use the `break` keyword at the end of the code block, as in [Listing 4-7](ch04.xhtml#ch4list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-7: Using the break keyword in a switch statement*'
  prefs: []
  type: TYPE_NORMAL
- en: The `break` keyword can be used to make your `switch` conditions mutually exclusive.
    Let’s go back to our example of five servers with the same file at different paths.
    You know that the server you’re working with can have only one value (it can’t
    be both `SRV1` and `SRV2`), so you have to use `break` statements. Your script
    should look something like [Listing 4-8](ch04.xhtml#ch4list8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-8: Checking various servers by using a switch statement*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could rewrite this code by using only `if` and `elseif` statements (and
    I encourage you to try!). But however you choose to write it, you’ll have to repeat
    the same structure for each server in your list, meaning that your script is going
    to get pretty long—and just think about if you wanted to test 500 servers instead
    of 5\. In the next section, you’ll learn how to spare yourself that trouble by
    using one of the most fundamental control flow structures: the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A good rule of thumb for computer work: Don’t Repeat Yourself (DRY). If you
    find yourself doing the same thing more than once, chances are there’s a way to
    automate it. The same is true of writing code: if you’re using the same lines
    of code over and over, there’s probably a better solution.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to avoid repetitive code is to use loops. A *loop* lets you execute
    code repeatedly until a condition changes. The *stop condition* can be used to
    run a loop a set number of times, or until a boolean value has changed, or even
    to have a loop run infinitely. We call each run of the loop an *iteration*.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell offers five types of loops: `foreach`, `for`, `do/while`, `do/until`,
    and `while`. This section explains each type of loop, noting what makes it unique,
    and highlighting the best situations to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: The foreach Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start with the type of loop you’ll probably use the most in PowerShell,
    the `foreach` loop. A `foreach` loop goes through a list of objects and performs
    the same action for every object, ending when it’s finished with the last one.
    This list of objects is typically represented by an array. When you run a loop
    over a list of objects, we say you’re *iterating* over the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `foreach` loop is useful when you have to perform the same task on a lot
    of different, but related, objects. Let’s go back to [Listing 4-1](ch04.xhtml#ch4list1)
    (reproduced here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You’re going to ignore all the fancy logic you added in the preceding section
    for now and put this into a `foreach` loop. But unlike other loops in PowerShell,
    the `foreach` loop can be used in three ways: as a `foreach` statement, as a `ForEach-Object`
    cmdlet, or as a `foreach()` method. Although each is similar to use, you should
    understand the differences. In the following three sections, you’ll rewrite [Listing
    4-1](ch04.xhtml#ch4list1) by using each type of `foreach` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: The foreach Statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first type of `foreach` you’ll look at is the `foreach` statement. [Listing
    4-9](ch04.xhtml#ch4list9) has the loop version of [Listing 4-1](ch04.xhtml#ch4list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-9: Using a foreach statement*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `foreach` statement is followed by parentheses that contain
    three elements, in order: a variable, the keyword `in`, and the object or array
    to iterate over. The variable you provide can have any name, but I recommend keeping
    the name as descriptive as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it moves through the list, PowerShell will *copy* the object it’s looking
    at into the variable. Note that because the variable is just a copy, you cannot
    directly change the item in the original list. To test this, try running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Nothing changed! This is because you’re modifying only a copy of the original
    variable in the array. This is one of the downsides of using a `foreach` loop
    (of any kind). To directly modify the original contents of the list you’re looping
    through, you have to use one of the other loop types.
  prefs: []
  type: TYPE_NORMAL
- en: The ForEach-Object cmdlet
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Like the `foreach` statement, the `ForEach-Object` cmdlet can iterate over a
    set of objects and perform an action. But because `ForEach-Object` is a cmdlet,
    you have to pass that set of objects and the action to complete as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Check out [Listing 4-10](ch04.xhtml#ch4list10) to see how you’d do the same
    thing as [Listing 4-9](ch04.xhtml#ch4list9) with the `ForEach-Object` cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-10: Using the ForEach-Object cmdlet*'
  prefs: []
  type: TYPE_NORMAL
- en: A bit is different here, so let’s walk through it. Notice that the `ForEach-Object`
    cmdlet takes an `InputObject` parameter. In this case, you’re using the `$servers`
    array, but you could use any object, such as a string or integer. In those cases,
    PowerShell will simply perform a single iteration. The cmdlet also accepts a `Process`
    parameter, which should be a scriptblock containing the code you’d like to run
    for each element inside the input object. (A *scriptblock* is a collection of
    statements that you pass into a cmdlet as a single unit.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed something else strange about [Listing 4-10](ch04.xhtml#ch4list10).
    Instead of using a `$server` variable, as you did with the `foreach` statement,
    you use the syntax `$_`. This special syntax represents the current object in
    the pipeline. The major difference between the `foreach` statement and the `ForEach-Object`
    cmdlet is that the cmdlet accepts pipeline input. In practice, `ForEach-Object`
    is almost always used by passing in the `InputObject` parameter through the pipeline,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `ForEach-Object` cmdlet can be a major time-saver.
  prefs: []
  type: TYPE_NORMAL
- en: The foreach() Method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The final type of `foreach` loop you’ll look at is the `foreach()` object method,
    introduced in PowerShell V4\. The `foreach()` method exists on all arrays in PowerShell,
    and can be used to accomplish the same thing as `foreach` and `ForEach-Object`.
    The `foreach()` method accepts a scriptblock parameter that should contain the
    code to execute each iteration. As with `ForEach-Object`, you use `$_` to capture
    the current iteration’s object, as you can see in [Listing 4-11](ch04.xhtml#ch4list11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-11: Using the foreach() method*'
  prefs: []
  type: TYPE_NORMAL
- en: The `foreach()` method is considerably faster than the other two, and noticeably
    so when processing large datasets. I recommend that you use this method over the
    other two wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: A `foreach` loop is great when you want to perform a task on an object-by-object
    basis. But say you want to do something simpler. What if you wanted to execute
    a task a certain number of times?
  prefs: []
  type: TYPE_NORMAL
- en: The for Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To execute code a predetermined number of times, you use a `for` loop. [Listing
    4-12](ch04.xhtml#ch4list12) shows the syntax for a basic `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-12: A simple for loop*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `for` loop consists of four pieces: the *iteration variable* declaration
    ❶, the condition to continue running the loop ❷, the action to perform on the
    iteration variable after each successful loop ❸, and the code you want to execute
    ❹. In this example, you start the loop by initializing the variable `$i` to 0\.
    Then, you check to see whether `$i` is less than 10; if it is, you execute the
    code in the curly brackets, which prints `$ix`. After the code has executed, you
    increment `$i` by 1 ❸ and then check whether it is still smaller than 10 ❷. You
    repeat this process until `$i` is no longer less than 10, resulting in 10 iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `for` loop can be used like this to execute a task any number of times—simply
    replace the condition ❷ to fit your needs. But the `for` loop has many more uses.
    One of the most powerful is manipulating the elements in an array. Earlier, you
    saw how you *couldn’t* use a `foreach` loop to change the elements in your array.
    Let’s try again, using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Try running this script. The server names should change.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `for` loop is also particularly useful when performing an action that requires
    multiple elements in the array. For instance, let’s say that your `$servers` array
    is arranged in a particular order, and you want to know which server comes after
    which. To do this, you could use a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this time you declare the iteration variable to start at 1 ❶. This
    ensures that you don’t try to access the server that comes before the first one,
    which would give you an error.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see over the course of this book, the `for` loop is a powerful tool
    that has many uses outside the simple examples provided here. For now, let’s move
    on to the next type of loop.
  prefs: []
  type: TYPE_NORMAL
- en: The while Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `while` loop is the simplest loop: while a condition is true, do something.
    To get a sense of the `while` loop syntax, let’s rewrite the `for` loop from [Listing
    4-12](ch04.xhtml#ch4list12) as shown in [Listing 4-13](ch04.xhtml#ch4list13).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-13: A simple counter using a while loop*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, to use a `while` loop, just place the condition you want to
    evaluate inside the parentheses, and the code you want to run inside the curly
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop is best used when the number of iterations for the loop is
    *not* predetermined. Say you have a Windows server (again called `$problemServer`)
    that’s frequently going down. But there’s a file you need on it, and you don’t
    want to sit there testing the server every few minutes to get it. You can use
    a `while` loop to automate this process for you, as in [Listing 4-14](ch04.xhtml#ch4list14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-14: Using a while loop to deal with a problematic server*'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a `while` loop instead of an `if`, you can repeatedly check to see
    whether the service is up. Then, once you get the content you need, you can `break`
    out of the loop to make sure you don’t continue to check the server. The `break`
    keyword can be used in any loop to stop the loop from running. This is especially
    important when using one of the most common `while` loops: the `while($true)`
    loop. By using `$true` as your condition, your `while` loop will run forever unless
    you stop it with a `break` or keyboard input.'
  prefs: []
  type: TYPE_NORMAL
- en: The do/while and do/until Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Similar to the `while` loop are the `do/while` and `do/until` loops. The two
    are essentially inverses: the `do/while` loop does something *while* a condition
    is true, and the `do/until` loop does something *until* a condition is true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An empty `do/while` loop looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `do` code comes before the `while` condition. The major
    difference between a `while` loop and a `do/while` loop is that a `do/while` loop
    will execute the code *before* the condition is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be useful in certain situations, particularly when you are continually
    receiving input from a source and want to evaluate it. For example, say you want
    to prompt the user to ask them for the best programming language. To do so, you
    could use the code in [Listing 4-15](ch04.xhtml#ch4list15). Here, you’ll use the
    `do/until` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-15: Using a do/until loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The `do/while` and `do/until` loops are *very* similar. Often this means you
    can accomplish the same thing using each loop simply by inverting the condition,
    as you’ve done here.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We covered a lot in this chapter. You learned about control flow, and how to
    use conditional logic to introduce alternative paths through your code. You saw
    various types of control flow statements, including the `if` statement, `switch`
    statement, and `foreach`, `for`, and `while` loops. Finally, you gained some hands-on
    experience, using PowerShell to check whether servers are up and to access files
    on them.
  prefs: []
  type: TYPE_NORMAL
- en: You can use conditional logic to handle some errors, but chances are you’ll
    miss something. In [Chapter 5](ch05.xhtml#ch5), you’ll take a closer look at errors
    and some techniques you can use to handle them.
  prefs: []
  type: TYPE_NORMAL
