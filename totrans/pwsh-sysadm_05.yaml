- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: CONTROL FLOW
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流
- en: '![Images](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Images](../images/common.jpg)'
- en: 'Let’s do a quick recap. In [Chapter 3](ch03.xhtml#ch3), you learned how to
    combine commands by using the pipeline and external scripts. In [Chapter 2](ch02.xhtml#ch2),
    you learned how to use variables to store values. One of the major benefits of
    working with variables is they allow you to write code that deals with what a
    value means: instead of working with the number 3, for example, you’ll work with
    the more general `$serverCount`, so you can write code that runs the same whether
    you have one, or two, or a thousand servers. Combine this ability to write general
    solutions with the ability to store your code in a script that you can run on
    many computers, and you can start solving problems at a much bigger scale.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下。在[第3章](ch03.xhtml#ch3)中，你学习了如何通过使用管道和外部脚本来组合命令。在[第2章](ch02.xhtml#ch2)中，你学习了如何使用变量来存储值。使用变量的一个主要好处是，它们让你能够编写处理值意义的代码：例如，不是直接处理数字3，而是处理更通用的`$serverCount`，这样你就可以编写出无论有一台、两台还是一千台服务器都能运行的代码。将这种编写通用解决方案的能力与将代码存储在脚本中的能力相结合，使你能够在多台计算机上运行，从而开始解决更大规模的问题。
- en: 'But in the real world, sometimes it matters whether you’re working with one
    server, or two servers, or a thousand. Right now, you don’t have a good way to
    account for that: your scripts run in one direction—top to bottom—and they don’t
    have any way of changing based on the specific values you’re working with. In
    this chapter, you’ll use control flow and conditional logic to write scripts that
    execute different sequences of instructions based on the values they’re working
    with. By the end of the chapter, you’ll know how to use `if/then` statements,
    `switch` statements, and all manner of loops to give your code some much-needed
    flexibility.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在现实世界中，有时候是否使用一台服务器、两台服务器或一千台服务器是很重要的。现在，你没有一个很好的方式来处理这个问题：你的脚本是单向执行的——从上到下——并且它们没有办法根据你正在处理的具体值进行改变。在本章中，你将使用控制流和条件逻辑来编写根据所处理的值执行不同指令序列的脚本。到本章结束时，你将学会如何使用`if/then`语句、`switch`语句以及各种循环语句，为你的代码提供所需的灵活性。
- en: Understanding Control Flow
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解控制流
- en: You’re going to write a script that reads the contents of a file stored in various
    remote computers. To follow along, download a file called *App_configuration.txt*
    from the book’s resources at [*https://github.com/adbertram/PowerShellForSysadmins/*](https://github.com/adbertram/PowerShellForSysadmins/)
    and place it in the root of the *C:\* drive of a few remote computers. (If you
    don’t have access to remote servers, just follow along in the text for now.) In
    this example, I’ll be using servers with the names `SRV1`, `SRV2`, `SRV3`, `SRV4`,
    and `SRV5`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写一个脚本，用来读取存储在多台远程计算机中的文件内容。为了跟上步骤，请从本书的资源下载一个名为*App_configuration.txt*的文件，网址是[*https://github.com/adbertram/PowerShellForSysadmins/*](https://github.com/adbertram/PowerShellForSysadmins/)，并将其放置在几台远程计算机的*C:\*驱动器根目录下。（如果你没有远程服务器的访问权限，现在可以仅通过文本跟随。）在这个示例中，我将使用名为`SRV1`、`SRV2`、`SRV3`、`SRV4`和`SRV5`的服务器。
- en: 'To access the file’s contents, you’ll use the `Get-Content` command and provide
    the path to the file as the argument to the `Path` parameter, as shown here:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问文件内容，你将使用`Get-Content`命令，并将文件的路径作为`Path`参数的参数提供，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As a first attempt, let’s store all our server names in an array, and run this
    command for every server in the array. Open a new *.ps1* file and enter the code
    in [Listing 4-1](ch04.xhtml#ch4list1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一次尝试，让我们把所有的服务器名称存储在一个数组中，并对数组中的每台服务器运行此命令。打开一个新的*.ps1*文件，并在[Listing 4-1](ch04.xhtml#ch4list1)中输入代码。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 4-1: Getting the contents of a file on multiple servers*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-1：获取多台服务器上文件的内容*'
- en: In theory, this code will run with no problems. But this example assumes that
    everything in your environment is pristine. What if `SRV2` is down? What if someone
    forgot to move *App_configuration.txt* onto `SRV4`? Or used a different file path?
    You could write a different script for each server, but that solution won’t scale—especially
    as you start to add more and more servers. What you need is code that can execute
    differently depending on what it encounters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，这段代码应该没有问题。但是这个示例假设你的环境中一切都很完美。如果`SRV2`宕机了怎么办？如果有人忘了把*App_configuration.txt*文件移动到`SRV4`上呢？或者用了不同的文件路径？你可以为每台服务器编写不同的脚本，但这种解决方案无法扩展——尤其是在你开始添加越来越多的服务器时。你需要的是可以根据遇到的情况执行不同的代码。
- en: That’s the basic idea behind *control flow*, the ability to have your code execute
    different sequences of instructions depending on predetermined logic. You can
    think of your scripts as executing along a certain path. Right now, that path
    goes straight from the first line of code to the last one, but you can use control
    flow statements to add forks in the road, circle back to places you’ve already
    been, or take you over lines. By introducing different paths for your script to
    run along, you allow for much greater flexibility, enabling you to write a single
    script that can handle many situations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是*控制流*的基本概念，即根据预定的逻辑，让你的代码执行不同的指令序列。你可以将脚本看作沿着某一特定路径执行。目前，这条路径从代码的第一行直接走到最后一行，但你可以使用控制流语句在道路上增加分支、回到已经走过的地方，或者跳过某些行。通过为脚本引入不同的执行路径，你可以让脚本更加灵活，从而编写一个能够应对多种情况的脚本。
- en: 'You’ll start by looking at the most basic type of control flow: the conditional
    statement.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从最基本的控制流类型开始：条件语句。
- en: Using Conditional Statements
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: 'In [Chapter 2](ch02.xhtml#ch2), you learned about the concept of a boolean:
    a true or false value. You use booleans to build *conditional statements*, which
    tell PowerShell to execute a certain code block based on whether an expression
    (called a *condition*) evaluates to `True` or `False`. A condition is a yes/no
    question: Do you have more than five servers? Is server 3 up? Does this file path
    exist? To start using conditional statements, let’s see how to translate these
    kinds of questions into expressions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml#ch2)中，你了解了布尔值的概念：一个真假值。你可以使用布尔值来构建*条件语句*，该语句根据表达式（称为*条件*）的值是`True`还是`False`来决定是否执行特定的代码块。条件就像一个是/否问题：你有超过五台服务器吗？服务器3是否在线？这个文件路径是否存在？要开始使用条件语句，让我们看看如何将这些问题转化为表达式。
- en: Building Expressions by Using Operators
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用运算符构建表达式
- en: 'You can write expressions by using *comparison operators*, which compare values.
    To use a comparison operator, you put it between two values, like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*比较运算符*来编写表达式，这些运算符用来比较值。使用比较运算符时，将它放在两个值之间，如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You use the `–eq` operator to determine whether two values are equal. Here’s
    a list of the most common comparison operators you’ll use:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`–eq`运算符来判断两个值是否相等。以下是你将使用的最常见比较运算符列表：
- en: '**-eq** Compares two values and returns `True` if they are equal.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**-eq** 比较两个值，如果它们相等，则返回`True`。'
- en: '**-ne** Compares two values and returns `True` if they are not equal.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**-ne** 比较两个值，如果它们不相等，则返回`True`。'
- en: '**-gt** Compares two values and returns `True` if the first is greater than
    the second.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**-gt** 比较两个值，如果第一个值大于第二个，则返回`True`。'
- en: '**-ge** Compares two values and returns `True` if the first is greater than
    or equal to the second.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**-ge** 比较两个值，如果第一个值大于或等于第二个，则返回`True`。'
- en: '**-lt** Compares two values and returns `True` if the first is less than the
    second.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**-lt** 比较两个值，如果第一个值小于第二个，则返回`True`。'
- en: '**-le** Compares two values and returns `True` if the first is less than or
    equal to the second.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**-le** 比较两个值，如果第一个值小于或等于第二个，则返回`True`。'
- en: '**-contains** Returns `True` if the second value is “in” the first. You can
    use this to determine whether a value is inside an array.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**-contains** 如果第二个值“在”第一个值中，则返回`True`。你可以使用它来确定一个值是否在数组中。'
- en: PowerShell offers more advanced comparison operators. I won’t go into them now,
    but I encourage you to read about them in the Microsoft documentation at [*https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators*](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators)*/*,
    or in the PowerShell help (see [Chapter 1](ch01.xhtml#ch1)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell提供了更高级的比较运算符。我现在不会详细介绍它们，但我建议你查阅微软文档中的[关于比较运算符](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators)*/*，或者在PowerShell帮助文档中查看（见[第1章](ch01.xhtml#ch1)）。
- en: You can use the preceding operators to compare variables and values. But an
    expression doesn’t have to be a comparison. Sometimes PowerShell commands can
    be used as conditions. In the previous example, you wanted to know whether a server
    was online. You can test to see whether a server can be pinged by using the `Test-Connection`
    cmdlet. Normally, the output of `Test-Connection` returns an object full of information,
    but by using the `Quiet` parameter, you can force the command to return a simple
    `True` or `False` and limit the test to a single attempt via the `Count` parameter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用前面提到的操作符来比较变量和值。但一个表达式不一定非得是比较。有时 PowerShell 命令本身就可以作为条件。在之前的例子中，你想知道服务器是否在线。你可以通过使用
    `Test-Connection` cmdlet 来测试服务器是否可以被 ping 通。通常，`Test-Connection` 的输出会返回一个充满信息的对象，但通过使用
    `Quiet` 参数，你可以强制命令仅返回简单的 `True` 或 `False`，并通过 `Count` 参数限制测试次数为一次。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you wanted to know whether the server was offline, you could use the `–not`
    operator to convert the expression to its opposite:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道服务器是否离线，可以使用 `–not` 操作符将表达式转换为其相反的值：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you’ve seen the basics of expressions, let’s look at the simplest conditional
    statement.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了表达式的基础，接下来我们来看最简单的条件语句。
- en: The if Statement
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if 语句
- en: 'The `if` statement is straightforward: if *X* is true, then do *Y*. That’s
    it!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句很简单：如果 *X* 为真，则执行 *Y*。就是这么简单！'
- en: To write an `if` statement, you begin with an `if` keyword followed by parentheses
    containing a condition. After the expression comes a code block, demarcated in
    curly brackets. PowerShell will execute that code block only when the expression
    evaluates to `True`. If the `if` expression evaluates to `False` or returns nothing
    at all, the code block is skipped. You can see the basic syntax of an `if/then`
    statement in [Listing 4-2](ch04.xhtml#ch4list2).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 `if` 语句时，你首先写 `if` 关键字，后面跟括号包含的条件。表达式之后是一个代码块，用大括号括起来。PowerShell 只有在表达式评估为
    `True` 时才会执行该代码块。如果 `if` 表达式评估为 `False` 或根本没有返回任何内容，则跳过该代码块。你可以在[清单 4-2](ch04.xhtml#ch4list2)中看到基本的
    `if/then` 语句的语法。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 4-2: The syntax of an if statement*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-2：if 语句的语法*'
- en: 'This example uses a bit of new syntax: the hash mark (`#`) signals a *comment*,
    which is text PowerShell will ignore. You can use comments to leave yourself,
    or anyone else reading your code, helpful notes and descriptions.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了一些新的语法：井号 (`#`) 表示 *注释*，这段文本 PowerShell 会忽略。你可以使用注释来给自己或任何阅读代码的人留下有用的备注和说明。
- en: Now let’s take a second look at the code in [Listing 4-1](ch04.xhtml#ch4list1)
    and see how to use an `if` statement to make sure you don’t try to access a server
    that’s not up. In the preceding section, you saw how `Test-Connection` can be
    used as an expression that returns `True` or `False`, so let’s wrap a `Test-Connection`
    command in an `if` statement and then use `Get-Content` in the following code
    block to avoid accessing a server that’s down. For now, you’ll change the code
    for only the first server, as in [Listing 4-3](ch04.xhtml#ch4list3).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再看一遍[清单 4-1](ch04.xhtml#ch4list1)中的代码，看看如何使用 `if` 语句确保你不会尝试访问一个无法连接的服务器。在上一节中，你已经看到如何将
    `Test-Connection` 用作返回 `True` 或 `False` 的表达式，所以接下来我们将把 `Test-Connection` 命令包装在一个
    `if` 语句中，并使用 `Get-Content` 来避免访问无法连接的服务器。暂时只更改第一个服务器的代码，如[清单 4-3](ch04.xhtml#ch4list3)所示。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 4-3: Using an if statement to selectively get server content*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-3：使用 if 语句选择性地获取服务器内容*'
- en: Because you have `Get-Content` in an `if` statement, you won’t run into any
    errors if you try to access a dead server; if the test fails, your script will
    know not to attempt to read the file. You’ll try to access the server only if
    you *already* know it’s up. But notice that this code handles only the case in
    which the condition is true. Often enough, you’ll want to have one behavior if
    a condition is true and another behavior if it’s false. In the next section, you’ll
    see how to specify behavior for a false condition by using the `else` statement.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将 `Get-Content` 放入了 `if` 语句中，因此如果你尝试访问一个死掉的服务器，也不会遇到任何错误；如果测试失败，脚本会知道不再尝试读取文件。只有在你*已经*知道服务器在线时，才会尝试访问它。但请注意，这段代码只处理条件为真的情况。通常情况下，你可能希望在条件为真时有一种行为，在条件为假时有另一种行为。接下来的部分，你将看到如何使用
    `else` 语句来指定假条件的行为。
- en: The else Statement
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: else 语句
- en: To add an alternate behavior to your `if` statement, you use the `else` keyword
    after the closing parenthesis of your `if` block, followed by another pair of
    curly brackets containing a code block. As shown in [Listing 4-4](ch04.xhtml#ch4list4),
    use an `else` statement to return an error to the console when the first server
    isn’t responding.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的 `if` 语句添加备用行为，你需要在 `if` 语句块的右括号后面使用 `else` 关键字，然后再加上一对大括号，里面放置一个代码块。如 [列表
    4-4](ch04.xhtml#ch4list4) 所示，当第一个服务器没有响应时，使用 `else` 语句将错误返回到控制台。
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 4-4: Using the else statement to run code if the condition is not
    true*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-4：使用 else 语句在条件不成立时运行代码*'
- en: The `if/else` statement works perfectly when you have two mutually exclusive
    situations. Here, the server is either online or it’s not; you need only two branches
    of code. Let’s look at how to handle more complex situations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有两个互斥的情况时，`if/else` 语句非常有效。在这里，服务器要么在线，要么不在线；你只需要两条代码分支。让我们来看一下如何处理更复杂的情况。
- en: The elseif Statement
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`elseif` 语句'
- en: 'The `else` statement works like a catchall: if the first `if` fails, do this
    no matter what. For a binary condition, such as a server being up or down, this
    works well. But sometimes you’ll need to account for even more variability. For
    example, let’s say you have a server that you know doesn’t have the file you want
    to get, and you’ve stored the name of that server in the variable `$problemServer`
    (add this line of code to the script on your own!). This means you need an extra
    check to see whether the server you’re dealing with is the problem server. You
    could account for this statement by using a nested `if`, as in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 语句就像一个兜底语句：如果第一个 `if` 语句失败，不管怎样都会执行。对于一个二元条件，比如服务器是否在线，这个方法很有效。但有时你需要考虑更多的变数。例如，假设你有一台服务器，你知道它没有你想要的文件，而且你已经把这台服务器的名称存储在变量
    `$problemServer` 中（这行代码需要你自己加到脚本中！）。这意味着你需要额外的检查，看看你正在处理的服务器是否是问题服务器。你可以通过使用嵌套的
    `if` 语句来考虑这个情况，如下面的代码所示：'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But a cleaner way to write this same logic is to use an `elseif` statement,
    which lets you add an extra condition to check before falling back on the code
    in the `else` block. The syntax of an `elseif` block is identical to that of an
    `if` block. So, to check for the problem server by using `elseif` statements,
    try the code in [Listing 4-5](ch04.xhtml#ch4list5).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，更简洁的方式是使用 `elseif` 语句，它允许你在回退到 `else` 代码块之前添加额外的条件检查。`elseif` 语句的语法与 `if`
    语句完全相同。因此，要使用 `elseif` 语句检查问题服务器，可以参考 [列表 4-5](ch04.xhtml#ch4list5) 中的代码。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 4-5: Using an elseif block*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-5：使用 elseif 语句块*'
- en: Notice that you haven’t just added an `elseif`; you’ve also changed the logic.
    Now you check to see whether the server is offline by first using the `–not` operator
    ❶. Then, once you’ve determined whether the server is online, you check to see
    whether it’s a problem server ❷. If it’s not, you use the `else` statement to
    run the default behavior—getting the file ❸. As you can see, there are multiple
    ways to structure code like this. What matters is that the code works and is readable
    to someone seeing it with fresh eyes, whether that’s a coworker reading it for
    the first time, or you looking back at a script you wrote a while ago.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你不仅仅是添加了一个 `elseif`；你还改变了逻辑。现在你通过先使用 `–not` 运算符 ❶ 来检查服务器是否离线。然后，一旦确定服务器是否在线，你就检查它是否是问题服务器
    ❷。如果不是，你就使用 `else` 语句执行默认行为——获取文件 ❸。如你所见，像这样的代码有多种结构方式。重要的是代码能够正常工作，并且对别人（无论是同事第一次阅读，还是你回头查看一段时间前写的脚本）来说具有可读性。
- en: 'You can chain together as many `elseif` statements as you like, which allows
    you to account for many scenarios. However, `elseif` statements are mutually exclusive:
    when one `elseif` evaluates to `True`, PowerShell will run only the code in its
    block and will not test the rest of the cases. In [Listing 4-5](ch04.xhtml#ch4list5),
    this didn’t cause any issues, as you needed to test only whether you were working
    with the problem server after you had checked that it was up, but it’s something
    to keep in mind moving forward.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要将多个 `elseif` 语句串联起来，这样就能处理更多的情况。然而，`elseif` 语句是互斥的：当某个 `elseif` 语句的条件为
    `True` 时，PowerShell 只会执行该语句块中的代码，而不会测试其他情况。在 [列表 4-5](ch04.xhtml#ch4list5) 中，这并没有引发问题，因为你只需要在检查服务器是否在线之后，测试是否是问题服务器，但这点在以后编写代码时需要牢记。
- en: The `if`, `else`, and `elseif` statements are great for handling simple yes/no
    questions. In the next section, you’ll learn how to handle slightly more complicated
    logic.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`、`else` 和 `elseif` 语句非常适合处理简单的是/否问题。在下一部分，你将学习如何处理稍微复杂一点的逻辑。'
- en: The switch Statement
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: switch 语句
- en: Let’s tweak our example a bit. Say you have five servers, and *each* server
    has the file in a different path. Based on what you know now, you’d need to write
    a separate `elseif` statement for each individual server. This would work, but
    there’s a cleaner method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微调整一下我们的例子。假设你有五台服务器，*每台*服务器的文件路径不同。根据你现在所知道的，你需要为每个服务器写一个单独的 `elseif` 语句。这样是可以的，但有一种更简洁的方法。
- en: 'Notice that now you’re working with a different kind of condition. Whereas
    before you wanted the answers to yes/no questions, here you want to know the specific
    value of one thing: Is the server `SRV1`? Is it `SRV2`? And so forth. If you were
    working with only one or two specific values, an `if` would do, but in this case,
    using a `switch` statement would be cleaner.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在你正在处理一种不同类型的条件。之前你想要的是对是/否问题的答案，而在这里，你想知道的是某个东西的具体值：服务器是 `SRV1` 吗？是 `SRV2`
    吗？以此类推。如果你只处理一个或两个特定值，使用 `if` 就可以，但在这种情况下，使用 `switch` 语句会更简洁。
- en: A `switch` statement allows you to execute various pieces of code based on a
    value. It consists of the `switch` keyword followed by an expression in parentheses.
    Inside the `switch` block are a series of statements that have a value, followed
    by a set of curly brackets containing a code block, and eventually a `default`
    block, as in [Listing 4-6](ch04.xhtml#ch4list6).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句允许你根据某个值执行不同的代码块。它由 `switch` 关键字和括号内的表达式组成。在 `switch` 块内有一系列的语句，每个语句后跟一个包含代码块的大括号，并最终有一个
    `default` 块，像[列表 4-6](ch04.xhtml#ch4list6)那样。'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 4-6: Template for a switch statement*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-6：switch 语句模板*'
- en: A `switch` statement can contain an (almost) unlimited number of values. If
    the expression evaluates to a value, the code inside that value’s block is executed.
    Critically, unlike with `elseif`, after one code block runs, PowerShell will continue
    to evaluate the other conditions unless otherwise specified. If none of the values
    match the evaluated value, PowerShell executes the code embedded under the `default`
    keyword. To force PowerShell to stop evaluating conditions in the `switch` statement,
    use the `break` keyword at the end of the code block, as in [Listing 4-7](ch04.xhtml#ch4list7).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句可以包含（几乎）无限多个值。如果表达式计算出一个值，则执行该值块内的代码。关键是，与 `elseif` 不同，PowerShell
    在执行完一个代码块后会继续评估其他条件，除非另有指定。如果没有任何值与计算出的值匹配，PowerShell 将执行 `default` 关键字下的嵌入代码。为了强制
    PowerShell 停止评估 `switch` 语句中的条件，可以在代码块末尾使用 `break` 关键字，像[列表 4-7](ch04.xhtml#ch4list7)那样。'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 4-7: Using the break keyword in a switch statement*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-7：在 switch 语句中使用 break 关键字*'
- en: The `break` keyword can be used to make your `switch` conditions mutually exclusive.
    Let’s go back to our example of five servers with the same file at different paths.
    You know that the server you’re working with can have only one value (it can’t
    be both `SRV1` and `SRV2`), so you have to use `break` statements. Your script
    should look something like [Listing 4-8](ch04.xhtml#ch4list8).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 关键字可以用来使你的 `switch` 条件互斥。让我们回到我们五台服务器的例子，这些服务器的文件路径不同。你知道你正在处理的服务器只能有一个值（它不可能同时是
    `SRV1` 和 `SRV2`），因此你必须使用 `break` 语句。你的脚本应该像[列表 4-8](ch04.xhtml#ch4list8)那样。'
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 4-8: Checking various servers by using a switch statement*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-8：使用 switch 语句检查不同的服务器*'
- en: 'You could rewrite this code by using only `if` and `elseif` statements (and
    I encourage you to try!). But however you choose to write it, you’ll have to repeat
    the same structure for each server in your list, meaning that your script is going
    to get pretty long—and just think about if you wanted to test 500 servers instead
    of 5\. In the next section, you’ll learn how to spare yourself that trouble by
    using one of the most fundamental control flow structures: the loop.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过仅使用 `if` 和 `elseif` 语句来重写这段代码（我鼓励你尝试一下！）。但无论你如何编写，它都会要求你为列表中的每台服务器重复相同的结构，这意味着你的脚本将变得相当长——而且如果你想要测试
    500 台服务器而不是 5 台服务器，想想看会是什么样子。在下一部分，你将学习如何通过使用最基本的控制流结构之一——循环，来避免这种麻烦。
- en: Using Loops
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用循环
- en: 'A good rule of thumb for computer work: Don’t Repeat Yourself (DRY). If you
    find yourself doing the same thing more than once, chances are there’s a way to
    automate it. The same is true of writing code: if you’re using the same lines
    of code over and over, there’s probably a better solution.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机工作中的一个好法则：不要重复自己（DRY）。如果你发现自己做同样的事情超过一次，很可能有办法自动化它。编写代码也是如此：如果你反复使用相同的代码行，很可能有更好的解决方案。
- en: One way to avoid repetitive code is to use loops. A *loop* lets you execute
    code repeatedly until a condition changes. The *stop condition* can be used to
    run a loop a set number of times, or until a boolean value has changed, or even
    to have a loop run infinitely. We call each run of the loop an *iteration*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 避免重复代码的一种方法是使用循环。*循环*允许你反复执行代码，直到条件发生变化。*停止条件*可以用于使循环执行设定次数，直到布尔值发生变化，甚至使循环无限执行。我们称每次运行循环为*一次迭代*。
- en: 'PowerShell offers five types of loops: `foreach`, `for`, `do/while`, `do/until`,
    and `while`. This section explains each type of loop, noting what makes it unique,
    and highlighting the best situations to use it.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 提供了五种类型的循环：`foreach`、`for`、`do/while`、`do/until`和`while`。本节解释了每种类型的循环，指出其独特之处，并强调了使用它的最佳场景。
- en: The foreach Loop
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`foreach`循环'
- en: We’ll start with the type of loop you’ll probably use the most in PowerShell,
    the `foreach` loop. A `foreach` loop goes through a list of objects and performs
    the same action for every object, ending when it’s finished with the last one.
    This list of objects is typically represented by an array. When you run a loop
    over a list of objects, we say you’re *iterating* over the list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从你在 PowerShell 中最常用的循环类型开始，即`foreach`循环。`foreach`循环遍历一个对象列表，并对每个对象执行相同的操作，直到完成最后一个对象为止。这个对象列表通常由数组表示。当你在对象列表上运行循环时，我们称之为*迭代*该列表。
- en: 'A `foreach` loop is useful when you have to perform the same task on a lot
    of different, but related, objects. Let’s go back to [Listing 4-1](ch04.xhtml#ch4list1)
    (reproduced here):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要对许多不同但相关的对象执行相同任务时，`foreach`循环非常有用。让我们回到[Listing 4-1](ch04.xhtml#ch4list1)（这里复述一下）：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You’re going to ignore all the fancy logic you added in the preceding section
    for now and put this into a `foreach` loop. But unlike other loops in PowerShell,
    the `foreach` loop can be used in three ways: as a `foreach` statement, as a `ForEach-Object`
    cmdlet, or as a `foreach()` method. Although each is similar to use, you should
    understand the differences. In the following three sections, you’ll rewrite [Listing
    4-1](ch04.xhtml#ch4list1) by using each type of `foreach` loop.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将忽略前面一节中添加的所有复杂逻辑，并将其放入`foreach`循环中。但与 PowerShell 中的其他循环不同，`foreach`循环有三种使用方式：作为`foreach`语句、作为`ForEach-Object`
    cmdlet，或作为`foreach()`方法。虽然每种方式的使用类似，但你应该了解它们的区别。在接下来的三个部分中，你将通过使用每种类型的`foreach`循环来重写[Listing
    4-1](ch04.xhtml#ch4list1)。
- en: The foreach Statement
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`foreach`语句'
- en: The first type of `foreach` you’ll look at is the `foreach` statement. [Listing
    4-9](ch04.xhtml#ch4list9) has the loop version of [Listing 4-1](ch04.xhtml#ch4list1).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要看的第一个`foreach`类型是`foreach`语句。[Listing 4-9](ch04.xhtml#ch4list9)展示了[Listing
    4-1](ch04.xhtml#ch4list1)的循环版本。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 4-9: Using a foreach statement*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-9: 使用`foreach`语句*'
- en: 'As you can see, the `foreach` statement is followed by parentheses that contain
    three elements, in order: a variable, the keyword `in`, and the object or array
    to iterate over. The variable you provide can have any name, but I recommend keeping
    the name as descriptive as possible.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`foreach`语句后面跟着包含三个元素的括号，顺序是：一个变量、关键字`in`，以及要迭代的对象或数组。你提供的变量可以有任何名称，但我建议尽可能保持名称具有描述性。
- en: 'As it moves through the list, PowerShell will *copy* the object it’s looking
    at into the variable. Note that because the variable is just a copy, you cannot
    directly change the item in the original list. To test this, try running the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当 PowerShell 遍历列表时，它会将正在查看的对象*复制*到变量中。请注意，由于变量只是副本，你不能直接更改原始列表中的项目。为了验证这一点，试试运行以下代码：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should get something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到像这样的结果：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Nothing changed! This is because you’re modifying only a copy of the original
    variable in the array. This is one of the downsides of using a `foreach` loop
    (of any kind). To directly modify the original contents of the list you’re looping
    through, you have to use one of the other loop types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 什么都没改变！这是因为你只是在修改数组中原始变量的副本。这是使用`foreach`循环（任何类型）的一大缺点。要直接修改你正在遍历的列表的原始内容，你必须使用其他类型的循环。
- en: The ForEach-Object cmdlet
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`ForEach-Object` cmdlet'
- en: Like the `foreach` statement, the `ForEach-Object` cmdlet can iterate over a
    set of objects and perform an action. But because `ForEach-Object` is a cmdlet,
    you have to pass that set of objects and the action to complete as parameters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `foreach` 语句一样，`ForEach-Object` cmdlet 可以遍历一组对象并执行某个操作。但因为 `ForEach-Object`
    是一个 cmdlet，所以你必须将那组对象和完成的操作作为参数传递。
- en: Check out [Listing 4-10](ch04.xhtml#ch4list10) to see how you’d do the same
    thing as [Listing 4-9](ch04.xhtml#ch4list9) with the `ForEach-Object` cmdlet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[清单 4-10](ch04.xhtml#ch4list10)，看看如何使用 `ForEach-Object` cmdlet 完成与[清单 4-9](ch04.xhtml#ch4list9)相同的操作。
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 4-10: Using the ForEach-Object cmdlet*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-10：使用 ForEach-Object cmdlet*'
- en: A bit is different here, so let’s walk through it. Notice that the `ForEach-Object`
    cmdlet takes an `InputObject` parameter. In this case, you’re using the `$servers`
    array, but you could use any object, such as a string or integer. In those cases,
    PowerShell will simply perform a single iteration. The cmdlet also accepts a `Process`
    parameter, which should be a scriptblock containing the code you’d like to run
    for each element inside the input object. (A *scriptblock* is a collection of
    statements that you pass into a cmdlet as a single unit.)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不同，让我们一起来看一下。注意，`ForEach-Object` cmdlet 接受一个 `InputObject` 参数。在这个例子中，你使用的是
    `$servers` 数组，但你可以使用任何对象，比如字符串或整数。在这些情况下，PowerShell 将只执行一次迭代。该 cmdlet 还接受一个 `Process`
    参数，该参数应该是一个包含你希望在每个输入对象内元素上运行的代码的脚本块。（*脚本块* 是你传递给 cmdlet 作为一个整体的语句集合。）
- en: 'You may have noticed something else strange about [Listing 4-10](ch04.xhtml#ch4list10).
    Instead of using a `$server` variable, as you did with the `foreach` statement,
    you use the syntax `$_`. This special syntax represents the current object in
    the pipeline. The major difference between the `foreach` statement and the `ForEach-Object`
    cmdlet is that the cmdlet accepts pipeline input. In practice, `ForEach-Object`
    is almost always used by passing in the `InputObject` parameter through the pipeline,
    like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到[清单 4-10](ch04.xhtml#ch4list10)中另一个奇怪的地方。与使用 `foreach` 语句时使用 `$server`
    变量不同，这里你使用了语法 `$_`。这种特殊语法表示管道中的当前对象。`foreach` 语句和 `ForEach-Object` cmdlet 之间的主要区别在于，cmdlet
    接受管道输入。实际上，`ForEach-Object` 几乎总是通过管道传入 `InputObject` 参数来使用，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `ForEach-Object` cmdlet can be a major time-saver.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForEach-Object` cmdlet 可以节省大量时间。'
- en: The foreach() Method
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: foreach() 方法
- en: The final type of `foreach` loop you’ll look at is the `foreach()` object method,
    introduced in PowerShell V4\. The `foreach()` method exists on all arrays in PowerShell,
    and can be used to accomplish the same thing as `foreach` and `ForEach-Object`.
    The `foreach()` method accepts a scriptblock parameter that should contain the
    code to execute each iteration. As with `ForEach-Object`, you use `$_` to capture
    the current iteration’s object, as you can see in [Listing 4-11](ch04.xhtml#ch4list11).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要查看的最后一种 `foreach` 循环是 PowerShell V4 引入的 `foreach()` 对象方法。`foreach()` 方法在
    PowerShell 中所有数组上都存在，可以用来完成与 `foreach` 和 `ForEach-Object` 相同的操作。`foreach()` 方法接受一个脚本块参数，该参数应该包含要执行每次迭代的代码。与
    `ForEach-Object` 一样，你可以使用 `$_` 来捕捉当前迭代的对象，正如你在[清单 4-11](ch04.xhtml#ch4list11)中看到的那样。
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 4-11: Using the foreach() method*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-11：使用 foreach() 方法*'
- en: The `foreach()` method is considerably faster than the other two, and noticeably
    so when processing large datasets. I recommend that you use this method over the
    other two wherever possible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach()` 方法比其他两种方法快得多，尤其在处理大型数据集时，差异尤为明显。我建议在可能的情况下优先使用这种方法。'
- en: A `foreach` loop is great when you want to perform a task on an object-by-object
    basis. But say you want to do something simpler. What if you wanted to execute
    a task a certain number of times?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 循环非常适合你希望对每个对象逐个执行任务的情况。但如果你想做一些更简单的事情呢？如果你希望执行某个任务一定次数该怎么办？'
- en: The for Loop
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for 循环
- en: To execute code a predetermined number of times, you use a `for` loop. [Listing
    4-12](ch04.xhtml#ch4list12) shows the syntax for a basic `for` loop.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行预定次数的代码，你可以使用 `for` 循环。[清单 4-12](ch04.xhtml#ch4list12) 显示了基本 `for` 循环的语法。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 4-12: A simple for loop*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-12：一个简单的 for 循环*'
- en: 'A `for` loop consists of four pieces: the *iteration variable* declaration
    ❶, the condition to continue running the loop ❷, the action to perform on the
    iteration variable after each successful loop ❸, and the code you want to execute
    ❹. In this example, you start the loop by initializing the variable `$i` to 0\.
    Then, you check to see whether `$i` is less than 10; if it is, you execute the
    code in the curly brackets, which prints `$ix`. After the code has executed, you
    increment `$i` by 1 ❸ and then check whether it is still smaller than 10 ❷. You
    repeat this process until `$i` is no longer less than 10, resulting in 10 iterations.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环由四个部分组成：*迭代变量*声明 ❶，继续执行循环的条件 ❷，每次成功循环后对迭代变量进行的操作 ❸，以及你想要执行的代码 ❹。在这个例子中，你从将变量
    `$i` 初始化为 0 开始。然后，你检查 `$i` 是否小于 10；如果是，就执行花括号中的代码，这会打印 `$ix`。代码执行后，你将 `$i` 增加
    1 ❸，并检查它是否仍然小于 10 ❷。你重复这个过程，直到 `$i` 不再小于 10，从而完成 10 次迭代。'
- en: 'A `for` loop can be used like this to execute a task any number of times—simply
    replace the condition ❷ to fit your needs. But the `for` loop has many more uses.
    One of the most powerful is manipulating the elements in an array. Earlier, you
    saw how you *couldn’t* use a `foreach` loop to change the elements in your array.
    Let’s try again, using a `for` loop:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环可以这样使用，执行某个任务任意次数——只需替换条件 ❷ 来满足你的需求。但 `for` 循环有更多的用途。最强大的用途之一是操作数组中的元素。之前，你已经看到如何*不能*使用
    `foreach` 循环来修改数组中的元素。让我们再试一次，使用 `for` 循环：'
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Try running this script. The server names should change.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个脚本。服务器名称应该会发生变化。
- en: 'A `for` loop is also particularly useful when performing an action that requires
    multiple elements in the array. For instance, let’s say that your `$servers` array
    is arranged in a particular order, and you want to know which server comes after
    which. To do this, you could use a `for` loop:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环在执行需要多个数组元素的操作时也特别有用。例如，假设你的 `$servers` 数组按特定顺序排列，你想知道哪个服务器在另一个服务器之后。为此，你可以使用
    `for` 循环：'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that this time you declare the iteration variable to start at 1 ❶. This
    ensures that you don’t try to access the server that comes before the first one,
    which would give you an error.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次你将迭代变量声明为从 1 开始 ❶。这确保你不会尝试访问第一个服务器之前的服务器，否则会导致错误。
- en: As you’ll see over the course of this book, the `for` loop is a powerful tool
    that has many uses outside the simple examples provided here. For now, let’s move
    on to the next type of loop.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本书中看到的那样，`for` 循环是一个强大的工具，除了这里提供的简单示例外，它还有许多其他用途。现在，让我们继续讨论下一种类型的循环。
- en: The while Loop
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: 'The `while` loop is the simplest loop: while a condition is true, do something.
    To get a sense of the `while` loop syntax, let’s rewrite the `for` loop from [Listing
    4-12](ch04.xhtml#ch4list12) as shown in [Listing 4-13](ch04.xhtml#ch4list13).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环是最简单的循环：只要条件为真，就执行某个操作。为了理解 `while` 循环的语法，让我们将 [Listing 4-12](ch04.xhtml#ch4list12)
    中的 `for` 循环重写为 [Listing 4-13](ch04.xhtml#ch4list13) 所示。'
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 4-13: A simple counter using a while loop*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-13: 使用 while 循环的简单计数器*'
- en: As you can see, to use a `while` loop, just place the condition you want to
    evaluate inside the parentheses, and the code you want to run inside the curly
    brackets.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，要使用 `while` 循环，只需将你想评估的条件放入括号内，将你想运行的代码放入花括号中。
- en: The `while` loop is best used when the number of iterations for the loop is
    *not* predetermined. Say you have a Windows server (again called `$problemServer`)
    that’s frequently going down. But there’s a file you need on it, and you don’t
    want to sit there testing the server every few minutes to get it. You can use
    a `while` loop to automate this process for you, as in [Listing 4-14](ch04.xhtml#ch4list14).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环最适合用于循环次数*不*预先确定的情况。例如，假设你有一台频繁宕机的 Windows 服务器（再次称为 `$problemServer`）。但你需要从中获取一个文件，而不想每隔几分钟就去测试服务器是否正常。你可以使用
    `while` 循环来自动化这个过程，如 [Listing 4-14](ch04.xhtml#ch4list14) 所示。'
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 4-14: Using a while loop to deal with a problematic server*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-14: 使用 while 循环处理有问题的服务器*'
- en: 'By using a `while` loop instead of an `if`, you can repeatedly check to see
    whether the service is up. Then, once you get the content you need, you can `break`
    out of the loop to make sure you don’t continue to check the server. The `break`
    keyword can be used in any loop to stop the loop from running. This is especially
    important when using one of the most common `while` loops: the `while($true)`
    loop. By using `$true` as your condition, your `while` loop will run forever unless
    you stop it with a `break` or keyboard input.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `while` 循环代替 `if`，你可以反复检查服务是否正常运行。然后，一旦获取到所需的内容，你可以使用 `break` 跳出循环，确保不继续检查服务器。`break`
    关键字可以在任何循环中使用，用来停止循环的执行。这在使用最常见的 `while` 循环之一时尤其重要：`while($true)` 循环。通过使用 `$true`
    作为条件，除非你通过 `break` 或键盘输入停止它，否则 `while` 循环会永远运行下去。
- en: The do/while and do/until Loops
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`do/while` 和 `do/until` 循环'
- en: 'Similar to the `while` loop are the `do/while` and `do/until` loops. The two
    are essentially inverses: the `do/while` loop does something *while* a condition
    is true, and the `do/until` loop does something *until* a condition is true.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `while` 循环类似，`do/while` 和 `do/until` 循环也是非常相似的。二者本质上是反向的：`do/while` 循环在条件为真时执行某个操作，而
    `do/until` 循环则在条件为真时停止执行某个操作。
- en: 'An empty `do/while` loop looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的 `do/while` 循环看起来像这样：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the `do` code comes before the `while` condition. The major
    difference between a `while` loop and a `do/while` loop is that a `do/while` loop
    will execute the code *before* the condition is evaluated.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`do` 代码位于 `while` 条件之前。`while` 循环和 `do/while` 循环之间的主要区别在于，`do/while` 循环会在条件评估之前先执行代码。
- en: 'This can be useful in certain situations, particularly when you are continually
    receiving input from a source and want to evaluate it. For example, say you want
    to prompt the user to ask them for the best programming language. To do so, you
    could use the code in [Listing 4-15](ch04.xhtml#ch4list15). Here, you’ll use the
    `do/until` loop:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可能非常有用，特别是当你不断从一个来源接收输入并想要对其进行评估时。例如，假设你想提示用户询问他们最喜欢的编程语言。为了做到这一点，你可以使用
    [Listing 4-15](ch04.xhtml#ch4list15) 中的代码。在这里，你将使用 `do/until` 循环：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 4-15: Using a do/until loop*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-15: 使用 do/until 循环*'
- en: The `do/while` and `do/until` loops are *very* similar. Often this means you
    can accomplish the same thing using each loop simply by inverting the condition,
    as you’ve done here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`do/while` 和 `do/until` 循环非常相似。通常，这意味着你可以通过简单地反转条件，使用每种循环来完成相同的事情，正如你在这里所做的那样。'
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered a lot in this chapter. You learned about control flow, and how to
    use conditional logic to introduce alternative paths through your code. You saw
    various types of control flow statements, including the `if` statement, `switch`
    statement, and `foreach`, `for`, and `while` loops. Finally, you gained some hands-on
    experience, using PowerShell to check whether servers are up and to access files
    on them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讲了很多内容。你学习了控制流，了解了如何使用条件逻辑在代码中引入不同的路径。你看到了各种类型的控制流语句，包括 `if` 语句、`switch`
    语句，以及 `foreach`、`for` 和 `while` 循环。最后，你通过使用 PowerShell 检查服务器是否正常运行并访问服务器上的文件，获得了一些实践经验。
- en: You can use conditional logic to handle some errors, but chances are you’ll
    miss something. In [Chapter 5](ch05.xhtml#ch5), you’ll take a closer look at errors
    and some techniques you can use to handle them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用条件逻辑来处理一些错误，但很可能会遗漏一些内容。在 [第 5 章](ch05.xhtml#ch5) 中，你将更深入地了解错误以及一些处理错误的技巧。
