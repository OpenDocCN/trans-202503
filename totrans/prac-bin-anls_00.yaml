- en: INTRODUCTION
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vast majority of computer programs are written in high-level languages like
    C or C++, which computers can’t run directly. Before you can use these programs,
    you must first compile them into *binary executables* containing machine code
    that the computer can run. But how do you know that the compiled program has the
    same semantics as the high-level source? The unnerving answer is that *you don’t*!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: There’s a big semantic gap between high-level languages and binary machine code
    that not many people know how to bridge. Even most programmers have limited knowledge
    of how their programs really work at the lowest level, and they simply trust that
    the compiled program is true to their intentions. As a result, many compiler bugs,
    subtle implementation errors, binary-level backdoors, and malicious parasites
    can go unnoticed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: To make matters worse, there are countless binary programs and libraries—in
    industry, at banks, in embedded systems—for which the source code is long lost
    or proprietary. That means it’s impossible to patch those programs and libraries
    or assess their security at the source level using conventional methods. This
    is a real problem even for major software companies, as evidenced by Microsoft’s
    recent release of a painstakingly handcrafted binary patch for a buffer overflow
    in its Equation Editor program, which is part of the Microsoft Office suite.^([1](footnote.xhtml#ch00fn_1))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you’ll learn how to analyze and even modify programs at the binary
    level. Whether you’re a hacker, a security researcher, a malware analyst, a programmer,
    or simply interested, these techniques will give you more control over and insight
    into the binary programs you create and use every day.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What Is Binary Analysis, and Why Do You Need It?
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Binary analysis* is the science and art of analyzing the properties of binary
    computer programs, called *binaries*, and the machine code and data they contain.
    Briefly put, the goal of all binary analysis is to figure out (and possibly modify)
    the true properties of binary programs—in other words, what they *really* do as
    opposed to what we think they should do.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Many people associate binary analysis with reverse engineering and disassembly,
    and they’re at least partially correct. Disassembly is an important first step
    in many forms of binary analysis, and reverse engineering is a common application
    of binary analysis and is often the only way to document the behavior of proprietary
    software or malware. However, the field of binary analysis encompasses much more
    than this.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly speaking, you can divide binary analysis techniques into two classes,
    or a combination of these:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '**Static analysis** *Static analysis* techniques reason about a binary without
    running it. This approach has several advantages: you can potentially analyze
    the whole binary in one go, and you don’t need a CPU that can run the binary.
    For instance, you can statically analyze an ARM binary on an x86 machine. The
    downside is that static analysis has no knowledge of the binary’s runtime state,
    which can make the analysis very challenging.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic analysis** In contrast, *dynamic analysis* runs the binary and analyzes
    it as it executes. This approach is often simpler than static analysis because
    you have full knowledge of the entire runtime state, including the values of variables
    and the outcomes of conditional branches. However, you see only the executed code,
    so the analysis may miss interesting parts of the program.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Both static and dynamic analyses have their advantages and disadvantages, and
    you’ll learn techniques from both schools of thought in this book. In addition
    to passive binary analysis, you’ll also learn *binary instrumentation* techniques
    that you can use to modify binary programs without needing source. Binary instrumentation
    relies on analysis techniques like disassembly, and at the same time it can be
    used to aid binary analysis. Because of this symbiotic relationship between binary
    analysis and instrumentation techniques, this books covers both.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: I already mentioned that you can use binary analysis to document or pentest
    programs for which you don’t have source. But even if source is available, binary
    analysis can be useful to find subtle bugs that manifest themselves more clearly
    at the binary level than at the source level. Many binary analysis techniques
    are also useful for advanced debugging. This book covers binary analysis techniques
    that you can use in all these scenarios and more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: What Makes Binary Analysis Challenging?
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Binary analysis is challenging and much more difficult than equivalent analysis
    at the source code level. In fact, many binary analysis tasks are fundamentally
    undecidable, meaning that it’s impossible to build an analysis engine for these
    problems that always returns a correct result! To give you an idea of the challenges
    to expect, here is a list of some of the things that make binary analysis difficult.
    Unfortunately, the list is far from exhaustive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**No symbolic information** When we write source code in a high-level language
    like C or C++, we give meaningful names to constructs such as variables, functions,
    and classes. We call these names *symbolic information*, or *symbols* for short.
    Good naming conventions make the source code much easier to understand, but they
    have no real relevance at the binary level. As a result, binaries are often stripped
    of symbols, making it much harder to understand the code.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**No type information** Another feature of high-level programs is that they
    revolve around variables with well-defined types, such as `int`, `float`, or `string`,
    as well as more complex data structures like `struct` types. In contrast, at the
    binary level, types are never explicitly stated, making the purpose and structure
    of data hard to infer.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**No high-level abstractions** Modern programs are compartmentalized into classes
    and functions, but compilers throw away these high-level constructs. That means
    binaries appear as huge blobs of code and data, rather than well-structured programs,
    and restoring the high-level structure is complex and error-prone.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Mixed code and data** Binaries can (and do) contain data fragments mixed
    in with the executable code.^([2](footnote.xhtml#ch00fn_2)) This makes it easy
    to accidentally interpret data as code, or vice versa, leading to incorrect results.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Location-dependent code and data** Because binaries are not designed to be
    modified, even adding a single machine instruction can cause problems as it shifts
    other code around, invalidating memory addresses and references from elsewhere
    in the code. As a result, any kind of code or data modification is extremely challenging
    and prone to breaking the binary.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: As a result of these challenges, we often have to live with imprecise analysis
    results in practice. An important part of binary analysis is coming up with creative
    ways to build usable tools despite analysis errors!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Who Should Read This Book?
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book’s target audience includes security engineers, academic security researchers,
    hackers and pentesters, reverse engineers, malware analysts, and computer science
    students interested in binary analysis. But really, I’ve tried to make this book
    accessible for anyone interested in binary analysis.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, because this book covers advanced topics, some prior knowledge of
    programming and computer systems is required. To get the most out of this book,
    you should have the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: • A reasonable level of comfort programming in C and C++.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: • A basic working knowledge of operating system internals (what a process is,
    what virtual memory is, and so on).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: • Knowledge of how to use a Linux shell (preferably `bash`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: • A working knowledge of x86/x86-64 assembly. If you don’t know any assembly
    yet, make sure to read [Appendix A](appa.xhtml) first!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve never programmed before or you don’t like delving into the low-level
    details of computer systems, this book is probably not for you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: What’s in This Book?
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary goal of this book is to make you a well-rounded binary analyst who’s
    familiar with all the major topics in the field, including both basic topics and
    advanced topics like binary instrumentation, taint analysis, and symbolic execution.
    This book does *not* presume to be a comprehensive resource, as the binary analysis
    field and tools change so quickly that a comprehensive book would likely be outdated
    within a year. Instead, the goal is to make you knowledgeable enough on all important
    topics so that you’re well prepared to learn more independently.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, this book doesn’t dive into all the intricacies of reverse engineering
    x86 and x86-64 code (though [Appendix A](appa.xhtml) covers the basics) or analyzing
    malware on those platforms. There are many dedicated books on those subjects already,
    and it makes no sense to duplicate their contents here. For a list of books dedicated
    to manual reverse engineering and malware analysis, refer to [Appendix D](appd.xhtml).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: This book is divided into four parts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**[Part I: Binary Formats](part1.xhtml)** introduces you to binary formats,
    which are crucial to understanding the rest of this book. If you’re already familiar
    with the ELF and PE binary formats and `libbfd`, you can safely skip one or more
    chapters in this part.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1: Anatomy of a Binary](ch01.xhtml#ch01)** provides a general introduction
    to the anatomy of binary programs.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2: The ELF Format](ch02.xhtml#ch02)** introduces you to the ELF
    binary format used on Linux.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3: The PE Format: A Brief Introduction](ch03.xhtml#ch03)** contains
    a brief introduction on PE, the binary format used on Windows.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4: Building a Binary Loader Using libbfd](ch04.xhtml#ch04)** shows
    you how to parse binaries with `libbfd` and builds a binary loader used in the
    rest of this book.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**[Part II: Binary Analysis Fundamentals](part2.xhtml)** contains fundamental
    binary analysis techniques.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5: Basic Binary Analysis in Linux](ch05.xhtml#ch05)** introduces
    you to basic binary analysis tools for Linux.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6: Disassembly and Binary Analysis Fundamentals](ch06.xhtml#ch06)**
    covers basic disassembly techniques and fundamental analysis patterns.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7: Simple Code Injection Techniques for ELF](ch07.xhtml#ch07)**
    is your first taste of how to modify ELF binaries with techniques like parasitic
    code injection and hex editing.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**[Part III: Advanced Binary Analysis](part3.xhtml)** is all about advanced
    binary analysis techniques.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8: Customizing Disassembly](ch08.xhtml#ch08)** shows you how to
    build your own custom disassembly tools with Capstone.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9: Binary Instrumentation](ch09.xhtml#ch09)** is about modifying
    binaries with Pin, a full-fledged binary instrumentation platform.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10: Principles of Dynamic Taint Analysis](ch10.xhtml#ch10)** introduces
    you to the principles of *dynamic taint analysis*, a state-of-the-art binary analysis
    technique that allows you to track data flows in programs.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第10章：动态污点分析原理](ch10.xhtml#ch10)** 向你介绍了*动态污点分析*的原理，这是一种最先进的二进制分析技术，能够跟踪程序中的数据流。'
- en: '**[Chapter 11: Practical Dynamic Taint Analysis with libdft](ch11.xhtml#ch11)**
    teaches you to build your own dynamic taint analysis tools with `libdft`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第11章：使用libdft进行实用动态污点分析](ch11.xhtml#ch11)** 教你如何使用`libdft`构建自己的动态污点分析工具。'
- en: '**[Chapter 12: Principles of Symbolic Execution](ch12.xhtml#ch12)** is dedicated
    to *symbolic execution*, another advanced technique with which you can automatically
    reason about complex program properties.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第12章：符号执行原理](ch12.xhtml#ch12)** 专门讲解*符号执行*，这是一种先进技术，可以帮助你自动推理复杂的程序属性。'
- en: '**[Chapter 13: Practical Symbolic Execution with Triton](ch13.xhtml#ch13)**
    shows you how to build practical symbolic execution tools with Triton.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第13章：使用Triton进行实用符号执行](ch13.xhtml#ch13)** 向你展示如何使用Triton构建实用的符号执行工具。'
- en: '**[Part IV: Appendixes](part4.xhtml)** includes resources that you may find
    useful.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第四部分：附录](part4.xhtml)** 包含一些你可能会发现有用的资源。'
- en: '**[Appendix A: A Crash Course on x86 Assembly](appa.xhtml)** contains a brief
    introduction to x86 assembly language for those readers not yet familiar with
    it.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录A：x86汇编语言速成课程](appa.xhtml)** 为尚未熟悉x86汇编语言的读者提供了简短的入门介绍。'
- en: '**[Appendix B: Implementing PT_NOTE Overwriting Using libelf](appb.xhtml)**
    provides implementation details on the `elfinject` tool used in [Chapter 7](ch07.xhtml#ch07)
    and serves as an introduction to `libelf`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录B：使用libelf实现PT_NOTE覆盖](appb.xhtml)** 提供了`elfinject`工具的实现细节，该工具在[第7章](ch07.xhtml#ch07)中使用，并作为`libelf`的入门介绍。'
- en: '**[Appendix C: List of Binary Analysis Tools](appc.xhtml)** contains a list
    of binary analysis tools you can use.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录C：二进制分析工具列表](appc.xhtml)** 包含你可以使用的二进制分析工具列表。'
- en: '**[Appendix D: Further Reading](appd.xhtml)** contains a list of references,
    articles, and books related to the topics discussed in this book.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**[附录D：进一步阅读](appd.xhtml)** 包含与本书讨论的主题相关的参考文献、文章和书籍列表。'
- en: How to Use This Book
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用本书
- en: To help you get the most out of this book, let’s briefly go over the conventions
    with respect to code examples, assembly syntax, and development platform.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你最大限度地利用本书，让我们简要回顾一下关于代码示例、汇编语法和开发平台的约定。
- en: '*Instruction Set Architecture*'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*指令集架构*'
- en: While you can generalize many techniques in this book to other architectures,
    I’ll focus the practical examples on the Intel x86 *Instruction Set Architecture
    (ISA)* and its 64-bit version x86-64 (x64 for short). I’ll refer to both the x86
    and x64 ISA simply as “x86 ISA.” Typically, the examples will deal with x64 code
    unless specified otherwise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以将本书中的许多技术推广到其他架构，但我将把实际示例集中在Intel x86 *指令集架构（ISA）*及其64位版本x86-64（简称x64）上。我将把x86和x64
    ISA统称为“x86 ISA”。通常，示例将处理x64代码，除非另有说明。
- en: The x86 ISA is interesting because it’s incredibly common both in the consumer
    market, especially in desktop and laptop computers, and in binary analysis research
    (in part because of its popularity in end user machines). As a result, many binary
    analysis frameworks are targeted at x86.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: x86 ISA很有趣，因为它在消费市场中非常常见，尤其是在桌面和笔记本电脑中，并且在二进制分析研究中也有广泛应用（部分原因是它在终端用户机器中的普及）。因此，许多二进制分析框架都是针对x86的。
- en: In addition, the complexity of the x86 ISA allows you to learn about some binary
    analysis challenges that don’t occur on simpler architectures. The x86 architecture
    has a long history of backward compatibility (dating back to 1978), leading to
    a very dense instruction set, in the sense that the vast majority of possible
    byte values represent a valid opcode. This exacerbates the code versus data problem,
    making it less obvious to disassemblers that they’ve mistakenly interpreted data
    as code. Moreover, the instruction set is variable length and allows unaligned
    memory accesses for all valid word sizes. Thus, x86 allows unique complex binary
    constructs, such as (partially) overlapping and misaligned instructions. In other
    words, once you’ve learned to deal with an instruction set as complex as x86,
    other instruction sets (such as ARM) will come naturally!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '*Assembly Syntax*'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As explained in [Appendix A](appa.xhtml), there are two popular syntax formats
    used to represent x86 machine instructions: *Intel syntax* and *AT&T syntax*.
    Here, I’ll use Intel syntax because it’s less verbose. In Intel syntax, moving
    a constant into the `edi` register looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the destination operand (`edi`) comes first. If you’re unsure about
    the differences between AT&T and Intel syntax, refer to [Appendix A](appa.xhtml)
    for an outline of the major characteristics of each style.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '*Binary Format and Development Platform*'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I’ve developed all of the code samples that accompany this book on Ubuntu Linux,
    all in C/C++ except for a small number of samples written in Python. This is because
    many popular binary analysis libraries are targeted mainly at Linux and have convenient
    C/C++ or Python APIs. However, all of the techniques and most of the libraries
    and tools used in this book also apply to Windows, so if Windows is your platform
    of choice, you should have little trouble transferring what you’ve learned to
    it. In terms of binary format, this book focuses mainly on ELF binaries, the default
    on Linux platforms, though many of the tools also support Windows PE binaries.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '*Code Samples and Virtual Machine*'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each chapter in this book comes with several code samples, and there’s a preconfigured
    virtual machine (VM) that accompanies this book and includes all of the samples.
    The VM runs the popular Linux distribution Ubuntu 16.04 and has all of the discussed
    open source binary analysis tools installed. You can use the VM to experiment
    with the code samples and solve the exercises at the end of each chapter. The
    VM is available on the book’s website, which you’ll find at *[https://practicalbinaryanalysis.com](https://practicalbinaryanalysis.com)*
    or *[https://nostarch.com/binaryanalysis/](https://nostarch.com/binaryanalysis/)*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: On the book’s website, you’ll also find an archive containing just the source
    code for the samples and exercises. You can download this if you don’t want to
    download the entire VM, but do keep in mind that some of the required binary analysis
    frameworks require complex setup that you’ll have to do on your own if you opt
    not to use the VM.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在书籍的官方网站上，您还会找到一个包含所有示例和练习源代码的存档。如果您不想下载整个虚拟机，可以下载此存档，但请记住，如果您选择不使用虚拟机，一些所需的二进制分析框架需要复杂的设置，您需要自行完成。
- en: To use the VM, you will need virtualization software. The VM is meant to be
    used with VirtualBox, which you can download for free from *[https://www.virtualbox.org/](https://www.virtualbox.org/)*.
    VirtualBox is available for all popular operating systems, including Windows,
    Linux, and macOS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用虚拟机（VM），您需要虚拟化软件。虚拟机是与 VirtualBox 一起使用的，您可以从*[https://www.virtualbox.org/](https://www.virtualbox.org/)*免费下载
    VirtualBox。VirtualBox 支持所有流行的操作系统，包括 Windows、Linux 和 macOS。
- en: After installing VirtualBox, simply run it, navigate to the **File** → **Import
    Appliance** option, and select the virtual machine you downloaded from the book’s
    website. After it’s been added, start it up by clicking the green arrow marked
    **Start** in the main VirtualBox window. After the VM is done booting, you can
    log in using “binary” as the username and password. Then, open a terminal using
    the keyboard shortcut CTRL-ALT-T, and you’ll be ready to follow along with the
    book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 VirtualBox 后，只需运行它，点击 **文件** → **导入虚拟设备** 选项，选择您从书籍网站下载的虚拟机。添加后，点击主 VirtualBox
    窗口中标有 **启动** 的绿色箭头来启动虚拟机。虚拟机启动完成后，您可以使用“binary”作为用户名和密码进行登录。然后，使用键盘快捷键 CTRL-ALT-T
    打开终端，您就可以开始跟随书中的内容操作了。
- en: In the directory *~/code*, you’ll find one subdirectory per chapter, which contains
    all code samples and other relevant files for that chapter. For instance, you’ll
    find all code for [Chapter 1](ch01.xhtml#ch01) in the directory *~/code/chapter1*.
    There’s also a directory called *~/code/inc* that contains common code used by
    programs in multiple chapters. I use the *.cc* extension for C++ source files,
    *.c* for plain C files, *.h* for header files, and *.py* for Python scripts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录 *~/code* 中，您会找到每个章节的一个子目录，其中包含该章节的所有代码示例和其他相关文件。例如，您将在 *~/code/chapter1*
    目录中找到 [第 1 章](ch01.xhtml#ch01)的所有代码。还有一个名为 *~/code/inc* 的目录，包含多个章节中使用的公共代码。我为
    C++ 源文件使用 *.cc* 扩展名，为 C 源文件使用 *.c* 扩展名，为头文件使用 *.h* 扩展名，为 Python 脚本使用 *.py* 扩展名。
- en: To build all the example programs for a given chapter, simply open a terminal,
    navigate to the directory for the chapter, and then execute the `make` command
    to build everything in the directory. This works in all cases except those where
    I explicitly mention other commands to build an example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建给定章节的所有示例程序，只需打开终端，导航到该章节的目录，然后执行 `make` 命令来构建目录中的所有内容。除了我明确提到其他构建命令的情况，这种方法在所有情况下都适用。
- en: Most of the important code samples are discussed in detail in their corresponding
    chapters. If a code listing discussed in the book is available as a source file
    on the VM, its filename is shown before the listing, as follows.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数重要的代码示例在其对应的章节中都有详细讨论。如果书中讨论的代码清单在虚拟机上有对应的源文件，其文件名会显示在清单之前，如下所示。
- en: '***filename.c***'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '***filename.c***'
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This listing caption indicates that you’ll find the code shown in the listing
    in the file *filename.c*. Unless otherwise noted, you’ll find the file under its
    listed filename in the directory for the chapter in which the example appears.
    You’ll also encounter listings with captions that aren’t filenames, meaning that
    these are just examples used in the book without a corresponding copy on the VM.
    Short code listings that don’t have a copy on the VM may not have captions, such
    as in the assembly syntax example shown earlier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该清单标题表明，您可以在文件 *filename.c* 中找到清单所示的代码。除非另有说明，您将会在该章节的目录下找到文件，文件名与清单中的一致。您还会遇到没有文件名的清单标题，这意味着这些示例只是书中的示例，没有对应的虚拟机副本。没有虚拟机副本的简短代码清单可能没有标题，例如之前显示的汇编语法示例。
- en: 'Listings that show shell commands and their output use the `$` symbol to indicate
    the command prompt, and they use bold font to indicate lines containing user input.
    These lines are commands that you can try on the virtual machine, while subsequent
    lines that are not prefixed with a prompt or printed in bold represent command
    output. For instance, here’s an overview of the *~/code* directory on the VM:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 shell 命令及其输出的列表使用 `$` 符号来表示命令提示符，并且使用粗体字体来标识包含用户输入的行。这些行是你可以在虚拟机上尝试的命令，而后续未带提示符或未加粗的行则表示命令输出。例如，下面是虚拟机上*~/code*目录的概览：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that I’ll sometimes edit command output to improve readability, so the
    output you see on the VM may differ slightly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我有时会编辑命令输出以提高可读性，因此你在虚拟机上看到的输出可能会略有不同。
- en: '*Exercises*'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*练习*'
- en: At the end of each chapter, you’ll find a few exercises and challenges to consolidate
    the skills you learned in that chapter. Some of the exercises should be relatively
    straightforward to solve using the skills you learned in the chapter, while others
    may require more effort and some independent research.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在每章的结尾，你会找到一些练习和挑战，帮助巩固你在该章节中学到的技能。部分练习应该比较容易用你在章节中学到的技能解决，而其他一些则可能需要更多的努力和独立的研究。
